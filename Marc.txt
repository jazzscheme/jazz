- Comment obtenir la platform au runtime
- Would it be difficult to support compiling define-macro? It forces me to always seperate the code into 2 files when
  I want the expander to be compiled and it is very annoying: possible by using the underlying code used by define-macro
- Peut-on passer un (macro-absent) explicitement? NON
- Pourquoi le #\underscore fait-il une erreur et lui seul??? c'est un bug Gambit ou la notation #\u ne verifie pas la suite
- Is there an equiv to find-symbol in Gambit : ##find-interned-symbol
- Now that we are starting to dispatch on native Scheme types, we will really need a fast class-of
- When it's time to compile Jazz code, I'll clearly have correct code with circular symbol dependencies... We have to
  have a solution even if only to be able to load a binary file with suppressed warnings...
- Maintenant qu'on a une convergence des processeurs vers Intel a-t'il considere remettre une partie de code en assembleur?
- Comment ca marche? Je lit une string d'un fichier ouvert en UTF-8 et le repl ne peut l'afficher?
- We need a solution to exceptions that doesn't break Gambit's ability to debug. Seems like with-exception-* all unwind the
  stack before knowing we do not handle it and reraise... : fixed by not using with-exception-* at all which is not the right
  concept for us!
- Is there a way to add Jazz's 2 initialized and destroyed bits to Jazz objects without paying a penalty : not really
- Rename meroon with jazz :) : done!
- It seems that the construct that works for the loader doesn't work for the compiler :
  (parameterize ((current-readtable jazz.jazz-readtable))
    (compile-file-to src bindir "" cc-flags ld-flags))
(set! ##main-readtable ...)
- On ne peut faire ctrl-c quand on a un msg-loop surement car on capture les events a gambit? Y aurait-il une solution
  simple pour laisser le ctrl-c actif?
  - regarder si en faisant un GetMessage *juste* pour notre fenetre ca ne debloquerais pas le ctrl-c de la console
- Would be very nice to have a solution to Gambit's FFI not converting integers to real automatically
  ##fixnum->flonum qui test aussi que c'est bien un fixnum
- Serait pratique de pouvoir dire a l'option expansion de compile-file et gsc de ne pas generer de .o1
- Peut on utiliser statprof sur du code compile? oui mais bien mieux si -debug
- Le statprof est-il vraiment fiable (i.e. rejoin t-il tout le code?) : oui
- Tous les outils de Gambit sont totalement inutiles en presence de macros#!$!@#$ Y-aurais t'il moyen de faire qq chose?
  : define-macro recoit une version 100% strippe des infos de positionnement alors
    que ##define-syntax lui recoit l'info. Gambit etant la syntaxe de ##define-syntax pour permettre une lambda
    de transformation...
- Si besoin est, peut on accelerer le heartbeat de Gambit? oui mais deja au max qui est obtenu en passant 0 a la fonction qui le set
- Envoyer nos chg Gambit a marc comme patch Mercurial
- real-time resolution on windows? - uses C library function that do not use windows performance counters
- (##define-macro (macro-subtype-pair) 1) ??? historical??? : a pair IS a subtype but with a priviledge direct type
* Does Marc have any opinion on the very serious problem of Jazz user code capturing generated code like in
  (definition (f)
  (let ((begin 2))
    (if #t
        3
      5)))
  that gets expanded into
  (define test.f
  (lambda ()
    (let ((begin 2))
      (if #t
          3
        (begin 5)))))
- Is it ok to use the default hash function for hashing Shortcuts? Also, do I understand correctly that a custom hash function
  should return a fixnum? and if yes are there any fn to add 2 fixnums and return a fixnum? - NO
- C'est quoi l'idee en arriere de ##source1-marker et ##source2-marker? - doesn't remember ;)
- Es-ce que ##define-syntax est suppose marche en compile? - oui maintenant
- Si besoin est que j'implemente le slayer dans Gambit, peut-on batir un stack trace en C relativement facilement et de bonne
  qualite? Aussi, es-ce que Marc connaitrais un equivalent de SetUnhandledExceptionFilter en C portable ou unix ou mac...
  : Marc pense que oui avec les handlers de signaux...
- Marc, coup de main pour class-of en C
* Y a t'il une facon du crash handler d'obtenir la continuation courante? Pourrait meme de la invoquer du code Scheme compile pour
  l'affichage du stack!?
- Bug super etrange d'ajouter un include dans runtime.scm - le header fesait des declare toplevel et autres trucs ...
- En C __gc_hashtable_ref : es-ce que gc est pour gambit-c ou bien garbage-collect? : garbage collect. Ici c'etait garbage_collector_hashtable!
- Confirm that the following 2 notations are equivalent :
  (c-define-type int1 "int")
  (c-define-type int2 (type "int"))
  Quand on retourne les deux types on obtient comme representation :
  t1 = '#<foreign #17 0x412f420>
  t2 = '#<int #18 0x3400410>
  : they should but are not. the first one should not be used directly
* Pourquoi le gc brise t'il typ6 mais pas typ3? Je trouve etrange alors que typ4 et typ5 ne soient ni l'un ni released...
- On peut pas utiliser genre ___CONS dans le code C? Que doit t'on utiliser alors? : ___EXT(make_pair)
- Donc toute memoire allouee en C on doit creer des objets STILL sinon le gc peut non avoir. Mais si je veut retourner disons une
  paire, comment je fait car alors elle a un refcount = 1 et ne sera jamais collecte et si je release avant le retour, il y a un
  petit moment ou le gc peut passer non? Ou bien es-ce que le gc parcourt les __result? : au moment du release, le resultat est
  dans ___R1 qui sera protege
* Le statement dans la doc:
  Moreover the C code is always placed at the head of a compound statement whose lifetime encloses the C to Scheme conversion of the result. Consequently, temporary storage (strings in particular) declared at the head of the C code can be returned by assigning them to `___result' or `___result_voidstar'. In the c-name-or-code, the macro `___AT_END' may be defined as the piece of C 
  semble indiquer qu'on peut { S s; ___result_voidstar = s; } non?
* Pourquoi seul le type (c-type S1 "S1") fonctionne t'il avec les 2 prototypes a et c ?
* Comment connaitre si file ou directory dans directory-files? Et aussi n'es-ce pas vraiment inefficace de reappeler l'os alors
  qu'on avait surement l'info quand on scannais...
* C'est pas serieux! Ca prend absolument une sol pour que les define internes apparaissent correctement dans le stack!
* Certain de mes constructor sont passablement complexes... Es-ce normal due au fait qu'on est read-time qu'une erreur n'affiche aucun stack?
* Serait-il enviseagable d'avoir un declare qui ferait l'equivalent de si on avait code ##car, ##fixnum+, ... partout?
* Es-ce que l'access aux variables globales sont comme les fonctions bcp moins efficaces quand ca change de module?


option pour disabler les warning de dependance circulaire
code snippet pour permettre la compilation d'un define-macro ou ##define-syntax
code snippet pour le ##main-readtable et corriger qui compile-file n'utilise pas le parametre current-readtable
corriger le bug du #\underscore
ajouter find-symbol
repl #0 pour la derniere valeur calcule ou imprime
Serait pratique de pouvoir dire a l'option expansion de compile-file et gsc de ne pas generer de .o1 ni de C
