How to get the platform (architecture!?) in a portable way in Gambit message to the mailing list
  On top of Jeremie usage, use it to create a prefix for .o1 (message to mailing list about idea!?) like toto$gw$.o1 that is for $GambitWindows$

Need to do exceptions / catch / throw

Gambit load manages utf8 files correctly but read does not...

Problem with explicit metaclasses:
  - Must know the metaclass of our ascendant. I.e. if I extend Component, I do not want to have to know if Component defined an explicit metaclass or not
  - The metaclass must be autoload exported too!

Fix slow typing in (library)

try and build the jazz runtime which would be just kernel !? (should it include gsc?)

try and implement optional and named parameters based on show impl. of srfi89

cleanup core / dialect code with
  - iteration with named let
  - internal defines

find a good and elegant solution to the register-autoclass patch

think about a naming convention (maybe CL's *symbol*) that would distinguish between global variables
and class names that make code like (f~ X) hard to easily understand

add something like defvar to impl a construct that bypasses Gambit's block declaration so a var can be setbanged
elsewhere or even better it is the default for define and the other one is constant...

je commence pas mal a pencher pour seulement #f #t {} '() qui est pas mal plus clair et aussi qui est uniforme avec
le code quote et le code lue


(library x
  (export (x.lib.toto.X X)))

;; doit pouvoir referer a X comme :
(library a
  (x.X))

(lib org.jazz (export (org.jazz.lib.application)))
(lib org.jazz.lib.application (export (org.jazz.lib.application.lib.Application)))

(lib b
  (new org.jazz.application.Application))

;; il va aussi faloir que le systeme de module couvre les besoins de fichiers
;; quelconques comme les resources (pas sur du tout... probablement juste une hashtable de strings...)
