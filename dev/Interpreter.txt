- Do a proof of concept of every concept
  - eval
  - break
  - step
  - source location
  - stack
  - macros
  ...
with a mini-language
  - define
  - variable
  - call
  - lambda
  - integers
  - macros
  - annotations (!?)


- Gambit approach to interpreted lambda is really nice. As in Scheme, function call is the only
  communication protocol, by using a standard protocol (compiled functions) for compiled code and
  interpreted code, then even multiple interpreters can coexist easily :
  - compiled code
  - interpreted code by Gambit
  - interpreted code by Jazz Scheme interpreter
  so that i could use Gambit's fast interpreter to load the Jazz kernel and a Jazz interpreter with
  more functionality and simpler code to load Jazz classes!!
