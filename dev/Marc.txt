Questions
---------

- Is it possible to obtain the platform at runtime?
- Would it be difficult to support compiling define-macro? It forces me to always seperate the code into 2 files when
  I want the expander to be compiled and it is very annoying: possible by using the underlying code used by define-macro
- Is it possible to explicitly pass (macro-absent)? : no
- When it's time to compile Jazz code, I'll clearly have correct code with circular symbol dependencies... We have to
  have a solution even if only to be able to load a binary file with suppressed warnings...
- Is there a way to add Jazz's 2 initialized and destroyed bits to Jazz objects without paying a penalty : not really
- It seems that the construct that works for the loader doesn't work for the compiler :
  (parameterize ((current-readtable jazz.jazz-readtable))
    (compile-file-to src bindir "" cc-flags ld-flags))
  (set! ##main-readtable ...)
- It would be nice if compile-file had an option of not generating the .o1 when using options like -expansion
- Can statprof be used on compiled code? yes but better if compiled with -debug
- Is statprof really reliable in that it reaches all the code? : yes
- All of Gambit's tools are really useless in the presence of macros. Can something be done?
  : define-macro receives a version that is completely stripped of position infos but
    ##define-syntax receive the info intact. Gambit extends ##define-syntax to permit a transformation lambda
- If need be can Gambit's heartbeat be made faster? yes but it is already set to max by passing 0 to the function that sets it
- Is it ok to use the default hash function for hashing Shortcuts? Also, do I understand correctly that a custom hash function
  should return a fixnum? and if yes are there any fn to add 2 fixnums and return a fixnum? - NO
- Is ##define-syntax supposed to work in compiled code? : fixed
- If I want to reimplement Jazz's bug slayer module in Gambit, can a reliable stack trace be optained from C code? Also, does Marc know
  of an equivalent to Windows's SetUnhandledExceptionFilter in portable C? : Marc thinks that yes with signal handlers
- Confirm that the following 2 notations are equivalent :
  (c-define-type int1 "int")
  (c-define-type int2 (type "int"))
  When I return the 2 types I get :
  t1 = '#<foreign #17 0x412f420>
  t2 = '#<int #18 0x3400410>
  : they should but are not. the first one should not be used directly
- As ___CONS cannot be used in C code what should be used? : ___EXT(make_pair)
- Donc toute memoire allouee en C on doit creer des objets STILL sinon le gc peut non avoir. Mais si je veut retourner disons une
  paire, comment je fait car alors elle a un refcount = 1 et ne sera jamais collecte et si je release avant le retour, il y a un
  petit moment ou le gc peut passer non? Ou bien es-ce que le gc parcourt les __result? : au moment du release, le resultat est
  dans ___R1 qui sera protege
* Le statement dans la doc:
  Moreover the C code is always placed at the head of a compound statement whose lifetime encloses the C to Scheme conversion of the result. Consequently, temporary storage (strings in particular) declared at the head of the C code can be returned by assigning them to `___result' or `___result_voidstar'. In the c-name-or-code, the macro `___AT_END' may be defined as the piece of C 
  semble indiquer qu'on peut { S s; ___result_voidstar = s; } non?
- Comment connaitre si file ou directory dans directory-files? Et aussi n'es-ce pas vraiment inefficace de reappeler l'os alors
  qu'on avait surement l'info quand on scannais... : pourrais soit retourner ".../" pour les directories ou bien retourner directement les FileInfo
* Gambit really needs a solution to internal defines beeing represented only as #<procedure> in the backtrace
- Is global variable access like function calls, e.g. alot less efficient when crossing modules? no they become C global variables
- Les objets natifs à Gambit qui sont implémentés par des structures comme les ports et les hashtables. Comment pour ces cas obtenir un dispatch rapide et sans blotter la grosseur du ##c-code? : the best
  solution would probably be to integrate jazz classes to gambit types and then we would have no overhead
- Should I use ##fx+ or ##fixnum.+ or ??? : non
- Is there a difference between (f . rest) and (f #!rest rest) ? : non
- Is implementing proper tail calls in an interpreter very complex? Are there some issues about an interpreter preserving proper continuations? Any other Scheme specific gotchas? : if all the calls
  the interpreter makes are in tail position for the interpreted code in tail position, everything will work seamlessly
- Will Gambit optimize out any (let ((x ...)) body) where x occurs only once inside body? This would be usefull for macros generating code so I do not have to duplicate the
  logic of verifying the occurances of x and generating a surrounding let when > 1 : it's not even correct semantics to move the inlined code body into the variable place! and
  yes gambit will optimize many cases especially for variables like (let ((x a)) ...)
- I will have a .o1 for many files. If I then want for some reason to build an exe or dll to package some of them, will Gambit need to recompile
  everyone or can it link from .o1 files? -> no. can either link an exe that will auto dyna load the .o1 or compile so we keep both the .obj and .o1...
- The #ifdef ___LINKER_INFO header section in generated C files is it Lisp data that it contains? : yes
- I guess the ` should create mutable pairs *even* if it does not contain unquotes... Else it is difficult to create mutable data structures
  like in my inline patterns... : arbitrary decision
- When a compile like language takes a looong time, is it gambit or mostly gcc? If it's gcc are there any options to speed up compilation
  that do not affect output speed too much? : gcc mostly and affected *alot* by -debug
* If I do a new ./configure does it undo the other one? I did a ./configure without the single-host but don't feel it did anything. Is there any way to know?
* The problem with Gambit's implementation of keyword parameters and rest. See my "Paramêtres nommés" message thread.
- Is there any problem (semantic, performance, ...) in Gambit to have the same function defined many times in different modules when all the modules are declared block (for the compiled dispatchers).
  : yes so I should name them with a module-name prefix like a.b.fff
* Is Gambit's i/o buffered? Is there any way to improve the performance of load-lines which is about 12x slower than my old C version. Related to this, could we improve Gambit's read-line to return
  somehow info about whether the last line was properly terminated or not (or some other means of knowing)? Also for me to use Gambit's read-line, it would have to be smarter about all line-ending
  formats as I do not generally know in advance what line-ending is in a file!
* Exactly what does compiling with -debug give? The idea being could we have an option that turns off the embedding of source code that makes compiling sooooooooo slow but keeps the other debugging
  features
  - ability to show source with -i
  - variables content in debugger???
  - locations used by statprof???
  : should not be too hard to separate into something like -debug and -source
- Or is it not more like statprof should go up the continuation tree until it finds a continuation with info so we always get
  where the code was... : done
- Is there a performance penalty to loading a .o266? : maybe a slight one
* Look at optimizing hashtable-merge with Marc. Can we just vector-set! the next field if we find an entry empty? What we need is (hashtable-merge into from duplicates-proc) optimized for symbols table
- Es-ce que (if var ...) est plus efficace que (if (##not var) ...) ? : non
* Look with Marc at the reliability of cont-locat with a good example the reported 15% in jazz.read-toplevel-form
* Why the duplication between system and sys.
* Got to really start looking into forming people to Gambit as I am now convinced Gambit's will stay Jazz's platform even if Marc would stop
  work on it for any reason.
- Are there any problems (perfo, semantics, ...) to doing only toplevel set! with no associated define. The reason beeing that because both my display __p2217 and the actual method point to the same lambda
  Gambit's debugger displays __p2217 which is really annoying : extend gambit's heuristic that skips ## with skiping __ :)
* Probably the most usefull thing would be to fix the bug that Gambit's debugger often skips the last frame in ,b
- Is there a procedure to take 7 2 -> 3 : ##fxquotient
- Es-ce que marc as une passete scheme pour faire qq chose juste la 1er fois qu'un fichier est loade? pour CLASS_ATOM : utiliser genre ##global-value
* How can I create an output port that will print into the Jazz console?
* Does Gambit have something like fresh-line?
* Ask Marc about the thing I don't understand about hashtable resizing performance cost. Also, if resize is really so fast then it would indicate that table-merge! is thus so slow and could then be optimized alot


Todo
----

- option to disables warnings when code has circular dependencies
- code snippet to enable compiling a define-macro or ##define-syntax
- code snippet for ##main-readtable and fix compile-file that doesn't use the current-readtable parameter
- repl #0 for the last eval or the last printed value
- compile-file option to suppress .o1 generation
