;;;
;;;; Todo
;;;


JEREMIE
- See http://cairographics.org/cookbook/win32quickstart/ for an example of using Cairo in
  Python where they use BitBlt directly to copy Cairo's work
- I read somewhere that show_text cached the glyphs... Aren't we redoing the job then?
- Implement Clipboard which is not trivial
- Find a solution to put the dll somewhere else than the root


- implement access rights to declarations
- why reimplement queues in Jazz??
- need to fix the save of text is buggy and loses the last line because of the new load-lines
- if i do a search in gambit's c files i will find a place that marc thought of for pasting and cutting from the
  system stack
- at some point i should start looking at the generated c code for my typical code
- because I want to do all type casting at call site for natives, I will need to always call the lowlevel
  ## version of the procedure
- ummm I think that saying car's signature is <pair:object> is wrong. Really, car's signature is <object:object>
  and throws an error if its parameter is not a pair. The <pair:object> is really a compile time specializer!
- specialize iterate and accumulate on basic classes
- Decide if it is correct to only annotate the root method (annotations in a derived method should report an error)
  or maybe validate that the derived annotations are the same!?
- (in p (class X ... (definition some-x (new X)))) should generate a runtime error like Class X not fully loaded
- Because specifics don't have associated declarations, walk error in them get wrongly reported as beeing
  in their parent. Using the generic declaration is not correct as it will create illegal access problems.
  I will probably have to create dummy specific declarations or maybe this is yet again a macro problem
  that has to be solved with the complete macro solution...
- Add a test that if more than one symbol is found by import that it should be an ambiguity error
- Put offscreen? = false and take a *really* good look at all that gets painted. For instance when resizing the
  workbench splitter between the wb and the stage, very strange things get painted
- Not allocate void slots
- (let ((list 2)) (set! list 3)) will say illegal to assign to an export!
- Source code -> code walk -> tree of Jazz expressions -> analyse and optimise -> compile -> scheme code
- Many explorer features in JOptimized still need to be migrated
- Very interesting idea to pretty-print results in the repl...
- The optimisation of having a language construct that splices a slot's content at the end of the
  object's vector could be correct i think if limited to final classes...
- One way to enforce X extends Y => class(X) extends class(Y) is to not permit metaclasses to use the
  extends keyword...
- Gambit load manages utf8 files correctly but read does not...
- Problems with explicit metaclasses:
  - Must know the metaclass of our ascendant. I.e. if I extend Component, I do not want to have to know if Component defined an explicit metaclass or not
  - The metaclass must be autoload exported too!
- Find a good and elegant solution to the register-autoclass patch
- Think about a naming convention (maybe CL's *symbol*) that would distinguish between global variables
  and class names that make code like (f~ X) hard to understand
- Add something like defvar to impl a construct that bypasses Gambit's block declaration so a var can be setbanged
  elsewhere or even better it is the default for define and the other one is constant...
- Implement partial library access like importing jazz.platform.windows and then using (WinUser.RegisterClass ...)


- Determine the exact redefinition rules
  - Jazz -> Blues -> C++ -> Compiled Code
  - Jazz -> Blues -> Interpreted Code
- Policies
  - Debug
  - Release
  - Distribution
- Actions
  - add slot
  - redefine slot
  - remove slot
  - add method
  - redefine method
  - remove method
  - modify visibility
  - modify virtual
  - change slot -> definition
  - change definition -> slot


NOTES
- An interesting concept is to extend the RMI concept to inter-thread communication which would result in
  calling a thread connector through a proxy. What is nice is that the thread could be included in the IOR
  and the call be made directly even from another process. On the other hand it is very heavy to have to
  always marshall when calling in process between threads... We will see when the remote debugger implements
  the concept directly to support multi-thread debugging...


EXPERIMENTAL
- Une idee fort interessante est l'implementation du dispatch rmi et autres par:
  [X.foo x y z] qui est equivalent a
  (Dispatchable.dispatch x 'X.foo y z)
  (class IOR
    (method (dispatch ...)
      (rmi-call ...)))
  Ca correspont a une implementation tres simple du dispatch rmi via un dynamic invoke (comme dans
  la nouvelle version de Java)


Java 1.5
- Unicode
- Primitive datatypes
- Exceptions
- Assertions
- Generics
- Enumerated Types
- Annotations
