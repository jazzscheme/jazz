;;;
;;;; Concepts
;;;


Language
  - Jazz as a language is built of two types of constructs (like Scheme) :
    - Declarations : where Scheme has only one type of declaration (define), Jazz declarations
      form a hierarchy (units, modules, classes, slots, definitions, methods, ...)
    - Expressions : corresponds to executable code (variables, functions, special forms, macros, ...)


Packages
  - Packages describe at a high-level a set of related resources called a package. This includes
    source code, documentation, test, versionning, ... Note that this is different from units and
    modules which are source level concepts specific to the Jazz language. For instances, packages
    could easily be extended to support for foreign package systems like Snow, C libraries, ...
  - Packages unifies the concepts of development, build and deployment. When you build a package you
    are actually building your deployment package. There is no distinction.


Units
  - Represent loadable code usually packaged in a file
  - Very simple and pragmatic approach to runtime vs compiletime problems where, the compiler or interpreter or
    expander or whatever are just units like any other with their own dependencies with full flexibility


Modules
  - Each declaration has a name
  - An identifier is a symbol that can optionaly contain periods. An identifier needs a module context to uniquely
    identify a declaration
  - A fully qualified identifier is called a locator. Locators are usually built automatically by the module system
    from the context and an identifier. Locators are symbols that can be used in Scheme to gain access to any Jazz
    declaration.
  - On top of the module system is built a language framework where jazz is just one language defined with
    this framework. The module system is independant of the underlying language and so modules can be freely
    composed of different languages (scheme, jazz, c, java, c#, ...)
  - Compared to R6RS libraries, Jazz's have almost the same semantics. The two main differences are:
    - Jazz expands the export keyword to implement module composition and delayed loading semantics. Note that
      a module exporting another one not only makes explicitly naming the exported symbols unecessary but it
      also bypasses any conflict with other imports as the module itself does not need the symbols, it just
      'forward' exports them.
    - Using the previous features, Jazz tries to simplify all of R6RS phases and visit concepts and
      having to potentialy load the same module multiple times by a pragmatic but arguably less elegant
      approach where runtime and syntax code live in distinct submodules exported by their parent module
      under the 'runtime' and 'syntax' phase.
  - An important concept is that to walk a module, it's imported modules do not have to be loaded, only their
    declarations or the module itself if it is marked as syntax.
    - declarations
    - syntax
    - runtime


Dependencies
  - Declared dependencies in Jazz must form a DAG. Any cyclic dependency will be detected by the language
    at compile time. Regarding generated code efficiency: in a module, any reference to a direct dependency
    will get compiled to a direct static access while other references will be compiled using a level of
    indirection to ensure delayed loading of the dependency.


Language tower
  - As a design decision, Jazz is implemented by a language tower versus the approach where you try to use
    your new language as soon as possible by compiling it with itself. The compile approach is very fragile
    as any incompatible change to the language can leave you in a state where it is impossible to compile
    the code to the new version. Also it is a code generation approach basically which is always less
    interesting (management of multiple files, ...). The tower approach requires more work and has to be carefuly
    designed but on top of beeing extremely clean, different users with different needs can decide to use any
    part of the tower as fits their needs (especially as all the tower parts except the module one are simply
    modules you have to import).
  - kernel
  - core
  - class
  - generic
  - walker
  - module
  - scheme
  - jazz


Encapsulation
  - Any definition or method defined inside a class is considered encapsulated. Jazz will enforce access rights
    (public protected private) on calls. Also, encapsulated definitions can be dynamically accessed through the
    (f~ obj x y z ...) syntax.
  - Anything inside a class is accessed dynamically through the ~ syntax wheras anything defined outside, e.g. at
    the module level with be statically scoped by the module system.


Types
  - As a design decision, types are not propagated for function return type. A function return type must be explicit
    to be used (complex case is multualy recursive functions).


Conventions
  - Format
    - In format arguments, lowercase is prefered {a} {s} in order to distinguish
      more easily from literals that use uppercase {Point 2 3}...


Indentation
  - Because you always have to be inside a unit / module, indenting at that level doesn't add alot of information.
    On the contrary, by not indenting them, code that appears in column 0 can easily be identified to functional code
    whereas code appearing in column > 0 (usually 2) can easily be identified to methods inside a class.


Inline
  - Another advantage inline functions have over macros is that they can be defined and used in the same file.


- Design goal: most specific info that is more important to the programmer is to the left. Example: put.X.isaix.com
  like in url addresses.


- Note that Jazz has exactly the same lexical structure as Scheme in regards to internal definitions.
  e.g. in:
  a
    b
      c
        d
  d can access c, b and a and for each one their internal definitions (at the first level, which is
  where the . notation of Jazz can be used to go dynamically inside another definition (this is why
  the Jazz code walker has to create the whole declaration tree and not just the first levels)). Also,
  generic methods by their global nature (even if they are module scoped in Jazz) makes it very unatural
  to define classes lexically. This is not a big limitations as inner classes and similar constructs can
  be implemented very easily using the module structure of classes and in a fashion where nothing is
  hidden making the constructs cleaner:
  (module p jazz
  (class X
    (class Iter extends Iterator
      (slot x)
      (method (next iter)
        (get-next x))) ;; or (X.get-next x)
    (method (iterate x)
      (new Iter x))))


- Property
  - properties are slots that remember their getter and setter for efficient access
  - components present only properties to user edition


Component
  - Form - static
  - Branch - static tree of variations
  - Transformation - dynamic transformation (not done)
  - Code - totally dynamic


- Object : everything is Jazz is an object. Every object's behavior is fully defined by it's class.
- Structure : the structure macro defines the structure of a Jazz class, e.g. only the
  slots but not the methods. It also does this in a pure Scheme way by using plain accessor
  functions. This is the basis of the bootstrapping process necessary to make every object a
  Jazz object. Another important element in the bootstrapping process is that the base files
  located in the Jazz folder can all be loaded without loading any units from their .jazz files.
- Declaration : represent the whole declaration tree of a Jazz class. They are used to provide
  information about the class beeing defined and externally referenced classes in a uniform way.
  By using declarations, the macro expansion used by the interpreter and the compiler does not
  have to actually load any class so that the old Jazz environments are not needed anymore.
  At expand time, the declaration has to be available and the code generated will validate at
  runtime that the definition linked to is consistent with the declaration used (implementation
  will do this validation only once of course). I see that at the level of externally referred units
  (any reference to a unit other that ourself) where we build a declaration of that unit containing
  recursively all used declarations (e.g. slot a at offset 12, method f with signature sig, ...) and
  we validate this declaration against the actually loaded class at runtime. In a fully interpreted
  mode, that declaration would actually be empty (we do not depend on anything).
- Code Walker : here the code walker only walks the code, e.g. the Scheme implementation methods.
  Extracting declaration structure is done elsewhere...
- Reference : references from a declaration must be previously defined to be accessible. This is consistent
  with the Scheme runtime model of evaluating the definitions in the order they appear. References from
  expressions can freely refer to declarations appearing before or after.
