{Formatted-Text
 formats:
 ({Format Base}
  {Format Base left-margin: 16 bulleted?: #t}
  {Format Base left-margin: 48 bulleted?: #t})

 styles:
 ({Text-Style Base})

 paragraphs:
 ((1 ("Do a proof of concept of every concept" 0))
  (2 ("eval" 0))
  (2 ("break" 0))
  (2 ("step" 0))
  (2 ("source location" 0))
  (2 ("stack" 0))
  (2 ("macros" 0))
  (0 ("  ..." 0))
  (0 ("with a mini-language" 0))
  (2 ("define" 0))
  (2 ("variable" 0))
  (2 ("call" 0))
  (2 ("lambda" 0))
  (2 ("integers" 0))
  (2 ("macros" 0))
  (2 ("annotations (!?)" 0))
  (0)
  (0)
  (1 ("Gambit approach to interpreted lambda is really nice. As in Scheme, function call is the only communication protocol, by using a standard protocol (compiled functions) for compiled code and interpreted code, then even multiple interpreters can coexist easily :" 0))
  (2 ("compiled code" 0))
  (2 ("interpreted code by Gambit" 0))
  (2 ("interpreted code by Jazz Scheme interpreter" 0))
  (0 ("  so that i could use Gambit's fast interpreter to load the Jazz kernel and a Jazz interpreter with more functionality and simpler code to load Jazz classes!!" 0))
  (0))}
