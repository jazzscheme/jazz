;;;
;;;; Todo
;;;


GC  : Guillaume Cartier (gcartier@jazzscheme.org)
SLC : Stephane Le Cornec (coleste@videotron.ca)
AS  : Alex Shinn (alexshinn@gmail.com)
MF  : Marc Feeley (feeley@iro.umontreal.ca)


;;;
;;;; Build
;;;


HIGH
- Separate optimize? into proper-tail-calls and optimize-dead-local-variables for users wanting better control. We need
  to refactor the code for all the build settings that are all over the place
- Fix the jazz.setup-build patch of generating all the package (was to fix concurrent access from the build processes)
- To build a shared library for a package we will need some kind of manifest to know the order of the included modules.
  This manifest will probably be the module #1 in the list of linked modules. With this it seems natural to try and
  unify this with the .o1 / .mnf used for compiled modules! Could probably be used to build shared libraries at any
  desired level of granularity
  - We will probably need to do the same job that gambit does of generating a .o2 when there is already a .o1 present
    (maybe add this directly to gambit!?)

MEDIUM
- Modify the parallel build so the controller passes the module-names to compile instead of packages so
  that we get parallelisation at the module level
- Implement gsc update
- If I move a.b.c._c.jazz to a.b.c.jazz then a.b.c will always be compiled even if I do many makes


;;;
;;;; Kernel
;;;


MEDIUM
- Fix explicit exports. In time.exports, putting current-time as an explicit error caused problems in jazz.lookup-accessible/compatible-symbol
  as binding was a jazz.Export-Reference...
- Improve the locking mechanism used by load-module so it only locks out a thread if the module it wants to load / walk is actually on the load / walk stack (needs some brainstorming to make sure itâ€™s the right approach)
- Should not keep the full form-src in the syntax tree but just the locat info or maybe a source with the code emptied (note that for IDE tools it might be interesting to have the syntax tree point to the source locations)
- Is there something we can do about not compiled files that because of that get searched over all the binary packages


;;;
;;;; Language
;;;


HIGH
- Modify form to generate code that uses the imports
  - Note that an approach to use library-ref doesn't work as we need access to the private
    table. It will also make it so the errors occur at walk time
  - Scrap autoclass, module autoloads, the global registry of autoloads and everything else
  - Add support for some (import ...) for in .jml files!? For user files as they are templated,
    it is very fragile. Probably better that it is the caller responsibility to somehow inform
    the jml instantiater of the available imports
- Find a clean way of giving direct access to user's code to key functions like break, inspect, ... one approach is to define them
  in jazz and have them redirect to the module by using library-ref (SLC)
- Optimize object creation with a vector to copy of every constant slot initializer
- Should we not also support autoload in imports!?
- Autoload functions should be in the file that exports them!
- A constant syntax for tables would be nice for the library-ref hashtable implementation (Gambit)

MEDIUM
- It would probably be useful to have a similar syntax for a.b.c.field that uses library-ref,
  maybe a.b.c~field (for example to not error on loading the user profile if the field is not found)
- Brainstorm with Marc how to solve the problem of changing a module m that then breaks the
  modules using it and that are compiled. I think the only clean and efficient solution is to
  recompile the using modules not forgetting about transitivity. It could also be a dynamic
  importing or linking phase (kinda like a big lexical let around a library with a variable
  for every referenced external symbol (how can we do this efficiently)
- I should be able to clean *alot* of not directly related code that i was forced to put inside classes because i
  didn't have generics. A class that needs big time cleanup like this is Component
- Redefining a slot in a subclass should error
- Safe code with facade : it's easy compiling some modules in debug and some in release
  but debug code can pass bad values to release code. you kinda need a safe facade and
  debug code calls the safe facade. kinda jazz.language.safe
- I think Stephane's add to references code should only do it for private access
- Why BH?? when syntax-case is strictly more general than syntax-rules (it can easily implement syntax-rules),
  it gives access to arbitrary transformations and it could give us potentialy compatibility with R6RS code


;;;
;;;; Memory
;;;


HIGH
- The uber solution for a memory profiler is to enable each object to register a method
  that recurses all its dependent objects. Amongst other things, this will enable a
  profile-memory to return only the non-dependent objects with their total size


;;;
;;;; Format
;;;


MEDIUM
- Optimize format by making it a macro (posibly only when in head position) or look at other approaches with more optimal performance (Ken Dickey is an expert on format) (could use something like identifier-macro in syntax-case to implement the non-head position format)
- To optimize format we will probably need to add the ability to allocate static memory
  at the toplevel definition and then we can use it to eliminate the dispatch and literal
  toplevel symbols
- Brainstorm with Alex Shinn the possibility to integrate fmt in Gambit / Jazz. Is dsp as efficient as display (e.g. doesn't create a format context?)


;;;
;;;; Graphics
;;;


MEDIUM
- Performance
  - Replace exact->inexact and inexact->exact calls
- Fix the Cairo text truncation glitch
  - Maybe start work on integrating Pango
- Implement the CSS border-collapse concept !?


;;;
;;;; Platform
;;;


HIGH
- Validate memory leaks in FFI packages
- The memory of Jedi is constantly going up even when the app is not current


;;;
;;;; JRM
;;;


MEDIUM
- Could JRM be used for communication with making the protocol into a separate entity where we could define distinct protocols for a Jazz client, a Qt client or the Web client


;;;
;;;; Component
;;;


MEDIUM
- For various needs like the preferences, it might be useful to have a notation in forms to replace the children. It might
  even be possible to keep the children around and do some cherry-picking with ~ !?


;;;
;;;; Designer
;;;


HIGH
- Unify Domain, Property, Value-Row, ... (SLC)
  - Think of the MVC needs
  - Replace value rows with domains
  - The domains knowing their editor is broken. Clearly it is up to the user's code to instantiate the needed
    editor


;;;
;;;; UI
;;;


HIGH
- Need to implement a generic and robust mecanism for view changing size influencing their parent's layout
  One thing that needs to be generalized is the scrollee in the sense that all this should be done even when not in a scroller!
  - Maybe child-sized (or even better an abstract name like layout)
  - Scrollers and certain layouts do nothing
- Fix open-file dialog problems when navigating to C: on Windows due to locked system files (SLC)

LOW
- In Jedi, click on the Compare Files icon, drag and mouse up over the combo box next to it -> error.


;;;
;;;; Tree
;;;


MEDIUM
- Merge cell in trees (draw, selection, drag selection, keyboard navigation, ...)


;;;
;;;; IDE
;;;


HIGH
- Finish the dead code finder and use it to clean the code
- Implement an heuristic to find definitions & methods that should really be inner defines
- To support powerful codewalk based tools, can we find the declaration from a buffer's cursor
  position (use the source info associated to declarations)
- Improve how references are found on shift-F12 that causes for instance problems on : (SLC)
  - Recursive functions -> highlights the function instead
  - (register-autoclass X) -> highlights (class X) instead
- At the same time as the above, make it so all references are highlighted (maybe select the declaration containing
  the references and highlight the references!?) (SLC)

MEDIUM
- Make reload-process work on Jedi
  - Problem comes from the console being closed while we remain attached to the debugger
- Finish forward-invoices
  - Do show-arguments by searching in the library's invoices (SLC)
- The enter-import method should be generalized into something like (enter-form 'import) (already done?) (SLC)
- Faster search in files by using irregex (AS)
- Plan to implement partial evaluation of a library (not sure it's a good idea)
  - Add a special form 'in' enabling (in a.b.c (in X (method (foo) ...))) doing the same behavior as ~ in forms
    - With that, evaluating a method inside a not yet defined class will correctly error
  - It should then be possible to emit the code of only the foo node
  - For this to work, everything that is kept in the library like the literals, will have to either go in the
    walker or inside the declaration itself and be emited as a local let around the declaration
- Would be nice to generalise the "stub" code in Lisp-Parser and use it for instance to display
  define F12 as define (form) and maybe also improve F12 on core classes like jazz.Class-Declaration

LOW
- Finish toggle terminal by making it cross-platform
- Would be nice to have some way on unresolved symbols to ask for the imports needed to resolve those
- Should context-menu end picker before poping the menu?
- Try and understand the strange behavior of the time special-form


;;;
;;;; Debugger
;;;


URGENT
- Debuggee should remain functional even when the main thread is not responding (example an ADO
  request to an inexistant database that is timing out)
- Find a solution to exceptions occurring in the read or print stage of the read-eval-print-loop
  - We have the same problem for errors occuring in the 'print part of the read-eval-print
  - Should always kill the repl thread (optimize keeping it in certain case when all functional)
    by closing the repl port and joining on the thread till it's dead
    - The exception in the repl thread will then raise an uncaught exception wrapper in the joining
      thread
- Trap read errors in the Profile so it doesn't land us in the Gambit debugger
- Add support for interrupt and terminate thread
- Add TCP/IP exceptions to Gambit and have the debugger catch those to cleanly detect problems
- Try tcp-client-peer-socket-info to check before key TCP calls if the connection is still live
- Add logic to deduce the process where evaluations should go from the text moniker
- Should really make it so the default input/output port is the jazz console
- Find a solution to reimplement the initialized and destroyed fields which are key to full stability, for
  example (new Action 'a 'a) crashes the IDE without even going in the Gambit debugger!
  - This might be done with no runtime cost by scanning the stack upon handling an exception for calls to
    initialize and destroy and registering their object as invalid!!? (SLC)
- The auto-selected frame should display its variables even if it's not displaying the source code (SLC)
- c-a-space 2 fois ne fait plus un ensure-displayed sur le text-ending de la console (SLC)
- It is really annoying that after evaluating a new function, we need to reevaluate the imports in libraries
  that where already importing that module in order to access the new function
- If an error occurs in an eval in a frame (calling eval-within-no-winding) then the error occurs in
  the eval-within-no-winding continuation and that creates problems

MEDIUM
- Implement correct filled / border red color management for the workspace icon
- Reimplement the eval in <selected frame>
- Console tab should become a combo with menu items highlighting problems / visits
- A new console's button should be highlighted in red
- Make the indicators work nicelly with multiple threads
- Replace the temporary fix of (sleep .1) in the threads view with a clean callback
  from the debuggee
- Need a clean solution to repl threads. At the moment, if an exception occurs not from an eval,
  we get more than one repl thread reading at the same time
- Use Gambit's new "need" parameter to read-substring and read-subu8vector
- Finish the jazz.exe console debugger
  - Gambit repl channel is basicaly just a mutex + the owner for the banner
  - Gambit repl =
    - acquire mutex
    - read
    - release mutex
    - eval
  - If we try and implement a different mecanism to be able to stay in a certain thread, a
    potential problem is in the eval starting a thread that errors and doing a join on it -> deadlock
