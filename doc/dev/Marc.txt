;;;
;;;; Marc
;;;


DONE
- Would it be difficult to support compiling define-macro? It forces me to always separate the code into 2 files when
  I want the expander to be compiled and it is very annoying: possible by using the underlying code used by define-macro
- Is it possible to explicitly pass (macro-absent)? : no
- Is there a way to add Jazz's 2 initialized and destroyed bits to Jazz objects without paying a penalty : not really
- It would be nice if compile-file had an option of not generating the .o1 when using options like -expansion
- Can statprof be used on compiled code? yes but better if compiled with -debug
- Is statprof really reliable in that it reaches all the code? : yes
- All of Gambit's tools are really useless in the presence of macros. Can something be done?
  : define-macro receives a version that is completely stripped of position infos but
    ##define-syntax receive the info intact. Gambit extends ##define-syntax to permit a transformation lambda
- If need be can Gambit's heartbeat be made faster? yes but it is already set to max by passing 0 to the function that sets it
- Is it ok to use the default hash function for hashing Shortcuts? Also, do I understand correctly that a custom hash function
  should return a fixnum? and if yes are there any fn to add 2 fixnums and return a fixnum? - NO
- Is ##define-syntax supposed to work in compiled code? : fixed
- If I want to reimplement Jazz's bug slayer module in Gambit, can a reliable stack trace be optained from C code? Also, does Marc know
  of an equivalent to Windows's SetUnhandledExceptionFilter in portable C? : Marc thinks that yes with signal handlers
- Confirm that the following 2 notations are equivalent :
  (c-define-type int1 "int")
  (c-define-type int2 (type "int"))
  When I return the 2 types I get :
  t1 = '#<foreign #17 0x412f420>
  t2 = '#<int #18 0x3400410>
  : they should but are not. the first one should not be used directly
- As ___CONS cannot be used in C code what should be used? : ___EXT(make_pair)
- Donc toute memoire allouee en C on doit creer des objets STILL sinon le gc peut non avoir. Mais si je veut retourner disons une
  paire, comment je fait car alors elle a un refcount = 1 et ne sera jamais collecte et si je release avant le retour, il y a un
  petit moment ou le gc peut passer non? Ou bien es-ce que le gc parcourt les __result? : au moment du release, le resultat est
  dans ___R1 qui sera protege
- Comment connaitre si file ou directory dans directory-files? Et aussi n'es-ce pas vraiment inefficace de reappeler l'os alors
  qu'on avait surement l'info quand on scannais... : pourrais soit retourner ".../" pour les directories ou bien retourner directement les FileInfo
- Is global variable access like function calls, e.g. alot less efficient when crossing modules? no they become C global variables
- Native gambit objects implemented by structures like ports and hashtables. How can we obtain a fast dispatch for these : the best
  solution would probably be to integrate jazz classes to gambit types and then we would have no overhead
- Should I use ##fx+ or ##fixnum.+ or ??? : non
- Is there a difference between (f . rest) and (f #!rest rest) ? : non
- Is implementing proper tail calls in an interpreter very complex? Are there some issues about an interpreter preserving proper continuations? Any other Scheme specific gotchas? : if all the calls
  the interpreter makes are in tail position for the interpreted code in tail position, everything will work seamlessly
- Will Gambit optimize out any (let ((x ...)) body) where x occurs only once inside body? This would be usefull for macros generating code so I do not have to duplicate the
  logic of verifying the occurances of x and generating a surrounding let when > 1 : it's not even correct semantics to move the inlined code body into the variable place! and
  yes gambit will optimize many cases especially for variables like (let ((x a)) ...)
- I will have a .o1 for many files. If I then want for some reason to build an exe or dll to package some of them, will Gambit need to recompile
  everyone or can it link from .o1 files? -> no. can either link an exe that will auto dyna load the .o1 or compile so we keep both the .obj and .o1...
- The #ifdef ___LINKER_INFO header section in generated C files is it Lisp data that it contains? : yes
- I guess the ` should create mutable pairs *even* if it does not contain unquotes... Else it is difficult to create mutable data structures
  like in my inline patterns... : arbitrary decision
- When a compile like language takes a looong time, is it gambit or mostly gcc? If it's gcc are there any options to speed up compilation
  that do not affect output speed too much? : gcc mostly and affected *alot* by -debug
- Is there any problem (semantic, performance, ...) in Gambit to have the same function defined many times in different modules when all the modules are declared block (for the compiled dispatchers).
  : yes so I should name them with a module-name prefix like a.b.fff
- Exactly what does compiling with -debug give? The idea being could we have an option that turns off the embedding of source code that makes compiling sooooooooo slow but keeps the other debugging
  features
  - ability to show source with -i
  - variables content in debugger???
  - locations used by statprof???
  : should not be too hard to separate into something like -debug and -source
- Or is it not more like statprof should go up the continuation tree until it finds a continuation with info so we always get
  where the code was... : done
- Is there a performance penalty to loading a .o266? : maybe a slight one
- Es-ce que (if var ...) est plus efficace que (if (##not var) ...) ? : non
- Why the duplication between system and sys. : system is the good one
- Are there any problems (perfo, semantics, ...) to doing only toplevel set! with no associated define. The reason beeing that because both my display __p2217 and the actual method point to the same lambda
  Gambit's debugger displays __p2217 which is really annoying : extend gambit's heuristic that skips ## with skiping __ :)
- Is there a procedure to take 7 2 -> 3 : ##fxquotient
- Es-ce que marc as une passete scheme pour faire qq chose juste la 1er fois qu'un fichier est loade? pour CLASS_ATOM : utiliser genre ##global-value
- Does Gambit have something like fresh-line? : (output-port-column port)
- Why is compiling language sooooo much slower on the Mac? : maybe gcc version!? num.scm of gambit is similar size so investigate why
  it is not as slow
- Facon la + simple d'utiliser le sha-1 de snow? : implement show in jazz! Es-ce que ca va donner le meme resultat que le sha-1 de Git? yes
- Y-a-t-il une facon simple d'avoir le size d'un fichier ou port? : file-size
- Integrate my splitting the -debug option into -debug and -include-source
- Why the USE_environ=1 - setenv not really standard
- Validate that table-length is just a slot access - yes
- Validate that statprof needs the source option - yes it does
- (compile-file "x" options: '(some-garbage)) does not report an error - done
- Could there be a read-line with proper? - use the include-separator? parameter
- Entering #u8(72 101 108 108 111) at the gsc repl quits the application! - the problem is my exception handler that doesnt throw to get out of
  the exception point. this will be fixed when i do my own repl for the build system
- How can we in Gambit specify runtime options like -:m500000 when building an application? : #!gsi -:dr,m250000 at the top of the main module
- If i interrupt a build with ctrl-c and try to quit with ,q the process now hangs on windows : i need to manage correctly 


SNOW
* It took me like 20mn to just download and figure out all the dependencies of hello world!!! The system has to do all this automatically
* If I am to use snow to package jazz modules I will need :
  - support for binary packages : fat binaries for multiple architectures too!?
* How do namespaces work? Can we integrate namespaces and jazz libraries easily?
* For snow, (requires: a b c (d ...)) would be more consistant and much easier to parse as it would just be keywords
* So if I understand correctly, Snow is just Scheme code outside the package* form that rely on magic happening to make some
  symbols available like tk-start. There is no module management. This won't scale when a lot more packages are available. We absolutly need
  a robust module system underneath Snow and all code to go through that module system to access the Snow packages.
* It is also very difficult to reconcile Jazz's philosophy of refining concepts to their utmost simplicity with Snow's having to deal with
  all the various incompatibilities between all Scheme systems. It's pathetic to have to redifine all the bignum concepts and pay a performance
  penalty of going through an extra layer when bignums are part of r5rs.


TODO
* Le statement dans la doc:
  Moreover the C code is always placed at the head of a compound statement whose lifetime encloses the C to Scheme conversion of the result. Consequently, temporary storage (strings in particular) declared at the head of the C code can be returned by assigning them to `___result' or `___result_voidstar'. In the c-name-or-code, the macro `___AT_END' may be defined as the piece of C 
  semble indiquer qu'on peut { S s; ___result_voidstar = s; } non?
* Gambit really needs a solution to internal defines beeing represented only as #<procedure> in the backtrace
* The problem with Gambit's implementation of keyword parameters and rest. See my "Parametres nommes" message thread.
* Look at optimizing hashtable-merge with Marc. Can we just vector-set! the next field if we find an entry empty? What we need is (hashtable-merge into from duplicates-proc) optimized for symbols table
* Look with Marc at the reliability of cont-locat with a good example the reported 15% in jazz.read-toplevel-form
* Ask Marc about the thing I don't understand about hashtable resizing performance cost. Also, if resize is really so fast then it would indicate that table-merge! is thus so slow and could then be optimized alot
* Is there anything in Gambit for read-only flag of files and setting attributes and modification-time.
* Ask Marc his opinion on essay and either.
* Validate with Marc that my test.ptm is correct even if running tptm followed by ##gc doesn't really bring the memory back to where it was...
* Expose also the underlying get the frame etc ...
* Why is it important to assign the ##current-* at the start of ##repl-debug-main ?
* Could define-runtime-macro be exported? (integrate my version somehow!?)
* Integrate my version of define-runtime-cond-expand-feature !?
* Why does the (debug) option doesn't seem to work for the kernel?
* Logic of tab completion should be adapted for cases where there is *alot* of completions
* Could we compile using a precompiled header for gambit.h for faster builds?
* compile-file option to suppress .o1 generation
* still-obj-refcount
* Fix the pdf error during make of Gambit
* Marc needs to fix the problems with opening ports of u8vector so i can use one with eol-encoding: 'cr-lf to split the
  clipboard correctly on windows
* Marc will add a runtime option to disable ctrl-c handling
* Marc is thinking about always using / as path separator and only externalizing to the platform separator on demand
* Something is not uniform... When an error occurs and a repl is started, ctrl-d will come back to previous state wheras when it's from Jedi and a new
  repl is started, there is no way to exit the repl and get back to previous state. I implement it with my ,r command but there is something not uniform
  in this...
* Why does my throw-stop in resume-loop bug when another error occurs?
* Finish all that is necessary so a jazz binary release without gambit installed can still compile out of the box
* Look at integrating my ,r into gambit and also at doing it the right way as (car 1) ,r (car 1) will have no stack the second time
* Maybe Marc has some idea about the problem of switching to another app from the login dialog taking a long time. It is instantaneous when the gambit
  console is displayed...
* Any function to get a list of the threads
* Any functions to suspend / resume a thread. Usefull for a thread debugger
* Discuss with Marc about all the implications that any code that blocks outside of Gambit will basically stop all the threading system. Are there
  any workaround or ...
* OHHHHHHHHHHHHHHHHHHHHHH if i do my generate-disabled test from jedi and it pops the console i do not see the error messages but if i do from a jedi started
  from a gsc console i do arrrrrrrrrr. Also, why does it not work with open-process and works ok with shell-command ?
* Another problem is that shell-command on windows when in jedi will show the shell-command's console. We need control over showing or not
* I dont understand condition variables. How does a thread block on one? And how does the variable know what threads to unblock when doing a broadcast?
* Look at how to correctly do the platform-process-messages with marc. Just doing a PeekMessage is not good too as it consumes much too much cpu. Problem is
  a bit similar to how do i read the full content of a tcp port cleanly without blocking and without waiting for an arbitray timeout
* What does Marc think about my windows timer approach to unblocking the gambit threads. And who can a gambit multi-platform timer mecanism be implemented?
* This is also related to how do the tcp-server correctly so it can be stopped yet be responsive?
* Another difficulty is that if a gambit thread errors, the primordial jedi thread will consume all keyboard events maybe debugging impossible
* Carefull about the note about MsgWaitForMultipleObjects :
  Functions such as PeekMessage and GetMessage mark messages in the queue as old messages. Therefore, after you call one of these functions, a subsequent call
  to MsgWaitForMultipleObjects will not return until new input of the specified type arrives
* We will need a multi-platform solution to event management that works also on X11 and MacOS
* Is it normal that an error in a thread doesn't display at the console until i eval something or is it just a windows problem?
* Is there a work around to doing char input before read-subu8vector for my read-line/headers method?
* Is my approach of wrapping boot-app in ##repl-debug the correct approach?
* What is the diff between ##repl and ##repl-debug?
* Gambit doesnt support correctly spaces in install directories. If I start gsc from c:\Program Files\foo and try (compile-file "x") I get an error.
* Gambit still cannot (compile-file "x") when in a folder with spaces.
* Need a solution to class-of for ports
* Could we consider that (path-normalize "a/") should not error just like (path-normalize "a")
* Pulses will not work smoothly unless we implement the event system using gambit's ports
* Problem of read-line returning blabla\r on Windows
* Shouldn't open-event-queue be open-event-port?
* Lock at my Pulse code with Marc to improve it: should not consume resources when idle (now it sleeps the period in a loop) and it would be nice to guaranty
  that a start will sleep exactly the period before the first pulse
* Did Marc fix the pdf annoying error with the make?


NOTES
* Got to really start looking into forming people to Gambit as I am now convinced Gambit's will stay Jazz's platform even if Marc would stop
  work on it for any reason.
