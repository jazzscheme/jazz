;;;
;;;; Marc
;;;


DONE
- Would it be difficult to support compiling define-macro? It forces me to always separate the code into 2 files when
  I want the expander to be compiled and it is very annoying: possible by using the underlying code used by define-macro
- Is it possible to explicitly pass (macro-absent)? : no
- Is there a way to add Jazz's 2 initialized and destroyed bits to Jazz objects without paying a penalty : not really
- It would be nice if compile-file had an option of not generating the .o1 when using options like -expansion
- Can statprof be used on compiled code? yes but better if compiled with -debug
- Is statprof really reliable in that it reaches all the code? : yes
- All of Gambit's tools are really useless in the presence of macros. Can something be done?
  : define-macro receives a version that is completely stripped of position infos but
    ##define-syntax receive the info intact. Gambit extends ##define-syntax to permit a transformation lambda
- If need be can Gambit's heartbeat be made faster? yes but it is already set to max by passing 0 to the function that sets it
- Is it ok to use the default hash function for hashing Shortcuts? Also, do I understand correctly that a custom hash function
  should return a fixnum? and if yes are there any fn to add 2 fixnums and return a fixnum? - NO
- Is ##define-syntax supposed to work in compiled code? : fixed
- If I want to reimplement Jazz's bug slayer module in Gambit, can a reliable stack trace be optained from C code? Also, does Marc know
  of an equivalent to Windows's SetUnhandledExceptionFilter in portable C? : Marc thinks that yes with signal handlers
- Confirm that the following 2 notations are equivalent :
  (c-define-type int1 "int")
  (c-define-type int2 (type "int"))
  When I return the 2 types I get :
  t1 = '#<foreign #17 0x412f420>
  t2 = '#<int #18 0x3400410>
  : they should but are not. the first one should not be used directly
- As ___CONS cannot be used in C code what should be used? : ___EXT(make_pair)
- Donc toute memoire allouee en C on doit creer des objets STILL sinon le gc peut non avoir. Mais si je veut retourner disons une
  paire, comment je fait car alors elle a un refcount = 1 et ne sera jamais collecte et si je release avant le retour, il y a un
  petit moment ou le gc peut passer non? Ou bien es-ce que le gc parcourt les __result? : au moment du release, le resultat est
  dans ___R1 qui sera protege
- Comment connaitre si file ou directory dans directory-files? Et aussi n'es-ce pas vraiment inefficace de reappeler l'os alors
  qu'on avait surement l'info quand on scannais... : pourrais soit retourner ".../" pour les directories ou bien retourner directement les FileInfo
- Is global variable access like function calls, e.g. alot less efficient when crossing modules? no they become C global variables
- Native gambit objects implemented by structures like ports and hashtables. How can we obtain a fast dispatch for these : the best
  solution would probably be to integrate jazz classes to gambit types and then we would have no overhead
- Should I use ##fx+ or ##fixnum.+ or ??? : non
- Is there a difference between (f . rest) and (f #!rest rest) ? : non
- Is implementing proper tail calls in an interpreter very complex? Are there some issues about an interpreter preserving proper continuations? Any other Scheme specific gotchas? : if all the calls
  the interpreter makes are in tail position for the interpreted code in tail position, everything will work seamlessly
- Will Gambit optimize out any (let ((x ...)) body) where x occurs only once inside body? This would be usefull for macros generating code so I do not have to duplicate the
  logic of verifying the occurances of x and generating a surrounding let when > 1 : it's not even correct semantics to move the inlined code body into the variable place! and
  yes gambit will optimize many cases especially for variables like (let ((x a)) ...)
- I will have a .o1 for many files. If I then want for some reason to build an exe or dll to package some of them, will Gambit need to recompile
  everyone or can it link from .o1 files? -> no. can either link an exe that will auto dyna load the .o1 or compile so we keep both the .obj and .o1...
- The #ifdef ___LINKER_INFO header section in generated C files is it Lisp data that it contains? : yes
- I guess the ` should create mutable pairs *even* if it does not contain unquotes... Else it is difficult to create mutable data structures
  like in my inline patterns... : arbitrary decision
- When a compile like language takes a looong time, is it gambit or mostly gcc? If it's gcc are there any options to speed up compilation
  that do not affect output speed too much? : gcc mostly and affected *alot* by -debug
- Is there any problem (semantic, performance, ...) in Gambit to have the same function defined many times in different modules when all the modules are declared block (for the compiled dispatchers).
  : yes so I should name them with a module-name prefix like a.b.fff
- Exactly what does compiling with -debug give? The idea being could we have an option that turns off the embedding of source code that makes compiling sooooooooo slow but keeps the other debugging
  features
  - ability to show source with -i
  - variables content in debugger???
  - locations used by statprof???
  : should not be too hard to separate into something like -debug and -source
- Or is it not more like statprof should go up the continuation tree until it finds a continuation with info so we always get
  where the code was... : done
- Is there a performance penalty to loading a .o266? : maybe a slight one
- Es-ce que (if var ...) est plus efficace que (if (##not var) ...) ? : non
- Why the duplication between system and sys. : system is the good one
- Are there any problems (perfo, semantics, ...) to doing only toplevel set! with no associated define. The reason beeing that because both my display __p2217 and the actual method point to the same lambda
  Gambit's debugger displays __p2217 which is really annoying : extend gambit's heuristic that skips ## with skiping __ :)
- Is there a procedure to take 7 2 -> 3 : ##fxquotient
- Es-ce que marc as une passete scheme pour faire qq chose juste la 1er fois qu'un fichier est loade? pour CLASS_ATOM : utiliser genre ##global-value
- Does Gambit have something like fresh-line? : (output-port-column port)
- Why is compiling language sooooo much slower on the Mac? : maybe gcc version!? num.scm of gambit is similar size so investigate why
  it is not as slow
- Facon la + simple d'utiliser le sha-1 de snow? : implement show in jazz! Es-ce que ca va donner le meme resultat que le sha-1 de Git? yes
- Y-a-t-il une facon simple d'avoir le size d'un fichier ou port? : file-size
- Integrate my splitting the -debug option into -debug and -include-source
- Why the USE_environ=1 - setenv not really standard
- Validate that table-length is just a slot access - yes
- Validate that statprof needs the source option - yes it does
- (compile-file "x" options: '(some-garbage)) does not report an error - done
- Could there be a read-line with proper? - use the include-separator? parameter
- Entering #u8(72 101 108 108 111) at the gsc repl quits the application! - the problem is my exception handler that doesnt throw to get out of
  the exception point. this will be fixed when i do my own repl for the build system
- How can we in Gambit specify runtime options like -:m500000 when building an application? : #!gsi -:dr,m250000 at the top of the main module
- If i interrupt a build with ctrl-c and try to quit with ,q the process now hangs on windows : i need to manage correctly 
- Is there a peek on object ports? - no because as every scheme object is valid in an object port, peek would have to way of returning <not found>


SNOW
* It took me like 20mn to just download and figure out all the dependencies of hello world!!! The system has to do all this automatically
* If I am to use snow to package jazz modules I will need :
  - support for binary packages : fat binaries for multiple architectures too!?
* How do namespaces work? Can we integrate namespaces and jazz libraries easily?
* For snow, (requires: a b c (d ...)) would be more consistant and much easier to parse as it would just be keywords
* So if I understand correctly, Snow is just Scheme code outside the package* form that rely on magic happening to make some
  symbols available like tk-start. There is no module management. This won't scale when a lot more packages are available. We absolutly need
  a robust module system underneath Snow and all code to go through that module system to access the Snow packages.
* It is also very difficult to reconcile Jazz's philosophy of refining concepts to their utmost simplicity with Snow's having to deal with
  all the various incompatibilities between all Scheme systems. It's pathetic to have to redifine all the bignum concepts and pay a performance
  penalty of going through an extra layer when bignums are part of r5rs.


TODO
* Le statement dans la doc:
  Moreover the C code is always placed at the head of a compound statement whose lifetime encloses the C to Scheme conversion of the result. Consequently, temporary storage (strings in particular) declared at the head of the C code can be returned by assigning them to `___result' or `___result_voidstar'. In the c-name-or-code, the macro `___AT_END' may be defined as the piece of C 
  semble indiquer qu'on peut { S s; ___result_voidstar = s; } non?
* The problem with Gambit's implementation of keyword parameters and rest. See my "Parametres nommes" message thread.
* Look with Marc at the reliability of cont-locat with a good example the reported 15% in jazz.read-toplevel-form
* Ask Marc about the thing I don't understand about hashtable resizing performance cost. Also, if resize is really so fast then it would indicate that table-merge! is thus so slow and could then be optimized alot
* Is there anything in Gambit for read-only flag of files and setting attributes and modification-time.
* Validate with Marc that my test.ptm is correct even if running tptm followed by ##gc doesn't really bring the memory back to where it was...
* Expose also the underlying get the frame etc ...
* Could define-runtime-macro be exported? (integrate my version somehow!?)
* Integrate my version of define-runtime-cond-expand-feature !?
* Why does the (debug) option doesn't seem to work for the kernel?
* Logic of tab completion should be adapted for cases where there is *alot* of completions
* Could we compile using a precompiled header for gambit.h for faster builds?
* compile-file option to suppress .o1 generation
* still-obj-refcount
* Marc needs to fix the problems with opening ports of u8vector so i can use one with eol-encoding: 'cr-lf to split the
  clipboard correctly on windows
* Marc is thinking about always using / as path separator and only externalizing to the platform separator on demand
* Something is not uniform... When an error occurs and a repl is started, ctrl-d will come back to previous state wheras when it's from Jedi and a new
  repl is started, there is no way to exit the repl and get back to previous state. I implement it with my ,r command but there is something not uniform
  in this...
* Finish all that is necessary so a jazz binary release without gambit installed can still compile out of the box
* Any function to get a list of the threads
* Any functions to suspend / resume a thread. Usefull for a thread debugger
* OHHHHHHHHHHHHHHHHHHHHHH if i do my generate-disabled test from jedi and it pops the console i do not see the error messages but if i do from a jedi started
  from a gsc console i do arrrrrrrrrr. Also, why does it not work with open-process and works ok with shell-command ?
* Another problem is that shell-command on windows when in jedi will show the shell-command's console. We need control over showing or not
* I dont understand condition variables. How does a thread block on one? And how does the variable know what threads to unblock when doing a broadcast?
* What does Marc think about my windows timer approach to unblocking the gambit threads. And who can a gambit multi-platform timer mecanism be implemented?
* Another difficulty is that if a gambit thread errors, the primordial jedi thread will consume all keyboard events maybe debugging impossible
* Could we consider that (path-normalize "a/") should not error just like (path-normalize "a")
* Look at my Pulse code with Marc to improve it: should not consume resources when idle (now it sleeps the period in a loop) and it would be nice to guaranty
  that a start will sleep exactly the period before the first pulse
* Would the best way to implement window events be to have a thread on waiting on events and the main thread waiting on os events and have only one being processed
  at a time using a mutex?


* Need a solution to class-of for ports
- How to implement ports to direct output into the jazz console
* We will need a multi-platform solution to event management that works also on X11 and MacOS
* Any idea why current-instance is always returning 0? If we can fix this, I could include the icon in the executable
- Would be nice to fix the closing the Windows gsc console through the close box crashing
- If some syntax for unreadable objects was taken so that for example #<blabla #2> is read exactly as #2, then it would elegantly solve the problem of seeing
  output with literals containing unreadable objects. For example you could paste (length '(#<blabla #2> #<blublu #3>))
* Look at integrating my ,r into gambit and also at doing it the right way as (car 1) ,r (car 1) will have no stack the second time
- Can we safely rely on the meroon type to always exist to get the extra bit we need in Jazz to implement the initialized feature?
- Could the functionality to add to the repl-result-history be exported so that Jazz's console be consistant with the Gambit one.
- Try and understand with Marc why read can correctly read a point in Jazz and why even with a with-jazz-readtable a #\at cannot be read.
  - with it fix who-calls of forward-simple-expr with wrapping the read in find-expression with a with-jazz-readtable
* How does force-output work? For instance why does (format :terminal "aaa{%}") display directly and (format :console "aaa{%}")
  takes a (force-output) to work
* Review all the event system code with marc as it is so critical.
* The new thread-group->... are clearly badly named using -> instead of just -


* Need a way to use write with UTF-8 char-encoding
* Need a way to start a tcp server and let the stack find an available port

* Does creating a parameter have performance costs outside of it's own usage?
* Ask marc to really explain the difference between with-exception-handler and with-exception-catcher. Is it ok to use catcher to return something
  from the exception handler and what happens when you return a value form the exception handler when using a with-exception-handler?
* Need explicit catchable errors for everything that can happen to a TCP connection to implement a robust remote debugging system.
* Need a timeout parameter bad to open-tcp-client especially for the liveliness test.


TEST PERFORMANCE WITHOUT BLOCK

RELEASE
(declare (standard-bindings) (extended-bindings) (not inline) (block) (not safe))

DEBUG / CORE
(declare (standard-bindings) (extended-bindings) (not inline) (not inline-primitives))


It would be possible to link statically at any level into .o1 or .exe by preserving the gambit linking info but keeping the .c and by keeping the compile
code into the .o.


(definition cast-void*
  (c-function (int) void* "___result = (void*) ___arg1;"))

(definition cast-int*
  (c-function (int) int* "___result = (int*) ___arg1;"))

(cast-int* 0)
(foo 'int* (cast-void* 0))

(definition (foo-foo)
  (let* ((vect (make-u32vect 1)))
    (u32vect-set! vect 0 (enfoo #f))
    ((c-lambda (U32PTR) void "foo") vect)
    (defoo (u32vect-ref vect 0))))

{
 IUnknown* i;
 foo(&i);
 return i;
}


NOTES
* Got to really start looking into forming people to Gambit as I am now convinced Gambit's will stay Jazz's platform even if Marc would stop
  work on it for any reason.
