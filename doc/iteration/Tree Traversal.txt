
comp.lang.lisp (243)
comp.lang.scheme
Jazz Scheme
Recently visited  [clear]
comp.lang.functional
Google Groups Guide
Groups Alerts Groups Alerts
Create a group...
Google Groups Home 	gcartier@jazzscheme.org | My Groups | Favorites | Profile | Help | My Account | Sign out
comp.lang.scheme
	
		
Discussions
+ start a discussion
About this group
Edit my subscription
This is a Usenet group - learn more
		
Tree traversal
More options
There are currently too many topics in this group that display first. To make this topic appear first, remove this option from another topic.
There was an error processing your request. Please try again.
Show message list >
Proportional text   Fixed font
	
		
[Click the star to watch this topic] 	
[Click the envelope to receive email updates]
	  	9 messages - Collapse all 	
The group you are posting to is a Usenet group. Messages posted to this group will make your email visible to anyone on the Internet.
	
		
Vend   	
View profile
	 More options Dec 18, 9:57 am
Newsgroups: comp.lang.scheme
From: "Vend" <ven...@virgilio.it>
Date: 18 Dec 2006 06:57:37 -0800
Local: Mon, Dec 18 2006 9:57 am
Subject: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
Hello, I'm looking for an *iterative* algorithm to do post-order
depth-first tree traversal. That is, given the tree:
(a (b) (c (d)) (e))
the algorithm should traverse the node in this order: b d c e a
(note: the first element of a list is always an atom and the subsequent
elements are always lists)

I implemented it as:

(define (depth-first-post-order tree)
  (if (pair? tree) (begin
    (let childrenLoop ((childrenList (cdr tree)))
      (if (pair? childrenList) (begin
        (depth-first-post-order (car childrenList))
        (childrenLoop (cdr childrenList))
      ))
    )
    (display (car tree)) (newline)
  ))
)

But I'm looking for an iterative (or tail-recursive) version.
(This is because I plan to use it with two trees at once, so I can't
use the stack in the usual way).

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Chung-chieh Shan   	
View profile
	 More options Dec 18, 12:29 pm
Newsgroups: comp.lang.scheme
From: Chung-chieh Shan <ccs...@post.harvard.edu>
Date: Mon, 18 Dec 2006 17:29:50 GMT
Local: Mon, Dec 18 2006 12:29 pm
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
Vend <ven...@virgilio.it> wrote in article <1166453857.752898.102...@n67g2000cwd.googlegroups.com> in comp.lang.scheme:

> But I'm looking for an iterative (or tail-recursive) version.
> (This is because I plan to use it with two trees at once, so I can't
> use the stack in the usual way).

Apply a continuation-passing-style (CPS) transformation to your code.

-- 
Edit this signature at http://www.digitas.harvard.edu/cgi-bin/ken/sig
FORTH is a program that interfaces keyboards with computer.

Charles H.Moore, Geoffrey C. Leach, 1970.
http://www.ultratechnology.com/4th_1970.html

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
ggem   	
View profile
	 More options Dec 18, 5:28 pm
Newsgroups: comp.lang.scheme
From: "ggem" <gge...@gmail.com>
Date: 18 Dec 2006 14:28:15 -0800
Local: Mon, Dec 18 2006 5:28 pm
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

Vend wrote:
> Hello, I'm looking for an *iterative* algorithm to do post-order
> depth-first tree traversal.

Here's a solution:

(define (depth-first-post-order proc tree)
  (let loop ((to-visit '()) (trees (list tree)) (stack '()))
    (if (null? trees)
        (unless (null? to-visit)
          (proc (car to-visit))
          (loop (cdr to-visit) (car stack) (cdr stack)))
        (loop (cons (caar trees) to-visit)
          (cdar trees)
          (cons (cdr trees) stack)))))

-ggem.

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Andru Luvisi   	
View profile
	 More options Dec 19, 1:05 am
Newsgroups: comp.lang.scheme
From: Andru Luvisi <luv...@andru.sonoma.edu>
Date: 18 Dec 2006 22:05:06 -0800
Local: Tues, Dec 19 2006 1:05 am
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
>>>>> "Vend" == Vend  <ven...@virgilio.it> writes:

    Vend> Hello, I'm looking for an *iterative* algorithm to do
    Vend> post-order depth-first tree traversal.

Nonrecursive postorder traversal is one of my all time favorite problems.

With preorder or inorder traversal of a binary tree, all you need to do
is keep a stack.  What you do with each item as you pop it off is always
the same.

With postorder traversal, you also need to store on the stack some extra
information, indicating which children you have and haven't processed yet.

It's possible to work out an iterative solution directly, by using some
intelligently chosen invariants, but it's much easier to start with a
recursive solution and transform it into an iterative solution.

In order to perform this transformation, you need to start with some idea
of what a function call, in the generic case, really is.

Imagine you have procedures A and B, with A calling B.

  A:
    ...
    CALL B()
    ...

  B:
    ...
    return
    ...

While A is executing, when it is time to call B, some events need to
happen.  When A calls B, A's state needs to be stashed away and control
needs to be transfered to B.  When B wants to return, control needs
to be transfered to A and A's state needs to be restored.  Who saves
and who restores the state doesn't really matter.  Normally either the
caller both saves and restores, or the callee both saves and restores,
but not always. (Looking ahead, in my ultimate solution to this, the
caller will save the state, and the callee will restore it.)

Here is an example of what those might turn into:
  A:
    ...
    push state onto stack
    push address of RESUME_AFTER_B onto stack
    jump to B
    RESUME_AFTER_B:  ;;; This is just a label
    pop state off of stack
    ...

  B:
    ...
    jump to address on top of stack and pop it
    ...

In the case of a function calling itself:

  A:
    ...
    CALL A()
    ...
    return

This behaves something like:
  A:
    START_OF_A:
    ...
    push state onto stack
    push address of RESUME_AFTER_A onto stack
    jump to START_OF_A
    RESUME_AFTER_A:
    pop state off of stack
    ...
    jump to (pop return address off of stack)

Since we're trying to remove recursion, we can't use the system stack,
the one that the language handles for us automatically when we make a
recursive call, so we use our own.  If we are only making the recursive
call from one place in the procedure, we don't need to actually store
the address of the label to return to, we just need a way to answer
the question "are we returning from a fake recursive call, or are we
actually returning for real because our work here is done?"

How do we know if we are returning from a fake recursive call?  We check
whether our manually managed stack is empty.

  A:
    START_OF_A:
    ...
    push state onto stack
    jump to START_OF_A
    RESUME_AFTER_A:
    restore state from stack

    ...
    if(stack is not empty)
      jump to RESUME_AFTER_A
    else
      return

Now, for your problem in particular, the recursive call happens inside
of a loop.  Now, you can't normally jump into a loop from outside of
a loop, so we need to "flatten" the loop a little bit.  Here's what your
original function sort of resembles:

  A(node):
    foreach child in children_of(node)
      a(child)
    print value_in(node)
    return

Flattening the loop (pretending that I'm a compiler):
  A(node):
    local children  ;;; declare "children" as a local variable
    children = children_of(node)
    if(children is null) goto AFTER_LOOP
    LOOP:
    A(first(children))  ;;; recursive call
    children = rest(children)
    if(children isn't null) goto LOOP
    AFTER_LOOP:
    print value_in(node)
    return

Now, applying the manual recursion elimination:
  A(node):
    local children   ;;; declare "children" as a local variable
    local stack      ;;; the local stack for fake recursive calls
    stack = null
    START_OF_A:      ;;; place to jump back to for fake recursive calls
    children = children_of(node)
    if(children is null) goto AFTER_LOOP
    LOOP:

    ;;; begin fake recursive call
    push children and node onto stack
    set node = first(children)
    jump to START_OF_A
    AFTER_RECURSIVE_CALL:
    pop node and children from stack
    ;;; end fake recursive call

    children = rest(children)
    if(children isn't null) goto LOOP
    AFTER_LOOP:
    print value_in(node)
    if(stack isn't empty)
      goto AFTER_RECURSIVE_CALL
    else
      return

Now seems like a convenient time to transform all of this into
scheme.

(define (children-of node) (cdr node))
(define (contents-of node) (car node))

(define (process node)
  (let ((stack '())
        (children #f))
    (define (start-of-process)
      (set! children (children-of node))
      (if (not (null? children))
          (loop)
          (after-loop)))
    (define (loop)
      (set! stack (cons children (cons node stack)))
      (set! node (car children))
      (start-of-process))
    (define (after-recursive-call)
      (set! children (car stack))
      (set! node (cadr stack))
      (set! stack (cddr stack))
      (set! children (cdr children))
      (if (not (null? children))  
          (loop)
          (after-loop)))
    (define (after-loop)
      (display (contents-of node))
      (newline)
      (if (not (null? stack))
          (after-recursive-call)
          #t)) ;;; The #t is the equivalent of "returning true"
    (start-of-process)))

So far, this has been done entirely through mechanical means, via
meaning preserving transformations.  We could stop here, or we
could try and turn this into somewhat more idiomatic scheme code.
We can eliminate the set!'s by turning all of the variables into
arguments to all of the local functions and doing the changes
while making the calls.  To eliminate the assignments to node,
I'll call the new local variable "current-node".  I'll also switch
to a "callee restores" way of looking at things.  Notice that the
stack is now popped during the fake return through the choice of
arguments.

(define (children-of node) (cdr node))
(define (contents-of node) (car node))

(define (process node)
  (define (start-of-process current-node children stack)
    (if (not (null? children))
        (loop current-node children stack)
        (after-loop current-node children stack)))
  (define (loop current-node children stack)
    (let ((new-node (car children)))
      (start-of-process new-node
                        (children-of new-node)
                        (cons (cdr children) (cons current-node stack)))))
  (define (after-recursive-call current-node children stack)
    (if (not (null? children))  
        (loop current-node children stack)
        (after-loop current-node children stack)))
  (define (after-loop current-node children stack)
    (display (contents-of current-node))
    (newline)
    (if (not (null? stack))
        (after-recursive-call (cadr stack) (car stack) (cddr stack))
        #t)) ;;; The #t is the equivalent of "returning true"
  (start-of-process node (children-of node) '()))

Okay, we've gotten rid of the set!'s.  Now the tail calls act as both
assignments and gotos.  Let's see if we can do a little optimization,
take out some of the "administrative" cruft that got added by the
mechanical transformations.  For example, whenever after-loop is called,
children is null, and after-loop doesn't make any use of its children
parameter, so we can just whack it, right?  Also, after-recursive-call
and start-of-process behave exactly the same way, so we can dump one
of them.  I'll dump after-recursive-call and replace the call to it with
a call to start-of-process.  After doing that, it turns out that the
"loop" procedure is only called from start-of-process, so I'll go ahead
and inline it.  Now I've got:

(define (children-of node) (cdr node))
(define (contents-of node) (car node))

(define (process node)
  (define (start-of-process current-node children stack)
    (if (not (null? children))
        (let ((new-node (car children)))
          (start-of-process new-node
                            (children-of new-node)
                            (cons (cdr children) (cons current-node stack))))
        (after-loop current-node stack)))
  (define (after-loop current-node stack)
    (display (contents-of current-node))
    (newline)
    (if (not (null? stack))
        (start-of-process (cadr stack) (car stack) (cddr stack))
        #t)) ;;; The #t is the equivalent of "returning true"
  (start-of-process node (children-of node) '()))

after-loop is only called from one place.  I'll inline it too.

(define (children-of node) (cdr node))
(define (contents-of node) (car node))

(define (process node)
  (define (start-of-process current-node children stack)
    (if (not (null? children))
        (let ((new-node (car children)))
          (start-of-process new-node
                            (children-of new-node)
                            (cons (cdr children) (cons current-node stack))))
        (begin
          (display (contents-of current-node))
          (newline)
          (if (not (null? stack))
              (start-of-process (cadr stack) (car stack) (cddr stack))
              #t))))
  (start-of-process node (children-of node) '()))

This could be made shorter by eliminating the let with the new-node
and inlining the children-of and contents-of, but I think this is a
good place to stop.

Looking this final product over, we can see that "children" is the extra
information that is stored on the stack which tells us which children
of the current node we haven't processed yet.  That's the extra information
that I mentioned way back at the beginning of this post.

The basic algorithm ends up being:
  If we have children, save where we are, marking that next time
  we start with the second child, and move to the first child.

  If we have no children, print out the contents of the current
  node and pop the
...

read more »

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
H.   	
View profile
	 More options Dec 19, 2:31 am
Newsgroups: comp.lang.scheme
From: "H." <hbe...@gmail.com>
Date: 18 Dec 2006 23:31:00 -0800
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

Vend wrote:
> Hello, I'm looking for an *iterative* algorithm to do post-order
> depth-first tree traversal. That is, given the tree:
> (a (b) (c (d)) (e))
> the algorithm should traverse the node in this order: b d c e a
> (note: the first element of a list is always an atom and the subsequent
> elements are always lists)

How is the tree being represented? That is, is the tree really a
deep-list, or is there a more abstract representation? For instance,
I've seen implementations where there is data at each node, and I've
seen implementations (like a deep list representation) where there is
conceptually only data at the leaf nodes. I'm trying to draw a picture
of your tree to visualize the problem, but am not successful. Is the a
at the root node or a leaf node...?

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Vend   	
View profile
	 More options Dec 19, 6:36 am
Newsgroups: comp.lang.scheme
From: "Vend" <ven...@virgilio.it>
Date: 19 Dec 2006 03:36:51 -0800
Local: Tues, Dec 19 2006 6:36 am
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
Thank you for your replies.

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Vend   	
View profile
	 More options Dec 19, 8:36 am
Newsgroups: comp.lang.scheme
From: "Vend" <ven...@virgilio.it>
Date: 19 Dec 2006 05:36:10 -0800
Local: Tues, Dec 19 2006 8:36 am
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

- Hide quoted text -
- Show quoted text -
H. wrote:
> Vend wrote:
> > Hello, I'm looking for an *iterative* algorithm to do post-order
> > depth-first tree traversal. That is, given the tree:
> > (a (b) (c (d)) (e))
> > the algorithm should traverse the node in this order: b d c e a
> > (note: the first element of a list is always an atom and the subsequent
> > elements are always lists)

> How is the tree being represented? That is, is the tree really a
> deep-list, or is there a more abstract representation? For instance,
> I've seen implementations where there is data at each node, and I've
> seen implementations (like a deep list representation) where there is
> conceptually only data at the leaf nodes. I'm trying to draw a picture
> of your tree to visualize the problem, but am not successful. Is the a
> at the root node or a leaf node...?

node ::= (content {node})

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Vend   	
View profile
	 More options Dec 19, 8:38 am
Newsgroups: comp.lang.scheme
From: "Vend" <ven...@virgilio.it>
Date: 19 Dec 2006 05:38:20 -0800
Local: Tues, Dec 19 2006 8:38 am
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

Vend wrote:
> node ::= (content {node})

Sorry:

<node> ::= "("<content> {<node>}")"

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
	
		
Vend   	
View profile
	 More options Dec 19, 8:44 am
Newsgroups: comp.lang.scheme
From: "Vend" <ven...@virgilio.it>
Date: 19 Dec 2006 05:44:53 -0800
Local: Tues, Dec 19 2006 8:44 am
Subject: Re: Tree traversal
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

Andru Luvisi wrote:

<snip>

Thank you for the explanation.

> Another approach to solving your problem of running two recursive
> procedures in parallel is coroutines (or generators, which are really
> a restricted kind of coroutines).  Coroutines are fairly easy to
> implement in Scheme using continuations.  In this case, though, the
> iterative version is probably easier, and I'm getting tired.  I can
> dig up some references on coroutines tomorrow if you're interested.

Unfortunately, the in implementation I use (GNU/Guile) usage of
continuation is discouraged because they are too slow (they say that
since Guile mixes C and scheme functions in the stack, capturing and
calling continuation is implemented by copying the whole thread stack
in and from the heap).

Anyway, I'm intrested.

> Wow, this ended up a lot longer than I expected.  If you read all the
> way through it, I hope it was worth the effort.  :-)

Yes

  ReplyReply to authorForward     Rate this post: Text for clearing space
		
		
		
End of messages - back to Discussions 	
No newer topics 	  	Newbie question: define-sintax macros  -  Older topic »

	
Create a group - Google Groups - Google Home - Terms of Service - Privacy Policy
©2006 Google
