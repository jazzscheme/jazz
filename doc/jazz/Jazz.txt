KERNEL
======

The kernel represents the Jazz runtime.

The kernel implements a thin layer on top of the underlying Scheme system that
implements a language agnostic module and package system. The system supports dynamic
discovery of packages and hierarchycal naming of modules.

A Jazz application can be seen as a built kernel + libraries of packages.

To build the kernel, launch the build system and type 'make kernel'. This will create
a jazz.exe executable in your installation directory.

Note that a Jazz kernel statically includes the whole underlying Scheme so that
for instance, a kernel built on top of Gambit has access to every feature and API
of Gambit.

Repository
----------

A repository is where packages are located.

A repository is simply a directory that will be scanned for packages. Note that
repository order is important as it defines search precedence.

The kernel defines three standard repositories:

- Install
    This repository is where the build system will build all modules. For instance,
    if you built your kernel on Windows with 'release' safety, the directory would be
    bin/GambitWindowsRelease/lib. Note that by creating distinct install directories,
    the build system supports multiple configurations.
- Jazz
    The Jazz source repository located in lib. Note that a compiled module can
    potentially be found in more than one repository. For instance as a binary compiled
    module and as source module. When loading, the kernel will choose the latest modified.
    This greatly eases development as you never have to recompile to test a change as
    the module system will automatically load the newer source code over the compiled one.
- User
    The user's repository located in ~/.jazz/lib. This is where you should put
    your Jazz code.

Package
-------

A package is the deployment unit that groups together related resources like code modules.
Packages are discovered automatically and their order within their repository should not
be relevant. They are similar in function to Ruby gems, Chicken eggs, Gambit snowballs, ...

Every package needs a manifest file at the toplevel. This file contains meta information
about the package and should be name with the same name as the package with .pck extension.

Example: org.jedi.pck

(package org.jedi
  
  (root "src")
  (products (jedi (module jedi.product) (dependencies platform))))

Product
-------

A product is the runtime implementation of some user level entity that can be run and
built. They correspond to targets in the build system. For instance, when doing 'make jedi',
the build system will find the 'jedi' product and ask it to build itself.

Products are listed inside their package manifest.

Resource
--------

A resource is a triplet (package path . extension) representing a resource inside
a package.

Arguments
---------

The kernel recognizes the following command-line arguments:
-run <product> : run <product>
-debug <flag> : if <flag> is #t, try connecting to Jedi for remote debugging


JAZZ
====

The Jazz language is implemented as a single 'org.jazz' package.


JEDI
====

Jedi is the IDE. It is implemented inside the 'org.jedi' package.


USER
====

The HOME/.jazz directory is called the user directory. It contains user wide settings
that the kernel will always apply. See the section about profiles for ways to create
separate sets of customizations.

.jazzini
  The kernel will load early this Scheme file that can be used to customize
  many of the kernel's features.


PROFILE
=======

A profile is a set of Jedi preferences.

Profiles are located in the org.jedi.profiles package inside the User repository. For
example, if a 'Me' profile is created, it will contain the following files:

HOME
  .jazz
    .jazzini
    lib
      org.jedi.profiles
        profile
          Me
            _Me.jazz
            Me-Project.jazz
            settings
              Bindings.jml
              Preferences.jml
              WebServers.jml
              Workbench.jml

The reason profiles reside inside a package is that they contain Jazz code. In the example
above, the _Me.jazz module contains a Me class that can be used to customize the IDE,
experiment with code, ...

One nice way of using your profile is to test your code there is a very Lispish interactive
fashion and when it is functional, migrate it to it's own module.


SCHEME
======

Jazz fully supports every Scheme feature of the underlying Scheme system. By using Scheme's
load primitive, you can load any existing Scheme code.


MODULE
======

A Module is basically a file of Scheme code that was given a name. That name can then be used
to load, compile, ... the module. The kernel will automatically located the module by searching
all packages and ensure that it is loaded only once.

Syntax:

(module <name>

(require (<module-name>)
         ...)

<expr>
...)

Example:

(module fib

(define (fib n)
  (if (or (= n 0) (= n 1))
      n
    (+ (fib (- n 1)) (fib (- n 2))))))

(module test

(require (fib))

...)


LIBRARY
=======

A library is a module that implements a specific dialect. A library will walk it's code and
resolve all symbols at walk time.

Currently supported dialects are:
- scheme
- jazz

Syntax:

(library <name> <dialect-name>

(require (<module-name>)
         ...)

(export (<module-name>)
         ...)

(import)

<expr>
...)

Example:

(library jazz.sample.world jazz

(import (jazz.platform)
        (jazz.system)
        (jazz.system.process)
        (jazz.utilities))

(class World extends Process
  
  (method (start-process)
    (message-box "Hello World!")
    (exit-process))))
