;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; JAS Server
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jas.server jazz


(import (jazz.associative)
        (jazz.associative.remote)
        (jazz.io)
        (jazz.network)
        (jazz.zlib))


(definition jas-server
  #f)

(definition jas-directory
  #f)


(definition package (start-jas-server)
  (let ((host (let ((arg (command-argument "host")))
                (or arg "*")))
        (directory (let ((arg (command-argument "directory")))
                     (if (not arg)
                         (current-directory-get)
                       (new Directory (tokenise-filename arg))))))
    (let ((server (new Jas-Server host: host service: jas-service)))
      (start server)
      (set! jas-server server)
      (set! jas-directory directory))))


(definition package (stop-jas-server)
  (when jas-server
    (stop jas-server)
    (set! jas-server #f)))


;;;
;;;; Server
;;;


(definition (jas-server-connect port)
  (define (reply response)
    (write-binary-object response port)
    (force-output port))
  
  (let ((key (read-binary-object port)))
    (if (not (equal? key jas-key))
        (reply 'invalid-key)
      (let ((path (read-binary-object port)))
        (let ((directory (new-directory jas-directory path)))
          (if (not (exists? directory))
              (reply 'inexistant-repository)
            (reply 'connected)
            (let ((repository (register-shared-repository directory)))
              (let ((connection (new Jas-Connection port directory repository)))
                (send-entries connection)
                (process connection)))))))))


(definition (jas-server-deconnect directory)
  (unregister-shared-repository directory))


(class Jas-Server extends TCP-Server
  
  
  (method override (server-name self)
    'jas-server)
  
  
  (method override (connection-name self)
    'jas-connection)
  
  
  (method override (accept-connection self port)
    (jas-server-connect port)))


;;;
;;;; Shared
;;;


(definition shared-repositories
  (make-table test: pathname=? hash: pathname-hash))

(definition shared-mutex
  (make-mutex 'shared))


(definition (register-shared-repository directory)
  (mutex-lock! shared-mutex)
  (prog1 (let ((shared (table-ref shared-repositories directory #f)))
           (if (not shared)
               (let ((shared (new Shared-Repository directory)))
                 (table-set! shared-repositories directory shared)
                 shared)
             (increase-count! shared)
             shared))
    (mutex-unlock! shared-mutex)))


(definition (unregister-shared-repository directory)
  (mutex-lock! shared-mutex)
  (let ((shared (table-ref shared-repositories directory)))
    (when (<= (decrease-count! shared) 0)
      (when (get-modified? shared)
        (save-to-file (get-index shared)))
      (table-clear shared-repositories directory)))
  (mutex-unlock! shared-mutex))


(class Shared-Repository extends Associative-Repository
  
  
  (slot count     initialize 1  getter generate)
  (slot modified? initialize #f accessors generate)
  
  
  (method protected (increase-count! self)
    (increase! count)
    count)
  
  (method protected (decrease-count! self)
    (decrease! count)
    count))


;;;
;;;; Connection
;;;


(class Jas-Connection extends Object
  
  
  (slot port        getter generate)
  (slot directory   getter generate)
  (slot repository  getter generate)
  (slot save-index? getter generate)
  
  
  (method override (initialize self port directory repository)
    (nextmethod self)
    (set! self.port port)
    (set! self.directory directory)
    (set! self.repository repository)
    (set! self.save-index? #f))
  
  
  (method protected (send-entries self)
    (write-deflated-object (entries->list (get-entries (get-index repository))) port)
    (force-output port))
  
  
  (method protected (process self)
    (declare (proper-tail-calls))
    (let (loop)
      (let ((request (read-binary-object port)))
        (if (eof-object? request)
            (unregister-shared-repository directory)
          (bind (command . arguments) request
            (case command
              ((deconnect)
               (jas-server-deconnect directory))
              ((download)
               (let ((what (car arguments)))
                 (cond ((eq? what 'all)
                        (download-all self)
                        (loop))
                       (else
                        (download-file self what (cadr arguments))
                        (loop)))))
              ((upload)
               (let ((what (car arguments)))
                 (cond ((eq? what 'all)
                        (upload-all self)
                        (loop))
                       (else
                        (upload-file self what (cadr arguments) (caddr arguments))
                        (loop)))))))))))
  
  
  (method protected (download-all self)
    (let ((changes (list->changes (read-deflated-object port))))
      (for-each (lambda (change)
                  (bind (what path) change
                    (case what
                      ((added modified)
                       (let ((content (car (jas-retrieve-content repository path))))
                         (write-binary-content content port))))))
                changes))
    (force-output port))
  
  
  (method protected (download-file self path new-set)
    (let ((content (car (jas-retrieve-content repository path))))
      (write-binary-content content port)
      (force-output port))
    (when new-set
      (let ((entry (find-entry repository path)))
        (when (neq? (get-set entry) new-set)
          (set-set entry new-set)
          (set-modified? repository #t)))))
  
  
  (method protected (upload-all self)
    (let ((index (get-index repository)))
      (let ((entries (list->entries (read-deflated-object port)))
            (changes (list->changes (read-deflated-object port))))
        (for-each (lambda (change)
                    (bind (what path . rest) change
                      (case what
                        ((added modified)
                         (let ((content (read-binary-content port)))
                           (let ((entry (car rest)))
                             (let ((digest (get-digest entry))
                                   (flags (get-flags entry)))
                               (store-object repository content digest)
                               (unless (bare? repository)
                                 (let ((file (new-file (get-working repository) (tokenise-filename path))))
                                   (retrieve-file repository digest file flags))))))))))
                  changes)
        (setup-entries index entries)
        (save-to-file index))))
  
  
  (method protected (upload-file self path digest flags)
    (let ((index (get-index repository)))
      (let ((content (read-binary-content port)))
        (let ((file (new-file (get-working repository) (tokenise-filename path))))
          (store-object repository content digest)
          (retrieve-file repository digest file flags)
          (let ((entry (list path digest (get-last-modification-seconds file) flags)))
            (update index path 'file (list entry))
            (save-to-file index))))))))
