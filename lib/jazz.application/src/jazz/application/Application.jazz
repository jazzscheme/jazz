;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Applications
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.application.Application jazz


(require (jazz.ui.skin))

(import (jazz.action)
        (jazz.application)
        (jazz.application.services)
        (jazz.clipboard)
        (jazz.command)
        (jazz.component)
        (jazz.debuggee)
        (jazz.designer)
        (jazz.document)
        (jazz.event)
        (jazz.exemplar)
        (jazz.graphic)
        (jazz.handler)
        (jazz.history)
        (jazz.io)
        (jazz.layout)
        (jazz.locale)
        (jazz.markup)
        (jazz.menu)
        (jazz.outline)
        (jazz.platform)
        (jazz.preferences)
        (jazz.print)
        (jazz.process)
        (jazz.profile)
        (jazz.project)
        (jazz.recorder)
        (jazz.reference)
        (jazz.remote)
        (jazz.runtime)
        (jazz.settings)
        (jazz.skin)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(class Application extends Process implements (History-Provider Event-Consumer Save-Environment-Listener)


  (slot toplevel                 initialize #f)
  (slot focus-listeners          initialize '())
  (slot application-listeners    initialize (make-table test: eq?))
  (slot selected-owner           initialize #f                        getter generate)
  (slot selected                 initialize #f)
  (slot selected-listeners       initialize '())
  (slot event-consumer           initialize self)
  (slot history-manager          initialize (new History-Manager self))
  (slot active?                  initialize #f                        getter generate)
  (slot application-actions      initialize '()                       getter generate)
  (slot profile-actions          initialize '()                       getter generate)
  (slot guest-actions            initialize '()                       getter generate)
  (slot focus-actions            initialize '()                       getter generate)
  (slot bindings-designer        initialize #f                        getter generate)
  @skin-convert
  (slot skins-designer           initialize #f                        getter generate)
  (slot workspaces-designer      initialize #f                        getter generate)
  (slot shortcut-table           initialize #f)
  (slot shortcut-hook            initialize #f                        accessors generate)
  
  
  (method meta override (external-name self . rest)
    'application)

  
  ;;;
  ;;;; Access
  ;;;


  (method override (get-toplevel self)
    toplevel)
  
  
  (method override (is-application? self)
    #t)


  ;;;
  ;;;; Startup
  ;;;
  
  
  (method override (prepare-bindings self)
    (nextmethod self)
    ;; this is critical as any problem in the boot process
    ;; might display a message-box that needs basic bindings
    (set-current-bindings (new Application-Bindings)))
  
  
  (method override (prepare-locales self)
    (nextmethod self)
    (register-locale-change (get-locale-state) (~ locale-change self)))
  
  
  ;; quick hack
  (method override (prepare-platform self)
    (initialize-platform))


  (method override (prepare-profile self)
    (nextmethod self)
    (set-current-application self)
    (setup-shortcuts self)
    (prepare-window-manager self))


  (method override (prepare-environment self)
    (nextmethod self)
    (prepare-colors self)
    (prepare-fonts self)
    (prepare-formats self)
    (prepare-styles self)
    (provide-services self))

  
  (method override (install-environment self)
    (nextmethod self)
    (install-skins self)
    (install-bindings self)
    (install-workspaces self)
    (initialize-toplevel self)
    (initialize-clipboard)
    (register-clipboard-formats self))


  (method override (finalize-environment self)
    (nextmethod self)
    (set-cursor :arrow)
    (splash-screen self))

  
  (method override (setup-profile self)
    (define (create-profile)
      (with-safe-execution "loading the profile"
        (lambda ()
          (set! profile (if (find-unit-source profile-class)
                            (new (load-profile-class profile-class))
                          (new-default-profile self))))
        continue-text: (list (format "to bypass this problem by using a generic profile class"))
        continue-handler:
        (lambda (err)
          (set! profile (new-default-profile self)))))
    
    (when (use-profile? self)
      (create-profile)
      (set-profile-actions self (get-class-actions profile))))
  
  
  (method override (finish-environment self)
    (nextmethod self)
    (add-save-environment-listener self self)
    (when profile
      (with-safe-execution "initing the profile"
        (lambda ()
          (init profile))
        continue-handler:
        (lambda (err)
          )))
    (reload-session self)
    (remove-splash-screen self))
  
  
  (method override (finish-process self)
    (nextmethod self)
    (select-default-workspace self)
    (update-focus-actions self)
    (update-windowing-actions self))
  
  
  (method override (conclude-environment self)
    (nextmethod self)
    (initialize-actions self)
    (look-update)
    (show-toplevel self)
    (when (run-loop?)
      (select-foreground toplevel))
    (when profile
      (with-safe-execution "finalizing the profile"
        (lambda ()
          (finalize profile))
        continue-handler:
        (lambda (err)
          ))))
  
  
  ;;;
  ;;;; Termination
  ;;;
  
  
  (method override (terminate-process self)
    (nextmethod self)
    (reset-palettes)
    (reset-dockeds)
    (reset-toolbars)
    (when toplevel
      (close toplevel)
      (set! toplevel #f)
      (set! profile-class #f)
      (set! profile #f)))


  ;;;
  ;;;; Java
  ;;;
  
  
  @test-java
  (definition Java-Classpath
    '({File "C:" "Java" "j2sdk1.4.2_04" "jre" "lib" "rt.jar"}
      {File "C:" "Java" "BCEL" "lib" "bcel-5.1.jar"}
      {File "C:" "Java" "JDBC" "msbase.jar"}
      {File "C:" "Java" "JDBC" "msutil.jar"}
      {File "C:" "Java" "JDBC" "mssqlserver.jar"}))
  
  
  @test-java
  (method (test-java)
    (setup-jvm classpath: Java-Classpath)
    (c-test)
    (let* ((loader (getSystemClassLoader java.lang.ClassLoader))
           (class (forName java.lang.Class "yo" #t loader)))
      (message-box (format "{a}" class))))


  ;;;
  ;;;; Loop
  ;;;


  (method override (start-loop self)
    (set-preference (current-preferences-root) 'first-startup? #f)
    (thread-priority-boost-set! (event-thread) 1)
    (process-events))


  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (clipboard-prefix self)
    (format "{a}_{a}_"
            (process-name self)
            (present (process-version self))))
  
  
  (method protected virtual (register-clipboard-formats self)
    (register-jazz-clipboard-formats (clipboard-prefix self)))


  ;;;
  ;;;; Clipboard Ring
  ;;;

  
  (definition Clipboard-Ring
    '())
  
  (definition Max-Ring
    256)
  
  
  (method public (get-clipboard-ring self)
    Clipboard-Ring)
  
  
  (method public (empty-clipboard-ring? self)
    (null? Clipboard-Ring))
  
  
  (method public (add-clipboard self)
    (let ((clipboard (get-clipboard)))
      (when clipboard
        (set! Clipboard-Ring (cons clipboard Clipboard-Ring))
        (trim-clipboard)
        (update-focus-actions self))))
  
  
  (method public (push-clipboard-list self list)
    (let ((pushed (length list)))
      (if (> pushed Max-Ring)
          (error "Unable to push list of {a} onto the clipboard ring" pushed)
        (set! Clipboard-Ring (append list Clipboard-Ring))
        (trim-clipboard)
        (update-focus-actions self))))
  
  
  (definition (trim-clipboard)
    (when (> (length Clipboard-Ring) Max-Ring)
      (set-cdr! (tail Clipboard-Ring (- Max-Ring 1)) '())))
  
  
  (method (pop-clipboard self)
    (let ((clipboard (car Clipboard-Ring)))
      (set! Clipboard-Ring (cdr Clipboard-Ring))
      (set-clipboard clipboard)
      (update-focus-actions self)
      clipboard))

  
  (method package (paste-cycle-ring self reversed?)
    (define (cycle-clipboard)
      (set! Clipboard-Ring (append (cdr Clipboard-Ring) (list (car Clipboard-Ring))))
      (car Clipboard-Ring))
    
    (define (cycle-clipboard-reversed)
      (set! Clipboard-Ring (cons (last Clipboard-Ring) (butlast Clipboard-Ring)))
      (car Clipboard-Ring))
    
    (if (null? Clipboard-Ring)
        (bell)
      (let ((focus (active-focus))
            (previous-clipboard (get-clipboard)))
        (let ((clipboard (if reversed?
                             (cycle-clipboard-reversed)
                           (cycle-clipboard))))
          (set-clipboard clipboard)
          (cycle-paste-clipboard focus previous-clipboard clipboard)))))
  
  
  (method package (on-copy-formatted self evt)
    (let ((focus (active-focus)))
      (if (is-not? focus Text-View)
          (bell)
        (copy-formatted-selection focus))))
  
  
  (method package (on-paste-cycle-ring self evt)
    (paste-cycle-ring self #f))


  (method package (on-paste-cycle-ring-reversed self evt)
    (paste-cycle-ring self #t))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method package (on-add-history self evt)
    (add-current history-manager))
  
  
  (method package (on-backward-history self evt)
    (go-backward-history history-manager))
  
  
  (method package (on-forward-history self evt)
    (go-forward-history history-manager))
  
  
  (method public (add-history self item)
    (add-history history-manager item))
  
  
  (method override (current-history-item self)
    (let ((frame (current-frame)))
      (and frame
           (let ((guest (get-guest frame)))
             (and (is? guest Document)
                  (current-history-item guest))))))
  
  
  (method override (update-history-actions self)
    (let ((backward (get-backward-history history-manager))
          (forward (get-forward-history history-manager)))
      (set-action-enabled? {Action application backward-history} (not-null? backward))
      (set-action-enabled? {Action application forward-history} (not-null? forward))))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method public virtual (get-recorder self)
    #f)
  
  
  (method package (macro-recording? self)
    (let ((recorder (get-recorder self)))
      (and recorder (get-recording? recorder))))
  
  
  (method package (macro-playing? self)
    (let ((recorder (get-recorder self)))
      (and recorder (get-playing? recorder))))
  
  
  (method package (macro-active? self)
    (let ((recorder (get-recorder self)))
      (and recorder
           (or (get-recording? recorder)
               (get-playing? recorder)))))


  ;;;
  ;;;; Profile
  ;;;
  
  
  (method protected virtual (use-profile-logging? self)
    #f)
  
  
  (method override (log-profile self)
    (define (login-profile)
      (receive (name unit template always-use?) (choose-profile-login self)
        (cond-expand
          ;; to make dialog close more responsive
          (mac (poll-events))
          (else))
        (let ((one-shoot? (shift-down?)))
          (when settings
            (unless one-shoot?
              (set-setting settings 'profile (if always-use? (->string name) #f)))
            (when (and always-use? (not one-shoot?) (not (get-setting settings 'profile-warned? #f)))
              (message-box (format "{a} will now always start using profile {a}. Note that you can always get this dialog back by keeping the shift key pressed when launching."
                                   (process-name self)
                                   name))
              (set-setting settings 'profile-warned? #t))
            (save-content settings))
          (values name unit template))))
    
    (define (system-profile)
      (values 'Me 'jazz.profile (profile-kind self))
      @convert
      (standard-profile (get-system-user-name)))
    
    (define (load-profile-jazzini)
      (let ((file {File Profile ".jazzini"}))
        (when (exists? file)
          (load (parse file)))))
    
    (let ((use-logging? (use-profile-logging? self)))
      (let ((profile-arg (and (or (not use-logging?) (not (shift-down?))) (or (jazz-profile) (profile-parameter self)))))
        (receive (name unit template) (cond (profile-arg (standard-profile self (->string profile-arg)))
                                            (use-logging? (login-profile))
                                            (else (system-profile)))
          (set! profile-class (compose-identifier unit name))
          (install-profile self name unit template)
          (load-profile-jazzini)))))
  
  
  (method protected virtual (choose-profile-login self)
    )


  ;;;
  ;;;; Closing
  ;;;
  
  
  (method override (preserve-environment self)
    (nextmethod self)
    (call-save-environment-listeners self))
  
  
  (method override (close-environment self)
    ;; called before closing frames because saving a class form
    ;; can potentialy modify an opened text
    (call-quit-listeners self)
    (confirm-all-close self)
    (close-all-no-confirm self)
    (save-bindings self)
    (save-workspaces self)
    (save-page-setup self)
    (nextmethod self))
  
  
  (method virtual (confirm-all-close self)
    (define (frame-dependent-document? frame)
      (and (is? frame Host-View)
           (let ((guest (get-guest frame)))
             (and (is? guest Document)
                  (let ((controller (get-document-controller guest)))
                    (dependent-document? controller))))))
    
    (for-each (lambda (frame)
                (unless (frame-dependent-document? frame)
                  (confirm-close frame)))
              (all-frames include-invisibles?: #t)))
  
  
  (method (close-all self)
    (for-each close-host (all-frames include-invisibles?: #t)))
  
  
  (method (close-all-no-confirm self)
    (for-each (lambda (host)
                (close-host host confirm?: #f))
              (all-frames include-invisibles?: #t)))


  ;;;
  ;;;; Splash
  ;;;
  
  
  (definition Splash-Screen
    #f)
  
  (definition Splash-End
    #f)
  
  
  (method protected virtual (splash-screen self)
    )
  
  
  (method (show-splash-screen self (duration: duration #f))
    (set! Splash-Screen (show-splash self))
    (set! Splash-End (and duration (+ (current-seconds) duration))))
  
  
  (method (remove-splash-screen self)
    (when Splash-Screen
      (let ((time (current-seconds)))
        (when (and Splash-End (> Splash-End time))
          (sleep (- Splash-End time)))
        (remove-splash self Splash-Screen))))
  
  
  (method protected virtual (show-splash self)
    )
  
  
  (method protected virtual (remove-splash self splash-screen)
    )


  ;;;
  ;;;; Help
  ;;;
  
  
  (method public virtual (show-help self)
    #f)
  
  
  (method package (on-about self evt)
    (show-about self))
  
  
  (method public virtual (show-about self)
    (let ((name (process-name self))
          (owner (process-owner self))
          (copyright (process-copyright self))
          (licensee (process-licensee self))
          (version (present (process-version self)))
          (email (process-email self)))
      (message-box
        `(<span>
           (<paragraph> (<text> font: Text color: Dark-Blue ,(format "{a} v{a}" name version)))
           (<paragraph>)
           ,@(if owner
                 `((<paragraph> (<text> font: Text ,(format "Copyright {a}{a}" (if copyright (format "{a} " copyright) "") owner)))
                   (<paragraph>))
               '())
           ,@(if licensee
                 `((<paragraph> ,(localize {Locales english: "This product is licensed to " french: "Ce produit est autorisé à "}) (list licensee))
                   (<paragraph>))
               '())
           ,@(if email
                 `((<paragraph> ,(localize {Locales english: "Send comments, suggestions, bugs,... to:" french: "Envoyer vos commentaires, suggestions, problèmes,... à:"}))
                   (<paragraph> ,email))
               '()))
        title: (format "{a} {a}" (localize {Locales english: "About" french: "À propos de"}) name))))


  ;;;
  ;;;; Quit
  ;;;
  

  (slot quit-listeners initialize '())
  
  
  (method public (add-quit-listener self listener)
    (set! quit-listeners (cons listener quit-listeners)))
  
  
  (method public (remove-quit-listener self listener)
    (set! quit-listeners (remove! listener quit-listeners)))
  
  
  (method public (call-quit-listeners self)
    (for-each prepare-quit quit-listeners))


  ;;;
  ;;;; Activation
  ;;;
  
  
  (method public virtual (deactivate self)
    (when active?
      (close-popups toplevel)
      (reset-mouse-in)
      (set! active? #f)))
  
  
  (method public virtual (activate self)
    (unless active?
      (set! active? #t)
      (activate-verify-reloads self)))
  
  
  (cond-expand
    (cocoa
     (method (activate-verify-reloads self)
       (delay-event
         (lambda ()
           (verify-reloads self)))))
    (else
     (method (activate-verify-reloads self)
       (verify-reloads self))))
  
  
  (method public (verify-reloads self)
    (define (collect-reloads)
      (collect (lambda (view)
                 (and (is? view Frame-Host)
                      (let ((guest (get-guest view)))
                        (and (is? guest Document)
                             (let ((controller (get-document-controller guest)))
                               (and (needs-reload? controller)
                                    controller))))))
               (all-frames include-invisibles?: #t)))
    
    (let ((reloads (collect-reloads)))
      (when (not-null? reloads)
        (let ((partition (partition reloads key: class-of test: eq?)))
          (for-each (lambda (category)
                      (let ((code (propose-multiple-reloads (car category))))
                        (with-cursor :wait
                          (lambda ()
                            (for-each (lambda (controller)
                                        (propose-reload-action controller code))
                                      (cdr category))))))
                    partition)))))
  
  
  (method public (verify-reload self moniker)
    (let ((frame (find-document self moniker)))
      (when frame
        (let ((document (get-guest frame)))
          (verify-reload (get-document-controller document))))))


  ;;;
  ;;;; Environment
  ;;;
  

  (slot save-environment-listeners initialize '())
  
  
  (method public (add-save-environment-listener self listener)
    (set! save-environment-listeners (cons listener save-environment-listeners)))
  
  
  (method public (remove-save-environment-listener self listener)
    (set! save-environment-listeners (remove! listener save-environment-listeners)))
  
  
  (method public (call-save-environment-listeners self)
    (for-each (lambda (listener)
                (save-environment listener))
              save-environment-listeners))
  
  
  ;;;
  ;;;; Session
  ;;;
  
  
  (method public (reload-session self)
    (reload-opened-windows self))
  
  
  (method public virtual (reload-opened-windows self)
    )
  
  
  (method public virtual (reload-component self class properties)
    )

  
  (method override (save-environment self)
    (define (save-application)
      (let ((process-preferences (current-preferences-root)))
        (when process-preferences
          @convert/wait
          (set-preference process-preferences active-context: context)
          (set-preference process-preferences current-directory: (current-directory-get)))))
    
    (define (save-all-guest)
      @wait
      (for-each (lambda (frame)
                  (when (is? frame Host-Frame)
                    (let ((guest (get-guest frame)))
                      (when guest
                        (save-guest guest session-designer session)))))
                (all-frames include-invisibles?: #t)))
    
    (save-application)
    (save-all-guest))

  
  ;;;
  ;;;; Window Manager
  ;;;
  
  
  (method protected virtual (prepare-window-manager self)
    (set-window-manager (new Window-Manager)))

  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method public virtual (widget-display-aliases? self)
    #t)
  
  
  (method public virtual (widget-display-protocol? self)
    #t)
  
  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (method (prepare-colors self)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Colors.jml"}))
        (when (exists? file)
          (register-children (instantiate (read-form file)) (colors-domain))))))


  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method (prepare-fonts self)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Fonts.jml"}))
        (when (exists? file)
          (register-children (instantiate (read-form file)) (fonts-domain))))))


  ;;;
  ;;;; Formats
  ;;;
  
  
  (method (prepare-formats self)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Formats.jml"}))
        (when (exists? file)
          (register-children (instantiate (read-form file)) (formats-domain))))))


  ;;;
  ;;;; Styles
  ;;;
  
  
  (method (prepare-styles self)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Styles.jml"}))
        (when (exists? file)
          (register-children (instantiate (read-form file)) (styles-domain))))))


  ;;;
  ;;;; Services
  ;;;
  
  
  (method protected virtual (provide-services self)
    ;; platform
    (provide-service 'drop-file-callback (~ drop-file self))
    (provide-service 'quit-callback (~ quit-process self))
    (provide-service 'user-notification (~ user-notification self))
    ;; feedback
    (provide-service 'user-message user-message)
    (provide-service 'user-feedback user-feedback)
    (provide-service 'clear-user-message clear-user-message)
    (provide-service 'clear-user-feedback clear-user-feedback)
    (provide-service 'console-feedback console-feedback)
    (provide-service 'modal-feedback message-box)
    ;; edition
    (provide-service 'edit-document (~ edit-document self)))

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (add-focus-listener self listener)
    (set! focus-listeners (add-listener listener focus-listeners)))
  
  
  (method public (remove-focus-listener self listener)
    (set! focus-listeners (remove-listener listener focus-listeners)))

  
  (method package (process-focus-change self new-focus)
    (when focus-listeners
      (let ((evt (new Focus-Event :focus-change self (modifiers-mask) new-focus)))
        (for-each (lambda (listener)
                    (invoke listener self evt))
                  focus-listeners)))
    (update-focus-actions self))
  
  
  (method public virtual (update-focus-actions self)
    (let* ((focus (active-focus))
           (view? (and focus (is? focus View))))
      (when preferences-designer
        (set-action-enabled? {Action view undo} (and view? (can-view-undo? focus)))
        (set-action-enabled? {Action view redo} (and view? (can-view-redo? focus)))
        (set-action-enabled? {Action view cut} (and view? (can-view-cut? focus)))
        (set-action-enabled? {Action view copy} (and view? (can-view-copy? focus)))
        (set-action-enabled? {Action application copy-formatted} (and view? (can-view-copy? focus)))
        (set-action-enabled? {Action view paste} (and view? (can-view-paste? focus)))
        (set-action-enabled? {Action application paste-cycle-ring} (and view? (can-view-paste? focus) (not-null? Clipboard-Ring)))
        (set-action-enabled? {Action application paste-cycle-ring-reversed} (and view? (can-view-paste? focus) (not-null? Clipboard-Ring)))
        (set-action-enabled? {Action view paste-properties} (and view? (can-view-paste-properties? focus)))
        (set-action-enabled? {Action view delete} (and view? (can-view-delete? focus)))
        (set-action-enabled? {Action view select-all} (and view? (can-view-select-all? focus)))
        (when view?
          (focus-update-actions focus)))))
  
  
  ;;;
  ;;;; Selected
  ;;;
  
  
  (method public (add-selected-listener self listener)
    (set! selected-listeners (add-listener listener selected-listeners)))
  
  
  (method public (remove-selected-listener self listener)
    (set! selected-listeners (remove-listener listener selected-listeners)))
  
  
  (method public (get-selected self)
    selected)
  
  
  (method public (set-selected self owner sel (force?: force? #f))
    (let ((new-owner? (neq? owner selected-owner)))
      (when (or force? new-owner? (neq? sel selected))
        (process-selected-change self owner selected sel force?))))
  
  
  (method public (close-selected self owner)
    (when (eq? owner selected-owner)
      (set! selected-owner #f)
      (process-selected-change self #f selected #f #f)))

  
  (method (process-selected-change self owner old-selected new-selected force?)
    (set! selected-owner owner)
    (set! selected new-selected)
    (when (and selected-listeners (not (unloading-process?)))
      (let ((evt (new Selected-Event :selected-change self (modifiers-mask) owner old-selected new-selected force?: force?)))
        (for-each (lambda (listener)
                    (invoke listener self evt))
                  selected-listeners))))

  
  ;;;
  ;;;; Application
  ;;;
  
  
  (method public (add-application-listener self category listener)
    (set-application-listeners self category (add-listener listener (get-application-listeners self category))))
  
  
  (method public (remove-application-listener self category listener)
    (set-application-listeners self category (remove-listener listener (get-application-listeners self category))))

  
  (method package (process-application-event self category kind sender . properties)
    (let ((listeners (get-application-listeners self category)))
      (let ((evt (apply make-event Application-Event kind sender properties)))
        (for-each (lambda (listener)
                    (invoke listener self evt))
                  listeners))))
  
  
  (method (get-application-listeners self category)
    (table-ref application-listeners category '()))
  
  
  (method (set-application-listeners self category listeners)
    (table-set! application-listeners category listeners))

  
  ;;;
  ;;;; Frames
  ;;;
  
  
  (method public virtual (default-frame-class self)
    #f)


  (method public virtual (file-frame-class self file)
    (let ((extension (get-extension file)))
      (or (extension-frame-class self extension)
          (error "Unknown file extension: {a}" extension))))


  (method public virtual (extension-frame-class self ext)
    (or (profile-extension-frame-class self ext)
        (known-extension-frame-class self ext)
        (unknown-extension-frame-class self)))
  
  
  (method (profile-extension-frame-class self ext)
    (and profile
         (extension-frame-class profile ext)))


  (method public virtual (known-extension-frame-class self ext)
    #f)
  
  
  (method public virtual (unknown-extension-frame-class self)
    #f)


  (method public virtual (frame-class self (file: file #f))
    (if (not file)
        (default-frame-class self)
      (file-frame-class self file)))
  
  
  (method (get-default-frame-class self)
    (let* ((pref (current-workspace-preferences))
           (model (get-frame-model pref)))
      (if model
          (reference-resolve model)
        (default-frame-class self))))

  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (initialize-toplevel self)
    (set! toplevel (new-toplevel self)))
  
  
  (method public virtual (new-toplevel self)
    (new Toplevel))
  
  
  (method public virtual (show-toplevel self)
    (define (setup-stage)
      (let ((stage (current-stage)))
        (when stage
          (case (find-setting 'jazz.ui.stage-state #f)
            ((restored) (restore stage))
            ((maximized) (maximize stage))))))
    
    (setup-stage)
    (set-visible? toplevel #t)
    (acquire-focus toplevel))

  
  ;;;
  ;;;; Stage
  ;;;
  
  
  (method public virtual (new-stage self)
    (new (stage-class self) parent: (new Stage-Border) name: 'stage))
  
  
  (method protected virtual (stage-class self)
    Stage)
  
  
  ;;;
  ;;;; Shortcuts
  ;;;
  
  
  (method (setup-shortcuts self)
    (set! shortcut-table (make-table test: shortcut=? hash: shortcut-hash)))
  
  
  (method (unregister-actions-shortcuts self old-actions)
    (define (unregister-shortcut action-item shortcut)
      ;; the second test is necessary because bindings can be changed on-the-fly in the ide
      (when (and shortcut (table-ref shortcut-table shortcut #f))
        (table-remove! shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each (lambda (actions)
                  (when (get-visible? actions)
                    (for-each (lambda (action-item)
                                (when (get-visible? action-item)
                                  (for-each (lambda (shortcut)
                                              (unregister-shortcut action-item shortcut))
                                            (all-shortcuts action-item))))
                              (get-children actions))))
                old-actions)))
  
  
  (method (register-actions-shortcuts self new-actions)
    (define (register-shortcut action-item shortcut)
      (when shortcut
        (table-add shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each-reversed (lambda (actions)
                           (when (get-visible? actions)
                             (for-each (lambda (action-item)
                                         (when (get-visible? action-item)
                                           (for-each (lambda (shortcut)
                                                       (register-shortcut action-item shortcut))
                                                     (all-shortcuts action-item))))
                                       (get-children actions))))
                         new-actions)))
      
  
  (method (update-actions-shortcuts self old-actions new-actions)
    (unregister-actions-shortcuts self old-actions)
    (register-actions-shortcuts self new-actions))
  
  
  (method public (update-shortcut self action-item old-shortcut new-shortcut)
    (when old-shortcut
      (table-remove! shortcut-table old-shortcut action-item))
    (when new-shortcut
      (table-add shortcut-table new-shortcut action-item)))
  
  
  (method public virtual (dispatch-shortcut self shortcut)
    (if (or (not shortcut-hook)
            (not (shortcut-hook shortcut)))
        (let ((action-items (collect-if get-action-handler (get-allowed-actions self shortcut))))
          (and (not-null? action-items)
               (let ((action (car action-items)))
                 (and (action-allowed? self action)
                      (parameterize ((event-type 'keyboard))
                        ;; the memq? is a quick hack
                        (unless (memq? (get-name action) '(start-recording stop-recording))
                          (hook-event (new Keyboard-Event :char #f (modifiers->mask (get-modifiers shortcut)) key: (get-key shortcut))))
                        (invoke action self #f)
                        #t)))))
      #t))
  
  
  (method public (get-bound-actions self shortcut)
    (table-ref shortcut-table shortcut '()))
  
  
  (method public (get-allowed-actions self shortcut)
    (define (filter-allowed actions)
      (collect-if (~ action-allowed? self) actions))
    
    (let ((actions (get-bound-actions self shortcut)))
      ;; This temporary test is because I am not sure it is what we want in general
      ;; It could be very surprising to do a shortcut that's supposed to do nothing
      ;; as it's disabled and find out that something completly different happened!
      (if (shortcut=? shortcut {Shortcut :control #\X})
          (filter-allowed actions)
        actions)))
  
  
  (method public (action-allowed? self action-item)
    (define (some-actionable-active?)
      (some? (lambda (actionable)
               (and (get-enabled? actionable)
                    (actionable-reachable? actionable)))
             (get-actionables action-item)))
    
    ;; maybe we shouldn't even use the action-item's enabled? property
    (and (get-enabled? action-item)
         (or (not (actions-orphaned? (get-parent action-item)))
             (allow-orphaned-action? self action-item)
             (some-actionable-active?))))
  
  
  (method protected virtual (allow-orphaned-action? self action-item)
    #f)
  
  
  ;;;
  ;;;; Bindings
  ;;;
  
  
  (definition Bindings-File
    {File Profile "settings" "Bindings.jml"})
  
  
  (method package (install-bindings self)
    (define (set-bindings/designer bindings)
      (set-current-bindings bindings)
      (set! bindings-designer (new (former-class self) form: (get-form bindings) reference: bindings)))
    
    (with-safe-execution "loading the bindings"
      (lambda ()
        (let ((bindings (load-bindings self)))
          (set-bindings/designer bindings)
          (let ((active (or (get-active-bindings (current-preferences #f)) 'jazz)))
            (let ((trait (locate-component bindings active)))
              (when (is? trait Trait)
                (set-base-traits bindings (list trait)))))))
      continue-handler:
      (lambda (err)
        (set-bindings/designer (default-bindings self)))))
  
  
  (method protected virtual (load-bindings self)
    (let ((file Bindings-File))
      (if (and (is-alias? 'Profile) (exists? file))
          (instantiate (read-form file))
        (default-bindings self))))
  
  
  (method protected virtual (default-bindings self)
    (new Application-Bindings))
  
  
  (method (save-bindings self)
    (when (and bindings-designer (get-modified? bindings-designer) (file? (get-origin (get-form bindings-designer))))
      (save bindings-designer)))
    
  
  ;;;
  ;;;; Skins
  ;;;
  
  
  (method protected virtual (install-skins self)
    @skin-convert
    (with-safe-execution "loading the skins"
      (lambda ()
        (let ((skins (load-skins)))
          (set-skins-designer skins)
          (set-skin (child skins (or (get-active skins) (default-skin))))))
      continue-handler:
      (lambda (err)
        (let ((skins (default-skins)))
          (set-skins-designer skins)
          (set-skin (child skins (default-skin)))))))
  
  
  (method package virtual (skins-file self)
    @skin-convert
    {File Profile "settings" "Skins.jml"})
  
  
  (method protected virtual (load-skins self)
    @skin-convert
    (let ((file (skins-file)))
      (if (and (is-alias? 'Profile) (exists? file))
          (instantiate (read-form file))
        (default-skins))))
  
  
  (method protected (set-skins-designer self skins)
    @skin-convert
    (set! skins-designer (new (former-class) form: (get-form skins) reference: skins)))
  
  
  (method (save-skins self)
    @skin-convert
    (when (and skins-designer (get-modified? skins-designer) (file? (get-origin (get-form skins-designer))))
      (save skins-designer)))

  
  ;;;
  ;;;; Workspaces
  ;;;
  
  
  (definition Workspaces-File
    {File Profile "settings" "Workspaces.jml"})
  
  
  (method (install-workspaces self)
    (define (set-workspaces-designer workspaces)
      (set! workspaces-designer (new (former-class self) form: (get-form workspaces) reference: workspaces)))
    
    (with-safe-execution "loading the workspaces"
      (lambda ()
        (set-workspaces-designer (load-workspaces self)))
      continue-handler:
      (lambda (err)
        (set-workspaces-designer (default-workspaces self)))))
  
  
  (method protected virtual (load-workspaces self)
    (let ((file Workspaces-File))
      (if (and (is-alias? 'Profile) (exists? file))
          (instantiate (read-form file))
        (default-workspaces self))))
  
  
  (method protected virtual (default-workspaces self)
    (instantiate
      (<form>
        (<Workspaces-Preferences>))))
  
  
  (method (save-workspaces self)
    (when (and workspaces-designer (get-modified? workspaces-designer) (file? (get-origin (get-form workspaces-designer))))
      (save workspaces-designer)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method public (set-application-actions self actions-list)
    (update-actions-shortcuts self application-actions actions-list)
    (set! application-actions actions-list))
  
  
  (method public (set-profile-actions self actions-list)
    (update-actions-shortcuts self profile-actions actions-list)
    (set! profile-actions actions-list))


  (method public (set-guest-actions self actions-list)
    (update-actions-shortcuts self guest-actions actions-list)
    (set! guest-actions actions-list))
  
  
  (method public (set-focus-actions self actions-list)
    (update-actions-shortcuts self focus-actions actions-list)
    (set! focus-actions actions-list))
  
  
  (method (gather-application-actions self)
    (append (global-actions self) (get-class-actions self)))
  
  
  (method (initialize-actions self)
    (set-application-actions self (gather-application-actions self)))
  
  
  (method package (updating-actions self update)
    (unregister-actions-shortcuts self application-actions)
    (update)
    (let ((actions (gather-application-actions self)))
      (register-actions-shortcuts self actions)
      (set-application-actions self actions)))

  
  ;;;
  ;;;; Menubar
  ;;;


  (method public (find-menubar self)
    (let ((host (get-toolbar :menubar)))
      (and host (in-player? host)
        (get-guest host))))
  
  
  (method public (find-menu self name)
    (let ((menubar (find-menubar self)))
      (and menubar
           (let ((menuitem (find-component menubar name)))
             (and menuitem
                  (get-content menuitem))))))
  
  
  (method public (update-menubar-buttons self)
    (let ((menubar (find-menubar self)))
      (when menubar
        (update-buttons menubar))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (definition Undisplayed-Message
    #f)


  (method public (set-status-message self msg action-handler update?)
    (let ((message (get-message-view self)))
      (if (not message)
          (set! Undisplayed-Message msg)
        (set! Undisplayed-Message #f)
        (post-event
          (lambda ()
            (set-title message (cond ((not msg) "")
                                      ((is? msg Locales) msg)
                                      (else (->string msg))))
            (set-action-handler message action-handler)))
        (when (and update? (primordial-thread?))
          (update-view message)))))


  (method public (find-status-bar self)
    (let ((host (get-toolbar :status)))
      (and host (in-player? host)
        (get-guest host))))
  
  
  (method public (get-message-view self)
    (let ((status-bar (find-status-bar self)))
      (and status-bar
           (find-component status-bar 'message))))
  
  
  (method public (show-undisplayed-message self)
    (when Undisplayed-Message
      (set-status-message self Undisplayed-Message #f #f)
      (set! Undisplayed-Message #f)))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method protected virtual (global-actions self)
    '())
  
  
  (method override (class-actions self)
    (cons (find-actions 'application)
          (nextmethod self)))


  ;;;
  ;;;; Nicknames
  ;;;
  
  
  (method override (setup-nicknames self)
    (nextmethod self)
    (register-nickname :application (lambda () self))
    (register-nickname :toplevel    (lambda () (get-toplevel self)))
    (register-nickname :modal       (lambda () (current-modal)))
    (register-nickname :menubar     (lambda () (find-menubar self)))
    (register-nickname :toolbar     (lambda () (find-toolbar self)))
    (register-nickname :status-bar  (lambda () (find-status-bar self)))
    (register-nickname :stage       (lambda () (current-stage)))
    (register-nickname :frame       (lambda () (current-frame)))
    (register-nickname :document    (lambda () (current-document)))
    (register-nickname :focus       (lambda () (active-focus)))
    (register-nickname :focus-host  (lambda () (focused-host)))
    (register-nickname :focus-guest (lambda () (focused-guest)))
    (register-nickname :images      (lambda () (get-images-portfolio self)))
    (register-nickname :bindings    (lambda () (current-bindings))))
  
  
  ;;;
  ;;;; Menus
  ;;;
  
  
  (method public virtual (text-menu self text)
    (new-text-context-menu text))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public virtual (get-logs-manager self)
    #f)
  
  
  (method public virtual (get-output-log self)
    #f)
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (definition All-Results
    #f)
  
  (definition Active-Results
    #f)
  
  
  (method public virtual (navigable-results self)
    (must-implement 'navigable-results "results navigation"))
  
  
  (method (get-navigable-results self)
    (unless All-Results
      (set! All-Results (navigable-results self)))
    All-Results)
  
  
  (method public (get-active-results self)
    (unless Active-Results
      (set! Active-Results (car (get-navigable-results self))))
    Active-Results)
  
  
  (method public (set-active-results self results)
    (set! Active-Results results))
  
  
  ;;;
  ;;;; Locales
  ;;;
  
  
  (method (locale-change self loc update?)
    (select-locale self loc)
    (when update?
      (locale-update self)))


  (method public (select-locale self locale)
    (let ((status (find-status-bar self)))
      (when status
        (let ((label (locate-component status 'locales)))
          (when label
            (set-title label (localize (present-locale (get-locale-state) locale))))))))
  
  
  (method public (locale-update self)
    (define (update-menubar)
      (let ((menubar (find-menubar self)))
        (layout-menu menubar)
        (for-each (lambda (child)
                    (when (is? child Label-Item)
                      (let ((content (get-content child)))
                        (when (is? content Menu)
                          (layout-menu content)))))
                  (get-children menubar))))
    
    (define (update-toplevel)
      (let ((toplevel (get-toplevel self)))
        (invalidate-title toplevel)
        (redraw-window toplevel)))
    
    ;; All this should of course be event based but it will do for now...
    (update-menubar)
    (update-toplevel))
  
  
  ;;;
  ;;;; Workspace
  ;;;
  
  
  (method (setup-workspaces self)
    (let ((preferences (get-workspaces-preferences)))
      (case (length (get-children preferences))
        ((0) (error "No workspaces found in Preferences.jml"))
        ((1))
        (else
         (let ((menu (find-menu self 'workspace)))
           (when menu
             (let ((actions (find-actions 'application))
                   (toolbar (find-toolbar self))
                   (active (get-active preferences)))
               (for-each (lambda (workspace)
                           (when (get-visible? workspace)
                             (let ((name (get-name workspace))
                                   (title (get-title workspace))
                                   (icon (get-icon workspace)))
                               (let ((action-name (string->symbol (format "select-{a}-workspace" name)))
                                     (event-handler (new Event-Handler target-name: :application method-name: 'on-select-workspace properties: (list workspace: name)))
                                     (selected? (eq? name active)))
                                 (new Action-Item parent: actions name: action-name action-handler: event-handler shortcut: (get-shortcut workspace))
                                 (new Radio-Item parent: menu name: (get-name workspace) title: title icon: icon before: 'delete group: 'workspace selected?: selected? action-handler: (new Action 'application action-name '()))
                                 (new Workspace-Button parent: toolbar name: name size: {Dimension 22 22} location: 'tail before: 'tail-separator group: 'workspace resource: icon portfolio: :images selected?: selected? tooltip?: #t tooltip-text: title action-handler: event-handler)
                                 (new Separator parent: toolbar size: {Dimension 1 0} location: 'tail before: 'tail-separator)))))
                         (get-children preferences))
               (new Separator-Item parent: menu before: 'delete)
               (layout-menu menu)
               (layout toolbar))))))))
  
  
  (method (select-default-workspace self)
    (define (find-workspace)
      (let ((pref (get-workspaces-preferences error?: #f)))
        (if (not pref)
            (default-workspace)
          (let ((active (get-active pref)))
            (if (not active)
                (default-workspace)
              (child pref active))))))
    
    (define (default-workspace)
      (new Default-Workspace))
    
    (apply-preferences (find-workspace)))
  
  
  (method package (on-select-workspace self evt)
    (select-named-workspace (get-property evt workspace:)))
  
  
  (method package (on-next-workspace self evt)
    (select-next-workspace))
  
  
  (method package (on-previous-workspace self evt)
    (select-previous-workspace))
  
  
  (method package virtual (on-workspace self evt)
    (case (get-kind evt)
      ((activate)
       (let ((workspace (get-property evt workspace:)))
         (activate-workspace-item self workspace)
         (activate-workspace-button self workspace)))))
  
  
  (method public undocumented (activate-workspace-item self workspace)
    (let ((menu (find-menu self 'workspace)))
      (when menu
        (let ((radio (find-component menu (get-name workspace))))
          (if (not radio)
              (unselect-elements menu class: Radio-Item group: 'workspace)
            (set-selected? radio #t))))))
  
  
  (method public undocumented (activate-workspace-button self workspace)
    (let ((toolbar (find-toolbar self))
          (name (workspace-button-name self workspace)))
      (when (and toolbar name)
        (let ((radio (find-component toolbar name)))
          (if (not radio)
              (unselect-elements toolbar class: Radio-Tool group: 'workspace)
            (set-selected? radio #t))))))
  
  
  (method public virtual undocumented (workspace-button-name self workspace)
    (get-name workspace))
  
  
  (method public virtual (workspace-installed self)
    )
  
  
  (method package (on-zoom-horizontally self evt)
    (zoom-direction self 'horz))
  
  
  (method package (on-zoom-vertically self evt)
    (zoom-direction self 'vert))
  
  
  (method package (zoom-direction self direction)
    (with-locked-update
      (lambda ()
        (let ((stage (current-stage)))
          (receive (preference view) (find-top-stage stage)
            (continuation-capture
              (lambda (return)
                (for-each-splitter view
                  (lambda (splitter host)
                    (when (and (eq? (get-orientation splitter) direction)
                               (get-zoomable? splitter))
                      (if (eq? (get-state splitter) 'split)
                          (zoom splitter host)
                        (unzoom splitter))
                      (continuation-return return)))))))))))
  
  
  (method package (on-maximize/restore self evt)
    (let ((stage (current-stage)))
      (if (get-maximized? stage)
          (restore stage)
        (maximize stage))))
  
  
  (method package (on-full-stage self evt)
    (let ((stage (current-stage)))
      (receive (preference view) (find-top-stage stage)
        (if (is-not? preference Splitter-Preferences)
            (bell)
          (let ((zoom?  (eq? (get-state view) 'split)))
            (continuation-capture
              (lambda (return)
                (for-each-splitter (get-border stage)
                  (lambda (splitter host)
                    (if zoom?
                        (zoom splitter host)
                      (unzoom splitter))
                    (when (eq? splitter view)
                      (continuation-return return #f)))))))))))
  
  
  (method package (on-full-screen self evt)
    (let ((pref (current-preferences #f)))
      (when (not (get-fullscreen-warned? pref))
        (message-box "Warning: There is currently only one way of exiting the fullscreen mode which is by using the Alt-Shift Backspace shortcut for Full Screen toggle")
        (set-property preferences-designer pref 'fullscreen-warned? #t)))
    (full-screen self (not (get-fullscreen? (get-toplevel self)))))
  
  
  (method public (full-screen self fullscreen?)
    (set-fullscreen? (selected-workspace) fullscreen?)
    (full-screen-stage self fullscreen?))
  
  
  (method public (full-screen-stage self fullscreen?)
    (let ((stage (current-stage)))
      (when stage
        (set-fullscreen? stage fullscreen?)
        (receive (preference view) (find-top-stage stage)
          (full-screen-host self view fullscreen?)))))
  
  
  (method public (toggle-full-screen self host)
    (let ((fullscreen? (not (get-fullscreen? (get-toplevel self)))))
      (full-screen-host self host fullscreen?)))
  
  
  (method public (full-screen-host self host fullscreen?)
    (define (fix-top-splitter-insets splitter)
      (if (not fullscreen?)
          (let ((preserved (get-preserved-insets splitter)))
            (when preserved
              (set-preserved-insets splitter #f)
              (set-insets splitter preserved)))
        (set-preserved-insets splitter (get-insets splitter))
        (set-insets splitter {Rect 0 0 0 0})))
    
    (let ((toplevel (get-toplevel self))
          (stage (current-stage)))
      (when (neq? fullscreen? (get-fullscreen? toplevel))
        (with-locked-update
          (lambda ()
            (set-fullscreen? toplevel fullscreen?)
            (for-each-splitter host
              (lambda (splitter host)
                (let ((preferences (get-preferences splitter)))
                  (when (and preferences (eq? (get-name preferences) 'top))
                    (fix-top-splitter-insets splitter)))
                (if fullscreen?
                    (zoom splitter host)
                  (unzoom splitter)))))))))
  
  
  (method public (on-delete-stage self evt)
    (delete-stage))
  
  
  (method public (on-delete-other-stages self evt)
    (delete-other-stages))
  
  
  (method public (on-split-vertically self evt)
    (split-stage-vertically))
  
  
  (method public (on-split-horizontally self evt)
    (split-stage-horizontally))
  
  
  (method public (on-move-frame self evt)
    (move-frame))
  
  
  (method public (on-clone-frame self evt)
    (clone-frame))
  
  
  (method public (on-tie-frame-model self evt)
    (tie-frame-model))
  
  
  (method public (on-untie-stage self evt)
    (untie-stage))


  ;;;
  ;;;; Toolbar
  ;;;
  
  
  (method public (find-toolbar self)
    (let ((host (get-toolbar :toolbar)))
      (and (and host (in-player? host))
           (get-guest host))))
  
  
  (method public (find-command-toolbar self)
    (define (try name)
      (let ((host (get-toolbar name)))
        (and (and host (in-player? host))
             (get-guest host))))
    
    (or (try :command)
        (try :minibuffer)
        (try :toolbar)))
   
  
  ;;;
  ;;;; Classes
  ;;;
  
  
  (method public virtual (get-text-class self)
    Plain-Text-View)
  

  ;;;
  ;;;; Resources
  ;;;
  
  
  (method public (get-resource self type name)
    (case type
      ((image) (new-file (resources-dir self) (list "images" (format "{a}.png" name))))
      ((cursor) (new-file (resources-dir self) (cond-expand
                                             (cocoa (list "cursors" name "cursor.pdf"))
                                             (windows (list "cursors" (format "{a}.cur" name)))
                                             (else (error "Custom cursors not supported on this platform")))))))
  
  
  (method protected virtual (resources-dir self)
    (if (is-alias? 'Jazz)
        {Directory Jazz "lib" "jazz.resources" "resources"}
      {Directory Build "lib" "jazz.resources" "resources"}))


  ;;;
  ;;;; Images
  ;;;
  
  
  (definition Images-Portfolio
    #f)
  
  
  (method public (get-images-portfolio self)
    (unless Images-Portfolio
      (set! Images-Portfolio (new Portfolio name: :images)))
    Images-Portfolio)


  ;;;
  ;;;; Catalog
  ;;;


  (method protected virtual (setup-cataloguer self)
    #f)


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method public virtual (designer-default-imports self)
    '())
  
  
  (method public virtual (designer-form-imports self form)
    '())


  ;;;
  ;;;; Events
  ;;;
  

  (method override (get-event-consumer self)
    event-consumer)
  
  
  (method override (set-event-consumer self consumer)
    (set! event-consumer consumer))


  (method override (deliver-event self handler target proc event)
    (proc target event))


  ;;;
  ;;;; Debug
  ;;;
  
  
  (method override (process-debuggee-loop self)
    (if (and (local-proxy? (get-controller-debugger))
             (event-thread?))
        (with-jazz-exception-debugger
          process-events)
      (nextmethod self)))


  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method (exception-reported self)
    ;; so as not to get recursive exceptions
    (catch Exception
      (cleanup-mouse-processing)))
  
  
  @convert
  (method (present-execution-context exception type prefix?)
    (present (new Exception-Presenter) exception type: type prefix?: prefix?))

  
  ;;;
  ;;;; Source
  ;;;


  (method package (on-edit-next self evt)
    (edit-next (get-active-results self)))


  (method package (on-edit-previous self evt)
    (edit-previous (get-active-results self)))


  (method package (on-edit-current self evt)
    (edit-current (get-active-results self)))
  
  
  (method public (update-source-actions self)
    (let* ((results (get-active-results self))
           (results-count (and results (get-visible-count (get-tree results)))))
      (set-action-enabled? {Action application edit-next} (and results (>= results-count 1)))
      (set-action-enabled? {Action application edit-previous} (and results (>= results-count 1)))
      (set-action-enabled? {Action application edit-current} (and results (>= results-count 1)))))

  
  ;;;
  ;;;; Command Shell
  ;;;
  
  
  (method package (on-command-extended self evt)
    (select-command-extended self))
  
  
  (method package (on-command-execute self evt)
    (select-command-execute self))
  
  
  (method public virtual (get-command-shell self)
    (let ((toolbar (find-command-toolbar self)))
      (and toolbar
           (locate-component toolbar 'command-shell))))
  
  
  (method public virtual (get-command-text self)
    (let ((shell (get-command-shell self)))
      (and shell
           (get-text shell))))
  
  
  (method public (require-command-text self)
    (or (get-command-text self)
        (begin
          (message-box "This workspace doesn't contain a command text")
          (signal-cancel))))
  
  
  (method public (require-unzoomed-command-text self)
    (let ((text (require-command-text self)))
      (unzoom-command-text self text)
      text))
  
  
  (method protected virtual (unzoom-command-text self command-text)
    (let ((host (get-host command-text)))
      (let ((splitter (get-parent host)))
        (when (is? splitter Splitter-View)
          (when (eq? (get-state splitter) 'zoom)
            (let ((target (get-target splitter)))
              (when (neq? target host)
                (unzoom splitter)
                (set-client-restore command-text
                  (lambda ()
                    (when (in-player? splitter)
                      (zoom splitter target)))))))))))
  
  
  (method package virtual (rezoom-command-text self text command-text)
    )
  
  
  (method public (select-command-search self direction initial)
    (select-search (require-unzoomed-command-text self) direction #f initial again?: #t))
  
  
  (method public (select-command-search-current self direction range initial)
    (select-search (require-unzoomed-command-text self) direction range initial again?: #f))
  
  
  (method public (select-command-highlight self direction range search-result client (highlight?: highlight? #f))
    (select-search (require-unzoomed-command-text self) direction range #f search-result: search-result client: client highlight?: highlight? again?: #f))
  
  
  (method public (select-command-extended self)
    (select-extended (require-unzoomed-command-text self)))
  
  
  (method public (select-command-execute self)
    (select-execute (require-unzoomed-command-text self)))


  ;;;
  ;;;; Files
  ;;;


  (method package virtual (on-new self evt)
    (new-event (get-default-frame-class self)))
    

  (method package virtual (on-open self evt)
    (open-files self))
  
  
  (method public (open-files self (directory: directory #f))
    (let ((files (choose-file directory: directory extensions: (open-extensions self) multiple-selection?: #t)))
      (for-each (~ edit-file self)
                (sort string>? files key: get-name))))
  
  
  (method public virtual (receive-files self pos pathnames)
    (if (and (= (length pathnames) 1) (directory? (car pathnames)))
        (let ((dir (car pathnames)))
          (current-directory-set! dir)
          (user-message "Current directory set to {a}" (parse dir)))
      (let ((class (cond ((alt-down?) jazz.editor.jazz:Jazz-Plain-Text-View)
                         ((shift-down?) jazz.editor.jazz:Jazz-Text-View)
                         (else #f))))
        (let ((queue (new-queue)))
          (for-each (lambda (pathname)
                      (when (file? pathname)
                        (with-exception-filter
                          (lambda (exc)
                            (os-exception? exc))
                          (lambda (exc)
                            (enqueue queue pathname))
                          (lambda ()
                            (if class
                                (edit-document self pathname class: class)
                              (edit-file self pathname))))))
                    pathnames)
          (let ((unreadable (queue-list queue)))
            (when (not-null? unreadable)
              (message-box
                `(<span>
                   (<paragraph> ,(format "The following file{a} could not be read:" (format-plural (length unreadable))))
                   ,@(map (lambda (pathname)
                            `(<bulleted> ,(parse pathname)))
                          unreadable))
                title: "Problems")))))))
  
  
  (method public virtual (drop-file self filename)
    (let ((pathname (new (case (pathname-type filename) ((directory) Directory) (else File)) (tokenise-filename filename))))
      (let ((pos {Point 0 0}) ;; quicky
            (files (list (anchorize pathname))))
        ;; delay as this method gets called before the toplevel is fully
        ;; initialized when opening the application by a drag & drop on it
        (delay-event
          (lambda ()
            (receive-files self pos files))))))
  
  
  (method public virtual (edit-file self file . rest)
    (apply edit-document self file rest))
  
  
  ;; a quicky... this should really be up to the current workspace
  (method public virtual (open-extensions self)
    #f)


  (method public (find-document self moniker (class: class #f))
    (find-frame-if-guest
      (lambda (guest)
        (and (is? guest Document)
             (or (not class) (is? guest class))
             (let ((guest-moniker (get-moniker (get-document-controller guest))))
               (and guest-moniker
                    (pathname=? guest-moniker moniker)))))))
  
  
  (method public (edit-document self moniker
                                (class: class #f)
                                (kind: kind #f)
                                (workspace: workspace #f)
                                (selection: selection #f)
                                (force-selection?: force-selection? #f)
                                (generate-event?: generate-event? #t)
                                (char-encoding: char-encoding #f)
                                (wrap?: wrap? #f)
                                (force-new?: force-new? #f)
                                (visible?: visible? #t)
                                (activate-focus?: activate-focus? #t)
                                (return-new?: return-new? #f))
    (and moniker
         (if (not (exists? moniker))
             (error "Unable to locate document: {t}" moniker)
           (let ((file moniker))
             (let ((frame (if force-new? #f (find-document self file class: class))))
               (define (return frame new?)
                 (if return-new?
                     (values frame new?)
                   frame))
               
               (if (not frame)
                   (let ((class (or class (file-frame-class self file))))
                     (with-cursor :wait
                       (lambda ()
                         (let ((frame (new-frame class
                                                 kind: kind
                                                 host-workspace: workspace
                                                 host-visible?: visible?
                                                 host-focus?: activate-focus?
                                                 initialize: (lambda (document)
                                                               (let ((text? (is? document Text-View)))
                                                                 (when text?
                                                                   (set-char-encoding (get-model document) char-encoding))
                                                                 (set-moniker (get-document-controller document) moniker)
                                                                 (when (and text? wrap?)
                                                                   (set-wrap? (get-model document) #t)))))))
                           (when selection
                             (let ((document (get-guest frame)))
                               (when (is? document Text-View)
                                 (end-completion document)
                                 (set-selection-safe document selection reposition: 'vertical ensure-displayed?: 'center-caret force?: force-selection? generate-event?: generate-event?))))
                           (return frame #t)))))
                 (when selection
                   (let ((document (get-guest frame)))
                     (end-completion document)
                     (set-selection-safe document selection ensure-displayed?: #f force?: force-selection? generate-event?: generate-event?)
                     (ensure-displayed document force-vertical: 'head)))
                 (when (and workspace (neq? workspace (get-workspace frame)))
                   (set-workspace frame workspace)
                   (apply-preferences (require-workspace workspace) restore-focus?: #f))
                 (when (and visible? activate-focus?)
                   (focus-host frame))
                 (verify-reload (get-document-controller (get-guest frame)))
                 (return frame #f)))))))
  
  
  (method public (edit-help-document self moniker)
    (let* ((frame (edit-document self moniker))
           (text (get-guest frame)))
      (set-editable? text #f)))
  
  
  (method public (edit-filename self filename)
    (let* ((workbench (find-service 'workbench))
           (project-file (and workbench (find-filename workbench filename))))
      (if (not project-file)
          (error "Unable to locate filename: {t}" filename)
        (let* ((frame (edit-document self (get-source project-file)))
               (text (get-guest frame)))
          (verify-reload (get-document-controller text))))))
  
  
  (method package virtual (on-close self evt)
    (let ((frame (front-frame)))
      (when frame
        (close-host frame))))

  
  (method package virtual (on-close-all self evt)
    (for-each (lambda (view)
                (when (is? view Frame-Host)
                  (let ((guest (get-guest view)))
                    (when (or (is-not? guest Document) (close-on-close-all? (get-document-controller guest)))
                      (confirm-close view)
                      (close-host view)))))
              (all-frames)))
        
    
  (method package virtual (on-save-all self evt)
    (save-all self))
  
  
  (method package virtual (on-print self evt)
    (let ((guest (current-guest)))
      (print-document guest)))

   
  (method package virtual (on-print-layout self evt)
    (let ((guest (current-guest)))
      (print-layout guest)))

  
  (method package virtual (on-print-preview self evt)
    (let ((guest (current-guest)))
      (print-preview guest)))
  
  
  (method package virtual (on-quit-application self evt)
    (delay-event
      (lambda ()
        (quit-process self))))
  
  
  (method public (save-all self (class: class Document) (save-unanchored?: save-unanchored? #t))
    (define (save-documents main-documents?)
      (for-each (lambda (host)
                  (when (is? host Frame-Host)
                    (let ((guest (get-guest host)))
                      (when (is? guest Document)
                        (let ((controller (get-document-controller guest)))
                          (when (and (is? guest class)
                                     (or save-unanchored? (get-moniker guest))
                                     (xor main-documents? (dependent-document? controller))
                                     (get-modified? controller))
                            (save guest)))))))
                (all-frames include-invisibles?: #t)))
    
    ;; saving dependent documents will make their main document modified
    (save-documents #f)
    (save-documents #t))


  ;;;
  ;;;; Definitions
  ;;;

  
  (method public virtual (edit-definitions self object . rest)
    )

  
  (method public virtual (edit-references self object . rest)
    )


  ;;;
  ;;;; Context
  ;;;
  
  
  @cant-find-get-profile-class
  (method override (context-update self)
    (define (modify-profile)
      (when profile
        (close profile))
      (let ((pref (current-preferences #f error?: #f)))
        (when pref
          (let ((class-unit (or (get-profile-class pref) Profile)))
            (when class-unit
              (set! profile (new (load-profile-class class-unit)))))))
      (when profile
        (init profile))
      (when profile
        (finalize profile)))
    
    (nextmethod self)
    (modify-profile)
    (user-message "Context set to {a}" context))

  
  ;;;
  ;;;; Preferences
  ;;;
  
  
  (method override (setup-preferences self)
    (with-safe-execution "loading the preferences"
      (lambda ()
        (setup-preferences/designer self))
      continue-handler:
      (lambda (err)
        (set-preferences/designer self (default-preferences self)))))
  
  
  (method override (default-preferences self)
    (new Application-Preferences))
  
  
  (method package virtual (toolbox-file self toolbox)
    (new-file {Directory Profile "settings"}
      (or toolbox "Toolbox.jml")))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (definition Default-Page-Setup
    #f)
  
  (definition Default-Page-Setup-Form
    #f)
  
  (definition Default-Page-Setup-Designer
    #f)
  
  
  (definition public (set-default-page-setup setup)
    (set! Default-Page-Setup setup))
  
  
  (method virtual (get-page-setup-file self)
    (when (is-alias? 'Profile)
      {File Profile "settings" "PageSetup.jml"}))
  
  
  (method virtual (get-page-setup-form self)
    (<form> (<Page-Setup>)))
  
  
  (method public (default-page-setup self)
    (when (not Default-Page-Setup)
      (setup-page-setup self))
    Default-Page-Setup)
  
  
  (method public (default-page-setup-designer self)
    (when (not Default-Page-Setup-Designer)
      (setup-page-setup self))
    Default-Page-Setup-Designer)
  
  
  (method public (default-page-setup-parcel self designer)
    (when (not Default-Page-Setup)
      (setup-page-setup self))
    (package-component designer (default-page-setup self)))
  
  
  (method public (default-apply-page-setup self designer form page-setup)
    (when form
      (apply-form designer form (default-page-setup self))))
  
  
  (method package virtual (setup-page-setup self)
    (let* ((file (get-page-setup-file self))
           (form (if (and file (exists? file)) (read-form file) (get-page-setup-form self)))
           (reference (instantiate form)))
      (set! Default-Page-Setup reference)
      (set! Default-Page-Setup-Form form)
      (set! Default-Page-Setup-Designer (new (former-class self) form: form reference: reference))))
  
  
  (method virtual (save-page-setup self)
    (when (and Default-Page-Setup-Designer (file? (get-origin (get-form Default-Page-Setup-Designer))))
      (let ((form (get-form Default-Page-Setup-Designer)))
        (when (not (get-origin form))
          (set-origin form (get-page-setup-file self))))
      (save Default-Page-Setup-Designer)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public virtual (get-documentation-cataloguer self)
    #f)


  ;;;
  ;;;; Windows
  ;;;
  
  
  (method public virtual (update-windowing-actions self)
    (unless (unloading-process?)
      (update-history-actions self)
      (update-window-actions self)
      (update-menubar-buttons self)))
  
  
  (method public (update-window-actions self)
    (let ((all-frames (length (all-frames)))
          (frames (length (current-stage-frames)))
          (stages (length (get-active-stages)))
          (in-modal? (in-modal?)))
      (set-action-enabled? {Action application close}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application close-all}         (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save}                    (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save-as}                 (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application save-all}          (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest revert-saved}            (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest compare-saved}           (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application page-setup}        (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-layout}      (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-preview}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-frame}        (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-frame}    (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application current-frame}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-stage}        (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-stage}    (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-horizontally} (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-vertically}   (and (>= frames 2) (not in-modal?)))))
  
  
  (method package virtual (on-next-frame self evt)
    (let ((first (first-frame)))
      (send-frame-to-back first)
      (send-to-back first)
      (focus-host (front-frame))))
  
  
  (method package virtual (on-previous-frame self evt)
    (let ((last (last-frame)))
      (bring-frame-to-front last)
      (bring-to-front last)
      (focus-host (front-frame))))
  
  
  (method package virtual (on-current-frame self evt)
    (let ((first (first-frame)))
      (focus-host first)))
  
  
  (method package (on-next-stage self evt)
    (or (navigate-next-stage)
        (bell)))
  
  
  (method package (on-previous-stage self evt)
    (or (navigate-previous-stage)
        (bell)))
  
  
  (method package virtual (on-tile-horizontally self evt)
    (let* ((two-frames? (shift-down?))
           (stage (current-stage))
           (frames (get-views stage))
           (count (length frames))
           (width (get-width stage))
           (height (get-height stage))
           (w (quotient width (if two-frames? 2 count)))
           (l 0))
      (with-locked-update
        (lambda ()
          (restore stage)
          (for-each (lambda (frame)
                      (set-position frame (new Point l 0))
                      (set-size frame (new Dimension w height))
                      (increase! l w))
                    (if (and two-frames? (>= count 2))
                        (subseq frames 0 2)
                      frames))))))
  
  
  (method package virtual (on-tile-vertically self evt)
    (let* ((two-frames? (shift-down?))
           (stage (current-stage))
           (frames (get-views stage))
           (count (length frames))
           (width (get-width stage))
           (height (get-height stage))
           (h (quotient height (if two-frames? 2 count)))
           (t 0))
      (with-locked-update
        (lambda ()
          (restore stage)
          (for-each (lambda (frame)
                      (set-position frame (new Point 0 t))
                      (set-size frame (new Dimension width h))
                      (increase! t h))
                    (if (and two-frames? (>= count 2))
                        (subseq frames 0 2)
                      frames))))))
  
  
  (method package (on-select-frame self evt)
    (let ((host (get-property evt host:)))
      (bring-to-front host)
      (focus-host host)))
  
  
  (method package (on-select-palette self evt)
    (let ((host (get-property evt host:)))
      (bring-to-front (get-player host))))


  ;;;
  ;;;; Modal
  ;;;
  
  
  (method package virtual (update-modal-actions self)
    (update-windowing-actions self)))


;;;
;;;; Selected-Event
;;;


(class Selected-Event extends Event
  
  
  (slot owner    getter generate)
  (slot old      getter generate)
  (slot selected getter generate)
  (slot force?   getter generate)


  (method override (initialize self kind sender modifiers owner old selected (force?: force? #f) (user-origin: user-origin #f))
    (nextmethod self kind sender modifiers)
    (set! self.owner owner)
    (set! self.old old)
    (set! self.selected selected)
    (set! self.force? force?)))


;;;
;;;; Default-Workspace
;;;


(class Default-Workspace extends Workspace-Preferences
  
  
  (form
    (<install>             fullscreen?: #t
      (<Stage-Preferences> location: root)))))
