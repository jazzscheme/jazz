;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Applications
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.application.Application jazz


(import (jazz.action)
        (jazz.application)
        (jazz.application.services)
        (jazz.clipboard)
        (jazz.component)
        (jazz.component.runtime)
        (jazz.debuggee)
        (jazz.designer)
        (jazz.document)
        (jazz.event)
        (jazz.graphic)
        (jazz.handler)
        (jazz.history)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.locale)
        (jazz.menu)
        (jazz.platform)
        (jazz.preferences)
        (jazz.print)
        (jazz.process)
        (jazz.profile)
        (jazz.runtime)
        (jazz.search)
        (jazz.settings)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.picker)
        (jazz.ui.skin)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.ui.workspace))


(class Application extends Process implements (History-Provider Event-Consumer Save-Environment-Listener)


  (slot toplevel                 initialize #f)
  (slot focus-listeners          initialize '())
  (slot application-listeners    initialize (make-table test: eq?))
  (slot selected-owner           initialize #f                        getter generate)
  (slot selected                 initialize #f)
  (slot selected-listeners       initialize '())
  (slot event-consumer           initialize self)
  (slot history-manager          initialize (new History-Manager self))
  (slot active?                  initialize #f                        getter generate)
  (slot application-actions      initialize '()                       getter generate)
  (slot profile-actions          initialize '()                       getter generate)
  (slot guest-actions            initialize '()                       getter generate)
  (slot focus-actions            initialize '()                       getter generate)
  (slot bindings-designer        initialize #f                        getter generate)
  (slot skins-designer           initialize #f                        getter generate)
  (slot workspaces-designer      initialize #f                        getter generate)
  (slot shortcut-table           initialize #f)
  (slot shortcut-hook            initialize #f                        accessors generate)
  
  
  (method meta override (external-name . rest)
    'application)

  
  ;;;
  ;;;; Access
  ;;;


  (method override (get-toplevel)
    toplevel)
  
  
  (method override (is-application?)
    #t)


  ;;;
  ;;;; Startup
  ;;;
  
  
  (method override (prepare-bindings)
    (nextmethod)
    ;; this is critical as any problem in the boot process
    ;; might display a message-box that needs basic bindings
    (set-bindings (new Application-Bindings)))
  
  
  (method override (prepare-locales)
    (nextmethod)
    (register-locale-change~ (get-locale-state) locale-change))


  (method override (prepare-profile)
    (nextmethod)
    (set-application self)
    (setup-shortcuts)
    (prepare-window-manager)
    (prepare-skins))


  (method override (prepare-environment)
    (nextmethod)
    (prepare-colors)
    (prepare-fonts)
    (prepare-formats)
    (prepare-styles)
    (provide-platform)
    (provide-feedback)
    (provide-edition))

  
  (method override (install-environment)
    (nextmethod)
    (install-skins)
    (install-bindings)
    (install-workspaces)
    (initialize-toplevel)
    (initialize-clipboard)
    (register-clipboard-formats))


  (method override (finalize-environment)
    (nextmethod)
    (set-cursor :arrow)
    (splash-screen))

  
  (method override (setup-profile)
    (define (create-profile)
      (with-safe-execution "loading the profile"
        (lambda ()
          (set! profile (if (find-unit-source profile-class)
                            (new (load-profile-class profile-class))
                          (new-default-profile))))
        continue-text: (list (format "to bypass this problem by using a generic profile class"))
        continue-handler:
        (lambda (err)
          (set! profile (new-default-profile)))))
    
    (when (use-profile?)
      (create-profile)
      (set-profile-actions (get-class-actions profile))))
  
  
  (method override (finish-environment)
    (nextmethod)
    (add-save-environment-listener self)
    (when profile
      (with-safe-execution "initing the profile"
        (lambda ()
          (init~ profile))
        continue-handler:
        (lambda (err)
          )))
    (reload-session)
    (remove-splash-screen))
  
  
  (method override (finish-process)
    (nextmethod)
    (select-default-workspace)
    (update-focus-actions)
    (update-windowing-actions))
  
  
  (method override (conclude-environment)
    (nextmethod)
    (initialize-actions)
    (skin-update)
    (show-toplevel)
    (when (run-loop?)
      (select-foreground~ toplevel))
    (when profile
      (with-safe-execution "finalizing the profile"
        (lambda ()
          (finalize~ profile))
        continue-handler:
        (lambda (err)
          ))))
  
  
  ;;;
  ;;;; Termination
  ;;;
  
  
  (method override (terminate-process)
    (nextmethod)
    (reset-palettes)
    (reset-dockeds)
    (reset-toolbars)
    (when toplevel
      (close~ toplevel)
      (set! toplevel #f)
      (set! profile-class #f)
      (set! profile #f)))


  ;;;
  ;;;; Java
  ;;;
  
  
  @test-java
  (definition Java-Classpath
    '({File "C:" "Java" "j2sdk1.4.2_04" "jre" "lib" "rt.jar"}
      {File "C:" "Java" "BCEL" "lib" "bcel-5.1.jar"}
      {File "C:" "Java" "JDBC" "msbase.jar"}
      {File "C:" "Java" "JDBC" "msutil.jar"}
      {File "C:" "Java" "JDBC" "mssqlserver.jar"}))
  
  
  @test-java
  (method (test-java)
    (setup-jvm classpath: Java-Classpath)
    (c-test)
    (let* ((loader (getSystemClassLoader~ java.lang.ClassLoader))
           (class (forName~ java.lang.Class "yo" #t loader)))
      (message-box (format "{a}" class))))


  ;;;
  ;;;; Loop
  ;;;


  (method override (start-loop)
    (set-preference (get-preferences-root) 'first-startup? #f)
    (thread-priority-boost-set! (event-thread) 1)
    (process-events))


  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (clipboard-prefix)
    (format "{a}_{a}_"
            (process-name)
            (present~ (process-version))))
  
  
  (method protected virtual (register-clipboard-formats)
    (register-jazz-clipboard-formats (clipboard-prefix)))


  ;;;
  ;;;; Clipboard Ring
  ;;;

  
  (definition Clipboard-Ring
    '())
  
  (definition Max-Ring
    256)
  
  
  (method public (get-clipboard-ring)
    Clipboard-Ring)
  
  
  (method public (empty-clipboard-ring?)
    (null? Clipboard-Ring))
  
  
  (method public (add-clipboard)
    (let ((clipboard (get-clipboard)))
      (when clipboard
        (set! Clipboard-Ring (cons clipboard Clipboard-Ring))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (method public (push-clipboard-list list)
    (let ((pushed (length list)))
      (if (> pushed Max-Ring)
          (error "Unable to push list of {a} onto the clipboard ring" pushed)
        (set! Clipboard-Ring (append list Clipboard-Ring))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (definition (trim-clipboard)
    (when (> (length Clipboard-Ring) Max-Ring)
      (set-cdr! (tail Clipboard-Ring (- Max-Ring 1)) '())))
  
  
  (method (pop-clipboard)
    (let ((clipboard (car Clipboard-Ring)))
      (set! Clipboard-Ring (cdr Clipboard-Ring))
      (set-clipboard clipboard)
      (update-focus-actions)
      clipboard))

  
  (method package (paste-cycle-ring reversed?)
    (define (cycle-clipboard)
      (set! Clipboard-Ring (append (cdr Clipboard-Ring) (list (car Clipboard-Ring))))
      (car Clipboard-Ring))
    
    (define (cycle-clipboard-reversed)
      (set! Clipboard-Ring (cons (last Clipboard-Ring) (butlast Clipboard-Ring)))
      (car Clipboard-Ring))
    
    (if (null? Clipboard-Ring)
        (bell)
      (let ((focus (get-focus))
            (previous-clipboard (get-clipboard)))
        (let ((clipboard (if reversed?
                             (cycle-clipboard-reversed)
                           (cycle-clipboard))))
          (set-clipboard clipboard)
          (cycle-paste-clipboard~ focus previous-clipboard clipboard)))))
  
  
  (method package (on-copy-formatted evt)
    (let ((focus (get-focus)))
      (if (is-not? focus Text-View)
          (bell)
        (copy-formatted-selection~ focus))))
  
  
  (method package (on-paste-cycle-ring evt)
    (paste-cycle-ring #f))


  (method package (on-paste-cycle-ring-reversed evt)
    (paste-cycle-ring #t))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method package (on-add-history evt)
    (add-current~ history-manager))
  
  
  (method package (on-backward-history evt)
    (go-backward-history~ history-manager))
  
  
  (method package (on-forward-history evt)
    (go-forward-history~ history-manager))
  
  
  (method public (add-history item)
    (add-history~ history-manager item))
  
  
  (method override (current-history-item)
    (let ((frame (current-frame)))
      (when frame
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (current-history-item~ guest))))))
  
  
  (method override (update-history-actions)
    (let ((backward (get-backward-history~ history-manager))
          (forward (get-forward-history~ history-manager)))
      (set-action-enabled? {Action application backward-history} (not-null? backward))
      (set-action-enabled? {Action application forward-history} (not-null? forward))))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method public virtual (get-recorder)
    #f)
  
  
  (method package (macro-recording?)
    (let ((recorder (get-recorder)))
      (and recorder (get-recording?~ recorder))))
  
  
  (method package (macro-playing?)
    (let ((recorder (get-recorder)))
      (and recorder (get-playing?~ recorder))))
  
  
  (method package (macro-active?)
    (let ((recorder (get-recorder)))
      (and recorder
           (or (get-recording?~ recorder)
               (get-playing?~ recorder)))))


  ;;;
  ;;;; Profile
  ;;;
  
  
  (method protected virtual (use-profile-logging?)
    #f)
  
  
  (method override (log-profile)
    (define (login-profile)
      (receive (name unit template always-use?) (choose-profile-login)
        (let ((one-shoot? (shift-down?)))
          (when settings
            (unless one-shoot?
              (set-setting~ settings 'profile (if always-use? (->string name) #f)))
            (when (and always-use? (not one-shoot?) (not (get-setting~ settings 'profile-warned? #f)))
              (message-box (format "{a} will now always start using profile {a}. Note that you can always get this dialog back by keeping the shift key pressed when launching."
                                   (process-name)
                                   name))
              (set-setting~ settings 'profile-warned? #t))
            (save-content~ settings))
          (values name unit template))))
    
    (define (system-profile)
      (values 'Me 'jazz.profile (profile-kind))
      @convert
      (standard-profile (get-system-user-name)))
    
    (define (load-profile-jazzini)
      (let ((file {File Profile ".jazzini"}))
        (when (exists?~ file)
          (load (parse~ file)))))
    
    (let ((use-logging? (use-profile-logging?)))
      (let ((profile-arg (and (or (not use-logging?) (not (shift-down?))) (or (jazz-profile) (profile-parameter)))))
        (receive (name unit template) (cond (profile-arg (standard-profile (->string profile-arg)))
                                            (use-logging? (login-profile))
                                            (else (system-profile)))
          (set! profile-class (compose-identifier unit name))
          (install-profile name unit template)
          (load-profile-jazzini)))))
  
  
  (method protected virtual (choose-profile-login)
    )


  ;;;
  ;;;; Closing
  ;;;
  
  
  (method override (preserve-environment)
    (nextmethod)
    (call-save-environment-listeners))
  
  
  (method override (close-environment)
    ;; called before closing frames because saving a class form
    ;; can potentialy modify an opened text
    (call-exit-listeners)
    (confirm-all-close)
    (close-all-no-confirm)
    (save-bindings)
    (save-workspaces)
    (save-page-setup)
    (nextmethod))
  
  
  (method virtual (confirm-all-close)
    (define (frame-dependent-document? frame)
      (and (is? frame Host-View)
           (let ((guest (get-guest~ frame)))
             (and (is? guest Document)
                  (let ((controller (get-document-controller~ guest)))
                    (dependent-document?~ controller))))))
    
    (for-each (lambda (frame)
                (unless (frame-dependent-document? frame)
                  (confirm-close~ frame)))
              (all-frames include-invisibles?: #t)))
  
  
  (method (close-all)
    (for-each close-host~ (all-frames include-invisibles?: #t)))
  
  
  (method (close-all-no-confirm)
    (for-each (lambda (host)
                (close-host~ host confirm?: #f))
              (all-frames include-invisibles?: #t)))


  ;;;
  ;;;; Splash
  ;;;
  
  
  (definition Splash-Screen
    #f)
  
  (definition Splash-End
    #f)
  
  
  (method protected virtual (splash-screen)
    )
  
  
  (method (show-splash-screen (duration: duration #f))
    (set! Splash-Screen (show-splash))
    (set! Splash-End (and duration (+ (current-seconds) duration))))
  
  
  (method (remove-splash-screen)
    (when Splash-Screen
      (let ((time (current-seconds)))
        (when (and Splash-End (> Splash-End time))
          (sleep (- Splash-End time)))
        (remove-splash Splash-Screen))))
  
  
  (method protected virtual (show-splash)
    )
  
  
  (method protected virtual (remove-splash splash-screen)
    )


  ;;;
  ;;;; Help
  ;;;
  
  
  (method public virtual (show-help)
    #f)
  
  
  (method package (on-about evt)
    (show-about))
  
  
  (method public virtual (show-about)
    (let ((name (process-name))
          (owner (process-owner))
          (copyright (process-copyright))
          (licensee (process-licensee))
          (version (present~ (process-version)))
          (email (process-email)))
      (message-box
        `(<span>
           (<paragraph> (<text> font: Text color: Dark-Blue ,(format "{a} v{a}" name version)))
           (<paragraph>)
           ,@(if owner
                 `((<paragraph> (<text> font: Text ,(format "Copyright {a}{a}" (if copyright (format "{a} " copyright) "") owner)))
                   (<paragraph>))
               '())
           ,@(if licensee
                 `((<paragraph> ,(localize {Locales english: "This product is licensed to " french: "Ce produit est autorisé à "}) (list licensee))
                   (<paragraph>))
               '())
           ,@(if email
                 `((<paragraph> ,(localize {Locales english: "Send comments, suggestions, bugs,... to:" french: "Envoyer vos commentaires, suggestions, problèmes,... à:"}))
                   (<paragraph> ,email))
               '()))
        title: (format "{a} {a}" (localize {Locales english: "About" french: "À propos de"}) name))))


  ;;;
  ;;;; Exit
  ;;;
  

  (slot exit-listeners initialize '())
  
  
  (method public (add-exit-listener listener)
    (set! exit-listeners (cons listener exit-listeners)))
  
  
  (method public (remove-exit-listener listener)
    (set! exit-listeners (remove! listener exit-listeners)))
  
  
  (method public (call-exit-listeners)
    (for-each prepare-exit~ exit-listeners))


  ;;;
  ;;;; Activation
  ;;;
  
  
  (method public virtual (deactivate)
    (when active?
      (close-popups~ toplevel)
      (reset-mouse-in)
      (set! active? #f)))
  
  
  (method public virtual (activate)
    (unless active?
      (set! active? #t)
      (activate-verify-reloads)))
  
  
  (cond-expand
    (cocoa
     (method (activate-verify-reloads)
       (delay-event
         (lambda ()
           (verify-reloads)))))
    (else
     (method (activate-verify-reloads)
       (verify-reloads))))
  
  
  (method public (verify-reloads)
    (define (collect-reloads)
      (collect (lambda (view)
                 (when (is? view Frame-Host)
                   (let ((guest (get-guest~ view)))
                     (when (is? guest Document)
                       (let ((controller (get-document-controller~ guest)))
                         (when (needs-reload?~ controller)
                           controller))))))
               (all-frames include-invisibles?: #t)))
    
    (let ((reloads (collect-reloads)))
      (when (not-null? reloads)
        (let ((partition (partition reloads key: class-of test: eq?)))
          (for-each (lambda (category)
                      (let ((code (propose-multiple-reloads~ (car category))))
                        (with-cursor :wait
                          (lambda ()
                            (for-each (lambda (controller)
                                        (propose-reload-action~ controller code))
                                      (cdr category))))))
                    partition)))))
  
  
  (method public (verify-reload moniker)
    (let ((frame (find-document moniker)))
      (when frame
        (let ((document (get-guest~ frame)))
          (verify-reload~ (get-document-controller~ document))))))


  ;;;
  ;;;; Environment
  ;;;
  

  (slot save-environment-listeners initialize '())
  
  
  (method public (add-save-environment-listener listener)
    (set! save-environment-listeners (cons listener save-environment-listeners)))
  
  
  (method public (remove-save-environment-listener listener)
    (set! save-environment-listeners (remove! listener save-environment-listeners)))
  
  
  (method public (call-save-environment-listeners)
    (for-each (lambda (listener)
                (save-environment~ listener))
              save-environment-listeners))
  
  
  ;;;
  ;;;; Session
  ;;;
  
  
  (method public (reload-session)
    (reload-opened-windows))
  
  
  (method public virtual (reload-opened-windows)
    )
  
  
  (method public virtual (reload-component class properties)
    )

  
  (method override (save-environment)
    (define (save-application)
      (let ((process-preferences (get-preferences-root)))
        (when process-preferences
          @convert/wait
          (set-preference process-preferences active-context: context)
          (set-preference process-preferences current-directory: (get-current-directory)))))
    
    (define (save-all-guest)
      @wait
      (for-each (lambda (frame)
                  (when (is? frame Host-Frame)
                    (let ((guest (get-guest~ frame)))
                      (when guest
                        (save-guest~ guest session-designer session)))))
                (all-frames include-invisibles?: #t)))
    
    (save-application)
    (save-all-guest))

  
  ;;;
  ;;;; Window Manager
  ;;;
  
  
  (method protected virtual (prepare-window-manager)
    (set-window-manager (new Window-Manager)))

  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method public virtual (display-aliases?)
    #t)
  
  
  (method public virtual (display-protocol?)
    #t)
  
  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (method (prepare-colors)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Colors.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (colors-domain))))))


  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method (prepare-fonts)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Fonts.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (fonts-domain))))))


  ;;;
  ;;;; Formats
  ;;;
  
  
  (method (prepare-formats)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Formats.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (formats-domain))))))


  ;;;
  ;;;; Styles
  ;;;
  
  
  (method (prepare-styles)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Styles.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (styles-domain))))))


  ;;;
  ;;;; Platform
  ;;;
  
  
  (method (provide-platform)
    (provide-service 'drop-file-callback drop-file)
    (provide-service 'exit-callback exit-process)
    (provide-service 'user-notification user-notification))


  ;;;
  ;;;; Feedback
  ;;;
  
  
  (method protected virtual (provide-feedback)
    (provide-service 'user-message user-message)
    (provide-service 'user-feedback user-feedback)
    (provide-service 'clear-user-message clear-user-message)
    (provide-service 'clear-user-feedback clear-user-feedback)
    (provide-service 'console-feedback console-feedback)
    (provide-service 'modal-feedback message-box))


  ;;;
  ;;;; Edition
  ;;;
  
  
  (method protected virtual (provide-edition)
    (provide-service 'edit-document edit-document))

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (add-focus-listener listener)
    (set! focus-listeners (add-listener listener focus-listeners)))
  
  
  (method public (remove-focus-listener listener)
    (set! focus-listeners (remove-listener listener focus-listeners)))

  
  (method package (process-focus-change new-focus)
    (when focus-listeners
      (let ((evt (new Focus-Event :focus-change self (modifiers-mask) new-focus)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  focus-listeners)))
    (update-focus-actions))
  
  
  (method public virtual (update-focus-actions)
    (let* ((focus (get-focus))
           (view? (and focus (is? focus View))))
      (when preferences-designer
        (set-action-enabled? {Action view undo} (and view? (can-view-undo?~ focus)))
        (set-action-enabled? {Action view redo} (and view? (can-view-redo?~ focus)))
        (set-action-enabled? {Action view cut} (and view? (can-view-cut?~ focus)))
        (set-action-enabled? {Action view copy} (and view? (can-view-copy?~ focus)))
        (set-action-enabled? {Action application copy-formatted} (and view? (can-view-copy?~ focus)))
        (set-action-enabled? {Action view paste} (and view? (can-view-paste?~ focus)))
        (set-action-enabled? {Action application paste-cycle-ring} (and view? (can-view-paste?~ focus) (not-null? Clipboard-Ring)))
        (set-action-enabled? {Action application paste-cycle-ring-reversed} (and view? (can-view-paste?~ focus) (not-null? Clipboard-Ring)))
        (set-action-enabled? {Action view paste-properties} (and view? (can-view-paste-properties?~ focus)))
        (set-action-enabled? {Action view delete} (and view? (can-view-delete?~ focus)))
        (set-action-enabled? {Action view select-all} (and view? (can-view-select-all?~ focus)))
        (when view?
          (focus-update-actions~ focus)))))
  
  
  ;;;
  ;;;; Selected
  ;;;
  
  
  (method public (add-selected-listener listener)
    (set! selected-listeners (add-listener listener selected-listeners)))
  
  
  (method public (remove-selected-listener listener)
    (set! selected-listeners (remove-listener listener selected-listeners)))
  
  
  (method public (get-selected)
    selected)
  
  
  (method public (set-selected owner sel (force?: force? #f))
    (let ((new-owner? (neq? owner selected-owner)))
      (when (or force? new-owner? (neq? sel selected))
        (process-selected-change owner selected sel force?))))
  
  
  (method public (close-selected owner)
    (when (eq? owner selected-owner)
      (set! selected-owner #f)
      (process-selected-change #f selected #f #f)))

  
  (method (process-selected-change owner old-selected new-selected force?)
    (set! selected-owner owner)
    (set! selected new-selected)
    (when (and selected-listeners (not (exiting-process?)))
      (let ((evt (new Selected-Event :selected-change self (modifiers-mask) owner old-selected new-selected force?: force?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  selected-listeners))))

  
  ;;;
  ;;;; Application
  ;;;
  
  
  (method public (add-application-listener category listener)
    (set-application-listeners category (add-listener listener (get-application-listeners category))))
  
  
  (method public (remove-application-listener category listener)
    (set-application-listeners category (remove-listener listener (get-application-listeners category))))

  
  (method package (process-application-event category kind sender . properties)
    (let ((listeners (get-application-listeners category)))
      (let ((evt (apply make-event Application-Event kind sender properties)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (get-application-listeners category)
    (table-ref application-listeners category '()))
  
  
  (method (set-application-listeners category listeners)
    (table-set! application-listeners category listeners))

  
  ;;;
  ;;;; Frames
  ;;;
  
  
  (method public virtual (default-frame-class)
    #f)


  (method public virtual (file-frame-class file)
    (let ((extension (get-extension~ file)))
      (or (extension-frame-class extension)
          (error "Unknown file extension: {a}" extension))))


  (method public virtual (extension-frame-class ext)
    (or (profile-extension-frame-class ext)
        (known-extension-frame-class ext)
        (unknown-extension-frame-class)))
  
  
  (method (profile-extension-frame-class ext)
    (when profile
      (extension-frame-class~ profile ext)))


  (method public virtual (known-extension-frame-class ext)
    #f)
  
  
  (method public virtual (unknown-extension-frame-class)
    #f)


  (method public virtual (frame-class (file: file #f))
    (if (not file)
        (default-frame-class)
      (file-frame-class file)))
  
  
  (method (get-default-frame-class)
    (let* ((pref (get-workspace-preferences))
           (model (get-frame-model~ pref)))
      (if model
          (resolve-reference~ model)
        (default-frame-class))))

  
  ;;;
  ;;;; User
  ;;;
  
  
  (method protected virtual (user-notification wparam lparam)
    )

  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (initialize-toplevel)
    (set! toplevel (new-toplevel)))
  
  
  (method public virtual (new-toplevel)
    (new Toplevel))
  
  
  (method public virtual (show-toplevel)
    (define (setup-stage)
      (let ((stage (current-stage)))
        (when stage
          (case (find-setting 'jazz.ui.stage-state #f)
            ((restored) (restore~ stage))
            ((maximized) (maximize~ stage))))))
    
    (setup-stage)
    (set-visible?~ toplevel #t)
    (acquire-focus~ toplevel))
  
  
  (method (initialize-actions)
    (set-application-actions (get-class-actions self)))
  
  
  (method (update-actions update)
    (unregister-actions-shortcuts application-actions)
    (update)
    (let ((actions (get-class-actions self)))
      (register-actions-shortcuts actions)
      (set-application-actions actions)))

  
  ;;;
  ;;;; Stage
  ;;;
  
  
  (method public virtual (new-stage)
    (new (stage-class) parent: (new Stage-Border) name: 'stage))
  
  
  (method protected virtual (stage-class)
    Stage)
  
  
  ;;;
  ;;;; Shortcuts
  ;;;
  
  
  (method (setup-shortcuts)
    (set! shortcut-table (make-table test: shortcut=? hash: shortcut-hash)))
  
  
  (method (unregister-actions-shortcuts old-actions)
    (define (unregister-shortcut action-item shortcut)
      ;; the second test is necessary because bindings can be changed on-the-fly in the ide
      (when (and shortcut (table-ref shortcut-table shortcut #f))
        (table-remove! shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each (lambda (actions)
                  (when (get-visible?~ actions)
                    (for-each (lambda (action-item)
                                (when (get-visible?~ action-item)
                                  (for-each (lambda (shortcut)
                                              (unregister-shortcut action-item shortcut))
                                            (all-shortcuts~ action-item))))
                              (get-children~ actions))))
                old-actions)))
  
  
  (method (register-actions-shortcuts new-actions)
    (define (register-shortcut action-item shortcut)
      (when shortcut
        (table-add shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each-reversed (lambda (actions)
                           (when (get-visible?~ actions)
                             (for-each (lambda (action-item)
                                         (when (get-visible?~ action-item)
                                           (for-each (lambda (shortcut)
                                                       (register-shortcut action-item shortcut))
                                                     (all-shortcuts~ action-item))))
                                       (get-children~ actions))))
                         new-actions)))
      
  
  (method (update-actions-shortcuts old-actions new-actions)
    (unregister-actions-shortcuts old-actions)
    (register-actions-shortcuts new-actions))
  
  
  (method public (update-shortcut action-item old-shortcut new-shortcut)
    (when old-shortcut
      (table-remove! shortcut-table old-shortcut action-item))
    (when new-shortcut
      (table-add shortcut-table new-shortcut action-item)))
  
  
  (method public virtual (dispatch-shortcut shortcut)
    (if (or (not shortcut-hook)
            (not (shortcut-hook shortcut)))
        (let ((action-items (collect-if get-action-handler~ (get-allowed-actions shortcut))))
          (when (not-null? action-items)
            (let ((action (car action-items)))
              (when (action-allowed? action)
                (parameterize ((event-type 'keyboard))
                  ;; the memq? is a quick hack
                  (unless (memq? (get-name~ action) '(start-recording stop-recording))
                    (hook-event (new Keyboard-Event :char #f (modifiers->mask (get-modifiers~ shortcut)) key: (get-key~ shortcut))))
                  (invoke~ action self #f)
                  #t)))))
      #t))
  
  
  (method public (get-bound-actions shortcut)
    (table-ref shortcut-table shortcut '()))
  
  
  (method public (get-allowed-actions shortcut)
    (define (filter-allowed actions)
      (collect-if action-allowed? actions))
    
    (let ((actions (get-bound-actions shortcut)))
      ;; This temporary test is because I am not sure it is what we want in general
      ;; It could be very surprising to do a shortcut that's supposed to do nothing
      ;; as it's disabled and find out that something completly different happened!
      (if (shortcut=? shortcut {Shortcut :control #\X})
          (filter-allowed actions)
        actions)))
  
  
  (method public (action-allowed? action-item)
    (define (some-actionable-active?)
      (some? (lambda (actionable)
               (and (get-enabled?~ actionable)
                    (actionable-reachable?~ actionable)))
             (get-actionables~ action-item)))
    
    ;; maybe we shouldn't even use the action-item's enabled? property
    (and (get-enabled?~ action-item)
         (or (not (actions-orphaned?~ (get-parent~ action-item)))
             (allow-orphaned-action? action-item)
             (some-actionable-active?))))
  
  
  (method protected virtual (allow-orphaned-action? action-item)
    #f)
  
  
  ;;;
  ;;;; Bindings
  ;;;
  
  
  (definition Bindings-File
    {File Profile "settings" "Bindings.jml"})
  
  
  (method (install-bindings)
    (define (set-bindings/designer bindings)
      (set-bindings bindings)
      (set! bindings-designer (new Designer form: (get-form~ bindings) reference: bindings)))
    
    (with-safe-execution "loading the bindings"
      (lambda ()
        (let ((bindings (load-bindings)))
          (set-bindings/designer bindings)
          (let ((active (or (get-active-bindings~ (get-preferences #f)) 'jazz)))
            (let ((trait (locate-component~ bindings active)))
              (when (is? trait Trait)
                (set-base-traits~ bindings (list trait)))))))
      continue-handler:
      (lambda (err)
        (set-bindings/designer (default-bindings)))))
  
  
  (method protected virtual (load-bindings)
    (let ((file Bindings-File))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-bindings))))
  
  
  (method protected virtual (default-bindings)
    (new Application-Bindings))
  
  
  (method (save-bindings)
    (when (and bindings-designer (get-modified?~ bindings-designer) (file? (get-origin~ (get-form~ bindings-designer))))
      (save~ bindings-designer)))
    
  
  ;;;
  ;;;; Skins
  ;;;
  
  
  (method (install-skins)
    (with-safe-execution "loading the skins"
      (lambda ()
        (let ((skins (load-skins)))
          (set-skins-designer skins)
          (set-skin (child~ skins (or (get-active~ skins) (default-skin))))))
      continue-handler:
      (lambda (err)
        (let ((skins (default-skins)))
          (set-skins-designer skins)
          (set-skin (child~ skins (default-skin)))))))
  
  
  (method protected virtual (skins-file)
    {File Profile "settings" "Skins.jml"})
  
  
  (method protected virtual (load-skins)
    (let ((file (skins-file)))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-skins))))
  
  
  (method protected (set-skins-designer skins)
    (set! skins-designer (new Designer form: (get-form~ skins) reference: skins)))
  
  
  (method (save-skins)
    (when (and skins-designer (get-modified?~ skins-designer) (file? (get-origin~ (get-form~ skins-designer))))
      (save~ skins-designer)))

  
  ;;;
  ;;;; Workspaces
  ;;;
  
  
  (definition Workspaces-File
    {File Profile "settings" "Workspaces.jml"})
  
  
  (method (install-workspaces)
    (define (set-workspaces-designer workspaces)
      (set! workspaces-designer (new Designer form: (get-form~ workspaces) reference: workspaces)))
    
    (with-safe-execution "loading the workspaces"
      (lambda ()
        (set-workspaces-designer (load-workspaces)))
      continue-handler:
      (lambda (err)
        (set-workspaces-designer (default-workspaces)))))
  
  
  (method protected virtual (load-workspaces)
    (let ((file Workspaces-File))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-workspaces))))
  
  
  (method protected virtual (default-workspaces)
    (instantiate~
      (<form>
        (<Workspaces-Preferences>))))
  
  
  (method (save-workspaces)
    (when (and workspaces-designer (get-modified?~ workspaces-designer) (file? (get-origin~ (get-form~ workspaces-designer))))
      (save~ workspaces-designer)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method public (set-application-actions actions-list)
    (update-actions-shortcuts application-actions actions-list)
    (set! application-actions actions-list))
  
  
  (method public (set-profile-actions actions-list)
    (update-actions-shortcuts profile-actions actions-list)
    (set! profile-actions actions-list))


  (method public (set-guest-actions actions-list)
    (update-actions-shortcuts guest-actions actions-list)
    (set! guest-actions actions-list))
  
  
  (method public (set-focus-actions actions-list)
    (update-actions-shortcuts focus-actions actions-list)
    (set! focus-actions actions-list))

  
  ;;;
  ;;;; Menubar
  ;;;


  (method public (find-menubar)
    (let ((host (get-toolbar :menubar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (find-menu name)
    (let ((menubar (find-menubar)))
      (when menubar
        (let ((menuitem (find-component~ menubar name)))
          (when menuitem
            (get-content~ menuitem))))))
  
  
  (method public (update-menubar-buttons)
    (let ((menubar (find-menubar)))
      (when menubar
        (update-buttons~ menubar))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (definition Undisplayed-Message
    #f)


  (method public (set-status-message msg action-handler update?)
    (let ((message (get-message-view)))
      (if (not message)
          (set! Undisplayed-Message msg)
        (set! Undisplayed-Message #f)
        (post-event
          (lambda ()
            (set-title~ message (cond ((not msg) "")
                                      ((is? msg Locales) msg)
                                      (else (->string msg))))
            (set-action-handler~ message action-handler)))
        (when (and update? (primordial-thread?))
          (update-view~ message)))))


  (method public (find-status-bar)
    (let ((host (get-toolbar :status)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (get-message-view)
    (let ((status-bar (find-status-bar)))
      (when status-bar
        (find-component~ status-bar 'message))))
  
  
  (method public (show-undisplayed-message)
    (when Undisplayed-Message
      (set-status-message Undisplayed-Message #f #f)
      (set! Undisplayed-Message #f)))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (class-actions)
    (cons (find-actions 'application)
          (nextmethod)))


  ;;;
  ;;;; Alias
  ;;;
  
  
  (method override (process-alias name)
    (case name
      ((:application) self)
      ((:toplevel)    (get-toplevel))
      ((:modal)       (current-modal))
      ((:menubar)     (find-menubar))
      ((:toolbar)     (find-toolbar))
      ((:status-bar)  (find-status-bar))
      ((:stage)       (current-stage))
      ((:frame)       (current-frame))
      ((:document)    (current-document))
      ((:focus)       (get-focus))
      ((:focus-host)  (focused-host))
      ((:focus-guest) (focused-guest))
      ((:images)      (get-images-portfolio))
      ((:bindings)    (get-bindings))
      (else (cond ((and (pair? name) (eq? (car name) :menu)) (find-menu (cadr name)))
                  (else (nextmethod name))))))
  
  
  ;;;
  ;;;; Menus
  ;;;
  
  
  (method public virtual (text-menu text)
    (new-text-context-menu~ text))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public virtual (get-logs-manager)
    #f)
  
  
  (method public virtual (get-output-log)
    #f)
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (definition All-Results
    #f)
  
  (definition Active-Results
    #f)
  
  
  (method public virtual (navigable-results)
    (must-implement 'navigable-results "results navigation"))
  
  
  (method (get-navigable-results)
    (unless All-Results
      (set! All-Results (navigable-results)))
    All-Results)
  
  
  (method public (get-active-results)
    (unless Active-Results
      (set! Active-Results (car (get-navigable-results))))
    Active-Results)
  
  
  (method public (set-active-results results)
    (set! Active-Results results))
  
  
  ;;;
  ;;;; Locales
  ;;;
  
  
  (method (locale-change loc update?)
    (select-locale loc)
    (when update?
      (locale-update)))


  (method public (select-locale locale)
    (let ((status (find-status-bar)))
      (when status
        (let ((label (locate-component~ status 'locales)))
          (when label
            (set-title~ label (localize (present-locale~ (get-locale-state) locale))))))))
  
  
  (method public (locale-update)
    (define (update-menubar)
      (let ((menubar (find-menubar)))
        (layout-menu~ menubar)
        (for-each (lambda (child)
                    (when (is? child Label-Item)
                      (let ((content (get-content~ child)))
                        (when (is? content Menu)
                          (layout-menu~ content)))))
                  (get-children~ menubar))))
    
    (define (update-toplevel)
      (let ((toplevel (get-toplevel)))
        (invalidate-title~ toplevel)
        (redraw-window~ toplevel)))
    
    ;; All this should of course be event based but it will do for now...
    (update-menubar)
    (update-toplevel))
  
  
  ;;;
  ;;;; Workspace
  ;;;
  
  
  (method (setup-workspaces)
    (let ((preferences (get-workspaces-preferences)))
      (case (length (get-children~ preferences))
        ((0) (error "No workspaces found in Preferences.jml"))
        ((1))
        (else
         (let ((menu (find-menu 'workspace)))
           (when menu
             (let ((actions (find-actions 'application))
                   (toolbar (find-toolbar))
                   (active (get-active~ preferences)))
               (for-each (lambda (workspace)
                           (when (get-visible?~ workspace)
                             (let ((name (get-name~ workspace))
                                   (title (get-title~ workspace))
                                   (icon (get-icon~ workspace)))
                               (let ((action-name (string->symbol (format "select-{a}-workspace" name)))
                                     (event-handler (new Event-Handler target-name: :application method-name: 'on-select-workspace properties: (list workspace: name)))
                                     (selected? (eq? name active)))
                                 (new Action-Item parent: actions name: action-name action-handler: event-handler shortcut: (get-shortcut~ workspace))
                                 (new Radio-Item parent: menu name: (get-name~ workspace) title: title icon: icon before: 'delete group: 'workspace selected?: selected? action-handler: (new Action 'application action-name '()))
                                 (new Workspace-Button parent: toolbar name: name size: {Dimension 22 22} location: 'tail before: 'tail-separator group: 'workspace resource: icon portfolio: :images selected?: selected? tooltip?: #t tooltip-text: title action-handler: event-handler)
                                 (new Separator parent: toolbar size: {Dimension 1 0} location: 'tail before: 'tail-separator)))))
                         (get-children~ preferences))
               (new Separator-Item parent: menu before: 'delete)
               (layout-menu~ menu)
               (layout~ toolbar))))))))
  
  
  (method (select-default-workspace)
    (define (find-workspace)
      (let ((pref (get-workspaces-preferences error?: #f)))
        (if (not pref)
            (default-workspace)
          (let ((active (get-active~ pref)))
            (if (not active)
                (default-workspace)
              (child~ pref active))))))
    
    (define (default-workspace)
      (new Default-Workspace))
    
    (apply-preferences~ (find-workspace)))
  
  
  (method package (on-select-workspace evt)
    (select-workspace (get-property~ evt workspace:)))
  
  
  (method package (on-next-workspace evt)
    (select-next-workspace))
  
  
  (method package (on-previous-workspace evt)
    (select-previous-workspace))
  
  
  (method package virtual (on-workspace evt)
    (case (get-kind~ evt)
      ((activate)
       (let ((workspace (get-property~ evt workspace:)))
         (activate-workspace-item workspace)
         (activate-workspace-button workspace)))))
  
  
  (method public undocumented (activate-workspace-item workspace)
    (let ((menu (find-menu 'workspace)))
      (when menu
        (let ((radio (find-component~ menu (get-name~ workspace))))
          (if (not radio)
              (unselect-elements~ menu class: Radio-Item group: 'workspace)
            (set-selected?~ radio #t))))))
  
  
  (method public undocumented (activate-workspace-button workspace)
    (let ((toolbar (find-toolbar))
          (name (workspace-button-name workspace)))
      (when (and toolbar name)
        (let ((radio (find-component~ toolbar name)))
          (if (not radio)
              (unselect-elements~ toolbar class: Radio-Tool group: 'workspace)
            (set-selected?~ radio #t))))))
  
  
  (method public virtual undocumented (workspace-button-name workspace)
    (get-name~ workspace))
  
  
  (method public virtual (workspace-installed)
    )
  
  
  (method package (on-zoom-horizontally evt)
    (zoom-direction 'horz))
  
  
  (method package (on-zoom-vertically evt)
    (zoom-direction 'vert))
  
  
  (method package (zoom-direction direction)
    (with-locked-update
      (lambda ()
        (let ((stage (current-stage)))
          (receive (preference view) (find-top-stage stage)
            (continuation-capture
              (lambda (return)
                (for-each-splitter view
                  (lambda (splitter host)
                    (when (and (eq? (get-orientation~ splitter) direction)
                               (get-zoomable?~ splitter))
                      (if (eq? (get-state~ splitter) 'split)
                          (zoom~ splitter host)
                        (unzoom~ splitter))
                      (continuation-return return)))))))))))
  
  
  (method package (on-maximize/restore evt)
    (let ((stage (current-stage)))
      (if (get-maximized?~ stage)
          (restore~ stage)
        (maximize~ stage))))
  
  
  (method package (on-full-stage evt)
    (let ((stage (current-stage)))
      (receive (preference view) (find-top-stage stage)
        (if (is-not? preference Splitter-Preferences)
            (bell)
          (let ((zoom?  (eq? (get-state~ view) 'split)))
            (continuation-capture
              (lambda (return)
                (for-each-splitter (get-border~ stage)
                  (lambda (splitter host)
                    (if zoom?
                        (zoom~ splitter host)
                      (unzoom~ splitter))
                    (when (eq? splitter view)
                      (continuation-return return #f)))))))))))
  
  
  (method package (on-full-screen evt)
    (let ((pref (get-preferences #f)))
      (when (not (get-fullscreen-warned?~ pref))
        (message-box "Warning: There is currently only one way of exiting the fullscreen mode which is by using the Alt-Shift Backspace shortcut for Full Screen toggle")
        (set-property~ preferences-designer pref 'fullscreen-warned? #t)))
    (full-screen (not (get-fullscreen?~ (get-toplevel)))))
  
  
  (method public (full-screen fullscreen?)
    (set-fullscreen?~ (selected-workspace) fullscreen?)
    (full-screen-stage fullscreen?))
  
  
  (method public (full-screen-stage fullscreen?)
    (let ((stage (current-stage)))
      (when stage
        (set-fullscreen?~ stage fullscreen?)
        (receive (preference view) (find-top-stage stage)
          (full-screen-host view fullscreen?)))))
  
  
  (method public (toggle-full-screen host)
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (full-screen-host host fullscreen?)))
  
  
  (method public (full-screen-host host fullscreen?)
    (define (fix-top-splitter-insets splitter)
      (if (not fullscreen?)
          (let ((preserved (get-preserved-insets~ splitter)))
            (when preserved
              (set-preserved-insets~ splitter #f)
              (set-insets~ splitter preserved)))
        (set-preserved-insets~ splitter (get-insets~ splitter))
        (set-insets~ splitter {Rect 0 0 0 0})))
    
    (let ((toplevel (get-toplevel))
          (stage (current-stage)))
      (when (neq? fullscreen? (get-fullscreen?~ toplevel))
        (with-locked-update
          (lambda ()
            (set-fullscreen?~ toplevel fullscreen?)
            (for-each-splitter host
              (lambda (splitter host)
                (let ((preferences (get-preferences~ splitter)))
                  (when (and preferences (eq? (get-name~ preferences) 'top))
                    (fix-top-splitter-insets splitter)))
                (if fullscreen?
                    (zoom~ splitter host)
                  (unzoom~ splitter)))))))))
  
  
  (method public (on-delete-stage evt)
    (delete-stage))
  
  
  (method public (on-delete-other-stages evt)
    (delete-other-stages))
  
  
  (method public (on-split-vertically evt)
    (split-stage-vertically))
  
  
  (method public (on-split-horizontally evt)
    (split-stage-horizontally))
  
  
  (method public (on-move-frame evt)
    (move-frame))
  
  
  (method public (on-clone-frame evt)
    (clone-frame))
  
  
  (method public (on-tie-frame-model evt)
    (tie-frame-model))
  
  
  (method public (on-untie-stage evt)
    (untie-stage))


  ;;;
  ;;;; Toolbar
  ;;;
  
  
  (method public (find-toolbar)
    (let ((host (get-toolbar :toolbar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (find-command-toolbar)
    (define (try name)
      (let ((host (get-toolbar name)))
        (when (and host (in-player?~ host))
          (get-guest~ host))))
    
    (or (try :command)
        (try :minibuffer)
        (try :toolbar)))
   
  
  ;;;
  ;;;; Classes
  ;;;
  
  
  (method public virtual (get-text-class)
    Plain-Text-View)
  

  ;;;
  ;;;; Resources
  ;;;
  
  
  (method public (get-resource type name)
    (case type
      ((image) (new-file~ (resources-dir) (list "images" (format "{a}.png" name))))
      ((cursor) (new-file~ (resources-dir) (cond-expand
                                             (cocoa (list "cursors" name "cursor.pdf"))
                                             (windows (list "cursors" (format "{a}.cur" name)))
                                             (else (error "Custom cursors not supported on this platform")))))))
  
  
  (method protected virtual (resources-dir)
    (if (is-alias? 'Jazz)
        {Directory Jazz "lib" "jazz.resources" "resources"}
      {Directory Build "lib" "jazz.resources" "resources"}))


  ;;;
  ;;;; Images
  ;;;
  
  
  (definition Images-Portfolio
    #f)
  
  
  (method public (get-images-portfolio)
    (unless Images-Portfolio
      (set! Images-Portfolio (new Portfolio name: :images)))
    Images-Portfolio)


  ;;;
  ;;;; Catalog
  ;;;


  (method protected virtual (setup-cataloguer)
    #f)


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method public virtual (designer-default-imports)
    '())
  
  
  (method public virtual (designer-form-imports form)
    '())


  ;;;
  ;;;; Events
  ;;;
  

  (method override (get-event-consumer)
    event-consumer)
  
  
  (method override (set-event-consumer consumer)
    (set! event-consumer consumer))


  (method override (deliver-event handler target proc event)
    (proc target event))


  ;;;
  ;;;; Debug
  ;;;
  
  
  (method override (process-debuggee-loop)
    (if (and (local-proxy? (get-controller-debugger))
             (event-thread?))
        (with-jazz-exception-debugger
          process-events)
      (nextmethod)))


  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method (exception-reported)
    ;; so as not to get recursive exceptions
    (catch Exception
      (cleanup-mouse-processing)))
  
  
  @convert
  (method (present-execution-context exception type prefix?)
    (present~ (new Exception-Presenter) exception type: type prefix?: prefix?))

  
  ;;;
  ;;;; Source
  ;;;
  
  
  (method public (update-source-actions)
    (let* ((results (get-active-results))
           (results-count (and results (get-visible-count~ (get-tree~ results)))))
      (set-action-enabled? {Action application edit-next} (and results (>= results-count 1)))
      (set-action-enabled? {Action application edit-previous} (and results (>= results-count 1)))
      (set-action-enabled? {Action application edit-current} (and results (>= results-count 1)))))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual undocumented (get-search-manager)
    #f)
  
  
  (method public virtual undocumented (get-search-results)
    (get-guest~ (singleton-docked Search-Results)))
  
  
  (method public (active-search-view)
    (let ((manager (get-search-manager)))
      (when manager
        (get-search~ manager))))
  
  
  ;; This needs cleanup as it cannot be done for every application
  (method public (update-search-actions)
    (let* ((document (current-document))
           (result (active-search-result))
           (results (get-search-results))
           (resultset (get-current-resultset~ results))
           (results-count (get-visible-count~ (get-tree~ results))))
      (set-action-enabled? {Action application find-forward} (and result document))
      (set-action-enabled? {Action application find-backward} (and result document))
      (set-action-enabled? {Action application replace} (and result document))
      (set-action-enabled? {Action application replace&find-forward} (and result document))
      (set-action-enabled? {Action application replace-all} (and result document))
      (set-action-enabled? {Action application replace-selected} (>= results-count 1))
      (set-action-enabled? {Action application previous-search} (and result resultset))))


  ;;;
  ;;;; Search Menu
  ;;;
  
  
  (method package (on-find evt)
    (update-search 'text domain: 'window))
  
  
  (method package (on-find-in-text evt)
    (update-search 'text))
  
  
  (method package (on-find-in-projects evt)
    (update-search 'projects))
  
  
  (method package (on-find-in-directories evt)
    (update-search 'directories))
  
  
  (method package (on-find-in-user evt)
    (update-search 'user))
  
  
  (method (update-search tab (domain: domain #f) (selector: selector #f))
    (let* ((focus (get-focus))
           (internal? (is? focus Tree-Embedded-Search-Text-View))
           (strings (and (not internal?) (is? focus Text-View) (get-selected-strings~ focus)))
           (string (and strings (= (length strings) 1) (car strings)))
           (manager (get-search-manager))
           (palette (get-host~ manager))
           (player (get-player~ palette))
           (tab-view (locate~ manager 'tab))
           (same-tab? (eq? tab (get-selection-name~ tab-view))))
      (if (and (not domain)
               (eq? (get-focused-window) player)
               same-tab?)
          (next-radio~ (get-search~ manager))
        (when tab
          (set-selection-name~ tab-view tab)
          (when domain
            (set-search-domain~ (get-search~ manager) domain))))
      (for-each (lambda (search)
                  (let ((targets (get-search-targets~ search)))
                    (unless (or (not string)
                                (and (not-null? targets)
                                     (equal? string (first (first targets)))))
                      (set-search-targets~ search (list (list string ""))))))
                (get-searches~ manager))
      (when (or (not internal?) (not same-tab?))
        (select-search~ (get-search~ manager)))
      (when selector
        (selector (get-search~ manager)))
      (bring-to-front~ player)
      (set-visible?~ player #t)))
  
  
  (method public (end-search-edition)
    (let ((tree (get-targets~ (get-search~ (get-search-manager)))))
      (end-edition~ tree)))


  (method package (on-edit-next evt)
    (edit-next~ (get-active-results)))


  (method package (on-edit-previous evt)
    (edit-previous~ (get-active-results)))


  (method package (on-edit-current evt)
    (edit-current~ (get-active-results)))


  (method package (on-find-forward evt)
    (let ((result (active-search-result)))
      (if result
          (if (find-forward~ result follow?: #f)
              (acquire-focus~ (effective-client~ result))
            (unless (follow-forward~ result)
              (bell)))
        (bell))))


  (method package (on-find-backward evt)
    (let ((result (active-search-result)))
      (if result
          (if (find-backward~ result follow?: #f)
              (acquire-focus~ (effective-client~ result))
            (unless (follow-backward~ result)
              (bell)))
        (bell))))


  (method package (on-replace evt)
    (let ((result (active-search-result)))
      (unless (and result (replace-selection~ result))
        (bell))))


  (method package (on-replace&find-forward evt)
    (let ((result (active-search-result)))
      (unless (and result (replace-selection&find-forward~ result))
        (bell))))


  (method package (on-replace-all evt)
    (let ((result (active-search-result)))
      (if (not result)
          (bell)
        (replace-all~ result))))
  
  
  (method package (on-replace-selected evt)
    (replace-selected~ (get-search-results)))


  (method package (on-previous-search evt)
    (let ((result (active-search-result))
          (results (get-search-results)))
      (let ((resultset (get-current-resultset~ results)))
        (if (eq? (get-current-resultset~ results) (get-resultset~ result))
            (pop-resultset~ results)
          (set-active-search-result (new Search-Result resultset))))))

  
  ;;;
  ;;;; Command Shell
  ;;;
  
  
  (method package (on-command-extended evt)
    (select-command-extended))
  
  
  (method package (on-command-execute evt)
    (select-command-execute))
  
  
  (method public virtual (get-command-shell)
    (let ((toolbar (find-command-toolbar)))
      (when toolbar
        (locate-component~ toolbar 'command-shell))))
  
  
  (method public virtual (get-command-text)
    (let ((shell (get-command-shell)))
      (when shell
        (get-text~ shell))))
  
  
  (method public (require-command-text)
    (or (get-command-text)
        (begin
          (message-box "This workspace doesn't contain a command text")
          (signal-cancel))))
  
  
  (method public (require-unzoomed-command-text)
    (define (unzoom text)
      (let ((host (get-host~ text)))
        (let ((splitter (get-parent~ host)))
          (when (is? splitter Splitter-View)
            (when (eq? (get-state~ splitter) 'zoom)
              (let ((target (get-target~ splitter)))
                (when (neq? target host)
                  (unzoom~ splitter)
                  (set-client-restore~ text
                    (lambda ()
                      (when (in-player?~ splitter)
                        (zoom~ splitter target)))))))))))
    
    (let ((text (require-command-text)))
      (unzoom text)
      text))
  
  
  (method public (select-command-search direction initial)
    (select-search~ (require-unzoomed-command-text) direction #f initial again?: #t))
  
  
  (method public (select-command-search-current direction range initial)
    (select-search~ (require-unzoomed-command-text) direction range initial again?: #f))
  
  
  (method public (select-command-highlight direction range search-result client (highlight?: highlight? #f))
    (select-search~ (require-unzoomed-command-text) direction range #f search-result: search-result client: client highlight?: highlight? again?: #f))
  
  
  (method public (select-command-extended)
    (select-extended~ (require-unzoomed-command-text)))
  
  
  (method public (select-command-execute)
    (select-execute~ (require-unzoomed-command-text)))


  ;;;
  ;;;; Files
  ;;;


  (method package virtual (on-new evt)
    (new-event~ (get-default-frame-class)))
    

  (method package virtual (on-open evt)
    (open-files))
  
  
  (method public (open-files (directory: directory #f))
    (let ((files (choose-file directory: directory extensions: (open-extensions) multiple-selection?: #t)))
      (for-each edit-file
                (sort string>? files key: get-name~))))
  
  
  (method public virtual (receive-files pos pathnames)
    (if (and (= (length pathnames) 1) (directory? (car pathnames)))
        (let ((dir (car pathnames)))
          (set-current-directory dir)
          (user-message "Current directory set to {a}" (parse~ dir)))
      (let ((class (cond ((alt-down?) jazz.editor.jazz:Jazz-Plain-Text-View)
                         ((shift-down?) jazz.editor.jazz:Jazz-Text-View)
                         (else #f))))
        (let ((queue (new-queue)))
          (for-each (lambda (pathname)
                      (when (file? pathname)
                        (with-exception-filter
                          (lambda (exc)
                            (os-exception? exc))
                          (lambda (exc)
                            (enqueue queue pathname))
                          (lambda ()
                            (if class
                                (edit-document pathname class: class)
                              (edit-file pathname))))))
                    pathnames)
          (let ((unreadable (queue-list queue)))
            (when (not-null? unreadable)
              (message-box
                `(<span>
                   (<paragraph> ,(format "The following file{a} could not be read:" (format-plural (length unreadable))))
                   ,@(map (lambda (pathname)
                            `(<bulleted> ,(parse~ pathname)))
                          unreadable))
                title: "Problems")))))))
  
  
  (method public virtual (drop-file filename)
    (let ((pathname (new (case (pathname-type filename) ((directory) Directory) (else File)) (tokenise-filename filename))))
      (let ((pos {Point 0 0}) ;; quicky
            (files (list (anchorize~ pathname))))
        ;; delay as this method gets called before the toplevel is fully
        ;; initialized when opening the application by a drag & drop on it
        (delay-event
          (lambda ()
            (receive-files pos files))))))
  
  
  (method public virtual (edit-file file . rest)
    (apply edit-document file rest))
  
  
  ;; a quicky... this should really be up to the current workspace
  (method public virtual (open-extensions)
    #f)


  (method public (find-document moniker (class: class #f))
    (find-frame-if-guest
      (lambda (guest)
        (and (is? guest Document)
             (or (not class) (is? guest class))
             (let ((guest-moniker (get-moniker~ (get-document-controller~ guest))))
               (and guest-moniker
                    (pathname=? guest-moniker moniker)))))))
  
  
  (method public (edit-document moniker
                                (class: class #f)
                                (kind: kind #f)
                                (workspace: workspace #f)
                                (selection: selection #f)
                                (force-selection?: force-selection? #f)
                                (generate-event?: generate-event? #t)
                                (char-encoding: char-encoding #f)
                                (wrap?: wrap? #f)
                                (force-new?: force-new? #f)
                                (visible?: visible? #t)
                                (activate-focus?: activate-focus? #t)
                                (return-new?: return-new? #f))
    (when moniker
      (if (not (exists?~ moniker))
          (error "Unable to locate document: {t}" moniker)
        (let ((file moniker))
          (let ((frame (if force-new? #f (find-document file class: class))))
            (define (return frame new?)
              (if return-new?
                  (values frame new?)
                frame))
            
            (if (not frame)
                (let ((class (or class (file-frame-class file))))
                  (with-cursor :wait
                    (lambda ()
                      (let ((frame (new-frame class
                                              kind: kind
                                              host-workspace: workspace
                                              host-visible?: visible?
                                              host-focus?: activate-focus?
                                              initialize: (lambda (document)
                                                            (let ((text? (is? document Text-View)))
                                                              (when text?
                                                                (set-char-encoding~ (get-model~ document) char-encoding))
                                                              (set-moniker~ (get-document-controller~ document) moniker)
                                                              (when (and text? wrap?)
                                                                (set-wrap?~ (get-model~ document) #t)))))))
                        (when selection
                          (let ((document (get-guest~ frame)))
                            (when (is? document Text-View)
                              (end-completion~ document)
                              (set-selection-safe~ document selection reposition: 'vertical ensure-displayed?: 'center-caret force?: force-selection? generate-event?: generate-event?))))
                        (return frame #t)))))
              (when selection
                (let ((document (get-guest~ frame)))
                  (end-completion~ document)
                  (set-selection-safe~ document selection ensure-displayed?: #f force?: force-selection? generate-event?: generate-event?)
                  (ensure-displayed~ document force-vertical: 'head)))
              (when (and workspace (neq? workspace (get-workspace~ frame)))
                (set-workspace~ frame workspace)
                (apply-preferences~ (get-workspace workspace) restore-focus?: #f))
              (when (and visible? activate-focus?)
                (focus-host~ frame))
              (verify-reload~ (get-document-controller~ (get-guest~ frame)))
              (return frame #f)))))))
  
  
  (method public (edit-help-document moniker)
    (let* ((frame (edit-document moniker))
           (text (get-guest~ frame)))
      (set-editable?~ text #f)))
  
  
  (method public (edit-filename filename)
    (let* ((workbench (get-service 'workbench))
           (project-file (and workbench (find-filename~ workbench filename))))
      (if (not project-file)
          (error "Unable to locate filename: {t}" filename)
        (let* ((frame (edit-document (get-source~ project-file)))
               (text (get-guest~ frame)))
          (verify-reload~ (get-document-controller~ text))))))
  
  
  (method package virtual (on-close evt)
    (let ((frame (front-frame)))
      (when frame
        (close-host~ frame))))

  
  (method package virtual (on-close-all evt)
    (for-each (lambda (view)
                (when (is? view Frame-Host)
                  (let ((guest (get-guest~ view)))
                    (when (or (is-not? guest Document) (close-on-close-all?~ (get-document-controller~ guest)))
                      (confirm-close~ view)
                      (close-host~ view)))))
              (all-frames)))
        
    
  (method package virtual (on-save-all evt)
    (save-all))
  
  
  (method package virtual (on-print evt)
    (let ((guest (current-guest)))
      (print-document~ guest)))

   
  (method package virtual (on-print-layout evt)
    (let ((guest (current-guest)))
      (print-layout~ guest)))

  
  (method package virtual (on-print-preview evt)
    (let ((guest (current-guest)))
      (print-preview~ guest)))
  
  
  (method package virtual (on-quit-application evt)
    (exit-process))
  
  
  (method public (save-all (class: class Document) (save-unanchored?: save-unanchored? #t))
    (let ((save-documents
            (lambda (main-documents?)
              (for-each (lambda (host)
                          (when (is? host Frame-Host)
                            (let ((guest (get-guest~ host)))
                              (when (is? guest Document)
                                (let ((controller (get-document-controller~ guest)))
                                  (when (and (is? guest class)
                                             (or save-unanchored? (get-moniker~ guest))
                                             (xor main-documents? (dependent-document?~ controller))
                                             (get-modified?~ controller))
                                    (save~ guest)))))))
                        (all-frames include-invisibles?: #t)))))
      ;; saving dependent documents will make their main document modified
      (save-documents #f)
      (save-documents #t)))


  ;;;
  ;;;; Definitions
  ;;;

  
  (method public virtual (edit-definitions object . rest)
    )

  
  (method public virtual (edit-references object . rest)
    )


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (context-update)
    (define (modify-profile)
      (when profile
        (close~ profile))
      (let ((pref (get-preferences #f error?: #f)))
        (when pref
          (let ((class-unit (or (get-profile-class~ pref) Profile)))
            (when class-unit
              (set! profile (new (load-profile-class class-unit)))))))
      (when profile
        (init~ profile))
      (when profile
        (finalize~ profile)))
    
    (nextmethod)
    (modify-profile)
    (user-message "Context set to {a}" context))

  
  ;;;
  ;;;; Preferences
  ;;;
  
  
  (method override (setup-preferences)
    (with-safe-execution "loading the preferences"
      (lambda ()
        (setup-preferences/designer))
      continue-handler:
      (lambda (err)
        (set-preferences/designer (default-preferences)))))
  
  
  (method override (default-preferences)
    (new Application-Preferences))
  
  
  (method protected virtual (toolbox-file toolbox)
    (new-file~ {Directory Profile "settings"}
      (or toolbox "Toolbox.jml")))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (definition Default-Page-Setup
    #f)
  
  (definition Default-Page-Setup-Form
    #f)
  
  (definition Default-Page-Setup-Designer
    #f)
  
  
  (definition public (set-default-page-setup setup)
    (set! Default-Page-Setup setup))
  
  
  (method virtual (get-page-setup-file)
    (when (is-alias? 'Profile)
      {File Profile "settings" "PageSetup.jml"}))
  
  
  (method virtual (get-page-setup-form)
    (<form> (<Page-Setup>)))
  
  
  (method public (default-page-setup)
    (when (not Default-Page-Setup)
      (setup-page-setup))
    Default-Page-Setup)
  
  
  (method public (default-page-setup-designer)
    (when (not Default-Page-Setup-Designer)
      (setup-page-setup))
    Default-Page-Setup-Designer)
  
  
  (method public (default-page-setup-parcel designer)
    (when (not Default-Page-Setup)
      (setup-page-setup))
    (package-component~ designer (default-page-setup)))
  
  
  (method public (default-apply-page-setup designer form page-setup)
    (when form
      (apply-form~ designer form (default-page-setup))))
  
  
  (method virtual (setup-page-setup)
    (let* ((file (get-page-setup-file))
           (form (if (and file (exists?~ file)) (read-form file) (get-page-setup-form)))
           (reference (instantiate~ form)))
      (set! Default-Page-Setup reference)
      (set! Default-Page-Setup-Form form)
      (set! Default-Page-Setup-Designer (new Designer form: form reference: reference))))
  
  
  (method virtual (save-page-setup)
    (when (and Default-Page-Setup-Designer (file? (get-origin~ (get-form~ Default-Page-Setup-Designer))))
      (let ((form (get-form~ Default-Page-Setup-Designer)))
        (when (not (get-origin~ form))
          (set-origin~ form (get-page-setup-file))))
      (save~ Default-Page-Setup-Designer)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public virtual (get-documentation-cataloguer)
    #f)
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  (method (on-zoom-out evt)
    (scale-view (get-property~ evt what:) 0.75))
  
  
  (method (on-zoom-in evt)
    (scale-view (get-property~ evt what:) 1.25))
  
  
  (method (on-unzoom evt)
    (scale-view (get-property~ evt what:) #f))
  
  
  (method (scale-view what factor)
    (define (scaled-view what)
      (case what
        ((document) (current-document))
        ((mouse-view) (mouse-view))))
    
    (let ((view (scaled-view what)))
      (scale-view~ view factor)
      (user-message "Scaling set to {a}" (get-scaling~ view))))


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (on-capture-document evt)
    (pick-figure
      click: (lambda (view pos) (capture-document view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-document evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-document view))))
  
  
  (definition (capture-document view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (let ((guest (get-guest~ view)))
          (if (not guest)
              (bell)
            (export-picture~ guest))))))
  
  
  (method (on-capture-host evt)
    (pick-figure
      click: (lambda (view pos) (capture-host view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-host evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-host view))))
  
  
  (definition (capture-host view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (export-picture~ host))))


  ;;;
  ;;;; Windows
  ;;;
  
  
  (method public virtual (update-windowing-actions)
    (unless (exiting-process?)
      (update-history-actions)
      (update-window-actions)
      (update-menubar-buttons)))
  
  
  (method public (update-window-actions)
    (let ((all-frames (length (all-frames)))
          (frames (length (current-stage-frames)))
          (stages (length (get-active-stages)))
          (in-modal? (in-modal?)))
      (set-action-enabled? {Action application close}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application close-all}         (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save}                    (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save-as}                 (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application save-all}          (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest revert-saved}            (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest compare-saved}           (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application page-setup}        (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-layout}      (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-preview}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-frame}        (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-frame}    (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application current-frame}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-stage}        (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-stage}    (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-horizontally} (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-vertically}   (and (>= frames 2) (not in-modal?)))))
  
  
  (method package virtual (on-next-frame evt)
    (let ((first (first-frame)))
      (send-frame-to-back first)
      (send-to-back~ first)
      (focus-host~ (front-frame))))
  
  
  (method package virtual (on-previous-frame evt)
    (let ((last (last-frame)))
      (bring-frame-to-front last)
      (bring-to-front~ last)
      (focus-host~ (front-frame))))
  
  
  (method package virtual (on-current-frame evt)
    (let ((first (first-frame)))
      (focus-host~ first)))
  
  
  (method package (on-next-stage evt)
    (or (navigate-next-stage)
        (bell)))
  
  
  (method package (on-previous-stage evt)
    (or (navigate-previous-stage)
        (bell)))
  
  
  (method package virtual (on-tile-horizontally evt)
    (let* ((two-frames? (shift-down?))
           (stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (w (quotient width (if two-frames? 2 count)))
           (l 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point l 0))
                      (set-size~ frame (new Dimension w height))
                      (increase! l w))
                    (if (and two-frames? (>= count 2))
                        (subseq frames 0 2)
                      frames))))))
  
  
  (method package virtual (on-tile-vertically evt)
    (let* ((two-frames? (shift-down?))
           (stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (h (quotient height (if two-frames? 2 count)))
           (t 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point 0 t))
                      (set-size~ frame (new Dimension width h))
                      (increase! t h))
                    (if (and two-frames? (>= count 2))
                        (subseq frames 0 2)
                      frames))))))
  
  
  (method package (on-select-frame evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ host)
      (focus-host~ host)))
  
  
  (method package (on-select-palette evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ (get-player~ host))))


  ;;;
  ;;;; Modal
  ;;;
  
  
  (method package virtual (update-modal-actions)
    (update-windowing-actions)))


;;;
;;;; Default-Workspace
;;;


(class Default-Workspace extends Workspace-Preferences
  
  
  (form
    (<install>             fullscreen?: #t
      (<Stage-Preferences> location: root)))))
