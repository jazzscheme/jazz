;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Associative Storage
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.associative jazz


(hub add-directory)
(hub add-file)
(hub add-path)
(hub branch-name)
(hub branch?)
(hub branches)
(hub checkout)
(hub commit)
(hub commit-index)
(hub commit?)
(hub config-get)
(hub config-set)
(hub diff)
(hub discard)
(hub exists?)
(hub find-entry)
(hub get-changes)
(hub get-directory)
(hub get-entries)
(hub get-file)
(hub get-head)
(hub get-index)
(hub get-objects)
(hub head-index)
(hub init)
(hub parse)
(hub read-head)
(hub remove-directory)
(hub remove-file)
(hub remove-path)
(hub require-head)
(hub reset)
(hub resolve)
(hub restore)
(hub retrieve)
(hub retrieve-blob)
(hub save-to-file)
(hub scan)
(hub scan-directory)
(hub scan-file)
(hub staging-index)
(hub staging-status)
(hub staging-tree)
(hub update)
(hub working-index)
(hub working-status)


(import (jazz.io)
        (jazz.pack)
        (jazz.settings)
        (jazz.time)
        (jazz.zlib)
        (time))


;;;
;;;; Interface
;;;


(definition public (jas-settings)
  {Directory Home ".jas"})


(definition public (jas-init root (bare?: bare? #f) (open?: open? #f))
  (new Associative-Repository root init?: #t bare?: bare? open?: open?))


(definition public (jas-open root)
  (new Associative-Repository root))


(definition public (jas-config-get repo key)
  (config-get repo key))


(definition public (jas-config-set repo key value)
  (config-set repo key value))


(definition public (jas-staging-tree repo)
  (staging-tree repo))


(definition public (jas-commit repo author email message tree parent)
  (commit repo author email message tree parent))


(definition public (jas-discard repo (dirpath: dirpath #f))
  (discard repo dirpath: dirpath))


(definition public (jas-restore repo commit)
  (restore repo commit))


(definition public (jas-reset repo commit)
  (reset repo commit))


(definition public (jas-branches repo)
  (branches repo))


(definition public (jas-checkout repo name (validate-clean?: validate-clean? #f) (create?: create? #f))
  (checkout repo name validate-clean?: validate-clean? create?: create?))


(definition public (jas-read-head repo)
  (read-head repo))


(definition public (jas-require-head repo)
  (require-head repo))


(definition public (jas-add repo path)
  (add-path repo path))


(definition public (jas-remove repo path)
  (remove-path repo path))


(definition public (jas-sync repo)
  (sync repo))


(definition public (jas-head-index repo)
  (head-index repo))


(definition public (jas-working-index repo)
  (working-index repo))


(definition public (jas-staging-index repo)
  (staging-index repo))


(definition public (jas-commit-index repo commit)
  (commit-index repo commit))


(definition public (jas-staging-status repo)
  (staging-status repo))


(definition public (jas-working-status repo (dirpath: dirpath #f))
  (working-status repo dirpath: dirpath))


(definition public (jas-diff repo from to)
  (diff repo from to))


(definition public (jas-commit? repo ref)
  (commit? repo ref))


(definition public (jas-branch? repo ref)
  (branch? repo ref))


(definition public (jas-branch-name repo ref)
  (branch-name repo ref))


(definition public (jas-resolve repo ref)
  (resolve repo ref))


(definition public (jas-parse repo rev)
  (parse repo rev))


(definition public (jas-retrieve repo digest)
  (retrieve repo digest))


(definition public (jas-scan repo path)
  (scan repo path))


(definition public (jas-collect repo dry?)
  (collect-objects repo dry?))


;;;
;;;; Repository
;;;


(definition ignored-toplevel-dirnames
  '(".jas" ".git"))

(definition ignored-dirnames
  '("_CodeSignature"))


(class Associative-Repository extends Object
  
  
  (slot working         getter generate)
  (slot directory       getter generate)
  (slot global-settings getter generate)
  (slot local-settings  getter generate)
  (slot settings-list   getter generate)
  (slot disregard       getter generate)
  (slot ignore          getter generate)
  (slot head            getter generate)
  (slot index           getter generate)
  (slot objects         getter generate)
  (slot heads           getter generate)
  (slot sets            getter generate)
  (slot filters         getter generate)
  
  
  (method override (initialize self root (init?: init? #f) (bare?: bare? #f) (open?: open? #f) (directory: directory #f))
    (define (already-inited?)
      (or (exists? (new-directory root ".jas"))
          (exists? (new-file root ".jasbare"))))
    
    (let ((init? (and init? (not (already-inited?)))))
      (define (jas-bare?)
        (if init?
            bare?
          (exists? (new-file root ".jasbare"))))
      
      (define (jas-directory)
        (let ((dir (or directory (new-directory root ".jas"))))
          (cond ((exists? dir)
                 dir)
                (init?
                 (create-directories dir)
                 dir)
                (else
                 (jas-exception "Not a jas repository")))))
      
      (define (jas-open? directory)
        (if init?
            open?
          (not (exists? (new-directory directory "objects")))))
      
      (initialize-aliases)
      (let ((bare? (jas-bare?)))
        (let ((working (and (not bare?) root))
              (directory (if bare? root (jas-directory))))
          (set! self.working working)
          (set! self.directory directory)
          (let ((open? (jas-open? directory)))
            (set! self.head (new-file directory "HEAD"))
            (set! self.index (new Associative-Index self working file: (new-file directory "index")))
            (set! self.objects (and (not open?) (new-directory directory "objects")))
            (set! self.heads (new-directory directory '("refs" "heads")))
            (set! self.sets (new-directory directory '("sets")))
            (set! self.filters (load-filters self))
            (set! self.disregard '(".DS_Store" ".gitignore"))
            (set! self.ignore '())
            (when init?
              (init self bare? open?))
            (register-configs self))))))
  
  
  (method package (bare? self)
    (not working))
  
  
  (method package (open? self)
    (not objects))
  
  
  ;;;
  ;;;; Init
  ;;;
  
  
  (method package (init self bare? open?)
    (create-directories directory)
    (when bare?
      (create (new-file directory ".jasbare")))
    (unless open?
      (create-directories objects))
    (create-directories heads)
    (create-directories sets))
  
  
  ;;;
  ;;;; Config
  ;;;
  
  
  (method (register-configs self)
    ;; cleanup old .jas being a file
    (let ((pathname (parse {File Home ".jas"})))
      (when (and (file-exists? pathname)
                 (eq? (pathname-type pathname) 'file))
        (delete-file pathname)))
    (let ((global (new-file (jas-settings) "config"))
          (local (new-file directory "config")))
      (define (new-settings file)
        (when (not (exists? file))
          (create file))
        (new File-Settings file: file))
      
      (set! global-settings (new-settings global))
      (set! local-settings (new-settings local))
      (set! settings-list (list local-settings global-settings))))
  
  
  (method package (config-get self key)
    (locate-setting settings-list key))
  
  
  (method package (config-set self key value)
    (let ((settings local-settings))
      (set-setting settings key value)
      (save-content settings)))
  
  
  ;;;
  ;;;; Load
  ;;;
  
  
  (method (load-filters self)
    (define (load-sets file)
      (call-with-input-file (path-settings file)
        read-all))
    
    (define (load-conditions file)
      (collect (lambda (line)
                 (cond ((empty-string? line)
                    #f)
                   ((starts-with? line ".")
                    (cons 'extension (filename-extension line)))
                   ((ends-with? line "/")
                    (cons 'directory line))
                   (else
                    (cons 'file line))))
               (load-lines file)))
    
    ;; backward compatible
    (if (not (exists? sets))
        '()
      (let ((names #f)
            (filters '()))
        (iterate-directory sets
          (lambda (file)
            (let ((name (get-name file)))
              (if (filename=? name ".sets")
                  (set! names (load-sets file))
                (let ((name (string->symbol (get-name file)))
                      (conditions (load-conditions file)))
                  (set! filters (cons (new Associative-Filter name conditions) filters))))))
          files?: #t
          directories?: #f
          recursive?: #f)
        (if (not names)
            (sort nu<? filters key: get-name)
          (map (lambda (name)
                 (find filters name key: get-name return: 'item))
               names)))))
  
  
  ;;;
  ;;;; Database
  ;;;
  
  
  (method (objects-file self digest)
    (new-file objects digest))
  
  
  ;;;
  ;;;; Store
  ;;;
  
  
  (method (store-tree self tree)
    (store-content self tree))
  
  
  (method (store-content self content)
    (let ((digest (digest-u8vector (object->u8vector content) 'SHA-1)))
      (call-with-output-file (path-settings (objects-file self digest))
        (lambda (output)
          (pp content output)))
      digest))
  
  
  (method package (store-file self file digest)
    (store-blob self (load-binary file) digest (get-extension file)))
  
  
  (method package (store-blob self content digest extension)
    (let ((object-content (if (already-compressed? extension)
                              content
                            (zlib-deflate content))))
      (store-object self object-content digest)))
  
  
  (method package (store-object self content digest)
    (let ((file (objects-file self digest)))
      (save-binary file content)
      content))
  
  
  ;;;
  ;;;; Retrieve
  ;;;
  
  
  (method package (exists? self digest)
    (exists? (objects-file self digest)))
  
  
  (method package (retrieve self digest)
    (call-with-input-file (path-settings (objects-file self digest))
      read))
  
  
  (method package (retrieve-file self digest file flags (content #f))
    (create-directories file)
    (save-binary file (retrieve-blob self digest (get-extension file) content))
    (set-permissions file flags))
  
  
  (method package (retrieve-blob self digest extension (content #f))
    (let ((object-content (or content (retrieve-object self digest))))
      (if (already-compressed? extension)
          object-content
        (zlib-inflate object-content))))
  
  
  (method package (retrieve-object self digest)
    (let ((file (objects-file self digest)))
      (load-binary file)))
  
  
  ;;;
  ;;;; Collect
  ;;;
  
  
  (method package (collect-objects self dry?)
    (if (read-head self)
        (jas-exception "Only commitless repositories can be collected")
      (let ((alive (make-table test: equal?)))
        (for-each (lambda (entry)
                    (let ((digest (get-digest entry)))
                      (table-set! alive digest #t)))
                  (get-entries index))
        (let ((queue (new-queue)))
          (iterate-directory objects
            (lambda (file)
              (let ((digest (get-name file)))
                (when (not (table-ref alive digest #f))
                  (enqueue queue file)))))
          (let ((dead (queue-list queue)))
            (let ((count (length dead)))
              (if dry?
                  (format :terminal "{a} object{a} would be collected{%}" (capitalize (format-cardinality count)) (format-plural count))
                (for-each delete dead)
                (format :terminal "{a} object{a} collected{%}" (capitalize (format-cardinality count)) (format-plural count)))))))))
  
  
  ;;;
  ;;;; Commit
  ;;;
  
  
  (method package (staging-tree self)
    (index->tree self index))
  
  
  (method package (commit self author email message tree parent)
    (let ((time (date->string (system-date) "~a ~b ~d ~H:~M:~S ~Y ~z")))
      (let ((content (list author email message tree parent time)))
        (let ((commit (store-content self content))
              (head (read-head self)))
          (cond ((branch? self head)
                 (write-branch self (branch-name self head) commit))
                ((and (commit? self head)
                      (equal? head parent))
                 (write-head self commit))
                ((and (not head)
                      (not parent))
                 (write-branch self "master" commit)
                 (write-head self (make-branch self "master"))))
          commit))))
  
  
  (method (commit-tree self commit)
    (bind (author email message tree parent time) (retrieve self commit)
      tree))
  
  
  (method (commit-parent self commit)
    (bind (author email message tree parent time) (retrieve self commit)
      parent))
  
  
  ;;;
  ;;;; Discard
  ;;;
  
  
  (method package (discard self (dirpath: dirpath #f) (ignore-set?: ignore-set? #f))
    (let ((diff (diff self (working-index self dirpath: dirpath) (staging-index self dirpath: dirpath) ignore-set?: ignore-set?)))
      (discarding-directories self
        (lambda (discard-directory)
          (for-each (lambda (change)
                      (bind (what path . rest) change
                        (let ((file (new-file working (tokenise-filename path))))
                          (case what
                            ((added)
                             (delete file)
                             (discard-directory (get-parent file)))
                            ((removed)
                             (let ((entry (car rest)))
                               (let ((digest (get-digest entry))
                                     (flags (get-flags entry)))
                                 (retrieve-file self digest file flags))))
                            ((modified)
                             (let ((entry (cadr rest)))
                               (let ((digest (get-digest entry))
                                     (flags (get-flags entry)))
                                 (retrieve-file self digest file flags))))))))
                    (get-changes diff))))
      diff))
  
  
  (method package (discarding-directories self proc)
    (if (bare? self)
        (proc (lambda (dir)))
      (let ((queue (new-queue)))
        (define (discard-directory dir)
          (unless (member? dir (queue-list queue) test: pathname=?)
            (enqueue queue dir)))
        
        (define (directory-empty? dir)
          (continuation-capture
            (lambda (return)
              (iterate-directory dir
                (lambda (path)
                  (unless (member? (get-name path) disregard)
                    (continuation-return return #f)))
                files?: #t
                directories?: #t
                recursive?: #f
                ignored-toplevel-dirnames: ignored-toplevel-dirnames
                ignored-dirnames: ignored-dirnames)
              #t)))
        
        (prog1 (proc discard-directory)
          (for-each (lambda (dir)
                      (when (and (exists? dir)
                                 (directory-empty? dir))
                        (unless (pathname=? dir working)
                          (delete dir))))
                    (queue-list queue))))))
  
  
  ;;;
  ;;;; Restore
  ;;;
  
  
  (method package (restore self commit)
    (let ((head (require-head self)))
      (if (equal? (resolve self head) commit)
          (discard self)
        (discard self)
        (checkout-commit self commit)
        (cond ((commit? self head)
               (write-head self commit))
              (else
               (let ((name (branch-name self head)))
                 (write-branch self name commit)))))))
  
  
  ;;;
  ;;;; Reset
  ;;;
  
  
  (method package (reset self commit)
    (let ((head (require-head self)))
      (cond ((commit? self head)
             (jas-exception "Unable to reset while in a detached HEAD state"))
            (else
             (let ((name (branch-name self head)))
               (write-branch self name commit))))))
  
  
  ;;;
  ;;;; Sync
  ;;;
  
  
  (method package (sync self)
    (let ((working-index (working-index self))
          (staging-index (staging-index self)))
      (let ((diff (diff self working-index staging-index)))
        (discarding-directories self
          (lambda (discard-directory)
            (for-each (lambda (change)
                        (bind (what path . rest) change
                          (let ((file (new-file working (tokenise-filename path))))
                            (case what
                              ((added)
                               (add-file staging-index path file))
                              ((removed)
                               (discard-directory (get-parent file))
                               (remove-file staging-index path))
                              ((modified)
                               (add-file staging-index path file))))))
                      (get-changes diff))))
        (save-to-file staging-index)
        diff)))
  
  
  ;;;
  ;;;; Checkout
  ;;;
  
  
  (method package (checkout self name (validate-clean?: validate-clean? #f) (create?: create? #f))
    (when (and validate-clean?
               (not-null? (get-changes (diff self (working-index self) (staging-index self)))))
      (jas-exception "Please commit your changes before you can checkout"))
    (cond (create?
           (let ((commit (resolve self (require-head self))))
             (write-branch self name commit)
             (write-head self (make-branch self name))
             commit))
          ((branch-exists? self name)
           (let ((ref (make-branch self name)))
             (checkout-commit self (resolve self ref))
             (write-head self ref)
             ref))
          (else
           (let ((commit (resolve self (parse self name))))
             (if (exists? self commit)
                 (begin
                   (checkout-commit self commit)
                   (write-head self commit)
                   commit)
               (jas-exception "Unable to checkout {a}" name))))))
  
  
  (method (checkout-commit self commit)
    (let ((staging-index (staging-index self))
          (commit-index (commit-index self commit)))
      (let ((diff (diff self commit-index staging-index)))
        (discarding-directories self
          (lambda (discard-directory)
            (for-each (lambda (change)
                        (bind (what path . rest) change
                          (let ((file (new-file working (tokenise-filename path))))
                            (case what
                              ((added)
                               (let ((entry (car rest)))
                                 (let ((digest (get-digest entry))
                                       (flags (get-flags entry)))
                                   (retrieve-file self digest file flags)))
                               (add-file staging-index path file))
                              ((removed)
                               (delete file)
                               (discard-directory (get-parent file))
                               (remove-file staging-index path))
                              ((modified)
                               (let ((entry (car rest)))
                                 (let ((digest (get-digest entry))
                                       (flags (get-flags entry)))
                                   (retrieve-file self digest file flags)))
                               (add-file staging-index path file))))))
                      (get-changes diff))))
        (save-to-file staging-index))))
  
  
  ;;;
  ;;;; Index
  ;;;
  
  
  (method package (add-path self path)
    (receive (path pathname) (normalize-path self path)
      (cond ((directory? pathname)
             (add-directory index path pathname))
            (else
             (add-file index path pathname)))))
  
  
  (method package (remove-path self path)
    (if (bare? self)
        (cond ((equal? path ".")
               (remove-directory index ""))
              ((ends-with? path "/")
               (remove-directory index path))
              (else
               (remove-file index path)))
      (receive (path pathname) (normalize-path self path)
        (cond ((directory? pathname)
               (iterate-subpaths index path
                 (lambda (subpath)
                   (let ((file (new-file working (tokenise-filename subpath))))
                     (when (exists? file)
                       (delete file)))))
               (delete-empty-directories pathname)
               (remove-directory index path))
              (else
               (discarding-directories self
                 (lambda (discard-directory)
                   (delete pathname)
                   (discard-directory (get-parent pathname))
                   (remove-file index path))))))))
  
  
  (method (normalize-path self path)
    (if (equal? path ".")
        (values "" working)
      (let ((pathname (string-append (parse working) path)))
        (if (file-exists? pathname)
            (case (pathname-type pathname)
              ((file)
               (values path (new-file working (tokenise-filename path))))
              (else
               (let ((path (normalize-directory path)))
                 (values path (new-directory working (tokenise-filename path))))))
          (jas-exception "Unable to find {a}" path)))))
  
  
  (method package (head-index self)
    (let ((head (read-head self)))
      (if (not head)
          (new Associative-Index self #f)
        (commit-index self (resolve self head)))))
  
  
  (method package (working-index self (dirpath: dirpath #f))
    (let ((working-index (if (not dirpath)
                             (new Associative-Index self working entries: (scan-directory self "" working base: index))
                           (let ((dir (new-directory working (tokenise-filename dirpath))))
                             (new Associative-Index self dir entries: (scan-directory self dirpath dir base: index))))))
      (save-to-file index)
      working-index))
  
  
  (method package (staging-index self (dirpath: dirpath #f))
    (if (not dirpath)
        index
      (directory-index index dirpath)))
  
  
  (method package (commit-index self commit)
    (tree->index self (commit-tree self commit)))
  
  
  (method (tree->index self tree)
    (new Associative-Index self #f entries: (scan-tree self tree)))
  
  
  (method (scan self path)
    (receive (path pathname) (normalize-path self path)
      (scan-file self path pathname base: index)))
  
  
  (method package (scan-file self path file (base: base #f))
    (let ((filename (parse file)))
      (let ((seconds (get-last-modification-seconds file))
            (flags (determine-flags filename))
            (set (determine-set self path)))
        (or (and base (let ((entry (find-entry base path)))
                        (and entry
                             (let ((entry-digest (get-digest entry))
                                   (entry-seconds (get-seconds entry))
                                   (entry-flags (get-flags entry))
                                   (entry-set (get-set entry))
                                   (entry-live? (get-live? entry)))
                               (and entry-seconds
                                    (if (and (= entry-seconds seconds)
                                             (= entry-flags flags)
                                             (eq? entry-set set))
                                        (new Associative-Entry path entry-digest entry-seconds entry-flags entry-set entry-live?)
                                      (let ((digest (digest-file (parse file) 'SHA-1)))
                                        ;; update base entry seconds
                                        ;; we do not update the digest
                                        ;; we are only creating a fast test
                                        ;; path + seconds = correct digest
                                        (when (equal? entry-digest digest)
                                          (set-seconds entry seconds))
                                        (new Associative-Entry path digest seconds flags set #f))))))))
            (new Associative-Entry
              path
              (digest-file filename 'SHA-1)
              seconds
              flags
              set
              #f)))))
  
  
  (method package (scan-blob self path content)
    (new Associative-Entry path (digest-u8vector content 'SHA-1) #f 0 #f #f))
  
  
  (method package (scan-directory self dirpath dir (base: base #f))
    (scanning-directory dirpath dir
      (lambda (path file base)
        (scan-file self path file base: base))
      disregard: disregard
      ignore: ignore
      base: base))
  
  
  (method (scan-tree self tree)
    (let ((entries (new-queue)))
      (define (scan prefix tree)
        (for-each (lambda (entry)
                    (bind (kind path digest . rest) entry
                      (case kind
                        ((blob) (enqueue entries (new Associative-Entry (string-append prefix path) digest #f (car rest) #f #f)))
                        ((tree) (scan (string-append prefix path "/") digest)))))
                  (retrieve self tree)))
      
      (scan "" tree)
      (queue-list entries)))
  
  
  (method (index->tree self index)
    (let ((directory (get-directory index))
          (entries (get-entries index)))
      (define (gather prefix)
        (let ((len (string-length prefix))
              (queue (new-queue)))
          (define (prefix-change path)
            (let ((slash (search path "/" start: len)))
              (and slash
                   (substring path 0 (+ slash 1)))))
          
          (let (iter)
            (if (null? entries)
                (store-tree self (queue-list queue))
              (let ((entry (car entries)))
                (let ((path (get-path entry))
                      (digest (get-digest entry))
                      (flags (get-flags entry)))
                  (if (starts-with? path prefix)
                      (let ((slash (search path "/" start: len)))
                        (if (not slash)
                            (let ((file (new-file directory (tokenise-filename path))))
                              (enqueue queue (list 'blob (get-name file) digest flags))
                              (set! entries (cdr entries))
                              (iter))
                          (let ((name (substring path len slash))
                                (new-prefix (substring path 0 (+ slash 1))))
                            (enqueue queue (list 'tree name (gather new-prefix)))
                            (iter))))
                    (store-tree self (queue-list queue)))))))))
      
      (assert directory)
      (gather "")))
  
  
  (method package (find-entry self path)
    (find-entry index path))
  
  
  ;;;
  ;;;; Set
  ;;;
  
  
  (method (determine-set self path)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (filter)
                    (when (filter-path filter path)
                      (continuation-return return (get-name filter))))
                  filters)
        #f)))
  
  
  ;;;
  ;;;; Diff
  ;;;
  
  
  (method package (diff self left-index right-index (ignore-set?: ignore-set? #f))
    (diff-entries self
                  (get-entries left-index)
                  (get-entries right-index)
                  ignore-set?: ignore-set?))
  
  
  (method package (diff-sets self remote-index local-index sets update-sets)
    (let ((local-entries (get-entries local-index))
          (remote-entries (get-entries remote-index)))
      (define (determine-effective-sets)
        (if (not update-sets)
            sets
          (let ((queue (new-queue))
                (local-sets (make-table test: eq?)))
            (enqueue-list queue sets)
            (for-each (lambda (entry)
                        (table-set! local-sets (get-set entry) #t))
                      local-entries)
            (for-each (lambda (set)
                        (when (table-ref local-sets set #f)
                          (enqueue queue set)))
                      update-sets)
            (queue-list queue))))
      
      (let ((effective-sets (determine-effective-sets)))
        (define (filter kind entries)
          (collect-if (lambda (entry)
                        (let ((entry-set (get-set entry)))
                          (some? (lambda (set)
                                   ;; only live
                                   (if (pair? set)
                                       (let ((set (car set)))
                                         (if (eq? kind 'remote)
                                             (and (eq? set entry-set)
                                                  (get-live? entry))
                                           (eq? set entry-set)))
                                     (eq? set entry-set)))
                                 effective-sets)))
                      entries))
        
        (diff-entries self
                      (filter 'remote remote-entries)
                      (filter 'local local-entries)))))
  
  
  (method package (diff-entries self left-entries right-entries (ignore-set?: ignore-set? #f))
    (let ((queue (new-queue))
          (added 0)
          (modified 0)
          (removed 0))
      (merge-ordered (lambda (what key left right)
                       (case what
                         ((:left)
                          (enqueue queue (list 'added key left))
                          (increase! added))
                         ((:right)
                          (enqueue queue (list 'removed key right))
                          (increase! removed))
                         ((:same)
                          (unless (and (equal? (get-digest left) (get-digest right))
                                       (= (get-flags left) (get-flags right))
                                       (or ignore-set?
                                           (eq? (get-set left) (get-set right))))
                            (enqueue queue (list 'modified key left right))
                            (increase! modified)))))
                     left-entries
                     right-entries
                     key: get-path
                     case-insensitive?: #t)
      (new Associative-Diff (queue-list queue) added modified removed)))
  
  
  ;;;
  ;;;; Status
  ;;;
  
  
  (method package (staging-status self)
    (diff self (staging-index self) (head-index self)))
  
  
  (method package (working-status self (dirpath: dirpath #f) (ignore-set?: ignore-set? #f))
    (diff self (working-index self dirpath: dirpath) (staging-index self dirpath: dirpath) ignore-set?: ignore-set?))
  
  
  ;;;
  ;;;; Head
  ;;;
  
  
  (method (write-head self ref)
    (call-with-output-file (path-settings head)
      (lambda (output)
        (write ref output)
        (newline output))))
  
  
  (method package (read-head self)
    (and (exists? head)
         (call-with-input-file (path-settings head)
           read)))
  
  
  (method package (require-head self)
    (or (read-head self)
        (jas-exception-no-commits)))
  
  
  ;;;
  ;;;; Branches
  ;;;
  
  
  (method (write-branch self branch commit)
    (let ((file (branch-file self branch)))
      (call-with-output-file (path-settings file)
        (lambda (output)
          (write commit output)
          (newline output)))))
  
  
  (method (read-branch self name)
    (let ((file (branch-file self name)))
      (and (exists? file)
           (call-with-input-file (path-settings file)
             read))))
  
  
  (method (branch-file self name)
    (new-file (branches-directory self) name))
  
  
  (method (branches-directory self)
    heads)
  
  
  (method (branch-exists? self name)
    (exists? (branch-file self name)))
  
  
  (method package (branches self)
    (map get-name (collect-files (branches-directory self)
                     (lambda (file)
                       #t))))
  
  
  ;;;
  ;;;; References
  ;;;
  
  
  (method package (commit? self ref)
    (string? ref))
  
  
  (method package (branch? self ref)
    (and (pair? ref)
         (eq? (car ref) branch:)))
  
  (method (make-branch self name)
    (list branch: name))
  
  (method package (branch-name self ref)
    (cadr ref))
  
  
  (method package (resolve self ref)
    (cond ((commit? self ref)
           ref)
          ((branch? self ref)
           (read-branch self (branch-name self ref)))
          (else
           (jas-exception "Invalid reference: {a}" ref))))
  
  
  ;;;
  ;;;; Revisions
  ;;;
  
  
  (method package (parse self rev)
    (cond ((starts-with? rev "HEAD" ignore-case?: #t)
           (let ((parents (substring rev (string-length "HEAD") (string-length rev))))
             (if (equal? parents (make-string (string-length parents) #\^))
                 (let (iter (commit (resolve self (require-head self))) (count (string-length parents)))
                   (if (<= count 0)
                       commit
                     (iter (commit-parent self commit) (- count 1))))
               (jas-exception "Invalid revision: {a}" rev))))
          ((equal? rev "master")
           (make-branch self "master"))
          (else
           rev))))


;;;
;;;; Index
;;;


(class Associative-Index extends Object
  
  
  (slot repository getter generate)
  (slot directory  getter generate)
  (slot file       getter generate)
  (slot paths      getter generate)
  (slot entries    getter generate)
  
  
  (method override (initialize self repository directory (file: file #f) (entries: entries #f))
    (set! self.repository repository)
    (set! self.directory directory)
    (set! self.file file)
    (set! self.paths (make-table test: equal?))
    (setup-entries self (or entries (if (and file (exists? file))
                                        (list->entries (load-from-file self))
                                      '()))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((len (length entries)))
          (format output "with {a} entr{a}" (format-cardinality len) (format-y/ies len))))))
  
  
  (method package (setup-entries self lst)
    (set! entries lst)
    (for-each (lambda (entry)
                (table-set! paths (get-path entry) entry))
              entries))
  
  
  (method package (setup-entries-preserving-live self lst)
    (let ((preserved
            (map (lambda (entry)
                   (let ((path (get-path entry)))
                     (let ((actual-entry (find-entry self path)))
                       (if (and actual-entry
                                (get-live? actual-entry)
                                (not (get-live? entry)))
                           (new Associative-Entry
                             path
                             (get-digest entry)
                             (get-seconds entry)
                             (get-flags entry)
                             (get-set entry)
                             #t)
                         entry))))
                 lst)))
      (setup-entries self preserved)))
  
  
  (method (load-from-file self)
    (call-with-input-file (path-settings file)
      read-all))
  
  
  (method package (save-to-file self)
    (call-with-output-file (path-settings file)
      (lambda (output)
        (for-each (lambda (entry)
                    (format output "({s} {s} {s} {s} {s} {s}){%}"
                      (get-path entry)
                      (get-digest entry)
                      (get-seconds entry)
                      (get-flags entry)
                      (get-set entry)
                      (get-live? entry)))
                  entries))))
  
  
  (method (updating self path test proc)
    (declare (proper-tail-calls))
    (let ((head (cons #f entries)))
      (let (iter (prev head) (scan entries))
        (if (null? scan)
            (proc prev scan)
          (let ((entry (car scan)))
            (let ((entry-path (get-path entry)))
              (if (test entry-path path)
                  (iter prev (cdr scan))
                (case (ci-compare entry-path path)
                  ((:less)
                   (iter scan (cdr scan)))
                  ((:equal)
                   (proc prev (cdr scan)))
                  ((:greater)
                   (proc prev scan))))))))
      (set! entries (cdr head))))
  
  
  (method package (update self path path-type replace)
    (declare (proper-tail-calls))
    (let ((test (if (eq? path-type 'file)
                    ci=?
                  (lambda (entry-path path)
                    (starts-with? entry-path path ignore-case?: #t)))))
      (iterate-table paths
        (lambda (entry-path entry)
          (when (test entry-path path)
            (table-clear paths entry-path))))
      (for-each (lambda (entry)
                  (let ((path (get-path entry)))
                    (table-set! paths path entry)))
                replace)
      (updating self path test
        (lambda (prev next)
          (if (null? replace)
              (set-cdr! prev next)
            (let ((replace (copy replace)))
              (set-cdr! prev replace)
              (set-cdr! (last-pair replace) next)))))
      entries))
  
  
  (method package (update-changes self changes)
    (declare (proper-tail-calls))
    (let ((head (cons #f entries)))
      (let (iter (prev head) (scan entries) (changes changes))
        (if (null? changes)
            (begin
              (set! entries (cdr head))
              (when file
                (save-to-file self)))
          (let ((change (car changes)))
            (bind (what path . rest) change
              (define (update next)
                (case what
                  ((added modified)
                   (let ((entry (copy (car rest))))
                     (let ((pair (cons entry next)))
                       (set-cdr! prev pair)
                       (table-set! paths path entry)
                       (iter prev pair (cdr changes)))))
                  ((removed)
                   (set-cdr! prev next)
                   (table-clear paths path)
                   (iter prev next (cdr changes)))))
              
              (if (null? scan)
                  (update scan)
                (case (ci-compare (get-path (car scan)) path)
                  ((:less)
                   (iter scan (cdr scan) changes))
                  ((:equal)
                   (update (cdr scan)))
                  ((:greater)
                   (update scan))))))))))
  
  
  (method package (entry-unchanged? self entry)
    (let ((path (get-path entry)))
      (let ((actual-entry (find-entry self path)))
        (and actual-entry
             (equal? (get-digest entry) (get-digest actual-entry))
             (= (get-flags entry) (get-flags actual-entry))
             (eq? (get-set entry) (get-set actual-entry))))))
  
  
  (method package (add-file self path file)
    (let ((open? (open? repository))
          (entry (scan-file repository path file base: self)))
      (unless (entry-unchanged? self entry)
        (let ((entries (list entry)))
          (let ((path (get-path entry))
                (digest (get-digest entry)))
            (unless open?
              (store-file repository file digest))
            (update self path 'file entries)
            (save-to-file self))))))
  
  
  (method package (add-directory self path dir)
    (let ((open? (open? repository))
          (entries (scan-directory repository path dir base: self))
          (added? #f))
      (for-each (lambda (entry)
                  (unless (entry-unchanged? self entry)
                    (unless open?
                      (let ((path (get-path entry))
                            (digest (get-digest entry)))
                        (let ((file (new-file directory (tokenise-filename path))))
                          (store-file repository file digest))))
                    (set! added? #t)))
                entries)
      (when added?
        (update self path 'directory entries)
        (save-to-file self))))
  
  
  (method package (remove-file self path)
    (update self path 'file '())
    (save-to-file self))
  
  
  (method package (remove-directory self path)
    (update self path 'directory '())
    (save-to-file self))
  
  
  (method package (find-entry self path)
    (table-ref paths path #f))
  
  
  (method package (iterate-subpaths self path proc)
    (iterate-table paths
      (lambda (entry-path entry)
        (when (starts-with? entry-path path ignore-case?: #t)
          (proc entry-path)))))
  
  
  (method package (directory-index self dirpath)
    (let ((dir (new-directory directory (tokenise-filename dirpath)))
          (entries (collect-if (lambda (entry)
                                 (starts-with? (get-path entry) dirpath ignore-case?: #t))
                               entries)))
      (new Associative-Index repository dir entries: entries))))


;;;
;;;; Entry
;;;


(class Associative-Entry extends Object
  
  
  (slot path    getter generate)
  (slot digest  getter generate)
  (slot seconds getter generate)
  (slot flags   getter generate)
  (slot set     getter generate)
  (slot live?   getter generate)
  
  
  (method override (initialize self path digest seconds flags set live?)
    (set! self.path path)
    (set! self.digest digest)
    (set! self.seconds seconds)
    (set! self.flags flags)
    (set! self.set set)
    (set! self.live? live?))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}" path))))
  
  
  (method override (copy-object self deep?)
    (new Associative-Entry
      path digest seconds flags set live?))
  
  
  (method package (set-seconds self sec)
    (set! seconds sec))
  
  
  (method package (set-live? self flag)
    (set! live? flag)))


;; backward compatible
(definition protected (list->entry lst)
  (bind (path digest seconds . rest) lst
    (if (null? rest)
        (new Associative-Entry path digest seconds 0 #f #f)
      (bind (flags . rest) rest
        (if (null? rest)
            (new Associative-Entry path digest seconds flags #f #f)
          (bind (set . rest) rest
            (if (null? rest)
                (new Associative-Entry path digest seconds flags set #f)
              (bind (live? . rest) rest
                (new Associative-Entry path digest seconds flags set live?)))))))))

(definition protected (list->entries lst)
  (map list->entry lst))


(definition protected (entry->list entry)
  (list (get-path entry)
        (get-digest entry)
        (get-seconds entry)
        (get-flags entry)
        (get-set entry)
        (get-live? entry)))

(definition protected (entries->list entries)
  (map entry->list entries))


;;;
;;;; Diff
;;;


(class Associative-Diff extends Object
  
  
  (slot changes  getter generate)
  (slot added    getter generate)
  (slot modified getter generate)
  (slot removed  getter generate)
  
  
  (method override (initialize self changes added modified removed)
    (set! self.changes changes)
    (set! self.added added)
    (set! self.modified modified)
    (set! self.removed removed))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((len (length changes)))
          (format output "with {a} change{a}" (format-cardinality len) (format-plural len))))))
  
  
  (method package (get-added/modified self)
    (collect-if (lambda (change)
                  (memq? (car change) '(added modified)))
                changes)))


;;;
;;;; Filter
;;;


(class Associative-Filter extends Object
  
  
  (slot name       getter generate)
  (slot conditions getter generate)
  
  
  (method override (initialize self name conditions)
    (set! self.name name)
    (set! self.conditions conditions))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))
  
  
  (method package (filter-path self path)
    (let ((extension (filename-extension path)))
      (some? (lambda (condition)
               (bind (kind . target) condition
                 (case kind
                   ((extension) (extension=? extension target))
                   ((directory) (starts-with? path target test: filename=?))
                   ((file) (filename=? path target)))))
             conditions))))


;;;
;;;; Changes
;;;


(definition protected (list->changes lst)
  (map (lambda (change)
         (bind (what path . lsts) change
           (cons what (cons path (map list->entry lsts)))))
       lst))


(definition protected (changes->list changes)
  (map (lambda (change)
         (bind (what path . entries) change
           (cons what (cons path (map entry->list entries)))))
       changes))


;;;
;;;; Scan
;;;


(definition package (scanning-directory dirpath dir proc (disregard: disregard '()) (ignore: ignore '()) (base: base #f))
  (let ((entries (new-queue)))
    (iterate-directory dir
      (lambda (path kind)
        (let ((file (new-file dir path)))
          (let ((name (get-name file)))
            (unless (or (member? name disregard)
                        (member? name ignore))
              (let ((subpath (join path "/")))
                (enqueue entries (proc (string-append dirpath subpath) file base)))))))
      full?: #f
      files?: #t
      directories?: #f
      recursive?: #t
      ignored-toplevel-dirnames: ignored-toplevel-dirnames
      ignored-dirnames: ignored-dirnames
      sort?: #f)
    ;; passing sort?: #t to iterate-directory doesn't work
    ;; as sorting each directory children can yield a global
    ;; result that is different because of the / separators
    (sort ci<? (queue-list entries) key: get-path)))


;;;
;;;; Flags
;;;


(definition Executable-Flag
  1)


(definition (determine-flags filename)
  (cond-expand
    (windows
     0)
    (else
     (if (file-executable? filename)
         Executable-Flag
       0))))


(definition (set-permissions file flags)
  (cond-expand
    (windows)
    (else
     (let ((permissions (if (mask-bit-set? flags Executable-Flag)
                            #o755
                          #o644)))
       (file-permissions-set! (parse file) permissions)))))


;;;
;;;; Exception
;;;


(definition protected (jas-exception format-string . rest)
  (throw (new Associative-Exception (apply format format-string rest))))


(definition protected (jas-exception-no-commits)
  (jas-exception "Your current head does not have any commits yet"))


(class Associative-Exception extends Exception
  
  
  (slot message)
  
  
  (method override (initialize self message)
    (nextmethod self)
    (set! self.message message))
  
  
  (method override (get-message self)
    message))


;;;
;;;; Describe
;;;


(definition public (jas-describe obj output (reverse? #f))
  (define (describe-index index)
    (for-each (lambda (entry)
                (let ((path (get-path entry))
                      (digest (get-digest entry))
                      (seconds (get-seconds entry))
                      (flags (get-flags entry))
                      (set (get-set entry)))
                  (format output "{s} {s} {a} {a} {a}{%}" path digest seconds flags set)))
              (get-entries index)))
  
  (define (describe-diff diff)
    (for-each (lambda (change)
                (bind (what path) change
                  (let ((what (if (not reverse?) what (case what ((added) 'removed) ((removed) 'added) (else what)))))
                    (case what
                      ((added)    (format output "    \033[32madded:    {a}\033[39;49m{%}" path))
                      ((removed)  (format output "    \033[31mremoved:  {a}\033[39;49m{%}" path))
                      ((modified) (format output "    \033[36mmodified: {a}\033[39;49m{%}" path))))))
              (get-changes diff)))
  
  (typecase obj
    ((Associative-Index)
     (describe-index obj))
    ((Associative-Diff)
     (describe-diff obj))
    (else
     (jas-exception "Unable to describe {a}" obj)))))
