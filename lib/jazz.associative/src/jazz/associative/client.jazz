;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Associative Client
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.associative.client jazz


(import (jazz.associative)
        (jazz.associative.remote)
        (jazz.io)
        (jazz.zlib))


;;;
;;;; Interface
;;;


(definition (with-jas-client repo host path feedback what proc)
  (let ((client (new Jas-Client repo host path feedback: feedback)))
    (connect client)
    (proc client)
    (deconnect client)))


(definition public (jas-download repo host path what)
  (define content?
    #f)
  
  (define (feedback stage . rest)
    (case stage
      ((connect)
       (format :terminal "Connecting to {a}{%}" path))
      ((deconnect)
       (if (not content?)
           (format :terminal "Already up to date{%}")
         (format :terminal "{%}")))
      ((progress)
       (set! content? #t)
       (bind (total-objects received-objects received-bytes) rest
         (let ((percentage (fxfloor (percentage received-objects total-objects))))
           (format :terminal "Downloading {a}% ({a}/{a}) {a}\r" percentage received-objects total-objects (present-bytes received-bytes)))))))
  
  (with-jas-client repo host path feedback what
    (lambda (client)
      (cond ((eq? what 'all)
             (download-all client))
            (else
             (download-file client what))))))


(definition public (jas-upload repo host path what)
  (define content?
    #f)
  
  (define (feedback stage . rest)
    (case stage
      ((connect)
       (format :terminal "Connecting to {a}{%}" path))
      ((deconnect)
       (if (not content?)
           (format :terminal "Everything up-to-date{%}")
         (format :terminal "{%}")))
      ((progress)
       (set! content? #t)
       (bind (total-objects sent-objects sent-bytes) rest
         (let ((percentage (fxfloor (percentage sent-objects total-objects))))
           (format :terminal "Uploading {a}% ({a}/{a}) {a}\r" percentage sent-objects total-objects (present-bytes sent-bytes)))))))
  
  (with-jas-client repo host path feedback what
    (lambda (client)
      (cond ((eq? what 'all)
             (upload-all client))
            (else
             (upload-file client what))))))


;;;
;;;; Client
;;;


(class Not-Found-Error extends Error)


(class Jas-Client extends Object
  
  
  (slot repository   getter generate)
  (slot remote-index getter generate)
  (slot path         getter generate)
  (slot port         getter generate)
  (slot feedback     getter generate)
  
  
  (method override (initialize self repo host path (feedback: feedback #f))
    (nextmethod self)
    (set! self.repository repo)
    (set! self.remote-index (new Associative-Index #f #f))
    (set! self.path path)
    (set! self.port (open-tcp-client (list server-address: host port-number: jas-service)))
    (set! self.feedback feedback))
  
  
  (method protected (connect self)
    (when feedback
      (feedback 'connect))
    (write-binary-object jas-key port)
    (write-binary-object path port)
    (force-output port)
    (let ((response (read-binary-object port)))
      (case response
        ((invalid-key)
         (terminal 'invalid-key)
         (exit))
        ((inexistant-repository)
         (terminal 'inexistant-repository)
         (exit))
        ((connected)
         (setup-entries remote-index (read-deflated-object port))))))
  
  
  (method protected (deconnect self)
    (write-binary-object '(deconnect) port)
    (force-output port)
    (close-port port)
    (set! port #f)
    (when feedback
      (feedback 'deconnect)))
  
  
  (method protected (download-all self)
    (let ((index (get-index repository)))
      (let ((diff (diff repository remote-index index)))
        (let ((changes (get-added/modified diff)))
          (let ((total (length changes)))
            (when (> total 0)
              (download-changes self changes total 0 0)
              (setup-entries index (get-entries remote-index))
              (save-to-file index)))))))
  
  
  (method protected (download-all-with-cache self cache-repository)
    (assert (open? repository)
      (assert (open? cache-repository)
        (let ((index (get-index repository)))
          (let ((diff (diff repository remote-index index)))
            (let ((changes (get-added/modified diff)))
              (let ((total (length changes)))
                (when (> total 0)
                  (let ((cache-index (get-index cache-repository))
                        (local-changes (new-queue))
                        (remote-changes (new-queue)))
                    (for-each (lambda (change)
                                (bind (what path digest) change
                                  (when (memq? what '(added modified))
                                    (let ((cache-entry (find-entry cache-index path)))
                                      (if (and cache-entry
                                               (equal? (second cache-entry) digest))
                                          (enqueue local-changes change)
                                        (enqueue remote-changes change))))))
                              changes)
                    (let ((local-changes (queue-list local-changes))
                          (remote-changes (queue-list remote-changes))
                          (received 0)
                          (downloaded 0))
                      ;; local
                      (for-each (lambda (change)
                                  (bind (what path digest seconds flags) change
                                    (let ((pathname (tokenise-filename path)))
                                      (let ((src (new-file (get-working cache-repository) pathname))
                                            (dst (new-file (get-working repository) pathname)))
                                        (create-directories dst)
                                        (duplicate src dst)
                                        (increase! received)
                                        (when feedback
                                          (feedback 'progress total received downloaded))))))
                                local-changes)
                      ;; remote
                      (download-changes self remote-changes total received downloaded)
                      ;; index
                      (setup-entries index (get-entries remote-index))
                      (save-to-file index)))))))))))
  
  
  (method protected (download-changes self changes total received downloaded)
    (write-binary-object (list 'download 'all) port)
    (write-deflated-object changes port)
    (force-output port)
    (for-each (lambda (change)
                (bind (what path digest seconds flags) change
                  (let ((content (read-binary-content port)))
                    (increase! received)
                    (increase! downloaded (u8vector-length content))
                    (when feedback
                      (feedback 'progress total received downloaded))
                    (if (bare? repository)
                        (store-object repository content digest)
                      (let ((file (new-file (get-working repository) (tokenise-filename path))))
                        (if (open? repository)
                            (retrieve-file repository digest file flags content)
                          (store-object repository content digest)
                          (retrieve-file repository digest file flags)))))))
              changes))
  
  
  (method protected (download-file self path)
    (let ((index (get-index repository)))
      (let ((entry (find-entry index path))
            (remote-entry (find-entry remote-index path))
            (file (new-file (get-working repository) (tokenise-filename path))))
        (if (not remote-entry)
            (signal (new Not-Found-Error message: (format "Entry not found: {a}" path)))
          (when (or (not entry)
                    (not (equal? (second entry) (second remote-entry)))
                    ;; this is a fail safe against someone deleting
                    ;; a file without the jas index being updated
                    (not (exists? file)))
            (write-binary-object (list 'download path) port)
            (force-output port)
            (let ((content (read-binary-content port))
                  (digest (second remote-entry))
                  (flags (fourth remote-entry)))
              (when feedback
                (feedback 'progress 1 1 (u8vector-length content)))
              (store-object repository content digest)
              (retrieve-file repository digest file flags)
              (update index path 'file (list remote-entry))
              (save-to-file index)))))))
  
  
  (method protected (upload-all self)
    (let ((index (get-index repository)))
      (let ((diff (diff repository index remote-index)))
        (let ((changes (get-changes diff))
              (total (+ (get-added diff) (get-modified diff)))
              (sent 0)
              (uploaded 0))
          (when (> total 0)
            (write-binary-object (list 'upload 'all) port)
            (write-deflated-object (get-entries index) port)
            (write-deflated-object changes port)
            (force-output port)
            (for-each (lambda (change)
                        (bind (what path . rest) change
                          (case what
                            ((added modified)
                             (let ((content (car (jas-retrieve-content repository path))))
                               (write-binary-content content port)
                               (increase! sent)
                               (increase! uploaded (u8vector-length content))
                               (when feedback
                                 (feedback 'progress total sent uploaded)))))))
                      changes))))))
  
  
  (method protected (upload-file self path)
    (let ((index (get-index repository)))
      (let ((entry (find-entry index path))
            (remote-entry (find-entry remote-index path)))
        (when (or (not remote-entry)
                  (not (equal? (second entry) (second remote-entry))))
          (bind (content digest flags) (jas-retrieve-content repository path)
            (write-binary-object (list 'upload path digest flags) port)
            (write-binary-content content port)
            (force-output port)
            (when feedback
              (feedback 'progress 1 1 (u8vector-length content))))))))))
