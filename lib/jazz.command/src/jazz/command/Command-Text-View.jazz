;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Command Text-View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.command.Command-Text-View jazz


(import (jazz.action)
        (jazz.application)
        (jazz.command)
        (jazz.component)
        (jazz.document)
        (jazz.editor.lisp)
        (jazz.event)
        (jazz.exemplar)
        (jazz.feedback)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.preferences)
        (jazz.project)
        (jazz.search)
        (jazz.text)
        (jazz.ui)
        (jazz.undoer)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(import (jazz.editor)
        (jazz.editor.jazz))

(class Copy-of-IDE-Text-View-quick-hack extends Code-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-User}))

  
  (method override (new-syntax self)
    (new Jazz-Syntax model colorize?: #f))
   
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method override (current-history-item self)
    #f)


  ;;;
  ;;;; Match
  ;;;
  
  
  (method override (match-backwards? self char)
    (typecase syntax
      ((Jazz-Syntax) (memq? char '(#\close-parenthesis #\close-bracket #\close-brace)))
      (else (nextmethod self char))))
  
  
  (method override (match-forwards? self char)
    (typecase syntax
      ((Jazz-Syntax) (memq? char '(#\open-parenthesis #\open-bracket #\open-brace)))
      (else (nextmethod self char))))

  
  ;;;
  ;;;; Menu
  ;;;


  (method override (context-menu self evt)
    (when (and (view-enabled? self) editable?)
      (let ((pos (get-position evt)))
        (receive (shift? control? alt? meta?) (get-down evt)
          (let ((definition? (and (not control?) shift? (not alt?)))
                (references? (and control? shift? (not alt?))))
            (when (or definition? references?)
              (context-menu-click self pos))
            (cond (definition? (edit-definitions self pos))
                  (references? (edit-references self pos))
                  (else (nextmethod self evt))))))))
  
  
  (method override (get-context-menu self)
    (new-text-context-menu self)))


(class Command-Text-View extends Copy-of-IDE-Text-View-quick-hack
  
  
  (slot mode             initialize #f accessors generate)
  (slot client           initialize #f getter generate)
  (slot client-selection initialize #f getter generate)
  (slot client-position  initialize #f getter generate)
  (slot client-restore   initialize #f accessors generate)
  (slot previous-mode    initialize #f accessors generate)
  
  
  (form
    (<install>
      focus-selects-all?: #t
      show-unfocused-selection?: #f
      accepts-returns?: #f
      left-padding: 2
      top-padding: 2
      tooltip?: #t
      tooltip-text: "Command Shell"))
  
  
  (method override (preferences self)
    (current-preferences '(documents command-text)))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-propagate-styles? model #f)
    (let ((pref (preferences self)))
      (add-style self 'Separator (get-separator-style pref))))
  
  
  (method override (finish self rest)
    (nextmethod self rest)
    (set! mode (default-mode self)))
  
  
  (method override (component-alias self name)
    (case name
      ((:mode) mode)
      (else (nextmethod self name))))
  
  
  (method (status-label self)
    (child creator 'status))
  
  
  (method package (set-status self title)
    (set-title (status-label self) title))
  
  
  (method package (clear-status self)
    (set-status self ""))
  
  
  ;;;
  ;;;; Client
  ;;;
  
  
  (method (setup-client self)
    (set! client (active-focus))
    (set! client-selection #f))
  
  
  (method (setup-search-client self explicit-client)
    (define (determine-client)
      (let ((focus (active-focus)))
        (and (and (is? focus Text-View) (not (in-cell-edit? focus)))
             focus)))
    
    (set! client (or explicit-client (determine-client)))
    (set! client-selection (and client (new Text-Mark client (get-selection client))))
    (set! client-position (and client (get-scrolled-position client))))
  
  
  (method (cleanup-client self)
    (set! client #f)
    (set! client-selection #f))
  
  
  (method package (restore-client self)
    (when client-restore
      (client-restore)
      (set! client-restore #f)))
  
  
  (method package (preserve-mode self)
    (set! previous-mode mode))
  
  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method override (focus-lose self)
    (nextmethod self)
    (let ((client client))
      (cleanup mode #t)
      (cleanup-client self)
      (set-mode-default self)
      (clear-user-message)
      (clear-status self)
      (focus-empty self)
      (when client
        (focus-rezoom self client))))
  
  
  (method override (focus-actions self)
    (cons (mode-actions mode)
          (nextmethod self)))
  
  
  (method protected virtual (focus-empty self)
    (empty-text model))
  
  
  (method protected virtual (focus-rezoom self client)
    (rezoom-command-text (current-application) client self))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press self evt)
    (nextmethod self evt)
    (key-press mode (get-key evt)))
  
  
  (method override (backspace-press self evt (word?: word? #f))
    (nextmethod self evt word?: word?)
    (backspace-press mode evt word?: word?))
  
  
  (method override (tab-press self evt)
    (navigate-field self (get-shift? evt)))
  
  
  (method override (next-page self evt)
    (next-page mode))
  
  
  (method override (prior-page self evt)
    (prior-page mode))
  
  
  (method override (get-constituent-test self)
    (or (get-constituent-test mode)
        (nextmethod self)))
  
  
  (method override (auto-complete? self)
    (auto-complete? mode))
  
  
  (method override (auto-complete-char? self key last)
    (let ((value (auto-complete-char? mode key last)))
      (if (eq? value 'default)
          (nextmethod self key last)
        value)))


  (method override (favorite-completions? self)
    (let ((value (favorite-completions? mode)))
      (if (eq? value 'default)
          (nextmethod self)
        value)))
  
  
  (method override (complete-name? self size)
    (let ((value (complete-name? mode size)))
      (if (eq? value 'default)
          (nextmethod self size)
        value)))


  (method override (completion-name self pos)
    (or (completion-name mode pos)
        (nextmethod self pos)))
    
  
  (method override (symbol-completions self name)
    (or (symbol-completions mode name)
        (nextmethod self name)))

  
  ;;;
  ;;;; Fields
  ;;;
  
  
  (method (navigate-field self backward?)
    (let ((fields (collect-fields self)))
      (let ((rank (caret-rank self fields)))
        (let ((next (modulo ((if backward? - +) rank 1) (length fields))))
          (goto-field self (element fields next))))))
  
  
  (method (first-field self)
    (first (collect-fields self)))
  
  
  (method (second-field self)
    (let ((fields (collect-fields self)))
      (and (>= (length fields) 2)
           (second fields))))
  
  
  (method (last-field self)
    (last (collect-fields self)))
  
  
  (method package (first-content self)
    (field-content self (first-field self)))
  
  
  (method package (second-content self)
    (let ((field (second-field self)))
      (and field
           (field-content self field))))
  
  
  (method (last-content self)
    (field-content self (last-field self)))
  
  
  (method (field-content self field)
    (substring (get-string (first-paragraph self))
               (get-start field)
               (get-end field)))
  
  
  (method (field-range self field)
    (new Range$Cell$
      (new Cell 0 (get-start field))
      (new Cell 0 (get-end field))))
  
  
  (method (goto-field self field)
    (set-selection self (field-range self field)))
  
  
  (method package (goto-first-field self)
    (goto-field self (first-field self)))
  
  
  (method package (goto-second-field self)
    (let ((field (second-field self)))
      (if field
          (goto-field self field)
        (set-caret self (text-ending self))
        (insert-separator self))))
  
  
  (method package (collect-fields self)
    (let ((paragraph (first-paragraph self))
          (fields (new-queue)))
      (define (forward-style pos predicate)
        (let ((card (get-length paragraph)))
          (let (iterate (pos pos))
            (if (>= pos card)
                pos
              (let ((next (+ pos 1)))
                (let ((run (get-run paragraph next)))
                  (if (or (not run) (predicate (get-style run)))
                      (iterate next)
                    pos)))))))
      
      (define (text-style? style)
        (not (separator-style? style)))
      
      (define (separator-style? style)
        (inherits? style 'Separator))
      
      (define (new-field start end)
        (new Range start end))
      
      (let (iter (pos 0))
        (let ((text-end (forward-style pos text-style?)))
          (enqueue fields (new-field pos text-end))
          (let ((separator-end (forward-style text-end separator-style?)))
            (when (/= separator-end text-end)
              (iter separator-end)))))
      (queue-list fields)))
  
  
  (method (field-rank self fields pos)
    (let (iter (fields fields) (rank 0))
      (let ((field (car fields)))
        (if (between? pos (get-start field) (get-end field))
            rank
          (iter (cdr fields) (+ rank 1))))))
  
  
  (method package (caret-rank self fields)
    (let ((pos (get-col (get-caret self))))
      (field-rank self fields pos)))
  
  
  (method (insert-separator self)
    (insert-styled self "/" 'Separator))

  
  ;;;
  ;;;; Mode
  ;;;
  
  
  (method public (select-search self direction range initial (search-result: search-result #f) (client: client #f) (highlight?: highlight? #f) (again?: again? #f))
    (set-mode-search self (if highlight? Highlight-Mode Search-Mode) direction)
    (setup-search-client self client)
    (push-focus self)
    (prepare-search mode range)
    (let ((search-result (or search-result (make-text-search-result initial (get-client self) #f #f))))
      (set-search-result mode search-result)
      (set-text model (get-target (search-context model (get-find (get-search search-result))))))
    (select-all self)
    (search-client mode direction initial?: #t again?: again?))
  
  
  (method (set-mode-search self class direction)
    (set! mode (new class self direction))
    (user-message "Search..."))
  
  
  (method public (select-extended self)
    (set-mode-extended self)
    (setup-client self)
    (push-focus self))
  
  
  (method (set-mode-extended self)
    (set! mode (new Extended-Mode self))
    (user-message "Extended..."))
  
  
  (method public (select-execute self)
    (set-mode-execute self)
    (setup-client self)
    (push-focus self))
  
  
  (method (set-mode-execute self)
    (set! mode (new Execute-Mode self))
    (user-message "Execute..."))
  
  
  (method public (select-mode self md)
    (set! mode md)
    (setup-client self)
    (push-focus self))
  
  
  (method (set-mode-default self)
    (set! mode (default-mode self)))
  
  
  (method protected virtual (default-mode self)
    (new Execute-Mode self)))


;;;
;;;; Command-Mode
;;;


(class Command-Mode extends Object
  
  
  (slot text)
  
  
  (method override (initialize self text)
    (nextmethod self)
    (set! self.text text))
  
  
  (method package (get-client self)
    (get-client text))
  
  
  (method package (get-client-selection self)
    (get-client-selection text))
  
  
  (method package (get-client-position self)
    (get-client-position text))
  
  
  (method package virtual (mode-actions self)
    )
    
  
  (method package virtual (key-press self evt)
    )
  
  
  (method package virtual (backspace-press self evt (word?: word? #f))
    )
  
  
  (method package virtual (next-page self)
    )
  
  
  (method package virtual (prior-page self)
    )
  
  
  (method package virtual (get-constituent-test self)
    #f)

  
  (method package virtual (auto-complete? self)
    #f)
  
  
  (method package virtual (auto-complete-char? self key last)
    'default)
  
  
  (method package virtual (favorite-completions? self)
    'default)
  
  
  (method package virtual (complete-name? self size)
    'default)


  (method package virtual (completion-name self pos)
    #f)
  
  
  (method package virtual (symbol-completions self name)
    #f)
  
  
  (method virtual (finish self)
    (cleanup self))
  
  
  (method virtual (cancel self)
    (cleanup self))
  
  
  (method package virtual (cleanup self (lose-focus? #f))
    (restore-client text)
    (let ((client (get-client self)))
      (when client
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Search-Mode
;;;


(class Search-Mode extends Command-Mode
  
  
  (slot direction       initialize #f)
  (slot search-result   initialize #f)
  (slot last-range      initialize #f)
  (slot last-found?     initialize #t)
  (slot prefixes        initialize (make-table test: equal?))
  (slot found-style     initialize #f)
  (slot highlight-style initialize #f)
  (slot replace-style   initialize #f)
  (slot boundary-style  initialize #f)
  
  
  (method override (initialize self text direction)
    (nextmethod self text)
    (set! self.direction direction))
  
  
  (method package (prepare-search self range)
    (let ((client (get-client self))
          (client-selection (get-client-selection self)))
      (let ((model (and (is? client Text-View) (get-model client))))
        (set! last-range (if model (if range (new Text-Mark client range) client-selection) #f))
        (set! found-style (if model (add-style model 'Found (new Text-Style base: 'Base domain: (get-styles-domain model) highlight: {Color Found})) #f))
        (set! highlight-style (if model (add-style model 'Highlight (new Text-Style base: 'Base domain: (get-styles-domain model) highlight: {Color Highlight})) #f))
        (set! replace-style (if model (add-style model 'Replace (new Text-Style base: 'Base domain: (get-styles-domain model) highlight: {Color Light-Red} frame: {Color Replace})) #f))
        (set! boundary-style (if model (add-style model 'Boundary (new Text-Style base: 'Base domain: (get-styles-domain model) highlight: {Color Boundary})) #f)))))
  
  
  (method override (mode-actions self)
    (find-actions 'search-mode))
  
  
  (method override (key-press self evt)
    (search-client self direction))
  
  
  (method override (backspace-press self evt (word?: word? #f))
    (search-client self direction prefix?: #t))
  
  
  (method override (next-page self)
    (search-client self 'forward again?: #t))
  
  
  (method override (prior-page self)
    (search-client self 'backward again?: #t))
  
  
  (method package (set-search-result self result)
    (set! search-result result))
  
  
  (method (set-boundaries self range)
    (set-beginning search-result (and range (get-start range)))
    (set-ending search-result (and range (get-end range)))
    (rehighlight-search self))
  
  
  (method package (get-search self)
    (get-search search-result))
  
  
  (method package (get-context self)
    ;; fow now get first one
    (car (get-contexts (get-find (get-search self)))))
  
  
  (method package (set-context self context)
    (set-find (get-search self) context))
  
  
  (method package (get-whole-words? self)
    (get-whole-words? (get-context self)))
  
  
  (method (select-whole-words? self whole-words?)
    (set-whole-words? (get-context self) whole-words?))
  
  
  (method package (get-ignore-case? self)
    (get-ignore-case? (get-context self)))
  
  
  (method (select-ignore-case? self ignore-case?)
    (set-ignore-case? (get-context self) ignore-case?))
  
  
  (method package (get-regexp? self)
    (get-regexp? (get-context self)))
  
  
  (method (select-regexp? self regexp?)
    (set-regexp? (get-context self) regexp?))
  
  
  (method (on-whole-words self evt)
    (select-whole-words? self (not (get-whole-words? self)))
    (user-message "Search whole-words {a}" (if (get-whole-words? self) "on" "off"))
    (rehighlight-search self))
  
  
  (method (on-ignore-case self evt)
    (select-ignore-case? self (not (get-ignore-case? self)))
    (user-message "Search ignore-case {a}" (if (get-ignore-case? self) "on" "off"))
    (rehighlight-search self))
  
  
  (method (on-regexp self evt)
    (select-regexp? self (not (get-regexp? self)))
    (user-message "Search regexp {a}" (if (get-regexp? self) "on" "off"))
    (rehighlight-search self))
  
  
  (method package (on-forward self evt)
    (let ((again? (not (select-empty-search self))))
      (search-client self 'forward again?: again?)))
  
  
  (method package (on-backward self evt)
    (let ((again? (not (select-empty-search self))))
      (search-client self 'backward again?: again?)))
  
  
  (method (select-empty-search self)
    (let ((context (get-context self)))
      (and (empty-string? (get-target context))
           (let ((previous (get-previous-mode text)))
             (and (is? previous Search-Mode)
                  (begin
                    (let ((previous-context (get-context previous)))
                      (set-previous-mode text #f)
                      (set-context self previous-context)
                      (set-string-content text (get-target previous-context))
                      (set-caret text (text-ending text)))
                    #t))))))
  
  
  (method (on-current self evt)
    (cancel self))
  
  
  (method (on-widen self evt)
    (let ((client (get-client self)))
      (let ((model (get-model client))
            (selection (get-selection client)))
        (let ((end (get-end selection)))
          (let ((extend (next-word model end)))
            (let ((add (range-first-string client (new Range$Cell$ end extend))))
              (if (empty-string? add)
                  (bell)
                (insert-string text add)
                (search-client self direction))))))))
  
  
  (method (on-outer-boundaries self evt)
    (let ((client (get-client self)))
      (let ((range (or (get-boundaries search-result)
                       (get-selection client))))
        (let ((outer (outer-range client range)))
          (if (not outer)
              (bell)
            (set-boundaries self outer)
            (user-message "Boundaries set to range"))))))
  
  
  (method (on-declaration-boundaries self evt)
    (let ((client (get-client self)))
      (let ((range (or (get-boundaries search-result)
                       (get-selection client))))
        (let ((outer (outer-declaration-range client range)))
          (if (not outer)
              (bell)
            (receive (range name declaration-name) outer
              (set-boundaries self range)
              (user-message "Boundaries set to ({a} {a})" name declaration-name)))))))
  
  
  (method (on-buffer-boundaries self evt)
    (set-boundaries self #f)
    (user-message "Boundaries set to buffer"))
  
  
  (method (on-center-caret self evt)
    (center-caret (get-client self)))
  
  
  (method (on-prior self evt)
    (prior-page (get-client self) #f))
  
  
  (method (on-next self evt)
    (next-page (get-client self) #f))
  
  
  (method package (on-home self evt)
    (on-home (get-client self) evt)
    (finish self))
  
  
  (method package (on-end self evt)
    (on-end (get-client self) evt)
    (finish self))
  
  
  (method (on-highlight self evt)
    (highlight-current self))
  
  
  (method (on-persist-highlights self evt)
    (persist-highlights self))
  
  
  (method protected virtual (highlight-current self)
    (persist-highlights self)
    (cancel self))
  
  
  (method protected virtual (persist-highlights self)
    (let ((client (get-client self)))
      (let ((model (get-model client)))
        (let ((reference-style (locate-style model 'Reference)))
          (for-each (lambda (highlight)
                      (when (or (inherits? (get-style highlight) found-style)
                                (inherits? (get-style highlight) highlight-style))
                        (push-style model (get-range highlight) 'Reference)))
                    (get-highlights client))))))
  
  
  (method (on-goto-find self evt)
    (goto-first-field text))
  
  
  (method (on-goto-replace self evt)
    (goto-second-field text))
  
  
  (method (reset-search self range)
    (set! last-range (new Text-Mark (get-client self) range))
    (set! last-found? #t)
    (set! prefixes (make-table test: equal?)))


  (method (on-find-forward self evt)
    (let ((client (get-client self)))
      (if (find-forward search-result client: client follow?: #f)
          (begin
            (reset-search self (get-selection client))
            (rehighlight-search self))
        (unless (follow-forward search-result)
          (bell)))))


  (method (on-find-backward self evt)
    (let ((client (get-client self)))
      (if (find-backward search-result client: client follow?: #f)
          (begin
            (reset-search self (get-selection client))
            (rehighlight-search self))
        (unless (follow-backward search-result)
          (bell)))))
  
  
  (method (on-replace self evt)
    (unimplemented-replace self)
    (select-replace self)
    (with-rehighlight-search self
      (lambda ()
        (unless (replace-selection search-result client: (get-client self))
          (bell)))))
  
  
  (method (on-replace&find-forward self evt)
    (unimplemented-replace self)
    (select-replace self)
    (with-rehighlight-search self
      (lambda ()
        (unless (replace-selection&find-forward search-result client: (get-client self))
          (bell)))))
  
  
  (method (on-replace-all self evt)
    (unimplemented-replace self)
    (select-replace self)
    (with-rehighlight-search self
      (lambda ()
        (replace-all search-result client: (get-client self)))))
  
  
  (method (unimplemented-replace self)
    (message-box "Unimplemented functionality")
    (signal-cancel))
  
  
  (method (select-replace self)
    (let ((replace (second-content text)))
      (when replace
        (set-replace (get-search self) (new Replace (list replace))))))
  
  
  (method (on-finish self evt)
    (let ((fields (collect-fields text)))
      (when (= (caret-rank text fields) 1)
        (replace-all self (second-content text))))
    (finish self))
  
  
  (method (on-cancel self evt)
    (cancel self))

  
  (method package (search-client self direction (initial?: initial? #f) (prefix?: prefix? #t) (again?: again? #f))
    (define (setup-context target)
      (let ((context (get-context self)))
        (set-target context target)
        (set-regexp context #f)))
    
    (define (search-target model beginning ending target again?)
      (let ((context (get-context self))
            (range (get-range (or (and prefix? (table-ref prefixes target #f)) last-range))))
        (let ((pos (case direction
                     ((forward) (if again? (get-end range) (get-start range)))
                     ((backward) (if again? (get-start range) (nu+ (get-start range) (cardinality target))))))
              (reversed? (eq? direction 'backward)))
          (let ((found (text-regular-search model context start: pos end: (if reversed? beginning ending) reversed?: reversed?)))
            (define (add-prefix range)
              (reset-prefixes)
              (table-set! prefixes target (new Text-Mark (get-client self) range)))
            
            (define (reset-prefixes)
              (let ((card (cardinality target)))
                (iterate-table-safe prefixes
                  (lambda (prefix range)
                    (when (>= (cardinality prefix) card)
                      (table-clear prefixes prefix))))))
            
            (and found
                 (begin
                   (bind (from . to) found
                     (let ((range (new Range$Cell$ from to)))
                       (add-prefix range)
                       (set! last-range (new Text-Mark (get-client self) range))))
                   found))))))
    
    (define (highlight-boundary client beginning ending)
      (define (add-boundary-highlight range)
        (add-highlight client (new Text-Highlight client range boundary-style)))
      
      (when beginning
        (add-boundary-highlight (new Range$Cell$ beginning (next-cell client beginning))))
      (when ending
        (add-boundary-highlight (new Range$Cell$ (previous-cell client ending) ending))))
    
    (define (highlight-find client all)
      (when all
        (for-each (lambda (found)
                    (bind (start . end) found
                      (let ((range (new Range$Cell$ start end)))
                        (unless (nu=? range (get-range last-range))
                          (add-highlight client (new Text-Highlight client range highlight-style))))))
                  all))
      (add-highlight client (new Text-Highlight client (get-range last-range) found-style))
      (set-selection client (get-range last-range)))
    
    (define (highlight-replace client model beginning ending repl)
      (unless (empty-string? repl)
        (let ((target (make-search-context repl whole-words?: #t)))
          (for-each (lambda (found)
                      (bind (start . end) found
                        (let ((range (new Range$Cell$ start end)))
                          (add-highlight client (new Text-Highlight client range replace-style)))))
                    (text-regular-search-all model target start: beginning end: ending)))))
    
    (let ((client (get-client self)))
      (and (is? client Text-View)
           (let ((model (get-model client))
                 (content (first-content text))
                 (repl (second-content text))
                 (context (get-context self))
                 (beginning (get-beginning search-result))
                 (ending (get-ending search-result)))
             (setup-context content)
             (let ((all (and (not (empty-string? (get-target context))) (text-regular-search-all model context start: beginning end: ending))))
               (let ((found #f))
                 (set! found (search-target model beginning ending content #f))
                 (when again?
                   (set! found (search-target model beginning ending content #t)))
                 (if found
                     (set! last-found? #t)
                   (when (or last-found? again?)
                     (set! last-found? #f)
                     (bell)))
                 (if (not all)
                     (clear-status text)
                   (let ((rank (and last-range (find all (cons (get-start (get-range last-range))
                                                               (get-end (get-range last-range)))
                                                 test: (lambda (x y)
                                                         (and (cell=? (car x) (car y))
                                                              (cell=? (cdr x) (cdr y)))))))
                         (total (length all)))
                     (set-status text (if rank
                                           (format "{a} of {a}" (+ rank 1) total)
                                         (format "{a}" total)))))
                 (remove-highlights self)
                 (highlight-boundary client beginning ending)
                 (highlight-find client all)
                 (when repl
                   (highlight-replace client model beginning ending repl))
                 found))))))
  
  
  (method package (replace-all self repl)
    (let ((context (get-context self))
          (client (get-client self))
          (beginning (get-beginning search-result))
          (ending (get-ending search-result)))
      (let ((model (get-model client)))
        (with-atomic-undo (get-undoer model)
          (lambda ()
            (for-each-reversed (lambda (found)
                                 (bind (start . end) found
                                   (let ((range (new Range$Cell$ start end)))
                                     (replace client range (list repl)))))
                               (text-regular-search-all model context start: beginning end: ending)))))))
  
  
  (method (rehighlight-search self)
    (search-client self direction))
  
  
  (method (with-rehighlight-search self proc)
    (remove-highlights self)
    (proc)
    (reset-search self (get-selection (get-client self)))
    (rehighlight-search self))
  
  
  (method (remove-highlights self)
    (let ((client (get-client self)))
      (when (is? client Text-View)
        (remove-all-highlights client))))
  
  
  (method override (finish self)
    (cleanup self))
  
  
  (method override (cancel self)
    (let ((client (get-client self))
          (client-selection (get-client-selection self)))
      (when client-selection
        (set-selection client (get-range client-selection) ensure-displayed?: #f)
        (scroll-to client (get-client-position self))))
    (cleanup self))
  
  
  (method override (cleanup self (lose-focus? #f))
    (restore-client text)
    (preserve-mode text)
    (let ((client (get-client self)))
      (when client
        (remove-highlights self)
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Highlight-Mode
;;;


(class Highlight-Mode extends Search-Mode
  
  
  (method override (mode-actions self)
    (find-actions 'highlight-mode))
  
  
  (method override (highlight-current self)
    (cancel self))
  
  
  (method override (finish self)
    (persist-highlights self)
    (cleanup self)))


;;;
;;;; Extended-Mode
;;;


(class Extended-Mode extends Command-Mode
  
  
  (method override (mode-actions self)
    (find-actions 'extended-mode))
  
  
  (method (on-find-file self evt)
    (let ((model (get-model text)))
      (set-mode text (new Find-File-Mode text))
      (set-text model (standardize-filename (current-directory)))
      (set-caret text (text-ending text))
      (refresh-focus-actions text)
      (user-message "Find file...")))
  
  
  (method (on-find-filename self evt)
    (let ((model (get-model text)))
      (set-mode text (new Find-Filename-Mode text))
      (set-text model "")
      (refresh-focus-actions text)
      (user-message "Find filename...")))
  
  
  (method (on-find-buffer self evt)
    (set-mode text (new Find-Buffer-Mode text))
    (refresh-focus-actions text)
    (user-message "Find buffer..."))
  
  
  (method (on-save-buffer self evt)
    (finish self)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-save guest evt))))
  
  
  (method (on-save-buffer-as self evt)
    (finish self)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-save-as guest evt))))
  
  
  (method package (on-save-all self evt)
    (finish self)
    (let ((appl (current-application)))
      (on-save-all appl evt)))
  
  
  (method (on-revert-buffer self evt)
    (finish self)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-revert-saved guest evt))))
  
  
  (method (on-kill-buffer self evt)
    (let ((appl (current-application)))
      (on-close appl evt)))
  
  
  (method (on-delete-stage self evt)
    (delete-stage)
    (finish self))
  
  
  (method (on-delete-other-stages self evt)
    (delete-other-stages)
    (finish self))
  
  
  (method (on-split-stage-vertically self evt)
    (split-stage-vertically)
    (finish self))
  
  
  (method (on-split-stage-horizontally self evt)
    (split-stage-horizontally)
    (finish self))
  
  
  (method (on-quit self evt)
    (let ((appl (current-application)))
      (on-quit-application appl evt)))
  
  
  (method package (on-start-recording self evt)
    (finish self)
    (let ((recorder (get-recorder (current-application))))
      (on-start-recording recorder evt)))
  
  
  (method package (on-stop-recording self evt)
    (finish self)
    (let ((recorder (get-recorder (current-application))))
      (on-stop-recording recorder evt)))
  
  
  (method package (on-play-recording self evt)
    (finish self)
    (let ((recorder (get-recorder (current-application))))
      (on-play-recording recorder evt)))
  
  
  (method package (on-downcase-selection self evt)
    (finish self)
    (let ((text (current-document)))
      (if (is-not? text Text-View)
          (bell)
        (on-downcase-selection text evt))))
  
  
  (method package (on-upcase-selection self evt)
    (finish self)
    (let ((text (current-document)))
      (if (is-not? text Text-View)
          (bell)
        (on-upcase-selection text evt))))
  
  
  (method package (on-select-all self evt)
    (finish self)
    (let ((view (current-document)))
      (if (not view)
          (bell)
        (on-select-all view evt))))
  
  
  (method (on-finish self evt)
    (finish self))
  
  
  (method (on-cancel self evt)
    (cancel self)))


;;;
;;;; Find
;;;


(class Find-Mode extends Command-Mode
  
  
  (method override (mode-actions self)
    (find-actions 'find-mode))
  
  
  (method override (get-constituent-test self)
    alphanumeric?)
  
  
  (method override (auto-complete? self)
    #t)
  
  
  (method override (auto-complete-char? self key last)
    (memv? key '(#\/ #\- #\_ #\.)))

  
  (method override (favorite-completions? self)
    #f)
  
  
  (method override (complete-name? self size)
    (>= size 1))


  (method override (completion-name self pos)
    (get-string text (new Range$Cell$ {Cell 0 0} pos)))
  
  
  (method (on-finish self evt)
    (finish self))
  
  
  (method (on-cancel self evt)
    (cancel self))
  
  
  (method override (cancel self)
    (cleanup self))
  
  
  (method override (cleanup self (lose-focus? #f))
    (set-string-content text "")
    (restore-client text)
    (let ((client (get-client self)))
      (when client
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Find-File
;;;


(class Find-File-Mode extends Find-Mode
  
  
  (method override (symbol-completions self name)
    (define (split-filename filename)
      (let ((pos (find filename #\/ reversed?: #t)))
        (if (not pos)
            (values #f filename)
          (values (substring filename 0 (+ pos 1))
                  (substring filename (+ pos 1) (string-length filename))))))
    
    (receive (dir filename) (split-filename name)
      (and (or (not dir)
               (and (file-exists? dir)
                    (eq? (pathname-type dir) 'directory)))
           (collect (lambda (name)
                      (and (compare-n filename name (string-length filename) test: char-ci=?)
                           (let ((path (standardize-filename (string-append (or dir "") name))))
                             (if (and (file-exists? path)
                                      (eq? (pathname-type path) 'directory))
                                 (string-append path "/")
                               path))))
                    (directory-content (list path: (or dir (current-directory)) ignore-hidden: 'dot-and-dot-dot))))))
  
  
  (method override (finish self)
    (let ((filename (first-content text)))
      (if (and (file-exists? filename)
               (eq? (pathname-type filename) 'file))
          (let ((file (anchorize (new File (tokenise-filename (pathname-normalize filename))))))
            (current-directory-set! (get-parent file))
            (edit-document (current-application) file)
            (cleanup self))
        (bell)))))


;;;
;;;; Find-Filename
;;;


(class Find-Filename-Mode extends Find-Mode
  
  
  (slot filenames)
  
  
  (method override (initialize self text)
    (define (collect-filenames)
      (let ((workbench (get-workbench))
            (table (make-table test: equal?)))
        (for-each-project-file workbench
          (lambda (file)
            (let ((source (get-source file)))
              (when source
                (let ((name (downcase (get-name source))))
                  (table-set! table name source))))))
        table))
    
    (nextmethod self text)
    (set! filenames (collect-filenames)))
  
  
  (method override (symbol-completions self name)
    (let ((queue (new-queue)))
      (iterate-table filenames
                     (lambda (filename file)
                       (when (compare-n name filename (string-length name) test: char-ci=?)
                         (enqueue queue filename))))
      (queue-list queue)))
  
  
  (method override (finish self)
    (define (find-file name)
      (continuation-capture
        (lambda (return)
          (let ((len (string-length name)))
            (iterate-table filenames
                           (lambda (filename file)
                             (when (compare-n name filename len test: char-ci=?)
                               (let ((remaining (substring filename len (string-length filename))))
                                 (when (or (empty-string? remaining)
                                           (and (eqv? (string-ref remaining 0) #\.)
                                                (not (find remaining #\. start: 1))))
                                   (continuation-return return file)))))))
          #f)))
    
    (let ((filename (first-content text)))
      (let ((file (find-file filename)))
        (if file
            (edit-document (current-application) file)
          (bell))))))


;;;
;;;; Find-Buffer
;;;


(class Find-Buffer-Mode extends Find-Mode
  
  
  (method override (symbol-completions self name)
    (collect (lambda (view)
               (let ((presentation (present-title view)))
                 (and (compare-n name presentation (string-length name) test: char-ci=?)
                      presentation)))
             (all-views)))
  
  
  (method override (finish self)
    (define (find-view name)
      (find-if (lambda (view)
                 (string-ci=? (present-title view) name))
               (all-views)))
    
    (let ((name (first-content text)))
      (if (empty-string? name)
          (let ((views (all-frames)))
            (if (>= (length views) 2)
                (begin
                  (send-to-back (first views))
                  (focus-host (current-frame)))
              (bell)))
        (let ((view (find-view name)))
          (if view
              (begin
                (focus-host view)
                (cleanup self))
            (bell))))))
  
  
  (definition (present-title window/view)
    (let ((title (typecase window/view
                   ((Window)
                    (get-title window/view))
                   ((View)
                    (if (is? window/view Host-View)
                        (let ((guest (get-guest window/view)))
                          (if (is? guest Document)
                              (name-status (get-document-controller guest))
                            (get-title window/view)))
                      (get-title window/view))))))
      (if (or (null? title) (empty-string? title))
          "<Untitled>"
        title)))
  
  
  (definition (all-views)
    (append (collect-frames)
            (collect-palettes))))


;;;
;;;; Execute-Mode
;;;


(class Execute-Mode extends Command-Mode
  
  
  (method override (mode-actions self)
    (find-actions 'execute-mode))
  
  
  (method override (auto-complete? self)
    #t)
  
  
  (method (on-finish self evt)
    (finish self))
  
  
  (method (on-cancel self evt)
    (cancel self)))


;;;
;;;; Utilities
;;;


(definition (standardize-filename filename)
  (let ((home (pathname-normalize (home-directory))))
    (if (starts-with? filename home)
        (string-append "~/" (substring filename (cardinality home) (cardinality filename)))
      filename))))
