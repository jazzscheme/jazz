;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Component
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.component.Component jazz


(import (jazz.component)
        (jazz.component.runtime)
        (jazz.descriptor)
        (jazz.event)
        (jazz.integrity)
        (jazz.io)
        (jazz.locale)
        (jazz.process))


(class Component extends Object implements Event-Consumer
  
  
  ;; prepare      -> before the form gets installed
  ;; install      -> installs the class form and sets installed? -> #t
  ;; finish       -> before form structure from a containing form gets installed and sets finished? -> #t
  ;; conclude     -> after all initialization done, but before calling show
  
  
  (definition Installed-Flag    #x00000001)
  (definition Finished-Flag     #x00000002)
  (definition Initialized-Flag  #x00000004)
  (definition Visible-Flag      #x00000008)
  (definition Destroying-Flag   #x00000020)
  (definition Destroyed-Flag    #x00000040)
  (definition Layout-Valid-Flag #x00000100)
  
  
  (slot name                         initialize #f)
  (slot parent                       initialize #f)
  (slot base-traits                  initialize #f)
  (slot default-traits               initialize #f)
  (slot branch                       initialize #f)   ;; the immediatly installed branch
  (slot base-branch                  initialize #f)   ;; the branch set by base-traits and used when replacing the default-traits
  (slot form                         initialize #f)   ;; the form that created the component
  (slot class-forms                  initialize #f getter generate)
  (slot creator                      initialize #f)   ;; the root component of the class form (used for indexing and as inner class instantiation context)
  (slot creator-branch               initialize #f)   ;; the branch that created the component (#f if none)
  (slot event-consumer               initialize self)
  (slot designers                    initialize '())
  (slot surrogate                    initialize #f accessors generate)
  (slot index                        initialize #f)
  (slot flags                 <fx>   initialize Visible-Flag)
  
  
  (property before                   initialize #f  accessors explicit)
  (property children                 initialize '() accessors explicit)
  (property visible?          <void>                accessors explicit)
  (property class-info        <void>                getter get-class-info)
  (property name-info         <void>                getter get-name-info)
  (property presentation-info <void>                getter get-presentation-info)
  

  ;;;
  ;;;; Access
  ;;;
  
  
  (method public inline (get-name)
    name)
  
  
  (method public inline (set-name value)
    (set! name value))
  
  
  (method public inline (get-parent)
    parent)
  
  
  (method public virtual (set-parent value)
    (when parent
      (remove-child~ parent self))
    (set! parent value)
    (when parent
      (install-in-parent)))


  (method public inline (get-before)
    before)


  (method public (set-before value)
    (set! before value)
    (when (get-finished?)
      (send-child-before~ parent self (child~ parent before))))
  
  
  (method public inline (get-children)
    children)
  
  
  (method public virtual (set-children lst <Sequence>)
    (set! children '())
    (loop (for child in lst)
          (do (set-parent~ child self))))
  
  
  (method public inline (get-branch)
    branch)
  
  
  (method public inline (set-branch value)
    (set! branch value))


  (method public inline (get-form)
    form)
  
  
  (method public inline (set-form value)
    (set! form value))


  (method public inline (get-creator)
    creator)
  
  
  (method public inline (set-creator value)
    (set! creator value))


  (method public inline (get-creator-branch)
    creator-branch)
  
  
  (method public inline (set-creator-branch value)
    (set! creator-branch value))
  
  
  (method (get-class-info)
    (get-class-presentation~ (class-of self)))


  (method meta virtual (get-class-form)
    #f)
  
  
  (method meta virtual (set-class-form form)
    )
  

  (method meta virtual (get-class-forms)
    '())
  
  
  (method (get-name-info)
    (if (not name)
        "{}"
      (->string name)))
  
  
  (method (get-presentation-info)
    (get-presentation-property))
  
  
  (method public (get-file-form)
    (case (get-action~ form)
      ((instantiate) (registered-file-form (get-tag-reference~ form)))
      (else form)))
  
    
  ;;;
  ;;;; Flags
  ;;;
  
  
  (method protected (get-installed?)
    (mask-bit-set? flags Installed-Flag))
  
  (method protected (set-installed? flag <bool>)
    (set! flags (mask-bit-set flags Installed-Flag flag)))
  
  
  (method protected (get-finished?)
    (mask-bit-set? flags Finished-Flag))
  
  (method (set-finished? flag <bool>)
    (set! flags (mask-bit-set flags Finished-Flag flag)))
  
  
  (method protected (get-initialized?)
    (mask-bit-set? flags Initialized-Flag))
  
  (method (set-initialized? flag <bool>)
    (set! flags (mask-bit-set flags Initialized-Flag flag)))
    
  
  (method public (get-visible-flag)
    (mask-bit-set? flags Visible-Flag))
  
  (method public (set-visible-flag flag <bool>)
    (set! flags (mask-bit-set flags Visible-Flag flag)))

  
  (method (get-destroying?)
    (mask-bit-set? flags Destroying-Flag))
  
  (method (set-destroying? flag <bool>)
    (set! flags (mask-bit-set flags Destroying-Flag flag)))

  
  (method (get-destroyed?)
    (mask-bit-set? flags Destroyed-Flag))
  
  (method (set-destroyed? flag <bool>)
    (set! flags (mask-bit-set flags Destroyed-Flag flag)))

  
  (method (get-layout-valid?)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  (method (set-layout-valid? flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))


  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (call-print output detail)
    (if (get-initialized?)
        (print output detail)
      (print-unreadable self output
        (lambda (output)
          ))))

  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))


  ;;;
  ;;;; Initialization
  ;;;


  (method override (initialize . rest)
    (nextmethod)
    (initialize-component rest))
  
  
  (method protected virtual (initialize-component rest)
    (prepare rest)
    (install rest)
    (set-installed? #t)
    (finish rest)
    (install-in-parent)
    (set-finished? #t)
    (setup-component)
    (conclude rest)
    (set-initialized? #t)
    (let ((visible? (get-visible?)))
      (when (neq? visible? (initially-visible?))
        (if visible?
            (show)
          (hide)))))


  (method protected virtual (default-name)
    #f)


  (method protected virtual (default-parent)
    #f)
  
  
  (method protected virtual (setup-parent)
    )


  (method protected chained (prepare initargs <Object>)
    (define (prepare-parent)
      (let ((arg (getf initargs parent: not-found: #f)))
        (set! parent (if (not arg) (default-parent) arg))
        (setup-parent)))
    
    (define (prepare-component)
      (let ((init-name (or (getf initargs name:) (default-name))))
        (when init-name
          (set-name init-name)))
      (let ((alternative-class-form (getf initargs class-form:))
            (class-forms (get-class-forms~ (class-of self))))
        (set! class-forms~self (if alternative-class-form
                                   (cons alternative-class-form (if (null? class-forms) class-forms (cdr class-forms)))
                                 class-forms)))
      (set-form (or (getf initargs form:)
                    (and (not-null? class-forms)
                         (car class-forms))))
      (set-creator (getf initargs creator:))
      (set-creator-branch (getf initargs creator-branch:)))
    
    (prepare-parent)
    (prepare-component))


  (method protected chained (install initargs <Object>)
    (define (install-inherited forms)
      (when (not-null? forms)
        (install-inherited (cdr forms))
        (install-form (car forms) self #f #f)))
    
    (install-inherited class-forms))
  
  
  (method public (install-form form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (define (install-base-traits properties)
      (let ((traits (or (getf properties 'base-traits) (getf properties base-traits:))))
        (when traits
          (set-base-traits traits))))
    
    (define (install-properties properties <Object> restore-form <Object>)
      (let (iter (scan properties))
        (when (not-null? scan)
          (let ((expr (car scan))
                (value (cadr scan)))
            (unless (initer-property? expr)
              (when (symbol? expr)
                (set! expr (component-property (class-of self) expr))
                (set-car! scan expr))
              (when restore-form
                (remember-property~ restore-form self expr))
              (write-property-to self expr value)))
          (iter (cddr scan)))))
    
    (define (install-children children <Object> creator <Object> creator-branch <Object> restore-form <Object>)
      (loop (for child in children)
            (do (install-child child creator creator-branch restore-form))))
    
    (define (install-default-traits properties)
      (let ((traits (or (getf properties 'default-traits) (getf properties default-traits:))))
        (when traits
          (set-default-traits traits))))
    
    (when form
      (let ((properties (get-properties~ form))
            (children (get-children~ form)))
        (install-base-traits properties)
        (install-properties properties restore-form)
        (install-children children creator creator-branch restore-form)
        (install-default-traits properties))))
  
  
  (method protected virtual (install-child form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (let ((action (get-action~ form))
          (name (get-name~ form)))
      (define (new-component)
        (let ((reference (get-tag-reference~ form)))
          (if (and (eq? action 'instantiate) (file? reference))
              (catch (Unknown-Alias-Exception exc
                       (handle-not-found reference))
                (if (exists?~ reference)
                    (parameterize ((current-tag-reference-chain (cons reference (current-tag-reference-chain))))
                      (let ((child (instantiate-file reference parent: self name: name form: form creator: creator creator-branch: creator-branch)))
                        (install-form~ child form creator creator-branch restore-form)
                        (set-form~ child form)
                        child))
                  (handle-not-found reference)))
            (let ((model (if reference (module-ref reference (get-model~ form)) (form-model~ (or creator self) form))))
              (if model
                  (new model parent: self name: name form: form creator: creator creator-branch: creator-branch)
                (error "Unable to resolve model: {s}" (get-model~ form)))))))
      
      (define (handle-not-found reference)
        (let ((handler (tag-reference-not-found-handler)))
          (if handler
              (instantiate~ (handler reference) parent: self name: name)
            (error "Unable to find tag-reference: {s}" reference))))
      
      (case action
        ((new instantiate)
         (let ((component (new-component)))
           (when creator
             (add-to-index~ creator (get-name~ component) component))
           (when restore-form
             (remember-creation~ restore-form self component))))
        ((modify locate)
         (when restore-form
           (set! restore-form (remember-reference~ restore-form self name)))
         (install-form~ (find-to-modify name equal?) form creator creator-branch restore-form))
        ((remove)
         (let ((child (get-component~ form)))
           (close~ child)))
        (else
         (error "Unknown form action: {t} in {t}" action form)))))
  
  
  (method public virtual (find-to-modify name <Object> test <procedure>)
    (or (widget-part name)
        (find-component-with name test)
        (locate name)))
  
  
  ;; This is a very poor version of automatically being able to override subform classes.
  ;; For now, it will have to do because a clean efficient solution completely eludes me!
  (method public virtual (form-model form <Form>)
    (resolve-model~ form))


  (method protected chained (finish initargs <Object>)
    (define (write-properties properties <Object>)
      (define (write-initarg-to object <Object> property <Object> value <Object>)
        (let ((property-name (keyword->symbol property)))
          (unless (initer-property? property-name)
            (write-property-to object (component-property (class-of object) property-name) value))))
      
      (loop (for (property value) in-properties properties)
            (do (write-initarg-to self property value))))
    
    (bind-keywords ((form #f) (creator #f) . others) initargs
      (when form
        ;; setting the creator to #t is a service for Form instantiate
        (if (neq? creator #t)
            (install-form form creator #f #f)
          (set! creator~self self)
          (install-form form self #f #f)))
      (write-properties initargs)))
  
  
  (method protected chained (setup-component)
    )
  
  
  ;; Only done after the component is fully initialized so as not to install
  ;; an invalid component should an error occur during the initialization phase.
  (method protected virtual (install-in-parent)
    (when parent
      (let ((designers (get-designers~ parent)))
        (when (not-null? designers)
          (set-designers designers)))
      (let ((surrogate (get-surrogate~ parent)))
        (when surrogate
          (remove-surrogate)
          (install-surrogate (get-editor~ surrogate))))
      (add-child~ parent self)))


  (method protected chained (conclude initargs <Object>)
    )


  (method override (initialized?)
    (get-initialized?))


  ;;;
  ;;;; Destruction
  ;;;


  (method override (destroying?)
    (get-destroying?))


  (method override (destroyed?)
    (get-destroyed?))


  (method override (close)
    (unless (destroyed?)
      (destroy-component)))


  ;; called before children are destroyed
  (method chained (destroy-component)
    (set-destroying? #t)
    (for-each (lambda (child)
                (when (is? child Component)
                  (destroy-component~ child)))
              children)
    (destroy)
    (set-destroyed? #t))
  
  
  ;; called after children are destroyed
  (method override (destroy)
    (when parent
      (remove-child~ parent self))
    (when creator
      (remove-from-index~ creator name self))
    (nextmethod))
  
  
  (method public (close-children)
    (for-each close~ children))
  
  
  (method public virtual (confirm-close . rest)
    #t)


  ;;;
  ;;;; Visibility
  ;;;


  (method public virtual (initially-visible?)
    #t)


  (method public virtual (get-visible?)
    (get-visible-flag))
  
  
  (method public virtual (set-visible? flag <bool>)
    (if (not (get-finished?))
        (set-visible-flag flag)
      (when (neq? (get-visible-flag) flag)
        (if flag
            (show)
          (hide)))))
  
  
  (method public virtual (show)
    (set-visible-flag #t))
  
  
  (method public virtual (hide)
    (set-visible-flag #f))


  ;;;
  ;;;; Properties
  ;;;
  
  
  (definition initer-properties
    (list->table
      '((name . #t)
        (parent . #t)
        (base-traits . #t)
        (default-traits . #t)
        (form . #t)
        (class-form . #t)
        (creator . #t)
        (creator-branch . #t))))
  
  
  (method chained (initer-property? name)
    (table-ref initer-properties name #f))
  
  
  (method meta public (get-properties)
    (collect-if (lambda (property)
                  (and (property? property)
                       (property-getter property)))
                (get-instance-slots~ self)))
  
  
  (method (component-property category <Object> name <Object>)
    (let ((field (mop-category-field~ category name)))
      (if (property? field)
          field
        (error "Unknown property: {t}" name))))


  (definition (write-property-to object <Object> property <Object> value <Object>)
    (let ((setter (property-setter property)))
      (if setter
          (setter object value)
        (error "Property {s} has no setter" property))))
  
  
  (method public (get-filtered-properties (filter: filter 'standard))
    (define (collect-properties filter)
      (collect-if (lambda (property)
                    (display-filtered-property? property filter))
                  (mop-instance-slots~ (class-of self) self)))
    
    (define (display-filtered-property? property filter)
      (and (property? property)
           (property-getter property)
           (or (memq? filter '(all standard))
               (let ((name (get-name~ (get-category~ (class-of self) property))))
                 (if (symbol? filter)
                     (eq? name filter)
                   (memq? name filter))))))
    
    (if (eq? filter 'standard)
        (let ((properties (get-standard-properties)))
          (if (eq? properties #t)
              (collect-properties '(infos properties handlers))
            (let ((class (class-of self)))
              (define (standardize object)
                (cond ((string? object)
                       object)
                      ((symbol? object)
                       (or (category-field class object)
                           (error "Field {t} is undefined in {t}" object class)))
                      (else
                       (map standardize object))))
              
              (standardize properties))))
      (collect-properties filter)))


  ;;;
  ;;;; Children
  ;;;


  (method public (name? object <Object>)
    (or (symbol? object)
        (integer? object)
        (null? object)
        (pair? object)))


  (method public virtual (add-child child <Object>)
    (let ((before (and (is? child Component) (get-before~ child))))
      (if (not before)
          (set! children (append! children (list child)))
        (send-child-before child (find-component before)))))
  
  
  (method public (add-child-at child <Object> rank <Integer+>)
    (set! children (insert! children rank child)))
  
  
  (method public (append-child child <Object>)
    (set! children (append! children (list child))))


  (method public virtual (remove-child child <Object>)
    (set! children (remove! child children)))
    
  
  (method public virtual (replace-child rank <fx> replacement <Object>)
    (let ((child (element children rank)))
      (set-parent~ replacement self)
      (set-parent~ child #f)
      (set! children (insert! (remove! replacement children) rank replacement))))
  
  
  (method public virtual (front-child? child)
    (eq? child (first children)))
  
  
  (method public virtual (back-child? child)
    (eq? child (last children)))


  (method public virtual (send-child-to-front child <Object>)
    (set! children (move-to-head! child children)))


  (method public virtual (send-child-to-back child <Object>)
    (set! children (move-to-tail! child children)))
  
  
  (method public (send-child-before child <Object> target)
    (let* ((removed (remove! child children))
           (rank (and target (or (find removed target) (error "Unable to find: {t}" target)))))
      (set! children (insert! removed rank child))))
  
  
  (method public (child name <Object>)
    (or (find-component name)
        (error "Could not find child {t}" name)))
  
  
  (method public (find-component name <Object>)
    (find-component-with name equal?))
  
  
  (method public (find-component-with name <Object> test <procedure>)
    (cond ((null? name)
           (error "Invalid location: {t}" name))
          ((integer? name)
           (if (= name 0)
               self
             (find-component~ parent (- name 1))))
          ((pair? name)
           (let ((sub (find-component (car name))))
             (when sub
               (let ((next (cdr name)))
                 (if (null? next)
                     sub
                   (find-component~ sub next))))))
          (else
           (or (component-alias name)
               (find-child-with name test)))))
  
  
  (method public (brother name <Object>)
    (child~ parent name))
  
  
  (method public (next-brother (type: type #f))
    (if (not parent)
        self
      (next-child~ parent self type: type)))
  
  
  (method public (previous-brother (type: type #f))
    (if (not parent)
        self
      (previous-child~ parent self type: type)))
  
  
  (method public (child-ranked rank <fx>)
    (element children rank))
  
  
  (method public virtual (component-alias name <Object>)
    (case name
      ((:self) self)
      ((:parent) parent)
      ((:creator) creator)
      (else (let ((process (get-process)))
              (when process
                (process-alias~ process name))))))
  
  
  (method public (find-path path)
    (if (null? path)
        self
      (let ((child (find-child (car path))))
        (and child (find-path~ child (cdr path))))))
  

  (method public (find-child name <Object>)
    (find-if (lambda (child)
               (equal? (get-name~ child) name))
             children))


  (method public (find-child-with name <Object> test <procedure>)
    (find-if (lambda (child)
               (test (get-name~ child) name))
             children))


  (method public (find-type type)
    (find-if (lambda (child)
               (is? child type))
             children))
  
  
  (method public (find-key key value)
    (find-if (lambda (child)
               (equal? (key child) value))
             children))
  
  
  (method public (find-ascendant type (include-self?: include-self? #f))
    (if (and include-self? (is? self type))
        self
      (let ((parent (get-parent)))
        (while (and parent (is-not? parent type))
          (set! parent (get-parent~ parent)))
        parent)))
  
  
  (method public (find-descendant predicate (include-self?: include-self? #t))
    (continuation-capture
      (lambda (return)
        (for-each-descendant
          (lambda (component level)
            (when (predicate component)
              (continuation-return return component)))
          include-self?: include-self?)
        #f)))
  
  
  (method public (collect-ascendants (type #f))
    (let ((ascendants '())
          (parent (get-parent)))
      (while (and parent (or (not type) (is-not? parent type)))
        (set! ascendants (cons parent ascendants))
        (set! parent (get-parent~ parent)))
      (if (or (not parent) (and type (is? parent type)))
          ascendants
        (cons parent ascendants))))
  
  
  (method public (child-rank child <Object>)
    (find children child))
  
  
  (method public (get-brothers)
    (when parent
      (remove self (get-children~ parent))))
  
  
  (method public (has-parent? component <Component>)
    (and parent (or (eq? parent component) (has-parent?~ parent component))))
  
  
  (method public (has-ascendant? component <Component>)
    (or (eq? self component) (has-parent? component)))
  
  
  (method public (get-root-parent)
    (if (not parent)
        self
      (get-root-parent~ parent)))
  
  
  (method public (get-visible-children)
    (collect-if get-visible?~ children))
  
  
  (method public (first-visible-child)
    (let ((visible (get-visible-children)))
      (if (null? visible)
          #f
        (car visible))))
  
  
  (method public (get-ancestry)
    (let (iter (scan self) (ancestry '()))
      (if (not scan)
          ancestry
        (iter (get-parent~ scan) (cons scan ancestry)))))
  
  
  (method public (validate-duplicates title)
    (let ((duplicates (collect-duplicates (map get-name~ children) test: equal?)))
      (when (not-null? duplicates)
        (error "Found duplicate names in {a}: {l}" title duplicates))))


  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (for-each-parent proc <procedure>)
    (when parent
      (proc parent)
      (for-each-parent~ parent proc)))
  
  
  (method public (for-each-ancestor proc <procedure>)
    (proc self)
    (for-each-parent proc))
  
  
  (method public (for-each-descendant proc <procedure> (include-self?: include-self? #t) (stop-test: stop-test #f))
    (when include-self?
      (proc self 0))
    (let (iter (component self)
               (level 1))
      (loop (for child in (get-children~ component))
            (proc child level)
            (unless (and stop-test (stop-test child))
              (iter child (+ level 1))))))


  (method public (collect-descendants (type #f))
    (let ((factory (new List-Factory)))
      (for-each-descendant
        (lambda (child level)
          (when (or (not type) (is? child type))
            (put~ factory child))))
      (get-output~ factory)))
  
  
  (method public (for-each-sibling proc <procedure>)
    (loop (for child in (get-children~ parent))
          (when (neq? child self)
            (proc child))))
  
  
  ;;;
  ;;;; Widget
  ;;;
  
  
  (method public (outer-component limit)
    (let ((outer parent)
          (component self))
      (while (and outer (inner?~ outer component) (neq? component limit))
        (set! component outer)
        (set! outer (get-parent~ outer)))
      component))
  
  
  (method public (outer? limit)
    (eq? self (outer-component limit)))
  
  
  (method public virtual (inner? component)
    #f)
  
  
  (method public virtual (inner-widget)
    self)
  
  
  (method public (locate-part name)
    (or (widget-part name)
        (error "Unable to locate part: {s}" name)))
  
  
  (method public virtual (widget-part name)
    #f)
  
  
  (method public (iterate-parts proc)
    (for-each (lambda (name)
                (proc name (locate-part name)))
              (widget-parts)))
  
  
  (method public virtual (widget-parts)
    '())
  
  
  ;;;
  ;;;; Form
  ;;;
  
  
  (method public virtual (add-form parent-form <Form> child-form <Form>)
    (append-parent~ child-form parent-form))


  ;;;
  ;;;; Index
  ;;;
  
  
  (method public virtual (add-to-index name <Object> component <Component>)
    (when name
      (when (not index)
        (set! index (new-index)))
      (let ((ref (table-ref index name #f)))
        (table-set! index name (cond ((list? ref) (cons component ref))
                                     (ref (list component ref))
                                     (else component))))))
  
  
  (method public virtual (remove-from-index name <Object> component <Component>)
    (when (and name index)
      (let ((ref (table-ref index name #f)))
        (if (list? ref)
            (let ((removed (remove component ref)))
              (table-set! index name (if (= 1 (length removed))
                                         (car removed)
                                       removed)))
          (table-clear index name)))))
  
  
  (method protected virtual (new-index)
    (make-table test: eq?))
  
  
  (method public virtual (locate name <Object>)
    (let ((component (locate-component name)))
      (cond ((not component) (error "Unable to locate {t}" name))
            ((list? component) (error "Ambiguous name: {t}" name))
            (else component))))
  
  
  (method public (locate-recursive name <Object>)
    (let ((component (locate-component-recursive name)))
      (cond ((not component) (error "Unable to locate {t}" name))
            ((list? component) (error "Ambiguous name: {t}" name))
            (else component))))
  
  
  (method public (locate-component name <Object>)
    (cond ((pair? name)
           (let ((sub (locate-component (car name))))
             (when sub
               (let ((next (cdr name)))
                 (if (null? next)
                     sub
                   (locate-component~ sub next))))))
          (else
           (and index (table-ref index name #f)))))
  
  
  (method public (locate-component-recursive name <Object>)
    (define (is-descendant? component)
      (find-descendant
        (lambda (c)
          (and (eq? c component)
               (not (eq? self c))))))
    
    (let (loop (creator self))
      (and creator
           (let ((components (collect-if is-descendant? (listify (locate-component~ creator name)))))
             (cond ((null? components)
                    (loop (get-creator)))
                   ((> (length components) 1)
                    components)
                   (else
                    (car components)))))))
  
  
  (method public (identify-component component)
    (let (loop (component component) (identifier '()))
      (let ((creator (get-creator~ component)))
        (when creator
          (let ((name (get-name~ component)))
            (when (eq? (locate-component~ creator name) component)
              (if (eq? creator self)
                  (cons name identifier)
                (loop creator (cons name identifier)))))))))
  
  
  (method public (identify-descendant component)
    (let (loop (component component) (identifier '()))
      (if (eq? component self)
          identifier
        (let ((creator (get-creator~ component))
              (name (get-name~ component)))
          (or (and creator
                   (eq? (locate-component~ creator name) component)
                   (if (eq? creator self)
                       (cons name identifier)
                     (loop creator (cons name identifier))))
              (let ((parent (get-parent~ component)))
                (and name
                     parent
                     (loop parent (cons name identifier)))))))))
  
  
  (method public (locate-descendant path)
    (define (locate-element in elem)
      (or (locate-component~ in elem)
          (find-component~ in elem)))
    
    (let (locate (in self) (path path))
      (cond ((null? path)
             in)
            ((pair? path)
             (let ((elem (car path)))
               (let ((component (locate-element in elem)))
                 (when component
                   (locate component (cdr path))))))
            (else
             (locate-element in path)))))


  ;;;
  ;;;; Clone
  ;;;
  
  
  (method public (clone-component . rest)
    (let ((tag-reference (get-tag-reference~ form)))
      (if tag-reference
          (apply instantiate-file tag-reference rest)
        (apply instantiate~ form rest))))


  ;;;
  ;;;; Database
  ;;;
  
  
  (method public (get-database-component)
    (get-root-parent))


  ;;;
  ;;;; Consumer
  ;;;
  

  (method override (get-event-consumer)
    event-consumer)
  
  
  (method override (set-event-consumer consumer <Event-Consumer>)
    (set! event-consumer consumer))


  (method override (deliver-event handler target proc event)
    (proc target event))


  ;;;
  ;;;; Layering
  ;;;
  
  
  (method public (first-child)
    (if (null? children)
        #f
      (car children)))
  
  
  (method public (second-child)
    (if (>= (length children) 2)
        (second children)
      #f))
  
  
  (method public (last-child)
    (last children))
  
  
  (method public (next-child child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (+ rank 1) (length children))))))
  
  
  (method public (previous-child child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (- rank 1) (length children))))))
  
  
  (method public (front?)
    (or (not parent) (front-child?~ parent self)))
  
  
  (method public (back?)
    (or (not parent) (back-child?~ parent self)))
  
  
  (method public virtual (bring-to-front)
    (when parent
      (send-child-to-front~ parent self)))
  
  
  (method public virtual (send-to-back)
    (when parent
      (send-child-to-back~ parent self)))
  
  
  (method public virtual (send-before target)
    (when parent
      (send-child-before~ parent self target)))


  ;;;
  ;;;; Traits
  ;;;
  
  
  (method public (branch-installed?)
    (boolean branch))
  
  
  (method public (get-active-branch)
    (if (not branch)
        #f
      (let (iterate (branch branch))
        (if (get-branch~ branch)
            (iterate (get-branch~ branch))
          branch))))
  
  
  (method public (get-active-trait)
    (let ((branch (get-active-branch)))
      (when branch
        (get-trait~ branch))))
  
  
  (method public (set-active-trait trait)
    (replace-traits #f (if trait (list trait) '())))
  
  
  (method public (get-active-trait-name)
    (let ((trait (get-active-trait)))
      (when trait
        (get-name~ trait))))
  
  
  (method public (get-active-trait-presentation)
    (let ((trait (get-active-trait)))
      (if (not trait)
          (get-presentation-property)
        (get-presentation-property~ trait))))
  
  
  (method public (get-base-traits)
    base-traits)
  
  
  (method public (set-base-traits traits)
    (let ((traits (listify traits)))
      (set! base-traits traits)
      (let ((preserve (and base-branch (get-active-trait))))
        (replace-traits #f traits)
        (set! base-branch (get-active-branch))
        (when preserve
          (push-trait preserve)))))
  
  
  (method public (get-default-traits)
    default-traits)
  
  
  (method public (set-default-traits traits)
    (let ((traits (listify traits)))
      (set! default-traits traits)
      (replace-traits base-branch traits)))
  
  
  (method public (push-trait trait)
    (replace-traits base-branch (list trait)))
  
  
  (method public (pop-trait)
    (replace-traits base-branch '()))
  
  
  (method public (replace-active-trait trait)
    (replace-traits base-branch (if trait (list trait) '())))
  
  
  (method public (replace-traits target-branch traits)
    (define (install-traits root-branch effective-traits)
      (let ((parent-branch root-branch))
        (for-each (lambda (trait)
                    (let ((new-branch (configure-client~ trait self parent-branch)))
                      (set-branch~ parent-branch new-branch)
                      (set! parent-branch new-branch)))
                  effective-traits)))
    
    (define (install-in-branch current-branch current-traits)
      (let ((old-branch (get-branch~ current-branch)))
        (when old-branch
          (restore-client~ old-branch)
          (set-branch~ current-branch #f)))
      (install-traits current-branch current-traits))
    
    (define (install-in-self effective-traits)
      (when branch
        (restore-client~ branch)
        (set! branch #f))
      (when (not-null? effective-traits)
        (let ((new-branch (configure-client~ (car effective-traits) self self)))
          (set! branch new-branch)
          (install-traits new-branch (cdr effective-traits)))))
    
    (define (change-installed? current-branch current-traits)
      (let ((match? (and current-branch (pair? current-traits) (eq? (get-trait~ current-branch) (car current-traits)))))
        (when (and match? (not (change-installed? (get-branch~ current-branch) (cdr current-traits))))
          (install-in-branch current-branch (cdr current-traits)))
        match?))
    
    (let ((effective-traits (apply append! (map compute-effective-traits~ (map (lambda (trait)
                                                                                 (resolve-trait self trait))
                                                                               traits))))
          (base-branch (if target-branch (get-branch~ target-branch) branch)))
      (when (not (change-installed? base-branch effective-traits))
        (if target-branch
            (install-in-branch target-branch effective-traits)
          (install-in-self effective-traits)))))
  
  
  (method public (for-each-trait proc)
    (for-each (lambda (trait)
                (proc trait)
                (for-each-trait~ trait proc))
              (child-traits)))
  
  
  (method public (with-each-trait proc)
    (let ((active-branch (get-branch)))
      (for-each-trait
        (lambda (trait)
          (set-active-trait trait)
          (proc)))
      (set-active-trait (get-trait~ active-branch))))
  
  
  (method public (get-branches)
    (if (not branch)
        '()
      (cons branch (get-branches~ branch))))
  
  
  (method public (find-trait-branch trait)
    (find-if (lambda (branch)
               (eq? (get-trait~ branch) trait))
             (get-branches)))
  
  
  (method public (iterate-branch-spine proc (trait: trait #f))
    (let ((branch (get-branch)))
      (proc self (creator-effective-form))
      (while (is? branch Branch)
        (proc branch (get-client-form~ (get-trait~ branch)))
        (set! branch (get-branch~ branch)))))
  
  
  ;; For a creator that was install in another creator, it is
  ;; very tricky because it's form is pointing to the form that
  ;; created it inside the other creator but sometimes we need
  ;; the install form that defines its own structure...
  (method public (creator-effective-form)
    (cond ((eq? self creator)
           form)
          ((not-null? class-forms)
           (car class-forms))
          (else
           #f)))
  
  
  (method public (child-traits)
    (collect-type Trait children))
  
  
  (method public (trait-spine trait)
    (let (iter (trait trait) (spine (list trait)))
      (let ((parent (get-parent~ trait)))
        (if (is? parent Trait)
            (iter parent (cons parent spine))
          spine))))
  
  
  (method public (trait-fullname trait)
    (apply compose-identifier (map get-name~ (trait-spine trait))))
  

  ;;;
  ;;;; Session
  ;;;
  
  
  (method public virtual (save-session)
    )


  ;;;
  ;;;; Integrity
  ;;;
  
  
  (method public virtual (get-integrity-manager)
    #f)
  
  
  (method public virtual (validate-component validation-context)
    (for-each (lambda (symbol)
                (let* ((property (property-field (class-of self) symbol))
                       (validation-context (refine~ validation-context property: symbol)))
                  (map (lambda (violation)
                         (add-property-violation~ validation-context "{a}" (get-message~ violation)))
                       (collect-value-violations~ (property-domain property) (read-property self property) validation-context))))
              (get-filtered-properties))
    (validate-children validation-context))
  
  
  (method (validate-children validation-context)
    (define (validate-child addable-classes child)
      (unless (some? (lambda (addable-class)
                       (is? child addable-class))
                     addable-classes)
        (let ((violation (new Integrity-Violation
                           message: (format "Class {a} cannot have children of type {a}"
                                            (category-name (class-of self))
                                            (category-name (class-of child))))))
          (add-violation~ (get-manager~ validation-context) violation child (get-root~ validation-context) (get-editor~ validation-context)))))
    
    (define (validate-child-descriptor child child-descriptor)
      (unless (some? (lambda (class-ref)
                       (is? child (resolve-reference~ class-ref)))
                     (get-classes~ child-descriptor))
        (let ((violation (new Integrity-Violation
                           message: (format "Child named {a} cannot be of type {a}"
                                            (get-name~ child)
                                            (category-name (class-of child))))))
          (add-violation~ (get-manager~ validation-context) violation child (get-root~ validation-context) (get-editor~ validation-context)))))
    
    (let ((addable-classes (map resolve-runtime-reference (flatten (get-categorized-addable-classes))))
          (children-descriptor (get-children-descriptor~ (get-class-descriptor~ (class-of self)))))
      (for-each (lambda (child)
                  (let ((name (get-name~ child)))
                    (let ((child-descriptor (and name
                                                 (find-if (lambda (child-descriptor)
                                                            (eq? (get-target~ child-descriptor)
                                                                 name))
                                                          (get-children~ children-descriptor)))))
                      (if child-descriptor
                          (validate-child-descriptor child child-descriptor)
                        (validate-child addable-classes child)))))
                children)
      (for-each (lambda (child-descriptor)
                  (when (get-mandatory?~ child-descriptor)
                    (let ((child (find-child (get-target~ child-descriptor))))
                      (unless child
                        (let ((violation (new Integrity-Violation
                                           message: (format "Missing child named {a}"
                                                            (get-target~ child-descriptor)))))
                          (add-violation~ (get-manager~ validation-context) violation self (get-root~ validation-context) (get-editor~ validation-context)))))))
                (get-children~ children-descriptor))))
  
  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual (search-component target <Object>)
    (define (search-name name)
      (let ((presentation (localize (get-presentation-property))))
        (search presentation name ignore-case?: #t)))
    
    (define (search-type type)
      (is? self type))
    
    (let ((name (getf target name:))
          (type (getf target type:)))
      (and (or (not name) (search-name name))
           (or (not type) (search-type type)))))
  
  
  (method protected (search-text text <Object> target <Object>)
    (define (search-plain-text text <Object> target <Object>)
      (some? (lambda (line)
               (search line target ignore-case?: #t))
             (get-paragraphs~ text)))
    
    (define (search-formatted-text text <Object> target <Object>)
      (some? (lambda (info)
               (bind (format . runs) info
                 (some? (lambda (run)
                          (let ((string (car run)))
                            (search string target ignore-case?: #t)))
                        runs)))
             (get-paragraphs~ text)))
    
    (unimplemented 'search-text)
    @Unimplemented
    (typecase text
      ((Formatted-Text)
       (search-formatted-text text target))
      ((Text)
       (search-plain-text text target))
      (else
       #f)))
  
  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public virtual (launch . rest)
    )
  
  
  ;;;
  ;;;; Path
  ;;;
  
  
  (method public (component-path (root #f))
    (let (iter (path '())
               (scan self))
      (cond ((eq? scan root)
             (new Path path))
            ((not scan)
             (error "{t} is not a descendant of the root component {t}" self root))
            (else
             (let* ((parent-scan (get-parent~ scan))
                    (name/rank (or (get-name~ scan) (and parent-scan (child-rank~ parent-scan scan)))))
               (iter (cons name/rank path)
                     parent-scan))))))
  
  
  (method public virtual (present-path root)
    (let ((path '())
          (pres #f)
          (scan self))
      (while (neq? scan root)
        (let ((name (get-name~ scan)))
          (when (present-in-path?~ scan)
            (set! pres (cons (if name (->string name) "{}") (or pres '()))))
          (set! path (cons (or name (child-rank~ (get-parent~ scan) scan)) path))
          (set! scan (get-parent-component~ scan))
          (when (null? scan)
            (error "{t} is not a descendant of the root component {t}" self root))))
      (values (new Path path) pres)))
  
  
  (method public virtual (present-in-path?)
    #t)

  
  ;;;
  ;;;; Unfold
  ;;;
  
  
  (method public (unfold-branches (branches: branches #t) (properties: properties '()) (include-root?: include-root? #t))
    (let* ((form (get-form~ (get-creator)))
           (active-branch (get-branch))
           (active-branch-name (and active-branch (get-name~ active-branch)))
           (all-branch-names (map get-name~ (child-traits)))
           (instantiate
             (lambda (branch-name)
               (if (eq? branch-name active-branch-name)
                   self
                 (let ((client (apply (~ instantiate form) properties)))
                   (when branch-name
                     (let ((branch (child~ client branch-name)))
                       (set-restoreable?~ branch #f)
                       (set-active-branch~ client branch)))
                   client)))))
      (if (eq? branches #t)
          (if include-root?
              (cons (instantiate #f) (map instantiate all-branch-names))
            (map instantiate all-branch-names))
        (map instantiate branches))))


  ;;;
  ;;;; Foreign
  ;;;
  
  
  (method public virtual (search-descendants criteria)
    (if (not criteria)
        (get-children)
      (unimplemented 'search-descendants)))


  ;;;
  ;;;; Toolbox
  ;;;


  (method meta public virtual (show-in-toolbox?)
    #t)
  
  
  ;;;
  ;;;; Try Out
  ;;;
  
  
  (method meta public virtual (try-out)
    )


  ;;;
  ;;;; Descriptor
  ;;;


  (method meta public virtual (get-class-descriptor (context: context #f))
    (new (module-ref 'jazz.descriptor 'Component-Descriptor)))
  
  
  (method meta public virtual (get-domain property)
    (class-get-domain~ (get-descriptor self) self property))
  
  
  (method meta public virtual (get-category property)
    (class-get-category~ (get-descriptor self) self property))
  
  
  (method meta public virtual (get-standard? property)
    (class-get-standard?~ (get-descriptor self) self property))
  
  
  (method meta public (get-class-presentation)
    (class-presentation~ (get-descriptor self) self))
  
  
  (method meta public (get-class-image)
    (class-image~ (get-descriptor self) self))
  
  
  (method meta public (get-name-prohibited?)
    (class-name-prohibited?~ (get-descriptor self) self))
  
  
  (method meta public (get-name-mandatory?)
    (class-name-mandatory?~ (get-descriptor self) self))
  
  
  (method meta public (get-name-unicity?)
    (class-name-unicity?~ (get-descriptor self) self))
  
  
  (method meta public (presentation->name presentation)
    (class-presentation->name~ (get-descriptor self) self presentation))
  
  
  (method meta public (name->presentation name)
    (class-name->presentation~ (get-descriptor self) self name))
  
  
  (method meta public (property-presentation property)
    (class-property-presentation~ (get-descriptor self) self property))
  
  
  (method meta public (detail-presentation property)
    (class-detail-presentation~ (get-descriptor self) self property))
  
  
  (method meta public (persist-property? property)
    (class-persist-property?~ (get-descriptor self) self property))
  
  
  (method public (presentation-property? property)
    (component-presentation-property?~ (get-descriptor (class-of self)) self property))
  
  
  (method public (get-presentation-property)
    (component-get-presentation~ (get-descriptor (class-of self)) self))
  
  
  (method public (set-presentation-property designer presentation)
    (component-set-presentation~ (get-descriptor (class-of self)) self designer presentation))
  
  
  (method protected (get-string-presentation)
    (component-get-string-presentation~ (get-descriptor (class-of self)) self))
  
  
  (method protected (set-string-presentation designer presentation)
    (component-set-string-presentation~ (get-descriptor (class-of self)) self designer presentation))
  
  
  (method public (present-property property value)
    (component-present-property~ (get-descriptor (class-of self)) self property value))
  
  
  (method public (get-components)
    (component-get-components~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-component-image)
    (component-get-component-image~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-cut-component?)
    (component-can-cut-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-copy-component?)
    (component-can-copy-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-paste-component?)
    (component-can-paste-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-paste-properties-component?)
    (component-can-paste-properties-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-rename-component?)
    (component-can-rename-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-select-all-component?)
    (component-can-select-all-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-delete-component?)
    (component-can-delete-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-relocate-component?)
    (component-can-relocate-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-view-properties?)
    (component-can-view-properties?~ (get-descriptor (class-of self)) self))
  
  
  (method public (determine-can-paste (try-parent? #t))
    (component-determine-can-paste~ (get-descriptor (class-of self)) self try-parent?))
  
  
  (method public (determine-paster (try-parent? #t))
    (component-determine-paster~ (get-descriptor (class-of self)) self try-parent?))
  
  
  (method public (can-send-before? types father before)
    (component-can-send-before?~ (get-descriptor (class-of self)) self types father before))
  
  
  (method public (sort-components?)
    (component-sort-components?~ (get-descriptor (class-of self)) self))
  
  
  (method public (sort-components predicate components)
    (component-sort-components~ (get-descriptor (class-of self)) self predicate components))
  
  
  (method public (indexable?)
    (component-indexable?~ (get-descriptor (class-of self)) self))
  
  
  (method public (component-surrogate)
    (component-surrogate-class~ (get-descriptor (class-of self)) self))


  (method public (install-surrogate editor)
    (component-install-surrogate~ (get-descriptor (class-of self)) self editor))
  
  
  (method public (install-children-surrogates editor)
    (component-install-children-surrogates~ (get-descriptor (class-of self)) self editor))


  (method public (remove-surrogate)
    (component-remove-surrogate~ (get-descriptor (class-of self)) self))


  (method public (remove-component-surrogate)
    (component-remove-component-surrogate~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-default-property)
    (component-get-default-property~ (get-properties-descriptor (class-of self)) self))
  
  
  (method public (get-standard-properties)
    (component-get-standard-properties~ (get-properties-descriptor (class-of self)) self))
  
  
  (method public (property-domain property)
    (component-property-domain~ (get-descriptor (class-of self)) self property))
  
  
  (method public (get-addable-default)
    (component-get-addable-default~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-classes)
    (component-get-addable-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-categorized-addable-classes)
    (component-get-categorized-addable-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (addable-class? class)
    (component-addable-class?~ (get-descriptor (class-of self)) self class))
  
  
  (method public (get-component-classes)
    (component-get-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-traits)
    (component-get-addable-traits~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-default-trait)
    (component-get-addable-default-trait~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-base)
    (component-get-addable-base~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-details)
    (component-get-addable-details~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-recursive-details?)
    (component-get-recursive-details?~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-class-searchable-classes)
    (component-get-class-searchable-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-custom-details)
    (component-get-custom-details~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-custom-card)
    (component-get-custom-card~ (get-descriptor (class-of self)) self))
  
  
  (method public (add-component-menu menu)
    (component-add-component-menu~ (get-descriptor (class-of self)) self menu))
  
  
  (method public (save-component-properties designer)
    (component-save-properties~ (get-descriptor (class-of self)) self designer))


  ;;;
  ;;;; Designers
  ;;;
  
  
  (method public (get-designers)
    designers)
  
  
  (method public (set-designers lst)
    (set! designers lst)
    (for-each (lambda (child)
                (set-designers~ child lst))
              children))
  
  
  (method public (install-designer designer)
    (set! designers (cons designer designers))
    (for-each (lambda (child)
                (install-designer~ child designer))
              (get-components)))
  
  
  (method public (uninstall-designer designer)
    (set! designers (remove! designer designers))
    (for-each (lambda (child)
                (uninstall-designer~ child designer))
              (get-components)))


  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (print-component formatter output)
    (unimplemented 'print-component)
    @Component-HTML-Printer
    (let ((output (new Component-HTML-Printer self formatter output)))
      (print-html~ output)
      output))
  
  
  (method public (export-text)
    (unimplemented 'export-text)
    @convert
    (let ((output (open-output-string)))
      (generate-text output)
      (set-clipboard-text (get-output-string output))))
  
  
  (method public virtual (generate-text output)
    (let ((formatter (new-text-formatter)))
      (print-text formatter output)))
  
  
  (method protected virtual (new-text-formatter)
    (unimplemented 'new-text-formatter)
    @Formatter
    (new Formatter))
  
  
  (method public virtual (print-text formatter output)
    )
  
  
  (method public virtual (output-component text)
    )
  
  
  (method public virtual (output-properties text)
    (unimplemented 'output-properties)
    @get-properties
    (for-each (lambda (property)
                (let ((title (localize (property-presentation~ (class-of self) property)))
                      (value (->string (read-property self property))))
                  (insert-bulleted-line~ text (format "{a} : {a}" title value))))
              (get-properties)))))
