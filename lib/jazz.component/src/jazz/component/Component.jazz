;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Component
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.component.Component jazz


(import (jazz.component)
        (jazz.event)
        (jazz.io)
        (jazz.jml))


;;;
;;;; Component-Class
;;;


(class Component-Class extends Class


  (method package virtual (get-class-form self)
    #f)
  
  
  (method virtual (set-class-form self form)
    )
  

  (method package virtual (get-class-forms self)
    '())
  
  
  (method public (get-properties self)
    (collect-if (lambda (property)
                  (and (property? property)
                       (property-getter property)))
                (get-instance-slots self)))


  ;;;
  ;;;; Toolbox
  ;;;


  (method public virtual (show-in-toolbox? self)
    #t)
  
  
  ;;;
  ;;;; Try Out
  ;;;
  
  
  (method public virtual (try-out self)
    )


  ;;;
  ;;;; Descriptor
  ;;;


  (method public virtual (get-class-descriptor self (context: context #f))
    (new jazz.descriptor:Component-Descriptor)))


;;;
;;;; Component
;;;


(class Component metaclass Component-Class extends Object implements Event-Consumer
  
  
  ;; prepare      -> before the form gets installed
  ;; install      -> installs the class form and sets installed? -> #t
  ;; finish       -> before form structure from a containing form gets installed and sets finished? -> #t
  ;; conclude     -> after all initialization done, but before calling show
  
  
  (definition Installed-Flag    #x00000001)
  (definition Finished-Flag     #x00000002)
  (definition Initialized-Flag  #x00000004)
  (definition Visible-Flag      #x00000008)
  (definition Destroying-Flag   #x00000020)
  (definition Destroyed-Flag    #x00000040)
  (definition Layout-Valid-Flag #x00000100)
  
  
  (slot name                         initialize #f)
  (slot parent                       initialize #f)
  (slot base-traits                  initialize #f)
  (slot default-traits               initialize #f)
  (slot branch                       initialize #f)   ;; the immediatly installed branch
  (slot base-branch                  initialize #f)   ;; the branch set by base-traits and used when replacing the default-traits
  (slot form                         initialize #f)   ;; the form that created the component
  (slot class-forms                  initialize #f getter generate)
  (slot creator                      initialize #f)   ;; the root component of the class form (used for indexing and as inner class instantiation context)
  (slot creator-branch               initialize #f)   ;; the branch that created the component (#f if none)
  (slot event-consumer               initialize self)
  (slot designers                    initialize '())
  (slot surrogate                    initialize #f accessors generate)
  (slot index                        initialize #f)
  (slot flags                 <fx>   initialize Visible-Flag)
  
  
  (property before                   initialize #f  accessors explicit)
  (property children                 initialize '() accessors explicit)
  (property visible?          <void>                accessors explicit)
  @descriptor-convert
  (property class-info        <void>                getter get-class-info)
  (property name-info         <void>                getter get-name-info)
  @descriptor-convert
  (property presentation-info <void>                getter get-presentation-info)
  

  ;;;
  ;;;; Access
  ;;;
  
  
  (method public inline (get-name self)
    name)
  
  
  (method public inline (set-name self value)
    (set! name value))
  
  
  (method public inline (get-parent self)
    parent)
  
  
  (method public virtual (set-parent self value)
    (when parent
      (remove-child parent self))
    (set! parent value)
    (when parent
      (install-in-parent self)))


  (method public inline (get-before self)
    before)


  (method public (set-before self value)
    (set! before value)
    (when (get-finished? self)
      (send-child-before parent self (child parent before))))
  
  
  (method public inline (get-children self)
    children)
  
  
  (method public virtual (set-children self lst <Sequence>)
    (set! children '())
    (loop (for child in lst)
          (do (set-parent child self))))
  
  
  (method public inline (get-branch self)
    branch)
  
  
  (method public inline (set-branch self value)
    (set! branch value))


  (method public inline (get-form self)
    form)
  
  
  (method public inline (set-form self value)
    (set! form value))


  (method public inline (get-creator self)
    creator)
  
  
  (method public inline (set-creator self value)
    (set! creator value))


  (method public inline (get-creator-branch self)
    creator-branch)
  
  
  (method public inline (set-creator-branch self value)
    (set! creator-branch value))
  
  
  @descriptor-convert
  (method (get-class-info)
    (get-class-presentation (class-of self)))
  
  
  (method (get-name-info self)
    (if (not name)
        "{}"
      (->string name)))
  
  
  @descriptor-convert
  (method (get-presentation-info)
    (get-presentation-property))
  
  
  (method public (get-file-form self)
    (case (get-action form)
      ((instantiate) (registered-file-form (get-tag-reference form)))
      (else form)))
  
    
  ;;;
  ;;;; Flags
  ;;;
  
  
  (method protected (get-installed? self)
    (mask-bit-set? flags Installed-Flag))
  
  (method protected (set-installed? self flag <bool>)
    (set! flags (mask-bit-set flags Installed-Flag flag)))
  
  
  (method protected (get-finished? self)
    (mask-bit-set? flags Finished-Flag))
  
  (method (set-finished? self flag <bool>)
    (set! flags (mask-bit-set flags Finished-Flag flag)))
  
  
  (method protected (get-initialized? self)
    (mask-bit-set? flags Initialized-Flag))
  
  (method (set-initialized? self flag <bool>)
    (set! flags (mask-bit-set flags Initialized-Flag flag)))
    
  
  (method public (get-visible-flag self)
    (mask-bit-set? flags Visible-Flag))
  
  (method public (set-visible-flag self flag <bool>)
    (set! flags (mask-bit-set flags Visible-Flag flag)))

  
  (method (get-destroying? self)
    (mask-bit-set? flags Destroying-Flag))
  
  (method (set-destroying? self flag <bool>)
    (set! flags (mask-bit-set flags Destroying-Flag flag)))

  
  (method (get-destroyed? self)
    (mask-bit-set? flags Destroyed-Flag))
  
  (method (set-destroyed? self flag <bool>)
    (set! flags (mask-bit-set flags Destroyed-Flag flag)))

  
  (method (get-layout-valid? self)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  (method (set-layout-valid? self flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))


  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (call-print self output detail)
    (if (get-initialized? self)
        (print self output detail)
      (print-unreadable self output
        (lambda (output)
          ))))

  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" name))))


  ;;;
  ;;;; Initialization
  ;;;


  (method override (initialize self . rest)
    (nextmethod self)
    (initialize-component self rest))
  
  
  (method protected virtual (initialize-component self rest)
    (prepare self rest)
    (install self rest)
    (set-installed? self #t)
    (finish self rest)
    (install-in-parent self)
    (set-finished? self #t)
    (setup-component self)
    (conclude self rest)
    (set-initialized? self #t)
    (let ((visible? (get-visible? self)))
      (when (neq? visible? (initially-visible? self))
        (if visible?
            (show self)
          (hide self)))))


  (method protected virtual (default-name self)
    #f)


  (method protected virtual (default-parent self)
    #f)
  
  
  (method protected virtual (setup-parent self)
    )


  (method package chained (prepare self initargs <Object>)
    (define (prepare-parent)
      (let ((arg (getf initargs parent: not-found: #f)))
        (set! parent (if (not arg) (default-parent self) arg))
        (setup-parent self)))
    
    (define (prepare-component)
      (let ((init-name (or (getf initargs name:) (default-name self))))
        (when init-name
          (set-name self init-name)))
      (let ((alternative-class-form (getf initargs class-form:))
            (class-forms (get-class-forms (class-of self))))
        (set! self.class-forms (if alternative-class-form
                                   (cons alternative-class-form (if (null? class-forms) class-forms (cdr class-forms)))
                                 class-forms)))
      (set-form self (or (getf initargs form:)
                    (and (not-null? class-forms)
                         (car class-forms))))
      (set-creator self (getf initargs creator:))
      (set-creator-branch self (getf initargs creator-branch:)))
    
    (prepare-parent)
    (prepare-component))


  (method protected chained (install self initargs <Object>)
    (define (install-inherited forms)
      (when (not-null? forms)
        (install-inherited (cdr forms))
        (install-form self (car forms) self #f #f)))
    
    (install-inherited class-forms))
  
  
  (method public (install-form self form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (define (install-base-traits properties)
      (let ((traits (or (getf properties 'base-traits) (getf properties base-traits:))))
        (when traits
          (set-base-traits self traits))))
    
    (define (install-properties properties <Object> restore-form <Object>)
      (let (iter (scan properties))
        (when (not-null? scan)
          (let ((expr (car scan))
                (value (cadr scan)))
            (unless (initer-property? self expr)
              (when (symbol? expr)
                (set! expr (component-property self (class-of self) expr))
                (set-car! scan expr))
              (when restore-form
                (remember-property restore-form self expr))
              (write-property-to self expr value)))
          (iter (cddr scan)))))
    
    (define (install-children children <Object> creator <Object> creator-branch <Object> restore-form <Object>)
      (loop (for child in children)
            (do (install-child self child creator creator-branch restore-form))))
    
    (define (install-default-traits properties)
      (let ((traits (or (getf properties 'default-traits) (getf properties default-traits:))))
        (when traits
          (set-default-traits self traits))))
    
    (when form
      (let ((properties (get-properties form))
            (children (get-children form)))
        (install-base-traits properties)
        (install-properties properties restore-form)
        (install-children children creator creator-branch restore-form)
        (install-default-traits properties))))
  
  
  (method protected virtual (install-child self form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (let ((action (get-action form))
          (name (get-name form)))
      (define (new-component)
        (let ((reference (get-tag-reference form)))
          (if (and (eq? action 'instantiate) (file? reference))
              (catch (Unknown-Alias-Exception exc
                       (handle-not-found reference))
                (if (exists? reference)
                    (parameterize ((current-tag-reference-chain (cons reference (current-tag-reference-chain))))
                      (let ((child (instantiate-file reference parent: self name: name form: form creator: creator creator-branch: creator-branch)))
                        (install-form child form creator creator-branch restore-form)
                        (set-form child form)
                        child))
                  (handle-not-found reference)))
            (let ((model (if reference (module-ref reference (get-model form)) (form-model (or creator self) form))))
              (if model
                  (new model parent: self name: name form: form creator: creator creator-branch: creator-branch)
                (error "Unable to resolve model: {s}" (get-model form)))))))
      
      (define (handle-not-found reference)
        (let ((handler (tag-reference-not-found-handler)))
          (if handler
              (instantiate (handler reference) parent: self name: name)
            (error "Unable to find tag-reference: {s}" reference))))
      
      (case action
        ((new instantiate)
         (let ((component (new-component)))
           (when creator
             (add-to-index creator (get-name component) component))
           (when restore-form
             (remember-creation restore-form self component))))
        ((modify locate)
         (when restore-form
           (set! restore-form (remember-reference restore-form self name)))
         (install-form (find-to-modify self name equal?) form creator creator-branch restore-form))
        ((remove)
         (let ((child (get-component form)))
           (close child)))
        (else
         (error "Unknown form action: {t} in {t}" action form)))))
  
  
  (method public virtual (find-to-modify self name <Object> test <procedure>)
    (or (find-component-with self name test)
        (locate self name)))
  
  
  ;; This is a very poor version of automatically being able to override subform classes.
  ;; For now, it will have to do because a clean efficient solution completely eludes me!
  (method public virtual (form-model self form <Form>)
    (resolve-model form))


  (method protected chained (finish self initargs <Object>)
    (define (write-properties properties <Object>)
      (define (write-initarg-to object <Object> property <Object> value <Object>)
        (let ((property-name (keyword->symbol property)))
          (unless (initer-property? self property-name)
            (write-property-to object (component-property self (class-of object) property-name) value))))
      
      (loop (for (property value) in-properties properties)
            (do (write-initarg-to self property value))))
    
    (bind-keywords ((form #f) (creator #f) . others) initargs
      (when form
        ;; setting the creator to #t is a service for Form instantiate
        (if (neq? creator #t)
            (install-form self form creator #f #f)
          (set! self.creator self)
          (install-form self form self #f #f)))
      (write-properties initargs)))
  
  
  (method package chained (setup-component self)
    )
  
  
  ;; Only done after the component is fully initialized so as not to install
  ;; an invalid component should an error occur during the initialization phase.
  (method protected virtual (install-in-parent self)
    (when parent
      (let ((designers (get-designers parent)))
        (when (not-null? designers)
          (update-designers self designers)))
      (let ((surrogate (get-surrogate parent)))
        (when (and surrogate update-surrogate!)
          (update-surrogate! self surrogate)))
      (add-child parent self)))


  (method package chained (conclude self initargs <Object>)
    )


  (method override (initialized? self)
    (get-initialized? self))


  ;;;
  ;;;; Destruction
  ;;;


  (method override (destroying? self)
    (get-destroying? self))


  (method override (destroyed? self)
    (get-destroyed? self))


  (method override (close self)
    (unless (destroyed? self)
      (destroy-component self)))


  ;; called before children are destroyed
  (method package chained (destroy-component self)
    (set-destroying? self #t)
    (for-each (lambda (child)
                (when (is? child Component)
                  (destroy-component child)))
              children)
    (destroy self)
    (set-destroyed? self #t))
  
  
  ;; called after children are destroyed
  (method override (destroy self)
    (when parent
      (remove-child parent self))
    (when creator
      (remove-from-index creator name self))
    (nextmethod self))
  
  
  (method public (close-children self)
    (for-each close children))
  
  
  (method public virtual (confirm-close self . rest)
    #t)


  ;;;
  ;;;; Visibility
  ;;;


  (method public virtual (initially-visible? self)
    #t)


  (method public virtual (get-visible? self)
    (get-visible-flag self))
  
  
  (method public virtual (set-visible? self flag <bool>)
    (if (not (get-finished? self))
        (set-visible-flag self flag)
      (when (neq? (get-visible-flag self) flag)
        (if flag
            (show self)
          (hide self)))))
  
  
  (method public virtual (show self)
    (set-visible-flag self #t))
  
  
  (method public virtual (hide self)
    (set-visible-flag self #f))


  ;;;
  ;;;; Properties
  ;;;
  
  
  (definition initer-properties
    (list->table
      '((name . #t)
        (parent . #t)
        (base-traits . #t)
        (default-traits . #t)
        (form . #t)
        (class-form . #t)
        (creator . #t)
        (creator-branch . #t))))
  
  
  (method package chained (initer-property? self name)
    (table-ref initer-properties name #f))
  
  
  (method (component-property self category <Object> name <Object>)
    (let ((field (mop-category-field category name)))
      (if (property? field)
          field
        (error "Unknown property: {t}" name))))


  (definition (write-property-to object <Object> property <Object> value <Object>)
    (let ((setter (property-setter property)))
      (if setter
          (setter object value)
        (error "Property {s} has no setter" property))))


  ;;;
  ;;;; Children
  ;;;


  (method public (name? self object <Object>)
    (or (symbol? object)
        (integer? object)
        (null? object)
        (pair? object)))


  (method public virtual (add-child self child <Object>)
    (let ((before (and (is? child Component) (get-before child))))
      (if (not before)
          (set! children (append! children (list child)))
        (send-child-before self child (find-component self before)))))
  
  
  (method public (add-child-at self child <Object> rank <Integer+>)
    (set! children (insert! children rank child)))
  
  
  (method public (append-child self child <Object>)
    (set! children (append! children (list child))))


  (method public virtual (remove-child self child <Object>)
    (set! children (remove! child children)))
    
  
  (method public virtual (replace-child self rank <fx> replacement <Object>)
    (let ((child (element children rank)))
      (set-parent replacement self)
      (set-parent child #f)
      (set! children (insert! (remove! replacement children) rank replacement))))
  
  
  (method public virtual (front-child? self child)
    (eq? child (first children)))
  
  
  (method public virtual (back-child? self child)
    (eq? child (last children)))


  (method public virtual (send-child-to-front self child <Object>)
    (set! children (move-to-head! child children)))


  (method public virtual (send-child-to-back self child <Object>)
    (set! children (move-to-tail! child children)))
  
  
  (method public (send-child-before self child <Object> target)
    (let ((removed (remove! child children)))
      (let ((rank (and target (or (find removed target) (error "Unable to find: {t}" target)))))
        (set! children (insert! removed rank child)))))
  
  
  (method public (child self name <Object>)
    (or (find-component self name)
        (error "Could not find child {t}" name)))
  
  
  (method public (find-component self name <Object>)
    (find-component-with self name equal?))
  
  
  (method public (find-component-with self name <Object> test <procedure>)
    (cond ((null? name)
           (error "Invalid location: {t}" name))
          ((integer? name)
           (if (= name 0)
               self
             (find-component parent (- name 1))))
          ((pair? name)
           (let ((sub (find-component self (car name))))
             (and sub
                  (let ((next (cdr name)))
                    (if (null? next)
                        sub
                      (find-component sub next))))))
          (else
           (or (component-alias self name)
               (find-child-with self name test)))))
  
  
  (method public (brother self name <Object>)
    (child parent name))
  
  
  (method public (next-brother self (type: type #f))
    (if (not parent)
        self
      (next-child parent self type: type)))
  
  
  (method public (previous-brother self (type: type #f))
    (if (not parent)
        self
      (previous-child parent self type: type)))
  
  
  (method public (child-ranked self rank <fx>)
    (element children rank))
  
  
  (method public virtual (component-alias self name <Object>)
    (case name
      ((:self) self)
      ((:parent) parent)
      ((:creator) creator)
      (else (resolve-nickname name))))
  
  
  (method public (find-path self path)
    (if (null? path)
        self
      (let ((child (find-child self (car path))))
        (and child (find-path child (cdr path))))))
  

  (method public (find-child self name <Object>)
    (loop (for child in children)
          (when (equal? (get-name child) name)
            (return child))
          (finally #f)))


  (method public (find-child-with self name <Object> test <procedure>)
    (loop (for child in children)
          (when (test (get-name child) name)
            (return child))
          (finally #f)))


  (method public (find-type self type)
    (loop (for child in children)
          (when (is? child type)
            (return child))
          (finally #f)))
  
  
  (method public (find-key self key value)
    (loop (for child in children)
          (when (equal? (key child) value)
            (return child))
          (finally #f)))
  
  
  (method public (find-ascendant self type (include-self?: include-self? #f))
    (if (and include-self? (is? self type))
        self
      (let ((parent (get-parent self)))
        (while (and parent (is-not? parent type))
          (set! parent (get-parent parent)))
        parent)))
  
  
  (method public (find-descendant self predicate (include-self?: include-self? #t))
    (continuation-capture
      (lambda (return)
        (for-each-descendant self
          (lambda (component level)
            (when (predicate component)
              (continuation-return return component)))
          include-self?: include-self?)
        #f)))
  
  
  (method public (collect-ascendants self (type #f))
    (let ((ascendants '())
          (parent (get-parent self)))
      (while (and parent (or (not type) (is-not? parent type)))
        (set! ascendants (cons parent ascendants))
        (set! parent (get-parent parent)))
      (if (or (not parent) (and type (is? parent type)))
          ascendants
        (cons parent ascendants))))
  
  
  (method public (child-rank self child <Object>)
    (find children child))
  
  
  (method public (get-brothers self)
    (when parent
      (remove self (get-children parent))))
  
  
  (method public (has-parent? self component <Component>)
    (and parent (or (eq? parent component) (has-parent? parent component))))
  
  
  (method public (has-ascendant? self component <Component>)
    (or (eq? self component) (has-parent? self component)))
  
  
  (method public (get-root-parent self)
    (if (not parent)
        self
      (get-root-parent parent)))
  
  
  (method public (get-visible-children self)
    (collect-if get-visible? children))
  
  
  (method public (first-visible-child self)
    (let ((visible (get-visible-children self)))
      (if (null? visible)
          #f
        (car visible))))
  
  
  (method public (get-ancestry self)
    (let (iter (scan self) (ancestry '()))
      (if (not scan)
          ancestry
        (iter (get-parent scan) (cons scan ancestry)))))
  
  
  (method public (validate-duplicates self title)
    (let ((duplicates (collect-duplicates (map get-name children) test: equal?)))
      (when (not-null? duplicates)
        (error "Found duplicate names in {a}: {l}" title duplicates))))


  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (for-each-parent self proc <procedure>)
    (when parent
      (proc parent)
      (for-each-parent parent proc)))
  
  
  (method public (for-each-ancestor self proc <procedure>)
    (proc self)
    (for-each-parent self proc))
  
  
  (method public (for-each-descendant self proc <procedure> (include-self?: include-self? #t) (stop-test: stop-test #f))
    (when include-self?
      (proc self 0))
    (let (iter (component self)
               (level 1))
      (loop (for child in (get-children component))
            (proc child level)
            (unless (and stop-test (stop-test child))
              (iter child (+ level 1))))))


  (method public (collect-descendants self (type #f))
    (let ((factory (new List-Factory)))
      (for-each-descendant self
        (lambda (child level)
          (when (or (not type) (is? child type))
            (put factory child))))
      (get-output factory)))
  
  
  (method public (for-each-sibling self proc <procedure>)
    (loop (for child in (get-children parent))
          (when (neq? child self)
            (proc child))))
  
  
  ;;;
  ;;;; Widget
  ;;;
  
  
  (method public (outer-component self limit)
    (let ((outer parent)
          (component self))
      (while (and outer (inner? outer component) (neq? component limit))
        (set! component outer)
        (set! outer (get-parent outer)))
      component))
  
  
  (method public (outer? self limit)
    (eq? self (outer-component self limit)))
  
  
  (method public virtual (inner? self component)
    #f)
  
  
  (method public virtual (inner-widget self)
    self)
  
  
  ;;;
  ;;;; Form
  ;;;
  
  
  (method public virtual (add-form self parent-form <Form> child-form <Form>)
    (append-parent child-form parent-form))


  ;;;
  ;;;; Index
  ;;;
  
  
  (method public virtual (add-to-index self name <Object> component <Component>)
    (when name
      (when (not index)
        (set! index (new-index self)))
      (let ((ref (table-ref index name #f)))
        (table-set! index name (cond ((list? ref) (cons component ref))
                                     (ref (list component ref))
                                     (else component))))))
  
  
  (method public virtual (remove-from-index self name <Object> component <Component>)
    (when (and name index)
      (let ((ref (table-ref index name #f)))
        (if (list? ref)
            (let ((removed (remove component ref)))
              (table-set! index name (if (= 1 (length removed))
                                         (car removed)
                                       removed)))
          (table-clear index name)))))
  
  
  (method protected virtual (new-index self)
    (make-table test: eq?))
  
  
  (method public virtual (locate self name <Object>)
    (let ((component (locate-component self name)))
      (cond ((not component) (error "Unable to locate {t}" name))
            ((list? component) (error "Ambiguous name: {t}" name))
            (else component))))
  
  
  (method public (locate-recursive self name <Object>)
    (let ((component (locate-component-recursive self name)))
      (cond ((not component) (error "Unable to locate {t}" name))
            ((list? component) (error "Ambiguous name: {t}" name))
            (else component))))
  
  
  (method public (locate-component self name <Object>)
    (cond ((pair? name)
           (let ((sub (locate-component self (car name))))
             (and sub
                  (let ((next (cdr name)))
                    (if (null? next)
                        sub
                      (locate-component sub next))))))
          (else
           (and index (table-ref index name #f)))))
  
  
  (method public (locate-component-recursive self name <Object>)
    (define (is-descendant? component)
      (find-descendant self
        (lambda (c)
          (and (eq? c component)
               (not (eq? self c))))))
    
    (let (loop (creator self))
      (and creator
           (let ((components (collect-if is-descendant? (listify (locate-component creator name)))))
             (cond ((null? components)
                    (loop (get-creator self)))
                   ((> (length components) 1)
                    components)
                   (else
                    (car components)))))))
  
  
  (method public (identify-component self component)
    (let (loop (component component) (identifier '()))
      (let ((creator (get-creator component)))
        (when creator
          (let ((name (get-name component)))
            (when (eq? (locate-component creator name) component)
              (if (eq? creator self)
                  (cons name identifier)
                (loop creator (cons name identifier)))))))))
  
  
  (method public (identify-descendant self component)
    (let (loop (component component) (identifier '()))
      (if (eq? component self)
          identifier
        (let ((creator (get-creator component))
              (name (get-name component)))
          (or (and creator
                   (eq? (locate-component creator name) component)
                   (if (eq? creator self)
                       (cons name identifier)
                     (loop creator (cons name identifier))))
              (let ((parent (get-parent component)))
                (and name
                     parent
                     (loop parent (cons name identifier)))))))))
  
  
  (method public (locate-descendant self path)
    (define (locate-element in elem)
      (or (locate-component in elem)
          (find-component in elem)))
    
    (let (locate (in self) (path path))
      (cond ((null? path)
             in)
            ((pair? path)
             (let ((elem (car path)))
               (let ((component (locate-element in elem)))
                 (when component
                   (locate component (cdr path))))))
            (else
             (locate-element in path)))))


  ;;;
  ;;;; Clone
  ;;;
  
  
  (method public (clone-component self . rest)
    (let ((tag-reference (get-tag-reference form)))
      (if tag-reference
          (apply instantiate-file tag-reference rest)
        (apply instantiate form rest))))


  ;;;
  ;;;; Database
  ;;;
  
  
  (method public (get-database-component self)
    (get-root-parent self))


  ;;;
  ;;;; Consumer
  ;;;
  

  (method override (get-event-consumer self)
    event-consumer)
  
  
  (method override (set-event-consumer self consumer <Event-Consumer>)
    (set! event-consumer consumer))


  (method override (deliver-event self handler target proc event)
    (proc target event))


  ;;;
  ;;;; Layering
  ;;;
  
  
  (method public (first-child self)
    (if (null? children)
        #f
      (car children)))
  
  
  (method public (second-child self)
    (if (>= (length children) 2)
        (second children)
      #f))
  
  
  (method public (last-child self)
    (last children))
  
  
  (method public (next-child self child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (+ rank 1) (length children))))))
  
  
  (method public (previous-child self child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (- rank 1) (length children))))))
  
  
  (method public (front? self)
    (or (not parent) (front-child? parent self)))
  
  
  (method public (back? self)
    (or (not parent) (back-child? parent self)))
  
  
  (method public virtual (bring-to-front self)
    (when parent
      (send-child-to-front parent self)))
  
  
  (method public virtual (send-to-back self)
    (when parent
      (send-child-to-back parent self)))
  
  
  (method public virtual (send-before self target)
    (when parent
      (send-child-before parent self target)))


  ;;;
  ;;;; Traits
  ;;;
  
  
  (method public (branch-installed? self)
    (boolean branch))
  
  
  (method public (get-active-branch self)
    (if (not branch)
        #f
      (let (iterate (branch branch))
        (if (get-branch branch)
            (iterate (get-branch branch))
          branch))))
  
  
  (method public (get-active-trait self)
    (let ((branch (get-active-branch self)))
      (and branch
           (get-trait branch))))
  
  
  (method public (set-active-trait self trait)
    (replace-traits self #f (if trait (list trait) '())))
  
  
  (method public (get-active-trait-name self)
    (let ((trait (get-active-trait self)))
      (and trait
           (get-name trait))))
  
  
  (method public (get-base-traits self)
    base-traits)
  
  
  (method public (set-base-traits self traits)
    (let ((traits (listify traits)))
      (set! base-traits traits)
      (let ((preserve (and base-branch (get-active-trait self))))
        (replace-traits self #f traits)
        (set! base-branch (get-active-branch self))
        (when preserve
          (push-trait self preserve)))))
  
  
  (method public (get-default-traits self)
    default-traits)
  
  
  (method public (set-default-traits self traits)
    (let ((traits (listify traits)))
      (set! default-traits traits)
      (replace-traits self base-branch traits)))
  
  
  (method public (push-trait self trait)
    (replace-traits self base-branch (list trait)))
  
  
  (method public (pop-trait self)
    (replace-traits self base-branch '()))
  
  
  (method public (replace-active-trait self trait)
    (replace-traits self base-branch (if trait (list trait) '())))
  
  
  (method public (replace-traits self target-branch traits)
    (define (install-traits root-branch effective-traits)
      (let ((parent-branch root-branch))
        (for-each (lambda (trait)
                    (let ((new-branch (configure-client trait self parent-branch)))
                      (set-branch parent-branch new-branch)
                      (set! parent-branch new-branch)))
                  effective-traits)))
    
    (define (install-in-branch current-branch current-traits)
      (let ((old-branch (get-branch current-branch)))
        (when old-branch
          (restore-client old-branch)
          (set-branch current-branch #f)))
      (install-traits current-branch current-traits))
    
    (define (install-in-self effective-traits)
      (when branch
        (restore-client branch)
        (set! branch #f))
      (when (not-null? effective-traits)
        (let ((new-branch (configure-client (car effective-traits) self self)))
          (set! branch new-branch)
          (install-traits new-branch (cdr effective-traits)))))
    
    (define (change-installed? current-branch current-traits)
      (let ((match? (and current-branch (pair? current-traits) (eq? (get-trait current-branch) (car current-traits)))))
        (when (and match? (not (change-installed? (get-branch current-branch) (cdr current-traits))))
          (install-in-branch current-branch (cdr current-traits)))
        match?))
    
    (let ((effective-traits (apply append! (map compute-effective-traits (map (lambda (trait)
                                                                                 (resolve-trait self trait))
                                                                               traits))))
          (base-branch (if target-branch (get-branch target-branch) branch)))
      (when (not (change-installed? base-branch effective-traits))
        (if target-branch
            (install-in-branch target-branch effective-traits)
          (install-in-self effective-traits)))))
  
  
  (method public (for-each-trait self proc)
    (for-each (lambda (trait)
                (proc trait)
                (for-each-trait trait proc))
              (child-traits self)))
  
  
  (method public (with-each-trait self proc)
    (let ((active-branch (get-branch self)))
      (for-each-trait self
        (lambda (trait)
          (set-active-trait self trait)
          (proc)))
      (set-active-trait self (get-trait active-branch))))
  
  
  (method public (get-branches self)
    (if (not branch)
        '()
      (cons branch (get-branches branch))))
  
  
  (method public (find-trait-branch self trait)
    (find-if (lambda (branch)
               (eq? (get-trait branch) trait))
             (get-branches self)))
  
  
  (method public (iterate-branch-spine self proc (trait: trait #f))
    (let ((branch (get-branch self)))
      (proc self (creator-effective-form self))
      (while (is? branch Branch)
        (proc branch (get-client-form (get-trait branch)))
        (set! branch (get-branch branch)))))
  
  
  ;; For a creator that was install in another creator, it is
  ;; very tricky because it's form is pointing to the form that
  ;; created it inside the other creator but sometimes we need
  ;; the install form that defines its own structure...
  (method public (creator-effective-form self)
    (cond ((eq? self creator)
           form)
          ((not-null? class-forms)
           (car class-forms))
          (else
           #f)))
  
  
  (method public (child-traits self)
    (collect-type Trait children))
  
  
  (method public (trait-spine self trait)
    (let (iter (trait trait) (spine (list trait)))
      (let ((parent (get-parent trait)))
        (if (is? parent Trait)
            (iter parent (cons parent spine))
          spine))))
  
  
  (method public (trait-fullname self trait)
    (apply compose-identifier (map get-name (trait-spine self trait))))
  

  ;;;
  ;;;; Session
  ;;;
  
  
  (method public virtual (save-session self)
    )
  
  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public virtual (launch self . rest)
    )
  
  
  ;;;
  ;;;; Path
  ;;;
  
  
  (method public (component-path self (root #f))
    (let (iter (path '())
               (scan self))
      (cond ((eq? scan root)
             (new Path path))
            ((not scan)
             (error "{t} is not a descendant of the root component {t}" self root))
            (else
             (let* ((parent-scan (get-parent scan))
                    (name/rank (or (get-name scan) (and parent-scan (child-rank parent-scan scan)))))
               (iter (cons name/rank path)
                     parent-scan))))))
  
  
  (method public virtual (present-path self root)
    (let ((path '())
          (pres #f)
          (scan self))
      (while (neq? scan root)
        (let ((name (get-name scan)))
          (when (present-in-path? scan)
            (set! pres (cons (if name (->string name) "{}") (or pres '()))))
          (set! path (cons (or name (child-rank (get-parent scan) scan)) path))
          (set! scan (get-parent scan))
          (when (null? scan)
            (error "{t} is not a descendant of the root component {t}" self root))))
      (values (new Path path) pres)))
  
  
  (method public virtual (present-in-path? self)
    #t)


  ;;;
  ;;;; Foreign
  ;;;
  
  
  (method public virtual (search-descendants self criteria)
    (if (not criteria)
        (get-children self)
      (unimplemented 'search-descendants)))


  ;;;
  ;;;; Designers
  ;;;
  
  
  (method public (get-designers self)
    designers)
  
  
  (method public (set-designers self lst)
    (set! designers lst))
  
  
  (method (update-designers self lst)
    (set! designers lst)
    (for-each (lambda (child)
                (set-designers child lst))
              children))


  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (print-component self formatter output)
    (unimplemented 'print-component)
    @Component-HTML-Printer
    (let ((output (new Component-HTML-Printer self formatter output)))
      (print-html output)
      output))
  
  
  (method public (export-text self)
    (unimplemented 'export-text)
    @convert
    (let ((output (open-output-string)))
      (generate-text output)
      (set-clipboard-text (get-output-string output))))
  
  
  (method public virtual (generate-text self output)
    (let ((formatter (new-text-formatter self)))
      (print-text self formatter output)))
  
  
  (method protected virtual (new-text-formatter self)
    (unimplemented 'new-text-formatter)
    @Formatter
    (new Formatter))
  
  
  (method public virtual (print-text self formatter output)
    )
  
  
  (method public virtual (output-component self text)
    )
  
  
  (method public virtual (output-properties self text)
    (unimplemented 'output-properties)
    @get-properties
    (for-each (lambda (property)
                (let ((title (localize (property-presentation (class-of self) property)))
                      (value (->string (read-property self property))))
                  (insert-bulleted-line text (format "{a} : {a}" title value))))
              (get-properties)))))
