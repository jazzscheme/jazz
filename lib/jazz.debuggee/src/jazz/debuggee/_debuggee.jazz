;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.configure)
        (jazz.debuggee.stub)
        (jazz.debuggee.jazz.autoload)
        (jazz.debugger.stub)
        (jazz.component)
        (jazz.foreign)
        (jazz.io)
        (jazz.inspector)
        (jazz.network)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.process (cond (not ios)))
        (jazz.syntax (phase syntax)))


(cond-expand
  (ios
(definition (get-process)
  #f))
  (else))


;;;
;;;; Local
;;;


(definition local-process
  #f)


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (require-presence 'debugging) (new Jazz-Debuggee-Process)))
    (register-object (get-local-register 'debugging) 'debuggee local-process)))


;;;
;;;; Debugged Continuations
;;;


(definition public debugged-continuations-thread-group
  (make-thread-group 'debugged-continuations))


;;;
;;;; Controller
;;;


(definition controller-debugger
  #f)


(definition preserved-exception-debugger
  #f)

(definition preserved-exception-hook
  #f)

(definition preserved-filesystem-restricted?
  #f)


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller debugger-proxy focus?)
  (detach-from-controller)
  (set! preserved-exception-debugger (get-exception-debugger))
  (set! preserved-exception-hook (get-exception-hook))
  (set! preserved-filesystem-restricted? filesystem-restricted?)
  (set! controller-debugger debugger-proxy)
  (setup-local-process)
  (console-port-getter-set! console-port-getter)
  (console-clear-set! console-clear)
  (attach-process controller-debugger local-process focus?)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook)
  (filesystem-restrict)
  (set-invoke-timeout +inf.0)
  (add-exit-job! detach-from-controller))


(definition public (ready-to-controller (debugger-cookie #f))
  (ready-process controller-debugger local-process debugger-cookie))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    @register-object~-error-when-reattaching
    (set! local-process #f)))


(definition public (detach-from-debugger (close-proxy? #t))
  (when controller-debugger
    (detach-process controller-debugger local-process)
    (when (and close-proxy? (remote-proxy? controller-debugger))
      (closing-remote-proxy controller-debugger))
    (reset-invoke-timeout)
    (set! controller-debugger #f)
    (detach-consoles)
    (set-exception-debugger preserved-exception-debugger)
    (set-exception-hook preserved-exception-hook)
    (unless preserved-filesystem-restricted?
      (filesystem-unrestrict))
    (set! preserved-exception-debugger #f)
    (set! preserved-exception-hook #f)
    (set! preserved-filesystem-restricted? #f)))


(definition package (bailout-from-debugger)
  (when controller-debugger
    (reset-invoke-timeout)
    (set! controller-debugger #f)
    (detach-consoles)
    (set-exception-debugger preserved-exception-debugger)
    (set-exception-hook preserved-exception-hook)
    (set! preserved-exception-debugger #f)
    (set! preserved-exception-hook #f)))


(definition package (setup-debuggee (debugger: debugger #f) (connection-exception-exit?: connection-exception-exit? #t))
  (let ((debugger-arg (or debugger (command-argument "debugger") default-debugger))
        (interactive-arg (command-argument "debugger-interactive")))
    (when debugger-arg
      (receive (host port alternate-port) (parse-host/service debugger-arg)
        (if (not port)
            (error "Ill-formed debugger argument: {a}" debugger-arg)
          (catch (connection-exception? exc
                   (if (not connection-exception-exit?)
                       exc
                     (jazz.platform:system-message "Unable to connect to debugger"
                       title: "Application"
                       type: 'problem)
                     (exit 1)))
            (attach-debuggee host port focus?: #t @annoying-when-starting-from-terminal (parse-boolean interactive-arg))
            #f))))))


(definition package (attach-debuggee host port (focus?: focus? #f))
  (load-debuggee-units)
  (attach-debuggee-to-controller (connect-remote-reference (or host #u8(127 0 0 1)) port 'debugger purpose: 'debugging) focus?: focus?))


(definition package (attach-debuggee-to-controller debugger-proxy (focus?: focus? #f))
  (attach-to-controller debugger-proxy focus?))


(definition package (ready-debuggee)
  (let ((cookie-arg (command-argument "debugger-cookie")))
    (let ((cookie (and cookie-arg (parse-integer cookie-arg))))
      (when controller-debugger
        (ready-to-controller cookie)))))


(definition package (update-debuggee-arguments)
  (let ((title-arg (command-argument "process-title"))
        (traits-arg (command-argument "process-traits"))
        (icon-arg (command-argument "process-icon")))
    (when title-arg
      (current-process-title-set! title-arg))
    (when traits-arg
      (current-process-traits-set! traits-arg))
    (when icon-arg
      (current-process-icon-set! icon-arg))))


(definition package (update-debuggee-process)
  (when controller-debugger
    (update-process controller-debugger local-process)))


;;;
;;;; Process
;;;


(definition public (process-hash process <Debuggee-Process-Stub>)
  ;; fixme
  0)


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (stop-register stop-info)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (append *stops* (list stop-info))))))


(definition (stop-unregister stop-info)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (remove! stop-info *stops*)))))


(definition package (thread-active-stops thread)
  (let ((queue (new-queue)))
    (with-stops-mutex
      (lambda ()
        (for-each (lambda (stop-info)
                    (bind (stop thread-proxy stop-proxy) stop-info
                      (when (eq? (get-thread stop) thread)
                        (enqueue queue stop-proxy))))
                  *stops*)))
    (queue-list queue)))


(definition public (post-stop exc)
  (continuation-capture
    (lambda (cont)
      (thread-write
        (primordial-thread)
        (lambda ()
          (when (local-debugger?)
            (jazz-handle-exception exc cont)))))))


(definition public (post-continuation cont)
  (let ((exc (new Error message: "Posted continuation")))
    (thread-write
      (primordial-thread)
      (lambda ()
        (jazz-handle-exception exc cont)))))


;;;
;;;; Runtime
;;;


(definition public (transmit-information-unavailable)
  (unavailable-runtime-information controller-debugger local-process))


(definition public (transmit-information filenames processes properties)
  (receive-runtime-information controller-debugger local-process filenames processes properties)
  (let ((process (current-process)))
    (when process
      (let ((local-debugger (get-local-debugger process)))
        (when local-debugger
          (receive-runtime-information local-debugger local-process filenames processes properties))))))


;;;
;;;; Loop
;;;


(class Loop extends Object
  
  
  (slot level accessors generate)
  
  
  (method override (initialize self level)
    (set! self.level level)))


(definition public current-loop
  (make-parameter #f))


(definition public (with-current-loop thunk)
  (let ((current (current-loop)))
    (let ((loop (new Loop (if current (+ (get-level current) 1) 0))))
      (parameterize ((current-loop loop))
        (thunk)))))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  ;; gc protect
  (slot thread-proxy getter generate)
  (slot remote       getter generate)
  (slot pump         getter generate)
  (slot tail         getter generate)
  (slot head         getter generate)
  (slot readtable    accessors generate)
  (slot repl-thread  accessors generate)
  (slot context      accessors generate)
  (slot history      accessors generate)
  
  
  (method override (initialize self thread-proxy remote pump tail head)
    (set! self.thread-proxy thread-proxy)
    (set! self.remote remote)
    (set! self.pump pump)
    (set! self.tail tail)
    (set! self.head head)
    (set! self.readtable #f)
    (set! self.repl-thread #f)
    (set! self.context (unspecified))
    (set! self.history #f)))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition package (thread-console thread (debugger: debugger #f) (readtable: readtable #f) (select?: select? #f))
  (let ((debugger (or debugger controller-debugger)))
    (if (not debugger)
        #f
      (with-consoles-mutex
        (lambda ()
          (or (table-ref *consoles* thread #f)
              (let ((readtable (or readtable (and (current-process) (default-console-readtable (current-process))))))
                (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (require-presence 'debugging) (new Jazz-Debuggee-Thread thread)) debugger readtable select?)))
                  (table-set! *consoles* thread console)
                  console))))))))


(definition package (thread-console-pump-port thread)
  (get-tail (thread-console thread)))

(definition package (thread-console-port thread)
  (get-head (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))

(definition current-console-context
  (make-parameter #f))


(definition (make-debuggee-console thread-proxy debugger readtable select?)
  (let ((readtable-parameters (if readtable (list readtable: readtable) '())))
    (receive (head tail) (open-string-pipe `(permanent-close: #f ,@readtable-parameters))
      (let ((console (register-console debugger local-process thread-proxy select?)))
        (let ((pump (start-debuggee-console-pump debugger console tail)))
          (new Console thread-proxy console pump tail head))))))


(definition package (select-debugger-console)
  (select-console controller-debugger (get-remote (thread-console (current-thread) select?: #t))))


(definition package (persist-debugger-console)
  (persist-console controller-debugger (get-remote (thread-console (current-thread)))))


(definition package (clear-debugger-console)
  (clear-console controller-debugger (get-remote (thread-console (current-thread)))))


(definition package (close-console)
  (close-thread-console (current-thread)))


(definition package (close-thread-console thread)
  (let ((console (thread-console thread)))
    (when console
      (stop-repl-thread console)
      (detach-console thread console)
      (unregister-console controller-debugger (get-remote console)))))


(definition (console-port-getter)
  (if (not controller-debugger)
      (terminal-port)
    (get-head (current-console))))


(definition (detach-consoles)
  (for-each (lambda (pair)
              (bind (thread . console) pair
                (detach-console thread console)))
            (table-keys/values *consoles*)))


(definition (detach-console thread console)
  (with-consoles-mutex
    (lambda ()
      (stop-debuggee-console-pump (get-pump console))
      (close-port (get-tail console))
      (close-port (get-head console))
      (table-clear *consoles* thread))))


(definition (console-clear)
  (if (not controller-debugger)
      (clear-terminal)
    (clear-debugger-console)))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump debugger console port)
  (let ((thread
          (new-system-thread
            (lambda ()
              (start-pump port
                (lambda (str)
                  (when debugger
                    (console-output debugger console str)))))
            'debuggee-pump)))
    (thread-base-priority-set! thread debugging-presence-priority)
    (thread-start! thread)))


(definition (stop-debuggee-console-pump thread)
  (exit-thread thread))


;;;
;;;; Evaluate
;;;


(definition *eval-count*
  0)


(definition public (eval-count)
  (prog1 *eval-count*
    (increase! *eval-count*)))


(definition public (evaluate-in-unit unit-name expr evaluator)
  (define (evaluate-in)
    (wrap-evaluate
      (lambda ()
        (load-unit unit-name)
        (let ((module-declaration (outline-unit unit-name)))
          (parameterize ((requested-unit-name #f)
                         (generate-symbol-for (format "%{a}&" (eval-count)))
                         (generate-symbol-context unit-name))
            (evaluator
              `(module ,unit-name ,(get-dialect-name module-declaration) ,expr)))))))
  
  (let ((console-hook (get-console-evaluate-hook)))
    (if console-hook
        (receive (result hooked?) (console-hook unit-name expr evaluator)
          (if hooked?
              result
            (evaluate-in)))
      (evaluate-in))))


(definition *evaluate-wrap*
  #f)


(definition public (register-evaluate-wrap wrap)
  (set! *evaluate-wrap* wrap))

(definition public (unregister-evaluate-wrap)
  (set! *evaluate-wrap* #f))


(definition public (wrap-evaluate thunk)
  (if *evaluate-wrap*
      (*evaluate-wrap* thunk)
    (thunk)))


(definition *evaluate-hooks*
  '())


(definition public (register-evaluate-hook hook)
  (set! *evaluate-hooks* (append *evaluate-hooks* (list hook))))

(definition public (unregister-evaluate-hook hook)
  (set! *evaluate-hooks* (remove! hook *evaluate-hooks*)))


(definition public (hook-evaluate forms syntax str container line col)
  (for-each (lambda (hook)
              (hook forms syntax str container line col))
            *evaluate-hooks*))


;;;
;;;; Repl
;;;


(definition package current-repl-level
  (make-parameter 0))

(definition package current-repl-frame
  (make-parameter #f))


(definition (with-repl-thread thread reason port level thunk (step?: step? #f))
  (let ((previous-level (current-repl-level)))
    (parameterize ((current-repl-level level))
      (let ((repl-thread (start-repl-thread thread reason port level step?: step?)))
        (let ((console (thread-console thread)))
          (unwind-protect
              (thunk)
            (when console
              (stop-repl-thread console))))))))


(definition public (start-repl-thread thread reason port (level 0) (step?: step? #f))
  (let ((repl-thread
          (new-system-thread
            (lambda ()
              (when (= level 0)
                (display-banner port))
              (when reason
                (format port #"\($\)"#)
                (display reason port)
                (newline port))
              (when (and (> level 0) (not step?))
                (display-prompt port level))
              (read-eval-print-loop thread port level))
            (if (= level 0)
                'debuggee-repl
              (string->symbol (format "repl{a}" level))))))
    (thread-base-priority-set! repl-thread debugging-presence-priority)
    (thread-start! repl-thread)
    ;; robust try
    (let ((console (thread-console thread)))
      (when console
        (set-repl-thread console repl-thread)))
    repl-thread))


(definition package (stop-repl-thread console)
  (let ((repl-thread (get-repl-thread console)))
    (when repl-thread
      (exit-thread repl-thread)
      (set-repl-thread console #f))))


(definition public (start-local-debugger-repl)
  (let ((local-debugger (find-object (get-local-register 'debugging) 'debugger)))
    (when local-debugger
      (thread-start!
        (new-thread
          (lambda ()
            (let ((thread (current-thread)))
              (let ((port (get-head (thread-console thread debugger: local-debugger))))
                (start-repl-thread (primordial-thread) #f port)
                (with-current-loop
                  (lambda ()
                    (process-debuggee-loop (current-process)))))))
          'local-repl)))))


(definition package (display-banner port)
  (let ((title (current-process-title))
        (version (current-process-version)))
    (if (not version)
        (format port #"\(banner {a}{%}{%}\)"# title)
      (format port #"\(banner {a} v{a}{%}{%}\)"# title version)))
  (format port #"\(banner-prompt > \)"#)
  (force-output port))


(definition package (display-prompt port level)
  (define (prompt)
    (if (> level 0)
        (format "{a}> " level)
      "> "))
  
  (format port #"\($\)"#)
  (format port #"\(prompt {a}\)"# (prompt))
  (force-output port))


;;;
;;;; Loop
;;;


(definition (read-eval-print-loop thread port level)
  (define (read-eval-print thread resume port level)
    (define (console-read)
      (parameterize ((walk-for 'eval))
        (let ((console (thread-console thread)))
          (with-readtable (or (and console (get-readtable console)) scheme-readtable)
            (lambda ()
              (catch-exception-filter
                (lambda (exc)
                  #t)
                (lambda (exc)
                  (thread-post thread 'exception
                    (lambda ()
                      (throw exc)))
                  (continuation-return resume #f))
                (lambda ()
                  (read port))))))))
    
    (define (console-eval expr)
      (define (parse-unquote-command expr)
        (if (and (pair? expr)
                 (eq? (car expr) 'unquote)
                 (pair? (cdr expr)))
            (let ((unquoted (cadr expr)))
              (cond ((symbol? unquoted)
                     (values unquoted #f))
                    ((pair? unquoted)
                     (values (car unquoted) (cdr unquoted)))
                    (else
                     (values #f #f))))
          (values #f #f)))
      
      (define (current-frame)
        (let ((frame-box (current-repl-frame)))
          (if frame-box
              (unbox frame-box)
            #f)))
      
      (define (frame-evaluator frame)
        (if frame
            (let ((cont (serial->object (get-continuation frame))))
              (lambda (runner expr)
                (eval-within-no-winding runner expr cont)))
          (lambda (runner expr)
            (runner
              (lambda ()
                (eval expr))))))
      
      (define (eval-in-context context frame evaluator expr)
        (define (local-names variables)
          (map (lambda (var)
                 (string->symbol (second (car var))))
               variables))
        
        (define (local-self variables)
          (find-if (lambda (var)
                     (and (string=? (second (car var)) "self")
                          (let ((serial (cadr var)))
                            (and serial
                                 (let ((object (serial->object serial)))
                                   (and (object? object)
                                        object))))))
                   variables
                   return: 'result))
        
        (parameterize ((walk-for 'eval))
          (let ((local-variables (if frame (get-variables frame :lexical) '())))
            (let ((local-names (local-names local-variables))
                  (local-self (local-self local-variables)))
              (let ((effective-context (or local-self context)))
                (cond ((not effective-context)
                       (parameterize ((generate-symbol-for (format "%{a}&" (eval-count))))
                         (evaluator (lambda (thunk)
                                      (thunk))
                                    expr)))
                      ((symbol? effective-context)
                       (let ((unit-name effective-context))
                         (evaluate-in-unit
                           unit-name
                           `(with-local-variables ,local-names
                              ,expr)
                           (lambda (expr)
                             (evaluator (lambda (thunk)
                                          (parameterize ((current-console-context unit-name))
                                            (thunk)))
                                        expr)))))
                      (else
                       (let ((class-identifier (category-identifier (class-of effective-context))))
                         (receive (unit-name class-name) (break-reference class-identifier)
                           (evaluate-in-unit
                             unit-name
                             `(class ,class-name
                                (with-dynamic-self (jazz.debuggee:current-console-context)
                                  (with-local-variables ,local-names
                                    ,expr)))
                             (lambda (expr)
                               (evaluator (lambda (thunk)
                                            (parameterize ((current-console-context effective-context))
                                              (thunk)))
                                          expr))))))))))))
      
      (let ((console (current-console)))
        (let ((context (console-context console)))
          (receive (cmd arguments) (parse-unquote-command expr)
            (define (context-eval context expr)
              (let ((frame (current-frame)))
                (let ((evaluator (frame-evaluator frame)))
                  (catch (Walk-Problems problems
                           (display-exception problems port)
                           (unspecified))
                    (eval-in-context context frame evaluator expr)))))
            
            (if cmd
                (let ((command (registered-console-command cmd)))
                  (command cmd arguments console console-read console-eval console-print context-eval))
              (context-eval context expr))))))
    
    (define (console-print result)
      (when (and (thread-call-result? result)
                 (specified? result))
        (repl-result-history-add result)
        (let ((values (call-with-values (lambda () result) list)))
          (for-each (lambda (value)
                      (format port "{s}" value)
                      (format port "{%}"))
                    values)))
      (display-prompt port level)
      (force-output port))
    
    (let ((expr (console-read)))
      (if (eof-object? expr)
          (thread-post thread 'resume-loop
            (lambda ()
              (let ((restarts (find-restarts 'resume-loop)))
                (when (> (length restarts) 1)
                  (newline port)
                  ;; skip the current resume-loop restart
                  (let ((restart (second restarts)))
                    (invoke-restart restart))))))
        (let ((result
                (thread-call thread 'console-eval
                  (lambda ()
                    (console-eval expr)))))
          (console-print result)))))
  
  (declare (proper-tail-calls))
  (let (iterate)
    (continuation-capture
      (lambda (resume)
        (read-eval-print thread resume port level)))
    (iterate)))


;;;
;;;; Context
;;;


(definition default-context
  :not-set)

(definition public (get-default-context)
  default-context)

(definition public (set-default-context ctx)
  (set! default-context ctx))


(definition (context-alias context)
  (and (enumerator? context)
       (if (and (eq? context :default)
                (neq? default-context :not-set))
           default-context
         (if (eq? context :scheme)
             #f
           (let ((process (current-process)))
             (cond ((not process)
                    (if (eq? context :default)
                        (new (module-ref 'jazz.profile 'Me))
                      #f))
                   ((eq? context :default)
                    (or (resolve-nickname :profile)
                        (resolve-nickname :process)))
                   ((eq? context :me)
                    (context-alias :profile))
                   (else
                    (resolve-nickname context))))))))


(define (console-context console)
  (define (context-init console)
    (let ((context (get-context console)))
      (if (unspecified? context)
          (let ((new-context
                  (let ((process (current-process)))
                    (context-alias (if process
                                       (or (initial-console-context process)
                                           :default)
                                     :default)))))
            (set-context console new-context)
            new-context)
        context)))
  
  (if (not console)
      #f
    (context-init console)))


;;;
;;;; Commands
;;;


(definition *console-commands*
  (make-table test: eq?))


(definition public (register-console-command cmd proc)
  (table-set! *console-commands* cmd proc))


(definition public (registered-console-command cmd)
  (or (table-ref *console-commands* cmd #f)
      (error "Unknown console command: {s}" cmd)))


(define (in-command cmd arguments console read eval print context-eval)
  (if (or (not arguments) (null? arguments))
      (console-context console)
    (let ((ctx (car arguments)))
      (let ((new-context (or (context-alias ctx) (eval ctx))))
        (when (symbol? new-context)
          (load-unit new-context))
        (if (not-null? (cdr arguments))
            (let ((expr (cadr arguments)))
              (context-eval new-context expr))
          (when console
            (set-context console new-context)
            (set-readtable console (if (not new-context) #f jazz-readtable)))
          new-context)))))


(register-console-command 'in in-command)


(define (scheme-command cmd arguments console read eval print context-eval)
  (let ((expr (car arguments)))
    (context-eval #f expr)))


(register-console-command 'scheme scheme-command)


;;;
;;;; Exception
;;;


(definition public (jazz-exception-debugger exc)
  (declare (proper-tail-calls))
  (let ((cont (get-exception-context exc)))
    (if cont
        (jazz-handle-exception exc cont)
      (continuation-capture
        (lambda (cont)
          (jazz-handle-exception exc cont))))))


(definition public (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition (jazz-handle-exception exc cont)
  (let ((debugger (get-controller-debugger))
        (use (use-debugger?)))
    (if (or (not debugger) (not use))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (lambda ()
          (when (eq? use 'once)
            (use-debugger? #f))
          (let ((reason (exception-reason exc))
                (detail (exception-detail exc)))
            (invoke-debugger 'exception reason detail exc cont)))))))


(definition public (jazz-debugger?)
  (and (eq? (active-exception-debugger) jazz-exception-debugger)
       (boolean controller-debugger)))


(definition public (local-debugger?)
  (and (jazz-debugger?)
       (local-proxy? controller-debugger)))


(definition public (without-local-debugger thunk)
  (if (local-debugger?)
      (with-system-exception-debugger
        thunk)
    (thunk)))


(definition public (using-debugger?)
  (boolean (command-argument "debugger")))


(definition protected (break-internal (reason: reason #f) (detail: detail #f) (exception: exception #f))
  (declare (proper-tail-calls))
  (continuation-capture
    (lambda (continuation)
      (invoke-debugger 'break reason detail exception continuation))))


(definition protected (start-repl-internal (reason: reason #f) (readtable: readtable #f) (select?: select? #t))
  (declare (proper-tail-calls))
  (continuation-capture
    (lambda (continuation)
      (when readtable
        (thread-console (current-thread) readtable: readtable select?: select?))
      (when select?
        (select-debugger-console))
      (invoke-repl reason #f continuation))))


(definition protected (start-jazz-repl-internal (select?: select? #t))
  (start-repl-internal select?: select?))


;;;
;;;; Stepper
;;;


;; quick hack to mitigate the problem of stepping
;; into large macro expanded code that does not
;; correspond well with the original source code
(definition last-step-cmd
  #f)
(definition last-step-locat
  #f)


(definition public (install-stepper (step-level 5))
  (declare (proper-tail-calls))
  (install-step-handler step-level
    (lambda (locat executer)
      (if (and last-step-cmd (equal? locat last-step-locat))
          (executer last-step-cmd)
        (set! last-step-locat locat)
        (continuation-capture
          (lambda (cont)
            (invoke-debugger 'break #f #f #f cont
              locat: locat
              stepper: (lambda (cmd)
                         (set! last-step-cmd cmd)
                         (continuation-graft cont
                           (lambda ()
                             (executer cmd)))))))))))


;;;
;;;; Inspect
;;;


(definition protected (inspect-internal object (kind: kind :value))
  (let ((info (package-info object kind: kind)))
    (inspect-object controller-debugger local-process info)))


;;;
;;;; Advice
;;;


(definition *advices*
  (make-table test: eq?))


(definition public (get-advices)
  *advices*)


;; a.b.c:d/e
;; (a.b.c d e)
;; :site
(definition protected (advise-internal what proc)
  (define (advise-all)
    (iterate-table (get-modules-table)
      (lambda (module-name module)
        (advise-module module))))
  
  (define (advise-site enumerator)
    (let ((name (enumerator->symbol enumerator))
          (locator enumerator))
      (call-proc name
                 locator
                 (lambda ()
                   (call-site-ref name))
                 (lambda (value)
                   (call-site-set! name value)))))
  
  (define (advise-symbol symbol)
    (receive (module-name name) (break-reference symbol)
      (advise-path (cons module-name (if (not name) '() (split-symbol name #\/))))))
  
  (define (advise-path path)
    (bind (module-name . rest) path
      (if (ends-with? (symbol->string module-name) ".*")
          (assert (null? rest)
            (let ((name (symbol->string module-name)))
              (let ((prefix (substring name 0 (- (cardinality name) 2))))
                (advise-prefixed prefix))))
        (let ((module (require-module module-name)))
          (if (null? rest)
              (advise-module module)
            (bind (name . rest) rest
              (let ((entry (table-ref (get-entries module) name)))
                (if (null? rest)
                    (advise-entry entry)
                  (assert (category? entry)
                    (advise-class-field entry (category-field entry (car rest))))))))))))
  
  (define (advise-module module)
    (iterate-table (get-entries module)
      (lambda (name entry)
        (advise-entry entry))))
  
  (define (advise-prefixed prefix)
    (iterate-table (get-modules-table)
      (lambda (module-name module)
        (when (starts-with? (symbol->string module-name) prefix)
          (advise-module module)))))
  
  (define (advise-entry entry)
    (typecase entry
      ((Field)
       (advise-field entry))
      ((Class)
       (advise-class entry))))

  (define (advise-field field)
    (let ((locator (field-locator field)))
      (call-proc field
                 locator
                 (lambda () (field-ref field))
                 (lambda (value) (field-set! field value)))))
  
  (define (advise-class class)
    (iterate-table (get-fields class)
      (lambda (name field)
        (advise-class-field class field)))
    (iterate-class-overrides class
      (lambda (method)
        (advise-method class method))))
  
  (define (advise-class-field class field)
    (typecase field
      ((Slot))
      ((Method)
       (advise-method class field))
      ((Field)
       (advise-field field))))
  
  (define (advise-method class method)
    (let ((name (get-name method)))
      (let ((locator (compose-reference (get-name class) name)))
        (call-proc method
                   locator
                   (lambda () (find-dispatch class name))
                   (lambda (value) (update-method class name value))))))
  
  (define (call-proc field locator ref set)
    (define (original)
      (or (table-ref *advices* locator #f)
          (ref)))
    
    (proc field
          locator
          original
          (lambda (value)
            (let ((original (original)))
              (let ((value (or value original)))
                (if (eq? value original)
                    (table-clear *advices* locator)
                  (table-set! *advices* locator original))
                (set value))))))
  
  (cond @wait-recursive-problems
        ((not what)
         (advise-all))
        ((enumerator? what)
         (advise-site what))
        ((symbol? what)
         (advise-symbol what))
        ((null/pair? what)
         (advise-path what))
        ((class? what)
         (advise-class what))
        (else
         (error "Unknown advise: {s}" what))))


(definition protected (unadvise-internal what)
  (advise what
          (lambda (field locator original set)
            (set #f))))


;; for the debugger
(let ((original-procedure-name procedure-name))
  (procedure-name-set!
    (lambda (procedure)
      (or (original-procedure-name procedure)
          (continuation-capture
            (lambda (return)
              (iterate-table *advices*
                (lambda (locator proc)
                  (when (eq? proc procedure)
                    (continuation-return return locator))))
              #f))))))


;;;
;;;; Debug
;;;


(definition protected (debug-advice-internal field locator original set)
  (debug locator))


;;;
;;;; Count
;;;


(definition counts
  (make-table test: eq?))

(definition public (get-counts)
  counts)


(definition public (count-advice-internal field locator original set)
  (let ((original (original)))
    (when (procedure? original)
      (set (lambda rest
             (table-set! counts locator (+ (table-ref counts locator 0) 1))
             (apply original rest))))))


;;;
;;;; Time
;;;


(definition public (time-advice-internal field locator original set)
  (let ((original (original)))
    (when (procedure? original)
      (set (lambda rest
             (time (apply original rest)))))))


;;;
;;;; Trace
;;;


(define trace-depth
  (make-parameter 0))

(define default-present-reference
  present-reference)


(definition protected (trace-advice-internal (file: file #f) (port: port #f) (present-reference: present-reference #f) (present-context: present-context #f))
  (let ((port (or port :console))
        (present-reference (or present-reference default-present-reference)))
    (lambda (field locator original set)
      (let ((original (original)))
        (when (procedure? original)
          (set (lambda rest
                 (define (apply-original port)
                   (let ((column (* (trace-depth) 2)))
                     (format port "{$}{_ :v}[({a}{?: {l}~}){a}" column (present-reference locator) (not-null? rest) rest (if present-context (present-context) ""))
                     (let ((result (parameterize ((trace-depth (+ (trace-depth) 1)))
                                     (apply original rest))))
                       (format port "{$}{_ :v}  <= {s}]" column result)
                       result)))
                 
                 (if file
                     (call-with-output-file (list path: (parse file) eol-encoding: (platform-eol-encoding kernel-platform) append: #t)
                       (lambda (port)
                         (apply-original port)))
                   (apply-original port)))))))))


(definition protected (trace-internal what . rest)
  (advise what (apply trace-advice-internal rest)))


(definition protected (untrace-internal what)
  (unadvise what))


;;;
;;;; Debugger
;;;


(definition (invoke-repl reason detail continuation)
  (let ((thread (current-thread))
        (port (current-console-port))
        (level (if (not (current-loop)) 0 (+ (current-repl-level) 1))))
    (with-repl-thread thread reason port level
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (with-current-loop
            (lambda ()
              (let ((process (current-process)))
                (if (not process)
                    (debuggee-loop)
                  (process-debuggee-loop process))))))))))


(definition public (invoke-debugger kind reason detail exc continuation (locat: locat #f) (stepper: stepper #f))
  (define (invoke-releases)
    (for-each (lambda (proc)
                (proc))
              (get-debugger-releases)))
  
  (define (compute-restarts thread)
    (map (lambda (restart)
           (new Debuggee-Restart-Local-Proxy (require-presence 'debugging) (new Jazz-Debuggee-Restart thread restart)))
         (current-restarts)))
  
  (invoke-releases)
  (let ((thread (current-thread))
        (port (current-console-port))
        (level (current-repl-level)))
    (with-repl-thread thread reason port (+ level 1)
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (let ((stop (new Jazz-Debuggee-Stop thread kind reason detail exc continuation (compute-restarts thread) locat stepper)))
            (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (require-presence 'debugging) (new Jazz-Debuggee-Thread thread)))
                  (stop-proxy (new Debuggee-Stop-Local-Proxy (require-presence 'debugging) stop)))
              (let ((stop-info (list stop thread-proxy stop-proxy)))
                (dynamic-wind
                  (lambda ()
                    (stop-register stop-info)
                    (register-stop controller-debugger local-process thread-proxy stop-proxy step?: (boolean stepper))
                    (hook-debuggee thread (+ level 1)))
                  (lambda ()
                    (with-current-loop
                      (lambda ()
                        (let ((process (current-process)))
                          (if (not process)
                              (debuggee-loop)
                            (process-debuggee-loop process))))))
                  (lambda ()
                    (stop-unregister stop-info)
                    (when controller-debugger
                      (unregister-stop controller-debugger local-process thread-proxy stop-proxy))
                    (hook-debuggee thread level))))))))
      step?: (boolean stepper))))


(definition package (debuggee-loop)
  (declare (proper-tail-calls))
  (let (restart-loop)
    (with-restart-catcher 'resume-loop (present-current-loop-restart)
      (lambda ()
        (let (loop)
          (with-jazz-exception-debugger
            (lambda ()
              (thread-process)))
          (loop))))
    (restart-loop)))


(definition package (present-current-loop-restart)
  (let ((loop (current-loop)))
    (and loop
         (let ((level (get-level loop)))
           (format "Resume loop{a}"
                   (if (= level 0)
                       ""
                     (format " {a}" level)))))))


;;;
;;;; Debuggee
;;;


(definition *debuggee-hooks*
  '())


(definition public (register-debuggee-hook hook)
  (set! *debuggee-hooks* (append *debuggee-hooks* (list hook))))

(definition public (unregister-debuggee-hook hook)
  (set! *debuggee-hooks* (remove! hook *debuggee-hooks*)))


(definition public (hook-debuggee thread level)
  (for-each (lambda (hook)
              (hook thread level))
            *debuggee-hooks*))



;;;
;;;; Releases
;;;


(definition *debugger-releases*
  (new-queue))

(definition public (get-debugger-releases)
  (queue-list *debugger-releases*))

(definition public (add-debugger-release name proc)
  (enqueue *debugger-releases* proc))


(add-debugger-release 'enable-interrupts
  enable-interrupts!)


(add-debugger-release 'load-mutex
  ;; this is a temporary solution to threads keeping the load-mutex locked
  ;; see the todo file for details on what needs to be done for a clean solution
  (lambda ()
    (let ((load-mutex (get-load-mutex)))
      ;; limit the scope of the patch by a heuristic that could turn out
      ;; to be wrong if a loading thread depends on a thread that errors
      ;; but this is very far fetched and will do until a clean solution
      (when (eq? (mutex-state load-mutex) (current-thread))
        (mutex-unlock! load-mutex)))))


(add-debugger-release 'catalog-entries
  release-catalog-entries)


;;;
;;;; Hidden
;;;


(let ((previous hidden-frame?)
      (hidden
        (list
          with-callback
          with-exception-debugger
          with-system-exception-debugger
          catch-exception-filter
          continuation-capture)))
  (hidden-frame?-set!
    (lambda (frame)
      (or (previous frame)
          (eq? frame (get-exception-debugger))
          (eq? frame (get-exception-hook))
          (memq? frame hidden))))))
