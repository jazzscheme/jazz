;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.stub)
        (jazz.jrm)
        (jazz.jrm.register.stub)
        (jazz.network))


;;;
;;;; Local
;;;


(definition local-process
  {})


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (new Debuggee-Process)))))


;;;
;;;; Controller
;;;


(definition controller-debugger
  {})


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller controller-register select?)
  (detach-from-controller)
  (set! controller-debugger (require-object~ controller-register 'debugger))
  (setup-local-process)
  (set-console-port-getter console-port-getter)
  (attach-process~ controller-debugger local-process select?)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    (set! local-process {})))


(definition public (detach-from-debugger)
  (when controller-debugger
    (when (live?~ controller-debugger)
      (detach-process~ controller-debugger local-process))
    (set! controller-debugger {})
    (detach-consoles)))


(definition (setup-debuggee)
  (let ((arg (command-argument "debugger"))
        (interactive-arg (command-argument "interactive")))
    (when arg
      (receive (host port) (parse-host/service arg)
        (if (not port)
            (error "Ill-formed debugger argument: {a}" arg)
          (start-remote-listener)
          (attach-to-controller (new-remote-register (either host #u8(127 0 0 1)) port) (parse-boolean interactive-arg)))))))


(definition (update-debuggee-process)
  (when controller-debugger
    (update-process~ controller-debugger local-process)))


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (function (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (append *stops* (list stop))))))


(definition (unregister-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (remove! stop *stops*)))))


(definition package (get-thread-stops thread)
  (let ((queue (new-queue)))
    (for-each (function (stop)
                (when (eq? (get-thread~ stop) thread)
                  (enqueue queue (new Debuggee-Stop-Local-Proxy stop))))
              *stops*)
    (queue-list queue)))


;;;
;;;; Loop
;;;


(class Loop extends Object
  
  
  (slot level accessors generate)
  
  
  (method (initialize level)
    (set! level~self level)))


(definition public current-loop
  (make-parameter {}))


(definition public (with-current-loop thunk)
  (let ((current (current-loop)))
    (let ((loop (new Loop (if current (+ (get-level~ current) 1) 0))))
      (parameterize ((current-loop loop))
        (thunk)))))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  (slot remote    getter generate)
  (slot pump      getter generate)
  (slot tail      getter generate)
  (slot head      getter generate)
  (slot readtable accessors generate)
  (slot context   accessors generate)
  (slot history   accessors generate)
  
  
  (method (initialize remote pump tail head)
    (set! remote~self remote)
    (set! pump~self pump)
    (set! tail~self tail)
    (set! head~self head)
    (set! readtable~self {})
    (set! context~self (unspecified))
    (set! history~self {})))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (function (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition (thread-console thread (select? #f))
  (if (not controller-debugger)
      {}
    (with-consoles-mutex
      (function ()
        (either (table-ref *consoles* thread #f)
                (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)) select?)))
                  (table-set! *consoles* thread console)
                  console))))))


(definition package (thread-console-pump-port thread)
  (get-tail~ (thread-console thread)))

(definition package (thread-console-port thread)
  (get-head~ (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))

(definition (current-console-context)
  (get-context~ (current-console)))


(definition (make-debuggee-console thread-proxy select?)
  (receive (head tail) (open-string-pipe (list permanent-close: #f readtable: jazz-readtable))
    (let ((console (register-console~ controller-debugger local-process thread-proxy select?)))
      (let ((pump (start-debuggee-console-pump console tail)))
        (new Console console pump tail head)))))


(definition (select-console)
  (select-console~ controller-debugger (get-remote~ (thread-console (current-thread) #t))))


(definition (console-port-getter)
  (if (not controller-debugger)
      (terminal-port)
    (get-head~ (current-console))))


(definition (detach-consoles)
  (define (detach-console thread console)
    (stop-debuggee-console-pump (get-pump~ console))
    (close-port (get-tail~ console))
    (close-port (get-head~ console))
    (table-clear *consoles* thread))
  
  (with-consoles-mutex
    (function ()
      (for-each (function (pair)
                  (bind (thread . console) pair
                    (detach-console thread console)))
                (table-keys/values *consoles*)))))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump console port)
  (thread-start!
    (new-system-thread
      (function ()
        (start-pump (new Permanent-Port port)
          (function (str)
            (when controller-debugger
              (console-output~ controller-debugger console str)))))
      'debuggee-console-pump)))


(definition (stop-debuggee-console-pump thread)
  (thread-interrupt! thread
    thread-exit))


;;;
;;;; Repl
;;;


(definition default-context
  :not-set)

(definition (set-default-context ctx)
  (set! default-context ctx))


(definition package current-repl-level
  (make-parameter 0))

(definition package current-repl-frame
  (make-parameter {}))


(definition (with-repl-thread thread reason port level thunk)
  (parameterize ((current-repl-level level))
    (let ((thread (start-repl-thread thread reason port level)))
      (unwind-protect
          (thunk)
        (thread-interrupt! thread
          thread-exit)))))


(definition public (start-repl-thread thread reason port (level 0))
  (thread-start!
    (new-system-thread
      (function ()
        (when (= level 0)
          (display-banner port))
        (when reason
          (display reason port))
        (when (> level 0)
          (display-prompt port level))
        (read-eval-print-loop thread port level))
      (if (= level 0)
          'repl
        (string->symbol (format "repl{a}" level))))))


(definition package (display-banner port)
  (let ((title (current-process-title))
        (version (current-process-version)))
    (if (not version)
        (format port #"\(banner {a}{%}{%}> \)"# title)
      (format port #"\(banner {a} v{a}{%}{%}> \)"# title version)))
  (force-output port))


(definition package (display-prompt port level)
  (when (> level 0)
    (format port "{a}" level))
  (format port "> ")
  (force-output port))


(definition (read-eval-print-loop thread port level)
  (declare (proper-tail-calls))
  (let (iterate)
    (read-eval-print thread port level)
    (iterate)))


(definition (read-eval-print thread port level)
  (let ((console (thread-console thread)))
    (let ((expr (with-readtable (either (essay console (get-readtable~ console)) scheme-readtable)
                  (function ()
                    (read port)))))
      (if (eof-object? expr)
          (thread-post thread 'resume-loop
            (function ()
              (let ((restarts (find-restarts 'resume-loop)))
                (when (> (length restarts) 1)
                  (newline port)
                  ;; skip the current resume-loop restart
                  (let ((restart (second restarts)))
                    (invoke-restart restart))))))
        (let ((result
                (thread-call thread 'evaluate
                  (function ()
                    (evaluate expr)))))
          (when (and (thread-call-result? result)
                     (specified? result))
            (repl-result-history-add result)
            (let ((values (call-with-values (function () result) list)))
              (for-each (function (value)
                          (format port "{s}" value)
                          (format port "{%}"))
                        values)))
          (display-prompt port level)
          (force-output port))))))


(definition (evaluate expr)
  (define (context-init console)
    (let ((context (get-context~ console)))
      (if (unspecified? context)
          (let ((new-context
                  (let ((process (get-process)))
                    (context-alias (if process
                                       (initial-console-context~ process)
                                     :default)))))
            (set-context~ console new-context)
            new-context)
        context)))
  
  (define (context-alias context)
    (when (enumerator? context)
      (if (and (eq? context :default)
               (neq? default-context :not-set))
          default-context
        (let ((process (get-process)))
          (if (not process)
              (if (and (eq? context :default)
                       (module-loaded? 'jazz))
                  'jazz
                {})
            (if (eq? context :default)
                (either (process-alias~ process :profile)
                        (process-alias~ process :process))
              (process-alias~ process context)))))))
  
  (define (parse-unquote-command expr)
    (if (and (pair? expr)
             (eq? (car expr) 'unquote)
             (pair? (cdr expr)))
        (let ((unquoted (cadr expr)))
          (cond ((symbol? unquoted)
                 (values unquoted '()))
                ((pair? unquoted)
                 (values (car unquoted) (cdr unquoted)))
                (else
                 (values {} {}))))
      (values {} {})))
  
  (let ((console (current-console)))
    (let ((context (if (not console) {} (context-init console)))
          (frame-box (current-repl-frame)))
      (receive (command arguments) (parse-unquote-command expr)
        (cond ((eq? command 'in)
               (if (null? arguments)
                   context
                 (let ((ctx (car arguments)))
                   (let ((new-context (either (context-alias ctx) (evaluate ctx))))
                     (when (symbol? new-context)
                       (load-module new-context))
                     (when console
                       (set-context~ console new-context)
                       (set-readtable~ console (if (not new-context) {} jazz-readtable)))
                     new-context))))
              (#f @convert frame-box
               (evaluate-in-frame (unbox frame-box) expr))
              (else
               (evaluate-in-context context expr)))))))


(definition (evaluate-in-frame frame expr)
  (let ((frame (unbox box)))
    (if (not frame)
        (eval expr)
      (let ((cont (serial->object (get-continuation~ frame))))
        (eval-within-no-winding expr cont)))))


(definition (evaluate-in-context context expr)
  (parameterize ((walk-for 'eval))
    (cond ((not context)
           (eval expr))
          ((symbol? context)
           (let ((module-name context))
             (load-module module-name)
             (outline-module module-name)
             (eval
               `(library ,module-name jazz
                ,expr))))
          (else
           (let ((class-identifier (type-name (class-of context))))
             (let ((module-name (identifier-module class-identifier))
                   (class-name (identifier-name class-identifier)))
               (load-module module-name)
               (outline-module module-name)
               (eval
                 `(library ,module-name jazz
                  (class ,class-name
                    (with-dynamic-self (jazz.debuggee.current-console-context)
                      ,expr))))))))))


;;;
;;;; Exception
;;;


(definition (jazz-exception-debugger exc)
  (let ((debugger (get-controller-debugger)))
    (if (or (not debugger) (not (use-debugger?)))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (function ()
          (continuation-capture
            (function (continuation)
              (let ((reason (exception-reason exc))
                    (detail (exception-detail exc)))
                (invoke-debugger 'exception reason detail continuation)))))))))


(definition package (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition public (break (reason: reason {}))
  (continuation-capture
    (function (continuation)
      (invoke-debugger 'break reason {} continuation))))


(definition public (start-repl (reason: reason {}) (select?: select? #t))
  (continuation-capture
    (function (continuation)
      (when select?
        (select-console))
      (invoke-repl reason {} continuation))))


;;;
;;;; Debugger
;;;


(definition (invoke-repl reason detail continuation)
  (let ((thread (current-thread))
        (port (get-console-port))
        (level (if (not (current-loop)) 0 (+ (current-repl-level) 1))))
    (with-repl-thread thread reason port level
      (function ()
        (parameterize ((current-repl-frame (box {})))
          (with-current-loop
            (function ()
              (let ((process (get-process)))
                (if (not process)
                    (debuggee-loop)
                  (process-debuggee-loop~ process))))))))))


(definition (invoke-debugger kind reason detail continuation)
  (release-load-mutex!)
  (let* ((thread (current-thread))
         (port (get-console-port))
         (level (+ (current-repl-level) 1))
         (restarts (compute-restarts thread))
         (stop (new Debuggee-Stop thread kind reason detail continuation restarts)))
    (dynamic-wind
      (function ()
        (register-stop stop))
      (function ()
        (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))
              (stop-proxy (new Debuggee-Stop-Local-Proxy stop)))
          (with-repl-thread thread reason port level
            (function ()
              (parameterize ((current-repl-frame (box {})))
                (debuggee-stop~ controller-debugger local-process thread-proxy stop-proxy kind reason)
                (with-current-loop
                  (function ()
                    (let ((process (get-process)))
                      (if (not process)
                          (debuggee-loop)
                        (process-debuggee-loop~ process))))))))))
      (function ()
        (unregister-stop stop)))))


;; this is a temporary solution to threads keeping the load-mutex locked
;; see the todo file for details on what needs to be done for a clean solution
(definition (release-load-mutex!)
  (let ((load-mutex (get-load-mutex)))
    ;; limit the scope of the patch by a heuristic that could turn out
    ;; to be wrong if a loading thread depends on a thread that errors
    ;; but this is very far fetched and will do until a clean solution
    (when (eq? (mutex-owner load-mutex) (current-thread))
      (mutex-unlock! load-mutex))))


(definition (compute-restarts thread)
  (map (function (restart)
         (new Debuggee-Restart-Local-Proxy (new Debuggee-Restart thread restart)))
       (current-restarts)))


(definition (debuggee-loop)
  (let (loop)
    (with-restart-catcher 'resume-loop (present-loop-restart) {}
      (function ()
        (let ((thunk (thread-read)))
          (with-jazz-exception-debugger
            thunk))))
    (loop)))


(definition (present-loop-restart)
  (let ((loop (current-loop)))
    (when loop
      (let ((level (get-level~ loop)))
        (format "Resume loop{a}"
                (if (= level 0)
                    ""
                  (format " {a}" level)))))))


;;;
;;;; View
;;;


(definition *current-view-debugger*
  #f)


(definition public (current-view-debugger)
  (when (not *current-view-debugger*)
    (set! *current-view-debugger* (new View-Debugger)))
  *current-view-debugger*))
