;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.stub)
        (jazz.editor.jazz.inspector)
        (jazz.jrm)
        (jazz.network)
        (jazz.profile)
        (jazz.system.access))


;;;
;;;; Local
;;;


(definition local-process
  #f)


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (new Debuggee-Process)))))


;;;
;;;; Controller
;;;


(definition controller-debugger
  #f)

(definition controller-debugger-cookie
  #f)


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller controller-register focus?)
  (detach-from-controller)
  (set! controller-debugger (require-object~ controller-register 'debugger))
  (setup-local-process)
  (set-console-port-getter console-port-getter)
  (attach-process~ controller-debugger local-process focus?)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook)
  (add-exit-job! detach-from-controller))


(definition public (ready-to-controller debugger-cookie)
  (set! controller-debugger-cookie debugger-cookie)
  (ready-process~ controller-debugger local-process debugger-cookie))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    (set! local-process #f)))


(definition public (detach-from-debugger)
  (when controller-debugger
    (when (live?~ controller-debugger)
      (detach-process~ controller-debugger local-process))
    (set! controller-debugger #f)
    (detach-consoles)))


(definition package (setup-debuggee (debugger: debugger #f))
  (let ((debugger-arg (or debugger (command-argument "debugger")))
        (interactive-arg (command-argument "debugger-interactive")))
    (when debugger-arg
      (receive (host port) (parse-host/service debugger-arg)
        (if (not port)
            (error "Ill-formed debugger argument: {a}" debugger-arg)
          (load-debuggee-units)
          (start-remote-listener)
          (attach-to-controller (new-remote-register (or host #u8(127 0 0 1)) port) (parse-boolean interactive-arg))
          (current-input-port (console-input-port))
          (current-output-port (console-output-port)))))))


(definition package (ready-debuggee)
  (let ((cookie-arg (command-argument "debugger-cookie")))
    (when cookie-arg
      (ready-to-controller (parse-integer cookie-arg)))))


(definition package (update-debuggee-arguments)
  (let ((title-arg (command-argument "process-title"))
        (icon-arg (command-argument "process-icon")))
    (when title-arg
      (current-process-title-set! title-arg))
    (when icon-arg
      (current-process-icon-set! icon-arg))))


(definition package (update-debuggee-process)
  (when controller-debugger
    (update-process~ controller-debugger local-process)))


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-stop stop)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (append *stops* (list stop))))))


(definition (unregister-stop stop)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (remove! stop *stops*)))))


(definition package (get-thread-stops thread)
  (let ((queue (new-queue)))
    (with-stops-mutex
      (lambda ()
        (for-each (lambda (stop)
                    (when (eq? (get-thread~ stop) thread)
                      (enqueue queue (new Debuggee-Stop-Local-Proxy stop))))
                  *stops*)))
    (queue-list queue)))


(definition public (post-stop exc)
  (continuation-capture
    (lambda (continuation)
      (let ((reason (exception-reason exc))
            (detail (exception-detail exc)))
        (thread-write
          (current-thread)
          (lambda ()
            (invoke-debugger 'exception reason detail exc continuation)))))))


;;;
;;;; Loop
;;;


(class Loop extends Object
  
  
  (slot level accessors generate)
  
  
  (method override (initialize level)
    (set! level~self level)))


(definition public current-loop
  (make-parameter #f))


(definition public (with-current-loop thunk)
  (let ((current (current-loop)))
    (let ((loop (new Loop (if current (+ (get-level~ current) 1) 0))))
      (parameterize ((current-loop loop))
        (thunk)))))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  (slot remote    getter generate)
  (slot pump      getter generate)
  (slot tail      getter generate)
  (slot head      getter generate)
  (slot readtable accessors generate)
  (slot context   accessors generate)
  (slot history   accessors generate)
  
  
  (method override (initialize remote pump tail head)
    (set! remote~self remote)
    (set! pump~self pump)
    (set! tail~self tail)
    (set! head~self head)
    (set! readtable~self #f)
    (set! context~self (unspecified))
    (set! history~self #f)))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition (thread-console thread (select? #f))
  (if (not controller-debugger)
      #f
    (with-consoles-mutex
      (lambda ()
        (or (table-ref *consoles* thread #f)
            (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)) select?)))
              (table-set! *consoles* thread console)
              console))))))


(definition package (thread-console-pump-port thread)
  (get-tail~ (thread-console thread)))

(definition package (thread-console-port thread)
  (get-head~ (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))

(definition current-console-context
  (make-parameter #f))


(definition (make-debuggee-console thread-proxy select?)
  (receive (head tail) (open-string-pipe (list permanent-close: #f readtable: jazz-readtable))
    (let ((console (register-console~ controller-debugger local-process thread-proxy select?)))
      (let ((pump (start-debuggee-console-pump console tail)))
        (new Console console pump tail head)))))


(definition package (select-console)
  (select-console~ controller-debugger (get-remote~ (thread-console (current-thread) #t))))


(definition (console-port-getter)
  (if (not controller-debugger)
      (terminal-port)
    (get-head~ (current-console))))


(definition (detach-consoles)
  (define (detach-console thread console)
    (stop-debuggee-console-pump (get-pump~ console))
    (close-port (get-tail~ console))
    (close-port (get-head~ console))
    (table-clear *consoles* thread))
  
  (with-consoles-mutex
    (lambda ()
      (for-each (lambda (pair)
                  (bind (thread . console) pair
                    (detach-console thread console)))
                (table-keys/values *consoles*)))))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump console port)
  (thread-start!
    (new-system-thread
      (lambda ()
        (start-pump port
          (lambda (str)
            (when controller-debugger
              (console-output~ controller-debugger console str)))))
      'debuggee-console-pump)))


(definition (stop-debuggee-console-pump thread)
  (thread-interrupt! thread
    thread-exit))


;;;
;;;; Repl
;;;


(definition default-context
  :not-set)

(definition public (get-default-context)
  default-context)

(definition public (set-default-context ctx)
  (set! default-context ctx))


(definition package current-repl-level
  (make-parameter 0))

(definition package current-repl-frame
  (make-parameter #f))


(definition (with-repl-thread thread reason port level thunk (step?: step? #f))
  (parameterize ((current-repl-level level))
    (let ((thread (start-repl-thread thread reason port level step?: step?)))
      (unwind-protect
          (thunk)
        (thread-interrupt! thread
          thread-exit)))))


(definition public (start-repl-thread thread reason port (level 0) (step?: step? #f))
  (thread-start!
    (new-system-thread
      (lambda ()
        (when (= level 0)
          (display-banner port))
        (when reason
          (format port #"\($\)"#)
          (display reason port)
          (newline port))
        (when (and (> level 0) (not step?))
          (display-prompt port level))
        (read-eval-print-loop thread port level))
      (if (= level 0)
          'repl
        (string->symbol (format "repl{a}" level))))))


(definition package (display-banner port)
  (let ((title (current-process-title))
        (version (current-process-version)))
    (if (not version)
        (format port #"\(banner {a}{%}{%}\)"# title)
      (format port #"\(banner {a} v{a}{%}{%}\)"# title version)))
  (format port #"\(banner-prompt > \)"#)
  (force-output port))


(definition package (display-prompt port level)
  (define (prompt)
    (if (> level 0)
        (format "{a}> " level)
      "> "))
  
  (format port #"\($\)"#)
  (format port #"\(prompt {a}\)"# (prompt))
  (force-output port))


(definition *eval-count*
  0)


(definition public (eval-count)
  (prog1 *eval-count*
    (increase! *eval-count*)))


(definition (read-eval-print-loop thread port level)
  (define (read-eval-print thread resume port level)
    (let ((console (thread-console thread)))
      (let ((expr (parameterize ((walk-for 'eval))
                    (with-readtable (or (and console (get-readtable~ console)) scheme-readtable)
                      (lambda ()
                        (with-exception-filter
                          (lambda (exc)
                            #t)
                          (lambda (exc)
                            (thread-post thread 'exception
                              (lambda ()
                                (throw exc)))
                            (continuation-return resume #f))
                          (lambda ()
                            (read port))))))))
        (if (eof-object? expr)
            (thread-post thread 'resume-loop
              (lambda ()
                (let ((restarts (find-restarts 'resume-loop)))
                  (when (> (length restarts) 1)
                    (newline port)
                    ;; skip the current resume-loop restart
                    (let ((restart (second restarts)))
                      (invoke-restart restart))))))
          (let ((result
                  (thread-call thread 'evaluate
                    (lambda ()
                      (evaluate expr)))))
            (when (and (thread-call-result? result)
                       (specified? result))
              (repl-result-history-add result)
              (let ((values (call-with-values (lambda () result) list)))
                (for-each (lambda (value)
                            (format port "{s}" value)
                            (format port "{%}"))
                          values)))
            (display-prompt port level)
            (force-output port))))))
  
  (define (evaluate expr)
    (define (context-init console)
      (let ((context (get-context~ console)))
        (if (unspecified? context)
            (let ((new-context
                    (let ((process (get-process)))
                      (context-alias (if process
                                         (initial-console-context~ process)
                                       :default)))))
              (set-context~ console new-context)
              new-context)
          context)))
    
    (define (context-alias context)
      (when (enumerator? context)
        (if (and (eq? context :default)
                 (neq? default-context :not-set))
            default-context
          (let ((process (get-process)))
            (cond ((not process)
                   (if (eq? context :default)
                       (new Me)
                     #f))
                  ((eq? context :default)
                   (or (process-alias~ process :profile)
                       (process-alias~ process :process)))
                  ((eq? context :me)
                   (context-alias :profile))
                  (else
                   (process-alias~ process context)))))))
    
    (define (parse-unquote-command expr)
      (if (and (pair? expr)
               (eq? (car expr) 'unquote)
               (pair? (cdr expr)))
          (let ((unquoted (cadr expr)))
            (cond ((symbol? unquoted)
                   (values unquoted '()))
                  ((pair? unquoted)
                   (values (car unquoted) (cdr unquoted)))
                  (else
                   (values #f #f))))
        (values #f #f)))
    
    (define (current-frame)
      (let ((frame-box (current-repl-frame)))
        (if frame-box
            (unbox frame-box)
          #f)))
    
    (define (frame-evaluator frame)
      (if frame
          (let ((cont (serial->object (get-continuation~ frame))))
            (lambda (runner expr)
              (eval-within-no-winding runner expr cont)))
        (lambda (runner expr)
          (runner
            (lambda ()
              (eval expr))))))
    
    (let ((console (current-console)))
      (let ((context (if (not console) #f (context-init console))))
        (receive (command arguments) (parse-unquote-command expr)
          (if (eq? command 'in)
              (if (null? arguments)
                  context
                (let ((ctx (car arguments)))
                  (let ((new-context (or (context-alias ctx) (evaluate ctx))))
                    (when (symbol? new-context)
                      (load-unit new-context))
                    (when console
                      (set-context~ console new-context)
                      (set-readtable~ console (if (not new-context) #f jazz-readtable)))
                    new-context)))
            (let ((frame (current-frame)))
              (let ((evaluator (frame-evaluator frame)))
                (evaluate-in-context context frame evaluator expr))))))))
  
  (define (evaluate-in-context context frame evaluator expr)
    (define (local-names variables)
      (map (lambda (var)
             (string->symbol (car var)))
           variables))
    
    (define (local-self variables)
      (find-object (lambda (var)
                     (when (string=? (car var) "self")
                       (let ((serial (cadr var)))
                         (when serial
                           (let ((object (serial->object serial)))
                             (when (object? object)
                               object))))))
                   variables))
    
    @debugging
    (let ((ev evaluator))
      (set! evaluator
            (lambda (runner expr)
              (pp (current-console-context))
              (pp expr)
              (ev runner expr))))
    
    (parameterize ((walk-for 'eval))
      (let ((local-variables (if frame (get-variables~ frame :lexical) '())))
        (let ((local-names (local-names local-variables))
              (local-self (local-self local-variables)))
          (let ((effective-context (or local-self context)))
            (cond ((not effective-context)
                   (parameterize ((generate-symbol-for (format "%{a}&" (eval-count)))
                                  (generate-symbol-counter 0))
                     (evaluator (lambda (thunk)
                                  (thunk))
                                expr)))
                  ((symbol? effective-context)
                   (let ((unit-name effective-context))
                     (load-unit unit-name)
                     (let ((module-declaration (outline-unit unit-name)))
                       (parameterize ((requested-unit-name #f)
                                      (generate-symbol-for (format "%{a}&" (eval-count)))
                                      (generate-symbol-context unit-name)
                                      (generate-symbol-counter 0))
                         (evaluator (lambda (thunk)
                                      (parameterize ((current-console-context unit-name))
                                        (thunk)))
                                    `(module ,unit-name ,(get-dialect-name~ module-declaration)
                                     (with-local-variables ,local-names
                                       ,expr)))))))
                  (else
                   (let ((class-identifier (category-identifier (class-of effective-context))))
                     (receive (unit-name class-name) (split-composite class-identifier)
                       (load-unit unit-name)
                       (let ((module-declaration (outline-unit unit-name)))
                         (parameterize ((requested-unit-name #f)
                                        (generate-symbol-for (format "%{a}&" (eval-count)))
                                        (generate-symbol-context unit-name)
                                        (generate-symbol-counter 0))
                           (evaluator (lambda (thunk)
                                        (parameterize ((current-console-context effective-context))
                                          (thunk)))
                                      `(module ,unit-name ,(get-dialect-name~ module-declaration)
                                       (class ,class-name
                                         (with-dynamic-self (jazz.debuggee.current-console-context)
                                           (with-local-variables ,local-names
                                             ,expr))))))))))))))))
  
  (declare (proper-tail-calls))
  (let (iterate)
    (continuation-capture
      (lambda (resume)
        (read-eval-print thread resume port level)))
    (iterate)))


;;;
;;;; Exception
;;;


(definition public (jazz-exception-debugger exc)
  (let ((debugger (get-controller-debugger))
        (use (use-debugger?)))
    (if (or (not debugger) (not use))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (lambda ()
          (when (eq? use 'once)
            (use-debugger? #f))
          (continuation-capture
            (lambda (continuation)
              (let ((reason (exception-reason exc))
                    (detail (exception-detail exc)))
                (invoke-debugger 'exception reason detail exc continuation)))))))))


(definition public (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition public (local-debugger?)
  (and (eq? (current-exception-debugger) jazz-exception-debugger)
       controller-debugger
       (local-proxy? controller-debugger)))


(definition public (without-local-debugger thunk)
  (if (local-debugger?)
      (with-system-exception-debugger
        thunk)
    (thunk)))


(definition protected (break-internal (reason: reason #f))
  (continuation-capture
    (lambda (continuation)
      (invoke-debugger 'break reason #f #f continuation))))


(definition protected (start-repl-internal (reason: reason #f) (select?: select? #t))
  (continuation-capture
    (lambda (continuation)
      (when select?
        (select-console))
      (invoke-repl reason #f continuation))))


;;;
;;;; Step
;;;


(definition public (install-step)
  (declare (proper-tail-calls))
  (install-step-handler
    (lambda (locat executer)
      (continuation-capture
        (lambda (cont)
          (invoke-debugger 'break #f #f #f cont
            locat: locat
            stepper: (lambda (cmd)
                       (continuation-graft cont
                         (lambda ()
                           (executer cmd))))))))))


;;;
;;;; Inspect
;;;


(definition protected (inspect-internal object (kind: kind :value))
  (let ((info (package-info object kind: kind)))
    (inspect~ controller-debugger local-process info)))


;;;
;;;; Debugger
;;;


(definition (invoke-repl reason detail continuation)
  (let ((thread (current-thread))
        (port (get-console-port))
        (level (if (not (current-loop)) 0 (+ (current-repl-level) 1))))
    (with-repl-thread thread reason port level
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (with-current-loop
            (lambda ()
              (let ((process (get-process)))
                (if (not process)
                    (debuggee-loop)
                  (process-debuggee-loop~ process))))))))))


(definition public (invoke-debugger kind reason detail exc continuation (locat: locat #f) (stepper: stepper #f))
  ;; this is a temporary solution to threads keeping the load-mutex locked
  ;; see the todo file for details on what needs to be done for a clean solution
  (define (release-load-mutex!)
    (let ((load-mutex (get-load-mutex)))
      ;; limit the scope of the patch by a heuristic that could turn out
      ;; to be wrong if a loading thread depends on a thread that errors
      ;; but this is very far fetched and will do until a clean solution
      (when (eq? (mutex-owner load-mutex) (current-thread))
        (mutex-unlock! load-mutex))))
  
  (define (compute-restarts thread)
    (map (lambda (restart)
           (new Debuggee-Restart-Local-Proxy (new Debuggee-Restart thread restart)))
         (current-restarts)))
  
  (release-load-mutex!)
  (release-catalog-entries)
  (let ((thread (current-thread))
        (port (get-console-port))
        (level (+ (current-repl-level) 1)))
    (with-repl-thread thread reason port level
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (let ((stop (new Debuggee-Stop thread kind reason detail exc continuation (compute-restarts thread) locat stepper)))
            (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))
                  (stop-proxy (new Debuggee-Stop-Local-Proxy stop)))
              (dynamic-wind
                (lambda ()
                  (register-stop stop)
                  (register-stop~ controller-debugger local-process thread-proxy stop-proxy step?: (boolean stepper)))
                (lambda ()
                  (with-current-loop
                    (lambda ()
                      (let ((process (get-process)))
                        (if (not process)
                            (debuggee-loop)
                          (process-debuggee-loop~ process))))))
                (lambda ()
                  (unregister-stop stop)
                  (when controller-debugger ;; #f when quit while in error
                    (unregister-stop~ controller-debugger local-process thread-proxy stop-proxy))))))))
      step?: (boolean stepper))))


(definition package (debuggee-loop)
  (let (loop)
    (with-restart-catcher 'resume-loop (present-current-loop-restart) #f
      (lambda ()
        (let ((thunk (thread-read)))
          (with-jazz-exception-debugger
            thunk))))
    (loop)))


(definition package (present-current-loop-restart)
  (let ((loop (current-loop)))
    (when loop
      (let ((level (get-level~ loop)))
        (format "Resume loop{a}"
                (if (= level 0)
                    ""
                  (format " {a}" level)))))))


;;;
;;;; View
;;;


(definition *current-view-debugger*
  #f)


(definition public (current-view-debugger)
  (when (not *current-view-debugger*)
    (set! *current-view-debugger* (new View-Debugger)))
  *current-view-debugger*))
