;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.stub)
        (jazz.editor.jazz.inspector)
        (jazz.jrm)
        (jazz.network)
        (jazz.syntax (phase syntax))
        (jazz.system.access))


;;;
;;;; Local
;;;


(definition local-process
  #f)


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (new Debuggee-Process)))
    (register-object~ (get-local-register) 'debuggee local-process)))


;;;
;;;; Controller
;;;


(definition controller-debugger
  #f)

(definition controller-debugger-cookie
  #f)


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller controller-register focus?)
  (detach-from-controller)
  (set! controller-debugger (require-object~ controller-register 'debugger))
  (setup-local-process)
  (set-console-port-getter console-port-getter)
  (attach-process~ controller-debugger local-process focus?)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook)
  (add-exit-job! detach-from-controller))


(definition public (ready-to-controller (debugger-cookie #f))
  (set! controller-debugger-cookie debugger-cookie)
  (ready-process~ controller-debugger local-process debugger-cookie))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    (set! local-process #f)))


(definition public (detach-from-debugger)
  (when controller-debugger
    (when (live?~ controller-debugger)
      (detach-process~ controller-debugger local-process)
      (flush-remote-switchboard))
    (set! controller-debugger #f)
    (detach-consoles)))


(definition package (setup-debuggee (debugger: debugger #f))
  (let ((debugger-arg (or debugger (command-argument "debugger")))
        (interactive-arg (command-argument "debugger-interactive")))
    (when debugger-arg
      (receive (host port) (parse-host/service debugger-arg)
        (if (not port)
            (error "Ill-formed debugger argument: {a}" debugger-arg)
          (attach-debuggee host port focus?: (parse-boolean interactive-arg)))))))


(definition package (attach-debuggee host port (focus?: focus? #f))
  (load-debuggee-units)
  (start-remote-listener)
  (start-remote-switchboard)
  (attach-debuggee-to-controller (connect-remote-register (or host #u8(127 0 0 1)) port) focus?: focus?))


(definition package (attach-debuggee-to-controller controller-register (focus?: focus? #f))
  (attach-to-controller controller-register focus?)
  (current-input-port (console-input-port))
  (current-output-port (console-output-port)))


(definition package (ready-debuggee)
  (let ((cookie-arg (command-argument "debugger-cookie")))
    (when cookie-arg
      (ready-to-controller (parse-integer cookie-arg)))))


(definition package (update-debuggee-arguments)
  (let ((title-arg (command-argument "process-title"))
        (traits-arg (command-argument "process-traits"))
        (icon-arg (command-argument "process-icon")))
    (when title-arg
      (current-process-title-set! title-arg))
    (when traits-arg
      (current-process-traits-set! traits-arg))
    (when icon-arg
      (current-process-icon-set! icon-arg))))


(definition package (update-debuggee-process)
  (when controller-debugger
    (update-process~ controller-debugger local-process)))


;;;
;;;; Process
;;;


(definition public (process-hash process <Debuggee-Process-Stub>)
  ;; fixme
  0)


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-stop stop)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (append *stops* (list stop))))))


(definition (unregister-stop stop)
  (with-stops-mutex
    (lambda ()
      (set! *stops* (remove! stop *stops*)))))


(definition package (get-thread-stops thread)
  (let ((queue (new-queue)))
    (with-stops-mutex
      (lambda ()
        (for-each (lambda (stop)
                    (when (eq? (get-thread~ stop) thread)
                      (enqueue queue (new Debuggee-Stop-Local-Proxy stop))))
                  *stops*)))
    (queue-list queue)))


(definition public (post-stop exc)
  (continuation-capture
    (lambda (cont)
      (thread-write
        (primordial-thread)
        (lambda ()
          (when (local-debugger?)
            (jazz-handle-exception exc cont)))))))


(definition public (post-continuation cont)
  (let ((exc (new Error message: "Posted continuation")))
    (thread-write
      (primordial-thread)
      (lambda ()
        (jazz-handle-exception exc cont)))))


;;;
;;;; Runtime
;;;


(definition public (transmit-information-unavailable)
  (unavailable-runtime-information~ controller-debugger local-process))


(definition public (transmit-information filenames processes properties)
  (receive-runtime-information~ controller-debugger local-process filenames processes properties)
  (let ((process (get-process)))
    (when process
      (let ((local-debugger (get-local-debugger~ process)))
        (when local-debugger
          (receive-runtime-information~ local-debugger local-process filenames processes properties))))))


;;;
;;;; Loop
;;;


(class Loop extends Object
  
  
  (slot level accessors generate)
  
  
  (method override (initialize level)
    (set! level~self level)))


(definition public current-loop
  (make-parameter #f))


(definition public (with-current-loop thunk)
  (let ((current (current-loop)))
    (let ((loop (new Loop (if current (+ (get-level~ current) 1) 0))))
      (parameterize ((current-loop loop))
        (thunk)))))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  (slot remote      getter generate)
  (slot pump        getter generate)
  (slot tail        getter generate)
  (slot head        getter generate)
  (slot readtable   accessors generate)
  (slot repl-thread accessors generate)
  (slot context     accessors generate)
  (slot history     accessors generate)
  
  
  (method override (initialize remote pump tail head)
    (set! remote~self remote)
    (set! pump~self pump)
    (set! tail~self tail)
    (set! head~self head)
    (set! readtable~self #f)
    (set! repl-thread~self #f)
    (set! context~self (unspecified))
    (set! history~self #f)))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition package (thread-console thread (debugger: debugger #f) (select?: select? #f))
  (let ((debugger (or debugger controller-debugger)))
    (if (not debugger)
        #f
      (with-consoles-mutex
        (lambda ()
          (or (table-ref *consoles* thread #f)
              (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)) debugger select?)))
                (table-set! *consoles* thread console)
                console)))))))


(definition package (thread-console-pump-port thread)
  (get-tail~ (thread-console thread)))

(definition package (thread-console-port thread)
  (get-head~ (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))

(definition current-console-context
  (make-parameter #f))


(definition (make-debuggee-console thread-proxy debugger select?)
  (receive (head tail) (open-string-pipe (list permanent-close: #f readtable: jazz-readtable))
    (let ((console (register-console~ debugger local-process thread-proxy select?)))
      (let ((pump (start-debuggee-console-pump debugger console tail)))
        (new Console console pump tail head)))))


(definition package (select-console)
  (select-console~ controller-debugger (get-remote~ (thread-console (current-thread) select?: #t))))


(definition package (persist-console)
  (persist-console~ controller-debugger (get-remote~ (thread-console (current-thread)))))


(definition package (close-console)
  (close-thread-console (current-thread)))


(definition package (close-thread-console thread)
  (let ((console (thread-console thread)))
    (stop-repl-thread console)
    (detach-console thread console)
    (unregister-console~ controller-debugger (get-remote~ console))))


(definition (console-port-getter)
  (if (not controller-debugger)
      (terminal-port)
    (get-head~ (current-console))))


(definition (detach-consoles)
  (for-each (lambda (pair)
              (bind (thread . console) pair
                (detach-console thread console)))
            (table-keys/values *consoles*)))


(definition (detach-console thread console)
  (with-consoles-mutex
    (lambda ()
      (stop-debuggee-console-pump (get-pump~ console))
      (close-port (get-tail~ console))
      (close-port (get-head~ console))
      (table-clear *consoles* thread))))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump debugger console port)
  (thread-start!
    (new-system-thread
      (lambda ()
        (start-pump port
          (lambda (str)
            (when debugger
              (console-output~ debugger console str)))))
      'debuggee-pump)))


(definition (stop-debuggee-console-pump thread)
  (exit-thread thread))


;;;
;;;; Repl
;;;


(definition package current-repl-level
  (make-parameter 0))

(definition package current-repl-frame
  (make-parameter #f))


(definition (with-repl-thread thread reason port level thunk (step?: step? #f))
  (let ((previous-level (current-repl-level)))
    (parameterize ((current-repl-level level))
      (let ((repl-thread (start-repl-thread thread reason port level step?: step?)))
        (let ((console (thread-console thread)))
          (unwind-protect
              (thunk)
            (when console
              (stop-repl-thread console))))))))


(definition public (start-repl-thread thread reason port (level 0) (step?: step? #f))
  (let ((repl-thread
          (thread-start!
            (new-system-thread
              (lambda ()
                (when (= level 0)
                  (display-banner port))
                (when reason
                  (format port #"\($\)"#)
                  (display reason port)
                  (newline port))
                (when (and (> level 0) (not step?))
                  (display-prompt port level))
                (read-eval-print-loop thread port level))
              (if (= level 0)
                  'repl
                (string->symbol (format "repl{a}" level)))))))
    (set-repl-thread~ (thread-console thread) repl-thread)
    repl-thread))


(definition package (stop-repl-thread console)
  (let ((repl-thread (get-repl-thread~ console)))
    (when repl-thread
      (exit-thread repl-thread)
      (set-repl-thread~ console #f))))


(definition public (start-local-debugger-repl)
  (let ((local-debugger (find-object~ (get-local-register) 'debugger)))
    (when local-debugger
      (thread-start!
        (new-thread
          (lambda ()
            (let ((thread (current-thread)))
              (let ((port (get-head~ (thread-console thread debugger: local-debugger))))
                (start-repl-thread thread #f port)
                (with-current-loop
                  (lambda ()
                    (process-debuggee-loop~ (get-process)))))))
          'local-repl)))))


(definition package (display-banner port)
  (let ((title (current-process-title))
        (version (current-process-version)))
    (if (not version)
        (format port #"\(banner {a}{%}{%}\)"# title)
      (format port #"\(banner {a} v{a}{%}{%}\)"# title version)))
  (format port #"\(banner-prompt > \)"#)
  (force-output port))


(definition package (display-prompt port level)
  (define (prompt)
    (if (> level 0)
        (format "{a}> " level)
      "> "))
  
  (format port #"\($\)"#)
  (format port #"\(prompt {a}\)"# (prompt))
  (force-output port))


(definition *eval-count*
  0)


(definition public (eval-count)
  (prog1 *eval-count*
    (increase! *eval-count*)))


(definition public (evaluate-in-unit unit-name expr evaluator)
  (load-unit unit-name)
  (let ((module-declaration (outline-unit unit-name)))
    (parameterize ((requested-unit-name #f)
                   (generate-symbol-for (format "%{a}&" (eval-count)))
                   (generate-symbol-context unit-name)
                   (generate-symbol-counter 0))
      (evaluator
        `(module ,unit-name ,(get-dialect-name~ module-declaration) ,expr)))))


;;;
;;;; Loop
;;;


(definition (read-eval-print-loop thread port level)
  (define (read-eval-print thread resume port level)
    (define (console-read)
      (parameterize ((walk-for 'eval))
        (let ((console (thread-console thread)))
          (with-readtable (or (and console (get-readtable~ console)) scheme-readtable)
            (lambda ()
              (with-exception-filter
                (lambda (exc)
                  #t)
                (lambda (exc)
                  (thread-post thread 'exception
                    (lambda ()
                      (throw exc)))
                  (continuation-return resume #f))
                (lambda ()
                  (read port))))))))
    
    (define (console-eval expr)
      (define (parse-unquote-command expr)
        (if (and (pair? expr)
                 (eq? (car expr) 'unquote)
                 (pair? (cdr expr)))
            (let ((unquoted (cadr expr)))
              (cond ((symbol? unquoted)
                     (values unquoted #f))
                    ((pair? unquoted)
                     (values (car unquoted) (cdr unquoted)))
                    (else
                     (values #f #f))))
          (values #f #f)))
      
      (define (current-frame)
        (let ((frame-box (current-repl-frame)))
          (if frame-box
              (unbox frame-box)
            #f)))
      
      (define (frame-evaluator frame)
        (if frame
            (let ((cont (serial->object (get-continuation~ frame))))
              (lambda (runner expr)
                (eval-within-no-winding runner expr cont)))
          (lambda (runner expr)
            (runner
              (lambda ()
                (eval expr))))))
      
      (define (eval-in-context context frame evaluator expr)
        (define (local-names variables)
          (map (lambda (var)
                 (string->symbol (second (car var))))
               variables))
        
        (define (local-self variables)
          (find-object (lambda (var)
                         (when (string=? (second (car var)) "self")
                           (let ((serial (cadr var)))
                             (when serial
                               (let ((object (serial->object serial)))
                                 (when (object? object)
                                   object))))))
                       variables))
        
        @debugging
        (let ((ev evaluator))
          (set! evaluator
                (lambda (runner expr)
                  (pp (current-console-context))
                  (pp expr)
                  (ev runner expr))))
        
        (parameterize ((walk-for 'eval))
          (let ((local-variables (if frame (get-variables~ frame :lexical) '())))
            (let ((local-names (local-names local-variables))
                  (local-self (local-self local-variables)))
              (let ((effective-context (or local-self context)))
                (cond ((not effective-context)
                       (parameterize ((generate-symbol-for (format "%{a}&" (eval-count)))
                                      (generate-symbol-counter 0))
                         (evaluator (lambda (thunk)
                                      (thunk))
                                    expr)))
                      ((symbol? effective-context)
                       (let ((unit-name effective-context))
                         (evaluate-in-unit
                           unit-name
                           `(with-local-variables ,local-names
                              ,expr)
                           (lambda (expr)
                             (evaluator (lambda (thunk)
                                          (parameterize ((current-console-context unit-name))
                                            (thunk)))
                                        expr)))))
                      (else
                       (let ((class-identifier (category-identifier (class-of effective-context))))
                         (receive (unit-name class-name) (break-reference class-identifier)
                           (evaluate-in-unit
                             unit-name
                             `(class ,class-name
                                (with-dynamic-self (jazz.debuggee:current-console-context)
                                  (with-local-variables ,local-names
                                    ,expr)))
                             (lambda (expr)
                               (evaluator (lambda (thunk)
                                            (parameterize ((current-console-context effective-context))
                                              (thunk)))
                                          expr))))))))))))
      
      (let ((console (current-console)))
        (let ((context (console-context console)))
          (receive (cmd arguments) (parse-unquote-command expr)
            (define (context-eval context expr)
              (let ((frame (current-frame)))
                (let ((evaluator (frame-evaluator frame)))
                  (catch (Walk-Problems problems
                           (display-exception problems)
                           (unspecified))
                    (eval-in-context context frame evaluator expr)))))
            
            (if cmd
                (let ((command (registered-console-command cmd)))
                  (command cmd arguments console console-read console-eval console-print context-eval))
              (context-eval context expr))))))
    
    (define (console-print result)
      (when (and (thread-call-result? result)
                 (specified? result))
        (repl-result-history-add result)
        (let ((values (call-with-values (lambda () result) list)))
          (for-each (lambda (value)
                      (format port "{s}" value)
                      (format port "{%}"))
                    values)))
      (display-prompt port level)
      (force-output port))
    
    (let ((expr (console-read)))
      (if (eof-object? expr)
          (thread-post thread 'resume-loop
            (lambda ()
              (let ((restarts (find-restarts 'resume-loop)))
                (when (> (length restarts) 1)
                  (newline port)
                  ;; skip the current resume-loop restart
                  (let ((restart (second restarts)))
                    (invoke-restart restart))))))
        (let ((result
                (thread-call thread 'console-eval
                  (lambda ()
                    (console-eval expr)))))
          (console-print result)))))
  
  (declare (proper-tail-calls))
  (let (iterate)
    (continuation-capture
      (lambda (resume)
        (read-eval-print thread resume port level)))
    (iterate)))


;;;
;;;; Context
;;;


(definition default-context
  :not-set)

(definition public (get-default-context)
  default-context)

(definition public (set-default-context ctx)
  (set! default-context ctx))


(definition (context-alias context)
  (when (enumerator? context)
    (if (and (eq? context :default)
             (neq? default-context :not-set))
        default-context
      (let ((process (get-process)))
        (cond ((not process)
               (if (eq? context :default)
                   (new (module-ref 'jazz.profile 'Me))
                 #f))
              ((eq? context :default)
               (or (process-alias~ process :profile)
                   (process-alias~ process :process)))
              ((eq? context :me)
               (context-alias :profile))
              (else
               (process-alias~ process context)))))))


(define (console-context console)
  (define (context-init console)
    (let ((context (get-context~ console)))
      (if (unspecified? context)
          (let ((new-context
                  (let ((process (get-process)))
                    (context-alias (if process
                                       (or (initial-console-context~ process)
                                           :default)
                                     :default)))))
            (set-context~ console new-context)
            new-context)
        context)))
  
  (if (not console)
      #f
    (context-init console)))


;;;
;;;; Commands
;;;


(definition *console-commands*
  (make-table test: eq?))


(definition public (register-console-command cmd proc)
  (table-set! *console-commands* cmd proc))


(definition public (registered-console-command cmd)
  (or (table-ref *console-commands* cmd)
      (error "Unknown console command: {s}" cmd)))


(define (in-command cmd arguments console read eval print context-eval)
  (if (or (not arguments) (null? arguments))
      (console-context console)
    (let ((ctx (car arguments)))
      (let ((new-context (or (context-alias ctx) (eval ctx))))
        (when (symbol? new-context)
          (load-unit new-context))
        (if (not-null? (cdr arguments))
            (let ((expr (cadr arguments)))
              (context-eval new-context expr))
          (when console
            (set-context~ console new-context)
            (set-readtable~ console (if (not new-context) #f jazz-readtable)))
          new-context)))))


(register-console-command 'in in-command)


(define (scheme-command cmd arguments console read eval print context-eval)
  (let ((expr (car arguments)))
    (context-eval #f expr)))


(register-console-command 'scheme scheme-command)


;;;
;;;; Exception
;;;


(definition public (jazz-exception-debugger exc)
  (continuation-capture
    (lambda (cont)
      (jazz-handle-exception exc cont))))


(definition public (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition (jazz-handle-exception exc cont)
  (let ((debugger (get-controller-debugger))
        (use (use-debugger?)))
    (if (or (not debugger) (not use))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (lambda ()
          (when (eq? use 'once)
            (use-debugger? #f))
          (let ((reason (exception-reason exc))
                (detail (exception-detail exc)))
            (invoke-debugger 'exception reason detail exc cont)))))))


(definition public (jazz-debugger?)
  (and (eq? (active-exception-debugger) jazz-exception-debugger)
       (boolean controller-debugger)))


(definition public (local-debugger?)
  (and (jazz-debugger?)
       (local-proxy? controller-debugger)))


(definition public (without-local-debugger thunk)
  (if (local-debugger?)
      (with-system-exception-debugger
        thunk)
    (thunk)))


(definition public (using-debugger?)
  (boolean (command-argument "debugger")))


(definition protected (break-internal (reason: reason #f))
  (continuation-capture
    (lambda (continuation)
      (invoke-debugger 'break reason #f #f continuation))))


(definition protected (start-repl-internal (reason: reason #f) (select?: select? #t))
  (continuation-capture
    (lambda (continuation)
      (when select?
        (select-console))
      (invoke-repl reason #f continuation))))


(definition protected (start-jazz-repl-internal)
  (transmit-information-unavailable)
  (start-repl-internal))


(definition protected (load-object-internal module-name name)
  (load-object~ (get-local-register) module-name name))


;;;
;;;; Step
;;;


(definition public (install-step)
  (declare (proper-tail-calls))
  (install-step-handler
    (lambda (locat executer)
      (continuation-capture
        (lambda (cont)
          (invoke-debugger 'break #f #f #f cont
            locat: locat
            stepper: (lambda (cmd)
                       (continuation-graft cont
                         (lambda ()
                           (executer cmd))))))))))


;;;
;;;; Inspect
;;;


(definition protected (inspect-internal object (kind: kind :value))
  (let ((info (package-info object kind: kind)))
    (inspect~ controller-debugger local-process info)))


;;;
;;;; Advice
;;;


(definition *advices*
  (make-table test: eq?))


(definition public (get-advices)
  *advices*)


@comment
(definition public (profile-advice field locator original set)
  (let ((original (original)))
    (when (procedure? original)
      (set (lambda rest
             (profile-code original
               (lambda ()
                 (apply original rest))))))))


;; a.b.c:d/e (a.b.c d e)
(definition protected (advise-internal what proc)
  (define (advise-all)
    (iterate-table (get-modules)
      (lambda (module-name module)
        (advise-module module))))
  
  (define (advise-hook enumerator)
    (let ((name (enumerator->symbol enumerator))
          (locator enumerator))
      (proc name
            locator
            (lambda ()
              #f)
            (lambda (value)
              (if value
                  (install-hook name value)
                (uninstall-hook name))))))
  
  (define (advise-symbol symbol)
    (receive (module-name name) (break-reference symbol)
      (advise-path (cons module-name (if (not name) '() (split-symbol name #\/))))))
  
  (define (advise-path path)
    (bind (module-name . rest) path
      (if (ends-with? (symbol->string module-name) ".*")
          (assert (null? rest)
            (let ((name (symbol->string module-name)))
              (let ((prefix (substring name 0 (- (cardinality name) 2))))
                (advise-prefixed prefix))))
        (let ((module (require-module module-name)))
          (if (null? rest)
              (advise-module module)
            (bind (name . rest) rest
              (let ((entry (table-ref (get-entries~ module) name)))
                (if (null? rest)
                    (advise-entry entry)
                  (assert (category? entry)
                    (advise-class-field entry (category-field entry (car rest))))))))))))
  
  (define (advise-module module)
    (iterate-table (get-entries~ module)
      (lambda (name entry)
        (advise-entry entry))))
  
  (define (advise-prefixed prefix)
    (iterate-table (get-modules)
      (lambda (module-name module)
        (when (starts-with? (symbol->string module-name) prefix)
          (advise-module module)))))
  
  (define (advise-entry entry)
    (typecase entry
      ((Field)
       (advise-field entry))
      ((Class)
       (advise-class entry))))

  (define (advise-field field)
    (let ((locator (field-locator~ field)))
      (call-proc field
                 locator
                 (lambda () (field-ref~ field))
                 (lambda (value) (field-set!~ field value)))))
  
  (define (advise-class class)
    (iterate-table-safe (get-fields~ class)
      (lambda (name field)
        (advise-class-field class field)))
    (iterate-class-overrides class
      (lambda (method)
        (advise-method class method))))
  
  (define (advise-class-field class field)
    (typecase field
      ((Slot))
      ((Method)
       (advise-method class field))
      ((Field)
       (advise-field field))))
  
  (define (advise-method class method)
    (let ((name (get-name~ method)))
      (let ((locator (compose-reference (get-name~ class) name)))
        (call-proc method
                   locator
                   (lambda () (find-dispatch class name))
                   (lambda (value) (update-method class name value))))))
  
  (define (call-proc field locator ref set)
    (define (original)
      (or (table-ref *advices* locator #f)
          (ref)))
    
    (proc field
          locator
          original
          (lambda (value)
            (let ((original (original)))
              (let ((value (or value original)))
                (if (eq? value original)
                    (table-clear *advices* locator)
                  (table-set! *advices* locator original))
                (set value))))))
  
  (cond @wait-recursive-problems
        ((not what)
         (advise-all))
        ((enumerator? what)
         (advise-hook what))
        ((symbol? what)
         (advise-symbol what))
        ((null/pair? what)
         (advise-path what))
        ((class? what)
         (advise-class what))))


(definition protected (unadvise-internal what)
  (advise what
          (lambda (field locator original set)
            (set #f))))


(let ((original-procedure-name procedure-name))
  (procedure-name-set!
    (lambda (procedure)
      (or (original-procedure-name procedure)
          (continuation-capture
            (lambda (return)
              (iterate-table *advices*
                (lambda (locator proc)
                  (when (eq? proc procedure)
                    (continuation-return return locator))))
              #f))))))


;;;
;;;; Debug
;;;


(definition protected (debug-advice-internal field locator original set)
  (debug locator))


;;;
;;;; Count
;;;


(definition counts
  (make-table test: eq?))

(definition public (get-counts)
  counts)


(definition public (count-advice-internal field locator original set)
  (let ((original (original)))
    (when (procedure? original)
      (set (lambda rest
             (table-set! counts locator (+ (table-ref counts locator 0) 1))
             (apply original rest))))))


;;;
;;;; Time
;;;


(definition public (time-advice-internal field locator original set)
  (let ((original (original)))
    (when (procedure? original)
      (set (lambda rest
             (time (apply original rest)))))))


;;;
;;;; Trace
;;;


(define trace-depth
  (make-parameter 0))

(define default-present-reference
  present-reference)


(definition protected (trace-advice-internal (port: port #f) (present-reference: present-reference #f) (present-context: present-context #f))
  (let ((port (or port :console))
        (present-reference (or present-reference default-present-reference)))
    (lambda (field locator original set)
      (let ((original (original)))
        (when (procedure? original)
          (set (lambda rest
                 (let ((column (* (trace-depth) 2)))
                   (format port "{$}{_ :v}[({a}{?: {l}~}){a}" column (present-reference locator) (not-null? rest) rest (if present-context (present-context) ""))
                   (let ((result (parameterize ((trace-depth (+ (trace-depth) 1)))
                                   (apply original rest))))
                     (format port "{$}{_ :v}  <= {s}]" column result)
                     result)))))))))


(definition protected (trace-internal what . rest)
  (advise what (apply trace-advice-internal rest)))


(definition protected (untrace-internal what)
  (unadvise what))


;;;
;;;; Debugger
;;;


(definition (invoke-repl reason detail continuation)
  (let ((thread (current-thread))
        (port (get-console-port))
        (level (if (not (current-loop)) 0 (+ (current-repl-level) 1))))
    (with-repl-thread thread reason port level
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (with-current-loop
            (lambda ()
              (let ((process (get-process)))
                (if (not process)
                    (debuggee-loop)
                  (process-debuggee-loop~ process))))))))))


(definition public (invoke-debugger kind reason detail exc continuation (locat: locat #f) (stepper: stepper #f))
  (define (invoke-releases)
    (for-each (lambda (proc)
                (proc))
              (get-debugger-releases)))
  
  (define (compute-restarts thread)
    (map (lambda (restart)
           (new Debuggee-Restart-Local-Proxy (new Debuggee-Restart thread restart)))
         (current-restarts)))
  
  (invoke-releases)
  (let ((thread (current-thread))
        (port (get-console-port))
        (level (current-repl-level)))
    (with-repl-thread thread reason port (+ level 1)
      (lambda ()
        (parameterize ((current-repl-frame (box #f)))
          (let ((stop (new Debuggee-Stop thread kind reason detail exc continuation (compute-restarts thread) locat stepper)))
            (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))
                  (stop-proxy (new Debuggee-Stop-Local-Proxy stop)))
              (dynamic-wind
                (lambda ()
                  (register-stop stop)
                  (register-stop~ controller-debugger local-process thread-proxy stop-proxy step?: (boolean stepper))
                  (hook-debuggee thread (+ level 1)))
                (lambda ()
                  (with-current-loop
                    (lambda ()
                      (let ((process (get-process)))
                        (if (not process)
                            (debuggee-loop)
                          (process-debuggee-loop~ process))))))
                (lambda ()
                  (unregister-stop stop)
                  (when controller-debugger
                    (unregister-stop~ controller-debugger local-process thread-proxy stop-proxy))
                  (hook-debuggee thread level)))))))
      step?: (boolean stepper))))


(definition package (debuggee-loop)
  (declare (proper-tail-calls))
  (let (restart-loop)
    (with-restart-catcher 'resume-loop (present-current-loop-restart)
      (lambda ()
        (let (loop)
          (with-jazz-exception-debugger
            (lambda ()
              (thread-process)))
          (loop))))
    (restart-loop)))


(definition package (present-current-loop-restart)
  (let ((loop (current-loop)))
    (when loop
      (let ((level (get-level~ loop)))
        (format "Resume loop{a}"
                (if (= level 0)
                    ""
                  (format " {a}" level)))))))


;;;
;;;; Evaluate
;;;


(definition *evaluate-hooks*
  '())


(definition public (register-evaluate-hook hook)
  (set! *evaluate-hooks* (append *evaluate-hooks* (list hook))))

(definition public (unregister-evaluate-hook hook)
  (set! *evaluate-hooks* (remove! hook *evaluate-hooks*)))


(definition public (hook-evaluate syntax str container line col)
  (for-each (lambda (hook)
              (hook syntax str container line col))
            *evaluate-hooks*))


;;;
;;;; Debuggee
;;;


(definition *debuggee-hooks*
  '())


(definition public (register-debuggee-hook hook)
  (set! *debuggee-hooks* (append *debuggee-hooks* (list hook))))

(definition public (unregister-debuggee-hook hook)
  (set! *debuggee-hooks* (remove! hook *debuggee-hooks*)))


(definition public (hook-debuggee thread level)
  (for-each (lambda (hook)
              (hook thread level))
            *debuggee-hooks*))



;;;
;;;; Releases
;;;


(definition *debugger-releases*
  (new-queue))

(definition public (get-debugger-releases)
  (queue-list *debugger-releases*))

(definition public (add-debugger-release name proc)
  (enqueue *debugger-releases* proc))


(add-debugger-release 'enable-interrupts
  enable-interrupts!)


(add-debugger-release 'load-mutex
  ;; this is a temporary solution to threads keeping the load-mutex locked
  ;; see the todo file for details on what needs to be done for a clean solution
  (lambda ()
    (let ((load-mutex (get-load-mutex)))
      ;; limit the scope of the patch by a heuristic that could turn out
      ;; to be wrong if a loading thread depends on a thread that errors
      ;; but this is very far fetched and will do until a clean solution
      (when (eq? (mutex-owner load-mutex) (current-thread))
        (mutex-unlock! load-mutex)))))


(add-debugger-release 'catalog-entries
  release-catalog-entries)


;;;
;;;; View
;;;


(definition *current-view-debugger*
  #f)


(definition public (current-view-debugger)
  (when (not *current-view-debugger*)
    (set! *current-view-debugger* (new View-Debugger)))
  *current-view-debugger*)


;;;
;;;; Hidden
;;;


(let ((previous hidden-frame?)
      (hidden
        (list
          with-exception-debugger
          with-system-exception-debugger
          with-exception-filter
          continuation-capture)))
  (hidden-frame?-set!
    (lambda (frame)
      (or (previous frame)
          (eq? frame (get-exception-debugger))
          (eq? frame (get-exception-hook))
          (memq? frame hidden))))))
