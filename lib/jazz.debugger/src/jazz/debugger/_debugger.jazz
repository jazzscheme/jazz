;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debugger
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.debugger jazz


(export (jazz.debugger.autoload))

(import (jazz.debugger.autoload)
        (jazz.console)
        (jazz.jrm)
        (jazz.system)
        (jazz.ui.view)
        (jazz.ui.window))


(definition public (with-jrm-exception-handler process thunk)
  (define (jrm-exception? exc)
    (or (os-exception? exc)
        (and (object? exc)
             (is? exc Remote-Connection-Broke))))
  
  (define (warn-retry-connect)
    (execute-event
      (lambda ()
        (case (message-box "Connection failed previously. Do you want to retry?" type: 'question yes: "Retry" no: "Cancel")
          ((no) (signal-cancel))))))
  
  (define (process-jrm-exception exc)
    (execute-event
      (lambda ()
        (message-box "Connection to remote process failed")
        (when process
          (set-alive?~ (get-debugger-manager) process #f))
        (signal-cancel))))
  
  (when (and process (not (get-alive?~ (get-debugger-manager) process)))
    (warn-retry-connect))
  (catch (jrm-exception? exc (process-jrm-exception exc))
    (thunk)))


;;;
;;;; Manager
;;;


(definition *debugger-manager*
  #f)


(definition public (get-debugger-manager)
  *debugger-manager*)


(definition public (set-debugger-manager debugger-manager)
  (set! *debugger-manager* debugger-manager))


;;;
;;;; Debugger
;;;


(definition *debuggers*
  '())

(definition *current-debugger*
  #f)


(definition with-debuggers-mutex
  (let ((mutex (make-mutex 'debuggers)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition package (register-debugger debugger)
  (with-debuggers-mutex
    (lambda ()
      (set! *debuggers* (append *debuggers* (list debugger))))))


(definition package (unregister-debugger debugger)
  (with-debuggers-mutex
    (lambda ()
      (set! *debuggers* (remove! debugger *debuggers*)))))


(definition public (get-debuggers)
  *debuggers*)


(definition public (current-debugger)
  *current-debugger*)


(definition public (set-current-debugger debugger)
  (set! *current-debugger* debugger))


;;;
;;;; Inspector
;;;


(definition protected (backward-compatible-key key)
  (if (pair? key)
      key
    (list #f key 0)))


;;;
;;;; Debugged
;;;


(definition public (debugged=? x y)
  (or (and (not x) (not y))
      (and x
           y
           (let ((dx (get-debugger~ x))
                 (dy (get-debugger~ y)))
             (and (eq? dx dy)
                  (same?~ x y))))))


(definition public (debugged-hash debugged <Debugged+>)
  ;; fixme
  (if (not debugged)
      0
    0
    @must-be-recursive ; eq?-hash fails
    (fxwrap+ (eq?-hash (get-debugger~ debugged))
             (eq?-hash (get-process~ debugged))
             (eq?-hash (get-reference~ debugged)))))


;;;
;;;; Processes
;;;


(definition public (collect-processes)
  (let ((queue (new-queue)))
    (for-each (lambda (debugger)
                (for-each (lambda (process)
                            (let ((debugged (new Debugged-Process debugger process process)))
                              (enqueue queue debugged)))
                          (get-processes~ debugger validate-liveness?: #t)))
              (get-debuggers))
    (queue-list queue)))


;;;
;;;; Cookies
;;;


(definition *current-debugger-cookie*
  0)

(definition *debugger-cookie-procedures*
  (make-table test: eqv?))


(definition public (register-debugger-cookie)
  (prog1 *current-debugger-cookie*
    (increase! *current-debugger-cookie*)))


(definition public (register-debugger-cookie-procedure cookie proc)
  (table-add *debugger-cookie-procedures* cookie proc))


(definition public (invoke-registered-cookie-procedures process cookie)
  (let ((procedures (table-ref *debugger-cookie-procedures* cookie '())))
    (table-clear *debugger-cookie-procedures* cookie)
    (for-each-reversed (lambda (proc)
                         (proc process cookie))
                       procedures)))


(definition *process-configurations*
  (make-table test: debugged=? hash: debugged-hash))


(definition package (registered-process-configurations)
  *process-configurations*)


(definition public (register-process-configuration process configuration)
  (table-set! *process-configurations* process configuration))

(definition public (registered-process-configuration process)
  (table-ref *process-configurations* process #f))


(definition public (registered-processes target)
  (collect (lambda (kv)
             (bind (process . configuration) kv
               (when (equal? configuration target)
                 process)))
           (table->list *process-configurations*)))


(definition public (registered-process-live? configuration)
  (let ((processes (registered-processes configuration)))
    (some? (lambda (process)
             (find-live-process~ (get-debugger-manager) process))
           processes)))


(definition package (cleanup-process-configurations process)
  (table-clear *process-configurations* process))


;;;
;;;; Resources
;;;


(definition *debugger-resources*
  (make-table test: debugged=? hash: debugged-hash))


(definition package (get-debugger-resources-table)
  *debugger-resources*)


(definition public (get-debugger-resources process)
  (table-ref *debugger-resources* process '()))

(definition public (set-debugger-resources process resources)
  (table-set! *debugger-resources* process resources))


(definition public (register-debugger-resource process resource)
  (set-debugger-resources process (cons resource (get-debugger-resources process))))

(definition public (unregister-debugger-resource process resource)
  (set-debugger-resources process (remove! resource (get-debugger-resources process))))


(definition public (find-debugger-resource target)
  (continuation-capture
    (lambda (return)
      (let ((manager (get-debugger-manager)))
        (for-each-process~ manager
          (lambda (debugger process live? focused?)
            (for-each (lambda (resource)
                        (let ((reference (get-reference~ resource)))
                          (when (eq? reference target)
                            (continuation-return return resource))))
                      (get-debugger-resources process)))))
      #f)))


(definition package (close-process-debugger-resources process)
  (for-each close-resource~ (get-debugger-resources process))
  (table-clear *debugger-resources* process))


;;;
;;;; Break
;;;


(definition Once-Breaks
  (make-table test: eq?))


(definition public (add-break-once name)
  (table-set! Once-Breaks name #t))


(definition public (break-once name)
  (when (table-ref Once-Breaks name #f)
    (table-set! Once-Breaks name #f)
    (break)))


(definition Once-Executes
  (make-table test: eq?))


(definition public (add-execute-once name)
  (table-set! Once-Executes name #t))


(definition public (execute-once name proc)
  (when (table-ref Once-Executes name #f)
    (table-set! Once-Executes name #f)
    (proc)))


;;;
;;;; Console
;;;


(definition public (register-debugger-console debugged-process debugged-thread select?)
  (define (setup-debugger-console-ports text process-proxy thread-proxy)
    (receive (head tail) (open-string-pipe (list permanent-close: #f))
      (set-console-port~ text head)
      (set-console-pump~ text (start-debugger-console-pump tail process-proxy thread-proxy))))
  
  (define (start-debugger-console-pump port process-proxy thread-proxy)
    (thread-start!
      (new-system-thread
        (lambda ()
          (start-pump port
                      (lambda (str)
                        (with-jrm-exception-handler debugged-process
                          (lambda ()
                            (console-input~ process-proxy thread-proxy str))))))
        'debugger-pump)))
  
  (let ((manager (get-console-manager))
        (process-proxy (get-reference~ debugged-process))
        (thread-proxy (get-reference~ debugged-thread)))
    (bind (title traits thread) (process-information process-proxy thread-proxy)
      (let ((text (register-console~ manager (present-process-title/traits/thread title traits thread) select? process-title: title process-traits: traits process-thread: thread)))
        (setup-debugger-console-ports text process-proxy thread-proxy)
        text))))


(definition public (unregister-debugger-console text)
  (let ((pump (get-console-pump~ text)))
    (when pump
      (exit-thread pump)))
  (execute-event
    (lambda ()
      (unregister-console~ (get-console-text-manager text) text))))


(definition public (debugger-console-output text str)
  (execute-event
    (lambda ()
      (set-caret~ text (text-ending~ text))
      (insert-formatted-line~ text str))))


(definition public (present-process-title process-proxy thread-proxy)
  (bind (title traits thread) (process-information process-proxy thread-proxy)
    (present-process-title/traits/thread title traits thread)))


(definition public (present-process-title/traits/thread title traits thread)
  (let ((title (present-process-title/traits title traits)))
    (if (not thread)
        title
      (format "{a} {a}" title (present-thread-name thread)))))


(definition public (present-process-title/traits title traits)
  (if traits
      (format "{a}{a}" title traits)
    title))


(definition public (present-process-traits traits)
  (apply string-append (map (lambda (trait)
                              (format "<{a}>" (identifier-name trait)))
                            traits)))


(definition public (process-information process-proxy thread-proxy)
  (let ((thread-name (and thread-proxy (get-name~ thread-proxy))))
    (case thread-name
      ((local-repl)
       (list "Local"
             #f
             #f))
      (else
       (list (get-title~ process-proxy)
             (get-traits~ process-proxy)
             thread-name)))))


(definition public (console-title title traits thread)
  (let ((title (present-process-title/traits title @wait-smarter-space-management traits #f)))
    (if (or (not thread) (eq? thread 'primordial))
        title
      (format "{a} {a}" title (present-thread-name thread)))))


;;;
;;;; Calls
;;;


(definition public (on-call-step-over evt)
  (on-step-over evt))


(definition public (on-call-step-into evt)
  (if (get-shift?~ evt)
      (on-step-into-function evt)
    (on-step-into evt)))


(definition public (on-call-step-out evt)
  (if (get-shift?~ evt)
      (on-step-outside-function evt)
    (on-step-out evt)))


(definition public (on-call-run-to evt)
  (if (get-shift?~ evt)
      (on-run-to-result evt)
    (on-run-to-cursor evt)))


;;;
;;;; Events
;;;


(definition public (on-restart evt)
  (restart))


(definition public (on-break evt)
  @convert
  (break-next))


(definition public (on-continue evt)
  (if (not (debugging?))
      (bell)
    (continue)))


(definition public (on-step-over evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-over)))


(definition public (on-step-into evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into)))


(definition public (on-step-into-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into-function)))


(definition public (on-step-out evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-out)))


(definition public (on-step-outside-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-outside-function)))


(definition public (on-run-to-cursor evt)
  )


(definition public (on-run-to-result evt)
  )


(definition public (restart)
  (restart~ (get-loop~ (get-application))))


(definition public (continue)
  (continue~ (get-loop~ (get-application))))


(definition public (debugging?)
  (/= (get-level~ (get-loop~ (get-application))) 0))


;;;
;;;; View
;;;


(definition public (get-processes-view)
  (get-guest~ (singleton-docked Processes-View)))


(definition public (get-threads-view)
  (get-guest~ (singleton-docked Threads-View)))


(definition public (get-frames-view)
  (get-guest~ (singleton-docked Frames-View)))


(definition public (get-restarts-view)
  (get-guest~ (singleton-docked Restarts-View)))


(definition public (get-exception-view)
  (get-guest~ (singleton-docked Exception-View)))


(definition public (get-problems-view)
  (get-guest~ (singleton-docked Problems-View)))


(definition public (get-variables-view)
  (get-guest~ (singleton-docked Variables-View))))
