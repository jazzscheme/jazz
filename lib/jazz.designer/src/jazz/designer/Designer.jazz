;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Designer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.designer.Designer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.component.runtime)
        (jazz.designer)
        (jazz.editor.jazz)
        (jazz.event)
        (jazz.handler)
        (jazz.io)
        (jazz.jml)
        (jazz.platform)
        (jazz.preferences)
        (jazz.reference)
        (jazz.runtime)
        (jazz.ui.dialog)
        (jazz.undoer)
        (jazz.view))


(class Designer extends Object
  
  
  (slot form          initialize #f accessors generate)
  (slot reference     initialize #f getter generate)
  (slot listeners     initialize '())
  (slot modified?     initialize #f accessors generate)
  (slot undoer        initialize #f getter generate)

  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (initialize (form: form #f) (reference: reference #f))
    (define (setup-form frm)
      (if (not frm)
          (begin
            (set! form~self (new Form textual?: #f origin: (class-of reference) action: 'install))
            (set-context~ form~self form~self)
            (set-data~ form~self (new Data #f 'jazz '() #f)))
        (set! form~self frm)))
    
    ;; Setting form to a copy until saving is a tempting approach,
    ;; but fails because we absolutly need pointer equality as a test
    ;; for embed-form to work correctly with anonymous forms.
    ;; So the approach taken will be more like relational databases
    ;; where we modify the database directly but keep a log of
    ;; transactions in order to be able to rollback changes (and it
    ;; makes lots of sense to, because a designer is really the interface
    ;; by which Jazz's object-oriented databases are updated!).
    ;;
    ;; Or maybe simply take a copy before the first modification is made
    ;; (lazy approach) and if we need to rollback, set the original form
    ;; to the copy.
    
    (define (setup-undoer)
      (set! undoer (new Undoer reset-modified: reset-modified?)))
    
    (nextmethod)
    (set! reference~self reference)
    (setup-form form)
    (setup-undoer))
  
  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method public virtual (save (default-extension: default-extension #f) (extensions: extensions '()))
    (with-cursor :wait
      (lambda ()
        (let ((origin (get-origin~ form)))
          (if (not origin)
              (save-as default-extension: default-extension extensions: extensions)
            (save-content origin))))))
  
  
  (method public (save-to file)
    (if (not file)
        (save-as)
      (set-origin~ form file)
      (save-to-file file)
      (set-modified? #f)))
  
  
  (definition Default-Extension
    "jmf")
  
  (definition Default-Extensions
    '(("JMF Files" . "jmf")))
  
  
  (method (save-as (default-extension: default-extension #f) (extensions: extensions '()))
    (let ((file (choose-new-file default-extension: (or default-extension Default-Extension) extensions: (or extensions Default-Extensions))))
      (save-content file)
      (set-origin~ form file)))
  
  
  (method (save-content destination)
    (assert (use-print?))
    (typecase destination
      ((File) (save-to-file destination))
      ((Class) (save-to-class destination))
      ((Runtime-Reference) (save-to-reference destination))
      (else (error "unsupported destination")))
    (set-modified? #f))
  
  
  (method public (designing-trait?)
    (let ((origin (get-origin~ form)))
      (and (is? origin Runtime-Reference)
           (let ((obj (resolve-runtime-reference origin)))
             (is? obj Trait)))))
  
  
  (method (save-to-trait unit symbol)
    (let ((imports (imports-to-insert form '() (list unit)))
          (trait-form (first (get-children~ form)))
          (class-sym (get-model~ form)))
      (call-with-saved-text (find-unit-source unit)
        (lambda (text)
          (insert-imports text imports)
          (let ((trait-string (format "(define-trait {a} {a}{%}{a})" symbol class-sym (form->string trait-form 1 include-form?: #f))))
            (insert-string~ (get-model~ text) (location-range~ text (list symbol)) trait-string)
            (evaluate-range~ text (location-range~ text (list symbol))))))))
  
  
  (method (save-to-reference reference)
    (bind (_ unit symbol) (serialize-runtime-reference reference)
      (typecase (module-ref unit symbol)
        ((Trait)
         (save-to-trait unit symbol))
        (else
         (error "Unknown save target")))))
  
  
  (method (save-to-class class)
    (let ((class-name (category-name class))
          (module-name (category-unit class)))
      (define (save-form text form)
        (let ((form-exists? (class-has-form? text class-name)))
          (let ((form-range (location-range~ text (list class-name (if form-exists? :form :new-form))))
                (form-string (format (if form-exists? "{a}" "{%}{%}{%}{a}") (form->string form 2))))
            (insert-string~ (get-model~ text) form-range form-string))))
      
      (call-with-saved-text (find-unit-source module-name)
        (lambda (text)
          (insert-imports text (imports-to-insert form '() (list module-name)))
          (save-form text form)
          (evaluate-range~ text (location-range~ text (list class-name :form)))))))
  
  
  (method (save-to-file file)
    (define (super-class-reference form)
      (or (get-reference~ form (get-model~ form))
          (runtime-class-reference (class-ascendant (get-origin~ form)))))
    
    (define (adjust-form form super-class-symbol)
      (let ((adjusted-form (copy-object~ form #f)))
        (set-action~ adjusted-form 'new)
        (set-model~ adjusted-form super-class-symbol)
        adjusted-form))
    
    (if (and (exists?~ file) (read-only?~ file))
        (message-box (format "Unable to save to read-only file: {s}" file))
      (call-with-output-file (path-settings file char-encoding: 'UTF-8)
        (lambda (output)
          (bind (super-class-unit super-class-symbol) (parse-runtime-reference (super-class-reference form))
            (let ((data (get-data~ form))
                  (adjusted-form (if (class? (get-origin~ form))
                                     (adjust-form form super-class-symbol)
                                   form)))
              (output-header (get-model~ adjusted-form) output)
              (format output "{%}{%}")
              (format output "(data {a}{%}" (if data (get-dialect~ data) 'jazz))
              (format output "{%}{%}")
              (let ((version (and data (get-version~ data))))
                (when version
                  (format output "(version {a}){%}" (present-string~ version))))
              (let ((imports (if data
                                 (get-imports~ data)
                               (imports-to-insert form (list super-class-unit) '()))))
                (when (and imports (not-null? imports))
                  (format output "(import {s}" (car imports))
                  (for-each (lambda (import)
                              (format output "{%}        {s}" import))
                            (cdr imports))
                  (format output  "){%}{%}{%}")))
              (print-file-form adjusted-form 1 output)
              (format output "){%}")))))))


  (method public (saved-form . rest)
    (apply form->string form rest))
  
  
  (method public (print-to . rest)
    (apply print-file-form form rest))
  
  
  (method (reset-modified?)
    (set-modified? #f))
  
  
  ;;;
  ;;;; Design
  ;;;
  
  
  (method public virtual (set-default-traits component traits-references (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t) (imports: imports #f))
    (let* ((owner (find-owner component)))
      (if (neq? owner reference)
          (designer-error "Default traits cannot be changed in non owner root {a}" (get-presentation-property~ reference))
        (when imports
          (add-import imports))
        (for-each (lambda (ref)
                    (setup-context~ ref form))
                  traits-references)
        (set-default-traits~ component traits-references)
        (set-property~ form default-traits: traits-references)
        (when (and design-events? (not-null? (get-designers~ component)))
          (fire-refresh component 'all))
        (set-modified? #t))))
  
  
  (method public virtual (set-name component name (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (owner (find-owner component))
           (effective (or branch reference))
           (effective-cpn (if (is? effective Branch) (get-trait~ effective) effective)))
      (if (and owner (neq? owner effective))
          (designer-error "Component cannot be renamed in non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective-cpn))
        (let ((form (find-form component branch))
              (old-name (get-name~ component))
              (old-presentation (get-presentation-property~ component)))
          (for-each-trait~ effective-cpn
            (lambda (trait)
              (let ((form (get-client-form~ trait)))
                (when form
                  (let* ((ancestry (component-ancestry component reference))
                         (component-form (owned-form form ancestry)))
                    (when (and component-form (neq? (get-action~ component-form) 'install))
                      (set-name~ component-form name)))))))
          (set-name~ component name)
          (set-name~ form name)
          (when (and design-events? (not-null? (get-designers~ component)))
            (fire-name-change component name old-name undoable?)
            (let ((presentation (get-presentation-property~ component)))
              (fire-presentation-change component presentation old-presentation undoable?))
            (let ((property (property-field (class-of component) 'name-info)))
              (fire-property-change branch component property name undoable?)))
          (set-modified? #t)))))
  
  
  (method public virtual (set-property component/path property value (old-value: old-value #f) (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t) (import: import #f))
    (let ((branch (target-branch trait)))
      ;; Quick fix for the special case of setting a property of the active trait
      (if (eq? component/path trait)
          (set-property component/path property value trait: #f design-events?: design-events? undoable?: undoable?)
        (let ((installed? (or (not branch) (is? branch Branch)))
              (path? (is? component/path Path)))
          (if (and path? (not installed?))
              (let ((form (follow-form~ component/path (if branch (get-client-form~ (get-trait~ branch)) form))))
                (set-property~ form property value))
            (let* ((component (if path? (follow-component~ component/path reference) component/path))
                   (property (if component (property-field (class-of component) property) property)))
              (assert property)
              ;; This validation should probably also be done in other operations...
              (when (and component (not installed?))
                (let ((creator-branch (get-creator-branch~ component)))
                  ;; This test is not 100% correct as the creator-branch can be any parent branch of branch
                  (when (and creator-branch (neq? branch (get-creator-branch~ component)))
                    (designer-error "Unable to modify an explicit trait using a component having a different branch creator"))))
              (receive (form restore) (find-form component branch restore?: #t)
                (receive (next-form next-restore) (find-next-branch branch component property)
                  (let ((old-value (or old-value (read-property component property)))
                        (remove?   (not (has-property?~ form property))))
                    (set-property~ form property value)
                    (when undoable?
                      (register-undo~ undoer
                        (lambda ()
                          (if remove?
                              (remove-property component/path property old-value)
                            (set-property component/path property old-value))))))
                  (when import
                    (add-import import))
                  (when (is? value Reference)
                    (setup-context~ value (get-form)))
                  (when installed?
                    (if (not next-form)
                        (let ((old-value (or old-value (read-property component property))))
                          (when (and restore (not (has-property?~ restore property)))
                            (set-property~ restore property old-value))
                          (if (null? (get-designers~ component))
                              (write-property component property value)
                            (let* ((fire-presentation? (and design-events? (presentation-property?~ component property)))
                                   (old-presentation (and fire-presentation? (get-presentation-property~ component))))
                              (write-property component property value)
                              (when design-events?
                                (when fire-presentation?
                                  (let ((presentation (get-presentation-property~ component)))
                                    (fire-presentation-change component presentation old-presentation undoable?)))
                                (fire-property-change branch component property value undoable?)))))
                      (when (and restore (not (has-property?~ restore property)))
                        (set-property~ restore property (get-property~ next-restore property)))
                      (set-property~ next-restore property value)))))))
          (set-modified? #t)))))
  
  
  (method (purge-form form)
    (when (and (eq? (get-action~ form) 'modify)
               (null? (get-properties~ form))
               (null? (get-children~ form)))
      (let ((parent (get-parent~ form)))
        (when parent
          (remove-child~ parent form)
          (purge-form parent)))))
  
  
  ;; This works well really only with branches because else we don't have restore information
  (method public virtual (remove-property component/path property default-value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (installed? (or (not branch) (is? branch Branch)))
           (path? (is? component/path Path))
           (component (if path? (follow-component~ component/path reference) component/path))
           (property (property-field (class-of component) property)))
      (assert property)
      (receive (form restore) (find-form component branch restore?: #t)
        (receive (next-form next-restore) (find-next-branch branch component property)
          (when (has-property?~ form property)
            (remove-property~ form property)
            (purge-form form)
            (let ((old-value (read-property component property)))
              (when undoable?
                (register-undo~ undoer
                  (lambda ()
                    (set-property component/path property old-value)))))
            (let ((value (if (not restore) default-value (get-property~ restore property))))
              (when installed?
                (if (not next-form)
                    (begin
                      (write-property component property value)
                      (when (and design-events? (not-null? (get-designers~ component)))
                        (fire-property-change branch component property value undoable?)))
                  (set-property~ next-restore property value))))
            (when restore
              (remove-property~ restore property))
            (set-modified? #t))))))
  
  
  ;; to fix
  (method public virtual (add-import import)
    (let ((imports (map listify (listify import)))
          (origin-form (get-context~ (get-form))))
      (set-locator~ origin-form (locator-add-imports (get-locator~ origin-form) imports))
      (let ((data (get-data~ origin-form)))
        (when data
          (for-each (lambda (import) (add-import~ data import)) imports)))))
  
  
  (method public virtual (add-child child parent (undoable?: undoable? #t) (form: form #f) (trait: trait #t) (name: name #f) (properties: properties '()) (tag-reference: tag-reference #f) (import: import '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (define (make-new-child-form parent-form)
      (let* ((child-origin-form (get-form~ child))
             (child-is-form? (and child-origin-form (is? (get-origin~ child-origin-form) File))))
        (new Form
          textual?: #f
          context: (get-context~ parent-form)
          action: (if tag-reference 'instantiate 'new)
          model: (cond (tag-reference #f)
                       (child-is-form? (get-name~ child-origin-form))
                       (else (category-name (class-of child))))
          tag-reference: tag-reference)))
    
    (let ((branch (target-branch trait)))
      (unless (eq? (get-parent~ child) parent)
        (set-parent~ child parent))
      (receive (parent-form restore) (find-form parent branch restore?: #t)
        (let ((child-form (or form (make-new-child-form parent-form))))
          (set-form~ child child-form)
          (add-form~ parent parent-form child-form)
          (when undoable?
            (register-undo~ undoer
              (lambda ()
                (remove-child child)))))
        (when restore
          (remember-creation~ restore self child))
        (when name
          (set-name child name trait: trait design-events?: #f))
        (set-creator~ child reference)
        (add-to-index~ reference (get-name~ child) child)
        (when properties
          (for-each-property (lambda (property value)
                               (set-property child property value trait: trait design-events?: design-events?))
                             properties))
        (when import
          (add-import import))
        ;; the two sexpr where toggled so that the
        ;; event occurs after the properties are set
        (when (and design-events? (not-null? (get-designers~ parent)))
          (fire-child-add child parent descendant?))
        (set-modified? #t)))
    child)
  
  
  (method public virtual (add-form form parent (trait: trait #t) (name: name #f) (imports: imports '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (with-atomic-undo~ undoer
      (lambda ()
        (let ((child (instantiate-form name #f form parent trait design-events? descendant? imports: imports)))
          (register-undo~ undoer
            (lambda ()
              (remove-child child)))
          child))))
  
  
  (method public virtual (apply-form form component (trait: trait #t) (design-events?: design-events? #t))
    (with-atomic-undo~ undoer
      (lambda ()
        (instantiate-content form component trait design-events?))))

  
  (method public virtual (remove-child child (trait: trait #t) (design-events?: design-events? #t))
    (let ((branch (target-branch trait)))
      (if (eq? child reference)
          (designer-error "The reference component cannot be removed")
        (let ((effective (or branch reference))
              (owner (find-owner child)))
          ;; the (and owner) part is a try
          (if (and owner (neq? owner effective))
              (designer-error "Component cannot be removed from non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective))
            (let* ((name (get-name~ child))
                   (parent (get-parent~ child))
                   (parent-form (find-form parent branch))
                   (form (find-form child branch)))
              (define (purge-references form)
                (when form
                  (let* ((parent-ancestry (component-ancestry parent reference))
                         (parent-form (owned-form form parent-ancestry)))
                    (when parent-form
                      (let ((child-form (find-child~ parent-form name)))
                        (when child-form
                          (remove-child~ parent-form child-form)))))))
              
              ;; Remove component from branch restore-form
              (when (is? effective Branch)
                (let* ((restore-form (get-restore-form~ effective))
                       (remove-form (find-by~ restore-form (lambda (form)
                                                             (and (eq? (get-action~ form) 'remove)
                                                                  (eq? (get-component~ form) child))))))
                  (remove-child~ restore-form remove-form)))
              
              (for-each-trait~ (if (is? effective Branch) (get-trait~ effective) effective)
                (lambda (trait)
                  (purge-references (get-client-form~ trait))))
              (register-undo~ undoer
                (lambda ()
                  (add-child child parent form: form)))
              (set-parent~ child #f)
              (remove-child~ parent-form form)
              (when (and design-events? (get-designers~ child))
                (fire-child-remove child parent))
              (set-modified? #t)))))))
  
  
  (method public virtual (remove-components components)
    (with-atomic-undo~ undoer
      (lambda ()
        (for-each remove-child components))))
  
  
  (method public (remove-children parent (trait: trait #t) (design-events?: design-events? #t))
    (for-each (lambda (child)
                (remove-child child trait: trait design-events?: design-events?))
              (get-children~ parent)))
  
  
  (method public (relocate-component component destination (trait: trait #t) (design-events?: design-events? #t))
    (relocate-components (list component) destination trait: trait design-events?: design-events?))
  
  
  (method public virtual (relocate-components components destination (trait: trait #t) (design-events?: design-events? #t))
    (let ((destination-form (get-form~ destination)))
      (for-each (lambda (component)
                  (let ((parent (get-parent~ component))
                        (form (get-form~ component)))
                    (remove-child component trait: trait)
                    (add-child component destination form: form trait: trait)))
                components)
      (set-modified? #t)))
  
  
  (method public (can-relocate-component? component destination)
    (and (addable-class?~ destination (class-of component))
         (component-owned-by-reference? component)))
  
  
  (method public (can-relocate-components? components destination)
    (every? (lambda (component)
              (can-relocate-component? component destination))
            components))
  
  
  (method public virtual (transfer-components components destination (trait: trait #t))
    (let* ((components (remove-redundant-descendants components))
           (parcels (package-components components))
           (name-resolution (verify-name-conflicts parcels destination)))
      (delete-components components trait: trait)
      (prog1 (instantiate-parcels parcels destination trait: trait name-resolution: name-resolution design-events?: #t descendant?: #f)
        (set-modified? #t))))
  
  
  (method public virtual (send-before child target (trait: trait #t))
    (unless (eq? child target)
      (let* ((branch (target-branch trait))
             (parent (get-parent~ child))
             (parent-form (find-form parent branch))
             (child-form (find-form child branch))
             (target-form (and target (find-form target branch))))
        (send-before~ child target)
        (send-child-before~ parent-form child-form target-form)
        (fire-send-before child parent target)
        (set-modified? #t))))
  
  
  (method public (send-to-back child (trait: trait #t))
    (send-before child (first-child~ (get-parent~ child)) trait: trait))
  
  
  (method public (bring-to-front child (trait: trait #t))
    (send-before child #f trait: trait))
  
  
  ;; This is not a 100% complete solution as this for instance will
  ;; not restore the correct property values as remove-property would...
  (method public virtual (purge-trait component (trait: trait #t) (design-events?: design-events? #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ component))
           (parent-form (find-form parent branch)))
      (receive (form restore-form) (find-form component branch restore?: #t)
        (install-form~ component restore-form component #f #f)
        (remove-child~ parent-form form))))
  
  
  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (cut-components components)
    (let ((components (remove-redundant-descendants components)))
      (copy-components components)
      (delete-components components)))
  
  
  (method public virtual (copy-components components)
    (let ((components (remove-redundant-descendants components)))
      (let ((text (copy-components-text components)))
        (set-clipboard-text text format: 'jazz-parcels))))
  
  
  (method public (copy-components-text components (trait: trait #f))
    (let ((output (open-output-string))
          (parcels (package-components components trait: trait)))
      (format output "(")
      (for-each (lambda (parcel)
                  (format output "~{{a} " (category-name (class-of parcel)))
                  (format output "{a} " (get-process-id~ parcel))
                  (format output "{a} " (get-object-id~ parcel))
                  (format output "{a} " (get-imports~ parcel))
                  (format output "(")
                  (for-each (lambda (form)
                              (print-form form 0 output))
                            (get-content~ parcel))
                  (format output ")")
                  (format output "}"))
                parcels)
      (format output ")")
      (get-output-string output)))
  
  
  (method public virtual (paste-clipboard parent (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcels (get-jazz-parcels)))
      (paste-parcels parcels parent trait: trait design-events?: design-events?)))
  
  
  (method public virtual (paste-parcels parcels parent (trait: trait #t) (design-events?: design-events? #t) (reporter: reporter #f))
    (let* ((parent (determine-paster~ parent))
           (name-resolution (verify-name-conflicts parcels parent)))
      (prog1 (instantiate-parcels parcels parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: #f reporter: reporter)
        (set-modified? #t))))
  
  
  (method public virtual (paste-properties components (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcel (car (get-jazz-parcels))))
      (paste-parcel-properties parcel components trait: trait design-events?: design-events?)))
  
  
  (method public (paste-parcel-properties parcel components (trait: trait #t) (design-events?: design-events? #t))
    (let ((forms (get-content~ parcel)))
      (for-each (lambda (component)
                  (for-each (lambda (form)
                              (instantiate-properties component (get-properties~ form) trait design-events?))
                            forms))
                components)
      (set-modified? #t)))
  
  
  (method public virtual (delete-components components (trait: trait #t) (design-events?: design-events? #t))
    (let ((components (remove-redundant-descendants components)))
      (for-each (lambda (component)
                  (delete-component component trait: trait design-events?: design-events?))
                components)))
  
  
  (method public virtual (delete-component component (trait: trait #t) (design-events?: design-events? #t))
    (remove-child component trait: trait design-events?: design-events?))
  
  
  ;; For some operations like cut, copy, delete and move, having a component that
  ;; is a descendant of another one doesn't make sense and can lead to problems...
  (method (remove-redundant-descendants components)
    components
    ;; waiting for a bug fix in the tree selection update that this has uncovered
    @wait
    (collect-if (lambda (component)
                  (not (some? (lambda (target)
                                (and (neq? component target)
                                     (has-parent?~ component target)))
                              components)))
                components))
  
  
  ;;;
  ;;;; Package
  ;;;
  
  
  (method public (package-component component (trait: trait #f))
    (car (package-components (list component) trait: trait)))
  
  
  (method public (package-components components (trait: trait #f))
    ;; Allows copying the reference component
    (define (replace-master old-master component)
      (if (eq? (get-action~ old-master) 'install)
          (let ((master (copy-object~ old-master #t))
                (class-name (get-name~ (class-of component))))
            (receive (module models) (split-locator class-name)
              (let* ((model (car models))
                     (reference (deserialize-runtime-reference (list 'module-private class-name))))
                (set-action~ master 'new)
                (set-model~ master model)
                (setup-context~ master master)
                (set-locator~ master (locator-add-reference (get-locator~ master) model reference))
                master)))
        old-master))
    
    ;; Modifying the master from its parent is equivalent to an install
    (define (modify->install form)
      (let ((new-form (copy-object~ form #f)))
        (when (eq? (get-action~ new-form) 'modify)
          (set-action~ new-form 'install)
          (set-name~ new-form #f))
        new-form))
    
    (define (package-component component)
      (let ((original-forms (let ((forms (if (eq? reference component) (list form) (component-forms component))))
                              ;; This is when the form is not associated to a class. Does not work with traits
                              (if (null? forms) (list (owned-form form (component-ancestry component reference))) forms))))
        (if (not original-forms)
            (designer-error "Unable to find owner for {t}" component)
          (let* ((imports (map listify (apply union (map (lambda (form) (form-imports form)) original-forms))))
                 (forms (cons (replace-master (car original-forms) component)
                              (map modify->install (cdr original-forms)))))
            (new jazz.designer.ui:Component-Parcel (current-process-id) (object->serial component) imports forms)))))
    
    (map package-component components))
  
  
  ;;;
  ;;;; Instantiate
  ;;;
  
  
  (method public virtual (instantiate-parcels parcels parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f) (reporter: reporter #f))
    (map (lambda (parcel)
           (when reporter
             (user-message~ reporter "Pasting {a}..." (get-master-name~ parcel)))
           (prog1 (instantiate-parcel parcel parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: descendant?)
             (when reporter
               (step-it~ reporter))))
         parcels))
  
  
  (method public virtual (instantiate-parcel parcel parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (define (set-context-recursive form context)
      (set-context~ form context)
      (for-each (lambda (child) (set-context-recursive child context)) (get-children~ form)))
    
    (let* ((forms (get-content~ parcel))
           (master (car forms))
           (name (get-name~ master)))
      (if (not (eq? (get-action~ master) 'new))
          (designer-error "Master form's action must be 'new")
        (let* ((brothers (get-children~ parent))
               (domain (map get-name~ brothers))
               (equal (sort-predicate 'equal))
               (conflict? (and name (member? name domain test: equal))))
          (when conflict?
            (case name-resolution
              ((rename)
               (set! name (unique-name name domain)))
              ((override)
               (let ((conflicts (name-conflicts (list name) brothers)))
                 (delete-components conflicts trait: trait))))))
        (let ((imports (get-imports~ parcel)))
          (let ((locator (imports-locator imports)))
            (for-each (lambda (f)
                        (set-locator~ f locator)
                        (set-context-recursive f f))
                      forms))
          (let ((component (instantiate-form name name-resolution master parent trait design-events? descendant? imports: imports)))
            (for-each (lambda (form)
                        (instantiate-form name #f form component trait design-events? descendant?))
                      (cdr forms))
            component)))))
  
  
  (method public virtual (instantiate-form name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component name name-resolution form parent trait design-events? descendant? imports: imports)))
      (when component
        (instantiate-content form component trait design-events?))))
  
  
  (method public virtual (instantiate-content form component trait design-events?)
    (instantiate-properties component (get-properties~ form) trait design-events?)
    (instantiate-children component (get-children~ form) trait design-events?)
    component)

  
  (method public virtual (instantiate-component name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((action (get-action~ form)))
      (case action
        ((new) (instantiate-new-component name form parent trait design-events? descendant? imports: imports))
        ((modify locate) (find-to-modify~ parent (get-name~ form) (sort-predicate 'equal)))
        ((install) parent)
        (else (designer-error "Unsupported form action: {t}" action)))))
  
  
  (method public virtual (instantiate-new-component name form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component~ form parent: parent)))
      (add-child component parent trait: trait name: name design-events?: design-events? descendant?: descendant? import: imports)
      component))
  
  
  (method public virtual (instantiate-properties component properties trait design-events?)
    (for-each-property (lambda (property value)
                         (unless (initer-property?~ component property)
                           (set-property component property value trait: trait design-events?: design-events? undoable?: #f)))
                       properties))

  
  (method public virtual (instantiate-children component children trait design-events?)
    (for-each (lambda (form)
                (instantiate-form (get-name~ form) #f form component trait design-events? #t))
              children))
  
  
  ;;;
  ;;;; Unique
  ;;;
  
  
  (method protected virtual (unique-name name domain)
    (let ((unique-name (unique-domain-name (->string name) (map ->string domain) separator: (unique-separator))))
      (if (symbol? name)
          (string->symbol unique-name)
        unique-name)))
  
  
  (method protected virtual (unique-separator)
    "_")
  
  
  ;;;
  ;;;; Conflicts
  ;;;
  
  
  (definition (name-conflicts names children)
    (let ((equal (sort-predicate 'equal)))
      (collect-if (lambda (child)
                    (let ((child-name (get-name~ child)))
                      (and child-name
                           (some? (lambda (name)
                                    (equal child-name name))
                                  names))))
                  children)))
  
  
  (method public (verify-name-conflicts parcels destination)
    (define (confirm-name-resolution children conflicts)
      (define (present-conflicts header conflicts)
        (let ((fact (new List-Factory)))
          (put~ fact header)
          (for-each (lambda (conflict)
                      (put~ fact `(<bulleted> ,(->string (get-name~ conflict)))))
                    conflicts)
          (get-output~ fact)))
      
      (if (every? (lambda (parcel)
                    (let ((equal (sort-predicate 'equal))
                          (process-id (get-process-id~ parcel))
                          (component-id (get-object-id~ parcel))
                          (name (get-master-name~ parcel)))
                      (and (= process-id (current-process-id))
                           (some? (lambda (child)
                                    (and (= component-id (object->serial child))
                                         (equal name (get-name~ child))))
                                  children))))
                  parcels)
          'rename
        (let* ((header "The following conflicts where detected. Override destination?")
               (text `(<span> ,@(present-conflicts header conflicts)))
               (code (message-box text type: 'question)))
          (case code
            ((yes) 'override)
            ((no) (signal-cancel))))))
    
    (let* ((names (map get-master-name~ parcels))
           (children (get-children~ destination))
           (conflicts (name-conflicts names children)))
      (when (not-null? conflicts)
        (confirm-name-resolution children conflicts))))
  
  
  ;;;
  ;;;; View
  ;;;
  
  
  ;; This special support for views is not clean, but it is better
  ;; than having it directly inside add-child where it was before!
  (method public virtual (add-view child parent . rest)
    (bind-keywords ((name #f) (position #f) (centered? #f) (visible? #t) . others) rest
      (with-atomic-undo~ undoer
        (lambda ()
          (apply add-child child parent name: name others)
          (when position
            (set-property child 'position position))
          (when centered?
            (center-child child))
          (when visible?
            (set-visible?~ child #t))
          (set-modified? #t)))))
  
  
  (method public (center-child child)
    (let ((size (get-size~ child)))
      (move-figure~ child (- (quotient (get-width~ size) 2)) (- (quotient (get-height~ size) 2)))
      (set-property child 'position (get-position~ child))))
  
  
  (method public (cascade-view-position view initial)
    (when (is? view View)
      (let* ((positions (map get-position~ (remove view (get-views~ (get-parent~ view)))))
             (pos (cascade-position initial {Distance 10 10} positions)))
        (safe-set-property view 'position pos))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  ;; package modifier is for tests
  (method package (find-form component branch (restore?: restore? #f) (error?: error? #t))
    (define (embed-form form ancestry)
      (for-each (lambda (cpn)
                  (let ((children (get-children~ form))
                        (cpn-form (get-form~ cpn)))
                    (if (not cpn-form)
                        (embed-new-form form #f)
                      (if (memq? cpn-form children)
                          (set! form cpn-form)
                        (let ((restore-form (find-in children cpn key: (lambda (form) (and (is? form Restore-Form) (get-component~ form))))))
                          (if restore-form
                              (set! form restore-form)
                            (let ((name (get-name~ cpn)))
                              (if (not name)
                                  (designer-error "Component {t} must be named to allow modification" cpn)
                                (let ((subform (find-in children name key: get-name~ test: equal?)))
                                  (if (not subform)
                                      (set! form (embed-new-form form name))
                                    (set! form subform)))))))))))
                ancestry)
      form)
    
    (define (embed-new-form form name)
      (let ((subform (new Form action: 'modify context: (get-context~ form) name: name)))
        (set-parent~ subform form)
        subform))
    
    (let* ((ancestry (component-ancestry component reference))
           (trait-form (if branch (get-client-form~ (get-trait~ branch)) form))
           (restore-form (and restore? branch (get-restore-form~ branch)))
           (form (embed-form trait-form ancestry))
           (restore (and restore-form (embed-form restore-form ancestry))))
      (if (and error? (not form))
          (designer-error "Unable to locate target form")
        (if restore?
            (values form restore)
          form))))
  
  
  (method (target-branch trait)
    (cond ((eq? trait #t) (get-active-branch~ reference))
          ((is? trait Path) (follow-component~ trait reference))
          (else (find-trait-branch~ reference trait))))
  
  
  ;;;
  ;;;; Owner
  ;;;
  
  
  (method public virtual (component-owned-by-reference? component)
    (component-owned? component form reference))
  
  
  (method public (component-in-descendants? component)
    (component-in-reference-descendants? component reference))
  
  
  (method public (descendant-owned-by-reference? component)
    (and (component-in-descendants? component)
         (component-owned-by-reference? component)))
  
  
  (method public (find-owner component (property #f))
    (let ((ancestry (component-ancestry component reference)))
      (continuation-capture
        (lambda (return)
          (iterate-branch-spine~ reference
            (lambda (owner form)
              (when form
                (let ((form (owned-form form ancestry)))
                  (when (and form
                             (or (and (not property) (eq? (get-action~ form) 'new))
                                 (and property (has-property?~ form property))))
                    (continuation-return return owner))))))
          #f))))
  
  
  (method (find-next-branch branch component property)
    (if (not branch)
        (values #f #f)
      (let ((lower (get-branches~ (or branch reference)))
            (ancestry (component-ancestry component reference)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (branch)
                        (let ((client-form (get-client-form~ branch)))
                          (when client-form
                            (let ((form (owned-form client-form ancestry)))
                              (when (and form (has-property?~ form property))
                                (continuation-return return (values form (owned-form (get-restore-form~ branch) ancestry))))))))
                      lower)
            (values #f #f))))))
  
  
  ;;;
  ;;;; Value
  ;;;
  
  
  ;; Until a fully generic solution, these methods implement the following special case:
  ;; - the trait must be the owner of the property (i.e. have set it)
  
  
  (method public (get-name path (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-name~ (follow-form~ path form))))
  
  
  (method public (get-property path property (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-property~ (follow-form~ path form) property)))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method public (edit-form (workspace: workspace #f))
    (let ((appl (get-application))
          (origin (get-origin~ form)))
      (define (find-entry locator)
        ((module-ref 'jazz.project 'locator->entry) locator))
      
      (cond ((not origin)
             (bell))
            ((file? origin)
             (edit-document~ appl origin class: Jazz-Text-View workspace: workspace))
            ((find-entry (get-name~ origin)) => (lambda (entry) (edit~ entry workspace: workspace)))
            (else
             (receive (module class) (break-reference (get-name~ origin))
               (edit-document~ appl (find-unit-source module) class: Jazz-Text-View workspace: workspace))))))
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method public (safe-set-property . rest)
    (with-safe-design
      (lambda ()
        (apply set-property rest))))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-designer-listener listener)
    (set! listeners (add-listener listener listeners)))
  
  
  (method public (remove-designer-listener listener)
    (set! listeners (remove-listener listener listeners)))

  
  (method (process-name-change component name old-name undoable?)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :name-change self component: component name: name old-name: old-name undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-presentation-change component presentation old-presentation undoable?)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :presentation-change self component: component presentation: presentation old-presentation: old-presentation undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-property-change branch component property value undoable?)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :property-change self branch: branch component: component property: property value: value undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-add child parent descendant?)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :child-add self child: child parent: parent descendant?: descendant?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-remove child parent)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :child-remove self child: child parent: parent)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (process-child-relocate child parent destination)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :child-relocate self child: child parent: parent target: destination)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-send-before child parent target)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :send-before self child: child parent: parent target: target)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-refresh component what)
    (when (not-null? listeners)
      (let ((evt (make-event Designer-Event :refresh self component: component what: what)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-user-event event)
    (when (not-null? listeners)
      (for-each (lambda (listener)
                  (invoke~ listener self event))
                listeners))))


;;;
;;;; Designer-Event
;;;


(class Designer-Event extends Event))
