;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Properties Tree
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.designer.card.Properties-Tree jazz


(import (jazz.designer)
        (jazz.graphic)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view))


(definition Filter-Width
  20)


(class undocumented Properties-Tree extends Tree-View


  (property filter           initialize 'categorized accessors explicit)
  (property filter-locked?   initialize #f           accessors generate)
  (property filter-visible?  initialize #t           accessors generate)
  (property property-handler initialize #f           accessors generate)
  

  (form
    (<install>                            filled-column: value draggable?: #t multiple-selection?: #f selection-mode: row auto-expand/collapse?: #t focused-on-descendants?: #t portfolio: :images context-menu-handler: {Event-Handler :form on-context-menu}
      (<Property-Column>   name: property title: "Property" width: 140 toplevel-controls?: #f)
      (<Value-Column>      name: value    title: "Value" width: 192 justification: (2 2))
      (<Tree-Image-Column> name: owner    title: "!" width: 25 justification: center)))


  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-card)
    (child 5))
  
  
  (method public (get-editor)
    (get-editor~ (get-card)))
  
  
  (method public (get-client)
    (get-client~ (get-card)))
  
  
  (method public (get-designer)
    (get-designer~ (get-card)))
  

  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (double-click pos)
    (let ((row (get-selected-row)))
      (when row
        (double-click~ row (acquire~ row self pos)))))
  
  
  (method (on-context-menu evt)
    (let ((sender (get-sender~ evt))
          (pos (get-position~ evt)))
      (cond ((is? sender Tree-Header)
             (unless (or filter-locked? (not filter-visible?))
               (let ((header-height 16))
                 (when (and (< (get-h~ pos) Filter-Width) (< (get-v~ pos) header-height))
                   (track-popup-menu~ sender (new Filter-Menu client: self) (new Point 5 header-height))))))
            (else
             (context-menu pos)))))
  
  
  (method (new-property-menu client)
    (let* ((menu (new Property-Menu client: self))
           (any (car client))
           (creator (get-creator~ any)))
      (if (branch-installed?~ creator)
          (begin
            (set-visible?~ (locate~ menu 'end-consolidate-group) #f)
            (set-visible?~ (locate~ menu 'distribute) #f))
        (set-visible?~ (locate~ menu 'consolidate) #f)
        (set-visible?~ (locate~ menu 'end-consolidate-group) #f))
      (layout-menu~ menu)
      menu))
  
  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method override (focus-gained)
    (nextmethod)
    (focus-delegate))
  
  
  (method override (focus-delegate)
    (let ((row (selected-row)))
      (when (and row (editable?~ row))
        (editor-focus-delegate~ row))))
  
  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method protected (save-edition)
    (let ((row auto-expanded-row))
      (when (and row (is? row Value-Row) (in-edition?~ row))
        (save-edition~ row))))


  ;;;
  ;;;; Handler
  ;;;

  
  (method public (notify-property-change property)
    (when property-handler
      (invoke-handler self property-handler (new Event :property-change self property: property))))
  
  
  ;;;
  ;;;; Client
  ;;;
  
  
  (method public (client-update)
    (with-update-locked
      (lambda ()
        (close-auto-expanded)
        (preserving-update))))
  
  
  (method (find-property-index target)
    (continuation-capture
      (lambda (return)
        (for-each-visible-row
          (lambda (row rank)
            (when (is? row Value-Row)
              (let ((property (get-property~ row)))
                (when (if (symbol? target)
                          (eq? (field-name property) target)
                        (eq? property target))
                  (continuation-return return rank))))))
        #f)))

  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method (preserving-update)
    (define (empty-client?)
      (let ((client (get-client)))
        (or (not client) (null? client))))
    
    (define (get-client-default-property)
      (let ((client (get-client)))
        (when (= 1 (length client))
          (let ((component (car client)))
            (when (is? component Component)
              (let ((name (get-default-property~ component)))
                (when name
                  (category-field (class-of component) name))))))))
    
    (if (empty-client?)
        (remove-every-row)
      (let ((selected (selected-property))
            (default (get-client-default-property)))
        (update)
        (let ((index (if selected (or (find-property-index selected) (find-property-index default)) (find-property-index default))))
          (when index
            (set-single-selection index auto-expand?: #f))))))


  (method (update)
    (define (insert-properties client any editor designer father properties)
      (for-each (lambda (property)
                  (if (pair? property)
                      (for-each (lambda (property)
                                  (insert-property client any editor designer father property 'collapsed #f))
                                property)
                    @wait-completed
                    (bind (title . properties) property
                      (let ((row (add-row father: father state: 'expanded children: (list (new Tree-Node title: title image: {Image-Resource "Info"}) (new Tree-Label) (new Tree-Image)))))
                        (insert-properties client any editor designer row properties)))
                    (insert-property client any editor designer father property 'collapsed #f)))
                properties))
    
    (define (insert-property client any editor designer father property state position)
      (let* ((domain (property-domain~ any property))
             (category (get-category~ (class-of any) property))
             (row (new Domain-Row domain: domain))
             (image (get-image~ category))
             (values (map (lambda (component) (read-property component property)) client))
             (presented (map (lambda (value) (present~ row value)) values))
             (creator (get-creator~ any))
             (trait (and creator (get-active-trait~ creator)))
             ;; temp patch because the root object doesn't have a creator...
             (changed? (if (or (not creator) (not editor)) #f (find-changed-property~ editor trait any property)))
             (uniform? (or (<= (length values) 1) (apply string=? presented)))
             (title (property-presentation~ (class-of any) property))
             (node (new Tree-Node title: title image: image color: (if uniform? (if changed? {Color Dark-Red} #f) {Color Medium-Gray})))
             (label (new Tree-Label))
             (owner (new Tree-Image image: (owner-image designer client category property))))
        (set-parent~ row self)
        (set-row-height~ row 17)
        (set-children~ row (list node label owner))
        (set-property~ row property)
        (set-value~ row (car values))
        (set-title~ label (car presented))
        (set-color~ label (if uniform? #f {Color Medium-Gray}))
        (add-row father: father state: state row: row position: position)
        row))
    
    (define (get-client-properties client editor)
      (when client
        (apply intersection (map (lambda (component)
                                   (when (is? component Component)
                                     (get-component-properties component editor)))
                                 client))))
    
    (define (get-component-properties component editor)
      (filter-by-rights component editor
        (get-filtered-properties~ component filter: filter)))
    
    (let* ((client (get-client))
           ;; temp fix. need to investigate. if i remember correctly
           ;; client is actually a list of clients and so the problem
           ;; would be a wrong default value of #f instead of '()
           (any (if (or (not client) (null? client)) #f (car client)))
           (editor (get-editor))
           (designer (get-designer))
           (properties (get-client-properties client editor)))
      (remove-every-row)
      (with-update-locked
        (lambda ()
          ;; see above comment for this test too
          (when properties
            (insert-properties client any editor designer #f properties))))))
  
  
  (method (owner-image designer client category property)
    (when (and designer (= 1 (length client)) (/= (get-rank~ category) 0))
      (let* ((component (car client))
             (owner (find-owner~ designer component property)))
        (cond ((is? owner Trait) (trait-owner-image))
              ((eq? owner (get-reference~ designer)) (root-owner-image))
              (else (default-owner-image))))))
  
  
  (method protected virtual (default-owner-image)
    #f)
  
  
  (method protected virtual (root-owner-image)
    {Image-Resource "OwnerRoot"})
  
  
  (method protected virtual (trait-owner-image)
    {Image-Resource "OwnerTrait"})
  
  
  (method protected (reset-modified-properties)
    (for-each-visible-row
      (lambda (row rank)
        (when (is? row Value-Row)
          (let ((node (car (get-children~ row))))
            (when (get-color~ node)
              (set-color~ node #f)
              (invalidate-cell (new Cell rank 0))))))))
  
  
  ;;;
  ;;;; Rights
  ;;;
  
  
  (definition (filter-by-rights component editor properties)
    (let ((rights (and editor (get-rights~ editor))))
      (if (not rights)
          properties
        (let* ((reference (get-client~ editor))
               (component-rights (find-component-rights~ rights reference component)))
          (when component-rights
            (filter-properties~ component-rights properties))))))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method (selected-row)
    (let ((row (get-selected-row)))
      (when (is? row Value-Row)
        row)))
  
  
  (method (selected-property)
    (let ((row (selected-row)))
      (when row
        (get-property~ row))))
  
  
  (method public (select-property property)
    (let ((rank (find-property-index property)))
      (if (not rank)
          (set-selection '() auto-expand?: #f generate-event?: #f)
        (set-single-selection rank auto-expand?: #f generate-event?: #f))))

  
  ;;;
  ;;;; Property
  ;;;
  
  
  (method (consolidate-property)
    (let* ((client (get-client))
           (code (message-box (format "Consolidate value{a} to root and lose values in other traits?" (format-plural (length client))) type: 'confirmation)))
      (when (eq? code 'yes)
        (let ((row (selected-row)))
          (save-edition~ row)
          (let ((property (get-property~ row))
                (designer (get-designer)))
            (for-each (lambda (component)
                        (let ((creator (get-creator~ component))
                              (value (read-property component property)))
                          (for-each-trait~ creator
                            (lambda (trait)
                              (remove-property~ designer component property #f trait: trait)))
                          (set-property~ designer component property value trait: #f)))
                      client))
          (set-edited-modified?~ row #f)))))
  
  
  (method (distribute-property)
    (let* ((client (get-client))
           (code (message-box (format "Distribute value{a} onto traits and lose their current values?" (format-plural (length client))) type: 'confirmation)))
      (when (eq? code 'yes)
        (let ((row (selected-row)))
          (save-edition~ row)
          (let ((property (get-property~ row))
                (designer (get-designer)))
            (for-each (lambda (component)
                        (let ((creator (get-creator~ component))
                              (value (read-property component property)))
                          (for-each-trait~ creator
                            (lambda (trait)
                              (set-property~ designer component property value trait: trait)))))
                      client))
          (set-edited-modified?~ row #f)))))
  

  ;;;
  ;;;; Sort
  ;;;

  
  (method override (header-click column)
    @w
    (let ((row auto-expanded-row))
      (when (and row (is? row Value-Row) (in-edition?~ row))
        (close-auto-expanded)
        (end-edition~ row)))
    (nextmethod column))

  
  ;;;
  ;;;; Filter
  ;;;


  (method public (get-filter)
    filter)


  (method public (set-filter flt)
    (when (neq? flt filter)
      (set! filter flt)
      (invalidate-column-header~ (get-header) node-column)
      (update)))


  (method public (toggle-filter)
    (case filter
      ((all)         (set-filter 'infos))
      ((infos)       (set-filter 'properties))
      ((properties)  (set-filter 'handlers))
      ((handlers)    (set-filter 'categorized))
      ((categorized) (set-filter 'all))))

  
  ;;;
  ;;;; Design
  ;;;
  
  
  (method public (property-change component property value)
    (let ((rank (find-property-index property)))
      (when rank
        (let ((row (get-row rank)))
          (update~ row value)
          (let* ((cell (new Cell rank 2))
                 (data (get-cell-data cell)))
            (set-image~ data (owner-image (get-designer) (get-client) (get-category~ (class-of component) property) property))
            (invalidate-cell cell)))))))


;;;
;;;; Property-Column
;;;


(class Property-Column extends Tree-Node-Column
  
  
  (slot filter-down? initialize #f)
  
  
  (method override (draw-header surface context lh lv h v width height sorted spaced? flat? enabled?)
    (if (not (get-filter-visible?~ parent))
        (nextmethod surface context lh lv h v width height sorted spaced? flat? enabled?)
      (draw-header-at surface lh lv h v Filter-Width height "" filter-down? #f spaced? flat? enabled?)
      (with-clipper~ surface {Rect 1 1 17 14}
        (lambda ()
          (draw-image-at surface context (+ h 1) v (get-filter-image))))
      (draw-header-at surface lh lv (+ h Filter-Width) v (- width Filter-Width) height (localize (get-column-title)) down? sorted spaced? flat? enabled?)))
  
  
  (method (draw-image-at surface context h v image)
    (let ((offset (if filter-down? 1 0)))
      (draw-opaque-image~ (get-images-portfolio~ (get-application)) surface context image {Color Medium} (+ h offset) (+ v offset))))
  
  
  (method override (header-down pos)
    (if (not (get-filter-visible?~ parent))
        (nextmethod pos)
      (let ((in-filter? (< (get-h~ pos) Filter-Width)))
        (if (get-filter-locked?~ parent)
            (unless in-filter?
              (nextmethod pos))
          (if in-filter?
              (set! filter-down? #t)
            (set! down? #t))
          (invalidate-column-header~ (get-header~ parent) self)))))
  
  
  (method override (header-up pos)
    (if (not (get-filter-visible?~ parent))
        (nextmethod pos)
      (if (get-filter-locked?~ parent)
          (unless (< (get-h~ pos) Filter-Width)
            (nextmethod pos))
        (let ((filter? filter-down?))
          (set! down? #f)
          (set! filter-down? #f)
          (when filter?
            (toggle-filter~ parent))
          (invalidate-column-header~ (get-header~ parent) self)
          (when (not filter?)
            (header-click~ parent self))))))
  
  
  (method override (draw-data surface context row data width height)
    (draw-background surface context row data width height)
    (draw-level surface row data width height)
    (draw-image surface context row data width height)
    (draw-title surface context row data 0 0 width height))
  
  
  (method (get-filter-image)
    (case (get-filter~ parent)
      ((all) {Image-Resource "All"})
      ((infos) {Image-Resource "Info"})
      ((properties) {Image-Resource "Property"})
      ((handlers) {Image-Resource "Handler"})
      ((categorized) {Image-Resource "UpdateCatalog"})))
  
  
  (method (get-column-title)
    (case (get-filter~ parent)
      ((all) "Property")
      ((infos) "Info")
      ((properties) "Property")
      ((handlers) "Handler")
      ((categorized) "Property"))))


;;;
;;;; Value-Column
;;;


(class Value-Column extends Tree-Label-Column
  
  
  (method override (complete-mouse-down cell pos shift? control?)
    (let* ((auto? (get-auto-expand/collapse?~ parent))
           ;; get row before super complete-mouse-down changes anything...
           (row (and auto? (get-row~ parent (get-line~ cell)))))
      (nextmethod cell pos shift? control?)
      (when auto?
        (auto-expand/collapse~ parent row))))
  
  
  (method override (draw-data surface context row data width height)
    (when (is? row Value-Row)
      (let ((value (get-value~ row)))
        (draw-data~ row surface context value self row data width height)))))


;;;
;;;; Filter-Menu
;;;


(class Filter-Menu extends Context-Menu
  
  
  (form
    (<install>
      (<Radio-Item>     name: all         title: "All" icon: {Image-Resource "All"} action-handler: {Event-Handler :form on-action})
      (<Separator-Item>)
      (<Radio-Item>     name: infos       title: "Infos" icon: {Image-Resource "Info"} action-handler: {Event-Handler :form on-action})
      (<Radio-Item>     name: properties  title: "Properties" icon: {Image-Resource "Property"} action-handler: {Event-Handler :form on-action})
      (<Radio-Item>     name: handlers    title: "Handlers" icon: {Image-Resource "Handler"} action-handler: {Event-Handler :form on-action})
      (<Separator-Item>)
      (<Radio-Item>     name: categorized title: "Categorized" icon: {Image-Resource "UpdateCatalog"} action-handler: {Event-Handler :form on-action})))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set-selected?~ (locate (get-filter~ client)) #t))
  
  
  (method (on-action evt)
    (let ((filter (get-name~ (get-sender~ evt))))
      (set-filter~ client filter))))


;;;
;;;; Property-Menu
;;;


(class Property-Menu extends Context-Menu
  
  
  (form
    (<install>
      (<Radio-Item>     name: consolidate           title: "Consolidate To Root" icon: {Image-Resource "ConsolidateProperty"} action-handler: {Event-Handler :form on-consolidate})
      (<Separator-Item> name: end-consolidate-group)
      (<Radio-Item>     name: distribute            title: "Distribute Onto Traits" icon: {Image-Resource "DistributeProperty"} action-handler: {Event-Handler :form on-distribute})))
  
  
  (method (on-consolidate evt)
    (consolidate-property~ client))
  
  
  (method (on-distribute evt)
    (distribute-property~ client))))
