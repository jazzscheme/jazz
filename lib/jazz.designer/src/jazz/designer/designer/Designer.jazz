;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Designer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.designer.designer.Designer jazz


(import (jazz.catalog)
        (jazz.designer)
        (jazz.designer.view)
        (jazz.editor.jazz)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.system)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view))


(class Designer extends Object
  
  
  (slot form      initialize #f accessors generate)
  (slot reference initialize #f getter generate)
  (slot listeners initialize '())
  (slot modified? initialize #f accessors generate)

  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (initialize (form: form #f) (reference: reference #f))
    (define (setup-form frm)
      (if (not frm)
          (set! form~self (new Form textual?: #f origin: (class-of reference) action: 'new model-name: 'install))
        (let ((origin (get-origin~ frm)))
          (if (file? origin)
              (setup-file-form frm)
            (setup-class-form frm)))))
    
    ;; Setting form to a copy until saving is a tempting approach,
    ;; but fails because we absolutly need pointer equality as a test
    ;; for embed-form to work correctly with anonymous forms.
    ;; So the approach taken will be more like relational databases
    ;; where we modify the database directly but keep a log of
    ;; transactions in order to be able to rollback changes (and it
    ;; makes lots of sense to, because a designer is really the interface
    ;; by which Jazz's object-oriented databases are updated!).
    ;;
    ;; Or maybe simply take a copy before the first modification is made
    ;; (lazy approach) and if we need to rollback, set the original form
    ;; to the copy.
    (define (setup-class-form frm)
      (set! form~self frm))
    
    (define (setup-file-form frm)
      (set! form~self frm))
    
    (nextmethod)
    (set! reference~self reference)
    (setup-form form))
  

  ;;;
  ;;;; Save
  ;;;
  
  
  (method public virtual (save (default-extension: default-extension #f) (extensions: extensions '()))
    (with-cursor :wait
      (lambda ()
        (let ((origin (get-origin~ form)))
          (if (not origin)
              (save-as default-extension: default-extension extensions: extensions)
            (save-content))))))
  
  
  (method public (save-to file)
    (if (not file)
        (save-as)
      (set-origin~ form file)
      (save-to-file file)
      (set-modified? #f)))
  
  
  (definition Default-Extension
    "jmf")
  
  (definition Default-Extensions
    '(("JMF Files" . "jmf")))
  
  
  (method (save-as (default-extension: default-extension #f) (extensions: extensions '()))
    (set-origin~ form (choose-new-file default-extension: (or default-extension Default-Extension) extensions: (or extensions Default-Extensions)))
    (save-content))
  
  
  (method (save-content)
    (let ((origin (get-origin~ form)))
      (if (file? origin)
          (save-to-file origin)
        (save-to-class origin)))
    (set-modified? #f))
  
  
  (method (save-to-class class)
    (let* ((appl (get-application))
           (class-name (category-identifier class))
           (where (if (eq? form (get-self-form~ class)) :form :new-form))
           (location (list class-name where))
           (code-location (new Jazz-Code-Location location))
           (code-source (find-source~ code-location))
           (being-edited? (find-document~ appl code-source))
           (output (saved-form #t 2)))
      ;; Invoking the Interpreter is the simplest way of creating
      ;; the new definition that did not already exist in the class...
      @convert
      (when (eq? where :new-form)
        (evaluate~ Interpreter (list '(form (<install>))) #f class (list Language)))
      @convert
      (set-class-form~ class form)
      (receive (frame text range) (find-location~ code-location)
        (with-update-locked~ text
          (lambda ()
            (set-selection~ text range)
            (when (eq? where :new-form)
              (insert-string~ text (format "{%}{%}{%}  ")))
            (insert-string~ text output)))
        (if being-edited?
            (focus-host~ frame)
          (save~ text)
          (close~ frame)))))
  
  
  (method (save-to-file file)
    (if (and (exists?~ file) (read-only?~ file))
        (message-box (format "Unable to save to read-only file: {s}" file))
      (call-with-output-file (list path: (parse~ file) char-encoding: 'UTF-8 eol-encoding: (get-eol-encoding))
        (lambda (printer)
          (output-header (get-model-name~ form) printer)
          (format printer "{%}{%}")
          (print-to #f 0 printer)))))


  (method public (saved-form class-form? level (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (with-jazz-readtable
      (lambda ()
        (let ((printer (open-output-string)))
          (print-to class-form? level printer space-properties?: space-properties? align-name?: align-name?)
          (get-output-string printer)))))
  
  
  (method public (print-to class-form? level printer (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (when class-form?
      (format printer "(form{%}"))
    (let ((node (form->node form))
          (base (if class-form? level level)))
      (pretty-print~ node printer form?: class-form? base: base space-properties?: space-properties? align-name?: align-name?))
    (if class-form?
        (format printer ")")
      (format printer "{%}")))
  
  
  (method (print-form form level printer)
    (pretty-print~ (form->node form) printer base: level))
  
  
  ;;;
  ;;;; Design
  ;;;
  
  
  (method public virtual (set-name component name (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (form (find-form component branch))
           (old-name (get-name~ component))
           (old-presentation (get-presentation-property~ component)))
      (for-each-trait~ (or branch reference)
        (lambda (trait)
          (let ((form (get-client-form~ trait)))
            (when form
              (let* ((ancestry (component-ancestry component))
                     (component-form (owned-form form ancestry)))
                (when (and component-form (neq? (get-action~ component-form) 'install))
                  (set-name~ component-form name)))))))
      (set-name~ component name)
      (set-name~ form name)
      (when design-events?
        (fire-name-change component name old-name undoable?)
        (let ((presentation (get-presentation-property~ component)))
          (fire-presentation-change component presentation old-presentation undoable?))
        (let ((property (property-field (class-of component) 'name-info)))
          (fire-property-change branch component property name undoable?)))
      (set-modified? #t)))
  
  
  (method public virtual (set-tag-unit component parent tag-unit)
    (let ((form (find-form component #f)))
      (set-tag-unit~ form tag-unit)
      (set-modified? #t)))
  
  
  (method public virtual (set-property component/path property value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let ((branch (target-branch trait)))
      ;; Quick fix for the special case of setting a property of the active trait
      (if (eq? component/path trait)
          (set-property component/path property value trait: #f design-events?: design-events? undoable?: undoable?)
        (let ((installed? (or (not branch) (is? branch Branch)))
              (path? (is? component/path Path)))
          (if (and path? (not installed?))
              (let ((form (follow-form~ component/path (if branch (get-client-form~ (get-trait~ branch)) form))))
                (set-property~ form property value))
            (let* ((component (if path? (follow-component~ component/path reference) component/path))
                   (property (if component (property-field (class-of component) property) property)))
              (assert property)
              ;; This validation should probably also be done in other operations...
              (when (and component (not installed?))
                (let ((creator-branch (get-creator-branch~ component)))
                  ;; This test is not 100% correct as the creator-branch can be any parent branch of branch
                  (when (and creator-branch (neq? branch (get-creator-branch~ component)))
                    (designer-error "Unable to modify an explicit trait using a component having a different branch creator"))))
              (receive (form restore) (find-form component branch restore?: #t)
                (receive (next-form next-restore) (find-next-branch branch component property)
                  (set-property~ form property value)
                  (when installed?
                    (if (not next-form)
                        (let ((old-value (read-property component property)))
                          (when (and restore (not (has-property?~ restore property)))
                            (set-property~ restore property old-value))
                          (let* ((fire-presentation? (and design-events? (presentation-property?~ component property)))
                                 (old-presentation (and fire-presentation? (get-presentation-property~ component))))
                            (write-property component property value)
                            (when design-events?
                              (when fire-presentation?
                                (let ((presentation (get-presentation-property~ component)))
                                  (fire-presentation-change component presentation old-presentation undoable?)))
                              (fire-property-change branch component property value undoable?))))
                      (when (and restore (not (has-property?~ restore property)))
                        (set-property~ restore property (get-property~ next-restore property)))
                      (set-property~ next-restore property value)))))))
          (set-modified? #t)))))
  
  
  ;; This works well really only with branches because else we don't have restore information
  (method public virtual (remove-property component/path property default-value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let* ((branch (target-branch trait))
           (installed? (or (not branch) (is? branch Branch)))
           (path? (is? component/path Path))
           (component (if path? (follow-component~ component/path reference) component/path))
           (property (property-field (class-of component) property)))
      (assert property)
      (receive (form restore) (find-form component branch restore?: #t)
        (receive (next-form next-restore) (find-next-branch branch component property)
          (when (has-property?~ form property)
            (let ((value (if (not restore) default-value (get-property~ restore property))))
              (when installed?
                (if (not next-form)
                    (begin
                      (write-property component property value)
                      (when design-events?
                        (fire-property-change branch component property value undoable?)))
                  (set-property~ next-restore property value))))
            (remove-property~ form property)
            (when restore
              (remove-property~ restore property))
            (set-modified? #t))))))
  
  
  (method public virtual (add-child child parent (trait: trait #t) (name: name #f) (properties: properties '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (let ((branch (target-branch trait)))
      (set-parent~ child parent)
      (receive (form restore) (find-form parent branch restore?: #t)
        (let ((child-form (new Form textual?: #f context: (get-context~ form) action: 'new model-name: (category-name (class-of child)))))
          (set-form~ child child-form)
          (add-form~ parent form child-form))
        (when restore
          (remember-creation~ restore self child))
        (when name
          (set-name child name trait: trait design-events?: #f))
        (set-creator~ child reference)
        (add-to-index~ reference (get-name~ child) child)
        (when properties
          (for-each-property (lambda (property value)
                               (set-property child property value trait: trait design-events?: design-events?))
            properties))
        ;; the two sexpr where toggled so that the event occurs
        ;; after the properties are set (check that this doesn't
        ;; break the MetaModeler who calls this at 3 places)
        (when design-events?
          (fire-child-add child parent descendant?))
        (set-modified? #t)))
    child)

  
  (method public virtual (remove-child child (trait: trait #t) (design-events?: design-events? #t))
    (let ((branch (target-branch trait)))
      (if (eq? child reference)
          (designer-error "The reference component cannot be removed")
        (let ((effective (or branch reference))
              (owner (find-owner child)))
          ;; the (and owner) part is a try
          (if (and owner (neq? owner effective))
              (designer-error "Component cannot be removed from non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective))
            (let* ((name (get-name~ child))
                   (parent (get-parent~ child))
                   (parent-form (find-form parent branch))
                   (form (find-form child branch)))
              (define (purge-references form)
                (when form
                  (let* ((parent-ancestry (component-ancestry parent))
                         (parent-form (owned-form form parent-ancestry)))
                    (when parent-form
                      (let ((child-form (find-child~ parent-form name)))
                        (when child-form
                          (remove-child~ parent-form child-form)))))))
              
              (for-each-trait~ effective
                (lambda (trait)
                  (purge-references (get-client-form~ trait))
                  (purge-references (get-restore-form~ trait))))
              (close~ child)
              (remove-child~ parent-form form)
              (when design-events?
                (fire-child-remove child parent))
              (set-modified? #t)))))))
  
  
  (method public (remove-children parent (trait: trait #t) (design-events?: design-events? #t))
    (for-each (lambda (child)
                (remove-child child trait: trait design-events?: design-events?))
              (get-children~ parent)))
  
  
  (method public (move-component component destination (trait: trait #t))
    (move-components (list component) destination trait: trait))
  
  
  (method public virtual (move-components components destination (trait: trait #t))
    (assert (eq? (get-form~ (get-creator~ destination)) form))
    (let ((destination-form (get-form~ destination)))
      (for-each (lambda (component)
                  (assert (eq? (get-form~ (get-creator~ component)) form))
                  (set-parent~ component destination)
                  (let ((component-form (get-form~ component)))
                    (set-parent~ component-form destination-form)))
                components)
      (set-modified? #t)))
  
  
  (method public (can-move-component? component destination)
    (and (eq? (get-form~ (get-creator~ component)) form)
         (eq? (get-form~ (get-creator~ destination)) form)))
  
  
  (method public virtual (transfer-components components destination (trait: trait #t))
    (let* ((components (remove-redundant-descendants components))
           (parcels (package-components components))
           (name-resolution (verify-name-conflicts parcels destination)))
      (delete-components components trait: trait)
      (prog1 (instantiate-parcels parcels destination trait: trait name-resolution: name-resolution design-events?: #t descendant?: #f)
        (set-modified? #t))))
  
  
  (method public virtual (send-before child target (trait: trait #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ child))
           (parent-form (find-form parent branch))
           (child-form (find-form child branch))
           (target-form (and target (find-form target branch))))
      (send-before~ child target)
      (send-child-before~ parent-form child-form target-form)
      (fire-send-before child parent target)
      (set-modified? #t)))
  
  
  (method public (send-to-back child (trait: trait #t))
    (send-before child (first-child~ (get-parent~ child)) trait: trait))
  
  
  (method public (bring-to-front child (trait: trait #t))
    (send-before child #f trait: trait))
  
  
  ;; This is not a 100% complete solution as this for instance will
  ;; not restore the correct property values as remove-property would...
  (method public virtual (purge-trait component (trait: trait #t) (design-events?: design-events? #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ component))
           (parent-form (find-form parent branch)))
      (receive (form restore-form) (find-form component branch restore?: #t)
        (install-form~ component restore-form component #f #f)
        (remove-child~ parent-form form))))
  
  
  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (cut-components components)
    (let ((components (remove-redundant-descendants components)))
      (copy-components components)
      (delete-components components)))
  
  
  (method public virtual (copy-components components)
    (let ((components (remove-redundant-descendants components)))
      (let ((text (copy-components-text components)))
        (set-clipboard-text text format: 'jazz-parcels))))
  
  
  (method public (copy-components-text components (trait: trait #f))
    (let ((output (open-output-string))
          (parcels (package-components components trait: trait)))
      (format output "(")
      (for-each (lambda (parcel)
                  (format output "~{{a} " (category-name (class-of parcel)))
                  (format output "{a} " (get-process-id~ parcel))
                  (format output "{a} " (get-object-id~ parcel))
                  (format output "(")
                  (for-each (lambda (form)
                              (print-form form 0 output))
                            (get-content~ parcel))
                  (format output ")")
                  (format output "}"))
                parcels)
      (format output ")")
      (get-output-string output)))
  
  
  (method public virtual (paste-clipboard parent (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcels (get-jazz-parcels)))
      (paste-parcels parcels parent trait: trait design-events?: design-events?)))
  
  
  (method public virtual (paste-parcels parcels parent (trait: trait #t) (design-events?: design-events? #t) (reporter: reporter #f))
    (let* ((parent (determine-paster~ parent))
           (name-resolution (verify-name-conflicts parcels parent)))
      (prog1 (instantiate-parcels parcels parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: #f reporter: reporter)
        (set-modified? #t))))
  
  
  (method public virtual (paste-properties components (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcel (car (get-jazz-parcels))))
      (paste-parcel-properties parcel components trait: trait design-events?: design-events?)))
  
  
  (method public (paste-parcel-properties parcel components (trait: trait #t) (design-events?: design-events? #t))
    (let ((forms (get-content~ parcel)))
      (for-each (lambda (component)
                  (for-each (lambda (form)
                              (instantiate-properties component (get-properties~ form) trait design-events?))
                            forms))
                components)
      (set-modified? #t)))
  
  
  (method public virtual (delete-components components (trait: trait #t) (design-events?: design-events? #t))
    (let ((components (remove-redundant-descendants components)))
      (for-each (lambda (component)
                  (delete-component component trait: trait design-events?: design-events?))
                components)))
  
  
  (method public virtual (delete-component component (trait: trait #t) (design-events?: design-events? #t))
    (remove-child component trait: trait design-events?: design-events?))
  
  
  ;; For some operations like cut, copy, delete and move, having a component that
  ;; is a descendant of another one doesn't make sense and can lead to problems...
  (method (remove-redundant-descendants components)
    components
    ;; waiting for a bug fix in the tree selection update that this has uncovered
    @wait
    (collect-if (lambda (component)
                  (not (some? (lambda (target)
                                (and (neq? component target)
                                     (has-parent?~ component target)))
                              components)))
                components))
  
  
  ;;;
  ;;;; Package
  ;;;
  
  
  (method (package-components components (trait: trait #f))
    (define (package-component component (trait: trait #f))
      (let ((ancestry (component-ancestry component))
            (forms '()))
        (iterate-branch-spine~ reference
          (lambda (owner form)
            (let ((form (owned-form form ancestry)))
              (when form
                (set! forms (cons form forms)))))
          trait: trait)
        (if (and (not-null? forms) (memq? (get-action~ (car forms)) '(new install)))
            (new Component-Parcel (current-process-id) (object->serial component) forms)
          (designer-error "Unable to find owner for {t}" component))))
    
    (map (lambda (component)
           (package-component component trait: trait))
         components))
  
  
  ;;;
  ;;;; Instantiate
  ;;;
  
  
  (method public virtual (instantiate-parcels parcels parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f) (reporter: reporter #f))
    (map (lambda (parcel)
           (when reporter
             (user-message~ reporter "Pasting {a}..." (get-master-name~ parcel)))
           (prog1 (instantiate-parcel parcel parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: descendant?)
             (when reporter
               (step-it~ reporter))))
         parcels))
  
  
  (method public virtual (instantiate-parcel parcel parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (let* ((forms (get-content~ parcel))
           (master (car forms))
           (name (get-name~ master)))
      (let* ((brothers (get-children~ parent))
             (domain (map get-name~ brothers))
             (equal (sort-predicate 'equal))
             (conflict? (and name (member? name domain test: equal))))
        (when conflict?
          (case name-resolution
            ((rename) (set! name (unique-name name domain))
             (for-each (lambda (form)
                         (set-name~ form name))
                       forms))
            ((override) (let ((conflicts (name-conflicts (list name) brothers)))
                          (delete-components conflicts trait: trait))))))
      (let ((component (instantiate-form name name-resolution master parent trait design-events? descendant?)))
        (for-each (lambda (form)
                    (instantiate-form name #f form parent trait design-events? descendant?))
                  (cdr forms))
        component)))
  
  
  (method public virtual (instantiate-form name name-resolution form parent trait design-events? descendant?)
    (let ((component (instantiate-component name name-resolution form parent trait design-events? descendant?)))
      (when component
        (instantiate-properties component (get-properties~ form) trait design-events?)
        (instantiate-children component (get-children~ form) trait design-events?)
        component)))

  
  (method public virtual (instantiate-component name name-resolution form parent trait design-events? descendant?)
    (let ((action (get-action~ form)))
      (case action
        ((new) (instantiate-new-component name form parent trait design-events? descendant?))
        ((modify locate) (find-to-modify~ parent (get-name~ form) (sort-predicate 'equal)))
        (else (designer-error "Unsupported form action: {t}" action)))))
  
  
  (method public virtual (instantiate-new-component name form parent trait design-events? descendant?)
    (let ((component (instantiate-component~ form parent: parent)))
      (add-child component parent trait: trait name: name design-events?: design-events? descendant?: descendant?)
      component))
  
  
  (method public virtual (instantiate-properties component properties trait design-events?)
    (for-each-property (lambda (property value)
                         (set-property component property value trait: trait design-events?: design-events? undoable?: #f))
                       properties))

  
  (method public virtual (instantiate-children component children trait design-events?)
    (for-each (lambda (form)
                (instantiate-form (get-name~ form) #f form component trait design-events? #t))
              children))
  
  
  ;;;
  ;;;; Unique
  ;;;
  
  
  (method protected virtual (unique-name name domain)
    (let ((unique-name (unique-domain-name (->string name) (map ->string domain) separator: (unique-separator))))
      (if (symbol? name)
          (string->symbol unique-name)
        unique-name)))
  
  
  (method protected virtual (unique-separator)
    "_")
  
  
  ;;;
  ;;;; Conflicts
  ;;;
  
  
  (definition (name-conflicts names children)
    (let ((equal (sort-predicate 'equal)))
      (collect-if (lambda (child)
                    (let ((child-name (get-name~ child)))
                      (and child-name
                           (some? (lambda (name)
                                    (equal child-name name))
                                  names))))
                  children)))
  
  
  (method public (verify-name-conflicts parcels destination)
    (define (confirm-name-resolution children conflicts)
      (define (present-conflicts header conflicts)
        (let ((fact (new List-Factory)))
          (put~ fact header)
          (for-each (lambda (conflict)
                      (put~ fact (list :bulleted (->string (get-name~ conflict)))))
                    conflicts)
          (get-output~ fact)))
      
      (if (every? (lambda (parcel)
                    (let ((equal (sort-predicate 'equal))
                          (process-id (get-process-id~ parcel))
                          (component-id (get-object-id~ parcel))
                          (name (get-master-name~ parcel)))
                      (and (= process-id (current-process-id))
                           (some? (lambda (child)
                                    (and (= component-id (object->serial child))
                                         (equal name (get-name~ child))))
                                  children))))
                  parcels)
          'rename
        (let* ((header "The following conflicts where detected. Override destination?")
               (text (present-conflicts header conflicts))
               (code (message-box text type: 'question)))
          (case code
            ((yes) 'override)
            ((no) (throw-cancel))))))
    
    (let* ((names (map get-master-name~ parcels))
           (children (get-children~ destination))
           (conflicts (name-conflicts names children)))
      (when (not-null? conflicts)
        (confirm-name-resolution children conflicts))))
  
  
  ;;;
  ;;;; View
  ;;;
    
  
  ;; This special support for views is not clean, but it is better
  ;; than having it directly inside add-child where it was before!
  (method public virtual (add-view child parent (name: name #f) (position: position #f) (centered?: centered? #f) (visible?: visible? #t) . others)
    (apply add-child child parent name: name others)
    (when position
      (set-property child 'position position))
    (when centered?
      (let ((size (get-size~ child)))
        (move-figure~ child (- (quotient (get-width~ size) 2)) (- (quotient (get-height~ size) 2)))))
    (when visible?
      (set-visible?~ child #t))
    (set-modified? #t))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  ;; package modifier is for tests
  (method package (find-form component branch (restore?: restore? #f) (error?: error? #t))
    (define (embed-form form ancestry)
      (for-each (lambda (cpn)
                  (let ((children (get-children~ form))
                        (cpn-form (get-form~ cpn)))
                    (if (not cpn-form)
                        (embed-new-form form #f)
                      (if (memq? cpn-form children)
                          (set! form cpn-form)
                        (let ((restore-form (find-in children cpn key: (lambda (form) (and (is? form Restore-Form) (get-component~ form))))))
                          (if restore-form
                              (set! form restore-form)
                            (let ((name (get-name~ cpn)))
                              (if (not name)
                                  (designer-error "Component {t} must be named to allow modification" cpn)
                                (let ((subform (find-in children name key: get-name~ test: equal?)))
                                  (if (not subform)
                                      (set! form (embed-new-form form name))
                                    (set! form subform)))))))))))
                ancestry)
      form)
    
    (define (embed-new-form form name)
      (let ((subform (new Form action: 'modify name: name)))
        (add-child~ form subform)
        subform))
    
    (let* ((ancestry (component-ancestry component))
           (trait-form (if branch (get-client-form~ (get-trait~ branch)) form))
           (restore-form (and restore? branch (get-restore-form~ branch)))
           (form (embed-form trait-form ancestry))
           (restore (and restore-form (embed-form restore-form ancestry))))
      (if (and error? (not form))
          (designer-error "Unable to locate target form")
        (if restore?
            (values form restore)
          form))))
  
  
  (method (target-branch trait)
    (cond ((eq? trait #t) (get-active-branch~ reference))
          ((is? trait Path) (follow-component~ trait reference))
          (else (find-trait-branch~ reference trait))))
  
  
  (method (component-ancestry component)
    (let ((ancestry '())
          (scan component))
      (while (neq? scan reference)
        (set! ancestry (cons scan ancestry))
        (set! scan (get-parent-component~ scan))
        (when (not scan)
          (designer-error "{t} is not a descendant of the reference component {t}" component reference)))
      ancestry))
  
  
  ;;;
  ;;;; Owner
  ;;;
  
  
  (method public (find-owner component (property #f))
    (let ((ancestry (component-ancestry component)))
      (continuation-capture
        (lambda (return)
          (iterate-branch-spine~ reference
            (lambda (owner form)
              (when form
                (let ((form (owned-form form ancestry)))
                  (when (and form
                             (or (and (not property) (eq? (get-action~ form) 'new))
                                 (and property (has-property?~ form property))))
                    (continuation-return return owner))))))
          #f))))
  
  
  (method (find-next-branch branch component property)
    (if (not branch)
        (values #f #f)
      (let ((lower (get-branches~ (or branch reference)))
            (ancestry (component-ancestry component)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (branch)
                        (let ((client-form (get-client-form~ branch)))
                          (when client-form
                            (let ((form (owned-form client-form ancestry)))
                              (when (and form (has-property?~ form property))
                                (continuation-return return (values form (owned-form (get-restore-form~ branch) ancestry))))))))
                      lower)
            (values #f #f))))))
  
  
  (definition (owned-form form ancestry)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (cpn)
                    (let ((children (get-children~ form))
                          (cpn-form (get-form~ cpn)))
                      (if (not cpn-form)
                          (continuation-return return #f)
                        (if (memq? cpn-form children)
                            (set! form cpn-form)
                          (let ((name (get-name~ cpn)))
                            (if (not name)
                                (continuation-return return #f)
                              (let ((subform (find-in children name key: get-name~ test: equal?)))
                                (if (not subform)
                                    (continuation-return return #f)
                                  (set! form subform)))))))))
                  ancestry)
        form)))
  
  
  ;;;
  ;;;; Value
  ;;;
  
  
  ;; Until a fully generic solution, these methods implement the following special case:
  ;; - the trait must be the owner of the property (i.e. have set it)
  
  
  (method public (get-name path (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-name~ (follow-form~ path form))))
  
  
  (method public (get-property path property (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-property~ (follow-form~ path form) property)))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method public (edit-form)
    (let ((appl (get-application))
          (origin (get-origin~ form)))
      (cond ((not origin)
             (bell))
            ((file? origin)
             (edit-document~ appl origin class: Jazz-Text-View))
            (else
             (edit~ (locator->entry (get-name~ origin)))))))
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method (designer-error . rest)
    (signal (new Designer-Error message: (apply format rest))))
  
  
  (method public (safe-set-property . rest)
    (with-safe-design
      (lambda ()
        (apply set-property rest))))
  
  
  ;;;
  ;;;; Fire
  ;;;
  
  
  (definition (fire-name-change component name old-name undoable?)
    (for-each (lambda (designer)
                (process-name-change~ designer component name old-name undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-presentation-change component presentation old-presentation undoable?)
    (for-each (lambda (designer)
                (process-presentation-change~ designer component presentation old-presentation undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-property-change branch component property value undoable?)
    (for-each (lambda (designer)
                (process-property-change~ designer branch component property value undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-child-add child parent descendant?)
    (for-each (lambda (designer)
                (process-child-add~ designer child parent descendant?))
              (get-designers~ parent)))
  
  
  (definition (fire-child-remove child parent)
    (for-each (lambda (designer)
                (process-child-remove~ designer child parent))
              (get-designers~ child)))
  
  
  (definition (fire-send-before child parent target)
    (for-each (lambda (designer)
                (process-send-before~ designer child parent target))
              (get-designers~ child)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-designer-listener listener)
    (set! listeners (add-listener listener listeners)))
  
  
  (method public (remove-designer-listener listener)
    (set! listeners (remove-listener listener listeners)))

  
  (method (process-name-change component name old-name undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :name-change self component: component name: name old-name: old-name undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-presentation-change component presentation old-presentation undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :presentation-change self component: component presentation: presentation old-presentation: old-presentation undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-property-change branch component property value undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :property-change self branch: branch component: component property: property value: value undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-add child parent descendant?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-add self child: child parent: parent descendant?: descendant?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-remove child parent)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-remove self child: child parent: parent)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-send-before child parent target)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :send-before self child: child parent: parent target: target)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-refresh component what)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :refresh self component: component what: what)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-user-event event)
    (when (not-null? listeners)
      (for-each (lambda (listener)
                  (invoke~ listener self event))
                listeners)))))
