;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Designer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.designer.designer.Designer jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.designer.view)
        (jazz.editor.jazz)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view))


(class Designer extends Object
  
  
  (slot form      initialize #f accessors generate)
  (slot form-copy initialize #f accessors generate)
  (slot reference initialize #f getter generate)
  (slot listeners initialize '())
  (slot modified? initialize #f accessors generate)

  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (initialize (form: form #f) (reference: reference #f))
    (define (setup-form frm)
      (if (not frm)
          (begin
            (set! form~self (new Form textual?: #f origin: (class-of reference) action: 'new model: 'install))
            (set-data~ form~self (new Data 'jazz '() #f)))
        (let ((origin (get-origin~ frm)))
          (if (file? origin)
              (setup-file-form frm)
            (setup-class-form frm)))))
    
    ;; Setting form to a copy until saving is a tempting approach,
    ;; but fails because we absolutly need pointer equality as a test
    ;; for embed-form to work correctly with anonymous forms.
    ;; So the approach taken will be more like relational databases
    ;; where we modify the database directly but keep a log of
    ;; transactions in order to be able to rollback changes (and it
    ;; makes lots of sense to, because a designer is really the interface
    ;; by which Jazz's object-oriented databases are updated!).
    ;;
    ;; Or maybe simply take a copy before the first modification is made
    ;; (lazy approach) and if we need to rollback, set the original form
    ;; to the copy.
    (define (setup-class-form frm)
      (set! form~self frm)
      (unless (get-data~ frm)
        (set-data~ frm (new Data 'jazz '() #f)))
      (set! form-copy (copy-object~ frm #t)))
    
    (define (setup-file-form frm)
      (set! form~self frm))
    
    (nextmethod)
    (set! reference~self reference)
    (setup-form form))
  
  
  ;;;
  ;;;; Revert
  ;;;
  
  
  (method public (revert)
    (let ((origin (get-origin~ form)))
      (when (class? origin)
        (set-class-form~ origin form-copy))))
  

  ;;;
  ;;;; Save
  ;;;
  
  
  (method public virtual (save (default-extension: default-extension #f) (extensions: extensions '()))
    (with-cursor :wait
      (lambda ()
        (let ((origin (get-origin~ form)))
          (if (not origin)
              (save-as default-extension: default-extension extensions: extensions)
            (save-content))))))
  
  
  (method public (save-to file)
    (if (not file)
        (save-as)
      (set-origin~ form file)
      (save-to-file file)
      (set-modified? #f)))
  
  
  (definition Default-Extension
    "jmf")
  
  (definition Default-Extensions
    '(("JMF Files" . "jmf")))
  
  
  (method (save-as (default-extension: default-extension #f) (extensions: extensions '()))
    (let ((toolbox-manager (find-docked Toolbox-Manager)))
        (set-origin~ form 
          (if toolbox-manager
              (choose-new-origin toolbox-manager)
            (choose-new-file default-extension: (or default-extension Default-Extension) extensions: (or extensions Default-Extensions))))
        (save-content)))
  
  
  (method (call-with-saved-text file func)
    (call-with-text file
      (lambda (text)
        (let ((result (func text)))
          (save~ text)
          result))))
  
  
  (method (call-with-text file func)
    (let* ((frame (edit-document~ (get-application) file force-new?: #t class: Jazz-Text-View visible?: #f))
           (text (get-guest~ frame))
           (result (func text)))
      (close~ frame)
      result))
  
  
  (method (evaluate-at-caret text)
    (apply evaluate-expressions~ (get-local-process) (prepare-expressions~ text (current-declaration-range~ text))))
  
  (method (choose-new-origin toolbox-manager)
    (define (parse-class-name class-string)
      (let ((content (with-exception-catcher
                       (lambda (err) #f)
                       (lambda () (read-string-content class-string)))))
        (and content
             (= 1 (length content))
             (symbol? (car content))
             (car content))))
    
    (define (validate-class-name module-name class-name)
      (if class-name
          (let* ((not-found (list #f))
                 (ref (module-get module-name class-name not-found: not-found)))
            (if (eq? ref not-found)
                class-name
              (designer-error "Existing class")))
        (designer-error "Invalid class name")))
    
    (define (validate-module-name module-name)
      (if module-name
          (with-exception-catcher
            (lambda (exc)
              (designer-error "Non-existant module"))
            (lambda ()
              (require-module module-name)))
        (designer-error "Empty module")))
    
    (define (evaluate-class text module-name class-name)
      (let ((explorer (new Jazz-Explorer (get-model~ text))))
        (forward-location~ explorer (list class-name))
        (set-end~ explorer (get-start~ explorer))
        (enter-list~ explorer)
        (set-caret~ text (get-end~ explorer))
        (evaluate-at-caret text)
        (module-ref module-name class-name)))
    
    (define (insert-class text class-name)
      (let ((explorer (new Jazz-Explorer (get-model~ text))))
        (forward-namespace~ explorer)
        ;; We suppose the import form exist
        (forward-expr~ explorer)
        (set-caret~ text (get-end~ explorer))
        (let* ((super-class (get-model~ form))
               (class-string (format "{%}{%}{%}(class {a} extends {a})" class-name super-class)))
          (insert-string~ text class-string))))
    
    (let* ((modules (get-module-names~ toolbox-manager))
           (result (get-modal Save-Chooser modules: modules)))
      (if (is? result File)
          result
        (bind (module-name class-string) result
          (with-safe-design
            (lambda ()
              (let ((class-name (parse-class-name class-string)))
                (validate-module-name module-name)
                (validate-class-name module-name class-name)
                (call-with-saved-text (find-unit-source module-name)
                  (lambda (text)
                    (insert-imports text module-name)
                    (evaluate-imports text)
                    (insert-class text class-name)
                    (evaluate-class text module-name class-name))))))))))
  
  
  (method (save-content)
    (let ((origin (get-origin~ form)))
      (if (file? origin)
          (save-to-file origin)
        (save-to-class origin)))
    (set-modified? #f))
  
  
  (method (evaluate-imports text)
    (let ((explorer (new Jazz-Explorer (get-model~ text))))
      (forward-namespace~ explorer)
      (enter-import~ explorer)
      (set-caret~ text (get-end~ explorer))
      (evaluate-at-caret text)))
  
  
  (method (insert-imports text module-name)
    (define (insert-import unit)
      (let ((explorer (new Jazz-Explorer (get-model~ text))))
        (forward-namespace~ explorer)
        (if (not (enter-import~ explorer))
            (error "Unable to find import declaration")
          (receive (found? first?) (find-import-invoice~ explorer unit #t)
            (unless found?
              (set-caret~ text (get-end~ explorer))
              (cond (first?
                      (insert-string~ text (format " ({a})" unit))
                      (insert-newline~ text)
                      (tabulate~ text))
                    (else
                     (insert-newline~ text)
                     (tabulate~ text)
                     (insert-string~ text (format "({a})" unit)))))))))
    
    
    (for-each insert-import (let ((explorer (new Jazz-Explorer (get-model~ text)))
                                  (units (cons 'jazz.jml (remove module-name (map car (get-imports~ (get-data~ form)))))))
                              (filter-existing-import-invoices~ explorer units))))
  
  
  (method (save-to-class class)
    (let ((class-name (category-name class))
          (module-name (category-unit class)))
      
      (define (save-to-existing-class text)
        (let ((form-exists? (eq? form (get-class-form~ class))))
          (insert-imports text module-name)
          (evaluate-imports text)
          (save-form text form form-exists?)
          (tabulate-form text)
          (unless form-exists? (evaluate-form text))))
      
      (define (save-to-new-class text)
        (let ((adjusted-form (new Form textual?: #f action: 'new model: 'install properties: (get-properties~ form) children: (get-children~ form))))
          (save-form text adjusted-form #f)
          (tabulate-form text)
          (evaluate-form text)
          (set-object-slot reference 0 class)
          (for-each (lambda (designer)
                      (process-property-change~ designer #f reference (category-field class 'class-info) (get-class-presentation~ class) #f)) 
                    (get-designers~ reference))))
      
      (define (tabulate-form text)
        (let ((explorer (new Jazz-Explorer (get-model~ text))))
          (forward-location~ explorer (list class-name :form))
          (set-selection~ text (get-range~ explorer))
          (tabulate~ text)))
      
      (define (save-form text form form-exists?)
        (let ((explorer (new Jazz-Explorer (get-model~ text)))
              (where (if form-exists? :form :new-form))
              (str (form->string form 2)))
          (forward-location~ explorer (list class-name where))
          (set-selection~ text (get-range~ explorer))
          (insert-string~ text (format (if form-exists? "{a}" "{%}{%}{%}{a}") str))))
      
      (define (evaluate-form text)
        (let ((explorer (new Jazz-Explorer (get-model~ text))))
          (forward-location~ explorer (list class-name :form))
          (set-end~ explorer (get-start~ explorer))
          (enter-list~ explorer)
          (set-caret~ text (get-end~ explorer))
          (evaluate-at-caret text)
          (let ((new-form (get-class-form~ class)))
            (set-data~ new-form (get-data~ form))
            (for-each (lambda (designer)
                        (set-form~ designer new-form))
                      (get-designers~ reference)))))
      
      (call-with-saved-text (find-unit-source module-name)
        (lambda (text)
          (if (is? reference class)
              (save-to-existing-class text)
            (save-to-new-class text))))))
  
  
  (method (save-to-file file)
    (if (and (exists?~ file) (read-only?~ file))
        (message-box (format "Unable to save to read-only file: {s}" file))
      (call-with-output-file (path-settings file char-encoding: 'UTF-8)
        (lambda (output)
          (let ((data (get-data~ form)))
            (output-header (get-model~ form) output)
            (format output "{%}{%}")
            (format output "(data {a}{%}" (get-dialect~ data))
            (format output "{%}{%}")
            (let ((imports (get-imports~ data)))
              (when imports
                (format output "(import ")
                (let ((first? #t))
                  (for-each (lambda (import)
                              (if first?
                                  (set! first? #f)
                                (format output "{%}"))
                              (format output "{s}" import))
                            imports)
                  (format output "){%}"))
                (format output "{%}{%}")))
            (print-to 1 output)
            (format output "){%}"))))))


  (method public (saved-form . rest)
    (apply form->string form rest))
  
  
  (method public (print-to . rest)
    (apply print-file-form form rest))
  
  
  ;;;
  ;;;; Design
  ;;;
  
  (method public virtual (set-name component name (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (owner (find-owner component))
           (effective (or branch reference))
           (effective-cpn (if (is? effective Branch) (get-trait~ effective) effective)))
      (if (and owner (neq? owner effective))
          (designer-error "Component cannot be renamed in non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective-cpn))
        (let ((form (find-form component branch))
              (old-name (get-name~ component))
              (old-presentation (get-presentation-property~ component)))
          (for-each-trait~ effective-cpn
            (lambda (trait)
              (let ((form (get-client-form~ trait)))
                (when form
                  (let* ((ancestry (component-ancestry component))
                         (component-form (owned-form form ancestry)))
                    (when (and component-form (neq? (get-action~ component-form) 'install))
                      (set-name~ component-form name)))))))
          (set-name~ component name)
          (set-name~ form name)
          (when design-events?
            (fire-name-change component name old-name undoable?)
            (let ((presentation (get-presentation-property~ component)))
              (fire-presentation-change component presentation old-presentation undoable?))
            (let ((property (property-field (class-of component) 'name-info)))
              (fire-property-change branch component property name undoable?)))
          (set-modified? #t)))))
  
  
  (method public virtual (set-property component/path property value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let ((branch (target-branch trait)))
      ;; Quick fix for the special case of setting a property of the active trait
      (if (eq? component/path trait)
          (set-property component/path property value trait: #f design-events?: design-events? undoable?: undoable?)
        (let ((installed? (or (not branch) (is? branch Branch)))
              (path? (is? component/path Path)))
          (if (and path? (not installed?))
              (let ((form (follow-form~ component/path (if branch (get-client-form~ (get-trait~ branch)) form))))
                (set-property~ form property value))
            (let* ((component (if path? (follow-component~ component/path reference) component/path))
                   (property (if component (property-field (class-of component) property) property)))
              (assert property)
              ;; This validation should probably also be done in other operations...
              (when (and component (not installed?))
                (let ((creator-branch (get-creator-branch~ component)))
                  ;; This test is not 100% correct as the creator-branch can be any parent branch of branch
                  (when (and creator-branch (neq? branch (get-creator-branch~ component)))
                    (designer-error "Unable to modify an explicit trait using a component having a different branch creator"))))
              (receive (form restore) (find-form component branch restore?: #t)
                (receive (next-form next-restore) (find-next-branch branch component property)
                  (set-property~ form property value)
                  (when installed?
                    (if (not next-form)
                        (let ((old-value (read-property component property)))
                          (when (and restore (not (has-property?~ restore property)))
                            (set-property~ restore property old-value))
                          (let* ((fire-presentation? (and design-events? (presentation-property?~ component property)))
                                 (old-presentation (and fire-presentation? (get-presentation-property~ component))))
                            (write-property component property value)
                            (when design-events?
                              (when fire-presentation?
                                (let ((presentation (get-presentation-property~ component)))
                                  (fire-presentation-change component presentation old-presentation undoable?)))
                              (fire-property-change branch component property value undoable?))))
                      (when (and restore (not (has-property?~ restore property)))
                        (set-property~ restore property (get-property~ next-restore property)))
                      (set-property~ next-restore property value)))))))
          (set-modified? #t)))))
  
  
  ;; This works well really only with branches because else we don't have restore information
  (method public virtual (remove-property component/path property default-value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let* ((branch (target-branch trait))
           (installed? (or (not branch) (is? branch Branch)))
           (path? (is? component/path Path))
           (component (if path? (follow-component~ component/path reference) component/path))
           (property (property-field (class-of component) property)))
      (assert property)
      (receive (form restore) (find-form component branch restore?: #t)
        (receive (next-form next-restore) (find-next-branch branch component property)
          (when (has-property?~ form property)
            (let ((value (if (not restore) default-value (get-property~ restore property))))
              (when installed?
                (if (not next-form)
                    (begin
                      (write-property component property value)
                      (when design-events?
                        (fire-property-change branch component property value undoable?)))
                  (set-property~ next-restore property value))))
            (remove-property~ form property)
            (when restore
              (remove-property~ restore property))
            (set-modified? #t))))))
  
  
  (method public virtual (add-child child parent (trait: trait #t) (name: name #f) (properties: properties '()) (tag-reference: tag-reference #f) (import: import '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (let ((data (get-data~ form))
          (branch (target-branch trait)))
      (unless (eq? (get-parent~ child) parent)
        (set-parent~ child parent))
      (receive (form restore) (find-form parent branch restore?: #t)
        (let* ((child-origin-form (get-form~ child))
               (child-is-form? (and child-origin-form (is? (get-origin~ child-origin-form) File)))
               (child-form (new Form
                             textual?: #f
                             context: (get-context~ form)
                             action: (if tag-reference 'instantiate 'new)
                             model: (cond (tag-reference #f)
                                          (child-is-form? (get-name~ child-origin-form))
                                          (else (category-name (class-of child))))
                             tag-reference: tag-reference)))
          (set-form~ child child-form)
          (add-form~ parent form child-form))
        (when restore
          (remember-creation~ restore self child))
        (when name
          (set-name child name trait: trait design-events?: #f))
        (set-creator~ child reference)
        (add-to-index~ reference (get-name~ child) child)
        (when properties
          (for-each-property (lambda (property value)
                               (set-property child property value trait: trait design-events?: design-events?))
            properties))
        (when import
          (let ((imports (map listify (listify import))))
            (when (not-null? imports)
              (let* ((form (get-form))
                     (old-locator (get-locator~ form)))
                (set-locator~ form (let ((new-locator (imports-locator imports)))
                                     (lambda (symbol)
                                       (or (new-locator symbol)
                                           (old-locator symbol)))))))
            (when data
              (for-each (lambda (import) (add-import~ data import)) imports))))
        ;; the two sexpr where toggled so that the
        ;; event occurs after the properties are set
        (when design-events?
          (fire-child-add child parent descendant?))
        (set-modified? #t)))
    child)

  
  (method public virtual (remove-child child (trait: trait #t) (design-events?: design-events? #t))
    (let ((branch (target-branch trait)))
      (if (eq? child reference)
          (designer-error "The reference component cannot be removed")
        (let ((effective (or branch reference))
              (owner (find-owner child)))
          ;; the (and owner) part is a try
          (if (and owner (neq? owner effective))
              (designer-error "Component cannot be removed from non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective))
            (let* ((name (get-name~ child))
                   (parent (get-parent~ child))
                   (parent-form (find-form parent branch))
                   (form (find-form child branch)))
              (define (purge-references form)
                (when form
                  (let* ((parent-ancestry (component-ancestry parent))
                         (parent-form (owned-form form parent-ancestry)))
                    (when parent-form
                      (let ((child-form (find-child~ parent-form name)))
                        (when child-form
                          (remove-child~ parent-form child-form)))))))
              
              ;; Remove component from branch restore-form
              (when (is? effective Branch)
                (let* ((restore-form (get-restore-form~ effective))
                       (remove-form (find-by~ restore-form (lambda (form)
                                                             (and (eq? (get-action~ form) 'remove)
                                                                  (eq? (get-component~ form) child))))))
                  (remove-child~ restore-form remove-form)))
              
              (for-each-trait~ (if (is? effective Branch) (get-trait~ effective) effective)
                (lambda (trait)
                  (purge-references (get-client-form~ trait))))
              (close~ child)
              (remove-child~ parent-form form)
              (when design-events?
                (fire-child-remove child parent))
              (set-modified? #t)))))))
  
  
  (method public (remove-children parent (trait: trait #t) (design-events?: design-events? #t))
    (for-each (lambda (child)
                (remove-child child trait: trait design-events?: design-events?))
              (get-children~ parent)))
  
  
  (method public (move-component component destination (trait: trait #t))
    (move-components (list component) destination trait: trait))
  
  
  (method public virtual (move-components components destination (trait: trait #t))
    (assert (eq? (get-form~ (get-creator~ destination)) form))
    (let ((destination-form (get-form~ destination)))
      (for-each (lambda (component)
                  (assert (eq? (get-form~ (get-creator~ component)) form))
                  (set-parent~ component destination)
                  (let ((component-form (get-form~ component)))
                    (set-parent~ component-form destination-form)))
                components)
      (set-modified? #t)))
  
  
  (method public (can-move-component? component destination)
    (and (eq? (get-form~ (get-creator~ component)) form)
         (eq? (get-form~ (get-creator~ destination)) form)))
  
  
  (method public virtual (transfer-components components destination (trait: trait #t))
    (let* ((components (remove-redundant-descendants components))
           (parcels (package-components components))
           (name-resolution (verify-name-conflicts parcels destination)))
      (delete-components components trait: trait)
      (prog1 (instantiate-parcels parcels destination trait: trait name-resolution: name-resolution design-events?: #t descendant?: #f)
        (set-modified? #t))))
  
  
  (method public virtual (send-before child target (trait: trait #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ child))
           (parent-form (find-form parent branch))
           (child-form (find-form child branch))
           (target-form (and target (find-form target branch))))
      (send-before~ child target)
      (send-child-before~ parent-form child-form target-form)
      (fire-send-before child parent target)
      (set-modified? #t)))
  
  
  (method public (send-to-back child (trait: trait #t))
    (send-before child (first-child~ (get-parent~ child)) trait: trait))
  
  
  (method public (bring-to-front child (trait: trait #t))
    (send-before child #f trait: trait))
  
  
  ;; This is not a 100% complete solution as this for instance will
  ;; not restore the correct property values as remove-property would...
  (method public virtual (purge-trait component (trait: trait #t) (design-events?: design-events? #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ component))
           (parent-form (find-form parent branch)))
      (receive (form restore-form) (find-form component branch restore?: #t)
        (install-form~ component restore-form component #f #f)
        (remove-child~ parent-form form))))
  
  
  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (cut-components components)
    (let ((components (remove-redundant-descendants components)))
      (copy-components components)
      (delete-components components)))
  
  
  (method public virtual (copy-components components)
    (let ((components (remove-redundant-descendants components)))
      (let ((text (copy-components-text components)))
        (set-clipboard-text text format: 'jazz-parcels))))
  
  
  (method public (copy-components-text components (trait: trait #f))
    (let ((output (open-output-string))
          (parcels (package-components components trait: trait)))
      (format output "(")
      (for-each (lambda (parcel)
                  (format output "~{{a} " (category-name (class-of parcel)))
                  (format output "{a} " (get-process-id~ parcel))
                  (format output "{a} " (get-object-id~ parcel))
                  (format output "{a} " (get-imports~ parcel))
                  (format output "(")
                  (for-each (lambda (form)
                              (print-form form 0 output))
                            (get-content~ parcel))
                  (format output ")")
                  (format output "}"))
                parcels)
      (format output ")")
      (get-output-string output)))
  
  
  (method public virtual (paste-clipboard parent (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcels (get-jazz-parcels)))
      (paste-parcels parcels parent trait: trait design-events?: design-events?)))
  
  
  (method public virtual (paste-parcels parcels parent (trait: trait #t) (design-events?: design-events? #t) (reporter: reporter #f))
    (let* ((parent (determine-paster~ parent))
           (name-resolution (verify-name-conflicts parcels parent)))
      (prog1 (instantiate-parcels parcels parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: #f reporter: reporter)
        (set-modified? #t))))
  
  
  (method public virtual (paste-properties components (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcel (car (get-jazz-parcels))))
      (paste-parcel-properties parcel components trait: trait design-events?: design-events?)))
  
  
  (method public (paste-parcel-properties parcel components (trait: trait #t) (design-events?: design-events? #t))
    (let ((forms (get-content~ parcel)))
      (for-each (lambda (component)
                  (for-each (lambda (form)
                              (instantiate-properties component (get-properties~ form) trait design-events?))
                            forms))
                components)
      (set-modified? #t)))
  
  
  (method public virtual (delete-components components (trait: trait #t) (design-events?: design-events? #t))
    (let ((components (remove-redundant-descendants components)))
      (for-each (lambda (component)
                  (delete-component component trait: trait design-events?: design-events?))
                components)))
  
  
  (method public virtual (delete-component component (trait: trait #t) (design-events?: design-events? #t))
    (remove-child component trait: trait design-events?: design-events?))
  
  
  ;; For some operations like cut, copy, delete and move, having a component that
  ;; is a descendant of another one doesn't make sense and can lead to problems...
  (method (remove-redundant-descendants components)
    components
    ;; waiting for a bug fix in the tree selection update that this has uncovered
    @wait
    (collect-if (lambda (component)
                  (not (some? (lambda (target)
                                (and (neq? component target)
                                     (has-parent?~ component target)))
                              components)))
                components))
  
  
  ;;;
  ;;;; Package
  ;;;
  
  
  (method (package-components components (trait: trait #f))
    (define (component-forms component)
      (let ((ancestry (component-ancestry component))
            (forms '()))
        (iterate-branch-spine~ reference
          (lambda (owner form)
            (let ((form (owned-form form ancestry)))
              (when form
                (set! forms (cons form forms)))))
          trait: trait)
        (reverse forms)))
    
    (define (form-imports form)
      (let ((imports (case (get-action~ form)
                       ((new)
                        (let* ((context (get-context~ form))
                               (reference (get-reference~ context (get-model~ form)))
                               (serialization (serialize-runtime-reference reference)))
                          (list (if (eq? (first serialization) 'module-private)
                                    (receive (module symbol) (split-locator (second serialization))
                                      module)
                                  (second serialization)))))
                       (else
                        '()))))
        (remove-duplicates (apply append imports (map form-imports (get-children~ form))))))
    
    (define (replace-master forms component)
      (if (null? forms)
          forms
        (let ((master (copy-object~ (car forms) #t))
              (class-name (get-name~ (class-of component))))
          (receive (module models) (split-locator class-name)
            (let* ((model (car models))
                   (reference (deserialize-runtime-reference (list 'module-private class-name))))
              (set-action~ master 'new)
              (set-model~ master model)
              (setup-context~ master master)
              (set-locator~ master (let ((locator (get-locator~ master)))
                                     (lambda (symbol)
                                       (if (eq? symbol model) reference (locator symbol)))))
              (cons master (cdr forms)))))))
    
    (define (package-component component)
      (let ((forms (replace-master (component-forms component) component)))
        (if (and (not-null? forms) (memq? (get-action~ (car forms)) '(new install)))
            (let ((imports (map listify (apply union (map form-imports forms)))))
              (new Component-Parcel (current-process-id) (object->serial component) imports forms))
          (designer-error "Unable to find owner for {t}" component))))
    
    (map package-component components))
  
  
  ;;;
  ;;;; Instantiate
  ;;;
  
  
  (method public virtual (instantiate-parcels parcels parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f) (reporter: reporter #f))
    (map (lambda (parcel)
           (when reporter
             (user-message~ reporter "Pasting {a}..." (get-master-name~ parcel)))
           (prog1 (instantiate-parcel parcel parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: descendant?)
             (when reporter
               (step-it~ reporter))))
         parcels))
  
  
  (method public virtual (instantiate-parcel parcel parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (define (set-context-recursive form context)
      (set-context~ form context)
      (for-each (lambda (child) (set-context-recursive child context)) (get-children~ form)))
    
    (let* ((forms (get-content~ parcel))
           (master (car forms))
           (name (get-name~ master)))
      (let* ((brothers (get-children~ parent))
             (domain (map get-name~ brothers))
             (equal (sort-predicate 'equal))
             (conflict? (and name (member? name domain test: equal))))
        (when conflict?
          (case name-resolution
            ((rename) (set! name (unique-name name domain))
             (for-each (lambda (form)
                         (set-name~ form name))
                       forms))
            ((override) (let ((conflicts (name-conflicts (list name) brothers)))
                          (delete-components conflicts trait: trait))))))
      (let ((imports (get-imports~ parcel)))
        (let ((locator (imports-locator imports)))
          (for-each (lambda (f)
                      (set-locator~ f locator)
                      (set-context-recursive f f))
                    forms))
        (let ((component (instantiate-form name name-resolution master parent trait design-events? descendant? imports: imports)))
          (for-each (lambda (form)
                      (instantiate-form name #f form parent trait design-events? descendant?))
                    (cdr forms))
          component))))
  
  
  (method public virtual (instantiate-form name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component name name-resolution form parent trait design-events? descendant? imports: imports)))
      (when component
        (instantiate-properties component (get-properties~ form) trait design-events?)
        (instantiate-children component (get-children~ form) trait design-events?)
        component)))

  
  (method public virtual (instantiate-component name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((action (get-action~ form)))
      (case action
        ((new) (instantiate-new-component name form parent trait design-events? descendant? imports: imports))
        ((modify locate) (find-to-modify~ parent (get-name~ form) (sort-predicate 'equal)))
        (else (designer-error "Unsupported form action: {t}" action)))))
  
  
  (method public virtual (instantiate-new-component name form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component~ form parent: parent)))
      (add-child component parent trait: trait name: name design-events?: design-events? descendant?: descendant? import: imports)
      component))
  
  
  (method public virtual (instantiate-properties component properties trait design-events?)
    (for-each-property (lambda (property value)
                         (set-property component property value trait: trait design-events?: design-events? undoable?: #f))
                       properties))

  
  (method public virtual (instantiate-children component children trait design-events?)
    (for-each (lambda (form)
                (instantiate-form (get-name~ form) #f form component trait design-events? #t))
              children))
  
  
  ;;;
  ;;;; Unique
  ;;;
  
  
  (method protected virtual (unique-name name domain)
    (let ((unique-name (unique-domain-name (->string name) (map ->string domain) separator: (unique-separator))))
      (if (symbol? name)
          (string->symbol unique-name)
        unique-name)))
  
  
  (method protected virtual (unique-separator)
    "_")
  
  
  ;;;
  ;;;; Conflicts
  ;;;
  
  
  (definition (name-conflicts names children)
    (let ((equal (sort-predicate 'equal)))
      (collect-if (lambda (child)
                    (let ((child-name (get-name~ child)))
                      (and child-name
                           (some? (lambda (name)
                                    (equal child-name name))
                                  names))))
                  children)))
  
  
  (method public (verify-name-conflicts parcels destination)
    (define (confirm-name-resolution children conflicts)
      (define (present-conflicts header conflicts)
        (let ((fact (new List-Factory)))
          (put~ fact header)
          (for-each (lambda (conflict)
                      (put~ fact (list :bulleted (->string (get-name~ conflict)))))
                    conflicts)
          (get-output~ fact)))
      
      (if (every? (lambda (parcel)
                    (let ((equal (sort-predicate 'equal))
                          (process-id (get-process-id~ parcel))
                          (component-id (get-object-id~ parcel))
                          (name (get-master-name~ parcel)))
                      (and (= process-id (current-process-id))
                           (some? (lambda (child)
                                    (and (= component-id (object->serial child))
                                         (equal name (get-name~ child))))
                                  children))))
                  parcels)
          'rename
        (let* ((header "The following conflicts where detected. Override destination?")
               (text (present-conflicts header conflicts))
               (code (message-box text type: 'question)))
          (case code
            ((yes) 'override)
            ((no) (throw-cancel))))))
    
    (let* ((names (map get-master-name~ parcels))
           (children (get-children~ destination))
           (conflicts (name-conflicts names children)))
      (when (not-null? conflicts)
        (confirm-name-resolution children conflicts))))
  
  
  ;;;
  ;;;; View
  ;;;
    
  
  ;; This special support for views is not clean, but it is better
  ;; than having it directly inside add-child where it was before!
  (method public virtual (add-view child parent . rest)
    (bind-keywords ((name #f) (position #f) (centered? #f) (visible? #t) . others) rest
      (apply add-child child parent name: name others)
      (when position
        (set-property child 'position position))
      (when centered?
        (let ((size (get-size~ child)))
          (move-figure~ child (- (quotient (get-width~ size) 2)) (- (quotient (get-height~ size) 2)))))
      (when visible?
        (set-visible?~ child #t))
      (set-modified? #t)))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  ;; package modifier is for tests
  (method package (find-form component branch (restore?: restore? #f) (error?: error? #t))
    (define (embed-form form ancestry)
      (for-each (lambda (cpn)
                  (let ((children (get-children~ form))
                        (cpn-form (get-form~ cpn)))
                    (if (not cpn-form)
                        (embed-new-form form #f)
                      (if (memq? cpn-form children)
                          (set! form cpn-form)
                        (let ((restore-form (find-in children cpn key: (lambda (form) (and (is? form Restore-Form) (get-component~ form))))))
                          (if restore-form
                              (set! form restore-form)
                            (let ((name (get-name~ cpn)))
                              (if (not name)
                                  (designer-error "Component {t} must be named to allow modification" cpn)
                                (let ((subform (find-in children name key: get-name~ test: equal?)))
                                  (if (not subform)
                                      (set! form (embed-new-form form name))
                                    (set! form subform)))))))))))
                ancestry)
      form)
    
    (define (embed-new-form form name)
      (let ((subform (new Form action: 'modify context: (get-context~ form) name: name)))
        (add-child~ form subform)
        subform))
    
    (let* ((ancestry (component-ancestry component))
           (trait-form (if branch (get-client-form~ (get-trait~ branch)) form))
           (restore-form (and restore? branch (get-restore-form~ branch)))
           (form (embed-form trait-form ancestry))
           (restore (and restore-form (embed-form restore-form ancestry))))
      (if (and error? (not form))
          (designer-error "Unable to locate target form")
        (if restore?
            (values form restore)
          form))))
  
  
  (method (target-branch trait)
    (cond ((eq? trait #t) (get-active-branch~ reference))
          ((is? trait Path) (follow-component~ trait reference))
          (else (find-trait-branch~ reference trait))))
  
  
  (method (component-ancestry component)
    (let ((end? (lambda (scan)
                  (if scan
                      (eq? scan reference)
                    (designer-error "{t} is not a descendant of the reference component {t}" component reference)))))
      (unfold-right end? identity get-parent-component~ component)))
  
  
  ;;;
  ;;;; Owner
  ;;;
  
  
  (method public (find-owner component (property #f))
    (let ((ancestry (component-ancestry component)))
      (continuation-capture
        (lambda (return)
          (iterate-branch-spine~ reference
            (lambda (owner form)
              (when form
                (let ((form (owned-form form ancestry)))
                  (when (and form
                             (or (and (not property) (eq? (get-action~ form) 'new))
                                 (and property (has-property?~ form property))))
                    (continuation-return return owner))))))
          #f))))
  
  
  (method (find-next-branch branch component property)
    (if (not branch)
        (values #f #f)
      (let ((lower (get-branches~ (or branch reference)))
            (ancestry (component-ancestry component)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (branch)
                        (let ((client-form (get-client-form~ branch)))
                          (when client-form
                            (let ((form (owned-form client-form ancestry)))
                              (when (and form (has-property?~ form property))
                                (continuation-return return (values form (owned-form (get-restore-form~ branch) ancestry))))))))
                      lower)
            (values #f #f))))))
  
  
  (definition (owned-form form ancestry)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (cpn)
                    (let ((children (get-children~ form))
                          (cpn-form (get-form~ cpn)))
                      (if (not cpn-form)
                          (continuation-return return #f)
                        (if (memq? cpn-form children)
                            (set! form cpn-form)
                          (let ((name (get-name~ cpn)))
                            (if (not name)
                                (continuation-return return #f)
                              (let ((subform (find-in children name key: get-name~ test: equal?)))
                                (if (not subform)
                                    (continuation-return return #f)
                                  (set! form subform)))))))))
                  ancestry)
        form)))
  
  
  ;;;
  ;;;; Value
  ;;;
  
  
  ;; Until a fully generic solution, these methods implement the following special case:
  ;; - the trait must be the owner of the property (i.e. have set it)
  
  
  (method public (get-name path (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-name~ (follow-form~ path form))))
  
  
  (method public (get-property path property (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-property~ (follow-form~ path form) property)))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method public (edit-form)
    (let ((appl (get-application))
          (origin (get-origin~ form)))
      (define (find-entry locator)
        ((module-ref 'jazz.project 'locator->entry) locator))
      
      (cond ((not origin)
             (edit~ (find-entry (category-identifier (class-of reference)))))
            ((file? origin)
             (edit-document~ appl origin class: Jazz-Text-View))
            ((find-entry (get-name~ origin)) => edit~)
            (else
             (receive (module class) (break-reference (get-name~ origin))
               (edit-document~ appl (find-unit-source module) class: Jazz-Text-View))))))
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method public (safe-set-property . rest)
    (with-safe-design
      (lambda ()
        (apply set-property rest))))
  
  
  ;;;
  ;;;; Fire
  ;;;
  
  
  (definition (fire-name-change component name old-name undoable?)
    (for-each (lambda (designer)
                (process-name-change~ designer component name old-name undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-presentation-change component presentation old-presentation undoable?)
    (for-each (lambda (designer)
                (process-presentation-change~ designer component presentation old-presentation undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-property-change branch component property value undoable?)
    (for-each (lambda (designer)
                (process-property-change~ designer branch component property value undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-child-add child parent descendant?)
    (for-each (lambda (designer)
                (process-child-add~ designer child parent descendant?))
              (get-designers~ parent)))
  
  
  (definition (fire-child-remove child parent)
    (for-each (lambda (designer)
                (process-child-remove~ designer child parent))
              (get-designers~ child)))
  
  
  (definition (fire-send-before child parent target)
    (for-each (lambda (designer)
                (process-send-before~ designer child parent target))
              (get-designers~ child)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-designer-listener listener)
    (set! listeners (add-listener listener listeners)))
  
  
  (method public (remove-designer-listener listener)
    (set! listeners (remove-listener listener listeners)))

  
  (method (process-name-change component name old-name undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :name-change self component: component name: name old-name: old-name undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-presentation-change component presentation old-presentation undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :presentation-change self component: component presentation: presentation old-presentation: old-presentation undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-property-change branch component property value undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :property-change self branch: branch component: component property: property value: value undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-add child parent descendant?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-add self child: child parent: parent descendant?: descendant?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-remove child parent)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-remove self child: child parent: parent)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-send-before child parent target)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :send-before self child: child parent: parent target: target)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-refresh component what)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :refresh self component: component what: what)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-user-event event)
    (when (not-null? listeners)
      (for-each (lambda (listener)
                  (invoke~ listener self event))
                listeners)))))
