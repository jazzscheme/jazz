;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Designer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.designer.designer.Designer jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.designer.view)
        (jazz.editor.jazz)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view))


(class Designer extends Object
  
  
  (slot form      initialize #f accessors generate)
  (slot form-copy initialize #f accessors generate)
  (slot reference initialize #f getter generate)
  (slot listeners initialize '())
  (slot modified? initialize #f accessors generate)
  (slot undoer    initialize #f getter generate)

  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (initialize (form: form #f) (reference: reference #f))
    (define (setup-form frm)
      (if (not frm)
          (begin
            (set! form~self (new Form textual?: #f origin: (class-of reference) action: 'install))
            (set-context~ form~self form~self)
            (set-data~ form~self (new Data #f 'jazz '() #f)))
        (let ((origin (get-origin~ frm)))
          (set! form~self frm)
          (cond ((class? origin)
                 (setup-class-form frm))
                ((designing-trait?)
                 (setup-trait-form frm))))))
    
    ;; Setting form to a copy until saving is a tempting approach,
    ;; but fails because we absolutly need pointer equality as a test
    ;; for embed-form to work correctly with anonymous forms.
    ;; So the approach taken will be more like relational databases
    ;; where we modify the database directly but keep a log of
    ;; transactions in order to be able to rollback changes (and it
    ;; makes lots of sense to, because a designer is really the interface
    ;; by which Jazz's object-oriented databases are updated!).
    ;;
    ;; Or maybe simply take a copy before the first modification is made
    ;; (lazy approach) and if we need to rollback, set the original form
    ;; to the copy.
    (define (setup-class-form frm)
      (set! form-copy (copy-object~ frm #t)))
    
    (define (setup-client-forms form-copy)
      (set-property~ form-copy client-form: (copy-object~ (get-property~ form-copy client-form:) #t))
      (for-each setup-client-forms (get-children~ form-copy)))
    
    (define (setup-trait-form frm)
      (set! form-copy (copy-object~ frm #t))
      (setup-client-forms (first-child~ form-copy)))
    
    (define (setup-undoer)
      (set! undoer (new Undoer reset-modified: reset-modified?)))
    
    (nextmethod)
    (set! reference~self reference)
    (setup-form form)
    (setup-undoer))
  
  
  ;;;
  ;;;; Revert
  ;;;
  
  
  (method public (revert)
    (let ((origin (get-origin~ form)))
      (cond
        ((class? origin)
         (set-class-form~ origin form-copy))
        ((designing-trait?)
         (revert-trait origin)))))
  
  
  (method public (revert-trait reference)
    (define (revert-form trait form)
      (set-form~ trait form)
      (set-client-form~ trait (get-property~ form client-form:))
      (for-each (lambda (child)
                  (let* ((name (get-name~ child))
                         (child-form (find-child~ form name)))
                    (if child-form
                        (revert-form child child-form)
                      (remove-child~ trait child))))
                (get-children~ trait)))
    
    (let ((trait (resolve-runtime-reference reference)))
      (revert-form trait (first-child~ form-copy))))
  
  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method public virtual (save (default-extension: default-extension #f) (extensions: extensions '()))
    (with-cursor :wait
      (lambda ()
        (let ((origin (get-origin~ form)))
          (if (not origin)
              (save-as default-extension: default-extension extensions: extensions)
            (save-content origin))))))
  
  
  (method public (save-to file)
    (if (not file)
        (save-as)
      (set-origin~ form file)
      (save-to-file file)
      (set-modified? #f)))
  
  
  (definition Default-Extension
    "jmf")
  
  (definition Default-Extensions
    '(("JMF Files" . "jmf")))
  
  
  (method (save-as (default-extension: default-extension #f) (extensions: extensions '()))
    (let* ((toolbox-managers (get-toolbox-managers))
           (destination (if (null? toolbox-managers)
                            (choose-new-file default-extension: (or default-extension Default-Extension) extensions: (or extensions Default-Extensions))
                          (choose-new-destination toolbox-managers))))
      (save-content destination)))
  
  
  (method (choose-new-destination toolbox-managers)
    (define (parse-class-name class-string)
      (let ((content (with-exception-catcher
                       (lambda (err) #f)
                       (lambda () (read-string-content class-string)))))
        (and content
             (= 1 (length content))
             (symbol? (car content))
             (car content))))
    
    (define (validate-class-name module-name class-name)
      (if class-name
          (let* ((not-found (list #f))
                 (ref (module-get module-name class-name not-found: not-found)))
            (if (eq? ref not-found)
                class-name
              (designer-error "Existing class")))
        (designer-error "Invalid class name")))
    
    (define (validate-module-name module-name)
      (if module-name
          (with-exception-catcher
            (lambda (exc)
              (designer-error "Non-existant module"))
            (lambda ()
              (require-module module-name)))
        (designer-error "Empty module")))
    
    (define (evaluate-class module-name class-name super-class-name imports)
      (evaluate-in-unit module-name `(import ,@imports) eval)
      (evaluate-in-unit module-name `(class ,class-name extends ,super-class-name) eval)
      (module-ref module-name class-name))
    
    (define (insert-class text class-name super-class-name)
      (let ((explorer (new Jazz-Explorer (get-model~ text))))
        (forward-namespace~ explorer)
        ;; We suppose the import form exist
        (forward-expr~ explorer)
        (set-caret~ text (get-end~ explorer))
        (let ((class-string (format "{%}{%}{%}(class {a} extends {a})" class-name super-class-name)))
          (insert-string~ text class-string))))
    
    (let* ((modules (apply union test: eq? (map get-module-names~ toolbox-managers)))
           (result (get-modal Save-Chooser modules: modules)))
      (if (is? result File)
          result
        (bind (module-name class-string) result
          (with-safe-design
            (lambda ()
              (let ((class-name (parse-class-name class-string))
                    (super-class-name (super-class-name form)))
                (validate-module-name module-name)
                (validate-class-name module-name class-name)
                (call-with-saved-text (find-unit-source module-name)
                  (lambda (text)
                    (let ((imports (imports-to-insert form super-class-name module-name)))
                      (insert-imports text imports)
                      (insert-class text class-name super-class-name)
                      (evaluate-class module-name class-name super-class-name imports)))))))))))
  
    
  (method (super-class-name form)
    (or (get-model~ form)
        (category-name (class-ascendant (get-origin~ form)))))
  
  
  (method (imports-to-insert form super-class-name module-name)
    (define (super-class-import)
      (and super-class-name
           (eq? 'install (get-action~ form))
           (receive (unit _) (split-locator (get-name~ (get-origin~ form)))
             (let ((ser (serialize-runtime-reference (evaluate-in-unit unit `(reference ,super-class-name) eval))))
               (if (eq? (first ser) 'module-private)
                   (origin-import form)
                 (second ser))))))
    
    (let* ((super-class-import (super-class-import))
           (modules (remove-duplicates (append (default-designer-imports~ (get-application))
                                               (if super-class-import (list super-class-import) '())
                                               (form-imports form (and (is? (get-origin~ form) Class) (origin-import form)))))))
      (if module-name (remove module-name modules) modules)))
  
  
  (method (save-content destination)
    (typecase destination
      ((File) (save-to-file destination))
      ((Class) (save-to-class destination))
      ((Runtime-Reference) (save-to-reference destination))
      (else (error "unsupported destination")))
    (set-modified? #f)
    destination)
  
  
  (method (origin-import form)
    (let ((origin (get-origin~ form)))
      (and origin 
           (is? origin Class)
           (let ((toolbox-models (apply union (map get-toolbox-models~ (get-toolbox-managers)))))
             (receive (module models) (split-locator (get-name~ origin))
               (let ((toolbox-model (find-in toolbox-models (car models) key: get-model~)))
                 (if toolbox-model
                     (get-unit~ toolbox-model)
                   module)))))))
  
  
  (method public (designing-trait?)
    (let ((origin (get-origin~ form)))
      (and (is? origin Runtime-Reference)
           (let ((obj (resolve-runtime-reference origin)))
             (is? obj Trait)))))
  
  
  (method (save-to-trait unit symbol)
    (define (select-trait text)
      (let ((explorer (new Jazz-Explorer (get-model~ text))))
        (forward-location~ explorer (list symbol) toplevel-location: (list unit))
        (set-selection~ text (get-range~ explorer))))
    
    (let ((imports (imports-to-insert form #f unit))
          (trait-form (first (get-children~ form)))
          (class-sym (get-model~ form)))
      (call-with-saved-text (find-unit-source unit)
        (lambda (text)
          (insert-imports text imports)
          (select-trait text)
          (insert-string~ text (format "(define-trait {a} {a}{%}{a})" symbol class-sym (form->string trait-form 2 include-form?: #f)))
          (select-trait text)
          (tabulate~ text)))))
  
  
  (method (save-to-reference reference)
    (bind (_ unit symbol) (serialize-runtime-reference reference)
      (typecase (module-ref unit symbol)
        ((Trait)
         (save-to-trait unit symbol))
        (else
         (error "Unknown save target")))))
  
  
  (method (save-to-class class)
    (let ((class-name (category-name class))
          (module-name (category-unit class)))
      
      (define (save-to-existing-class text)
        (let ((form-exists? (eq? form (get-class-form~ class)))
              (imports (imports-to-insert form #f module-name)))
          (insert-imports text imports)
          (save-form text form form-exists?)
          (tabulate-form text)
          (unless form-exists? (evaluate-form form imports))))
      
      (define (save-to-new-class text)
        (let ((adjusted-form (new Form textual?: #f action: 'install properties: (get-properties~ form) children: (get-children~ form)))
              (origin (get-origin~ form)))
          (save-form text adjusted-form #f)
          (tabulate-form text)
          ;; If we are saving in a new class from an old class
          (when origin (revert))
          (evaluate-form adjusted-form #f)))
      
      (define (tabulate-form text)
        (let ((explorer (new Jazz-Explorer (get-model~ text))))
          (forward-location~ explorer (list class-name :form))
          (set-selection~ text (get-range~ explorer))
          (tabulate~ text)))
      
      (define (save-form text form form-exists?)
        (let ((explorer (new Jazz-Explorer (get-model~ text)))
              (where (if form-exists? :form :new-form))
              (str (form->string form 2)))
          (forward-location~ explorer (list class-name where))
          (set-selection~ text (get-range~ explorer))
          (insert-string~ text (format (if form-exists? "{a}" "{%}{%}{%}{a}") str))))
      
      (define (evaluate-form form imports)
        (let ((super-class-name (category-name (class-ascendant class)))
              (form-expr (parameterize ((walk-for 'eval))
                           (with-jazz-readtable
                             (lambda ()
                               (read-string-element
                                 (->string (->jml~ (form->node form)))))))))
          (when imports
            (evaluate-in-unit module-name `(import ,@imports) eval))
          (evaluate-in-unit
            module-name
            `(class ,class-name extends ,super-class-name
               (form
                 ,form-expr))
            eval)))
      
      (call-with-saved-text (find-unit-source module-name)
        (lambda (text)
          (if (is? reference class)
              (save-to-existing-class text)
            (save-to-new-class text))))))
  
  
  (method (save-to-file file)
    (define (adjust-form form)
      (if (is? (get-origin~ form) Class)
          (let ((adjusted-form (copy-object~ form #f)))
            (set-action~ adjusted-form 'new)
            (set-model~ adjusted-form (super-class-name form))
            adjusted-form)
        form))
    
    (if (and (exists?~ file) (read-only?~ file))
        (message-box (format "Unable to save to read-only file: {s}" file))
      (call-with-output-file (path-settings file char-encoding: 'UTF-8)
        (lambda (output)
          (let ((data (get-data~ form))
                (origin (get-origin~ form))
                (adjusted-form (adjust-form form)))
            (output-header (get-model~ adjusted-form) output)
            (format output "{%}{%}")
            (format output "(data {a}{%}" (if data (get-dialect~ data) 'jazz))
            (format output "{%}{%}")
            (let ((imports (if data
                               (get-imports~ data)
                             (imports-to-insert form (super-class-name form) #f))))
              (when (and imports (not-null? imports))
                (format output "(import {s}" (car imports))
                (for-each (lambda (import)
                            (format output "{%}        {s}" import))
                          (cdr imports))
                (format output  "){%}{%}{%}")))
            (print-file-form adjusted-form 1 output)
            (format output "){%}")
            (when origin
              (revert)))))))


  (method public (saved-form . rest)
    (apply form->string form rest))
  
  
  (method public (print-to . rest)
    (apply print-file-form form rest))
  
  
  (method (reset-modified?)
    (set-modified? #f))
  
  
  ;;;
  ;;;; Design
  ;;;
  
  
  (method public virtual (set-default-traits component traits-references (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t) (imports: imports #f))
    (let* ((owner (find-owner component)))
      (if (neq? owner reference)
          (designer-error "Default traits cannot be changed in non owner root {a}" (get-presentation-property~ reference))
        (when imports
          (add-import imports))
        (for-each (lambda (ref)
                    (setup-context~ ref form))
                  traits-references)
        (set-default-traits~ component traits-references)
        (set-property~ form default-traits: traits-references)
        (when design-events?
          (fire-refresh component 'all))
        (set-modified? #t))))
  
  
  (method public virtual (set-name component name (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (owner (find-owner component))
           (effective (or branch reference))
           (effective-cpn (if (is? effective Branch) (get-trait~ effective) effective)))
      (if (and owner (neq? owner effective))
          (designer-error "Component cannot be renamed in non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective-cpn))
        (let ((form (find-form component branch))
              (old-name (get-name~ component))
              (old-presentation (get-presentation-property~ component)))
          (for-each-trait~ effective-cpn
            (lambda (trait)
              (let ((form (get-client-form~ trait)))
                (when form
                  (let* ((ancestry (component-ancestry component reference))
                         (component-form (owned-form form ancestry)))
                    (when (and component-form (neq? (get-action~ component-form) 'install))
                      (set-name~ component-form name)))))))
          (set-name~ component name)
          (set-name~ form name)
          (when design-events?
            (fire-name-change component name old-name undoable?)
            (let ((presentation (get-presentation-property~ component)))
              (fire-presentation-change component presentation old-presentation undoable?))
            (let ((property (property-field (class-of component) 'name-info)))
              (fire-property-change branch component property name undoable?)))
          (set-modified? #t)))))
  
  
  (method public virtual (set-property component/path property value (old-value: old-value #f) (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t) (import: import #f))
    (let ((branch (target-branch trait)))
      ;; Quick fix for the special case of setting a property of the active trait
      (if (eq? component/path trait)
          (set-property component/path property value trait: #f design-events?: design-events? undoable?: undoable?)
        (let ((installed? (or (not branch) (is? branch Branch)))
              (path? (is? component/path Path)))
          (if (and path? (not installed?))
              (let ((form (follow-form~ component/path (if branch (get-client-form~ (get-trait~ branch)) form))))
                (set-property~ form property value))
            (let* ((component (if path? (follow-component~ component/path reference) component/path))
                   (property (if component (property-field (class-of component) property) property)))
              (assert property)
              ;; This validation should probably also be done in other operations...
              (when (and component (not installed?))
                (let ((creator-branch (get-creator-branch~ component)))
                  ;; This test is not 100% correct as the creator-branch can be any parent branch of branch
                  (when (and creator-branch (neq? branch (get-creator-branch~ component)))
                    (designer-error "Unable to modify an explicit trait using a component having a different branch creator"))))
              (receive (form restore) (find-form component branch restore?: #t)
                (receive (next-form next-restore) (find-next-branch branch component property)
                  (let ((old-value (or old-value (read-property component property)))
                        (remove?   (not (has-property?~ form property))))
                    (set-property~ form property value)
                    (when undoable?
                      (register-undo~ undoer
                        (lambda ()
                          (if remove?
                              (remove-property component/path property old-value)
                            (set-property component/path property old-value))))))
                  (when import
                    (add-import import))
                  (when (is? value Reference)
                    (setup-context~ value (get-form)))
                  (when installed?
                    (if (not next-form)
                        (let ((old-value (or old-value (read-property component property))))
                          (when (and restore (not (has-property?~ restore property)))
                            (set-property~ restore property old-value))
                          (let* ((fire-presentation? (and design-events? (presentation-property?~ component property)))
                                 (old-presentation (and fire-presentation? (get-presentation-property~ component))))
                            (write-property component property value)
                            (when design-events?
                              (when fire-presentation?
                                (let ((presentation (get-presentation-property~ component)))
                                  (fire-presentation-change component presentation old-presentation undoable?)))
                              (fire-property-change branch component property value undoable?))))
                      (when (and restore (not (has-property?~ restore property)))
                        (set-property~ restore property (get-property~ next-restore property)))
                      (set-property~ next-restore property value)))))))
          (set-modified? #t)))))
  
  
  ;; This works well really only with branches because else we don't have restore information
  (method public virtual (remove-property component/path property default-value (trait: trait #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch trait))
           (installed? (or (not branch) (is? branch Branch)))
           (path? (is? component/path Path))
           (component (if path? (follow-component~ component/path reference) component/path))
           (property (property-field (class-of component) property)))
      (assert property)
      (receive (form restore) (find-form component branch restore?: #t)
        (receive (next-form next-restore) (find-next-branch branch component property)
          (when (has-property?~ form property)
            (remove-property~ form property)
            (let ((old-value (read-property component property)))
              (when undoable?
                (register-undo~ undoer
                  (lambda ()
                    (set-property component/path property old-value)))))
            (let ((value (if (not restore) default-value (get-property~ restore property))))
              (when installed?
                (if (not next-form)
                    (begin
                      (write-property component property value)
                      (when design-events?
                        (fire-property-change branch component property value undoable?)))
                  (set-property~ next-restore property value))))
            (when restore
              (remove-property~ restore property))
            (set-modified? #t))))))
  
  
  ;; tofix
  (method public virtual (add-import import)
    (let ((imports (map listify (listify import)))
          (origin-form (get-context~ (get-form))))
      (when (not-null? imports)
        (let ((old-locator (get-locator~ origin-form)))
          (set-locator~ origin-form (let ((new-locator (imports-locator imports)))
                                      (lambda (symbol)
                                        (or (new-locator symbol)
                                            (old-locator symbol)))))))
      (let ((data (get-data~ origin-form)))
        (when data
          (for-each (lambda (import) (add-import~ data import)) imports)))))
  
  
  (method public virtual (add-child child parent (undoable?: undoable? #t) (form: form #f) (trait: trait #t) (name: name #f) (properties: properties '()) (tag-reference: tag-reference #f) (import: import '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (define (make-new-child-form parent-form)
      (let* ((child-origin-form (get-form~ child))
             (child-is-form? (and child-origin-form (is? (get-origin~ child-origin-form) File))))
        (new Form
          textual?: #f
          context: (get-context~ parent-form)
          action: (if tag-reference 'instantiate 'new)
          model: (cond (tag-reference #f)
                       (child-is-form? (get-name~ child-origin-form))
                       (else (category-name (class-of child))))
          tag-reference: tag-reference)))
    
    (let ((branch (target-branch trait)))
      (unless (eq? (get-parent~ child) parent)
        (set-parent~ child parent))
      (receive (parent-form restore) (find-form parent branch restore?: #t)
        (let ((child-form (or form (make-new-child-form parent-form))))
          (set-form~ child child-form)
          (add-form~ parent parent-form child-form)
          (when undoable?
            (register-undo~ undoer
              (lambda ()
                (remove-child child)))))
        (when restore
          (remember-creation~ restore self child))
        (when name
          (set-name child name trait: trait design-events?: #f))
        (set-creator~ child reference)
        (add-to-index~ reference (get-name~ child) child)
        (when properties
          (for-each-property (lambda (property value)
                               (set-property child property value trait: trait design-events?: design-events?))
                             properties))
        (when import
          (add-import import))
        ;; the two sexpr where toggled so that the
        ;; event occurs after the properties are set
        (when design-events?
          (fire-child-add child parent descendant?))
        (set-modified? #t)))
    child)
  
  
  (method public virtual (add-form form parent (trait: trait #t) (name: name #f) (imports: imports '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (with-atomic-undo~ undoer
      (lambda ()
        (let ((child (instantiate-form name #f form parent trait design-events? descendant? imports: imports)))
          (register-undo~ undoer
            (lambda ()
              (remove-child child)))
          child))))
  
  
  (method public virtual (apply-form form component (trait: trait #t) (design-events?: design-events? #t))
    (with-atomic-undo~ undoer
      (lambda ()
        (instantiate-content form component trait design-events?))))

  
  (method public virtual (remove-child child (trait: trait #t) (design-events?: design-events? #t))
    (let ((branch (target-branch trait)))
      (if (eq? child reference)
          (designer-error "The reference component cannot be removed")
        (let ((effective (or branch reference))
              (owner (find-owner child)))
          ;; the (and owner) part is a try
          (if (and owner (neq? owner effective))
              (designer-error "Component cannot be removed from non owner {a} {a}" (if trait "trait" "root") (get-presentation-property~ effective))
            (let* ((name (get-name~ child))
                   (parent (get-parent~ child))
                   (parent-form (find-form parent branch))
                   (form (find-form child branch)))
              (define (purge-references form)
                (when form
                  (let* ((parent-ancestry (component-ancestry parent reference))
                         (parent-form (owned-form form parent-ancestry)))
                    (when parent-form
                      (let ((child-form (find-child~ parent-form name)))
                        (when child-form
                          (remove-child~ parent-form child-form)))))))
              
              ;; Remove component from branch restore-form
              (when (is? effective Branch)
                (let* ((restore-form (get-restore-form~ effective))
                       (remove-form (find-by~ restore-form (lambda (form)
                                                             (and (eq? (get-action~ form) 'remove)
                                                                  (eq? (get-component~ form) child))))))
                  (remove-child~ restore-form remove-form)))
              
              (for-each-trait~ (if (is? effective Branch) (get-trait~ effective) effective)
                (lambda (trait)
                  (purge-references (get-client-form~ trait))))
              (register-undo~ undoer
                (lambda ()
                  (add-child child parent form: form)))
              (set-parent~ child #f)
              (remove-child~ parent-form form)
              (when design-events?
                (fire-child-remove child parent))
              (set-modified? #t)))))))
  
  
  (method public virtual (remove-components components)
    (with-atomic-undo~ undoer
      (lambda ()
        (for-each remove-child components))))
  
  
  (method public (remove-children parent (trait: trait #t) (design-events?: design-events? #t))
    (for-each (lambda (child)
                (remove-child child trait: trait design-events?: design-events?))
              (get-children~ parent)))
  
  
  (method public (relocate-component component destination (trait: trait #t) (design-events?: design-events? #t))
    (relocate-components (list component) destination trait: trait design-events?: design-events?))
  
  
  (method public virtual (relocate-components components destination (trait: trait #t) (design-events?: design-events? #t))
    (let ((destination-form (get-form~ destination)))
      (for-each (lambda (component)
                  (let ((parent (get-parent~ component))
                        (form (get-form~ component)))
                    (remove-child component trait: trait)
                    (add-child component destination form: form trait: trait)))
                components)
      (set-modified? #t)))
  
  
  (method public (can-relocate-component? component destination)
    (and (addable-class?~ destination (class-of component))
         (component-owned-by-reference? component)))
  
  
  (method public (can-relocate-components? components destination)
    (every? (lambda (component)
              (can-relocate-component? component destination))
            components))
  
  
  (method public virtual (transfer-components components destination (trait: trait #t))
    (let* ((components (remove-redundant-descendants components))
           (parcels (package-components components))
           (name-resolution (verify-name-conflicts parcels destination)))
      (delete-components components trait: trait)
      (prog1 (instantiate-parcels parcels destination trait: trait name-resolution: name-resolution design-events?: #t descendant?: #f)
        (set-modified? #t))))
  
  
  (method public virtual (send-before child target (trait: trait #t))
    (unless (eq? child target)
      (let* ((branch (target-branch trait))
             (parent (get-parent~ child))
             (parent-form (find-form parent branch))
             (child-form (find-form child branch))
             (target-form (and target (find-form target branch))))
        (send-before~ child target)
        (send-child-before~ parent-form child-form target-form)
        (fire-send-before child parent target)
        (set-modified? #t))))
  
  
  (method public (send-to-back child (trait: trait #t))
    (send-before child (first-child~ (get-parent~ child)) trait: trait))
  
  
  (method public (bring-to-front child (trait: trait #t))
    (send-before child #f trait: trait))
  
  
  ;; This is not a 100% complete solution as this for instance will
  ;; not restore the correct property values as remove-property would...
  (method public virtual (purge-trait component (trait: trait #t) (design-events?: design-events? #t))
    (let* ((branch (target-branch trait))
           (parent (get-parent~ component))
           (parent-form (find-form parent branch)))
      (receive (form restore-form) (find-form component branch restore?: #t)
        (install-form~ component restore-form component #f #f)
        (remove-child~ parent-form form))))
  
  
  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (cut-components components)
    (let ((components (remove-redundant-descendants components)))
      (copy-components components)
      (delete-components components)))
  
  
  (method public virtual (copy-components components)
    (let ((components (remove-redundant-descendants components)))
      (let ((text (copy-components-text components)))
        (set-clipboard-text text format: 'jazz-parcels))))
  
  
  (method public (copy-components-text components (trait: trait #f))
    (let ((output (open-output-string))
          (parcels (package-components components trait: trait)))
      (format output "(")
      (for-each (lambda (parcel)
                  (format output "~{{a} " (category-name (class-of parcel)))
                  (format output "{a} " (get-process-id~ parcel))
                  (format output "{a} " (get-object-id~ parcel))
                  (format output "{a} " (get-imports~ parcel))
                  (format output "(")
                  (for-each (lambda (form)
                              (print-form form 0 output))
                            (get-content~ parcel))
                  (format output ")")
                  (format output "}"))
                parcels)
      (format output ")")
      (get-output-string output)))
  
  
  (method public virtual (paste-clipboard parent (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcels (get-jazz-parcels)))
      (paste-parcels parcels parent trait: trait design-events?: design-events?)))
  
  
  (method public virtual (paste-parcels parcels parent (trait: trait #t) (design-events?: design-events? #t) (reporter: reporter #f))
    (let* ((parent (determine-paster~ parent))
           (name-resolution (verify-name-conflicts parcels parent)))
      (prog1 (instantiate-parcels parcels parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: #f reporter: reporter)
        (set-modified? #t))))
  
  
  (method public virtual (paste-properties components (trait: trait #t) (design-events?: design-events? #t))
    (let ((parcel (car (get-jazz-parcels))))
      (paste-parcel-properties parcel components trait: trait design-events?: design-events?)))
  
  
  (method public (paste-parcel-properties parcel components (trait: trait #t) (design-events?: design-events? #t))
    (let ((forms (get-content~ parcel)))
      (for-each (lambda (component)
                  (for-each (lambda (form)
                              (instantiate-properties component (get-properties~ form) trait design-events?))
                            forms))
                components)
      (set-modified? #t)))
  
  
  (method public virtual (delete-components components (trait: trait #t) (design-events?: design-events? #t))
    (let ((components (remove-redundant-descendants components)))
      (for-each (lambda (component)
                  (delete-component component trait: trait design-events?: design-events?))
                components)))
  
  
  (method public virtual (delete-component component (trait: trait #t) (design-events?: design-events? #t))
    (remove-child component trait: trait design-events?: design-events?))
  
  
  ;; For some operations like cut, copy, delete and move, having a component that
  ;; is a descendant of another one doesn't make sense and can lead to problems...
  (method (remove-redundant-descendants components)
    components
    ;; waiting for a bug fix in the tree selection update that this has uncovered
    @wait
    (collect-if (lambda (component)
                  (not (some? (lambda (target)
                                (and (neq? component target)
                                     (has-parent?~ component target)))
                              components)))
                components))
  
  
  ;;;
  ;;;; Package
  ;;;
  
  
  (method public (package-component component (trait: trait #f))
    (car (package-components (list component) trait: trait)))
  
  
  (method public (package-components components (trait: trait #f))
    ;; Allows copying the reference component
    (define (replace-master old-master component)
      (if (eq? (get-action~ old-master) 'install)
          (let ((master (copy-object~ old-master #t))
                (class-name (get-name~ (class-of component))))
            (receive (module models) (split-locator class-name)
              (let* ((model (car models))
                     (reference (deserialize-runtime-reference (list 'module-private class-name))))
                (set-action~ master 'new)
                (set-model~ master model)
                (setup-context~ master master)
                (set-locator~ master (let ((locator (get-locator~ master)))
                                       (lambda (symbol)
                                         (if (eq? symbol model) reference (locator symbol)))))
                master)))
        old-master))
    
    ;; Modifying the master from its parent is equivalent to an install
    (define (modify->install form)
      (let ((new-form (copy-object~ form #f)))
        (when (eq? (get-action~ new-form) 'modify)
          (set-action~ new-form 'install)
          (set-name~ new-form #f))
        new-form))
    
    (define (package-component component)
      (let ((original-forms (let ((forms (if (eq? reference component) (list form) (component-forms component))))
                              ;; This is when the form is not associated to a class. Does not work with traits
                              (if (null? forms) (list (owned-form form (component-ancestry component reference))) forms))))
        (if (not original-forms)
            (designer-error "Unable to find owner for {t}" component)
          (let* ((origin-import (origin-import (car original-forms)))
                 (imports (map listify (apply union (map (lambda (form) (form-imports form origin-import)) original-forms))))
                 (forms (cons (replace-master (car original-forms) component)
                              (map modify->install (cdr original-forms)))))
            (new Component-Parcel (current-process-id) (object->serial component) imports forms)))))
    
    (map package-component components))
  
  
  ;;;
  ;;;; Instantiate
  ;;;
  
  
  (method public virtual (instantiate-parcels parcels parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f) (reporter: reporter #f))
    (map (lambda (parcel)
           (when reporter
             (user-message~ reporter "Pasting {a}..." (get-master-name~ parcel)))
           (prog1 (instantiate-parcel parcel parent trait: trait name-resolution: name-resolution design-events?: design-events? descendant?: descendant?)
             (when reporter
               (step-it~ reporter))))
         parcels))
  
  
  (method public virtual (instantiate-parcel parcel parent (trait: trait #t) (name-resolution: name-resolution #f) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (define (set-context-recursive form context)
      (set-context~ form context)
      (for-each (lambda (child) (set-context-recursive child context)) (get-children~ form)))
    
    (let* ((forms (get-content~ parcel))
           (master (car forms))
           (name (get-name~ master)))
      (if (not (eq? (get-action~ master) 'new))
          (designer-error "Master form's action must be 'new")
        (let* ((brothers (get-children~ parent))
               (domain (map get-name~ brothers))
               (equal (sort-predicate 'equal))
               (conflict? (and name (member? name domain test: equal))))
          (when conflict?
            (case name-resolution
              ((rename)
               (set! name (unique-name name domain)))
              ((override)
               (let ((conflicts (name-conflicts (list name) brothers)))
                 (delete-components conflicts trait: trait))))))
        (let ((imports (get-imports~ parcel)))
          (let ((locator (imports-locator imports)))
            (for-each (lambda (f)
                        (set-locator~ f locator)
                        (set-context-recursive f f))
                      forms))
          (let ((component (instantiate-form name name-resolution master parent trait design-events? descendant? imports: imports)))
            (for-each (lambda (form)
                        (instantiate-form name #f form component trait design-events? descendant?))
                      (cdr forms))
            component)))))
  
  
  (method public virtual (instantiate-form name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component name name-resolution form parent trait design-events? descendant? imports: imports)))
      (when component
        (instantiate-content form component trait design-events?))))
  
  
  (method public virtual (instantiate-content form component trait design-events?)
    (instantiate-properties component (get-properties~ form) trait design-events?)
    (instantiate-children component (get-children~ form) trait design-events?)
    component)

  
  (method public virtual (instantiate-component name name-resolution form parent trait design-events? descendant? (imports: imports '()))
    (let ((action (get-action~ form)))
      (case action
        ((new) (instantiate-new-component name form parent trait design-events? descendant? imports: imports))
        ((modify locate) (find-to-modify~ parent (get-name~ form) (sort-predicate 'equal)))
        ((install) parent)
        (else (designer-error "Unsupported form action: {t}" action)))))
  
  
  (method public virtual (instantiate-new-component name form parent trait design-events? descendant? (imports: imports '()))
    (let ((component (instantiate-component~ form parent: parent)))
      (add-child component parent trait: trait name: name design-events?: design-events? descendant?: descendant? import: imports)
      component))
  
  
  (method public virtual (instantiate-properties component properties trait design-events?)
    (for-each-property (lambda (property value)
                         (unless (initer-property?~ component property)
                           (set-property component property value trait: trait design-events?: design-events? undoable?: #f)))
                       properties))

  
  (method public virtual (instantiate-children component children trait design-events?)
    (for-each (lambda (form)
                (instantiate-form (get-name~ form) #f form component trait design-events? #t))
              children))
  
  
  ;;;
  ;;;; Unique
  ;;;
  
  
  (method protected virtual (unique-name name domain)
    (let ((unique-name (unique-domain-name (->string name) (map ->string domain) separator: (unique-separator))))
      (if (symbol? name)
          (string->symbol unique-name)
        unique-name)))
  
  
  (method protected virtual (unique-separator)
    "_")
  
  
  ;;;
  ;;;; Conflicts
  ;;;
  
  
  (definition (name-conflicts names children)
    (let ((equal (sort-predicate 'equal)))
      (collect-if (lambda (child)
                    (let ((child-name (get-name~ child)))
                      (and child-name
                           (some? (lambda (name)
                                    (equal child-name name))
                                  names))))
                  children)))
  
  
  (method public (verify-name-conflicts parcels destination)
    (define (confirm-name-resolution children conflicts)
      (define (present-conflicts header conflicts)
        (let ((fact (new List-Factory)))
          (put~ fact header)
          (for-each (lambda (conflict)
                      (put~ fact (list :bulleted (->string (get-name~ conflict)))))
                    conflicts)
          (get-output~ fact)))
      
      (if (every? (lambda (parcel)
                    (let ((equal (sort-predicate 'equal))
                          (process-id (get-process-id~ parcel))
                          (component-id (get-object-id~ parcel))
                          (name (get-master-name~ parcel)))
                      (and (= process-id (current-process-id))
                           (some? (lambda (child)
                                    (and (= component-id (object->serial child))
                                         (equal name (get-name~ child))))
                                  children))))
                  parcels)
          'rename
        (let* ((header "The following conflicts where detected. Override destination?")
               (text (present-conflicts header conflicts))
               (code (message-box text type: 'question)))
          (case code
            ((yes) 'override)
            ((no) (throw-cancel))))))
    
    (let* ((names (map get-master-name~ parcels))
           (children (get-children~ destination))
           (conflicts (name-conflicts names children)))
      (when (not-null? conflicts)
        (confirm-name-resolution children conflicts))))
  
  
  ;;;
  ;;;; View
  ;;;
  
  
  ;; This special support for views is not clean, but it is better
  ;; than having it directly inside add-child where it was before!
  (method public virtual (add-view child parent . rest)
    (bind-keywords ((name #f) (position #f) (centered? #f) (visible? #t) . others) rest
      (with-atomic-undo~ undoer
        (lambda ()
          (apply add-child child parent name: name others)
          (when position
            (set-property child 'position position))
          (when centered?
            (let ((size (get-size~ child)))
              (move-figure~ child (- (quotient (get-width~ size) 2)) (- (quotient (get-height~ size) 2)))
              (set-property child 'position (get-position~ child))))
          (when visible?
            (set-visible?~ child #t))
          (set-modified? #t)))))
  
  
  (method public (cascade-view-position view initial)
    (when (is? view View)
      (let* ((positions (map get-position~ (remove view (get-views~ (get-parent~ view)))))
             (pos (cascade-position initial {Distance 10 10} positions)))
        (safe-set-property view 'position pos))))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  ;; package modifier is for tests
  (method package (find-form component branch (restore?: restore? #f) (error?: error? #t))
    (define (embed-form form ancestry)
      (for-each (lambda (cpn)
                  (let ((children (get-children~ form))
                        (cpn-form (get-form~ cpn)))
                    (if (not cpn-form)
                        (embed-new-form form #f)
                      (if (memq? cpn-form children)
                          (set! form cpn-form)
                        (let ((restore-form (find-in children cpn key: (lambda (form) (and (is? form Restore-Form) (get-component~ form))))))
                          (if restore-form
                              (set! form restore-form)
                            (let ((name (get-name~ cpn)))
                              (if (not name)
                                  (designer-error "Component {t} must be named to allow modification" cpn)
                                (let ((subform (find-in children name key: get-name~ test: equal?)))
                                  (if (not subform)
                                      (set! form (embed-new-form form name))
                                    (set! form subform)))))))))))
                ancestry)
      form)
    
    (define (embed-new-form form name)
      (let ((subform (new Form action: 'modify context: (get-context~ form) name: name)))
        (set-parent~ subform form)
        subform))
    
    (let* ((ancestry (component-ancestry component reference))
           (trait-form (if branch (get-client-form~ (get-trait~ branch)) form))
           (restore-form (and restore? branch (get-restore-form~ branch)))
           (form (embed-form trait-form ancestry))
           (restore (and restore-form (embed-form restore-form ancestry))))
      (if (and error? (not form))
          (designer-error "Unable to locate target form")
        (if restore?
            (values form restore)
          form))))
  
  
  (method (target-branch trait)
    (cond ((eq? trait #t) (get-active-branch~ reference))
          ((is? trait Path) (follow-component~ trait reference))
          (else (find-trait-branch~ reference trait))))
  
  
  ;;;
  ;;;; Owner
  ;;;
  
  
  (method public virtual (component-owned-by-reference? component)
    (component-owned? component form reference))
  
  
  (method public (find-owner component (property #f))
    (let ((ancestry (component-ancestry component reference)))
      (continuation-capture
        (lambda (return)
          (iterate-branch-spine~ reference
            (lambda (owner form)
              (when form
                (let ((form (owned-form form ancestry)))
                  (when (and form
                             (or (and (not property) (eq? (get-action~ form) 'new))
                                 (and property (has-property?~ form property))))
                    (continuation-return return owner))))))
          #f))))
  
  
  (method (find-next-branch branch component property)
    (if (not branch)
        (values #f #f)
      (let ((lower (get-branches~ (or branch reference)))
            (ancestry (component-ancestry component reference)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (branch)
                        (let ((client-form (get-client-form~ branch)))
                          (when client-form
                            (let ((form (owned-form client-form ancestry)))
                              (when (and form (has-property?~ form property))
                                (continuation-return return (values form (owned-form (get-restore-form~ branch) ancestry))))))))
                      lower)
            (values #f #f))))))
  
  
  ;;;
  ;;;; Value
  ;;;
  
  
  ;; Until a fully generic solution, these methods implement the following special case:
  ;; - the trait must be the owner of the property (i.e. have set it)
  
  
  (method public (get-name path (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-name~ (follow-form~ path form))))
  
  
  (method public (get-property path property (trait: trait #t))
    (let* ((branch (target-branch trait))
           (form (if branch (get-client-form~ (get-trait~ branch)) form)))
      (get-property~ (follow-form~ path form) property)))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method public (edit-form (workspace: workspace #f))
    (let ((appl (get-application))
          (origin (get-origin~ form)))
      (define (find-entry locator)
        ((module-ref 'jazz.project 'locator->entry) locator))
      
      (cond ((not origin)
             (bell))
            ((file? origin)
             (edit-document~ appl origin class: Jazz-Text-View workspace: workspace))
            ((find-entry (get-name~ origin)) => (lambda (entry) (edit~ entry workspace: workspace)))
            (else
             (receive (module class) (break-reference (get-name~ origin))
               (edit-document~ appl (find-unit-source module) class: Jazz-Text-View workspace: workspace))))))
  
  
  ;;;
  ;;;; Error
  ;;;
  
  
  (method public (safe-set-property . rest)
    (with-safe-design
      (lambda ()
        (apply set-property rest))))
  
  
  ;;;
  ;;;; Fire
  ;;;
  
  
  (definition (fire-name-change component name old-name undoable?)
    (for-each (lambda (designer)
                (process-name-change~ designer component name old-name undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-presentation-change component presentation old-presentation undoable?)
    (for-each (lambda (designer)
                (process-presentation-change~ designer component presentation old-presentation undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-property-change branch component property value undoable?)
    (for-each (lambda (designer)
                (process-property-change~ designer branch component property value undoable?))
              (get-designers~ component)))
  
  
  (definition (fire-child-add child parent descendant?)
    (for-each (lambda (designer)
                (process-child-add~ designer child parent descendant?))
              (get-designers~ parent)))
  
  
  (definition (fire-child-remove child parent)
    (for-each (lambda (designer)
                (process-child-remove~ designer child parent))
              (get-designers~ child)))
  
  
  (definition (fire-child-relocate child parent destination)
    (for-each (lambda (designer)
                (process-child-relocate~ designer child parent destination))
              (get-designers~ child)))
  
  
  (definition (fire-send-before child parent target)
    (for-each (lambda (designer)
                (process-send-before~ designer child parent target))
              (get-designers~ child)))
  
  
  (definition (fire-refresh component what)
    (for-each (lambda (designer)
                (process-refresh~ designer component what))
              (get-designers~ component)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-designer-listener listener)
    (set! listeners (add-listener listener listeners)))
  
  
  (method public (remove-designer-listener listener)
    (set! listeners (remove-listener listener listeners)))

  
  (method (process-name-change component name old-name undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :name-change self component: component name: name old-name: old-name undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-presentation-change component presentation old-presentation undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :presentation-change self component: component presentation: presentation old-presentation: old-presentation undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-property-change branch component property value undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :property-change self branch: branch component: component property: property value: value undoable?: undoable?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-add child parent descendant?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-add self child: child parent: parent descendant?: descendant?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-remove child parent)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-remove self child: child parent: parent)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (process-child-relocate child parent destination)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-relocate self child: child parent: parent target: destination)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-send-before child parent target)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :send-before self child: child parent: parent target: target)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-refresh component what)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :refresh self component: component what: what)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-user-event event)
    (when (not-null? listeners)
      (for-each (lambda (listener)
                  (invoke~ listener self event))
                listeners)))))
