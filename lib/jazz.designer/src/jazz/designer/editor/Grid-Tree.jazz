;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Grid Tree
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.designer.editor.Grid-Tree jazz


(import (jazz.graphic)
        (jazz.designer)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.ui))


(definition (get-class-categorized-properties class)
  (let* ((properties-descriptor (get-properties-descriptor class))
         (categorized (get-categorized~ properties-descriptor)))
    (either categorized #f)))


(definition (present-property-value component property)
  (let ((value (read-property component property)))
    (present-property~ component property value)))


(definition (follow-component-path parent-component path fail succeed)
  (let ((component (find-component-path parent-component (butlast path))))
    (if (not component)
        (fail)
      (let* ((base (class-of component))
             (property (category-field base (last path))))
        (if (not property)
            (fail)
          (succeed component base property))))))


(definition (find-component-path component path)
  (cond ((not component) #f)
        ((null? path) component)
        (else (find-component~ component path))))


(definition (iota count (start 0) (step 1))
  (if (zero? count)
      '()
    (cons start (iota (- count 1) (+ start step) step))))


(definition (target-classes-union target-classes)
  (cond ((null? target-classes)
         '())
        ((null? (cdr target-classes))
         target-classes)
        (else
         (bind (target title classes) (car target-classes)
           (receive (same rest) (partition-binary (cdr target-classes)
                                                  (lambda (el)
                                                    (equal? target (car el))))
             (cons (list target title (apply union test: eq? classes (map second same)))
                   (target-classes-union rest)))))))


(definition (class-properties class)
  (let* ((categorized (get-class-categorized-properties class))
         (keep-property?
           (lambda (property)
             (let ((category (get-name~ (get-category~ class property))))
               (and (eq? category 'properties)
                    (if categorized
                        (memq (get-name~ property) categorized)
                      (let ((property-descriptor (get-property-descriptor class (get-name~ property))))
                        (and property-descriptor (get-domain~ property-descriptor)))))))))
    (collect-if keep-property? (get-properties~ class))))


(definition (autoload-class-validate class-name)
  (or (autoload-class class-name)
      (error "Unable to autoload class {s}" class-name)))


(definition (make-class-cell-domain classes)
  (new Enumeration-Domain choices: (cons (list #f "") 
                                         (zip classes
                                              (map get-class-presentation~ classes)))))


(definition (normalize-descriptor-target descriptor)
  (let ((target (get-target~ descriptor)))
    (cond
      ((not target)
       (error "Child-Descriptor has no target: {s}" descriptor))
      ((symbol? target)
       (list target))
      (else target))))


(definition (validate-descriptor-title descriptor)
  (or (get-title~ descriptor)
      (error "Child-Descriptor has not title: {s}" descriptor)))


;;;
;;;; Grid-Column
;;;


(class Grid-Column extends Tree-Label-Column
  
  
  (property class-column? initialize #f accessors generate)
  
  
  (method public (get-path)
    (get-user-data))
  
  
  (method override (draw-data surface context row data width height)
    (let ((component (get-component~ row))
          (path (get-path)))
      (follow-component-path component path
        (lambda ()
          (nextmethod surface context row data width height))
        (lambda (child-component base property)
          (let ((domain (get-domain~ base property))
                (value (read-property child-component property)))
            (draw-data~ domain surface context value self row data width height)))))))


;;;
;;;; Grid-Row
;;;


(class Grid-Row extends Tree-Row
  
  
  (method public (get-component)
    (get-user-data)))


;;;
;;;; Grid-Tree
;;;


(class Grid-Tree extends Components-Tree
  
  
  (form
    (<install> reorderable?: #t multiple-selection?: #f selection-mode: cell selection-handler: {Event-Handler :self on-selection-change}))
  
  
  (definition Default-Width 100)
  
  
  (method override (on-return-press evt)
    (end-edition))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method override (on-selection-change evt)
    (let ((selection (get-selection~ evt)))
      (unless (null? selection)
        (select-cell (car selection))))
    (nextmethod evt))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method override (selection-changed selection old origin force-parent? focus?)
    (define (determine-client component force-parent?)
      (let ((parent (get-parent~ component)))
        (if (and parent (get-addable-classes~ parent) (or force-parent? (null? (get-addable-classes~ component))))
            (values parent #t)
          (values component #f))))
    
    (unless (or (not origin) (eq? origin self))
      (if (null? selection)
          (set-client #f)
        (let ((component (car selection)))
          (receive (client parent?) (determine-client component force-parent?)
            (set-client client)
            (if (not parent?)
                (set-selection '() generate-event?: #f)
              (let ((row (component-row component)))
                (when row
                  (set-selection (list (new Cell (row->line row) 1)) generate-event?: #t)))))))))
  
  
  ;;;
  ;;;; Select Cell
  ;;;
  
  
  (method (prepare-and-focus-entry entry)
    (let ((view-to-focus (tab-view~ entry)))
      (set-return-press-handler~ view-to-focus (new Event-Handler execute: on-return-press))
      (acquire-focus~ view-to-focus)
      (select-all~ view-to-focus)))
  
  
  (method (select-class-cell cell editor row-component path)
    (let ((parent-component (if (null? path) client (find-component-path row-component (butlast path))))
          (classes (if (null? path) (get-addable-classes~ client)
                     (let* ((row-descriptor (get-descriptor (class-of row-component)))
                            (descriptor (find-key~ (find-child~ row-descriptor 'children) normalize-descriptor-target path)))
                       (when descriptor
                         (map autoload-class (get-classes~ descriptor)))))))
      (when (and parent-component classes)
        (let ((old-component (if (null? path) row-component (find-child~ parent-component (last path)))))
          (let* ((domain (make-class-cell-domain classes))
                 (entry (setup-entry~ domain editor #f))
                 (end-edit (lambda (cell)
                             (when (get-modified?~ entry)
                               (let* ((class (get-value~ entry))
                                      (new-component (and class (new class))))
                                 (when old-component
                                   (remove-child~ designer old-component))
                                 (when new-component
                                   (add-child~ designer new-component parent-component name: (and (not-null? path) (last path)))))))))
            (set-value~ entry (and old-component (class-of old-component)))
            (edit-cell cell editor: editor close-editor?: #f after-end: end-edit)
            (prepare-and-focus-entry entry))))))
  
  
  (method (select-property-cell cell editor row-component path)
    ;; No property can be edited until a row-component exists
    (when row-component
      (follow-component-path row-component path 
        (lambda () #f)
        (lambda (component base property)
          (let* ((domain   (get-domain~ base property))
                 (entry    (setup-entry~ domain editor #f))
                 (end-edit (lambda (cell)
                             (when (get-modified?~ entry)
                               (let* ((value (get-value~ entry))
                                      (title (present-property~ component property value)))
                                 (set-title~ (get-cell-data cell) title)
                                 (safe-set-property~ designer component property value))))))
            (set-value~ entry (read-property component property))
            (edit-cell cell editor: editor close-editor?: #f after-end: end-edit)
            (prepare-and-focus-entry entry))))))
  
  
  (method override (select-cell cell)
    ;; Because changes in some cells could make other cells inactive
    (end-edition)
    (let ((editor (new Layout-View layout-type: 'fill))
          (column (get-column (get-col~ cell)))
          (row    (get-row (get-line~ cell))))
      (let ((path (get-path~ column))
            (row-component (get-component~ row)))
        (if (get-class-column?~ column)
            ;; Remove class-info from the path
            (select-class-cell cell editor row-component (butlast path))
          (select-property-cell cell editor row-component path)))))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method override (client-update)
    (end-edition)
    (update))
  
  
  (method override (update)
    (with-update-locked
      (lambda ()
        (setup-columns)
        (insert-rows))))
  
  
  (method (setup-node-column)
    (set-visible?~ (get-node-column) #f))
  
  
  (method (add-class-column path title)
    (add-column class: Grid-Column title: title width: Default-Width user-data: (append path '(class-info)) class-column?: #t))
  
  
  (method (add-property-column path title)
    (add-column class: Grid-Column title: title width: Default-Width user-data: path class-column?: #f))
  
  
  (method (setup-client-columns)
    (define (setup-target-columns target title classes)
      (add-class-column target title)
      (let ((classes-properties (map (lambda (class)
                                       (map (lambda (property)
                                              (list class property))
                                            (class-properties class)))
                                     classes)))
        (apply for-each (lambda (class property)
                          (add-property-column
                            (append target (list (get-name~ property)))
                            (let ((presentation (property-presentation~ class property)))
                              (if (null? target)
                                  presentation
                                (string-append title " " presentation)))))
          (apply zip (apply union key: (lambda (class+property)
                                         (get-name~ (second class+property)))
                       classes-properties)))))
    
    (let ((addable-classes (get-addable-classes~ client)))
      (if (null? addable-classes)
          (add-property-column '(name-info) "Name")
        (let* ((addable-descriptors (map get-class-descriptor~ addable-classes))
               (child-descriptors (append-map (lambda (descriptor)
                                                (get-children~ (find-child~ descriptor 'children)))
                                              addable-descriptors))
               (targets+titles+classes (apply zip (target-classes-union
                                                    (cons (list '() "Class" addable-classes)
                                                          (map (lambda (descriptor)
                                                                 (list (normalize-descriptor-target descriptor)
                                                                       (validate-descriptor-title descriptor)
                                                                       (map autoload-class-validate (get-classes~ descriptor))))
                                                               child-descriptors))))))
          (apply for-each setup-target-columns targets+titles+classes)))))
  
  
  (method (setup-columns)
    (set-filled-column #f)
    (remove-columns preserve-node-column?: #t)
    (setup-node-column)
    (when client
      (setup-client-columns)))
  
  
  (method override (row-class)
    Grid-Row)
  
  
  (method (insert-rows)
    (remove-every-row)
    (when client
      (insert-components client)))
  
  
  (method (insert-components component)
    (let ((components (get-components~ component)))
      (for-each (lambda (child)
                  (insert-component child))
                (if (sort-components?~ component)
                    (sort < components key: get-presentation-property~)
                  components))))
  
  
  (method (inactive-cell-background row-component column)
    (let ((component-path (butlast (get-path~ column))))
      (cond ((not (get-class-column?~ column))
             {Color name: Gray})
            ((null? component-path)
             {Color name: White})
            ((find-component-path row-component (butlast component-path))
             {Color name: White})
            (else
             {Color name: Gray}))))
  
  
  (method (make-row-element row-component column)
    (let ((path (get-path~ column)))
      (let ((make-inactive-element
              (lambda ()
                (let ((background (inactive-cell-background row-component column)))
                  (new Tree-Label title: "" background: background))))
            (make-active-element
              (lambda (component base property)
                (let ((title (present-property-value component property)))
                  (new Tree-Label title: title background: {Color name: White})))))
        (follow-component-path row-component path make-inactive-element make-active-element))))
  
  
  (method (call-with-row+column cell proc)
    (proc (get-row (get-line~ cell))
          (get-column (get-col~ cell))))
  
  
  (method (update-cell cell)
    (let* ((editor (get-cell-editor))
           (label (if editor (get-preserved-data~ editor) (get-cell-data cell))))
      (call-with-row+column cell
        (lambda (row column)
          (let ((row-component (get-component~ row))
                (path (get-path~ column)))
            (let ((update-inactive-element
                    (lambda ()
                      (let ((background (inactive-cell-background row-component column)))
                        (set-title~ label "")
                        (set-background~ label background))))
                  (update-active-element
                    (lambda (component base property)
                      (set-title~ label (present-property-value component property))
                      (set-background~ label {Color name: White}))))
              (follow-component-path row-component path update-inactive-element update-active-element)
              (invalidate-cell cell)))))))
  
  
  (method protected virtual (insert-component component)
    (let ((labels (map (lambda (column)
                         (make-row-element component column))
                       (cdr (get-columns)))))
      (add-row children: (cons (new Tree-Node) labels) user-data: component)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method override (on-designer evt)
    (case (get-kind~ evt)
      ((:name-change)     (name-change (get-property~ evt component:) (get-property~ evt name:) (get-property~ evt old-name:)))
      ((:child-add)       (child-add (get-property~ evt child:) (get-property~ evt parent:)))
      ((:child-remove)    (child-remove (get-property~ evt child:) (get-property~ evt parent:)))
      ((:property-change) (property-change (get-property~ evt component:) (get-property~ evt property:)))))
  
  
  (method (child-add child parent)
    (if (eq? parent client)
        (insert-component child)
      (call-with-parsed-lineage child update-component-paths)))
  
  
  (method (child-remove child parent)
    (if (eq? parent client)
        (remove-row (component-row child))
      (call-with-parsed-lineage child update-component-paths)))
  
  
  (method (for-each-column proc)
    (for-each proc (get-columns) (iota (get-columns-count))))
  
  
  (method (get-lineage-from component ancestor)
    (let* ((root (get-root-parent~ component))
           (ancestry (get-ancestry~ component root)))
      (memq ancestor ancestry)))
  
  
  (method (super-path? path1 path2)
    (cond ((null? path1) #t)
          ((eq? (car path1)
                (car path2))
           (super-path? (cdr path1) (cdr path2)))
          (else #f)))
  
  
  (method (update-component-paths row-component . paths)
    (for-each-row
      (lambda (row row-rank)
        (when (eq? row-component (get-component~ row))
          (for-each-column
            (lambda (column column-rank)
              ;; Because of the placeholder node column
              (unless (zero? column-rank)
                (let ((column-path (get-path~ column)))
                  (for-each (lambda (path)
                              (when (super-path? path column-path)
                                (update-cell (new Cell row-rank column-rank))))
                            paths)))))))))
  
  
  (method (call-with-parsed-lineage component proc)
    (let ((lineage-from-client (get-lineage-from component client)))
      (when lineage-from-client
        (proc (cadr lineage-from-client)
              (map get-name~ (cddr lineage-from-client))))))
  
  
  (method (name-change component new-name old-name)
    (if (eq? client (get-parent~ component))
        (update-component-paths component '(name-info))
      (call-with-parsed-lineage component
        (lambda (row-component change-path)
          (let ((old-path (append (butlast change-path) (list old-name)))
                (new-path (append (butlast change-path) (list new-name))))
            (update-component-paths row-component old-path new-path))))))
  
  
  (method (property-change component property)
    (call-with-parsed-lineage component
      (lambda (row-component change-path)
        (update-component-paths row-component (append change-path (list (field-name property)))))))))
