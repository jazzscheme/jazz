;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Inspector
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.editor.jazz.inspector jazz


(import (jazz.editor.jazz))


;;;
;;;; Package
;;;


(definition presentation-limit
  256)


(definition Unbound
  (cons #f #f))


(definition public (package-unbound)
  Unbound)


(definition public (package-info value (kind: kind :value) (mutable?: mutable? #t) (max-width: max-width #f))
  (define (more-value? value)
    (cond ((pair? value) #t)
          ((table? value) (> (table-length value) 0))
          ((structure? value) (> (kind-length (structure-kind value)) 0))
          ((string? value) #f)
          ((sequence? value) (> (cardinality value) 0))
          ((object? value) (not-null? (get-instance-slots~ (class-of value))))
          (else #f)))
  
  (define (truncate str)
    (let ((limit (or max-width presentation-limit)))
      (if (> (cardinality str) limit)
          (concatenate (subseq str 0 limit) "...")
        str)))
  
  (let ((serial (object->serial value)))
    (let* ((unbound? (eq? value Unbound))
           (raw? (eq? kind :raw))
           (class (category-identifier (class-of value)))
           (presentation (cond (unbound? "<unbound>")
                               (raw? (truncate (->string value)))
                               (else (safe-present-object value (or max-width presentation-limit)))))
           (more? (cond ((or unbound? raw?) #f)
                        ((memq? kind '(frame: context:)) #t)
                        (else (more-value? value)))))
      (list serial class presentation more? mutable? kind))))


;;;
;;;; Inspect
;;;


(constant inspect-rank-limit
  256)


(definition public (inspect-value value (max-width: max-width #f) (max-content: max-content inspect-rank-limit) (packager: packager package-info))
  (define (inspect-structure struct)
    (let ((kind (structure-kind struct)))
      (map (lambda (info)
             (bind (name rank) info
               (cons (list #f name rank) (packager (structure-ref struct rank kind)))))
           (cached-kind-fields kind))))
  
  (define (inspect-list lst)
    (let (iter (scan lst)
               (rank 0))
      (cond ((>= rank max-content)
             (list (inspect-limit (length lst) rank (+ rank (proper-length scan)))))
            ((pair? scan)
             (cons (cons (list #f rank rank) (packager (car scan)))
                   (iter (cdr scan) (+ rank 1))))
            ((not (null? scan))
             (list (cons (list #f 'rest rank) (packager scan))))
            (else
             '()))))
  
  (define (inspect-table table)
    (let ((limit? (> (table-length table) max-content)))
      (let ((elements (let ((lst (table->list table)))
                        (if limit?
                            (subseq lst 0 max-content)
                          lst))))
        (let ((content (map (lambda (pair rank)
                              (bind (key . value) pair
                                (cons (list #f (safe-present-object key max-width) rank)
                                      (packager value))))
                            elements
                            (naturals 0 (length elements)))))
          (let ((sorted (sort string<? content key: (lambda (info) (second (car info))))))
            (if limit?
                (append sorted (list (inspect-limit (table-length table) max-content (table-length table))))
              sorted))))))
  
  (define (inspect-object object)
    (define (class-slot-info class)
      (if (not class)
          '()
        (let ((class-name (category-name class)))
          (append (map (lambda (slot) (cons class-name slot)) (get-slots~ class))
                  (class-slot-info (get-ascendant~ class))))))
    
    (let ((slot-infos (class-slot-info (class-of object))))
      (map (lambda (slot-info rank)
             (bind (class . slot) slot-info
               (if (symbol? slot)
                   (cons (list class slot rank) (packager "<core slot>" kind: :raw))
                 (cons (list class (field-name slot) rank)
                       (let ((offset (get-offset~ slot)))
                         (if (not offset)
                             (packager (safe-present-property object slot) kind: :raw)
                           (packager (get-object-slot object offset))))))))
           slot-infos
           (naturals 0 (length slot-infos)))))
  
  (define (inspect-limit rank displayed total)
    (let ((missing (- total displayed)))
      (cons (list #f "..." rank) (packager (format "{a} missing of {a}" missing total) kind: :raw))))
  
  (cond ((null/pair? value) (inspect-list value))
        ((table? value) (inspect-table value))
        ((structure? value) (inspect-structure value))
        ((sequence? value) (inspect-list (coerce value List)))
        ((object? value) (inspect-object value))
        (else '())))


;;;
;;;; Kind
;;;


(definition kind-cache
  (make-table test: eq?))


(definition (cached-kind-fields kind)
  (or (table-ref kind-cache kind #f)
      (let ((fields (kind-fields kind)))
        (table-set! kind-cache kind fields)
        fields))))
