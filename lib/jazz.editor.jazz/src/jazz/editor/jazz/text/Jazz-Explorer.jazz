;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exploring Jazz Code
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.jazz.text.Jazz-Explorer jazz


(require (jazz.editor.scheme.forms))
(require (jazz.editor.jazz.forms))

(import (jazz.editor.jazz)
        (jazz.editor.lisp)
        (jazz.editor.scheme))


(proclaim (warn optimizations))


(class Jazz-Explorer extends Scheme-Explorer
  
  
  (method override (get-syntax)
    'jazz)
  
  
  (method override (expression-comment? mark)
    (define (get-first-char range)
      (get-char (get-start~ range)))
    
    (or (char=? (get-first-char (get-range~ mark)) #\at)
        (nextmethod mark)))


  ;;;
  ;;;; Location
  ;;;
  
  
  (method public (forward-location location <Object> (toplevel-location: toplevel-location #f))
    (define (forward-category-keywords)
      (let ((keyword #f)
            (previous (get-end)))
        (while (and (forward-expr)
                    (begin
                      (set! keyword (find-marked-symbol))
                      (or (expression-syntax-namespace? keyword)
                          (memq? keyword '(unit module class interface))
                          (memq? keyword '(metaclass extends implements))))
                    (forward-expr))
          (set! previous (get-end)))
        (set-start previous)
        (set-end previous)))
    
    (define (forward-new-form (toplevel-location: toplevel-location #f))
      (forward-category-keywords)
      (set-end (get-start)))
    
    (define (forward-form (toplevel-location: toplevel-location #f))
      (while (not (memq? (form-expr) '(form)))
        (when (not (forward-valid-expr))
          (signal (new Location-Error kind: 'unknown location: (or toplevel-location 'form))))))
    
    (define (forward-declaration name <Object> (toplevel-location: toplevel-location #f))
      (while (or (not (declaration-expr?))
                 (neq? (declaration-name) name))
        (when (not (forward-valid-expr))
          (signal (new Location-Error kind: 'unknown location: (or toplevel-location name))))))
    
    (define (forward-numeric n <fx> (toplevel-location: toplevel-location #f))
      (while (>= n 0)
        (when (not (forward-valid-expr))
          (signal (new Location-Error kind: 'unknown location: (or toplevel-location n))))
        (decrease! n)))
    
    (define (forward-valid-expr)
      (let ((kind (forward-expr)))
        (cond ((eq? kind 'named-comment)
               (forward-expr)
               (forward-expr))
              (else
               kind))))
    
    (let ((scan location))
      (while (not-null? scan)
        (let ((ref (car scan)))
          (set-end (get-start))
          (forward-whites)
          (let ((c0 (char-forward 0)))
            (cond ((eqv? c0 #\backquote)
                   (forward)
                   (forward-expr)
                   (set! scan (cdr scan)))
                  ((and (eqv? c0 #\comma) (eqv? (char-forward 1) #\at))
                   (forward)
                   (forward)
                   (forward-expr)
                   (set! scan (cdr scan)))
                  ((eqv? c0 #\comma)
                   (forward)
                   (forward-expr)
                   (set! scan (cdr scan)))
                  ((not (enter-composite))
                   (signal (new Location-Error kind: 'bad location: (or toplevel-location location))))
                  (else
                   (unless (eq? ref 'meta)
                     (cond ((eq? ref :new-form)
                            (forward-new-form toplevel-location: toplevel-location))
                           ((eq? ref :form)
                            (forward-form toplevel-location: toplevel-location))
                           ((symbol? ref)
                            (forward-declaration ref toplevel-location: toplevel-location))
                           (else
                            (forward-numeric ref toplevel-location: toplevel-location))))
                   (set! scan (cdr scan)))))))))


  ;;;
  ;;;; Namespace
  ;;;


  (method public (namespace-declaration-range)
    (let ((s (copy start))
          (e (copy end)))
      (forward-namespace)
      (prog1 (new Range$Cell$ s (copy end))
        (set-start s)
        (set-end e))))
  
  
  (method public (forward-namespace (include-invoices?: include-invoices? #f))
    (set-end start)
    (enter-list)
    (forward-expr)
    (let ((type (intern-marked-symbol)))
      (case type
        ((unit) (forward-unit include-invoices?))
        ((module) (forward-module include-invoices?))
        ((submodule) (forward-submodule))
        ((class) (forward-class))
        ((interface) (forward-interface)))))
  
  
  (method (forward-unit include-invoices?)
    (list 'unit
          (forward-modifiers (expression-syntax-modifiers 'unit))
          (forward-name)
          (when include-invoices?
            (forward-invoices))))
  
  
  (method (forward-module include-invoices?)
    (list 'module
          (forward-modifiers (expression-syntax-modifiers 'module))
          (forward-name)
          (forward-name)
          (when include-invoices?
            (forward-invoices))))
  
  
  (method (forward-submodule)
    (list 'submodule
          (forward-modifiers (expression-syntax-modifiers 'submodule))
          (forward-name)))
  
  
  (method (forward-class)
    (list 'class
          (forward-modifiers (expression-syntax-modifiers 'class))
          (forward-name)
          (forward-keywords (expression-syntax-keywords 'class))))
  
  
  (method (forward-interface)
    (list 'interface
          (forward-modifiers (expression-syntax-modifiers 'interface))
          (forward-name)
          (forward-keywords (expression-syntax-keywords 'interface))))
  
  
  (method (forward-name)
    (forward-expr)
    (intern-marked-symbol))
  
  
  (method (forward-keywords keywords)
    (let (iterate (finish (copy end))
                  (result '()))
      (define (done)
        (set-end finish)
        result)
      
      (forward-expr)
      (if (eq? kind 'symbol)
          (let ((expr (intern-marked-symbol)))
            (if (memq? expr keywords)
                (begin
                  (forward-expr)
                  (let ((value (read-marked)))
                    (iterate (copy end) (append result (list expr value)))))
              (done)))
        (done))))
  
  
  (method (forward-invoices)
    #f)


  ;;;
  ;;;; Imports
  ;;;
  
  
  (method (filter-existing-import-invoices units)
    (collect-if (lambda (unit)
                  (goto-beginning)
                  (forward-namespace)
                  (enter-import)
                  (receive (found? first?) (find-import-invoice unit #f)
                    (not found?)))
                units))
  
  
  (method (enter-import)
    (let (iterate)
      (when (forward-expr)
        (let ((pos (copy (get-end))))
          (if (eq? kind 'list)
              (let ((s (get-start))
                    (e (get-end)))
                (set-end s)
                (enter-list)
                (forward-expr)
                (if (eq? kind 'symbol)
                    (let ((expr (intern-marked-symbol)))
                      (if (eq? expr 'import)
                          #t
                        (set-end pos)
                        (iterate)))
                  (set-end pos)
                  (iterate)))
            (iterate))))))
  
  
  (method (find-import-invoice unit ordered-insert?)
    (let ((target (symbol->string unit)))
      (let (iterate (first? #t))
        (let ((pos (copy (get-end))))
          (if (forward-expr)
              (begin
                (set-end start)
                (enter-list)
                (forward-expr)
                (let ((name (get-marked)))
                  (cond ((string=? name target)
                         (exit-list)
                         (set-start pos)
                         (values #t first?))
                        ((and ordered-insert? (string>? name target))
                         (set-end pos)
                         (values #f first?))
                        (else
                         (set-end pos)
                         (forward-expr)
                         (iterate #f)))))
            (values #f first?))))))
  
  
  (method public (insert-import-invoice unit)
    (forward-namespace)
    (if (not (enter-import))
        (error "Unable to find import declaration")
      (receive (found? first?) (find-import-invoice unit #t)
        (unless found?
          (with-atomic-undo~ (get-undoer~ text)
            (lambda ()
              (set-caret~ text (get-end))
              (cond (first?
                      (insert-string~ text (format " ({a})" unit))
                      (insert-newline~ text)
                      (tabulate~ text))
                    (else
                     (insert-newline~ text)
                     (tabulate~ text)
                     (insert-string~ text (format "({a})" unit))))))))))
  
  
  (method public (remove-import-invoice unit)
    (forward-namespace)
    (if (not (enter-import))
        (error "Unable to find import declaration")
      (receive (found? first?) (find-import-invoice unit #f)
        (when found?
          (with-atomic-undo~ (get-undoer~ text)
            (lambda ()
              (delete-range~ text (get-range))
              (when first?
                (remove-spaces~ text (get-start) keep: 'one))))))))


  ;;;
  ;;;; Declarations
  ;;;
  
  
  (method override (find-named-walker name)
    (case name
      ((:proclaim)        walk-proclaim)
      ((:properties)      walk-properties)
      ((:attributes)      walk-attributes)
      ((:native)          walk-native)
      ((:definition)      walk-definition)
      ((:specialize)      walk-specialize)
      ((:class)           walk-class)
      ((:interface)       walk-interface)
      ((:remotable-stub)  walk-remotable-stub)
      ((:submodule)       walk-submodule)
      ((:method)          walk-method)
      ((:slot)            walk-slot)
      ((:property)        walk-property)
      ((:form)            walk-form)
      ((:global)          walk-global)
      ((:constant)        walk-constant)
      ((:enumeration)     walk-enumeration)
      ((:c-constant)      walk-c-constant)
      ((:c-enumeration)   walk-c-enumeration)
      ((:c-named-declare) walk-c-named-declare)
      ((:c-include)       walk-c-include)
      ((:c-type)          walk-c-type)
      ((:c-structure)     walk-c-structure)
      ((:c-definition)    walk-c-define)
      ((:c-external)      walk-external)
      ((:com-external)    walk-com-external)
      ((:datacontainer)   walk-datacontainer)
      (else               (nextmethod name))))
  
  
  (method (walk-proclaim context symbol form declaration keyword expression doc)
    (keyword context start end))

  
  (method (walk-properties context symbol form declaration keyword expression doc)
    (keyword context start end)
    (walk-expressions context expression))
  
  
  (method (walk-attributes context symbol form declaration keyword expression doc)
    (keyword context start end)
    (walk-expression context expression 'code #f)
    (forward-expr)
    (let (iterate)
      (when (enter-list)
        (forward-expr)
        (when (eq? kind 'symbol)
          (let ((marked (get-marked)))
            (declaration context 'definition symbol start end marked (symbol-documented? (find-marked-symbol) doc))
            (declaration context 'accessor 'getter start end (string-append "get-" marked) #f)
            (declaration context 'accessor 'setter start end (string-append "set-" marked) #f))
          (walk-keywords/properties context expression
            (lambda (symbol)
              (case symbol
                ((initialize test)
                 (keyword context start end)
                 #f)
                (else
                 #f))))
          (walk-expressions context expression))
        (exit-list)
        (iterate))))

  
  (method (walk-definition context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (forward-whites)
      (let ((list? (eqv? (char-forward 0) #\open-parenthesis)))
        (cond ((not list?)
               (when (and (forward-expr) (eq? kind 'symbol))
                 (set! entry (declaration context 'definition symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))))
              (else
               (enter-list)
               (when (and (forward-expr) (eq? kind 'symbol))
                 (set! entry (declaration context 'definition symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
               (walk-parameters entry declaration keyword expression doc)
               (exit-list))))
      (walk-expressions entry expression 'code #f)
      entry))
  
  
  (method (walk-specialize context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (forward-whites)
      (when (not (eqv? (char-forward 0) #\open-parenthesis))
        (when (and (forward-expr) (eq? kind 'symbol) (eq? (find-marked-symbol) 'as))
          (keyword context start end)
          (forward-expr)
          (declaration context 'specialize symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))
          (forward-whites)))
      (let ((list? (eqv? (char-forward 0) #\open-parenthesis)))
        (cond ((not list?)
               (when (and (forward-expr) (eq? kind 'symbol))
                 (set! entry (declaration context 'specialize symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))))
              (else
               (enter-list)
               (when (and (forward-expr) (eq? kind 'symbol))
                 (set! entry (declaration context 'specialize symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
               (walk-parameters entry declaration keyword expression doc)
               (exit-list))))
      (walk-expressions entry expression 'code #f)
      entry))

  
  (method (walk-class context symbol form declaration keyword expression doc)
    (walk-namespace context 'class symbol form declaration keyword expression doc))

  (method (walk-interface context symbol form declaration keyword expression doc)
    (walk-namespace context 'interface symbol form declaration keyword expression doc))

  (method (walk-remotable-stub context symbol form declaration keyword expression doc)
    (walk-namespace context 'remotable-stub symbol form declaration keyword expression doc))

  (method (walk-submodule context symbol form declaration keyword expression doc)
    (walk-namespace context 'submodule symbol form declaration keyword expression doc))
  
  
  (method public (walk-method context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (enter-list)
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'method symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))
        (forward-whites)
        (walk-parameters entry declaration keyword expression doc)
        (exit-list)
        (walk-expressions entry expression 'code #f))
      entry))
  
  
  (method (walk-keywords/properties context expression proc)
    (while (forward-expr)
      (unless (and (eq? kind 'symbol)
                   (let ((marked-symbol (find-marked-symbol)))
                     (if marked-symbol
                         (proc marked-symbol)
                       #f)))
        (walk-expression context expression 'code #f))))
  
  
  (method (walk-slot/property-accessors context slot-name declaration keyword expression doc)
    (define (declare-accessor accessor)
      (let ((name (string-append (case accessor ((getter) "get-") ((setter) "set-")) slot-name)))
        (declaration context 'accessor accessor start end name (symbol-documented? (find-marked-symbol) doc))
        #t))
    
    (walk-keywords/properties context expression
      (lambda (symbol)
        (case symbol
          ((initialize)
           (keyword context start end)
           #f)
          ((getter setter accessors)
           (keyword context start end)
           (when (and (forward-expr) (eq? kind 'symbol) (string=? (get-marked) "generate"))
             (case symbol
               ((getter)
                (declare-accessor 'getter))
               ((setter)
                (declare-accessor 'setter))
               ((accessors)
                (declare-accessor 'getter)
                (declare-accessor 'setter)))))
          (else
           #f)))))
  
  
  (method (walk-slot context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (forward-whites)
      (when (and (forward-expr) (eq? kind 'symbol))
        (let ((marked (get-marked)))
          (set! entry (declaration context 'slot symbol start end marked (symbol-documented? (find-marked-symbol) doc)))
          (walk-slot/property-accessors context marked declaration keyword expression doc)))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-property context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (let ((marked (get-marked)))
          (set! entry (declaration context 'property symbol start end marked (symbol-documented? (find-marked-symbol) doc)))
          (walk-slot/property-accessors context marked declaration keyword expression doc)))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-form context symbol form declaration keyword expression doc)
    (keyword context start end)
    (walk-expressions context expression))
        
  
  (method (walk-global context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'global symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      entry))
    
  
  (method (walk-constant context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'constant symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-enumeration context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'enumeration symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      (walk-expressions entry expression)
      entry))

  
  (method (walk-c-constant context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'c-constant symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-c-enumeration context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'c-enumeration symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      (walk-expressions entry expression)
      entry))

  
  (method (walk-c-named-declare context symbol form declaration keyword expression doc)
    (keyword context start end)
    (walk-expressions context expression))

  
  (method (walk-c-include context symbol form declaration keyword expression doc)
    (keyword context start end)
    (walk-expressions context expression))
  
  
  (method (walk-c-type context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (and (forward-expr) (eq? kind 'symbol))
        (set! entry (declaration context 'c-type symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-c-structure context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (forward-whites)
      (let ((list? (eqv? (char-forward 0) #\open-parenthesis)))
        (when list?
          (enter-list))
        (when (and (forward-expr) (eq? kind 'symbol))
          (set! entry (declaration context 'c-structure symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc))))
        (when list?
          (exit-list)))
      (walk-expressions entry expression)
      entry))

  
  (method (walk-external context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (forward-expr)
        (let ((entered? (enter-list)))
          (when (and (forward-expr) (eq? kind 'symbol))
            (declaration context 'external symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))
          (when entered?
            (walk-parameters entry declaration keyword expression doc))
          (when entered?
            (exit-list))))
      (walk-expressions entry expression)
      entry))

  
  (method (walk-com-external context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (walk-modifiers context declaration keyword (get-modifiers~ form))
      (when (forward-expr)
        (let ((entered? (enter-list)))
          (when (and (forward-expr) (eq? kind 'symbol))
            (declaration context 'com-external symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))
          (when entered?
            (walk-parameters entry declaration keyword expression doc))
          (when entered?
            (exit-list))))
      (walk-expressions entry expression)
      entry))
  
  
  (method (walk-datacontainer context symbol form declaration keyword expression doc)
    (let ((entry context))
      (keyword context start end)
      (when (forward-expr)
        (declaration context 'datacontainer symbol start end (get-marked) (symbol-documented? (find-marked-symbol) doc)))
      (walk-expressions entry expression)
      entry))))
