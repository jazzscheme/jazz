;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.jazz.text.Jazz-Text-View jazz


(import (jazz.designer)
        (jazz.doc)
        (jazz.editor.jazz)
        (jazz.editor.lisp)
        (jazz.graphic)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.platform)
        (jazz.runtime)
        (jazz.runtime.ui)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.view)
        (jazz.ui.window))


(class Jazz-Text-View extends Lisp-Text-View

  
  (form
    (<install> tooltip?: #t))

  
  (method override (install rest)
    (nextmethod rest)
    (let ((pref (preferences))
          (default (get-name~ default-style)))
      (add-style-preference 'Title                    default (get-title-style~ pref))
      (add-style-preference 'Comment                  default (get-comment-style~ pref))
      (add-style-preference 'Expr-Comment             default (get-expr-comment-style~ pref))
      (add-style-preference 'Named-Comment            default (get-named-comment-style~ pref))
      (add-style-preference 'Declaration-Keyword      default (get-declaration-keyword-style~ pref))
      (add-style-preference 'Documented-Declaration   default (get-documented-declaration-style~ pref))
      (add-style-preference 'Undocumented-Declaration default (get-undocumented-declaration-style~ pref))
      (add-style-preference 'Keyword                  default (get-keyword-style~ pref))
      (add-style-preference 'Tag                      default (get-tag-style~ pref))
      (add-style-preference 'Specifier                default (get-specifier-style~ pref))
      (add-style-preference 'Char                     default (get-char-style~ pref))
      (add-style-preference 'Number                   default (get-number-style~ pref))
      (add-style-preference 'Boolean                  default (get-boolean-style~ pref))
      (add-style-preference 'String                   default (get-string-style~ pref))
      (add-style-preference 'Delimited-String         default (get-delimited-string-style~ pref))
      (add-style-preference 'Named-String             default (get-named-string-style~ pref))
      (add-style-preference 'Quotation                default (get-quotation-style~ pref))
      (add-style-preference 'Literal                  default (get-literal-style~ pref))
      (add-style-preference 'Feature                  default (get-feature-style~ pref))
      (add-style (new Text-Style name: 'Reference    base: default frame: {Color name: Reference}))
      (add-style (new Text-Style name: 'Walk-Warning base: default frame: {Color name: Orange}))
      (add-style (new Text-Style name: 'Walk-Fatal   base: default frame: {Color name: Red}))
      (add-style (new Text-Style name: 'Break        base: default highlight: {Color name: Red}))))
  
  
  (method meta override (external-name . rest)
    'jazz-text)
  
  
  (method override (default-extension)
    "jazz")
  
  
  (method override (extensions)
    '(("Jazz Texts" . "jazz")))
    
  
  (method override (new-syntax)
    (new Jazz-Syntax))


  ;;;
  ;;;; Actions
  ;;;
  

  (method override (focus-actions)
    (cons (find-actions 'jazz-text)
          (nextmethod)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (get-context-menu)
    (let* ((menu (new Jazz-Text-Menu))
           (controller (get-controller))
           (moniker (get-moniker~ controller)))
      @waiting
      (when (or (not moniker) (read/write?~ moniker))
        (set-visible?~ (locate~ menu 'set-read/write) #f))
      (layout-menu~ menu)
      menu))
    
  
  ;;;
  ;;;; Design
  ;;;

  
  (method (on-design-form evt)
    (define (find-editor form)
      (let ((stage (get-stage)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (frame)
                        (when (is? frame Host-View)
                          (let ((guest (get-guest~ frame)))
                            (when (is? guest Editor-View)
                              (let ((designer (get-designer~ guest)))
                                (when (and designer (eq? form (get-form~ designer)))
                                  (continuation-return return frame)))))))
                      (get-children~ stage))
            {}))))
    
    (unimplemented 'on-design-form)
    @convert
    (let* ((name (current-category-name))
           (class (autoload name)))
      (if (not (subtype? class Component))
          (error "Only Component classes can be designed")
        (let* ((form (get-self-form~ class))
               (frame (essay form (find-editor form))))
            (if frame
                (begin
                  (bring-to-front~ frame)
                  (set-visible?~ frame #t))
              (let* ((component (new class))
                     (editor-class (if (is? component View) View-Editor Manager-View)))
                (new-frame editor-class client: component)))))))
  
  
  (method (on-copy-list evt)
    (let ((appl (get-application))
          (list (map (lambda (object) (->string object :reader)) (read-string-content (get-selected-string)))))
      (push-clipboard-list~ appl list)
      (user-message "Pushed {a} elements onto the clipboard stack" (length list))))

  
  ;;;
  ;;;; Tooltip
  ;;;
  

  (method override (get-tooltip-context view)
    {}
    @convert-manifest
    (when (and (in-manifest? 'Debugger) (debugging?~ Debugger))
      (let* ((pos (view->text view))
             (expl (new Jazz-Explorer self start: pos end: pos)))
        (catch (Explore-Error err {})
          (when (outer-expr~ expl atomic?: #t explore-whitespace?: #f)
            (let ((kind (get-kind~ expl)))
              (when (eq? kind 'symbol)
                (let* ((range (get-range~ expl))
                       (location (range-location range))
                       (text (essay location (present-location location))))
                  (when text
                    (let ((bounds (row-range-rect (get-row~ (get-start~ range)) (get-col~ (get-start~ range)) (get-col~ (get-end~ range)))))
                      (when (in-rect? view bounds)
                        (new Tooltip-Context
                          view: self
                          text: text
                          position: (+ (rect-position bounds) (new Point -10 (rect-height bounds)))
                          bounds: bounds
                          font: {Font name: Label}))))))))))))
  
  
  ;;;
  ;;;; Coloring
  ;;;
    
  
  (definition default-preferences
    (instantiate~
      (form>>
        (<Jazz-Text-Preferences>
          title-style:                    {Text-Style-Preference color: Dark-Red}
          comment-style:                  {Text-Style-Preference color: Purple}
          expr-comment-style:             {Text-Style-Preference color: Text-Gray}
          named-comment-style:            {Text-Style-Preference color: Text-Gray}
          documented-declaration-style:   {Text-Style-Preference color: Purple}
          undocumented-declaration-style: {Text-Style-Preference color: Dark-Green}
          keyword-style:                  {Text-Style-Preference color: Dark-Blue}
          completions: ()))))

  
  (method override (preferences)
    (get-preferences '(documents jazz-text)))
  
  
  (method override (declaration-style documented?)
    (if documented?
        'Documented-Declaration
      'Undocumented-Declaration))
  
  
  (method override (colorize-tag colorizer start end)
    (apply-coloring colorizer start end 'Tag))
  
  
  (method override (colorize-specifier colorizer start end)
    (apply-coloring colorizer start end 'Specifier))
  
  
  (method (recolorize-named-comments row)
    (let* ((line (paragraph-string row))
           (len (cardinality line))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((comment (search line "@" start: col)))
          (if (not comment)
              (set! done? #t)
            (unless (and (> comment 0) (eqv? (element line (- comment 1)) #\,))
              (let* ((pos (new Cell row (+ comment 1)))
                     (expl <Text-Explorer> (new (explorer-class) self start: pos end: pos))
                     (kind (forward-expr~ expl))
                     (end (get-end~ expl)))
                (when (and (eq? kind 'symbol) (= (get-row~ end) row))
                  (apply-style 'Named-Comment (- (get-start~ expl) 1) (get-end~ expl)))))
            (set! col (+ comment 1)))))))
  
  
  ;;;
  ;;;; Reading
  ;;;
  
  
  (method override (get-readtable)
    jazz-readtable)
  
  
  ;;;
  ;;;; Evaluation
  ;;;
  
  
  (method override (prepare-expressions range)
    (define (collect-namespaces)
      (let ((namespaces '())
            (expl (new Jazz-Explorer self range: range)))
        (while (outer-expr~ expl)
          (when (namespace-expr?~ expl)
            (let ((namespace (namespace-declaration-range~ expl)))
              (set! namespaces (cons namespace namespaces)))))
        namespaces))
    
    (define (package-expressions namespaces expressions)
      (let ((first (if (not-null? namespaces) (car namespaces) range)))
        (let ((first-row (get-row~ (get-start~ first)))
              (first-col (get-col~ (get-start~ first))))
          (let ((row first-row)
                (col first-col)
                (output (open-output-string)))
            (define (fill rng)
              (let ((r (get-row~ (get-start~ rng)))
                    (c (get-col~ (get-start~ rng))))
                (let (iterate)
                  (if (= r row)
                      (begin
                        (display (make-string (- c col) #\space) output)
                        (set! col c))
                    (display #\newline output)
                    (set! row (+ row 1))
                    (set! col 0)
                    (iterate)))))
            
            (for-each (lambda (range)
                        (let ((namespace (get-string range)))
                          (fill range)
                          (for-each-pair (lambda (pair)
                                           (let ((line (car pair))
                                                 (last? (null? (cdr pair))))
                                             (display line output)
                                             (if (not last?)
                                                 (begin
                                                   (newline output)
                                                   (set! row (+ row 1))
                                                   (set! col 0))
                                               (set! col (+ col (cardinality line))))))
                                         (split namespace (string #\newline)))))
                      namespaces)
            (fill range)
            (display expressions output)
            (display (make-string (length namespaces) #\)) output)
            (values (get-output-string output) first-row first-col)))))
    
    (let ((container (get-locat-container))
          (namespaces (collect-namespaces))
          (string (get-string range)))
      (receive (str line col) (package-expressions namespaces string)
        (list 'jazz str container line col))))


  ;;;
  ;;;; Breaks
  ;;;
  
  
  (method package (on-add-break evt)
    @convert
    (let* ((range (current-expr-range))
           (loc (range-location range)))
      (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter loc)
        (if (not resolved?)
            (error "Unable to resolve location: {t}" loc)
          (add-break~ Interpreter object)
          (apply-style 'Break (get-start~ range) (+ (get-start~ range) 1))))))
  
  
  (method package (on-remove-break evt)
    @convert
    (let* ((range (current-expr-range))
           (loc (range-location range)))
      (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter loc)
        (if (not resolved?)
            (bell)
          (remove-break~ Interpreter object)
          (let ((run (get-run-at (+ (get-start~ range) 1))))
            (when run
              (set-style~ run default-style)
              (invalidate-paragraph (get-paragraph (get-row~ (get-start~ range))))))))))

  
  ;;;
  ;;;; Presentation
  ;;;
  
  
  ;; todo: code from old jazz was not portable
  (definition (present-location location)
    )
  

  ;;;
  ;;;; Location
  ;;;
  
  @unused
  (method (current-location)
    (position->location (get-start)))
  
  @unused
  (method (position->location pos)
    (let ((expl (new Jazz-Explorer self start: pos end: pos)))
      (when (outer-expr~ expl outer-composite?: #f)
        (let ((range (get-range~ expl)))
          (range-location range)))))
  
  
  (method (location-class loc (load?: load? #f))
    @convert
    (let* ((class-name (car loc))
           (class (global-value~ class-name load?)))
      (if (not class)
          (error "Unable to find class: {t}" class-name)
        (let ((meta? #f))
          (for-each (lambda (name)
                      (if (eq? name 'meta)
                          (set! meta? #t)
                        (set! class (definition-value (category-field (if meta? (class-of class) class) name)))
                        (set! meta? #f)))
                    (cdr loc)))
        class)))
  
  
  (method (declaration-name-info object)
    (unimplemented 'declaration-name-info)
    @convert
    (cond ((category? object)
           (values 1 #f))
          ((slot? object)
           (values (+ 1 (field-modifiers-count object)) #f))
          ((field? object)
           (let ((value (definition-value object)))
             (cond ((procedure? value) (values (+ 1 (field-modifiers-count object)) #t))
                   ((external? value) (values (+ 2 (field-modifiers-count object) 1) #t))
                   (else {}))))
          (else
           {})))
  
  
  (method (declaration-name-location? object internal-location)
    (let ((info (declaration-name-info object)))
      (when info
        (receive (skip inside-allowed?) info
          (or (= internal-location (list skip))
              (and inside-allowed? (= internal-location (list skip 0))))))))


  (method (range-location range)
    (let ((expl (new Jazz-Explorer self start: (get-start~ range) end: (get-end~ range)))
          (location {})
          (previous-def? #f)
          (done? #f))
      (while (not done?)
        (let ((rank (outer-expr~ expl)))
          (if (not rank)
              (set! done? #t)
            (let ((def? (declaration-expr?~ expl)))
              (if def?
                  (receive (modifiers name) (declaration-name~ expl)
                    (let ((loc (if previous-def? location (cons rank location))))
                      (if (memq? 'meta modifiers)
                          (set! location (cons 'meta (cons name loc)))
                        (set! location (cons name loc)))))
                (set! location (cons rank location)))
              (set! previous-def? def?)))))
      location))


  (method public (location-range location (toplevel-location: toplevel-location {}))
    (let ((expl (new Jazz-Explorer self end: (text-beginning))))
      (forward-location~ expl location toplevel-location: toplevel-location)
      (get-range~ expl)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method (on-edit-documentation evt)
    (let ((symbol (current-symbol)))
      (if (not symbol)
          (bell)
        (let ((appl (get-application)))
          (edit-documentation~ appl symbol)))))
  
  
  (method (on-present-documentation evt)
    (present-documentation (current-symbol)))

  
  (method (present-documentation symbol)
    (define (doc-jml)
      (when symbol
        (let ((doc (get-documentation~ (get-application) symbol)))
          (when doc
            (present-text~ doc)))))
    
    (let ((jml (doc-jml)))
      (if (not jml)
          (bell)
        (let* ((view (new Documentation-View size: {Dimension 600 300}))
               (text (locate~ view 'text))
               (pos {Point 100 100})
               (alternate {Point 100 100})
               (border (new Border-View border-type: 'solid))
               (display (get-display)))
          (set-text~ text (transform-jml (parse-jml jml) (new DocToText-Transformation)))
          (popup~ display view pos alternate-position: alternate border: border)))))
  
  
  ;;;
  ;;;; Arguments
  ;;;
  
  
  ;; todo
  ;;   make work in console
  ;;   support for { [ ...

  
  (method override (show-arguments)
    (define (show-declaration-arguments expl)
      @convert
      (let ((name (get-marked~ expl))
            (info (current-toplevel-info)))
        (when info
          (receive (in category-info) info
            (bind (category kind meta? name keywords) category-info
              (when category
                (let ((symbol (find-symbol name)))
                  (when symbol
                    (let ((imports (getf keywords 'uses)))
                      (show-symbol-arguments symbol category imports))))))))))
    
    (define (show-symbol-arguments symbol class packages)
      (unimplemented 'show-symbol-arguments)
      @convert
      (let ((field (find-in symbol class packages)))
        (when field
          (let ((value (definition-value field)))
            (typecase value
              ((External)
               (show-external-arguments symbol value))
              ((%function)
               (show-function-arguments symbol value))
              ((Closure)
               (show-function-arguments symbol (closure-function~ Interpreter value))))))))
    
    (define (show-external-arguments symbol external)
      @convert
      (user-message "({s} {l}{a}) {s}"
                    symbol
                    (map category-name (accumulate (proxy-parameters~ Interpreter external) get-type~ List))
                    (if (proxy-rest?~ Interpreter external) " . rest" "")
                    (category-name (get-type~ (proxy-result~ Interpreter external)))))
    
    (define (show-function-arguments symbol function)
      @convert
      (let* ((parameters (function-parameters~ Interpreter function))
             (printer (open-output-string))
             ;; convert
             (rest 'rest))
        (present-parameters parameters rest printer)
        (user-message "({a} {a})" symbol (get-output-string printer))))
    
    (define (present-parameters parameters bind printer)
      (define (present-parameter parameter printer)
        @convert
        (typecase parameter
          ((Variable) (format printer "{s}" (variable-symbol~ Interpreter parameter)))
          (else (format printer "{s}" parameter))))
      
      (when parameters
        (cond ((pair? parameters)
               (present-parameter (car parameters) printer)
               (format printer " ")
               (present-parameters (cdr parameters) bind printer))
              (bind
                    (format printer "{a}" bind))
              (else
               (format printer ". {a}" parameters)))))
    
    (when (empty-selection?)
      (let ((expl (new Jazz-Explorer self start: (get-start) end: (get-end))))
        (when (and (backward-expr~ expl)
                   (= (get-kind~ expl) 'symbol))
          (case (char-backward~ expl 0)
            ((#\open-parenthesis) (show-declaration-arguments expl)))))))
   

  ;;;
  ;;;; Explorer
  ;;;


  (method override (explorer-class)
    Jazz-Explorer)

  
  ;;;
  ;;;; Category
  ;;;
  
  
  (method (current-category-name)
    @convert
    (receive (in category-info) (current-toplevel-info)
      (bind (category kind meta? name keywords) category-info
        name)))
  
  
  (method (toplevel-expr pos)
    (let ((expl (new Jazz-Explorer self start: pos end: pos))
          (range {}))
      (while (outer-expr~ expl)
        (set! range (get-range~ expl)))
      range))
  
  
  ;;;
  ;;;; Edit
  ;;;
    
  
  (method override (edit-symbol-class symbol)
    @convert
    (when (in-manifest? symbol)
      (edit-class~ (get-application) symbol)
      #t)))


;;;
;;;; Documentation-View
;;;


(class Documentation-View extends Layout-View
  
  
  (form
    (<install>                                     layout-type: fill
      (<Scroller-View>                             hscroll?: #f vscroll?: #t flat?: #t
        (<!>                         name: content layout-type: fill
          (<Documentation-Text-View> name: text    background: {Color name: Tooltip} editable?: #f))))))


;;;
;;;; Jazz-Text-Menu
;;;


(class Jazz-Text-Menu extends Context-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: evaluate             title: "Evaluate" icon: {Bitmap-Resource "Execute"} action: {Action code-text evaluate})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: design-form          title: "Design Form" icon: {Bitmap-Resource "Designer"} action: {Action jazz-text design-form})
      (<Separator-Item>)
      (<Label-Item>     name: edit-definitions     title: "Find Definitions" icon: {Bitmap-Resource "Edit"} action: {Action code-text edit-definitions})
      (<Label-Item>     name: edit-references      title: "Find References" action: {Action code-text edit-references})
      @waiting
      (<Label-Item>     name: edit-documentation   title: "Edit Documentation" action: {Action jazz-text edit-documentation})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: add-break            title: "Add Break" icon: {Bitmap-Resource "AddBreak"} action: {Action jazz-text add-break})
      @waiting
      (<Label-Item>     name: remove-break         title: "Remove Break" icon: {Bitmap-Resource "RemoveBreak"} action: {Action jazz-text remove-break})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: set-read/write       title: "Set Read/Write" action: {Action jazz-text set-read/write})
      (<Separator-Item>)
      (<Label-Item>     name: cut                  title: {Locales english: "Cut" french: "Couper"} icon: {Bitmap-Resource "Cut"} action: {Action view cut})
      (<Label-Item>     name: copy                 title: {Locales english: "Copy" french: "Copier"} icon: {Bitmap-Resource "Copy"} action: {Action view copy})
      (<Label-Item>     name: paste                title: {Locales english: "Paste" french: "Coller"} icon: {Bitmap-Resource "Paste"} action: {Action view paste})
      (<Separator-Item>)
      (<Label-Item>                                title: "Column"
        (<Column-Menu>))
      (<Label-Item>                                title: "Format"
        (<Format-Menu>))))))
