;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Lisp Parser
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.lisp.parser.Lisp-Parser jazz


(import (jazz.catalog)
        (jazz.editor.lisp)
        (jazz.jml))


(class Lisp-Parser extends File-Parser
  
  
  (method override (parse file time)
    (new Lisp-File-Entry catalog file time (parse-definitions file)))
  
  
  ;; Until it is cleanly processed in the Lisp explorer
  (definition Lisp-Period
    ".")
  
  
  (method (parse-definitions file)
    (let ((text (new (text-view-class) char-encoding: char-encoding colorize?: #f)))
      (set-moniker~ text file)
      (let* ((beginning (text-beginning~ text))
             (expl (new (explorer-class file) text start: beginning end: beginning))
             (fact (new List-Factory)))
        (walk-declarations~ expl
          {}
          ;; declaration
          (lambda (parent kind symbol start end marked documented?)
            (define (mangle-name name)
              (case symbol
                ((jazz.define-macro) '("macro"))
                ((jazz.define-syntax) '("syntax"))
                ((jazz.define-global) '("global"))
                ((jazz.define-setting) '("setting"))
                ((jazz.define-variable) '("variable"))
                ((jazz.define-check-macro) '("check-macro"))
                ((jazz.define-dialect) '("dialect"))
                ((jazz.define-walker-special) '("special"))
                ((jazz.define-walker-macro) '("macro"))
                ((jazz.define-walker-syntax) '("syntax"))
                ((jazz.define-class) '("class"))
                ((jazz.define-class-runtime) '("class runtime"))
                ((jazz.define-literal) '("literal"))
                ((remotable-stub) "~stub")
                ((register-autoclass) "~register")
                ((define-form) '("form"))
                (else #f)))
            
            (define (mangle-signature signature)
              (case symbol
                ((jazz.define-virtual) (cons (string-append (car signature) "~virtual") (cdr signature)))
                ((jazz.define-virtual-runtime) (cons (string-append (car signature) "~virtual-runtime") (cdr signature)))
                (else signature)))
            
            (define (mangle-declaration name signature)
              (let ((name-mangle (mangle-name name))
                    (signature-mangle (and signature (mangle-signature signature))))
                (when (or name-mangle signature-mangle)
                  (cond ((and name-mangle signature-mangle)
                         (append name-mangle signature-mangle))
                        (else
                         (or signature-mangle
                             name-mangle))))))
            
            (let* ((name (if (pair? marked) (car marked) marked))
                   (signature (mangle-declaration name (if (pair? marked) (cdr marked) #f))))
              (let ((entry (new Lisp-Entry name kind signature (get-row~ start) (get-col~ start) (get-row~ end) (get-col~ end) '() '())))
                (if (not parent)
                    (put~ fact entry)
                  (set-parent~ entry parent)
                  (add-definition~ parent entry))
                entry)))
          ;; keyword
          (lambda (parent start end)
            {})
          ;; expression
          (lambda (parent start end mode kind)
            (when (and parent (memq? kind '(symbol keyword)))
              (let ((name (get-marked~ expl)))
                (unless (string=? name Lisp-Period)
                  (add-reference~ parent
                    (cond ((tag-string? name) (tag->name name))
                          ((dispatch-string? name) (dispatch->name name))
                          (else name))))))
            parent)
          {})
        (get-output~ fact))))
  
  
  (method protected virtual (explorer-class file)
    )
  
  
  (method protected virtual (text-view-class)
    )))
