;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Lisp Parser
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.lisp.parser.Lisp-Parser jazz


(import (jazz.catalog)
        (jazz.editor.lisp)
        (jazz.jml))


(class Lisp-Parser extends File-Parser
  
  
  (method meta override (reference-searcher target constituent-test)
    (make-searcher
      (lambda (seq constituent-test start reversed?)
        (if (or (and (tag-string? seq)
                     (equal? (tag->name seq) target))
                (equal? seq target))
            (cons 0 (cardinality seq))
          #f))))
  
  
  (method override (parse file time dialect)
    (new Lisp-File-Entry catalog file time dialect (parse-definitions file)))
  
  
  (method (parse-definitions file)
    ;; until it is cleanly processed in the Lisp explorer
    (define Lisp-Period
      ".")
    
    (let ((text (new (text-view-class) char-encoding: char-encoding colorize?: #f)))
      (set-moniker~ text file)
      (let* ((beginning (text-beginning~ text))
             (expl (new (explorer-class file) text start: beginning end: beginning))
             (fact (new List-Factory)))
        (walk-declarations~ expl
          #f
          ;; declaration
          (lambda (parent kind symbol start end marked documented?)
            (define (mangle-name name)
              (expression-syntax-name-mangler symbol))
            
            (define (mangle-signature signature)
              (let ((mangler (expression-syntax-signature-mangler symbol)))
                (if mangler
                    (cons (string-append (car signature) mangler) (cdr signature))
                  signature)))
            
            (define (mangle-declaration name signature)
              (let ((name-mangle (mangle-name name))
                    (signature-mangle (and signature (mangle-signature signature))))
                (when (or name-mangle signature-mangle)
                  (cond ((and name-mangle signature-mangle)
                         (append name-mangle signature-mangle))
                        (else
                         (or signature-mangle
                             name-mangle))))))
            
            (let* ((name (if (pair? marked) (car marked) marked))
                   (signature (mangle-declaration name (if (pair? marked) (cdr marked) #f))))
              (let ((entry (new Lisp-Entry name kind signature (get-line~ start) (get-col~ start) (get-line~ end) (get-col~ end) '() '())))
                (if (not parent)
                    (put~ fact entry)
                  (set-parent~ entry parent)
                  (add-definition~ parent entry))
                entry)))
          ;; keyword
          (lambda (parent start end)
            #f)
          ;; expression
          (lambda (parent start end mode kind)
            (when (and parent (memq? kind '(symbol specifier keyword)))
              (let ((name (get-marked~ expl)))
                (unless (or (empty-string? name)
                            (eqv? (string-ref name 0) #\')
                            (string=? name Lisp-Period))
                  (add-references name
                                  (lambda (ref)
                                    (unless (empty-string? ref)
                                      (add-reference~ parent ref)))))))
            parent)
          #f)
        (get-output~ fact))))
  
  
  (method protected virtual (text-view-class)
    )
  
  
  (method protected virtual (explorer-class file)
    )
  
  
  (method protected virtual (add-references name <string> adder)
    (cond ((tag-string? name) (adder (tag->name name)))
          (else (adder name))))))
