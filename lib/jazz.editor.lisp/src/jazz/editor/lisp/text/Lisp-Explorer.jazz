;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exploring Lisp Code
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.lisp.text.Lisp-Explorer jazz


(import (jazz.exemplar)
        (jazz.editor)
        (jazz.editor.jazz)
        (jazz.editor.lisp)
        (jazz.text))


(proclaim (warn optimizations))


;; KINDS
;; - number
;; - boolean
;; - char
;; - sharp
;; - string
;; - delimited-string
;; - named-string
;; - symbol
;; - keyword
;; - expr-comment
;; - named-comment
;; - list
;; - reference
;; - literal


(class Lisp-Explorer extends Code-Explorer
  
  
  ;; simple cache to speed up getting many times
  ;; in a row the comment column for the same row
  (slot find-comment-last-row <fx+> initialize #f)
  (slot find-comment-last-col <fx+> initialize #f)
  
  
  (constant Composites
    '((#\open-parenthesis #\close-parenthesis list)
      (#\open-bracket     #\close-bracket     reference)
      (#\open-brace       #\close-brace       literal)))
  
  
  (constant Open-Composites
    '(#\open-parenthesis
      #\open-bracket
      #\open-brace))
  
  
  (constant Close-Composites
    '(#\close-parenthesis
      #\close-bracket
      #\close-brace))
  
  
  (method package (explore-error self message start end)
    (let ((source #f @mvc (get-moniker model))
          (start (or start (text-beginning model)))
          (end (or end (text-ending model))))
      (signal (new Explore-Error source start: start end: end message: message))))
  
  
  (method (present-char self c)
    (cond ((not c)
           "EOF")
          ((memv? c '(#\space #\tab #\return #\linefeed))
           (char-symbol c))
          (else
           (string c))))
  
  
  (method public (current-expr self)
    (and (backward-expr self) (eq? kind 'symbol)
      (get-marked self)))

  
  (method override (forward-expr self)
    (define (forward-quotes)
      (let ((c (char-forward self 0)))
        (and (memv? c '(#\quote #\backquote #\comma))
             (begin
               (when (and (eqv? c #\comma) (eqv? (char-forward self 1) #\at))
                 (forward self))
               (forward self)
               (forward-whites self)
               #t))))
    
    (forward-whites self)
    (set-start self end)
    (let ((s (get-start self)))
      (while (forward-quotes))
      (prog1 (forward-simple-expr self)
        (set-start self s))))

  
  (method override (backward-expr self)
    (define (backward-quote)
      (let ((c (char-backward self 0)))
        (cond ((memv? c '(#\quote #\backquote #\comma #\at))
               (backward self)
               #t)
              ((and (eqv? (char-backward self 1) #\comma) (eqv? c #\at))
               (backward self)
               (backward self)
               #t)
              (else
               #f))))
    
    (backward-whites self)
    (set-end self start)
    (let ((c0 (char-backward self 0))
          (c1 (char-backward self 1))
          (c2 (char-backward self 2)))
      (cond ((and (eqv? c0 #\sharp) (eqv? c1 #\double-quote))
             (backward-delimited-string self))
            ((and (eqv? c0 #\sharp) (eqv? c1 #\slash) (eqv? c2 #\slash))
             (backward-syntax-string self))
            ((and (eqv? c0 #\sharp) (eqv? c1 #\vertical-bar))
             (backward-multiline-comment self))
            ((and (eqv? c1 #\backslash) (eqv? (char-backward self 2) #\sharp))
             (backward-scheme-char self))
            (else
             (let ((found (backward-simple-expr self)))
               (and found
                    (begin
                      (while (backward-quote))
                      (if (and (is? (get-syntax self) Jazz-Syntax) (eqv? (get-char self start) #\at))
                          'name-comment
                        found))))))))


  (method protected (forward-simple-expr self)
    (let ((c (char-forward self 0)))
      (and c
           (cond ((eqv? c #\sharp)            (forward-sharp self))
                 ((string-delimiter? c)       (forward-string self))
                 ((eqv? c #\backslash)        (forward-backslahed-symbol self))
                 ((eqv? c #\vertical-bar)     (forward-escaped-symbol self))
                 ((text-constituent? self c)  (forward-constituent self))
                 ((eqv? c #\at)               (forward-named-comment self))
                 ((eqv? c #\open-parenthesis) (forward-composite self 'list      #\close-parenthesis))
                 ((eqv? c #\open-bracket)     (forward-composite self 'reference #\close-bracket))
                 ((eqv? c #\open-brace)       (forward-composite self 'literal   #\close-brace))
                 (else #f)))))

  
  (method protected (backward-simple-expr self)
    (define (space-literal? c)
      (and (eqv? (char-forward self 0) #\space)
           (eqv? (char-backward self 0) #\backslash)
           (eqv? (char-backward self 1) #\sharp)))
    
    (let ((c (char-backward self 0)))
      (and c
           (cond ((string-delimiter? c)        (backward-string self))
                 ((eqv? c #\vertical-bar)      (backward-escaped-symbol self))
                 ((text-constituent? self c)   (backward-constituent self))
                 ((space-literal? c)           (backward self) (backward self))
                 ((eqv? c #\close-parenthesis) (backward-composite self 'list      #\open-parenthesis))
                 ((eqv? c #\close-bracket)     (backward-composite self 'reference #\open-bracket))
                 ((eqv? c #\close-brace)       (backward-composite self 'literal   #\open-brace))
                 ((eqv? c #\open-parenthesis)  #f)
                 ((eqv? c #\open-bracket)      #f)
                 ((eqv? c #\open-brace)        #f)
                 (else (backward self))))))

  
  (method public (forward-all-expr self)
    (let ((initial-end (copy end)))
      (while (forward-expr self)
        )
      (set! start initial-end)))

  
  (method public (backward-all-expr self)
    (let ((initial-start (copy start)))
      (while (backward-expr self)
        )
      (set! end initial-start)))

  
  (method override (forward-constituent self)
    (let ((keyword? (eqv? (char-forward self 0) #\colon))
          (last #f))
      (let (iterate)
        (let ((c (char-forward self 0)))
          (cond ((eqv? c #\backslash)
                 (forward self)
                 (forward self)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? self c)))
                 (set! kind (if (or keyword? (and last (eqv? last #\colon))) 'keyword 'symbol))
                 kind)
                (else
                 (forward self)
                 (set! last c)
                 (iterate)))))))

  
  (method override (backward-constituent self)
    (let ((keyword? (eqv? (char-backward self 0) #\colon))
          (last #f))
      (let (iterate)
        (let ((c (char-backward self 0)))
          (cond ((and (eqv? (char-backward self 1) #\backslash)
                      (eqv? (char-backward self 2) #\sharp))
                 (backward self)
                 (backward self)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? self c)))
                 (set! kind (if (or keyword? (eqv? last #\colon)) 'keyword 'symbol))
                 kind)
                (else
                 (backward self)
                 (set! last c)
                 (iterate)))))))
  
  
  (method protected (backward-escaped-symbol self)
    (backward self)
    (let (iterate)
      (let ((c (char-backward self 0)))
        (if (not c)
            #f
          (cond ((eqv? (char-backward self 1) #\backslash)
                 (backward self)
                 (backward self)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (backward self)
                 (set! kind 'symbol)
                 kind)
                (else
                 (backward self)
                 (iterate)))))))
  
  
  (method protected (backward-scheme-char self)
    (backward self)
    (backward self)
    (backward self)
    (set! kind 'char)
    kind)
  
  
  (method protected (forward-expr-comment self)
    (forward self)
    (forward-expr self)
    (set! kind 'expr-comment)
    kind)
  
  
  (method protected (forward-named-comment self)
    (if (is-not? (get-syntax self) Jazz-Syntax)
        (forward-constituent self)
      (forward self)
      (forward-expr self)
      (set! kind 'named-comment)
      kind))
  
  
  ;; first draft that doesn't support nesting
  (method protected (forward-multiline-comment self)
    (forward self)
    (forward self)
    (let (iterate)
      (let ((c (char-forward self 0)))
        (and c
             (if (and (eqv? c #\vertical-bar)
                      (eqv? (char-forward self 1) #\sharp))
                 (begin
                   (forward self)
                   (forward self)
                   (set! kind 'multiline-comment)
                   kind)
               (forward self)
               (iterate))))))
  
  
  ;; first draft that doesn't support nesting
  (method protected (backward-multiline-comment self)
    (backward self)
    (backward self)
    (let (iterate)
      (let ((c0 (char-backward self 0))
            (c1 (char-backward self 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\vertical-bar) (eqv? c1 #\sharp))
               (backward self)
               (backward self)
               (set! kind 'multiline-comment)
               kind)
              (else
               (backward self)
               (iterate))))))
  
  
  (method protected (forward-sharp self)
    (forward self)
    (let ((c0 (char-forward self 0))
          (c1 (char-forward self 1)))
      (cond ((and (memq? c0 '(#\t #\f)) (or (not c1) (not (text-constituent? self c1))))
             (forward self)
             (set! kind 'boolean)
             kind)
            ((eqv? c0 #\double-quote)
             (forward-delimited-string self))
            ((eqv? c0 #\slash)
             (forward-syntax-string self))
            ((and (eqv? c0 #\<) (eqv? (char-forward self 1) #\<))
             (forward-named-string self))
            ((eqv? c0 #\backslash)
             (forward-scheme-char self))
            ((memv? c0 '(#\e #\i #\b #\o #\d #\x))
             (forward-scheme-char self))
            ((eqv? c0 #\semi-colon)
             (forward-expr-comment self))
            ((eq? c0 #\vertical-bar)
             (forward-multiline-comment self))
            (else
             (forward-constituent self)))))
  
  
  (method protected (forward-backslahed-symbol self)
    (forward self)
    (forward self)
    (forward-constituent self))
  
  
  (method protected (forward-escaped-symbol self)
    (forward self)
    (let (iterate)
      (let ((c (char-forward self 0)))
        (if (not c)
            #f
          (cond ((eqv? c #\backslash)
                 (forward self)
                 (forward self)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (forward self)
                 (set! kind 'symbol)
                 kind)
                (else
                 (forward self)
                 (iterate)))))))
  
  
  (method protected virtual (forward-delimited-string self)
    (forward self)
    (let (iterate)
      (let ((c0 (char-forward self 0))
            (c1 (char-forward self 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\double-quote) (eqv? c1 #\sharp))
               (forward self)
               (forward self)
               (set! kind 'delimited-string)
               kind)
              (else
               (forward self)
               (iterate))))))
  
  
  (method protected (backward-delimited-string self)
    (backward self)
    (backward self)
    (let (iterate)
      (let ((c0 (char-backward self 0))
            (c1 (char-backward self 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\double-quote) (eqv? c1 #\sharp))
               (backward self)
               (backward self)
               (set! kind 'delimited-string)
               kind)
              (else
               (backward self)
               (iterate))))))
  
  
  (method protected virtual (forward-syntax-string self)
    (forward self)
    (let (iterate)
      (let ((c0 (char-forward self 0))
            (c1 (char-forward self 1))
            (c2 (char-forward self 2)))
        (cond ((or (not c0) (not c1) (not c2))
               #f)
              ((and (eqv? c0 #\slash) (eqv? c1 #\slash) (eqv? c2 #\sharp))
               (forward self)
               (forward self)
               (forward self)
               (set! kind 'syntax-string)
               kind)
              (else
               (forward self)
               (iterate))))))
  
  
  (method protected (backward-syntax-string self)
    (backward self)
    (backward self)
    (backward self)
    (let (iterate)
      (let ((c0 (char-backward self 0))
            (c1 (char-backward self 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\slash) (eqv? c1 #\sharp))
               (backward self)
               (backward self)
               (set! kind 'syntax-string)
               kind)
              (else
               (backward self)
               (iterate))))))
  
  
  (method protected (forward-named-string self)
    (forward self)
    (forward self)
    (continuation-capture
      (lambda (return)
        (let ((name (subseq (paragraph-string self (get-line end)) (get-col end))))
          (set-end self (new Cell (+ (get-line end) 1) 0))
          (while (< (get-line end) limit)
            (if (nu=? (subseq (paragraph-string self (get-line end)) (get-col end)) name)
                (begin
                  (set-end self (new Cell (+ (get-line end) 1) 0))
                  (continuation-return return 'named-string))
              (set-end self (new Cell (+ (get-line end) 1) 0)))))
        #f)))

  
  (method protected (forward-scheme-char self)
    (forward self)
    (let ((c (char-forward self 0)))
      (if (not c)
          #f
        (if (not (alphanumeric? c))
            (begin
              (forward self)
              (set! kind 'char)
              kind)
          (let (iterate)
            (let ((c (char-forward self 0)))
              (cond ((not c)
                     #f)
                    ((not (text-constituent? self c))
                     (set! kind 'char)
                     kind)
                    (else
                     (forward self)
                     (iterate)))))))))
  
  
  (method protected (forward-string self)
    (forward self)
    (let (iterate)
      (call-line-hook self)
      (let ((c (char-forward self 0)))
        (cond ((not c)
               #f)
              ((eqv? c #\backslash)
               (forward self)
               (forward self)
               (iterate))
              ((string-delimiter? c)
               (forward self)
               (set! kind 'string)
               kind)
              (else
               (forward self)
               (iterate))))))
  
  
  (method protected (backward-string self)
    (backward self)
    (let (iterate)
      (let ((c (char-backward self 0)))
        (cond ((not c)
               #f)
              ((eqv? (char-backward self 1) #\backslash)
               (backward self)
               (backward self)
               (iterate))
              ((string-delimiter? c)
               (backward self)
               (set! kind 'string)
               kind)
              (else
               (backward self)
               (iterate))))))
  
  
  (method protected (forward-composite self knd <Object> delimiter)
    (set-start self end)
    (forward self)
    (forward-all-expr self)
    (forward-whites self)
    (let ((c (char-forward self 0)))
      (if (not (eqv? c delimiter))
          (explore-error self (format "Found unexpected character while exploring forward: {a}" (present-char self c)) end (next-pos self end 1))
        (forward self)
        (set! kind knd)
        kind)))
  
  
  (method protected (backward-composite self knd <Object> delimiter)
    (let ((initial-start (copy start)))
      (backward self)
      (backward-all-expr self)
      (backward-whites self)
      (let ((c (char-backward self 0)))
        (if (not (eqv? c delimiter))
            (explore-error self (format "Found unexpected character while exploring backward: {a}" (present-char self c)) (previous-pos self start 1) start)
          (backward self)
          (set! end initial-start)
          (set! kind knd)
          kind))))

  
  (method public (enter-list self)
    (forward-whites self)
    (and (eqv? (char-forward self 0) #\open-parenthesis)
         (begin
           (forward self)
           #t)))
  
  
  (method public (exit-list self)
    (forward-all-expr self)
    (forward-whites self)
    (and (eqv? (char-forward self 0) #\close-parenthesis)
         (begin
           (forward self)
           #t)))
  
  
  (method public (enter-composite self)
    (let ((end (get-end self)))
      (set-end self (get-start self))
      (forward-whites self)
      (let ((c0 (char-forward self 0)))
        (cond ((and (eqv? c0 #\comma) (eqv? (char-forward self 1) #\at))
               (forward self)
               (forward self)
               (set! kind 'unquote-splicing)
               #t)
              ((eqv? c0 #\comma)
               (forward self)
               (set! kind 'unquote)
               #t)
              ((eqv? c0 #\quote)
               (forward self)
               (set! kind 'quote)
               #t)
              ((eqv? c0 #\backquote)
               (forward self)
               (set! kind 'quasiquote)
               #t)
              ((eqv? c0 #\open-parenthesis)
               (forward self)
               (set! kind 'list)
               #t)
              ((eqv? c0 #\open-bracket)
               (forward self)
               (set! kind 'reference)
               #t)
              ((eqv? c0 #\open-brace)
               (forward self)
               (set! kind 'literal)
               #t)
              (else
               (set-end self end)
               #f)))))
  
  
  (method public (exit-composite self)
    (forward-all-expr self)
    (forward-whites self)
    (and (memv? (char-forward self 0) Close-Composites)
         (begin
           (forward self)
           #t)))
  
  
  (method public (skip-forward self name <string>)
    (and (forward-expr self) (= (get-marked self) name)))
  
  
  (method public (skip-backward self name <string>)
    (and (backward-expr self) (= (get-marked self) name)))
  
  
  (method public (forward-modifiers self modifiers)
    (let ((old (copy end))
          (symbol #f)
          (result '()))
      (let (iterate)
        (when (and (forward-expr self) (eq? kind 'symbol))
           (set! symbol (find-marked-symbol self))
           (when (memq? symbol modifiers)
             (set! old (copy end))
             (set! result (cons symbol result))
             (iterate))))
      (set! end old)
      (reverse! result)))
  
  
  (method (forward-comments self)
    (next-paragraph self))
  
  
  (method (backward-comments self)
    )

  
  (method public (forward-whites self) <void>
    (let (iterate)
      (let ((c (char-forward self 0)))
        (when c
          (if (whitespace? c)
              (when (forward self)
                (iterate))
            (case c
              ((#\semi-colon)
               (forward-comments self)
               (iterate)))))))
    (call-line-hook self))

  
  (method public (backward-whites self) <void>
    (let (iterate)
      (let (iterate)
        (let ((c (char-backward self 0)))
          (when (and c (whitespace? c) (backward self))
            (iterate))))
      (when (backward-lisp-comment self)
        (iterate))))

  
  (method (backward-lisp-comment self) <bool>
    (define (find-lisp-comment line <fx>) <fx+>
      (let ((max-col (paragraph-length self line))
            (preserved-end (copy end))
            (result #f))
        (set-end self (new Cell line 0))
        (let ((result
                (let (iterate)
                  (and (= (get-line end) line) (< (get-col end) max-col)
                    (let ((c0 (char-forward self 0)))
                      (cond ((eqv? c0 #\double-quote)
                             (forward-string self)
                             (iterate))
                            ((eqv? c0 #\sharp)
                             (let ((c1 (char-forward self 1)))
                               (cond ((eqv? c1 #\vertical-bar)
                                      (forward self)
                                      (forward-multiline-comment self)
                                      (iterate))
                                     ((eqv? c1 #\semi-colon)
                                      (forward self)
                                      (forward self)
                                      (iterate))
                                     ((eqv? c1 #\backslash)
                                      (forward self)
                                      (forward-scheme-char self)
                                      (iterate))
                                     (else
                                      (forward self)
                                      (iterate)))))
                            ((eqv? c0 #\semi-colon)
                             (get-col end))
                            (else
                             (forward self)
                             (iterate))))))))
          (set-end self preserved-end)
          result)))
    
    (let ((start-line (get-line start))
          (start-col (get-col start)))
      (let ((col (if (eqv? start-line find-comment-last-row)
                     find-comment-last-col
                   (let ((col (find-lisp-comment start-line)))
                     (set! find-comment-last-row start-line)
                     (set! find-comment-last-col col)
                     col))))
        (and (and col (< col start-col))
             (begin
               (set-col start col)
               #t)))))


  ;;;
  ;;;; Level
  ;;;
  
  
  ;; == explorer problem:
  ;; many exploration modes are free-form (_ = terminal/white-space)
  ;; - _/* ... */_
  ;; - _#" ... "#_
  ;; - multiline commented code like:
  ;;   ;; [ ...
  ;;   ;; ... ]
  ;; We want normal behavior until we hit one of the end token,
  ;;  but complete the expr by correcting the other end
  ;;  forex.: ... ( ... "# ...
  ;;   where backward found "(", then forward found "\"#", we must go backward again
  ;;
  ;; Strings are free-form too, but you don't know the open/close direction
  ;;  ... " ... ( .... " .... ) ...
  ;;  correction can be heavy/impossible if we guess wrong
  ;;
  ;; Proper exploration of free-forms demand the same special knowledge as syntax coloring
  ;;
  ;; We usually have 2 possible explorations: left or right
  ;; We take inner over outer, and left over right


  (method override (outer-expr self (atomic?: atomic? #f) (explore-whitespace?: explore-whitespace? #t) (uniform-style?: uniform-style? #f))
    (let ((empty? (= start end))
          (prv (previous-char self start 0))
          (nxt (next-char self end 0)))
      (define (reset)
        (set-start self end)
        (set! prv (previous-char self start 0))
        (set! nxt (next-char self end 0)))
      
      (define (unquote-splicing? comma at)
        (and (eqv? comma #\comma) (eqv? at #\at)))
      
      (define (quote? c)
        (memv? c '(#\quote #\comma #\backquote)))
      
      (define (terminal? c)
        (or (not c)
            (whitespace? c)
            (open-composite? self c)
            (close-composite? self c)
            (string-delimiter? c)
            (quote? c)))
      
      (define (homogeneous? str)
        (member? str '("#s8" "#s16" "#s32" "#s64" "#f32"
                       "#u8" "#u16" "#u32" "#u64" "#f64")))
      
      (define (advance-quoting)
        (let (iterate (count 0))
          (define (skip-quoting)
            (forward self)
            (forward-whitespaces self)
            (reset)
            (iterate (+ count 1)))
          
          (cond ((unquote-splicing? nxt (next-char self end 1))
                 (forward self)
                 (skip-quoting))
                ((unquote-splicing? prv nxt)
                 (skip-quoting))
                ((quote? nxt)
                 (skip-quoting))
                ((quote? prv)
                 count)
                (else
                 count))))
      
      (define (advance-literal)
        (outer-constituent)
        (and (eqv? (get-char self start) #\sharp)
             (begin
               (forward-until self terminal?)
               (reset)
               #t)))
      
      (define (outer-style)
        (let ((pos start))
          (let ((string-style 'Text-String)
                (style (get-style-at model pos)))
            (and (inherits? style string-style)
                 (begin
                   (select-style self
                     (lambda (style <Exemplar>)
                       (inherits? style string-style))
                     strict?: #t)
                   #t)))))
      
      (define (outer-literal)
        (define (backward-to-sharp)
          (let ((s (copy start)))
            (backward-until self terminal?)
            (if (eqv? (get-char self start) #\sharp)
                #t
              (set-start self s)
              #f)))
        
        (and (backward-to-sharp)
             (begin
               (forward-until self terminal?)
               (let ((marked (get-marked self)))
                 (cond ((homogeneous? marked)
                        (when (open-composite? self (next-char self end 0))
                          (let ((s (copy start)))
                            (forward-expr self)
                            (set-start self s))))
                       ((equal? marked "#\\")
                        (forward self))
                       ((equal? marked "#")
                        (when (open-composite? self (next-char self end 0))
                          (let ((s (copy start)))
                            (forward-expr self)
                            (set-start self s))))))
               #t)))
      
      (define (outer-constituent)
        (let ((prv-constituent? (and prv (text-constituent? self prv)))
              (nxt-constituent? (and nxt (text-constituent? self nxt))))
          (and (or prv-constituent? nxt-constituent?)
               (begin
                 (when prv-constituent?
                   (backward-constituent self))
                 (when nxt-constituent?
                   (forward-constituent self))
                 #t))))
      
      (define (outer-string)
        (let ((prv-string? (and prv (string-delimiter? prv)))
              (nxt-string? (and nxt (string-delimiter? nxt))))
          (and (or prv-string? nxt-string?)
               (begin
                 (cond ((and prv-string? nxt-string?)
                        (set-start self (previous-pos self start 1))
                        (set-end self (next-pos self end 1)))
                       (else
                        (when prv-string?
                          (backward-expr self))
                        (when nxt-string?
                          (forward-expr self))))
                 #t))))
      
      (define (outer-composite)
        (let ((prv-close-composite? (and prv (close-composite? self prv)))
              (nxt-open-composite? (and nxt (open-composite? self nxt))))
          (and (or prv-close-composite? nxt-open-composite?)
               (begin
                 (if prv-close-composite?
                     (backward-expr self)
                   (forward-expr self))
                 #t))))
      
      (define (prepend-quoting)
        (let ((s <Cell> (copy start)))
          (backward-whitespaces self)
          (backward self)
          (when (unquote-splicing? (previous-char self start 0) (get-char self start))
            (backward self))
          (if (quote? (get-char self start))
              #t
            (set-start self s)
            #f)))
      
      (define (prepend-literal)
        (let ((s <Cell> (copy start)))
          (and (not (terminal? (previous-char self start 0)))
               (begin
                 (backward-until self terminal?)
                 (let ((c (get-char self start)))
                   (if (eqv? c #\sharp)
                       #t
                     (set-start self s)
                     #f))))))
      
      (define (prepend-expr-comment)
        (and (eqv? (previous-char self start 0) #\at)
             (backward self)))
      
      (define (composites-match? start end)
        (or (and (eqv? start #\open-parenthesis) (eqv? end #\close-parenthesis))
            (and (eqv? start #\open-bracket)     (eqv? end #\close-bracket))
            (and (eqv? start #\open-brace)       (eqv? end #\close-brace))))
      
      (or (if empty?
              (let ((quote-count (advance-quoting)))
                (and (or (and uniform-style? (outer-style))
                         (outer-literal)
                         (outer-constituent)
                         (outer-string)
                         (outer-composite))
                     (begin
                       (when (> quote-count 0)
                         (for-each (lambda (n) (prepend-quoting)) (naturals 0 quote-count)))
                       #t)))
            (or (outer-constituent)
                (prepend-literal)
                (and (prepend-quoting)
                     (begin
                       (while (prepend-quoting))
                       #t))
                (prepend-expr-comment)))
          (and explore-whitespace?
               (receive (start-pos start-char) (let ((e (copy end)))
                                                 (backward-all-expr self)
                                                 (set-end self e)
                                                 (values (copy start) (previous-char self start 0)))
                 (when (and start-char (not (open-composite? self start-char)))
                   (explore-error self (format "Found unexpected character while exploring backward: {a}" (present-char self start-char)) (previous-pos self start-pos 1) start-pos))
                 (receive (end-pos end-char) (let ((s (copy start)))
                                               (forward-all-expr self)
                                               (set-start self s)
                                               (values (copy end) (next-char self end 0)))
                   (when (and end-char (not (close-composite? self end-char)))
                     (explore-error self (format "Found unexpected character while exploring forward: {a}" (present-char self end-char)) end-pos (next-pos self end-pos 1)))
                   (when (and start-char end-char (not (composites-match? start-char end-char)))
                     (explore-error self (format "Found mismatched open/close: {a} {a}" (present-char self start-char) (present-char self end-char)) end-pos (next-pos self end-pos 1)))
                   (set-start self start-pos)
                   (set-end self end-pos)
                   (forward self)
                   (backward self)
                   (and start-char end-char)))))))


  (method public (form-expr self)
    (let ((s (copy start))
          (e (copy end)))
      (set-end self start)
      (prog1
          (and (eqv? (next-char self end 0) #\open-parenthesis)
               (begin
                 (enter-list self)
                 (forward-expr self)
                 (and (eq? kind 'symbol)
                      (find-marked-symbol self))))
        (set-start self s)
        (set-end self e))))
  
  
  (method public (form-name self form)
    (and (pair? form)
         (let ((expression-syntax (get-expression-syntax (car form))))
           (and expression-syntax (get-declaration? expression-syntax)
             (if (get-anonymous? expression-syntax)
                 (car form)
               (let ((scan (cdr form))
                     (modifiers (get-modifiers expression-syntax)))
                 (while (and (not-null? scan) (memq? (car scan) modifiers))
                   (set! scan (cdr scan)))
                 (and (not-null? scan)
                      (let ((expr (car scan)))
                        (if (symbol? expr)
                            expr
                          (and (pair? expr)
                               (car expr)))))))))))


  (method public virtual (namespace-expr? self)
    (namespace-name? self (form-expr self)))


  (method public virtual (declaration-expr? self)
    (declaration-name? self (form-expr self)))


  (method public virtual (namespace-name? self name)
    (expression-syntax-namespace? name))


  (method public virtual (declaration-name? self name)
    (expression-syntax-declaration? name))


  (method public virtual (inner-name? self name)
    (expression-syntax-inner? name))


  (method public (declaration-modifiers/name self)
    (let ((s (copy start))
          (e (copy end)))
      (set-end self start)
      (enter-list self)
      (forward-expr self)
      (let* ((decl (find-marked-symbol self))
             (modifiers (forward-modifiers self (expression-syntax-modifiers decl))))
        (cond ((memq? decl '(generic specific))
               (forward-expr self)))
        (forward-whites self)
        (if (eqv? (char-forward self 0) #\open-parenthesis)
            (begin
              (enter-list self)
              (forward-expr self))
          (forward-expr self))
        (prog1 (values modifiers (find-marked-symbol self))
          (set-start self s)
          (set-end self e)))))
  
  
  (method package (declaration-name self)
    (receive (modifiers name) (declaration-modifiers/name self)
      name))
  
  
  (method protected virtual (find-expression-syntax self symbol)
    (get-expression-syntax symbol))


  ;;;
  ;;;; Comments
  ;;;
  
  
  (method public (for-each-comment self proc <procedure> (start-line: start-line #f) (end-line: end-line #f))
    (define (semicolon-literal? string col)
      (and (>= col 2)
           (equal? (substring string (- col 2) (+ col 1)) "#\\;")))
    
    (let* ((previous-line #f)
           (title-comment (title-comment-string syntax))
           (title-comment-size (string-length title-comment))
           (start-line (or start-line 0))
           (end-line (or end-line limit)))
      (for-each (lambda (pos <Cell>)
                  (let ((line (get-line pos))
                        (col (get-col pos)))
                    (when (or (not previous-line) (/= line previous-line))
                      (let ((string (paragraph-string self line))
                            (style (get-style-at model pos))
                            (start pos))
                        (unless (or (semicolon-literal? string col) (inherits? style 'Expr-Comment) (inherits? style 'Named-Comment) (string-style? syntax style))
                          (set! previous-line (get-line pos))
                          (set-end self pos)
                          (paragraph-end self)
                          (proc start end (and (< (+ col title-comment-size) (cast <fx> (cardinality string))) (string=? (subseq string col (+ col title-comment-size)) title-comment))))))))
                (let ((start (new Cell start-line 0))
                      (end (new Cell end-line (paragraph-length self end-line))))
                  (text-search-all model (comment-string syntax) start: start end: end)))))


  ;;;
  ;;;; Declarations
  ;;;
  
  
  (method public virtual (walk-declarations self context <Lisp-Entry+> declaration keyword expression doc)
    (while (walk-declaration self context declaration keyword expression doc)
      ))
  
  
  (method public virtual (walk-declaration self context <Lisp-Entry+> declaration keyword expression doc)
    (cond ((enter-list self)
           (cond ((enter-list self)
                  (walk-expressions self context expression)
                  (exit-list self)
                  (walk-expressions self context expression))
                 ((forward-expr self)
                  (if (eq? kind 'symbol)
                      (let ((symbol (find-marked-symbol self)))
                        (let ((form (find-expression-syntax self symbol)))
                          (walk-named-declaration self context symbol form declaration keyword expression doc)))
                    (walk-expression self context expression 'code #t)
                    (walk-expressions self context expression 'code #f))))
           (exit-list self)
           #t)
          ((forward-expr self)
           (expression context start end 'code kind)
           #t)
          (else
           #f)))
  
  
  (method protected virtual (walk-named-declaration self context <Lisp-Entry+> symbol form declaration keyword expression doc)
    (let ((walk (and form (get-walk form))))
      (if (procedure? walk)
          (walk self context symbol form declaration keyword expression doc)
        (let ((proc-walk (find-named-walker self walk)))
          (proc-walk context symbol form declaration keyword expression doc)))))
  
  
  (method protected virtual (find-named-walker self name)
    (if #f @w name ; we don't have a proc because we found a form for another explorer - tofix
        (error "Unknown define-expression walk: {s}" name)
      (~ walk-unknown self)))
  
  
  (method protected (walk-parameters self context <Lisp-Entry+> declaration keyword expression doc)
    (let ((result '()))
      (let (iterate)
        (when (forward-expr self)
          (set! result (cons (get-marked self) result))
          (walk-expression self context expression 'code #f)
          (iterate)))
      (when context
        (set-parameters context (reverse! result)))))
  
  
  (method protected (walk-unknown self context <Lisp-Entry+> symbol form declaration keyword expression doc)
    (walk-expression self context expression 'code #t)
    (walk-expressions self context expression 'code #f)
    context)


  ;;;
  ;;;; Expressions
  ;;;
  
  
  (method public (iterate-expressions self proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expressions self proc mode))
  
  
  (method public (iterate-expression self proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expression self proc mode))
  
  
  (method (for-each-expressions self proc mode)
    (while (forward-expr self)
      (for-each-expression self proc mode)))
  
  
  (method (for-each-expression self proc mode)
    (define Quotation-Forms
      '(quote quasiquote form <form> <markup> external intrinsic))
    
    (define (for-each-forms proc mode)
      (forward-expr self)
      (when kind
        (let ((mode (if (and (eq? kind 'symbol) (memq? (find-marked-symbol self) Quotation-Forms)
                          ;; a patch until the explorer has better code understanding
                          (or (neq? (intern-marked-symbol self) 'form)
                              (eqv? (char-forward self 0) #\newline)))
                        'quotation
                      mode)))
          (for-each-expression self proc mode)
          (for-each-expressions self proc mode))))
    
    (proc mode)
    (when (enter-composite self)
      (cond ((eq? kind 'list)
             (for-each-forms proc mode)
             (exit-list self))
            ((composite-kind? self kind)
             (let ((mode (if (eq? kind 'literal) 'quotation mode)))
               (for-each-expressions self proc mode))
             (exit-composite self))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) 'quotation 'code)))
               (forward-expr self)
               (for-each-expression self proc mode))))))
  
  
  (method public (walk-expressions self context <Lisp-Entry+> expression (mode 'code) (first? #t))
    (let (iterate (first? first?))
      (cond ((enter-list self)
             (walk-expressions self context expression)
             (exit-list self)
             (iterate #f))
            ((forward-expr self)
             (walk-expression self context expression mode first?)
             (iterate #f)))))
  
  
  (method (walk-expression self context <Lisp-Entry+> expression mode first?)
    (expression context start end mode
      (if (specifier-marked? self)
          (if first?
              'tag
            'specifier)
        kind))
    (when (enter-composite self)
      (cond ((composite-kind? self kind)
             (walk-expressions self context expression mode)
             (exit-composite self))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) kind 'code)))
               (forward-expr self)
               (walk-expression self context expression mode #f))))))
  
  
  (method (walk-specifier self context <Lisp-Entry+> expression mode)
    (when context
      (forward-whites self)
      (when (eqv? (char-forward self 0) #\<)
        (forward-expr self)
        (when (specifier-marked? self)
          (set-type context (get-marked self))
          (expression context start end mode 'specifier)))))
  

  ;;;
  ;;;; Constants
  ;;;
  
  
  (method public (constant? self)
    (memq? kind '(number boolean char symbol specifier tag keyword)))
  
  
  (method public (get-constant self)
    (case kind
      ((symbol) (intern-marked-symbol self))
      (else (with-jazz-readtable
              (lambda ()
                (read-string-element (get-marked self)))))))
  

  ;;;
  ;;;; Search
  ;;;
  
  
  ;; PATTERNS
  ;; - ?x    : matches exactly one expression
  ;; - *x    : matches any number of expressions inside a composite expression (todo)
  ;; - num   : matches a number
  ;; - #f    : matches the #f boolean
  ;; - #t    : matches the #t boolean
  ;; - #\x   : matches a character
  ;; - " "   : matches a string
  ;; - sym   : matches a symbol
  ;; - ( )   : matches a list that can contain patterns (todo)
  ;; - { }   : matches a literal that can contain patterns (todo)
  ;; - 'expr : matches expr only if within quoted text
  
  ;; VARIABLES
  ;; - Generalized variable syntax is ?name:kind
  ;; - The name is optional (not used at the moment)
  ;; - The kind is optional and can be : number boolean char string delimited-string named-string symbol specifier tag keyword expr-comment named-comment list reference literal
  
  ;; REPLACEMENT
  ;; - A good approach I think would be to generalize the backquote construct to non-code generation
  ;;   where the pattern variable names would be used to generate something like a template expander...
  
  ;; TODO
  ;; - For other tools like the highlighting done by edit-reference, it would be really nice to have an option
  ;;   for search-expressions to search a range and return all found matches
  
  
  (method public (search-expressions self mode search-context <Search-Set> position whole-words? ignore-case?)
    (let ((all (map (lambda (target-string)
                      (let ((target (read-string-element target-string)))
                        (cons target target-string)))
                    (if (pair? search-context)
                        search-context
                      (map get-target (get-contexts search-context))))))
      (continuation-capture
        (lambda (return)
          (iterate-expressions self
            (lambda (mode)
              (for-each (lambda (info)
                          (bind (target . target-string) info
                            (when (and (>= start position) (match? self mode target))
                              (continuation-return return (list (get-range self) target-string)))))
                        all))
            mode: mode)
          #f))))
  
  
  (method (match? self expl-mode target)
    (define (expression-kind expression)
      (cond ((number? expression) 'number)
            ((boolean? expression) 'boolean)
            ((char? expression) 'char)
            ((string? expression) 'string)
            ((symbol? expression) 'symbol)
            (else (unimplemented 'expression-kind))))
    
    (define (parse-expression expression)
      (if (and (pair? expression) (eq? (car expression) 'quote))
          (values 'quotation (cadr expression))
        (values #f expression)))
    
    (define (pattern-variable? expression)
      (and (symbol? expression)
           (eqv? #\? (element (symbol->string expression) 0))))
    
    (define (parse-pattern-variable variable)
      (let ((elements (parse-strings (subseq (symbol->string variable) 1) separator: ":")))
        (bind-optionals ((name "") (kind "") (mode "")) elements
          (values (if (empty-string? name) #f (string->symbol name))
                  (if (empty-string? kind) #f (string->symbol kind))
                  (if (empty-string? mode) #f (string->symbol mode))))))
    
    (receive (mode expression) (parse-expression target)
      (let ((expl-kind (get-kind self)))
        (if (pattern-variable? expression)
            (receive (name kind) (parse-pattern-variable expression)
              (and (or (not mode) (eq? mode expl-mode))
                   (or (not kind) (eq? kind expl-kind))))
          (let ((kind (expression-kind expression)))
            (and (or (not mode) (eq? mode expl-mode))
                 (eq? kind expl-kind)
                 (equal? expression (read-string-element (get-marked self)))))))))
  

  ;;;
  ;;;; Utilities
  ;;;


  (method (open-composite? self char)
    (memv? char Open-Composites))


  (method (close-composite? self char)
    (memv? char Close-Composites))
  
  
  (method (composite-kind? self kind)
    (memq? kind '(list reference literal)))))
