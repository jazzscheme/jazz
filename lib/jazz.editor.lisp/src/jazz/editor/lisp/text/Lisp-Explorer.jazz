;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exploring Lisp Code
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.editor.lisp.text.Lisp-Explorer jazz


(import (jazz.editor.lisp)
        (jazz.library)
        (jazz.ui))


(proclaim (warn optimizations))


;; KINDS
;; - number
;; - boolean
;; - char
;; - sharp
;; - string
;; - delimited-string
;; - named-string
;; - symbol
;; - keyword
;; - expr-comment
;; - named-comment
;; - list
;; - reference
;; - literal


(class Lisp-Explorer extends Code-Explorer
  
  
  ;; simple cache to speed up getting many times
  ;; in a row the comment column for the same row
  (slot find-comment-last-row <fx+> initialize {})
  (slot find-comment-last-col <fx+> initialize {})
  
  
  (constant Composites
    '((#\open-parenthesis #\close-parenthesis list)
      (#\open-bracket     #\close-bracket     reference)
      (#\open-brace       #\close-brace       literal)))
  
  
  (constant Open-Composites
    '(#\open-parenthesis
      #\open-bracket
      #\open-brace))
  
  
  (constant Close-Composites
    '(#\close-parenthesis
      #\close-bracket
      #\close-brace))
  
  
  (method (explore-error message start end)
    (let ((source (get-moniker~ text))
          (start (either start (text-beginning~ text)))
          (end (either end (text-ending~ text))))
      (signal (new Explore-Error source start: start end: end message: message))))
  
  
  (method (present-char c)
    (cond ((not c)
           "EOF")
          ((memv? c '(#\space #\tab #\return #\linefeed))
           (char-symbol c))
          (else
           (string c))))
  
  
  (method public (current-expr)
    (when (and (backward-expr) (eq? kind 'symbol))
      (get-marked)))

  
  (method override (forward-expr)
    (define (forward-quotes)
      (let ((c (char-forward 0)))
        (when (memv? c '(#\quote #\backquote #\comma))
          (when (and (eqv? c #\comma) (eqv? (char-forward 1) #\at))
            (forward))
          (forward)
          (forward-whites)
          #t)))
    
    (forward-whites)
    (set-start end)
    (let ((s (get-start)))
      (while (forward-quotes))
      (prog1 (forward-simple-expr)
        (set-start s))))

  
  (method override (backward-expr)
    (define (backward-quote)
      (let ((c (char-backward 0)))
        (cond ((memv? c '(#\quote #\backquote #\comma #\at))
               (backward)
               #t)
              ((and (eqv? (char-backward 1) #\comma) (eqv? c #\at))
               (backward)
               (backward)
               #t)
              (else
               #f))))
    
    (backward-whites)
    (set-end start)
    (let ((c0 (char-backward 0))
          (c1 (char-backward 1)))
      (if (and (eqv? c0 #\sharp) (eqv? c1 #\vertical-bar))
          (backward-delimited-string)
        (if (and (eqv? c1 #\backslash) (eqv? (char-backward 2) #\sharp))
            (backward-scheme-char)
          (let ((found (backward-simple-expr)))
            (when found
              (while (backward-quote))
              (if (and (eq? (get-syntax) 'jazz) (eqv? (get-char start) #\at))
                  'name-comment
                found)))))))


  (method private (forward-simple-expr)
    (let ((c (char-forward 0)))
      (when c
        (cond ((eqv? c #\sharp)            (forward-sharp))
              ((string-delimiter? c)       (forward-string))
              ((eqv? c #\backslash)        (forward-backslahed-symbol))
              ((eqv? c #\vertical-bar)     (forward-escaped-symbol))
              ((text-constituent? c)       (forward-constituent))
              ((eqv? c #\at)               (forward-named-comment))
              ((eqv? c #\open-parenthesis) (forward-composite 'list      #\close-parenthesis))
              ((eqv? c #\open-bracket)     (forward-composite 'reference #\close-bracket))
              ((eqv? c #\open-brace)       (forward-composite 'literal   #\close-brace))
              (else #f)))))

  
  (method private (backward-simple-expr)
    (let ((c (char-backward 0)))
      (when c
        (cond ((string-delimiter? c)        (backward-string))
              ((eqv? c #\vertical-bar)      (backward-escaped-symbol))
              ((text-constituent? c)        (backward-constituent))
              ((eqv? c #\close-parenthesis) (backward-composite 'list      #\open-parenthesis))
              ((eqv? c #\close-bracket)     (backward-composite 'reference #\open-bracket))
              ((eqv? c #\close-brace)       (backward-composite 'literal   #\open-brace))
              (else #f)))))

  
  (method public (forward-all-expr)
    (let ((initial-end (copy end)))
      (while (forward-expr)
        )
      (set! start initial-end)))

  
  (method public (backward-all-expr)
    (let ((initial-start (copy start)))
      (while (backward-expr)
        )
      (set! end initial-start)))

  
  (method (forward-constituent)
    (let ((keyword? (eqv? (char-forward 0) #\colon))
          (last {}))
      (let (iterate)
        (let ((c (char-forward 0)))
          (cond ((eqv? c #\backslash)
                 (forward)
                 (forward)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? c)))
                 (set! kind (if (or keyword? (and last (eqv? last #\colon))) 'keyword 'symbol))
                 kind)
                (else
                 (forward)
                 (set! last c)
                 (iterate)))))))

  
  (method private (backward-constituent)
    (let ((keyword? (eqv? (char-backward 0) #\colon))
          (last (unspecified)))
      (let (iterate)
        (let ((c (char-backward 0)))
          (cond ((eqv? (char-backward 1) #\backslash)
                 (backward)
                 (backward)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? c)))
                 (set! kind (if (or keyword? (eqv? last #\colon)) 'keyword 'symbol))
                 kind)
                (else
                 (backward)
                 (set! last c)
                 (iterate)))))))
  
  
  (method private (backward-escaped-symbol)
    (backward)
    (let (iterate)
      (let ((c (char-backward 0)))
        (if (not c)
            #f
          (cond ((eqv? (char-backward 1) #\backslash)
                 (backward)
                 (backward)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (backward)
                 (set! kind 'symbol)
                 kind)
                (else
                 (backward)
                 (iterate)))))))
  
  
  (method private (backward-scheme-char)
    (backward)
    (backward)
    (backward)
    (set! kind 'char)
    kind)
  
  
  (method private (forward-expr-comment)
    (forward)
    (forward-expr)
    (set! kind 'expr-comment)
    kind)
  
  
  (method private (forward-named-comment)
    (if (neq? (get-syntax) 'jazz)
        (forward-constituent)
      (forward)
      (forward-expr)
      (set! kind 'named-comment)
      kind))
  
  
  (method private (forward-sharp)
    (forward)
    (let ((c0 (char-forward 0))
          (c1 (char-forward 1)))
      (cond ((and (memq? c0 '(#\t #\f)) (or (not c1) (not (text-constituent? c1))))
             (forward)
             (set! kind 'boolean)
             kind)
            ((eqv? c0 #\double-quote)
             (forward-delimited-string))
            ((and (eqv? c0 #\<) (eqv? (char-forward 1) #\<))
             (forward-named-string))
            ((eqv? c0 #\backslash)
             (forward-scheme-char))
            ((eqv? c0 #\semi-colon)
             (forward-expr-comment))
            (else
             (forward-constituent)))))
  
  
  (method private (forward-backslahed-symbol)
    (forward)
    (forward)
    (forward-constituent))
  
  
  (method private (forward-escaped-symbol)
    (forward)
    (let (iterate)
      (let ((c (char-forward 0)))
        (if (not c)
            #f
          (cond ((eqv? c #\backslash)
                 (forward)
                 (forward)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (forward)
                 (set! kind 'symbol)
                 kind)
                (else
                 (forward)
                 (iterate)))))))
  
  
  (method private (forward-delimited-string)
    (forward)
    (let (iterate)
      (let ((c0 (char-forward 0))
            (c1 (char-forward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\double-quote) (eqv? c1 #\sharp))
               (forward)
               (forward)
               (set! kind 'delimited-string)
               kind)
              (else
               (forward)
               (iterate))))))
  
  
  (method private (forward-named-string)
    (forward)
    (forward)
    (continuation-capture
      (function (return)
        (let ((name (subseq (paragraph-string (get-row~ end)) (get-col~ end))))
          (set-end (new Cell (+ (get-row~ end) 1) 0))
          (while (< (get-row~ end) limit)
            (if (nu=? (subseq (paragraph-string (get-row~ end)) (get-col~ end)) name)
                (begin
                  (set-end (new Cell (+ (get-row~ end) 1) 0))
                  (continuation-return return 'named-string))
              (set-end (new Cell (+ (get-row~ end) 1) 0)))))
        #f)))

  
  (method private (forward-scheme-char)
    (forward)
    (let ((c (char-forward 0)))
      (if (not (alphanumeric? c))
          (begin
            (forward)
            (set! kind 'char)
            kind)
        (let (iterate)
          (let ((c (char-forward 0)))
            (cond ((not c)
                   #f)
                  ((not (text-constituent? c))
                   (set! kind 'char)
                   kind)
                  (else
                   (forward)
                   (iterate))))))))
  
  
  (method private (forward-string)
    (forward)
    (let (iterate)
      (call-line-hook)
      (let ((c (char-forward 0)))
        (cond ((not c)
               #f)
              ((eqv? c #\backslash)
               (forward)
               (forward)
               (iterate))
              ((string-delimiter? c)
               (forward)
               (set! kind 'string)
               kind)
              (else
               (forward)
               (iterate))))))
  
  
  (method private (backward-delimited-string)
    (backward)
    (backward)
    (let (iterate)
      (let ((c0 (char-backward 0))
            (c1 (char-backward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\vertical-bar) (eqv? c1 #\sharp))
               (backward)
               (backward)
               (set! kind 'delimited-string)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method private (backward-string)
    (backward)
    (let (iterate)
      (let ((c (char-backward 0)))
        (cond ((not c)
               #f)
              ((eqv? (char-backward 1) #\backslash)
               (backward)
               (backward)
               (iterate))
              ((string-delimiter? c)
               (backward)
               (set! kind 'string)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method private (forward-composite knd <Object> delimiter)
    (set-start end)
    (forward)
    (forward-all-expr)
    (forward-whites)
    (let ((c (char-forward 0)))
      (if (not (eqv? c delimiter))
          (explore-error (format "Found unexpected character while exploring forward: {a}" (present-char c)) end (next-pos end 1))
        (forward)
        (set! kind knd)
        kind)))
  
  
  (method private (backward-composite knd <Object> delimiter)
    (let ((initial-start (copy start)))
      (backward)
      (backward-all-expr)
      (backward-whites)
      (let ((c (char-backward 0)))
        (if (not (eqv? c delimiter))
            (explore-error (format "Found unexpected character while exploring backward: {a}" (present-char c)) (previous-pos start 1) start)
          (backward)
          (set! end initial-start)
          (set! kind knd)
          kind))))

  
  (method public (enter-list)
    (forward-whites)
    (when (eqv? (char-forward 0) #\open-parenthesis)
      (forward)
      #t))
  
  
  (method public (exit-list)
    (forward-all-expr)
    (forward-whites)
    (when (eqv? (char-forward 0) #\close-parenthesis)
      (forward)
      #t))
  
  
  (method public (enter-composite)
    (let ((end (get-end)))
      (set-end (get-start))
      (forward-whites)
      (let ((c0 (char-forward 0)))
        (cond ((and (eqv? c0 #\comma) (eqv? (char-forward 1) #\at))
               (forward)
               (forward)
               (set! kind 'unquote-splicing)
               #t)
              ((eqv? c0 #\comma)
               (forward)
               (set! kind 'unquote)
               #t)
              ((eqv? c0 #\quote)
               (forward)
               (set! kind 'quote)
               #t)
              ((eqv? c0 #\backquote)
               (forward)
               (set! kind 'quasiquote)
               #t)
              ((eqv? c0 #\open-parenthesis)
               (forward)
               (set! kind 'list)
               #t)
              ((eqv? c0 #\open-bracket)
               (forward)
               (set! kind 'reference)
               #t)
              ((eqv? c0 #\open-brace)
               (forward)
               (set! kind 'literal)
               #t)
              (else
               (set-end end)
               #f)))))
  
  
  (method public (exit-composite)
    (forward-all-expr)
    (forward-whites)
    (when (memv? (char-forward 0) Close-Composites)
      (forward)
      #t))
  
  
  (method public (skip-forward name <string>)
    (and (forward-expr) (= (get-marked) name)))
  
  
  (method public (skip-backward name <string>)
    (and (backward-expr) (= (get-marked) name)))
  
  
  (method public (forward-modifiers modifiers)
    (let ((old (copy end))
          (symbol {})
          (result '()))
      (let (iterate)
        (when (and (forward-expr) (eq? kind 'symbol))
           (set! symbol (find-marked-symbol))
           (when (memq? symbol modifiers)
             (set! old (copy end))
             (set! result (cons symbol result))
             (iterate))))
      (set! end old)
      (reverse! result)))
  
  
  (method (forward-comments)
    (next-paragraph))
  
  
  (method (backward-comments)
    )

  
  (method public (forward-whites) <void>
    (let (iterate)
      (let ((c (char-forward 0)))
        (when c
          (if (whitespace? c)
              (when (forward)
                (iterate))
            (case c
              ((#\semi-colon)
               (forward-comments)
               (iterate)))))))
    (call-line-hook))

  
  (method public (backward-whites) <void>
    (let (iterate)
      (let (iterate)
        (let ((c (char-backward 0)))
          (when (and c (whitespace? c) (backward))
            (iterate))))
      (when (backward-lisp-comment)
        (iterate))))

  
  (method (backward-lisp-comment) <bool>
    (let ((start-row (get-row~ start))
          (start-col (get-col~ start)))
      (let ((col (if (eqv? start-row find-comment-last-row)
                     find-comment-last-col
                   (let ((col (find-lisp-comment start-row)))
                     (set! find-comment-last-row start-row)
                     (set! find-comment-last-col col)
                     col))))
        (when (and col (< col start-col))
          (set-col~ start col)
          #t))))
  
  
  (method (find-lisp-comment row <fx>) <fx+>
    (let ((max-col (paragraph-length row))
          (preserved-end (copy end))
          (result #f))
      (set-end (new Cell row 0))
      (let ((result
              (let (iterate)
                (when (and (= (get-row~ end) row) (< (get-col~ end) max-col))
                  (let ((c0 (char-forward 0)))
                    (cond ((eqv? c0 #\double-quote)
                           (forward-string)
                           (iterate))
                          ((eqv? c0 #\sharp)
                           (let ((c1 (char-forward 1)))
                             (cond ((eqv? c1 #\vertical-bar)
                                    (forward)
                                    (forward-delimited-string)
                                    (iterate))
                                   ((eqv? c1 #\backslash)
                                    (forward)
                                    (forward-scheme-char)
                                    (iterate))
                                   (else
                                    (forward)
                                    (iterate)))))
                          ((eqv? c0 #\semi-colon)
                           (get-col~ end))
                          (else
                           (forward)
                           (iterate))))))))
        (set-end preserved-end)
        result)))


  ;;;
  ;;;; Level
  ;;;
  
  
  ;; == explorer problem:
  ;; many exploration modes are free-form (_ = terminal/white-space)
  ;; - _/* ... */_
  ;; - _#" ... "#_
  ;; - multiline commented code like:
  ;;   ;; [ ...
  ;;   ;; ... ]
  ;; We want normal behavior until we hit one of the end token,
  ;;  but complete the expr by correcting the other end
  ;;  forex.: ... ( ... "# ...
  ;;   where backward found "(", then forward found "\"#", we must go backward again
  ;;
  ;; Strings are free-form too, but you don't know the open/close direction
  ;;  ... " ... ( .... " .... ) ...
  ;;  correction can be heavy/impossible if we guess wrong
  ;;
  ;; Proper exploration of free-forms demand the same special knowledge as syntax coloring
  ;;
  ;; We usually have 2 possible explorations: left or right
  ;; We take inner over outer, and left over right


  (method override (outer-expr (atomic?: atomic? #f) (explore-whitespace?: explore-whitespace? #t))
    (let ((empty? (= start end))
          (prv (previous-char start 0))
          (nxt (next-char end 0)))
      (define (reset)
        (set-start end)
        (set! prv (previous-char start 0))
        (set! nxt (next-char end 0)))
      
      (define (unquote-splicing? comma at)
        (and (eqv? comma #\comma) (eqv? at #\at)))
      
      (define (quote? c)
        (memv? c '(#\quote #\comma #\backquote)))
      
      (define (terminal? c)
        (or (whitespace? c)
            (open-composite? c)
            (close-composite? c)
            (string-delimiter? c)
            (quote? c)))
      
      (define (homogeneous? str)
        (member? str '("#s8" "#s16" "#s32" "#s64" "#f32"
                       "#u8" "#u16" "#u32" "#u64" "#f64")))
      
      (define (advance-quoting)
        (let (iterate (count 0))
          (define (skip-quoting)
            (forward)
            (forward-whitespaces)
            (reset)
            (iterate (+ count 1)))
          
          (cond ((unquote-splicing? nxt (next-char end 1))
                 (forward)
                 (skip-quoting))
                ((unquote-splicing? prv nxt)
                 (skip-quoting))
                ((quote? nxt)
                 (skip-quoting))
                ((quote? prv)
                 count)
                (else
                 count))))
      
      (define (advance-literal)
        (outer-constituent)
        (when (eqv? (get-char start) #\sharp)
          (forward-until terminal?)
          (reset)
          #t))
      
      (define (outer-literal)
        (define (backward-to-sharp)
          (let ((s (copy start)))
            (backward-until terminal?)
            (if (eqv? (get-char start) #\sharp)
                #t
              (set-start s)
              #f)))
        
        (when (backward-to-sharp)
          (forward-until terminal?)
          (let ((marked (get-marked)))
            (cond ((homogeneous? marked)
                   (when (open-composite? (next-char end 0))
                     (let ((s (copy start)))
                       (forward-expr)
                       (set-start s))))
                  ((equal? marked "#\\")
                   (forward))
                  ((equal? marked "#")
                   (when (open-composite? (next-char end 0))
                     (let ((s (copy start)))
                       (forward-expr)
                       (set-start s))))))
          #t))
      
      (define (outer-constituent)
        (let ((prv-constituent? (and prv (text-constituent? prv)))
              (nxt-constituent? (and nxt (text-constituent? nxt))))
          (when (or prv-constituent? nxt-constituent?)
            (when prv-constituent?
              (backward-constituent))
            (when nxt-constituent?
              (forward-constituent))
            #t)))
      
      (define (outer-string)
        (let ((prv-string? (and prv (string-delimiter? prv)))
              (nxt-string? (and nxt (string-delimiter? nxt))))
          (when (or prv-string? nxt-string?)
            (cond ((and prv-string? nxt-string?)
                   (set-start (previous-pos start 1))
                   (set-end (next-pos end 1)))
                  (else
                   (when prv-string?
                     (backward-expr))
                   (when nxt-string?
                     (forward-expr))))
            #t)))
      
      (define (outer-composite)
        (let ((prv-close-composite? (and prv (close-composite? prv)))
              (nxt-open-composite? (and prv (open-composite? nxt))))
          (when (or prv-close-composite? nxt-open-composite?)
            (if prv-close-composite?
                (backward-expr)
              (forward-expr))
            #t)))
      
      (define (prepend-quoting)
        (let ((s <Cell> (copy start)))
          (backward-whitespaces)
          (backward)
          (when (unquote-splicing? (previous-char start 0) (get-char start))
            (backward))
          (if (quote? (get-char start))
              #t
            (set-start s)
            #f)))
      
      (define (prepend-literal)
        (let ((s <Cell> (copy start)))
          (unless (terminal? (previous-char start 0))
            (backward-until terminal?)
            (let ((c (get-char start)))
              (if (eqv? c #\sharp)
                  #t
                (set-start s)
                #f)))))
      
      (define (prepend-expr-comment)
        (when (eqv? (previous-char start 0) #\at)
          (backward)))
      
      (or (if empty?
              (let ((quote-count (advance-quoting)))
                (when (or (outer-literal)
                          (outer-constituent)
                          (outer-string)
                          (outer-composite))
                  (when (> quote-count 0)
                    (for-each (function (n) (prepend-quoting)) (naturals 0 quote-count)))
                  #t))
            (or (outer-constituent)
                (prepend-literal)
                (when (prepend-quoting)
                  (while (prepend-quoting))
                  #t)
                (prepend-expr-comment)))
          (when explore-whitespace?
            (receive (start-pos start-char) (let ((e (copy end)))
                                              (backward-all-expr)
                                              (set-end e)
                                              (values (copy start) (previous-char start 0)))
              (when (and start-char (not (open-composite? start-char)))
                (explore-error (format "Found unexpected character while exploring backward: {a}" (present-char start-char)) (previous-pos start-pos 1) start-pos))
              (receive (end-pos end-char) (let ((s (copy start)))
                                            (forward-all-expr)
                                            (set-start s)
                                            (values (copy end) (next-char end 0)))
                (when (and end-char (not (close-composite? end-char)))
                  (explore-error (format "Found unexpected character while exploring forward: {a}" (present-char end-char)) end-pos (next-pos end-pos 1)))
                (when (and start-char end-char (not (composites-match? start-char end-char)))
                  (explore-error (format "Found mismatched open/close: {a} {a}" (present-char start-char) (present-char end-char)) end-pos (next-pos end-pos 1)))
                (set-start start-pos)
                (set-end end-pos)
                (forward)
                (backward)
                (and start-char end-char)))))))


  (method public (form-expr)
    (let ((s (copy start))
          (e (copy end)))
      (set-end start)
      (prog1
          (when (eqv? (next-char end 0) #\open-parenthesis)
            (enter-list)
            (forward-expr)
            (when (eq? kind 'symbol)
              (find-marked-symbol)))
        (set-start s)
        (set-end e))))
  
  
  (method public (form-name form)
    (when (pair? form)
      (let ((lisp-form (get-lisp-form (car form))))
        (when (and lisp-form (get-declaration?~ lisp-form))
          (let ((scan (cdr form))
                (modifiers (get-modifiers~ lisp-form)))
            (while (and (not-null? scan) (memq? (car scan) modifiers))
              (set! scan (cdr scan)))
            (when (not-null? scan)
              (let ((expr (car scan)))
                (if (symbol? expr)
                    expr
                  (when (pair? expr)
                    (car expr))))))))))


  (method public virtual (namespace-expr?)
    (namespace-name? (form-expr)))


  (method public virtual (declaration-expr?)
    (declaration-name? (form-expr)))


  (method public virtual (namespace-name? name)
    (lisp-form-namespace? name))


  (method public virtual (declaration-name? name)
    (lisp-form-declaration? name))


  (method public virtual (inner-name? name)
    (lisp-form-inner? name))


  (method public (declaration-name)
    (let ((s (copy start))
          (e (copy end)))
      (set-end start)
      (enter-list)
      (forward-expr)
      (let* ((decl (find-marked-symbol))
             (modifiers (lisp-form-modifiers decl)))
        (cond ((memq? decl '(generic specific))
               (forward-expr)))
        (forward-whites)
        (if (eqv? (char-forward 0) #\open-parenthesis)
            (begin
              (enter-list)
              (forward-expr))
          (forward-expr))
        (prog1 (values modifiers (find-marked-symbol))
          (set-start s)
          (set-end e)))))
  
  
  (method (declaration-only-name)
    (receive (modifiers name) (declaration-name)
      name))


  ;;;
  ;;;; Comments
  ;;;
  
  
  (method public (for-each-comment proc <procedure>)
    (let* ((previous-row {})
           (title-comment (title-comment-string~ (get-syntax~ text)))
           (title-comment-size (string-length title-comment)))
      (for-each (function (pos <Cell>)
                  (let ((row (get-row~ pos))
                        (col (get-col~ pos)))
                    (when (or (not previous-row) (/= row previous-row))
                      (let ((string (paragraph-string row))
                            (style (get-style-at~ text pos))
                            (start pos))
                        (unless (or (memq? (get-name~ style) '(Expr-Comment Named-Comment)) (string-style?~ text style))
                          (set! previous-row (get-row~ pos))
                          (set-end pos)
                          (paragraph-end)
                          (proc start end (and (< (+ col title-comment-size) (cast <fx> (cardinality string))) (string=? (subseq string col (+ col title-comment-size)) title-comment))))))))
                (text-search-all~ text (comment-string~ (get-syntax~ text))))))


  ;;;
  ;;;; Declarations
  ;;;
  
  
  (method public virtual (walk-declarations context declaration keyword expression doc)
    (while (walk-declaration context declaration keyword expression doc)
      ))
  
  
  (method public virtual (walk-declaration context declaration keyword expression doc)
    (let ((list? (enter-list)))
      (if (not list?)
          (when (forward-expr)
            (expression context start end 'code kind)
            #t)
        (when (and (forward-expr) (eq? kind 'symbol))
          (let ((symbol (find-marked-symbol)))
            (let ((form (get-lisp-form symbol)))
              (walk-named-declaration context symbol form declaration keyword expression doc))))
        (exit-list)
        #t)))
  
  
  (method protected virtual (walk-named-declaration context symbol form declaration keyword expression doc)
    (let ((walk (essay form (get-walk~ form))))
      (if (procedure? walk)
          (walk self context symbol form declaration keyword expression doc)
        (let ((proc-walk (find-named-walker walk)))
          (proc-walk context symbol form declaration keyword expression doc)))))
  
  
  (method protected virtual (find-named-walker name)
    (if #f @w name ; we don't have a proc because we found a form for another explorer - tofix
        (error "Unknown define-form walk: {s}" name)
      walk-unknown))
  
  
  (method protected (walk-parameters context declaration keyword expression doc)
    (let (iterate)
      (when (forward-expr)
        (walk-expression context expression 'code #f)
        (iterate))))
  
  
  (method protected (walk-unknown context symbol form declaration keyword expression doc)
    (walk-expression context expression 'code #t)
    (walk-expressions context expression)
    context)


  ;;;
  ;;;; Expressions
  ;;;
  
  
  (method public (iterate-expressions proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expressions proc mode))
  
  
  (method public (iterate-expression proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expression proc mode))
  
  
  (method (for-each-expressions proc mode)
    (while (forward-expr)
      (for-each-expression proc mode)))
  
  
  (method (for-each-expression proc mode)
    (proc mode)
    (when (enter-composite)
      (cond ((eq? kind 'list)
             (for-each-forms proc mode)
             (exit-list))
            ((composite-kind? kind)
             (let ((mode (if (eq? kind 'literal) 'quotation mode)))
               (for-each-expressions proc mode))
             (exit-composite))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) 'quotation 'code)))
               (forward-expr)
               (for-each-expression proc mode))))))
  
  
  (definition Quotation-Forms
    '(quote quasiquote form form>> jml>> external intrinsic))
  
  
  (method (for-each-forms proc mode)
    (forward-expr)
    (when kind
      (let ((mode (if (and (eq? kind 'symbol) (memq? (find-marked-symbol) Quotation-Forms)
                           ;; a patch until the explorer has better code understanding
                           (or (neq? (intern-marked-symbol) 'form)
                               (eqv? (char-forward 0) #\newline)))
                      'quotation
                    mode)))
        (for-each-expression proc mode)
        (for-each-expressions proc mode))))
  
  
  (method public (walk-expressions context expression (mode 'code) (first? #t))
    (while (forward-expr)
      (walk-expression context expression mode first?)
      (set! first? #f)))
  
  
  (method (walk-expression context expression mode first?)
    (define (specifier-marked?)
      (and (eq? kind 'symbol)
           (eqv? (get-char start) #\<)
           (eqv? (get-char (- end 1)) #\>)))
    
    (expression context start end mode
      (if (and (eq? kind 'symbol) (specifier-marked?))
          (if first?
              'tag
            'specifier)
        kind))
    (when (enter-composite)
      (cond ((composite-kind? kind)
             (walk-expressions context expression mode)
             (exit-composite))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) kind 'code)))
               (forward-expr)
               (walk-expression context expression mode #f))))))
  

  ;;;
  ;;;; Constants
  ;;;
  
  
  (method public (constant?)
    (memq? kind '(number boolean char symbol keyword)))
  
  
  (method public (get-constant)
    (case kind
      ((symbol) (intern-marked-symbol))
      (else (with-jazz-readtable
              (function ()
                (read-string-element (get-marked)))))))
  

  ;;;
  ;;;; Search
  ;;;
  
  
  ;; PATTERNS
  ;; - ?x    : matches exactly one expression
  ;; - *x    : matches any number of expressions inside a composite expression (todo)
  ;; - num   : matches a number
  ;; - #f    : matches the #f boolean
  ;; - #t    : matches the #t boolean
  ;; - #\x   : matches a character
  ;; - " "   : matches a string
  ;; - sym   : matches a symbol
  ;; - ( )   : matches a list that can contain patterns (todo)
  ;; - { }   : matches a literal that can contain patterns (todo)
  ;; - 'expr : matches expr only if within quoted text
  
  ;; VARIABLES
  ;; - Generalized variable syntax is ?name:kind
  ;; - The name is optional (not used at the moment)
  ;; - The kind is optional and can be : number boolean char string delimited-string named-string symbol keyword expr-comment named-comment list reference literal
  
  ;; REPLACEMENT
  ;; - A good approach I think would be to generalize the backquote construct to non-code generation
  ;;   where the pattern variable names would be used to generate something like a template expander...
  
  ;; TODO
  ;; - For other tools like the highlighting done by edit-reference, it would be really nice to have an option
  ;;   for search-expressions to search a range and return all found matches
  
  
  (method public (search-expressions mode search-context position whole-words? ignore-case?)
    (let ((all (map (function (target-string)
                      (let ((target (read-string-element target-string)))
                        (cons target target-string)))
                    (if (pair? search-context)
                        search-context
                      (map get-target~ (get-contexts~ search-context))))))
      (continuation-capture
        (function (return)
          (iterate-expressions
            (function (mode)
              (for-each (function (info)
                          (bind (target . target-string) info
                            (when (and (>= start position) (match? mode target))
                              (continuation-return return (list (get-range) target-string)))))
                        all))
            mode: mode)
          {}))))
  
  
  (method (match? expl-mode target)
    (receive (mode expression) (parse-expression target)
      (let ((expl-kind (get-kind)))
        (if (pattern-variable? expression)
            (receive (name kind) (parse-pattern-variable expression)
              (and (or (not mode) (eq? mode expl-mode))
                   (or (not kind) (eq? kind expl-kind))))
          (let ((kind (expression-kind expression)))
            (and (or (not mode) (eq? mode expl-mode))
                 (eq? kind expl-kind)
                 (equal? expression (read-string-element (get-marked)))))))))
  
  
  (method (expression-kind expression)
    (cond ((number? expression) 'number)
          ((boolean? expression) 'boolean)
          ((char? expression) 'char)
          ((string? expression) 'string)
          ((symbol? expression) 'symbol)
          (else (unimplemented 'expression-kind))))
  
  
  (method (parse-expression expression)
    (if (and (pair? expression) (eq? (car expression) 'quote))
        (values 'quotation (cadr expression))
      (values {} expression)))
  
  
  (method (pattern-variable? expression)
    (and (symbol? expression)
         (eqv? #\? (element (symbol->string expression) 0))))
  
  
  (method (parse-pattern-variable variable)
    (let ((elements (parse-strings (subseq (symbol->string variable) 1) separator: ":")))
      (bind-optionals ((name "") (kind "") (mode "")) elements
        (values (if (empty-string? name) {} (string->symbol name))
                (if (empty-string? kind) {} (string->symbol kind))
                (if (empty-string? mode) {} (string->symbol mode))))))
  

  ;;;
  ;;;; Utilities
  ;;;


  (method (open-composite? char)
    (memv? char Open-Composites))


  (method (close-composite? char)
    (memv? char Close-Composites))
  
  
  (method (composite-kind? kind)
    (memq? kind '(list reference literal)))


  (method (composites-match? start end)
    (or (and (eqv? start #\open-parenthesis) (eqv? end #\close-parenthesis))
        (and (eqv? start #\open-bracket)     (eqv? end #\close-bracket))
        (and (eqv? start #\open-brace)       (eqv? end #\close-brace))))))
