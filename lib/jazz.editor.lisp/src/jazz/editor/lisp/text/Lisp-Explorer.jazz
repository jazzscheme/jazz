;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exploring Lisp Code
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.lisp.text.Lisp-Explorer jazz


(import (jazz.editor.jazz)
        (jazz.editor.lisp)
        (jazz.library)
        (jazz.ui))


(proclaim (warn optimizations))


;; KINDS
;; - number
;; - boolean
;; - char
;; - sharp
;; - string
;; - delimited-string
;; - named-string
;; - symbol
;; - keyword
;; - expr-comment
;; - named-comment
;; - list
;; - reference
;; - literal


(class Lisp-Explorer extends Code-Explorer
  
  
  ;; simple cache to speed up getting many times
  ;; in a row the comment column for the same row
  (slot find-comment-last-row <fx+> initialize #f)
  (slot find-comment-last-col <fx+> initialize #f)
  
  
  (constant Composites
    '((#\open-parenthesis #\close-parenthesis list)
      (#\open-bracket     #\close-bracket     reference)
      (#\open-brace       #\close-brace       literal)))
  
  
  (constant Open-Composites
    '(#\open-parenthesis
      #\open-bracket
      #\open-brace))
  
  
  (constant Close-Composites
    '(#\close-parenthesis
      #\close-bracket
      #\close-brace))
  
  
  (method (explore-error message start end)
    (let ((source #f @mvc (get-moniker~ model))
          (start (or start (text-beginning~ model)))
          (end (or end (text-ending~ model))))
      (signal (new Explore-Error source start: start end: end message: message))))
  
  
  (method (present-char c)
    (cond ((not c)
           "EOF")
          ((memv? c '(#\space #\tab #\return #\linefeed))
           (char-symbol c))
          (else
           (string c))))
  
  
  (method public (current-expr)
    (when (and (backward-expr) (eq? kind 'symbol))
      (get-marked)))

  
  (method override (forward-expr)
    (define (forward-quotes)
      (let ((c (char-forward 0)))
        (when (memv? c '(#\quote #\backquote #\comma))
          (when (and (eqv? c #\comma) (eqv? (char-forward 1) #\at))
            (forward))
          (forward)
          (forward-whites)
          #t)))
    
    (forward-whites)
    (set-start end)
    (let ((s (get-start)))
      (while (forward-quotes))
      (prog1 (forward-simple-expr)
        (set-start s))))

  
  (method override (backward-expr)
    (define (backward-quote)
      (let ((c (char-backward 0)))
        (cond ((memv? c '(#\quote #\backquote #\comma #\at))
               (backward)
               #t)
              ((and (eqv? (char-backward 1) #\comma) (eqv? c #\at))
               (backward)
               (backward)
               #t)
              (else
               #f))))
    
    (backward-whites)
    (set-end start)
    (let ((c0 (char-backward 0))
          (c1 (char-backward 1))
          (c2 (char-backward 2)))
      (cond ((and (eqv? c0 #\sharp) (eqv? c1 #\double-quote))
             (backward-delimited-string))
            ((and (eqv? c0 #\sharp) (eqv? c1 #\slash) (eqv? c2 #\slash))
             (backward-syntax-string))
            ((and (eqv? c0 #\sharp) (eqv? c1 #\vertical-bar))
             (backward-multiline-comment))
            ((and (eqv? c1 #\backslash) (eqv? (char-backward 2) #\sharp))
             (backward-scheme-char))
            (else
             (let ((found (backward-simple-expr)))
               (when found
                 (while (backward-quote))
                 (if (and (is? (get-syntax) Jazz-Syntax) (eqv? (get-char start) #\at))
                     'name-comment
                   found)))))))


  (method protected (forward-simple-expr)
    (let ((c (char-forward 0)))
      (when c
        (cond ((eqv? c #\sharp)            (forward-sharp))
              ((string-delimiter? c)       (forward-string))
              ((eqv? c #\backslash)        (forward-backslahed-symbol))
              ((eqv? c #\vertical-bar)     (forward-escaped-symbol))
              ((text-constituent? c)       (forward-constituent))
              ((eqv? c #\at)               (forward-named-comment))
              ((eqv? c #\open-parenthesis) (forward-composite 'list      #\close-parenthesis))
              ((eqv? c #\open-bracket)     (forward-composite 'reference #\close-bracket))
              ((eqv? c #\open-brace)       (forward-composite 'literal   #\close-brace))
              (else #f)))))

  
  (method protected (backward-simple-expr)
    (define (space-literal? c)
      (and (eqv? (char-forward 0) #\space)
           (eqv? (char-backward 0) #\backslash)
           (eqv? (char-backward 1) #\sharp)))
    
    (let ((c (char-backward 0)))
      (when c
        (cond ((string-delimiter? c)        (backward-string))
              ((eqv? c #\vertical-bar)      (backward-escaped-symbol))
              ((text-constituent? c)        (backward-constituent))
              ((space-literal? c)           (backward) (backward))
              ((eqv? c #\close-parenthesis) (backward-composite 'list      #\open-parenthesis))
              ((eqv? c #\close-bracket)     (backward-composite 'reference #\open-bracket))
              ((eqv? c #\close-brace)       (backward-composite 'literal   #\open-brace))
              ((eqv? c #\open-parenthesis)  #f)
              ((eqv? c #\open-bracket)      #f)
              ((eqv? c #\open-brace)        #f)
              (else (backward))))))

  
  (method public (forward-all-expr)
    (let ((initial-end (copy end)))
      (while (forward-expr)
        )
      (set! start initial-end)))

  
  (method public (backward-all-expr)
    (let ((initial-start (copy start)))
      (while (backward-expr)
        )
      (set! end initial-start)))

  
  (method override (forward-constituent)
    (let ((keyword? (eqv? (char-forward 0) #\colon))
          (last #f))
      (let (iterate)
        (let ((c (char-forward 0)))
          (cond ((eqv? c #\backslash)
                 (forward)
                 (forward)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? c)))
                 (set! kind (if (or keyword? (and last (eqv? last #\colon))) 'keyword 'symbol))
                 kind)
                (else
                 (forward)
                 (set! last c)
                 (iterate)))))))

  
  (method override (backward-constituent)
    (let ((keyword? (eqv? (char-backward 0) #\colon))
          (last #f))
      (let (iterate)
        (let ((c (char-backward 0)))
          (cond ((and (eqv? (char-backward 1) #\backslash)
                      (eqv? (char-backward 2) #\sharp))
                 (backward)
                 (backward)
                 (set! last c)
                 (iterate))
                ((or (not c) (not (text-constituent? c)))
                 (set! kind (if (or keyword? (eqv? last #\colon)) 'keyword 'symbol))
                 kind)
                (else
                 (backward)
                 (set! last c)
                 (iterate)))))))
  
  
  (method protected (backward-escaped-symbol)
    (backward)
    (let (iterate)
      (let ((c (char-backward 0)))
        (if (not c)
            #f
          (cond ((eqv? (char-backward 1) #\backslash)
                 (backward)
                 (backward)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (backward)
                 (set! kind 'symbol)
                 kind)
                (else
                 (backward)
                 (iterate)))))))
  
  
  (method protected (backward-scheme-char)
    (backward)
    (backward)
    (backward)
    (set! kind 'char)
    kind)
  
  
  (method protected (forward-expr-comment)
    (forward)
    (forward-expr)
    (set! kind 'expr-comment)
    kind)
  
  
  (method protected (forward-named-comment)
    (if (is-not? (get-syntax) Jazz-Syntax)
        (forward-constituent)
      (forward)
      (forward-expr)
      (set! kind 'named-comment)
      kind))
  
  
  ;; first draft that doesn't support nesting
  (method protected (forward-multiline-comment)
    (forward)
    (forward)
    (let (iterate)
      (let ((c (char-forward 0)))
        (when c
          (if (and (eqv? c #\vertical-bar)
                   (eqv? (char-forward 1) #\sharp))
              (begin
                (forward)
                (forward)
                (set! kind 'multiline-comment)
                kind)
            (forward)
            (iterate))))))
  
  
  ;; first draft that doesn't support nesting
  (method protected (backward-multiline-comment)
    (backward)
    (backward)
    (let (iterate)
      (let ((c0 (char-backward 0))
            (c1 (char-backward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\vertical-bar) (eqv? c1 #\sharp))
               (backward)
               (backward)
               (set! kind 'multiline-comment)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method protected (forward-sharp)
    (forward)
    (let ((c0 (char-forward 0))
          (c1 (char-forward 1)))
      (cond ((and (memq? c0 '(#\t #\f)) (or (not c1) (not (text-constituent? c1))))
             (forward)
             (set! kind 'boolean)
             kind)
            ((eqv? c0 #\double-quote)
             (forward-delimited-string))
            ((eqv? c0 #\slash)
             (forward-syntax-string))
            ((and (eqv? c0 #\<) (eqv? (char-forward 1) #\<))
             (forward-named-string))
            ((eqv? c0 #\backslash)
             (forward-scheme-char))
            ((eqv? c0 #\semi-colon)
             (forward-expr-comment))
            ((eq? c0 #\vertical-bar)
             (forward-multiline-comment))
            (else
             (forward-constituent)))))
  
  
  (method protected (forward-backslahed-symbol)
    (forward)
    (forward)
    (forward-constituent))
  
  
  (method protected (forward-escaped-symbol)
    (forward)
    (let (iterate)
      (let ((c (char-forward 0)))
        (if (not c)
            #f
          (cond ((eqv? c #\backslash)
                 (forward)
                 (forward)
                 (iterate))
                ((eqv? c #\vertical-bar)
                 (forward)
                 (set! kind 'symbol)
                 kind)
                (else
                 (forward)
                 (iterate)))))))
  
  
  (method protected virtual (forward-delimited-string)
    (forward)
    (let (iterate)
      (let ((c0 (char-forward 0))
            (c1 (char-forward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\double-quote) (eqv? c1 #\sharp))
               (forward)
               (forward)
               (set! kind 'delimited-string)
               kind)
              (else
               (forward)
               (iterate))))))
  
  
  (method protected (backward-delimited-string)
    (backward)
    (backward)
    (let (iterate)
      (let ((c0 (char-backward 0))
            (c1 (char-backward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\double-quote) (eqv? c1 #\sharp))
               (backward)
               (backward)
               (set! kind 'delimited-string)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method protected virtual (forward-syntax-string)
    (forward)
    (let (iterate)
      (let ((c0 (char-forward 0))
            (c1 (char-forward 1))
            (c2 (char-forward 2)))
        (cond ((or (not c0) (not c1) (not c2))
               #f)
              ((and (eqv? c0 #\slash) (eqv? c1 #\slash) (eqv? c2 #\sharp))
               (forward)
               (forward)
               (forward)
               (set! kind 'syntax-string)
               kind)
              (else
               (forward)
               (iterate))))))
  
  
  (method protected (backward-syntax-string)
    (backward)
    (backward)
    (backward)
    (let (iterate)
      (let ((c0 (char-backward 0))
            (c1 (char-backward 1)))
        (cond ((or (not c0) (not c1))
               #f)
              ((and (eqv? c0 #\slash) (eqv? c1 #\sharp))
               (backward)
               (backward)
               (set! kind 'syntax-string)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method protected (forward-named-string)
    (forward)
    (forward)
    (continuation-capture
      (lambda (return)
        (let ((name (subseq (paragraph-string (get-line~ end)) (get-col~ end))))
          (set-end (new Cell (+ (get-line~ end) 1) 0))
          (while (< (get-line~ end) limit)
            (if (nu=? (subseq (paragraph-string (get-line~ end)) (get-col~ end)) name)
                (begin
                  (set-end (new Cell (+ (get-line~ end) 1) 0))
                  (continuation-return return 'named-string))
              (set-end (new Cell (+ (get-line~ end) 1) 0)))))
        #f)))

  
  (method protected (forward-scheme-char)
    (forward)
    (let ((c (char-forward 0)))
      (if (not (alphanumeric? c))
          (begin
            (forward)
            (set! kind 'char)
            kind)
        (let (iterate)
          (let ((c (char-forward 0)))
            (cond ((not c)
                   #f)
                  ((not (text-constituent? c))
                   (set! kind 'char)
                   kind)
                  (else
                   (forward)
                   (iterate))))))))
  
  
  (method protected (forward-string)
    (forward)
    (let (iterate)
      (call-line-hook)
      (let ((c (char-forward 0)))
        (cond ((not c)
               #f)
              ((eqv? c #\backslash)
               (forward)
               (forward)
               (iterate))
              ((string-delimiter? c)
               (forward)
               (set! kind 'string)
               kind)
              (else
               (forward)
               (iterate))))))
  
  
  (method protected (backward-string)
    (backward)
    (let (iterate)
      (let ((c (char-backward 0)))
        (cond ((not c)
               #f)
              ((eqv? (char-backward 1) #\backslash)
               (backward)
               (backward)
               (iterate))
              ((string-delimiter? c)
               (backward)
               (set! kind 'string)
               kind)
              (else
               (backward)
               (iterate))))))
  
  
  (method protected (forward-composite knd <Object> delimiter)
    (set-start end)
    (forward)
    (forward-all-expr)
    (forward-whites)
    (let ((c (char-forward 0)))
      (if (not (eqv? c delimiter))
          (explore-error (format "Found unexpected character while exploring forward: {a}" (present-char c)) end (next-pos end 1))
        (forward)
        (set! kind knd)
        kind)))
  
  
  (method protected (backward-composite knd <Object> delimiter)
    (let ((initial-start (copy start)))
      (backward)
      (backward-all-expr)
      (backward-whites)
      (let ((c (char-backward 0)))
        (if (not (eqv? c delimiter))
            (explore-error (format "Found unexpected character while exploring backward: {a}" (present-char c)) (previous-pos start 1) start)
          (backward)
          (set! end initial-start)
          (set! kind knd)
          kind))))

  
  (method public (enter-list)
    (forward-whites)
    (when (eqv? (char-forward 0) #\open-parenthesis)
      (forward)
      #t))
  
  
  (method public (exit-list)
    (forward-all-expr)
    (forward-whites)
    (when (eqv? (char-forward 0) #\close-parenthesis)
      (forward)
      #t))
  
  
  (method public (enter-composite)
    (let ((end (get-end)))
      (set-end (get-start))
      (forward-whites)
      (let ((c0 (char-forward 0)))
        (cond ((and (eqv? c0 #\comma) (eqv? (char-forward 1) #\at))
               (forward)
               (forward)
               (set! kind 'unquote-splicing)
               #t)
              ((eqv? c0 #\comma)
               (forward)
               (set! kind 'unquote)
               #t)
              ((eqv? c0 #\quote)
               (forward)
               (set! kind 'quote)
               #t)
              ((eqv? c0 #\backquote)
               (forward)
               (set! kind 'quasiquote)
               #t)
              ((eqv? c0 #\open-parenthesis)
               (forward)
               (set! kind 'list)
               #t)
              ((eqv? c0 #\open-bracket)
               (forward)
               (set! kind 'reference)
               #t)
              ((eqv? c0 #\open-brace)
               (forward)
               (set! kind 'literal)
               #t)
              (else
               (set-end end)
               #f)))))
  
  
  (method public (exit-composite)
    (forward-all-expr)
    (forward-whites)
    (when (memv? (char-forward 0) Close-Composites)
      (forward)
      #t))
  
  
  (method public (skip-forward name <string>)
    (and (forward-expr) (= (get-marked) name)))
  
  
  (method public (skip-backward name <string>)
    (and (backward-expr) (= (get-marked) name)))
  
  
  (method public (forward-modifiers modifiers)
    (let ((old (copy end))
          (symbol #f)
          (result '()))
      (let (iterate)
        (when (and (forward-expr) (eq? kind 'symbol))
           (set! symbol (find-marked-symbol))
           (when (memq? symbol modifiers)
             (set! old (copy end))
             (set! result (cons symbol result))
             (iterate))))
      (set! end old)
      (reverse! result)))
  
  
  (method (forward-comments)
    (next-paragraph))
  
  
  (method (backward-comments)
    )

  
  (method public (forward-whites) <void>
    (let (iterate)
      (let ((c (char-forward 0)))
        (when c
          (if (whitespace? c)
              (when (forward)
                (iterate))
            (case c
              ((#\semi-colon)
               (forward-comments)
               (iterate)))))))
    (call-line-hook))

  
  (method public (backward-whites) <void>
    (let (iterate)
      (let (iterate)
        (let ((c (char-backward 0)))
          (when (and c (whitespace? c) (backward))
            (iterate))))
      (when (backward-lisp-comment)
        (iterate))))

  
  (method (backward-lisp-comment) <bool>
    (define (find-lisp-comment line <fx>) <fx+>
      (let ((max-col (paragraph-length line))
            (preserved-end (copy end))
            (result #f))
        (set-end (new Cell line 0))
        (let ((result
                (let (iterate)
                  (when (and (= (get-line~ end) line) (< (get-col~ end) max-col))
                    (let ((c0 (char-forward 0)))
                      (cond ((eqv? c0 #\double-quote)
                             (forward-string)
                             (iterate))
                            ((eqv? c0 #\sharp)
                             (let ((c1 (char-forward 1)))
                               (cond ((eqv? c1 #\vertical-bar)
                                      (forward)
                                      (forward-multiline-comment)
                                      (iterate))
                                     ((eqv? c1 #\backslash)
                                      (forward)
                                      (forward-scheme-char)
                                      (iterate))
                                     (else
                                      (forward)
                                      (iterate)))))
                            ((eqv? c0 #\semi-colon)
                             (get-col~ end))
                            (else
                             (forward)
                             (iterate))))))))
          (set-end preserved-end)
          result)))
    
    (let ((start-line (get-line~ start))
          (start-col (get-col~ start)))
      (let ((col (if (eqv? start-line find-comment-last-row)
                     find-comment-last-col
                   (let ((col (find-lisp-comment start-line)))
                     (set! find-comment-last-row start-line)
                     (set! find-comment-last-col col)
                     col))))
        (when (and col (< col start-col))
          (set-col~ start col)
          #t))))


  ;;;
  ;;;; Level
  ;;;
  
  
  ;; == explorer problem:
  ;; many exploration modes are free-form (_ = terminal/white-space)
  ;; - _/* ... */_
  ;; - _#" ... "#_
  ;; - multiline commented code like:
  ;;   ;; [ ...
  ;;   ;; ... ]
  ;; We want normal behavior until we hit one of the end token,
  ;;  but complete the expr by correcting the other end
  ;;  forex.: ... ( ... "# ...
  ;;   where backward found "(", then forward found "\"#", we must go backward again
  ;;
  ;; Strings are free-form too, but you don't know the open/close direction
  ;;  ... " ... ( .... " .... ) ...
  ;;  correction can be heavy/impossible if we guess wrong
  ;;
  ;; Proper exploration of free-forms demand the same special knowledge as syntax coloring
  ;;
  ;; We usually have 2 possible explorations: left or right
  ;; We take inner over outer, and left over right


  (method override (outer-expr (atomic?: atomic? #f) (explore-whitespace?: explore-whitespace? #t) (uniform-style?: uniform-style? #f))
    (let ((empty? (= start end))
          (prv (previous-char start 0))
          (nxt (next-char end 0)))
      (define (reset)
        (set-start end)
        (set! prv (previous-char start 0))
        (set! nxt (next-char end 0)))
      
      (define (unquote-splicing? comma at)
        (and (eqv? comma #\comma) (eqv? at #\at)))
      
      (define (quote? c)
        (memv? c '(#\quote #\comma #\backquote)))
      
      (define (terminal? c)
        (or (not c)
            (whitespace? c)
            (open-composite? c)
            (close-composite? c)
            (string-delimiter? c)
            (quote? c)))
      
      (define (homogeneous? str)
        (member? str '("#s8" "#s16" "#s32" "#s64" "#f32"
                       "#u8" "#u16" "#u32" "#u64" "#f64")))
      
      (define (advance-quoting)
        (let (iterate (count 0))
          (define (skip-quoting)
            (forward)
            (forward-whitespaces)
            (reset)
            (iterate (+ count 1)))
          
          (cond ((unquote-splicing? nxt (next-char end 1))
                 (forward)
                 (skip-quoting))
                ((unquote-splicing? prv nxt)
                 (skip-quoting))
                ((quote? nxt)
                 (skip-quoting))
                ((quote? prv)
                 count)
                (else
                 count))))
      
      (define (advance-literal)
        (outer-constituent)
        (when (eqv? (get-char start) #\sharp)
          (forward-until terminal?)
          (reset)
          #t))
      
      (define (outer-style)
        (let ((pos start))
          (let ((string-style 'Text-String)
                (style (get-style-at~ model pos)))
            (when (inherits?~ style string-style)
              (select-style
                (lambda (style <Exemplar>)
                  (inherits?~ style string-style))
                strict?: #t)
              #t))))
      
      (define (outer-literal)
        (define (backward-to-sharp)
          (let ((s (copy start)))
            (backward-until terminal?)
            (if (eqv? (get-char start) #\sharp)
                #t
              (set-start s)
              #f)))
        
        (when (backward-to-sharp)
          (forward-until terminal?)
          (let ((marked (get-marked)))
            (cond ((homogeneous? marked)
                   (when (open-composite? (next-char end 0))
                     (let ((s (copy start)))
                       (forward-expr)
                       (set-start s))))
                  ((equal? marked "#\\")
                   (forward))
                  ((equal? marked "#")
                   (when (open-composite? (next-char end 0))
                     (let ((s (copy start)))
                       (forward-expr)
                       (set-start s))))))
          #t))
      
      (define (outer-constituent)
        (let ((prv-constituent? (and prv (text-constituent? prv)))
              (nxt-constituent? (and nxt (text-constituent? nxt))))
          (when (or prv-constituent? nxt-constituent?)
            (when prv-constituent?
              (backward-constituent))
            (when nxt-constituent?
              (forward-constituent))
            #t)))
      
      (define (outer-string)
        (let ((prv-string? (and prv (string-delimiter? prv)))
              (nxt-string? (and nxt (string-delimiter? nxt))))
          (when (or prv-string? nxt-string?)
            (cond ((and prv-string? nxt-string?)
                   (set-start (previous-pos start 1))
                   (set-end (next-pos end 1)))
                  (else
                   (when prv-string?
                     (backward-expr))
                   (when nxt-string?
                     (forward-expr))))
            #t)))
      
      (define (outer-composite)
        (let ((prv-close-composite? (and prv (close-composite? prv)))
              (nxt-open-composite? (and nxt (open-composite? nxt))))
          (when (or prv-close-composite? nxt-open-composite?)
            (if prv-close-composite?
                (backward-expr)
              (forward-expr))
            #t)))
      
      (define (prepend-quoting)
        (let ((s <Cell> (copy start)))
          (backward-whitespaces)
          (backward)
          (when (unquote-splicing? (previous-char start 0) (get-char start))
            (backward))
          (if (quote? (get-char start))
              #t
            (set-start s)
            #f)))
      
      (define (prepend-literal)
        (let ((s <Cell> (copy start)))
          (unless (terminal? (previous-char start 0))
            (backward-until terminal?)
            (let ((c (get-char start)))
              (if (eqv? c #\sharp)
                  #t
                (set-start s)
                #f)))))
      
      (define (prepend-expr-comment)
        (when (eqv? (previous-char start 0) #\at)
          (backward)))
      
      (define (composites-match? start end)
        (or (and (eqv? start #\open-parenthesis) (eqv? end #\close-parenthesis))
            (and (eqv? start #\open-bracket)     (eqv? end #\close-bracket))
            (and (eqv? start #\open-brace)       (eqv? end #\close-brace))))
      
      (or (if empty?
              (let ((quote-count (advance-quoting)))
                (when (or (and uniform-style? (outer-style))
                          (outer-literal)
                          (outer-constituent)
                          (outer-string)
                          (outer-composite))
                  (when (> quote-count 0)
                    (for-each (lambda (n) (prepend-quoting)) (naturals 0 quote-count)))
                  #t))
            (or (outer-constituent)
                (prepend-literal)
                (when (prepend-quoting)
                  (while (prepend-quoting))
                  #t)
                (prepend-expr-comment)))
          (when explore-whitespace?
            (receive (start-pos start-char) (let ((e (copy end)))
                                              (backward-all-expr)
                                              (set-end e)
                                              (values (copy start) (previous-char start 0)))
              (when (and start-char (not (open-composite? start-char)))
                (explore-error (format "Found unexpected character while exploring backward: {a}" (present-char start-char)) (previous-pos start-pos 1) start-pos))
              (receive (end-pos end-char) (let ((s (copy start)))
                                            (forward-all-expr)
                                            (set-start s)
                                            (values (copy end) (next-char end 0)))
                (when (and end-char (not (close-composite? end-char)))
                  (explore-error (format "Found unexpected character while exploring forward: {a}" (present-char end-char)) end-pos (next-pos end-pos 1)))
                (when (and start-char end-char (not (composites-match? start-char end-char)))
                  (explore-error (format "Found mismatched open/close: {a} {a}" (present-char start-char) (present-char end-char)) end-pos (next-pos end-pos 1)))
                (set-start start-pos)
                (set-end end-pos)
                (forward)
                (backward)
                (and start-char end-char)))))))


  (method public (form-expr)
    (let ((s (copy start))
          (e (copy end)))
      (set-end start)
      (prog1
          (when (eqv? (next-char end 0) #\open-parenthesis)
            (enter-list)
            (forward-expr)
            (when (eq? kind 'symbol)
              (find-marked-symbol)))
        (set-start s)
        (set-end e))))
  
  
  (method public (form-name form)
    (when (pair? form)
      (let ((expression-syntax (get-expression-syntax (car form))))
        (when (and expression-syntax (get-declaration?~ expression-syntax))
          (if (get-anonymous?~ expression-syntax)
              (car form)
            (let ((scan (cdr form))
                  (modifiers (get-modifiers~ expression-syntax)))
              (while (and (not-null? scan) (memq? (car scan) modifiers))
                (set! scan (cdr scan)))
              (when (not-null? scan)
                (let ((expr (car scan)))
                  (if (symbol? expr)
                      expr
                    (when (pair? expr)
                      (car expr)))))))))))


  (method public virtual (namespace-expr?)
    (namespace-name? (form-expr)))


  (method public virtual (declaration-expr?)
    (declaration-name? (form-expr)))


  (method public virtual (namespace-name? name)
    (expression-syntax-namespace? name))


  (method public virtual (declaration-name? name)
    (expression-syntax-declaration? name))


  (method public virtual (inner-name? name)
    (expression-syntax-inner? name))


  (method public (declaration-modifiers/name)
    (let ((s (copy start))
          (e (copy end)))
      (set-end start)
      (enter-list)
      (forward-expr)
      (let* ((decl (find-marked-symbol))
             (modifiers (forward-modifiers (expression-syntax-modifiers decl))))
        (cond ((memq? decl '(generic specific))
               (forward-expr)))
        (forward-whites)
        (if (eqv? (char-forward 0) #\open-parenthesis)
            (begin
              (enter-list)
              (forward-expr))
          (forward-expr))
        (prog1 (values modifiers (find-marked-symbol))
          (set-start s)
          (set-end e)))))
  
  
  (method (declaration-name)
    (receive (modifiers name) (declaration-modifiers/name)
      name))
  
  
  (method protected virtual (find-expression-syntax symbol)
    (get-expression-syntax symbol))


  ;;;
  ;;;; Comments
  ;;;
  
  
  (method public (for-each-comment proc <procedure> (start-line: start-line #f) (end-line: end-line #f))
    (define (semicolon-literal? string col)
      (and (>= col 2)
           (equal? (substring string (- col 2) (+ col 1)) "#\\;")))
    
    (let* ((previous-line #f)
           (title-comment (title-comment-string~ syntax))
           (title-comment-size (string-length title-comment))
           (start-line (or start-line 0))
           (end-line (or end-line limit)))
      (for-each (lambda (pos <Cell>)
                  (let ((line (get-line~ pos))
                        (col (get-col~ pos)))
                    (when (or (not previous-line) (/= line previous-line))
                      (let ((string (paragraph-string line))
                            (style (get-style-at~ model pos))
                            (start pos))
                        (unless (or (semicolon-literal? string col) (inherits?~ style 'Expr-Comment) (inherits?~ style 'Named-Comment) (string-style?~ syntax style))
                          (set! previous-line (get-line~ pos))
                          (set-end pos)
                          (paragraph-end)
                          (proc start end (and (< (+ col title-comment-size) (cast <fx> (cardinality string))) (string=? (subseq string col (+ col title-comment-size)) title-comment))))))))
                (let ((start (new Cell start-line 0))
                      (end (new Cell end-line (paragraph-length end-line))))
                  (text-search-all~ model (comment-string~ syntax) start: start end: end)))))


  ;;;
  ;;;; Declarations
  ;;;
  
  
  (method public virtual (walk-declarations context <Lisp-Entry+> declaration keyword expression doc)
    (while (walk-declaration context declaration keyword expression doc)
      ))
  
  
  (method public virtual (walk-declaration context <Lisp-Entry+> declaration keyword expression doc)
    (cond ((enter-list)
           (cond ((enter-list)
                  (walk-expressions context expression)
                  (exit-list)
                  (walk-expressions context expression))
                 ((forward-expr)
                  (if (eq? kind 'symbol)
                      (let ((symbol (find-marked-symbol)))
                        (let ((form (find-expression-syntax symbol)))
                          (walk-named-declaration context symbol form declaration keyword expression doc)))
                    (walk-expression context expression 'code #t)
                    (walk-expressions context expression 'code #f))))
           (exit-list)
           #t)
          ((forward-expr)
           (expression context start end 'code kind)
           #t)
          (else
           #f)))
  
  
  (method protected virtual (walk-named-declaration context <Lisp-Entry+> symbol form declaration keyword expression doc)
    (let ((walk (and form (get-walk~ form))))
      (if (procedure? walk)
          (walk self context symbol form declaration keyword expression doc)
        (let ((proc-walk (find-named-walker walk)))
          (proc-walk context symbol form declaration keyword expression doc)))))
  
  
  (method protected virtual (find-named-walker name)
    (if #f @w name ; we don't have a proc because we found a form for another explorer - tofix
        (error "Unknown define-expression walk: {s}" name)
      walk-unknown))
  
  
  (method protected (walk-parameters context <Lisp-Entry+> declaration keyword expression doc)
    (let ((result '()))
      (let (iterate)
        (when (forward-expr)
          (set! result (cons (get-marked) result))
          (walk-expression context expression 'code #f)
          (iterate)))
      (when context
        (set-parameters~ context (reverse! result)))))
  
  
  (method protected (walk-unknown context <Lisp-Entry+> symbol form declaration keyword expression doc)
    (walk-expression context expression 'code #t)
    (walk-expressions context expression 'code #f)
    context)


  ;;;
  ;;;; Expressions
  ;;;
  
  
  (method public (iterate-expressions proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expressions proc mode))
  
  
  (method public (iterate-expression proc (mode: mode 'code) (recursive?: recursive? #t))
    (for-each-expression proc mode))
  
  
  (method (for-each-expressions proc mode)
    (while (forward-expr)
      (for-each-expression proc mode)))
  
  
  (method (for-each-expression proc mode)
    (define Quotation-Forms
      '(quote quasiquote form <form> <jml> external intrinsic))
    
    (define (for-each-forms proc mode)
      (forward-expr)
      (when kind
        (let ((mode (if (and (eq? kind 'symbol) (memq? (find-marked-symbol) Quotation-Forms)
                          ;; a patch until the explorer has better code understanding
                          (or (neq? (intern-marked-symbol) 'form)
                              (eqv? (char-forward 0) #\newline)))
                        'quotation
                      mode)))
          (for-each-expression proc mode)
          (for-each-expressions proc mode))))
    
    (proc mode)
    (when (enter-composite)
      (cond ((eq? kind 'list)
             (for-each-forms proc mode)
             (exit-list))
            ((composite-kind? kind)
             (let ((mode (if (eq? kind 'literal) 'quotation mode)))
               (for-each-expressions proc mode))
             (exit-composite))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) 'quotation 'code)))
               (forward-expr)
               (for-each-expression proc mode))))))
  
  
  (method public (walk-expressions context <Lisp-Entry+> expression (mode 'code) (first? #t))
    (let (iterate (first? first?))
      (cond ((enter-list)
             (walk-expressions context expression)
             (exit-list)
             (iterate #f))
            ((forward-expr)
             (walk-expression context expression mode first?)
             (iterate #f)))))
  
  
  (method (walk-expression context <Lisp-Entry+> expression mode first?)
    (expression context start end mode
      (if (specifier-marked?)
          (if first?
              'tag
            'specifier)
        kind))
    (when (enter-composite)
      (cond ((composite-kind? kind)
             (walk-expressions context expression mode)
             (exit-composite))
            (else
             (let ((mode (if (memq? kind '(quote quasiquote)) kind 'code)))
               (forward-expr)
               (walk-expression context expression mode #f))))))
  
  
  (method (walk-specifier context <Lisp-Entry+> expression mode)
    (when context
      (forward-whites)
      (when (eqv? (char-forward 0) #\<)
        (forward-expr)
        (when (specifier-marked?)
          (set-type~ context (get-marked))
          (expression context start end mode 'specifier)))))
  

  ;;;
  ;;;; Constants
  ;;;
  
  
  (method public (constant?)
    (memq? kind '(number boolean char symbol specifier tag keyword)))
  
  
  (method public (get-constant)
    (case kind
      ((symbol) (intern-marked-symbol))
      (else (with-jazz-readtable
              (lambda ()
                (read-string-element (get-marked)))))))
  

  ;;;
  ;;;; Search
  ;;;
  
  
  ;; PATTERNS
  ;; - ?x    : matches exactly one expression
  ;; - *x    : matches any number of expressions inside a composite expression (todo)
  ;; - num   : matches a number
  ;; - #f    : matches the #f boolean
  ;; - #t    : matches the #t boolean
  ;; - #\x   : matches a character
  ;; - " "   : matches a string
  ;; - sym   : matches a symbol
  ;; - ( )   : matches a list that can contain patterns (todo)
  ;; - { }   : matches a literal that can contain patterns (todo)
  ;; - 'expr : matches expr only if within quoted text
  
  ;; VARIABLES
  ;; - Generalized variable syntax is ?name:kind
  ;; - The name is optional (not used at the moment)
  ;; - The kind is optional and can be : number boolean char string delimited-string named-string symbol specifier tag keyword expr-comment named-comment list reference literal
  
  ;; REPLACEMENT
  ;; - A good approach I think would be to generalize the backquote construct to non-code generation
  ;;   where the pattern variable names would be used to generate something like a template expander...
  
  ;; TODO
  ;; - For other tools like the highlighting done by edit-reference, it would be really nice to have an option
  ;;   for search-expressions to search a range and return all found matches
  
  
  (method public (search-expressions mode search-context <Search-Set> position whole-words? ignore-case?)
    (let ((all (map (lambda (target-string)
                      (let ((target (read-string-element target-string)))
                        (cons target target-string)))
                    (if (pair? search-context)
                        search-context
                      (map get-target~ (get-contexts~ search-context))))))
      (continuation-capture
        (lambda (return)
          (iterate-expressions
            (lambda (mode)
              (for-each (lambda (info)
                          (bind (target . target-string) info
                            (when (and (>= start position) (match? mode target))
                              (continuation-return return (list (get-range) target-string)))))
                        all))
            mode: mode)
          #f))))
  
  
  (method (match? expl-mode target)
    (define (expression-kind expression)
      (cond ((number? expression) 'number)
            ((boolean? expression) 'boolean)
            ((char? expression) 'char)
            ((string? expression) 'string)
            ((symbol? expression) 'symbol)
            (else (unimplemented 'expression-kind))))
    
    (define (parse-expression expression)
      (if (and (pair? expression) (eq? (car expression) 'quote))
          (values 'quotation (cadr expression))
        (values #f expression)))
    
    (define (pattern-variable? expression)
      (and (symbol? expression)
           (eqv? #\? (element (symbol->string expression) 0))))
    
    (define (parse-pattern-variable variable)
      (let ((elements (parse-strings (subseq (symbol->string variable) 1) separator: ":")))
        (bind-optionals ((name "") (kind "") (mode "")) elements
          (values (if (empty-string? name) #f (string->symbol name))
                  (if (empty-string? kind) #f (string->symbol kind))
                  (if (empty-string? mode) #f (string->symbol mode))))))
    
    (receive (mode expression) (parse-expression target)
      (let ((expl-kind (get-kind)))
        (if (pattern-variable? expression)
            (receive (name kind) (parse-pattern-variable expression)
              (and (or (not mode) (eq? mode expl-mode))
                   (or (not kind) (eq? kind expl-kind))))
          (let ((kind (expression-kind expression)))
            (and (or (not mode) (eq? mode expl-mode))
                 (eq? kind expl-kind)
                 (equal? expression (read-string-element (get-marked)))))))))
  

  ;;;
  ;;;; Utilities
  ;;;


  (method (open-composite? char)
    (memv? char Open-Composites))


  (method (close-composite? char)
    (memv? char Close-Composites))
  
  
  (method (composite-kind? kind)
    (memq? kind '(list reference literal)))))
