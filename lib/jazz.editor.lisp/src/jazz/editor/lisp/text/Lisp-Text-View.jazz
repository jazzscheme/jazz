;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Lisp Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.editor.lisp.text.Lisp-Text-View jazz


(import (jazz.catalog)
        (jazz.debugger)
        (jazz.editor.lisp)
        (jazz.jml)
        (jazz.library)
        (jazz.library.automata)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view))


(constant Auto-Complete-Characters
  '(#\minus #\question-mark #\exclamation-mark #\period #\colon #\tilde #\>))


(class Lisp-Text-View extends Code-Text-View
    
  
  (method override (new-syntax)
    (new Lisp-Syntax))

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta override (host-icon)
    {Bitmap-Resource "Script"})

  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method public (get-locat-container)
    (let ((moniker (get-moniker)))
      (if moniker
          (parse~ moniker)
        {})))
  
  
  ;;;
  ;;;; Actions
  ;;;
  

  (method override (focus-actions)
    (cons (find-actions 'lisp-text)
          (nextmethod)))

  
  ;;;
  ;;;; Events
  ;;;


  (method override (context-menu pos)
    (receive (shift? control? alt?) (modifiers-down)
      (let ((move-caret
              (cond ((and (not control?) (not shift?) (not alt?)) 'outside-selection)
                    ((and (not control?) shift? (not alt?)) 'never)
                    ((and control? shift? (not alt?)) 'never)
                    (else 'always))))
        (context-menu-click pos move-caret: move-caret))
      (cond ((and (not control?) shift? (not alt?)) (edit-definitions pos))
            ((and control? shift? (not alt?)) (edit-references pos))
            (else (track-popup-menu (get-context-menu) pos)))))


  (method override (tab-press key modifiers)
    (if (or (has-completion?)
            (not accepts-returns?))
        (nextmethod key modifiers)
      (if (shift-key? modifiers)
          (insert-char #\tab)
        (with-atomic-undo~ undoer
          (lambda ()
            (tabulate))))))
  
  
  ;;;
  ;;;; Coloring
  ;;;
  
  
  (method override (colorize-syntax (recoloring?: recoloring? #f))
    (nextmethod entries?: #f)
    (with-safe-explore
      (lambda ()
        (let ((expl <Text-Explorer> (new (explorer-class) self start: (text-beginning) end: (text-beginning)))
              (colorizer (essay (not recoloring?) (new-colorizer self))))
          (colorize-declarations expl colorizer)
          (when colorizer
            (finish-current~ colorizer)))
        (let ((expl <Text-Explorer> (new (explorer-class) self start: (text-beginning) end: (text-beginning)))
              (colorizer (essay (not recoloring?) (new-colorizer self))))
          (colorize-comments expl colorizer)
          (when colorizer
            (finish-current~ colorizer))))))
  
  
  (definition Syntax-Targets
    {})
  
  (definition Syntax-Automata
    {})
  
  
  (method override (syntax-targets)
    (unless Syntax-Targets
      (set! Syntax-Targets (compute-syntax-targets)))
    Syntax-Targets)
  
  
  (method override (syntax-automata)
    (unless Syntax-Automata
      (set! Syntax-Automata (compute-syntax-automata)))
    Syntax-Automata)
  
  
  (method override (compute-syntax-targets)
    Syntax-Targets)
  
  
  (method override (compute-syntax-automata)
    (let ((targets (syntax-targets)))
      (when targets
        (build-search-automata targets #t #f text-constituent?))))
  
  
  (method override (colorize-type found type start end colorizer recolorize?)
    )
  
  
  (method override (colorize-declarations expl colorizer)
    (walk-declarations~ expl
      {}
      ;; declaration
      (lambda (context kind symbol start end marked documented?)
        (when (and marked (neq? symbol 'getter) (neq? symbol 'setter))
          (apply-coloring colorizer start end (declaration-style documented?))))
      ;; keyword
      (lambda (context start end)
        (apply-coloring colorizer start end 'Declaration-Keyword))
      ;; expression
      (lambda (context start end mode kind)
        (case kind
          ((symbol)
           @wait-no-easy-way-to-recolorize-when-on-multiple-lines
           (when (memq? mode '(quote quasiquote))
             (apply-coloring {} start end 'Quotation)))
          ((keyword)
           ;; This test doesn't work because of our use of a Colorizer
           @wait-fix
           (when (eq? (get-name~ (get-style-at start)) 'Default)
             (apply-coloring colorizer start end 'Keyword)))
          ((tag)
           (colorize-tag colorizer start end))
          ((specifier)
           (colorize-specifier colorizer start end))
          ((char)
           (apply-coloring colorizer start end 'Char))
          ((number)
           @wait-this-is-too-much
           (apply-coloring colorizer start end 'Number))
          ((boolean)
           (apply-coloring colorizer start end 'Boolean))
          ((string)
           (apply-coloring colorizer start end 'String))
          ((delimited-string)
           (apply-coloring colorizer start end 'Delimited-String))
          ((named-string)
           (apply-coloring colorizer start end 'Named-String))
          ((expr-comment)
           (apply-coloring colorizer start end 'Expr-Comment))
          ((named-comment)
           (apply-coloring colorizer start end 'Named-Comment))
          ((literal)
           @wait-buggy-because-of-coloring-within-coloring
           (apply-coloring colorizer start end 'Literal))
          ((feature)
           (apply-coloring colorizer start end 'Feature))))
      (get-documentation-cataloguer~ (get-application))))
  
  
  (method protected virtual (colorize-tag colorizer start end)
    )
  
  
  (method protected virtual (colorize-specifier colorizer start end)
    )
  
  
  (method protected virtual (declaration-style documented?)
    )
  
  
  (method override (colorize-comments expl colorizer)
    (for-each-comment~ expl
      (lambda (start <Cell> end <Cell> title?)
        (let* ((row (get-row~ start))
               (len (paragraph-length row))
               (end (new Cell row len)))
          (if (not title?)
              (apply-coloring colorizer start end 'Comment)
            (apply-coloring colorizer start (+ start 4) 'Comment)
            (apply-coloring colorizer (+ start 4) end 'Title))))))

  
  (method override (recolorize-text start end-row)
    (nextmethod start end-row)
    (recolorize-declarations (get-row~ start) end-row)
    (recolorize-comments (get-row~ start) end-row))
  
  
  (method (recolorize-declarations start-row end-row)
    (define (explorer)
      (let* ((line (paragraph-string start-row))
             (col (skip-whitespace line))
             (pos (new Cell start-row col)))
        (new (explorer-class) self start: pos end: pos)))
    
    (catch Explore-Error
      (let ((expl <Text-Explorer> (explorer))
            (colorizer (new-colorizer self)))
        (continuation-capture
          (lambda (exit)
            (set-line-hook~ expl
              (lambda (expl)
                (when (> (get-row~ (get-end~ expl)) end-row)
                  (continuation-return exit))))
            (let (iterate)
              (colorize-declarations expl colorizer)
              (when (exit-list~ expl)
                (iterate)))))
        (finish-current~ colorizer))))
  
  
  (method (recolorize-comments start-row end-row)
    (define (explorer)
      (let* ((line (paragraph-string start-row))
             (col (skip-whitespace line))
             (pos (new Cell start-row col)))
        (new (explorer-class) self start: pos end: pos)))
    
    (catch Explore-Error
      (let ((expl <Text-Explorer> (explorer))
            (colorizer (new-colorizer self)))
        (continuation-capture
          (lambda (exit)
            (set-line-hook~ expl
              (lambda (expl)
                (when (> (get-row~ (get-end~ expl)) end-row)
                  (continuation-return exit))))
            (colorize-comments expl colorizer)))
        (finish-current~ colorizer))))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (definition Comment-Styles
    '(Title Comment))
  
  (definition String-Styles
    '(String Delimited-String Named-String))
  
  
  (method override (commented? pos)
    (comment-style? (get-style-at pos)))
  
  
  (method override (comment-style? style)
    (some? (lambda (style-name)
             (inherits?~ style style-name))
           Comment-Styles))
  
  
  (method override (string-style? style)
    (some? (lambda (style-name)
             (inherits?~ style style-name))
           String-Styles))
  
  
  (method override (textual-style? style)
    (or (comment-style? style)
        (string-style? style)))


  (method override (favorite-completions)
    (get-completions~ (preferences)))

  
  ;;;
  ;;;; Tabulation
  ;;;
  
  
  @cases
  (comment
  
  (method public virtual (foo)
    a)
  
  (foo
    a
    b)
  
  (for-each (lambda (x)
              x)
            list)
  
  (cond (foo
         a)))
  
  
  (method (on-tabulate evt)
    (with-atomic-undo~ undoer
      (lambda ()
        (tabulate))))


  (method override (return-press key)
    (with-atomic-undo~ undoer
      (lambda ()
        (nextmethod key)
        (tabulate))))


  (method override (tabulate)
    (let ((start (get-start))
          (end (get-end)))
      (with-update-locked
        (lambda ()
          (with-safe-explore
            (lambda ()
              (set-caret (get-start))
              (receive (modified? last-delta <fx>) (tabulate-lines (get-row~ start) (get-row~ end))
                (set-caret (+ end last-delta))
                (when modified?
                  (set-modified? #t))))
            action: 'ignore)))))
  
  
  (method override (tabulate-lines start end)
    (let ((modified? #f)
          (last-delta {}))
      (loop (for row from start to end)
            (with delta (tabulate-line row))
            (when (/= delta 0)
              (set! modified? #t))
            (set! last-delta delta))
      (values modified? last-delta)))
  
  
  (method (remove-specifiers lst)
    (if (not (pair? lst))
        '()
      (cons (car lst)
            (collect-if (lambda (mark)
                          (let ((range <Range$Cell$> (get-range~ mark)))
                            (or (not (eqv? (get-char (get-start~ range)) #\<))
                                (not (eqv? (get-char (- (get-end~ range) 1)) #\>)))))
                        (cdr lst)))))
  
  
  (method (effective-symbol string)
    (if (ends-with? string "~")
        (string->symbol (subseq string 0 (- (cast <fx> (cardinality string)) 1)))
      (string->symbol string)))
  
  
  (method override (tabulate-line row)
    (let ((delta (tabulate-delta row)))
      (tabulate-column row delta)
      delta))
  
  
  (method public (tabulate-delta row)
    (define (count-modifiers expressions modifiers)
      (let ((total 0)
            (done? #f))
        (while (and (not-null? expressions) (not done?))
          (let ((symbol (find-symbol (get-string (get-range~ (car expressions))))))
            (if (or (not symbol) (not (memq? symbol modifiers)))
                (set! done? #t)
              (increase! total)
              (set! expressions (cdr expressions)))))
        total))
    
    (let* ((pos (new Cell row 0))
           (expl <Text-Explorer> (new (explorer-class) self start: pos))
           (expressions (remove-specifiers (remove-expression-comments~ expl (collect-backward-exprs~ expl))))
           (opening (- (get-start~ expl) 1))
           (count (length expressions))
           (rank (- count 1))
           (col {}))
      (if (null? expressions)
          (set! col (+ (get-col~ opening) 1))
        (let* ((first (car expressions))
               (first-string (get-string (get-range~ first)))
               (first-symbol (essay (eq? (get-kind~ first) 'symbol) (effective-symbol first-string)))
               (first-tag? (tag? first-symbol))
               (first-call-with? (and first-symbol (starts-with? first-string "call-with-")))
               (first-with? (and first-symbol (starts-with? first-string "with-")))
               (first-without? (and first-symbol (starts-with? first-string "without-")))
               (first-dispatch? (and first-symbol (ends-with? first-string "~")))
               (first-indent (if (or first-tag? first-call-with? first-with? first-without?) 1 0)))
          (if (or (not first-symbol) first-tag?)
              (set! col (+ (get-col~ (get-start~ (get-range~ first))) first-indent))
            (let ((info (let ((form (get-lisp-form first-symbol)))
                          (essay form
                                 (let ((modifiers (get-modifiers~ form))
                                       (tabulate (get-tabulate~ form)))
                                   (essay tabulate (list modifiers tabulate)))))))
              (if (not info)
                  (let ((first-last (first-on-last-line expressions count))
                        (first-row (get-row~ (get-start~ (get-range~ first)))))
                    (if (and (= (get-row~ (get-start~ (get-range~ first-last))) first-row) (or first-call-with? first-with? first-without? first-dispatch? (/= count 2)) (neq? first-symbol 'else))
                        (set! col (+ (get-col~ opening) 2))
                      (let ((proposed-col (+ (get-col~ (get-start~ (get-range~ first-last))) (if (= count 1) first-indent 0)))
                            (threshold (+ (get-col~ opening) 2 4))
                            (default-col (+ (get-col~ opening) 2)))
                        (if (and (> proposed-col threshold)
                                 (upper-case? (element first-string 0)))
                            (set! col default-col)
                          (set! col proposed-col)))))
                (bind (modifiers specials) info
                  (when (not-null? modifiers)
                    (decrease! rank (count-modifiers (cdr expressions) modifiers)))
                  (if (= specials -1)
                      (set! col (get-col~ opening))
                    (if (= specials 0)
                        (set! col (+ (get-col~ opening) 2))
                      (if (> rank specials)
                          (set! col (get-col~ (get-start~ (get-range~ (first-on-last-line expressions count)))))
                        (set! col (+ (get-col~ opening) (* (+ (- specials rank) 1) 2))))))))))))
      (- col (get-column row))))
  
  
  (method (tabulate-column row delta)
    (when (/= delta 0)
      (let ((actual (get-column row)))
        (replace-text (new Range$Cell$ (new Cell row 0) (new Cell row actual))
                      (list (make-string (+ actual delta) #\space))))))
  
  
  (method (first-on-last-line expressions count)
    (let* ((reversed (if (> count 1) (reverse (cdr expressions)) (reverse expressions)))
           (first (car reversed))
           (line (get-row~ (get-start~ (get-range~ first)))))
      (while (and (not-null? reversed) (= (get-row~ (get-start~ (get-range~ (car reversed)))) line))
        (set! first (car reversed))
        (set! reversed (cdr reversed)))
      first))
  
  
  ;;;
  ;;;; Evaluation
  ;;;
  
  
  (method override (evaluate-selection)
    (with-safe-explore
      (lambda ()
        (let ((range (current-declaration-range)))
          (if (not range)
              (bell)
            (with-cursor :wait
              (lambda ()
                (sleep .1)
                (evaluate-range range))))))))
  
  
  (method override (evaluate-buffer)
    (with-cursor :wait
      (lambda ()
        (sleep .1)
        (evaluate-range (buffer-selection)))))
  
  
  (method override (evaluate-range range)
    (let ((debugged (get-focused-process~ (get-debugger-manager))))
      (if (not debugged)
          (bell)
        (bind (syntax str container line col) (prepare-expressions range)
          (evaluate-expressions~ debugged syntax str container line col)
          (let ((names (collect-declaration-names range)))
            (when (not-null? names)
              (user-message "Evaluated: {l detail: :human separator: \", \"}" names)))))))
  
  
  (method protected virtual (prepare-expressions range)
    )
  
  
  (method (collect-declaration-names range)
    (let ((start (get-start~ range))
          (end (get-end~ range)))
      (let ((expl (new (explorer-class) self start: start end: start))
            (queue (new-queue)))
        (when (forward-expr~ expl)
          (let (iterate)
            (let ((s (get-start~ expl))
                  (e (get-end~ expl)))
              (cond ((nu<=? e end)
                     (let ((form (read-text-form (get-range~ expl))))
                       (let ((name (form-name~ expl form)))
                         (when name
                           (enqueue queue name))))
                     (when (forward-expr~ expl)
                       (iterate)))
                    ((nu<? s end)
                     (explore-error~ expl "Ill-balanced expressions" start end))))))
        (queue-list queue))))
  
  
  ;;;
  ;;;; Expr
  ;;;


  (method override (current-name)
    (let ((range (current-expr-range)))
      (when range
        (get-string range))))


  (method override (current-expr)
    (let ((range (current-expr-range)))
      (when range
        (range-expr range))))
  
  
  (method override (range-expr range)
    (with-readtable (get-readtable)
      (lambda ()
        (read-string-element (get-string range)))))
  
  
  (method (current-symbol)
    (let ((expr (current-expr)))
      (when (symbol? expr)
        expr)))
  
  
  (method override (expr-at pos)
    (let ((string (get-string (expr-range pos))))
      (with-readtable (get-readtable)
        (lambda ()
          (if (ends-with? string "&")
              (read-string-element (butlast string))
            (read-string-element string))))))
  

  ;;;
  ;;;; Match
  ;;;
  
  
  (method override (flash-character? char)
    (memq? char '(#\close-parenthesis #\close-bracket #\close-brace)))

  
  ;;;
  ;;;; Chapters
  ;;;
  
  
  (constant headers
    (list
      (string-append (make-string 4 #\semi-colon) " ")))
  
  
  (method override (get-headers)
    headers)
  
  
  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method override (get-context)
    '(jazz))


  (method (current-declaration)
    (let ((range (current-declaration-range)))
      (when range
        (read-string-element (get-string range)))))
  
  
  (method (current-declaration-range)
    (if (and (not completion-active?) (has-selection?))
        (get-selection)
      (declaration-range (get-end))))
  
  
  (method public (declaration-range pos)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: pos end: pos)))
      (let (iterate (range {}))
        (if (not (outer-expr~ expl))
            range
          (let ((new-range (get-range~ expl))
                (name (form-expr~ expl)))
            (cond ((namespace-name?~ expl name)
                   (if (or ;; anywhere on first line
                           (= (get-row~ pos)
                              (get-row~ (get-start~ new-range)))
                           ;; exactly at end
                           (nu=? pos (get-end~ new-range)))
                       new-range
                     range))
                  ((and (declaration-name?~ expl name)
                        (not (inner-name?~ expl name)))
                   new-range)
                  (else
                   (iterate new-range))))))))

  
  ;;;
  ;;;; Highlights
  ;;;
  
  
  (definition Highlight-Styles
    '(Reference Walk-Warning Walk-Fatal Break))
  
  
  (method (highlight-style? style)
    (some? (lambda (style-name)
             (inherits?~ style style-name))
           Highlight-Styles))
  
  
  (method public (constant? expr)
    (or (number? expr)
        (boolean? expr)
        (char? expr)
        (symbol? expr)
        (keyword? expr)))
  
  
  (method (on-highlight-selection evt)
    (let ((declaration-range (declaration-range (get-start)))
          (expr-range (current-expr-range)))
      (if (or (not declaration-range) (not expr-range))
          (bell)
        (let ((constant (range-expr expr-range)))
          (if (not (constant? constant))
              (bell)
            (let ((style (get-style-at (get-end~ expr-range))))
              (if (highlight-style? style)
                  (unhighlight-expression declaration-range constant)
                (highlight-expression declaration-range constant))))))))
  
  
  (method (on-remove-highlights evt)
    (let ((range (declaration-range (get-start))))
      (if (not range)
          (bell)
        (remove-highlights range))))
  
  
  (method public (find-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range)))
          (constant (standardize-form constant)))
      (continuation-capture
        (lambda (return)
          (iterate-expression~ expl
            (lambda (mode)
              (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
                (continuation-return return (get-range~ expl)))))
          {}))))
  
  
  (method public (highlight-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range)))
          (constant (standardize-form constant)))
      (iterate-expression~ expl
        (lambda (mode)
          (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
            (apply-style 'Reference (get-start~ expl) (get-end~ expl)))))))
  
  
  (method public (unhighlight-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range)))
          (constant (standardize-form constant)))
      (iterate-expression~ expl
        (lambda (mode)
          (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
            (apply-style default-style (get-start~ expl) (get-end~ expl)))))))
  
  
  (method public (remove-highlights range)
    (for-each-paragraph (lambda (row <fx> paragraph <Paragraph>)
                          (for-each (lambda (run)
                                      (let ((style (get-style~ run)))
                                        (when (highlight-style? style)
                                          (set-style~ run default-style)
                                          (invalidate-paragraph paragraph))))
                                    (get-runs~ paragraph)))
                        start: (get-row~ (get-start~ range))
                        end: (+ (get-row~ (get-end~ range)) 1)))))
