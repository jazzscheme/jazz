;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Lisp Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.editor.lisp.text.Lisp-Text-View jazz


(import (jazz.debugger)
        (jazz.editor.lisp)
        (jazz.library)
        (jazz.library.automata)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.utilities))


(constant Auto-Complete-Characters
  '(#\minus #\question-mark #\exclamation-mark #\period #\colon #\tilde #\>))


(class Lisp-Text-View extends Code-Text-View
    
  
  (method (new-syntax)
    (new Lisp-Syntax))

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta (host-icon)
    {Bitmap-Resource "Script"})

  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method public (get-locat-container)
    (let ((moniker (get-moniker)))
      (if moniker
          (parse~ moniker)
        {})))
  
  
  ;;;
  ;;;; Actions
  ;;;
  

  (method (focus-actions)
    (cons (find-actions 'lisp-text)
          (nextmethod)))

  
  ;;;
  ;;;; Events
  ;;;


  (method (context-menu pos)
    (receive (shift? control? alt?) (modifiers-down)
      (let ((move-caret
              (cond ((and (not control?) (not shift?) (not alt?)) 'outside-selection)
                    ((and (not control?) shift? (not alt?)) 'never)
                    ((and control? shift? (not alt?)) 'never)
                    (else 'always))))
        (context-menu-click pos move-caret: move-caret))
      (cond ((and (not control?) shift? (not alt?)) (edit-definitions pos))
            ((and control? shift? (not alt?)) (edit-references pos))
            (else (track-popup-menu (get-context-menu) pos)))))


  (method (tab-press key modifiers)
    (if (or (has-completion?)
            (not accepts-returns?))
        (nextmethod key modifiers)
      (if (shift-key? modifiers)
          (insert-char #\tab)
        (with-atomic-undo~ undoer
          (function ()
            (tabulate))))))
  
  
  ;;;
  ;;;; Coloring
  ;;;
  
  
  (method (colorize-syntax (recoloring?: recoloring? #f))
    (nextmethod entries?: #f)
    (with-safe-explore
      (function ()
        (colorize-declarations recoloring?)
        (colorize-comments recoloring?))))
  
  
  (definition Syntax-Targets
    {})
  
  (definition Syntax-Automata
    {})
  
  
  (method (syntax-targets)
    (unless Syntax-Targets
      (set! Syntax-Targets (compute-syntax-targets)))
    Syntax-Targets)
  
  
  (method (syntax-automata)
    (unless Syntax-Automata
      (set! Syntax-Automata (compute-syntax-automata)))
    Syntax-Automata)
  
  
  (method (compute-syntax-targets)
    Syntax-Targets)
  
  
  (method (compute-syntax-automata)
    (let ((targets (syntax-targets)))
      (when targets
        (build-search-automata targets #t #f text-constituent?))))
  
  
  (method (colorize-type found type start end colorizer recolorize?)
    )

  
  (method (colorize-declarations (recoloring? #f))
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (text-beginning) end: (text-beginning)))
          (colorizer (essay (not recoloring?) (new-colorizer self))))
      (walk-declarations~ expl
        {}
        (function (context symbol start end marked documented?)
          (when marked
            (apply-coloring colorizer start end (declaration-style documented?))))
        (function (context start end)
          (apply-coloring colorizer start end 'Declaration-Keyword))
        (function (context start end mode kind)
          (case kind
            ((symbol)
             @wait-no-easy-way-to-recolorize-when-on-multiple-lines
             (when (memq? mode '(quote quasiquote))
               (apply-coloring {} start end 'Quotation)))
            ((keyword)
             ;; This test doesn't work because of our use of a Colorizer
             @wait-fix
             (when (eq? (get-name~ (get-style-at start)) 'Default)
               (apply-coloring colorizer start end 'Keyword)))
            ((tag)
             (colorize-tag colorizer start end))
            ((specifier)
             (colorize-specifier colorizer start end))
            ((char)
             (apply-coloring colorizer start end 'Char))
            ((number)
             @wait-this-is-too-much
             (apply-coloring colorizer start end 'Number))
            ((boolean)
             (apply-coloring colorizer start end 'Boolean))
            ((string)
             (apply-coloring colorizer start end 'String))
            ((delimited-string)
             (apply-coloring colorizer start end 'Delimited-String))
            ((named-string)
             (apply-coloring colorizer start end 'Named-String))
            ((expr-comment)
             (apply-coloring colorizer start end 'Expr-Comment))
            ((named-comment)
             (apply-coloring colorizer start end 'Named-Comment))
            ((literal)
             @wait-buggy-because-of-coloring-within-coloring
             (apply-coloring colorizer start end 'Literal))
            ((feature)
             (apply-coloring colorizer start end 'Feature))))
        (get-documentation-cataloguer~ (get-application))
        #t)
      (when colorizer
        (finish-current~ colorizer))))
  
  
  (method protected virtual (colorize-tag colorizer start end)
    )
  
  
  (method protected virtual (colorize-specifier colorizer start end)
    )
  
  
  (method protected virtual (declaration-style documented?)
    )
  
  
  (method (colorize-comments (recoloring? #f))
    (let ((expl <Text-Explorer> (new (explorer-class) self end: (text-beginning)))
          (colorizer (essay (not recoloring?) (new-colorizer self))))
      (for-each-comment~ expl
        (function (start <Cell> end <Cell> title?)
          (let* ((row (get-row~ start))
                 (len (paragraph-length row))
                 (end (new Cell row len)))
            (if (not title?)
                (apply-coloring colorizer start end 'Comment)
              (apply-coloring colorizer start (+ start 4) 'Comment)
              (apply-coloring colorizer (+ start 4) end 'Title)))))
      (when colorizer
        (finish-current~ colorizer))))

  
  (method (recolorize-text start end-row)
    (nextmethod start end-row)
    (loop (for row from (get-row~ start) to end-row)
          (recolorize-row row)))

  
  (method protected virtual (recolorize-row row)
    (recolorize-declarations row)
    (recolorize-comments row)
    (recolorize-booleans row)
    (recolorize-chars row)
    (recolorize-specifiers row)
    (recolorize-strings row)
    (recolorize-delimited-strings row))
  
  
  (definition Max-Declaration-Col
    4)
  
  
  (method (recolorize-declarations row)
    (catch Explore-Error
      (let* ((line (paragraph-string row))
             (col (skip-whitespace line)))
        (when (and (< col (cardinality line)) (<= col Max-Declaration-Col) (eqv? (element line col) #\open-parenthesis))
          (continuation-capture
            (function (exit)
              (let* ((pos (new Cell row col))
                     (expl <Text-Explorer> (new (explorer-class) self start: pos end: pos)))
                (set-line-hook~ expl
                  (function (expl)
                    (when (/= (get-row~ (get-end~ expl)) row)
                      (continuation-return exit))))
                (walk-declaration~ expl
                  {}
                  (function (context symbol start end marked documented?)
                    (when marked
                      (apply-style (declaration-style documented?) start end)))
                  (function (context start end)
                    (apply-style 'Declaration-Keyword start end))
                  (function (context start end mode kind)
                    (case kind
                      ((tag)
                       (apply-style 'Tag start end))
                      ((specifier)
                       (apply-style 'Specifier start end))
                      ((string)
                       (apply-style 'String start end))
                      ((expr-comment)
                       (apply-style 'Expr-Comment start end))
                      ((named-comment)
                       (apply-style 'Named-Comment start end))))
                  (get-documentation-cataloguer~ (get-application))
                  #f))))))))
  
  
  (method (recolorize-comments row)
    (let* ((line (paragraph-string row))
           (len (cardinality line))
           (comment (search line (comment-string~ syntax))))
      (when (and comment (not (textual-style? (get-style-at (new Cell row comment)))))
        (let ((title-end (+ comment 4)))
          (if (and (< title-end len) (string=? (subseq line comment title-end) (title-comment-string~ syntax)))
              (begin
                (apply-style 'Comment (new Cell row comment) (new Cell row title-end))
                (apply-style 'Title (new Cell row title-end)))
            (apply-style 'Comment (new Cell row comment)))))))
  
  
  (method (recolorize-booleans row)
    (let* ((str (paragraph-string row))
           (trg (list (make-search-context "#t") (make-search-context "#f")))
           (len (cardinality str))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((pos (multisearch str trg start: col)))
          (if (not pos)
              (set! done? #t)
            (bind (ctx . pos) pos
              (let ((end (+ pos (cardinality (get-target~ ctx)))))
                (unless (commented? (new Cell row pos))
                  (apply-style 'Boolean (new Cell row pos) (new Cell row end)))
                (set! col end))))))))
  
  
  (method (recolorize-chars row)
    (let* ((str (paragraph-string row))
           (len (cardinality str))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((pos (search str "#\\" start: col)))
          (if (not pos)
              (set! done? #t)
            (if (not (alphanumeric? (get-char (new Cell row (+ pos 2)))))
                (let ((end (+ pos 3)))
                  (unless (commented? (new Cell row pos))
                    (apply-style 'Char (new Cell row pos) (new Cell row end)))
                  (set! col end))
              (let ((end (+ pos 3)))
                (while (and (< end len) (text-constituent? (get-char (new Cell row end))))
                  (increase! end))
                (unless (commented? (new Cell row pos))
                  (apply-style 'Char (new Cell row pos) (new Cell row end)))
                (set! col end))))))))
  
  
  (method (recolorize-specifiers row)
    (let* ((str (paragraph-string row))
           (len (cardinality str))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((pos (search str "<" start: col)))
          (if (not pos)
              (set! done? #t)
            (let ((end (find-specifier-end (new Cell row pos))))
              (if (not end)
                  (set! done? #t)
                (let ((before (essay (> pos 0) (get-char (new Cell row (- pos 1))))))
                  (apply-style (if (eqv? before #\open-parenthesis) 'Tag 'Specifier) (new Cell row pos) end))
                (set! col (+ (get-col~ end) 1)))))))))
  
  
  (method (recolorize-strings row)
    (let* ((str (paragraph-string row))
           (len (cardinality str))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((pos (search str "\"" start: col)))
          (if (not pos)
              (set! done? #t)
            (let ((end (search str "\"" start: (+ pos 1))))
              (if (not end)
                  (begin
                    (apply-style 'String (new Cell row pos))
                    (set! done? #t))
                (unless (commented? (new Cell row pos))
                  (apply-style 'String (new Cell row pos) (new Cell row (+ end 1))))
                (set! col (+ end 1)))))))))
  
  
  (method (recolorize-delimited-strings row)
    (let* ((str (paragraph-string row))
           (len (cardinality str))
           (col 0)
           (done? #f))
      (while (not done?)
        (let ((pos (search str "#\"" start: col)))
          (if (not pos)
              (set! done? #t)
            (let ((end (search str "\"#" start: (+ pos 2))))
              (if (not end)
                  (begin
                    (apply-style 'Delimited-String (new Cell row pos))
                    (set! done? #t))
                (unless (commented? (new Cell row pos))
                  (apply-style 'Delimited-String (new Cell row pos) (new Cell row (+ end 2))))
                (set! col (+ end 2)))))))))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (definition Comment-Styles
    '(Title Comment))
  
  (definition String-Styles
    '(String Delimited-String Named-String))
  
  
  (method (commented? pos)
    (comment-style? (get-style-at pos)))
  
  
  (method (comment-style? style)
    (some? (function (style-name)
             (inherits?~ style style-name))
           Comment-Styles))
  
  
  (method (string-style? style)
    (some? (function (style-name)
             (inherits?~ style style-name))
           String-Styles))
  
  
  (method (textual-style? style)
    (or (comment-style? style)
        (string-style? style)))


  (method (favorite-completions)
    (get-completions~ (preferences)))

  
  ;;;
  ;;;; Tabulation
  ;;;
  
  
  @cases
  (comment
  
  (method public virtual (foo)
    a)
  
  (foo
    a
    b)
  
  (for-each (function (x)
              x)
            list)
  
  (cond (foo
         a)))
  
  
  ;; Rules
  ;; -
  
  
  (method (on-tabulate evt)
    (tabulate))
  
  
  (method protected virtual (get-specials)
    )


  (method (return-press key)
    (with-atomic-undo~ undoer
      (function ()
        (nextmethod key)
        (tabulate))))


  (method (tabulate)
    (let ((start (get-start))
          (end (get-end)))
      (with-update-locked
        (function ()
          (with-safe-explore
            (function ()
              (set-caret (get-start))
              (receive (modified? last-delta <fx>) (tabulate-lines (get-row~ start) (get-row~ end))
                (set-caret (+ end last-delta))
                (when modified?
                  (set-modified? #t))))
            action: 'ignore)))))
  
  
  (method (tabulate-lines start end)
    (let ((modified? #f)
          (last-delta {}))
      (loop (for row from start to end)
            (with delta (tabulate-line row))
            (when (/= delta 0)
              (set! modified? #t))
            (set! last-delta delta))
      (values modified? last-delta)))
  
  
  (method (remove-specifiers lst)
    (if (not (pair? lst))
        '()
      (cons (car lst)
            (collect-if (function (mark)
                          (let ((range <Range$Cell$> (get-range~ mark)))
                            (or (not (eqv? (get-char (get-start~ range)) #\<))
                                (not (eqv? (get-char (- (get-end~ range) 1)) #\>)))))
                        (cdr lst)))))
  
  
  (method (effective-symbol string)
    (if (ends-with? string "~")
        (string->symbol (subseq string 0 (- (cast <fx> (cardinality string)) 1)))
      (string->symbol string)))
  
  
  (method (tabulate-line row)
    (let ((delta (tabulate-delta row)))
      (tabulate-column row delta)
      delta))
  
  
  (method public (tabulate-delta row)
    (let* ((pos (new Cell row 0))
           (expl <Text-Explorer> (new (explorer-class) self start: pos))
           (expressions (remove-specifiers (collect-backward-exprs~ expl)))
           (opening (- (get-start~ expl) 1))
           (count (length expressions))
           (rank (- count 1))
           (col {}))
      (if (null? expressions)
          (set! col (+ (get-col~ opening) 1))
        (let* ((first (car expressions))
               (first-string (get-string (get-range~ first)))
               (first-symbol (essay (eq? (get-kind~ first) 'symbol) (effective-symbol first-string)))
               (first-tag? (tag? first-symbol))
               (first-call-with? (and first-symbol (starts-with? first-string "call-with-")))
               (first-with? (and first-symbol (starts-with? first-string "with-")))
               (first-without? (and first-symbol (starts-with? first-string "without-")))
               (first-dispatch? (and first-symbol (ends-with? first-string "~")))
               (first-indent (if (or first-tag? first-call-with? first-with? first-without?) 1 0)))
          (if (or (not first-symbol) first-tag?)
              (set! col (+ (get-col~ (get-start~ (get-range~ first))) first-indent))
            (let* ((special-info (assq first-symbol (get-specials)))
                   (info (either (essay special-info (cdr special-info))
                                 (let ((form (get-lisp-form first-symbol)))
                                   (essay form
                                          (let ((tabulate (get-tabulate~ form)))
                                            (essay tabulate (list #f tabulate))))))))
              (if (not info)
                  (let ((first-last (first-on-last-line expressions count))
                        (first-row (get-row~ (get-start~ (get-range~ first)))))
                    (if (and (= (get-row~ (get-start~ (get-range~ first-last))) first-row) (or first-call-with? first-with? first-without? first-dispatch? (/= count 2)) (neq? first-symbol 'else))
                        (set! col (+ (get-col~ opening) 2))
                      (let ((proposed-col (+ (get-col~ (get-start~ (get-range~ first-last))) (if (= count 1) first-indent 0)))
                            (threshold (+ (get-col~ opening) 2 4))
                            (default-col (+ (get-col~ opening) 2)))
                        (if (and (> proposed-col threshold)
                                 (upper-case? (element first-string 0)))
                            (set! col default-col)
                          (set! col proposed-col)))))
                (bind (modifiers? specials) info
                  (when modifiers?
                    (decrease! rank (count-modifiers (cdr expressions))))
                  (if (= specials -1)
                      (set! col (get-col~ opening))
                    (if (= specials 0)
                        (set! col (+ (get-col~ opening) 2))
                      (if (> rank specials)
                          (set! col (get-col~ (get-start~ (get-range~ (first-on-last-line expressions count)))))
                        (set! col (+ (get-col~ opening) (* (+ (- specials rank) 1) 2))))))))))))
      (- col (get-column row))))
  
  
  (method (tabulate-column row delta)
    (when (/= delta 0)
      (let ((actual (get-column row)))
        (replace-text (new Range$Cell$ (new Cell row 0) (new Cell row actual))
                      (list (make-string (+ actual delta) #\space))))))
  
  
  (method (count-modifiers expressions)
    (let ((total 0)
          (done? #f))
      (while (and (not-null? expressions) (not done?))
        (let ((symbol (find-symbol (get-string (get-range~ (car expressions))))))
          ;; the (new (explorer-class)) is temporary
          (if (or (not symbol) (not (memq? symbol (get-modifiers~ (new (explorer-class) self)))))
              (set! done? #t)
            (increase! total)
            (set! expressions (cdr expressions)))))
      total))
  
  
  (method (first-on-last-line expressions count)
    (let* ((reversed (if (> count 1) (reverse (cdr expressions)) (reverse expressions)))
           (first (car reversed))
           (line (get-row~ (get-start~ (get-range~ first)))))
      (while (and (not-null? reversed) (= (get-row~ (get-start~ (get-range~ (car reversed)))) line))
        (set! first (car reversed))
        (set! reversed (cdr reversed)))
      first))
  
  
  ;;;
  ;;;; Evaluation
  ;;;
  
  
  (method (evaluate-selection)
    (with-safe-explore
      (function ()
        (let ((range (current-definition-range)))
          (when range
            (with-cursor :wait
              (function ()
                (sleep .1)
                (evaluate-range range))))))))
  
  
  (method (evaluate-buffer)
    (with-cursor :wait
      (function ()
        (sleep .1)
        (evaluate-range (buffer-selection)))))
  
  
  (method (evaluate-range range)
    (let ((debugged (get-focused-process)))
      (if (not debugged)
          (bell)
        (bind (syntax str container line col) (prepare-expressions range)
          (evaluate-expressions~ debugged syntax str container line col)
          (let ((names (collect-declaration-names range)))
            (when (not-null? names)
              (user-message "Evaluated: {l detail: :human separator: \", \"}" names)))))))
  
  
  (method protected virtual (prepare-expressions range)
    )
  
  
  (method (collect-declaration-names range)
    (let ((start (get-start~ range))
          (end (get-end~ range)))
      (let ((expl (new (explorer-class) self start: start end: start))
            (queue (new-queue)))
        (when (forward-expr~ expl)
          (let (iterate)
            (let ((s (get-start~ expl))
                  (e (get-end~ expl)))
              (cond ((nu<=? e end)
                     (let ((form (read-text-form (get-range~ expl))))
                       (let ((name (form-name~ expl form)))
                         (when name
                           (enqueue queue name))))
                     (when (forward-expr~ expl)
                       (iterate)))
                    ((nu<? s end)
                     (explore-error~ expl "Ill-balanced expressions" start end))))))
        (queue-list queue))))
  
  
  ;;;
  ;;;; Expr
  ;;;


  (method (current-name)
    (let ((range (current-expr-range)))
      (when range
        (get-string range))))


  (method (current-expr)
    (let ((range (current-expr-range)))
      (when range
        (read-string-element (get-string range)))))
  
  
  (method (current-expr-range)
    (if (and (not completion-active?) (has-selection?))
        (get-selection)
      (expr-range (get-end))))
  
  
  (method (current-symbol)
    (let ((expr (current-expr)))
      (when (symbol? expr)
        expr)))
  
  
  (method (expr-at pos)
    (let ((string (get-string (expr-range pos))))
      (if (ends-with? string "&")
          (read-string-element (butlast string))
        (read-string-element string))))
  

  ;;;
  ;;;; Match
  ;;;
  
  
  (method (flash-character? char)
    (memq? char '(#\close-parenthesis #\close-bracket #\close-brace)))

  
  ;;;
  ;;;; Chapters
  ;;;
  
  
  (constant headers
    (list
      (string-append (make-string 4 #\semi-colon) " ")))
  
  
  (method (get-headers)
    headers)
  
  
  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method (get-context)
    '(jazz))


  (method (current-definition)
    (let ((range (current-definition-range)))
      (when range
        (read-string-element (get-string range)))))
  
  
  (method (current-definition-range)
    (if (and (not completion-active?) (has-selection?))
        (get-selection)
      (definition-range (get-end))))
  
  
  (method public (definition-range pos)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: pos end: pos))
          (range {})
          (definition? #f)
          (done? #f))
      (while (not done?)
        (if (not (outer-expr~ expl))
            (set! done? #t)
          (set! range (get-range~ expl))
          (when (definition-expr?~ expl)
            (set! definition? #t)
            (set! done? #t))))
      (when (and range (or definition? (not (need-definition?))))
        range)))
  
  
  (method protected virtual (need-definition?)
    #t)

  
  ;;;
  ;;;; Highlights
  ;;;
  
  
  (definition Highlight-Styles
    '(Reference Walk-Warning Walk-Fatal Break))
  
  
  (method (highlight-style? style)
    (some? (function (style-name)
             (inherits?~ style style-name))
           Highlight-Styles))
  
  
  (method public (constant? expr)
    (or (number? expr)
        (boolean? expr)
        (char? expr)
        (symbol? expr)
        (keyword? expr)))
  
  
  (method (on-highlight-selection evt)
    (let ((range (definition-range (get-start)))
          (constant (current-expr)))
      (if (or (not range) (not (constant? constant)))
          (bell)
        (let ((style (get-style-at (get-end))))
          (if (highlight-style? style)
              (unhighlight-expression range constant)
            (highlight-expression range constant))))))
  
  
  (method (on-remove-highlights evt)
    (let ((range (definition-range (get-start))))
      (if (not range)
          (bell)
        (remove-highlights range))))
  
  
  (method public (find-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range))))
      (continuation-capture
        (function (return)
          (iterate-expression~ expl
            (function (mode)
              (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
                (continuation-return return (get-range~ expl)))))
          {}))))
  
  
  (method public (highlight-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range))))
      (iterate-expression~ expl
        (function (mode)
          (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
            (apply-style 'Reference (get-start~ expl) (get-end~ expl)))))))
  
  
  (method public (unhighlight-expression range constant)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start~ range) end: (get-start~ range))))
      (iterate-expression~ expl
        (function (mode)
          (when (and (constant?~ expl) (eqv? (standardize-form (get-constant~ expl)) constant))
            (apply-style default-style (get-start~ expl) (get-end~ expl)))))))
  
  
  (method public (remove-highlights range)
    (for-each-paragraph (function (row <fx> paragraph <Paragraph>)
                          (for-each (function (run)
                                      (let ((style (get-style~ run)))
                                        (when (highlight-style? style)
                                          (set-style~ run default-style)
                                          (invalidate-paragraph paragraph))))
                                    (get-runs~ paragraph)))
                        start: (get-row~ (get-start~ range))
                        end: (+ (get-row~ (get-end~ range)) 1)))))
