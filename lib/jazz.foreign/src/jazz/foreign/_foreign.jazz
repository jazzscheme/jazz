;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Foreign Function Interface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.foreign jazz


(import (jazz.core (phase syntax))
        (jazz.dialect.classes.foundation))


(native private jazz:current-walker)
(native private jazz:current-resume)
(native private jazz:current-declaration)

(native private jazz:resolve-c-type-reference)
(native private jazz:walk-error)


;;;
;;;; C-External
;;;


(macro public (c-external signature type . rest)
  (let* ((s-name (car signature))
         (params (cdr signature))
         (c-name (if (null? rest) (symbol->string s-name) (car rest))))
    `(definition public ,s-name
       (c-function ,params ,type ,c-name))))


;;;
;;;; C-Structure
;;;


(define (build-pointer-symbol type)
  (string->symbol (string-append (symbol->string type) "*")))


(define (build-method-symbol struct . rest)
  (string->symbol (apply string-append (symbol->string struct) "-" (map symbol->string rest))))


(define (expand-accessor walker resume declaration environment clause struct)
  (define (kind+type type)
    (let loop ((declaration (resolve-c-type-reference walker resume declaration environment type)))
         (let ((kind (get-kind~ declaration))
               (expansion (get-expansion~ declaration))
               (inclusions (get-inclusions~ declaration)))
           (if (eq? kind 'alias)
               (loop (car inclusions))
             (values kind expansion)))))
  
  (let ((type (car clause))
        (id   (cadr clause))
        (size (let ((clause-rest (cddr clause)))
                (and (not (null? clause-rest))
                     (car clause-rest)))))
    (when (and size (not (integer? size)) (not (symbol? size)))
      (walk-error walker resume declaration #f "Illegal clause size in {a}: {a}" struct clause))
    (receive (kind expansion) (kind+type type)
      (let ((id-string (symbol->string id)))
        (let ((getter-string
                (if size
                    (if (or (eq? expansion 'char)
                            (eq? expansion 'wchar_t))
                        (string-append "___result = ___arg1->" id-string ";")
                      (string-append "___result_voidstar = ___arg1->" id-string ";"))
                  (case kind
                    ((native)
                     (string-append "___result = ___arg1->" id-string ";"))
                    ((pointer function)
                     (string-append "___result_voidstar = ___arg1->" id-string ";"))
                    ((type struct union)
                     (string-append "___result_voidstar = &___arg1->" id-string ";")))))
              (setter-string
                (cond (size
                        (let ((size-string (if (integer? size)
                                               (number->string size)
                                             (symbol->string size))))
                          (cond ((eq? expansion 'char)
                                 (string-append "strncpy(___arg1->" id-string ", ___arg2, " size-string ");"))
                                ((eq? expansion 'wchar_t)
                                 (string-append "wcsncpy(___arg1->" id-string ", ___arg2, " size-string ");"))
                                (else
                                 ;; We need to adjust this to get the real c-type in the expansion
                                 (string-append "memcpy(___arg1->" id-string ", ___arg2, " size-string "*" "sizeof(" (symbol->string type) "));")))))
                      ((or (eq? kind 'struct)
                           (eq? kind 'union)
                           (eq? kind 'type))
                       #f)
                      (else
                       (string-append "___arg1->" id-string " = ___arg2;")))))
          (let* ((struct* (build-pointer-symbol struct))
                 (type* (build-pointer-symbol type))
                 (type (cond ((and size (eq? expansion 'char)) '(native char-string))
                             ((and size (eq? expansion 'wchar_t)) '(native wchar_t-string))
                             (size type*)
                             ((memq kind '(type struct union)) type*)
                             (else type))))
            (let ((getter `(definition public ,(build-method-symbol struct id '-ref)
                                       (c-function (,struct*) ,type ,getter-string)))
                  (setter (and setter-string
                               `(definition public ,(build-method-symbol struct id '-set!)
                                            (c-function (,struct* ,type) (native void) ,setter-string)))))
              (values getter setter))))))))


(define (expand-structure/union walker resume declaration environment name clauses)
  (define (parse-structure-name name)
    (if (symbol? name)
        (values name (symbol->string name) '())
      (values (car name) (cadr name) (cddr name))))
  
  (receive (struct c-struct-string tag-rest) (parse-structure-name name)
    (let ((struct* (build-pointer-symbol struct))
          (sizeof (string-append "sizeof(" c-struct-string ")"))
          (tag*-rest (if (null? tag-rest) '() (cons (build-pointer-symbol (car tag-rest)) (cdr tag-rest)))))
      (define (expand-acc clause)
        (receive (getter setter) (expand-accessor walker resume declaration environment clause struct)
          (if setter
              (list getter setter)
            (list getter))))
      `(begin
         (c-type ,struct (type ,c-struct-string ,@tag-rest))
         (c-type ,struct* (pointer ,struct ,@tag*-rest))
         (definition public ,(build-method-symbol struct 'make)
           (c-function () ,struct* ,(string-append "___result_voidstar = calloc(1," sizeof ");")))
         (definition public ,(build-method-symbol struct 'free)
           (c-function (,struct*) (native void) "free(___arg1);"))
         (definition public ,(build-method-symbol struct 'sizeof)
           (c-function () (native unsigned-int) ,(string-append "___result = " sizeof ";")))
         ,@(apply append (map expand-acc clauses))))))


(define (expand-c-structure-array name . rest)
  (let* ((struct name)
         (struct* (build-pointer-symbol struct))
         (c-struct-string (if (not (null? rest)) (car rest) (symbol->string struct))))
    `(begin
       (definition public ,(build-method-symbol struct 'array-make)
         (c-function (int) ,struct* ,(string-append "___result = calloc(___arg1,sizeof(" c-struct-string "));")))
       (definition public ,(build-method-symbol struct 'array-element)
         (c-function (,struct* int) ,struct* ,(string-append "___result = ___arg1+___arg2;"))))))


(syntax public c-structure
  (lambda (form environment macro-environment)
    (bind (name . clauses) (cdr (strip-syntactic-closures form))
      (expand-structure/union (current-walker) (current-resume) (current-declaration) environment name clauses))))


(syntax public c-union
  (lambda (form environment macro-environment)
    (bind (name . clauses) (cdr (strip-syntactic-closures form))
      (expand-structure/union (current-walker) (current-resume) (current-declaration) environment name clauses))))


;;;
;;;; COM-External
;;;


;; (com-external 22 (OpenDatabase (in VT_BSTR) (in VT_VARIANT) (in VT_VARIANT) (in VT_VARIANT) (out VT_PTR VT_UNKNOWN)) VT_HRESULT)
#;
(define (expand-com-external walker resume declaration environment offset signature result-type)
  (let ((name (car signature))
        (resolve-declaration (lambda (type) (if (symbol? type)
                                                (resolve-c-type-reference walker resume declaration environment type)
                                              (walk-error walker resume declaration #f "Illegal parameter type in com-external {s}: {s}" (car signature) type))))
        (fix-locator (lambda (declaration) (if (eq? (get-kind~ declaration) 'type)
                                               (string->symbol (string-append (symbol->string (get-locator~ declaration)) "*"))
                                             (get-locator~ declaration)))))
    ;; we assume coparam-types are symbols that exactly match the c type
    (let ((resolved-result (resolve-declaration result-type))
          (resolved-params (map resolve-declaration (map cadr (cdr signature))))
          (lowlevel-name (string->symbol (string-append (symbol->string name) "$"))))
      #; ;; debug
      (apply debug name resolved-result resolved-params)
      (if (every? (lambda (resolved) (is? resolved C-Type-Declaration)) (cons resolved-result resolved-params))
          `(definition ,lowlevel-name
             (c-function ,(cons 'IUnknown* (map fix-locator resolved-params))
                         ,(get-locator~ resolved-result)
                         ,(string-append
                            "{typedef "
                            (->string (get-name~ resolved-result))
                            " (*ProcType)(IUnknown*"
                            (apply string-append (let iter-arg ((resolved-params resolved-params))
                                                      (if (pair? resolved-params)
                                                          (cons ", " (cons (->string (get-name~ (car resolved-params)))
                                                                           (iter-arg (cdr resolved-params))))
                                                        '())))
                            "); ProcType fn = (*(ProcType**)___arg1)["
                            (number->string offset)
                            "]; ___result = (*fn)(___arg1"
                            (apply string-append (let iter-arg ((resolved-params resolved-params)
                                                                (order 2))
                                                      (if (pair? resolved-params)
                                                          (cons (if (eq? (get-kind~ (car resolved-params)) 'type) ", *___arg" ", ___arg")
                                                                (cons (number->string order)
                                                                      (iter-arg (cdr resolved-params) (+ order 1))))
                                                        '())))
                            ");}")))))))


;; (com-external (OpenDatabase (in VT_BSTR) (in VT_VARIANT) (in VT_VARIANT) (in VT_VARIANT) (out VT_PTR VT_UNKNOWN)) VT_HRESULT)
(define (expand-com-external walker resume declaration environment signature result-type com-interface offset)
  (let* ((name (car signature))
         (param-types (map cadr (cdr signature)))
         (resolve-declaration (lambda (type) (if (symbol? type)
                                                 (resolve-c-type-reference walker resume declaration environment type)
                                               (walk-error walker resume declaration #f "Illegal parameter type in com-external {s}: {s}" name type)))))
    (let ((resolved-result (resolve-declaration result-type))
          (resolved-params (map resolve-declaration param-types))
          (resolved-directions (map car (cdr signature)))
          (lowlevel-name (string->symbol (string-append (symbol->string name) "$"))))
      (let ((hresult? (eq? (get-locator~ resolved-result) 'jazz.platform.windows.com:HRESULT)))
        (if (every? (lambda (resolved) (is? resolved C-Type-Declaration)) (cons resolved-result resolved-params))
            (let ((x`(begin
               (definition ,lowlevel-name ,(emit-com-function offset result-type resolved-result param-types resolved-params))
               (definition public ,name ,(emit-com-external hresult? lowlevel-name resolved-params resolved-directions com-interface))))) x))))))


(define (emit-com-function offset result-type resolved-result param-types resolved-params)
  (define (fix-locator type declaration)
    (if (eq? (get-kind~ declaration) 'type)
        (string->symbol (string-append (symbol->string type) "*"))
      type))
  
  ;; we assume lexical-binding-name exactly matches the c type
  `(c-function ,(cons 'IUnknown* (map fix-locator param-types resolved-params))
               ,result-type
               ,(string-append
                  "{typedef "
                  (->string (get-name~ resolved-result))
                  " (*ProcType)(IUnknown*"
                  (apply string-append (let iter ((resolved-params resolved-params))
                                            (if (pair? resolved-params)
                                                (cons ", " (cons (->string (get-name~ (car resolved-params)))
                                                                 (iter (cdr resolved-params))))
                                              '())))
                  "); ProcType fn = (*(ProcType**)___arg1)["
                  (number->string offset)
                  "]; ___result = (*fn)(___arg1"
                  (apply string-append (let iter ((resolved-params resolved-params)
                                                  (order 2))
                                            (if (pair? resolved-params)
                                                (cons (if (eq? (get-kind~ (car resolved-params)) 'type) ", *___arg" ", ___arg")
                                                      (cons (number->string order)
                                                            (iter (cdr resolved-params) (+ order 1))))
                                              '())))
                  ");}")))


(define (emit-com-external hresult? lowlevel-name resolved-params resolved-directions com-interface)
  (define (generate-in resolved-param resolved-direction order)
    (if (eq? resolved-direction 'out)
        #f
      (string->symbol (string-append "in$" (number->string order)))))
  
  (define (generate-low resolved-param resolved-direction order)
    (string->symbol (string-append "low$" (number->string order))))
  
  (define (generate-out resolved-param resolved-direction order)
    (if (eq? resolved-direction 'in)
        #f
      (string->symbol (string-append "out$" (number->string order)))))
  
  (define (generate-encode/enref resolved-param resolved-direction order)
    (let ((binding (generate-low resolved-param resolved-direction order))
          (encode/enref (get-cotype-encode/enref resolved-param))
          (value (if (eq? resolved-direction 'out)
                     (get-cotype-default-value resolved-param)
                   (generate-in resolved-param resolved-direction order))))
      (if encode/enref
          `(,binding (,encode/enref ,value))
        `(,binding ,value))))
  
  (define (generate-ref resolved-param resolved-direction order)
    (if (eq? resolved-direction 'in)
        #f
      (let ((binding (generate-out resolved-param resolved-direction order))
            (ref (get-cotype-ref resolved-param))
            (value (generate-low resolved-param resolved-direction order)))
        (if ref
            `(,binding (,ref ,value))
          `(,binding ,value)))))
  
  (define (generate-free resolved-param resolved-direction order)
    (let ((free (get-cotype-free resolved-param))
          (value (generate-low resolved-param resolved-direction order)))
      (if free
          `(,free ,value)
        #f)))
  
  (define (generate-cotype-transform generator)
    (let iter ((resolved-params resolved-params)
               (resolved-directions resolved-directions)
               (order 1))
         (if (pair? resolved-directions)
             (let ((generated (generator (car resolved-params) (car resolved-directions) order)))
               (if generated
                   (cons generated (iter (cdr resolved-params) (cdr resolved-directions) (+ order 1)))
                 (iter (cdr resolved-params) (cdr resolved-directions) (+ order 1))))
           '())))
  
  (let ((out-list (generate-cotype-transform generate-out)))
    `(lambda (coptr ,@(generate-cotype-transform generate-in))
               (let (,@(generate-cotype-transform generate-encode/enref))
                 (let ((result (,lowlevel-name coptr ,@(generate-cotype-transform generate-low))))
                   ,(if hresult?
                        (if com-interface
                            `(validate-hresult2 result coptr ,com-interface)
                          `(validate-hresult result))
                      '(begin))
                   (let (,@(generate-cotype-transform generate-ref))
                     (begin
                       ,@(generate-cotype-transform generate-free))
                     ,(if hresult?
                          (case (length out-list)
                            ((0)
                             '(unspecified))
                            ((1)
                             (car out-list))
                            (else
                             `(values ,@out-list)))
                        (if (= (length out-list) 0)
                            'result
                          `(values result ,@out-list)))))))))


(define (get-cotype-default-value cotype)
  (case (get-locator~ cotype)
    ((jazz.platform.windows.com:BSTR) (error "cotype BSTR has no default value"))
    ((jazz.platform.windows.com:BSTR*) #f)
    ((jazz.platform.windows.com:GUID) (error "cotype GUID has no default value"))
    ((jazz.platform.windows.com:GUID*) #f)
    ((jazz.platform.windows.com:VARIANT_BOOL) (error "cotype VARIANT_BOOL has no default value"))
    ((jazz.platform.windows.com:VARIANT_BOOL*) #f)
    ((jazz.platform.windows.com:VARIANT) (error "cotype VARIANT has no default value"))
    ((jazz.platform.windows.com:VARIANT*) '())
    ((jazz.platform.windows.com:IUnknown*) (error "cotype IUnknown* has no default value"))
    ((jazz.platform.windows.com:IUnknown**) #f)
    ((jazz.platform.windows.WinTypes:INT*) 0)
    ((jazz.platform.windows.WinTypes:LONG*) 0)
    (else 0)))


(define (get-cotype-encode/enref cotype)
  (case (get-locator~ cotype)
    ((jazz.platform.windows.com:BSTR) 'BSTR-encode)
    ((jazz.platform.windows.com:BSTR*) 'BSTR*-enref)
    ((jazz.platform.windows.com:GUID) 'GUID-encode)
    ((jazz.platform.windows.com:GUID*) 'GUID-encode)
    ((jazz.platform.windows.com:VARIANT_BOOL) 'VARIANT_BOOL-encode)
    ((jazz.platform.windows.com:VARIANT_BOOL*) 'VARIANT_BOOL-enref)
    ((jazz.platform.windows.com:VARIANT) 'VARIANT-encode)
    ((jazz.platform.windows.com:VARIANT*) 'VARIANT-encode)
    ((jazz.platform.windows.com:IUnknown*) #f)
    ((jazz.platform.windows.com:IUnknown**) 'IUnknown*-enref)
    ((jazz.platform.windows.WinTypes:INT*) 'INT-enref)
    ((jazz.platform.windows.WinTypes:LONG*) 'LONG-enref)
    (else #f)))


(define (get-cotype-ref cotype)
  (case (get-locator~ cotype)
    ((jazz.platform.windows.com:BSTR) 'BSTR-ref)
    ((jazz.platform.windows.com:BSTR*) 'BSTR*-ref)
    ((jazz.platform.windows.com:GUID) 'GUID-ref)
    ((jazz.platform.windows.com:GUID*) 'GUID-ref)
    ((jazz.platform.windows.com:VARIANT_BOOL) 'VARIANT_BOOL-decode)
    ((jazz.platform.windows.com:VARIANT_BOOL*) 'VARIANT_BOOL*-ref)
    ((jazz.platform.windows.com:VARIANT) 'VARIANT-ref)
    ((jazz.platform.windows.com:VARIANT*) 'VARIANT-ref)
    ((jazz.platform.windows.com:IUnknown*) #f)
    ((jazz.platform.windows.com:IUnknown**) 'IUnknown**-ref)
    ((jazz.platform.windows.WinTypes:INT*) 'INT*-ref)
    ((jazz.platform.windows.WinTypes:LONG*) 'LONG*-ref)
    (else #f)))


(define (get-cotype-free cotype)
  (case (get-locator~ cotype)
    ((jazz.platform.windows.com:BSTR) 'BSTR-free)
    ((jazz.platform.windows.com:BSTR*) 'BSTR*-free)
    ((jazz.platform.windows.com:GUID) 'GUID-free)
    ((jazz.platform.windows.com:GUID*) 'GUID-free)
    ((jazz.platform.windows.com:VARIANT_BOOL) #f)
    ((jazz.platform.windows.com:VARIANT_BOOL*) 'VARIANT_BOOL*-free)
    ((jazz.platform.windows.com:VARIANT) 'VARIANT-decode)
    ((jazz.platform.windows.com:VARIANT*) 'VARIANT-decode)
    ((jazz.platform.windows.com:IUnknown*) #f)
    ((jazz.platform.windows.com:IUnknown**) 'IUnknown**-free)
    ((jazz.platform.windows.WinTypes:INT*) 'INT*-free)
    ((jazz.platform.windows.WinTypes:LONG*) 'LONG*-free)
    (else #f)))


(syntax public com-external
  (lambda (form environment macro-environment)
    (bind (signature result-type com-interface offset) (cdr (strip-syntactic-closures form))
      (expand-com-external (current-walker) (current-resume) (current-declaration) environment signature result-type com-interface offset))))


;;;
;;;; Special
;;;


@w
(class Foo extends Expression
  
  
  (slot x getter generate))


@w
(encapsulate-class Foo)


@w
(class Goo extends Expression
  
  
  (slot expressions getter generate)
  
  
  (method override (initialize source expressions)
    (nextmethod)
    (set! expressions~self expressions)))


@w
(define-method (emit-expression (Goo expression) declaration environment backend)
  (let ((expressions (emit-expressions (get-expressions~ expression) declaration environment backend)))
    (new-code
      (emit 'and backend expression declaration environment expressions)
      Any
      (get-source~ expression))))


@w
(encapsulate-class Goo)


@w
(define (walk-goo walker resume declaration environment form-src)
  (new Goo form-src (walk-list walker resume declaration environment (cdr (source-code form-src)))))


@w
(define-walker-special goo jazz walk-goo))
