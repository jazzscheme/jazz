;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cairo Surface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.graphic.Surface jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.resource))


(class Surface extends Object
  
  
  (slot handle                                  getter generate)
  (slot context                                 getter generate)
  (slot font               <Font> initialize #f)
  (slot glyph-array               initialize #f)
  (slot glyph-array-length <fx>   initialize 0)

  
  (method override (initialize self handle . rest)
    (nextmethod self)
    (set! self.handle handle)
    (set! self.context (cairo_create handle))
    (set! self.font (registered-font 'Label)))


  (method override (destroy self)
    (destroy-glyph-array self)
    (destroy-surface self)
    (destroy-context self)
    (nextmethod self))
  
  
  (method (destroy-glyph-array self)
    (when glyph-array
      (glyph-array-free glyph-array)
      (set! glyph-array #f)))
  
  
  (method (destroy-surface self)
    (when handle
      (cairo_surface_destroy handle)
      @wait
      (let ((err (cairo-surface-status)))
        (when (/= err 0)
          (error "Cairo surface error: {t}" (cairo_status_to_string err))))
      (set! handle #f)))
  
  
  (method (destroy-context self)
    (when context
      (cairo_destroy context)
      @wait
      (let ((err (cairo-status)))
        (when (/= err 0)
          (error "Cairo context error: {t}" (cairo_status_to_string err))))
      (set! context #f)))
  
  
  (method public (cairo-finish self)
    (cairo_surface_finish handle))
  
  
  ;;;
  ;;;; Access
  ;;;


  (proclaim (warn optimizations))
  
  
  (method public (flush self)
    (cairo_surface_flush handle))
  
  
  ;;;
  ;;;; Device
  ;;;

  
  (method public virtual (painting-tree-algorithm self)
    #f)
  

  (method public (logical->device self shape <Object>)
    (typecase shape
      ((Point)
       (receive (h v) (cairo_user_to_device context (cast <fl> (get-h shape)) (cast <fl> (get-v shape)))
         (new Point (fxfloor h) (fxfloor v))))
      ((Dimension)
       (receive (width height) (cairo_user_to_device_distance context (cast <fl> (get-width shape)) (cast <fl> (get-height shape)))
         (new Dimension (fxfloor width) (fxfloor height))))
      ((Distance)
       (receive (x y) (cairo_user_to_device_distance context (cast <fl> (get-x shape)) (cast <fl> (get-y shape)))
         (new Distance (fxfloor x) (fxfloor y))))
      ((Rect)
       (receive (left top) (cairo_user_to_device context (cast <fl> (get-left shape)) (cast <fl> (get-top shape)))
         (receive (right bottom) (cairo_user_to_device context (cast <fl> (get-right shape)) (cast <fl> (get-bottom shape)))
           (new Rect (fxfloor left) (fxfloor top) (fxfloor right) (fxfloor bottom)))))))
  
  
  (method public (device->logical self shape <Object>)
    (typecase shape
      ((Point)
       (receive (h v) (cairo_device_to_user context (cast <fl> (get-h shape)) (cast <fl> (get-v shape)))
         (new Point (fxfloor h) (fxfloor v))))
      ((Dimension)
       (receive (width height) (cairo_device_to_user_distance context (cast <fl> (get-width shape)) (cast <fl> (get-height shape)))
         (new Dimension (fxfloor width) (fxfloor height))))
      ((Distance)
       (receive (x y) (cairo_device_to_user_distance context (cast <fl> (get-x shape)) (cast <fl> (get-y shape)))
         (new Distance (fxfloor x) (fxfloor y))))
      ((Rect)
       (receive (left top) (cairo_device_to_user context (cast <fl> (get-left shape)) (cast <fl> (get-top shape)))
         (receive (right bottom) (cairo_device_to_user context (cast <fl> (get-right shape)) (cast <fl> (get-bottom shape)))
           (new Rect (fxfloor left) (fxfloor top) (fxfloor right) (fxfloor bottom)))))))
  
  
  ;;;
  ;;;; Matrix
  ;;;
  
  
  (method public (with-preserved-matrix self thunk <procedure>)
    (let ((preserved-matrix (cairo_get_matrix_raw context)))
      (prog1 (thunk)
        (cairo_set_matrix_raw context preserved-matrix))))
  
  
  (method public (present-matrix self)
    (let ((matrix (cairo_get_matrix_raw context)))
      (list
        (cairo_matrix_t-xx-ref matrix)
        (cairo_matrix_t-yx-ref matrix)
        (cairo_matrix_t-xy-ref matrix)
        (cairo_matrix_t-yy-ref matrix)
        (cairo_matrix_t-x0-ref matrix)
        (cairo_matrix_t-y0-ref matrix))))
  
  
  ;;;
  ;;;; Transform
  ;;;
  
  
  (method public (with-transformation self h <fx> v <fx> transformation <foreign+> thunk <procedure>)
    (with-preserved-matrix self
      (lambda ()
        (cairo_translate context (cast <fl> h) (cast <fl> v))
        (when transformation
          (cairo_transform context transformation))
        (thunk))))
  
  
  (method public (with-pristine-transformation self thunk <procedure>)
    (with-preserved-matrix self
      (lambda ()
        (cairo_identity_matrix context)
        (thunk))))
  
  
  (method public (with-clipping-transformation self h <fx> v <fx> width <fx> height <fx> transformation <foreign+> thunk <procedure>)
    (with-transformation self h v transformation
      (lambda ()
        (with-clip self (new Rect 0 0 width height)
          thunk))))
  
  
  (method public (with-pristine-clipping-transformation self thunk <procedure>)
    (with-preserved-matrix self
      (lambda ()
        (cairo_identity_matrix context)
        (with-preserved-clipper self
          (lambda ()
            (cairo_reset_clip context)
            (thunk))))))
  
  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (get-clipper self) <Rect>
    (cairo_get_clipper context))
  
  
  (method public (set-clipper self rect <Rect>)
    (cairo_reset_clip context)
    (clip self rect))
  
  
  (method public (reset-clipper self)
    (cairo_reset_clip context))
  
  
  (method public (clip self rect <Rect>)
    (draw-rectangle self rect)
    (cairo_clip context))
  
  
  (method public (with-preserved-clipper self thunk <procedure>)
    (let ((preserved-clipper (cairo_get_clipper_raw context)))
      (prog1 (thunk)
        (cairo_set_clipper_raw context preserved-clipper))))
  
  
  (method public (with-clip self rect <Rect> thunk <procedure>)
    (with-preserved-clipper self
      (lambda ()
        (clip self rect)
        (thunk))))
  
  
  (method public (with-clipout self outer <Rect> inner <Rect> thunk <procedure>)
    (with-preserved-clipper self
      (lambda ()
        (with ((out (new Cairo-Region rect: outer))
               (in (new Cairo-Region rect: inner)))
          (combine-diff! out in)
          (draw-region self out)
          (cairo_clip context)
          (thunk)))))
  
  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method public (set-text-color self color <Color>)
    (set-color self color))
  
  
  (method public (get-char-width self n <fx>)
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let ((ch (glyph-index font n)))
        (cairo_glyph_t-index-set! gly ch)
        (cairo_glyph_t-x-set! gly 0.)
        (cairo_glyph_t-y-set! gly 0.)
        (cairo_glyph_extents context gly 1 ext)
        (let ((width (cairo_text_extents_t-x_advance-ref ext)))
          (cairo_glyph_t-free gly)
          (cairo_text_extents_t-free ext)
          width))))


  (method public (get-char-widths self (first: first <fx> 0) (last: last <fx> 255))
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let ((vec (make-f64vector (+ (- last first) 1))))
        (loop (for i from first to last)
              (do (let ((ch (glyph-index font i)))
                    (cairo_glyph_t-index-set! gly ch)
                    (cairo_glyph_t-x-set! gly 0.)
                    (cairo_glyph_t-y-set! gly 0.)
                    (cairo_glyph_extents context gly 1 ext)
                    (f64vector-set! vec i (cairo_text_extents_t-x_advance-ref ext)))))
        (cairo_glyph_t-free gly)
        (cairo_text_extents_t-free ext)
        vec)))
  

  (method public (get-text-extent self text <string>)
    (let ((extents (cairo_text_extents_t-make))
          (metrics (get-text-metrics self)))
      (cairo_text_extents context text extents)
      (prog1 (new Dimension
               (fxround (cairo_text_extents_t-x_advance-ref extents))
               (fxround (cairo_font_extents_t-height-ref metrics)))
        (cairo_text_extents_t-free extents)
        (cairo_font_extents_t-free metrics))))
    
  
  (method public (get-font-height self)
    (let ((extents (cairo_font_extents_t-make)))
      (cairo_font_extents context extents)
      (prog1 (fxround (cairo_font_extents_t-height-ref extents))
        (cairo_font_extents_t-free extents))))
  
  
  (method public (get-text-metrics self)
    (let ((info (cairo_font_extents_t-make)))
      (cairo_font_extents context info)
      info))
  

  (method public (get-text-width self text <string>) <fx>
    (let ((extents (cairo_text_extents_t-make)))
      (cairo_text_extents context text extents)
      (prog1 (fxceiling (cairo_text_extents_t-x_advance-ref extents))
        (cairo_text_extents_t-free extents))))
  
  
  (method public (draw-text self h <fx> v <fx> str <string> color <Color> (shadow-color: shadow-color {Color Black}) (enabled?: enabled? #t))
    (define (draw-at h <fx> v <fx>)
      (let ((uph (cast <fl> h))
            (font-ext (cairo_font_extents_t-make))
            (extents (cairo_text_extents_t-make))
            (len <fx> (cardinality str)))
        (when (< glyph-array-length len)
          (destroy-glyph-array self)
          (set! glyph-array (glyph-array-make (* len 2)))
          (set! glyph-array-length (* len 2)))
        (cairo_font_extents context font-ext)
        (let ((y (+ (cast <fl> v) (cairo_font_extents_t-ascent-ref font-ext))))
          (let (iter (i 0))
            (when (< i len)
              (let ((glyph (glyph-array-ref glyph-array i))
                    (ch (glyph-index font (char->integer (element str i)))))
                (cairo_glyph_t-index-set! glyph ch)
                (cairo_glyph_t-x-set! glyph uph)
                (cairo_glyph_t-y-set! glyph y)
                (cairo_glyph_extents context glyph 1 extents)
                (set! uph (+ uph (cairo_text_extents_t-x_advance-ref extents)))
                (iter (+ i 1)))))
          (cairo_show_glyphs context glyph-array len)
          (cairo_font_extents_t-free font-ext)
          (cairo_text_extents_t-free extents)
          (- (fxround uph) h))))
    (case (get-shadow font)
      ((thin)
       (set-text-color self shadow-color)
       (draw-at (+ h 1) (+ v 1)))
      ((thick)
       (set-text-color self shadow-color)
       (draw-at (- h 1) (- v 1))
       (draw-at (+ h 1) (+ v 1))
       (draw-at (+ h 2) (+ v 2))))
    (set-text-color self color)
    (draw-at h v))
  
  
  ;; should remove the subseq! and pass the bounds to draw-substring
  (method public (draw-tabbed-text self h <fx> v <fx> str <Sequence> tabs origin <fx> color <Color> highlight-color <Color+> line-height <fx>) <fx>
    ;; temp copy/pasted from above until templates
    (define (draw-substring h <fl> v <fl> str <Sequence> shadow? <bool>) <fl>
      (let ((uph h)
            (font-ext (cairo_font_extents_t-make))
            (extents (cairo_text_extents_t-make))
            (len <fx> (cardinality str)))
        (when (< glyph-array-length len)
          (destroy-glyph-array self)
          (set! glyph-array (glyph-array-make (* len 2)))
          (set! glyph-array-length (* len 2)))
        (cairo_font_extents context font-ext)
        (let ((y (+ v (cairo_font_extents_t-ascent-ref font-ext))))
          (let (iter (i 0))
            (when (< i len)
              (let ((glyph (glyph-array-ref glyph-array i))
                    (ch (glyph-index font (char->integer (element str i)))))
                (cairo_glyph_t-index-set! glyph ch)
                (cairo_glyph_t-x-set! glyph uph)
                (cairo_glyph_t-y-set! glyph y)
                (cairo_glyph_extents context glyph 1 extents)
                (set! uph (+ uph (cairo_text_extents_t-x_advance-ref extents)))
                (iter (+ i 1)))))
          (when highlight-color
            (fill-rect self (new Rect (fxround h) (fxround v) (fxround uph) (+ (fxround v) line-height)) highlight-color))
          (set-text-color self (if (not shadow?) color {Color Black}))
          (cairo_show_glyphs context glyph-array len)
          (cairo_font_extents_t-free font-ext)
          (cairo_text_extents_t-free extents)
          (- uph h))))
    
    (define (draw-at h <fx> v <fx> shadow? <bool>)
      (let ((uph (cast <fl> h))
            (v (cast <fl> v))
            (beginning 0)
            (stops tabs))
        (loop (for i from 0 below (cardinality str))
              (do (when (eqv? (element str i) #\tab)
                    (when (/= beginning i)
                      (set! uph (+ uph (draw-substring uph v (subseq! str beginning i) shadow?))))
                    (while (<= (+ origin (cast <fx> (car stops))) (+ uph 1))
                      (set! stops (cdr stops)))
                    (set! uph (cast <fl> (+ origin (cast <fx> (car stops)))))
                    (set! beginning (+ i 1))
                    (set! stops (cdr stops)))))
        (- (fxround (+ uph (draw-substring uph v (subseq! str beginning (cardinality str)) shadow?)))
           h)))
    
    (case (get-shadow font)
      ((thin)
       (draw-at (+ h 1) (+ v 1) #t))
      ((thick)
       (draw-at (- h 1) (- v 1) #t)
       (draw-at (+ h 1) (+ v 1) #t)
       (draw-at (+ h 2) (+ v 2) #t)))
    (draw-at h v #f))

  
  ;;;
  ;;;; Region
  ;;;
  
  
  (method public (fill-region self region <Cairo-Region> color)
    (set-color self color)
    (draw-region self region)
    (fill self))
  
  
  (method public (gradient-fill self bounds <Rect> stops (direction: direction 'horizontal))
    (let* ((left (get-left bounds))
           (top (get-top bounds))
           (right (get-right bounds))
           (bottom (get-bottom bounds))
           (horzmid (fxfloor/ (- right left) 2))
           (vertmid (fxfloor/ (- bottom top) 2))
           (pattern (case direction
                      ((horizontal)
                       (create-linear-pattern left vertmid right vertmid))
                      ((vertical)
                       (create-linear-pattern horzmid top horzmid bottom)))))
      (for-each (lambda (stop)
                  (bind (offset color) stop
                    (add-color-stop pattern offset color)))
                stops)
      (cairo_set_source context pattern)
      (fill self)
      (cairo_pattern_destroy pattern)))
  
  
  (method public (gradient-fill-rect self rect <Rect> stops (direction: direction 'horizontal))
    (draw-rectangle self rect)
    (gradient-fill self rect stops direction: direction))
  
  
  (method public (ellipse self rect <Rect> outside inside)
    (let ((left (get-left rect))
          (right (get-right rect))
          (top (get-top rect))
          (bottom (get-bottom rect)))
      (let ((w (- right left))
            (h (- bottom top)))
        (let ((tx (+ (cast <fl> left) (/ (cast <fl> w) 2.)))
              (ty (+ (cast <fl> top) (/ (cast <fl> h) 2.))))
          (cairo_translate context tx ty)
          (cairo_scale context (/ (cast <fl> w) 2.) (/ (cast <fl> h) 2.))
          (cairo_arc context 0. 0. 1. 0. PI*2)
          (cairo_scale context (/ 2. w) (/ 2. h))
          (cairo_translate context (- tx) (- ty)))))
    (when outside
      (if (is? outside Color)
          (set-color self outside)
        (outside self)))
    (if (not inside)
        (stroke self)
      (stroke-preserve self)
      (if (is? inside Color)
          (set-color self inside)
        (inside self))
      (fill self)))
  
  
  (method public (ellipse$fl$ self rect <Rect$fl$> outside inside)
    (let ((left (get-left rect))
          (right (get-right rect))
          (top (get-top rect))
          (bottom (get-bottom rect)))
      (let ((w (- right left))
            (h (- bottom top)))
        (let ((tx (+ left (/ w 2.)))
              (ty (+ top (/ h 2.))))
          (cairo_translate context tx ty)
          (cairo_scale context (/ w 2.) (/ h 2.))
          (cairo_arc context 0. 0. 1. 0. PI*2)
          (cairo_scale context (/ 2. w) (/ 2. h))
          (cairo_translate context (- tx) (- ty)))))
    (when outside
      (if (is? outside Color)
          (set-color self outside)
        (outside self)))
    (if (not inside)
        (stroke self)
      (stroke-preserve self)
      (if (is? inside Color)
          (set-color self inside)
        (inside self))
      (fill self)))

  
  (method public (draw-surface self handle x <fl> y <fl> (alpha: alpha #f))
    (set-source-surface self handle x y)
    (if alpha
        (paint-with-alpha self alpha)
      (paint self)))
  
  
  (method public (fill-background self rect background)
    (typecase background
      ((Color) (fill-rect self rect background))
      ((Gradient) (fill-gradient self rect background))
      ((Texture) (fill-texture self rect background))
      ((List) (for-each (lambda (background)
                          (fill-background self rect background))
                        background))
      (else (error "Unable to fill background with {s}" background))))
  
  
  (method public (fill-gradient self rect <Rect> gradient <Gradient>)
    (let ((parts (get-parts gradient)))
      (let ((stops (if (every? (lambda (part)
                                 (is? part Color))
                               parts)
                       (let ((stop 0.)
                             (incr (/ 1. (- (fl (length parts)) 1.))))
                         (map (lambda (color)
                                (prog1 (list stop color)
                                  (increase! stop incr)))
                              parts))
                     parts))
            (direction (get-kind gradient)))
        (gradient-fill-rect self rect stops direction: direction))))
  
  
  (method public (fill-texture self rect <Rect> texture <Texture>)
    (define (texture-image)
      (let ((content (get-content texture)))
        (typecase content
          ((Image-Resource) (new Image resource: content))
          ((File) (and (exists? content) (new Image moniker: content))))))
    
    (with ((image (texture-image)))
      (if (not image)
          (fill-rect self rect {Color Red})
        (let ((mode (get-mode texture))
              (position (get-attribute texture 'position))
              (size (get-attribute texture 'size)))
          (fill-image self rect image mode: mode position: position size: size)))))
  
  
  (method public (fill-image self rect <Rect> image <Image> (mode: mode 'stretch) (position: position #f) (size: size #f) (alpha: alpha #f))
    (define (draw-position)
      (let ((pos <Point> (or position {Point 0 0})))
        (draw-at image self #f (get-h pos) (get-v pos) alpha: alpha)))
    
    (define (draw-center)
      (let ((pos <Point> (center (image-size image) (rect-size rect))))
        (draw-at image self #f (get-h pos) (get-v pos) alpha: alpha)))
    
    (define (draw-fill)
      (draw-scale 'fill))
    
    (define (draw-fit)
      (draw-scale 'fit))
    
    (define (draw-scale mode)
      (let ((image-size (image-size image))
            (rect-size (rect-size rect)))
        (let ((ratio (fit-dimensions image-size rect-size mode)))
          (let ((new-width (fxround (* (cast <fl> (get-width image-size)) ratio)))
                (new-height (fxround (* (cast <fl> (get-height image-size)) ratio))))
            (with ((resized (new Image handle: (resize-image (get-handle image) new-width new-height))))
              (let ((pos <Point> (center (new Dimension new-width new-height) rect-size)))
                (draw-at resized self #f (get-h pos) (get-v pos) alpha: alpha)))))))
    
    (define (draw-stretch)
      (with ((resized <Image> (new Image handle: (resize-image (get-handle image) (rect-width rect) (rect-height rect)))))
        (draw-at resized self #f 0 0 alpha: alpha)))
    
    (define (draw-tile)
      (let ((handle (get-handle image)))
        (set-source-surface self handle 0 0)
        (cairo_pattern_set_extend (get-source self) CAIRO_EXTEND_REPEAT)
        (cairo_rectangle context (cast <fl> (get-left rect)) (cast <fl> (get-top rect)) (cast <fl> (rect-width rect)) (cast <fl> (rect-height rect)))
        (cairo_fill context)))
    
    (case mode
      ((position) (draw-position))
      ((center) (draw-center))
      ((fill) (draw-fill))
      ((fit) (draw-fit))
      ((stretch) (draw-stretch))
      ((tile) (draw-tile))
      (else (error "Unknown fill mode: {s}" mode))))
  
  
  ;;;
  ;;;; Control
  ;;;
  
  
  (method public (draw-scroll-bar self rect <Rect> direction)
    (draw-rectangle self rect)
    (set-color self {Color Draw-Edge-Light})
    (fill self)
    (draw-edge self rect inner: 'raised outer: 'raised edges: 'rectangle)
    (let ((dh (cond ((eq? direction 'left) 1)
                    ((eq? direction 'right) 2)
                    ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)))
          (dv (cond ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)
                    (else 0))))
      (set-color self {Color Black})
      (draw-arrow-tip self (+ (get-left rect) 3 dh) (+ (get-top rect) 4 dv) 3 direction)))
   
  
  (method public (draw-caption self rect <Rect> type (pushed? #f) (in-rectangle? #t))
    (set-color self {Color Dark})
    (set-line-width self 1)
    (when in-rectangle?
      (draw-rectangle self rect)
      (set-color self {Color Draw-Edge-Light})
      (fill self)
      (if pushed?
          (begin
            (draw-edge self rect inner: 'sunken edges: 'rectangle)
            (draw-edge self (new Rect (+ (get-left rect) 1) (+ (get-top rect) 1) (- (get-right rect) 1) (- (get-bottom rect) 1)) outer: 'sunken edges: 'rectangle))
        (draw-edge self rect inner: 'raised outer: 'raised edges: 'rectangle))
      (set-color self {Color Black}))
    (let ((rect (if pushed? (new Rect (+ (get-left rect) 1) (+ (get-top rect) 1) (+ (get-right rect) 1) (+ (get-bottom rect) 1)) rect)))
      (cond ((eq? type 'close)
             (unless in-rectangle?
               (set-color self {Color red: 90 green: 90 blue: 90}))
             (move-to self (+ (get-left rect) 4) (+ (get-top rect) 3))
             (line-to self (- (get-right rect) 4) (- (get-bottom rect) 4))
             (move-to self (- (get-right rect) 4) (+ (get-top rect) 3))
             (line-to self (+ (get-left rect) 4) (- (get-bottom rect) 4))
             (stroke self))
            ((eq? type 'minimize)
             (move-to self (+ (get-left rect) 4) (- (get-bottom rect) 5))
             (line-to self (- (get-right rect) 6) (- (get-bottom rect) 5))
             (move-to self (+ (get-left rect) 4) (- (get-bottom rect) 4))
             (line-to self (- (get-right rect) 6) (- (get-bottom rect) 4))
             (stroke self))
            ((eq? type 'restore)
             (move-to self (+ (get-left rect) 3) (- (cast <fl> (- (get-bottom rect) 3)) 0.5))
             (line-to-rel self 5.5 0)
             (line-to-rel self 0 -4)
             (line-to-rel self -5.5 0)
             (move-to-rel self 0 -1)
             (line-to-rel self 6 0)
             (move-to-rel self -5.5 0)
             (line-to-rel self 0 5)
             (move-to self (+ (get-left rect) 8) (- (cast <fl> (- (get-bottom rect) 6)) 0.5))
             (line-to-rel self 2.5 0)
             (line-to-rel self 0 -4)
             (line-to-rel self -5.5 0)
             (move-to-rel self 0 -1)
             (line-to-rel self 6 0)
             (move-to-rel self -5.5 0)
             (line-to-rel self 0 3)
             (stroke self))
            ((eq? type 'maximize)
             (move-to self (+ (get-left rect) 3) (- (cast <fl> (- (get-bottom rect) 3)) 0.5))
             (line-to-rel self 8.5 0)
             (line-to-rel self 0 -7)
             (line-to-rel self -8.5 0)
             (move-to-rel self 0 -1)
             (line-to-rel self 9 0)
             (move-to-rel self -8.5 0)
             (line-to-rel self 0 7.5)
             (stroke self)))))
  
  
  (method public (draw-radio-button self rect <Rect> (radio-background: radio-background #f) (inactive?: inactive? #f) (selected?: selected? #f))
    (let ((x (+ (get-left rect) (/ (cast <fl> (- (get-right rect) (get-left rect))) 2)))
          (y (+ (get-top rect) (/ (cast <fl> (- (get-bottom rect) (get-top rect))) 2)))
          (r (/ (cast <fl> (- (get-right rect) (get-left rect))) 2)))
      (cairo_arc context x y r 0. PI*2)
      (set-color self (if inactive?
                     {Color Medium}
                   (or radio-background {Color White})))
      (fill self)
      (set-line-width self 1)
      (cairo_arc context x y r (* 3 PI/4) (* 7 PI/4))
      (set-color self {Color Draw-Edge-Medium})
      (stroke self)
      (cairo_arc context x y (- r 1) (* 3 PI/4) (* 7 PI/4))
      (set-color self {Color Draw-Edge-Dark})
      (stroke self)
      (cairo_arc context x y r (* 7 PI/4) (* 3 PI/4))
      (set-color self {Color White})
      (stroke self)
      (cairo_arc context x y (- r 1) (* 7 PI/4) (* 3 PI/4))
      (set-color self {Color Draw-Edge-Light})
      (stroke self)
      (when selected?
        (cairo_arc context x y (/ r 3) 0. PI*2)
        (set-color self {Color Black})
        (fill self))))
  
  
  (method public (draw-push-button self rect <Rect> (pushed? #f))
    (set-line-width self 1)
    (if pushed?
        (begin
          (set-color self {Color Draw-Edge-Dark})
          (line self (get-left rect) (get-top rect) (- (get-right rect) 1) (get-top rect))
          (line self (get-left rect) (get-top rect) (get-left rect) (- (get-bottom rect) 1))
          (set-color self {Color Draw-Edge-Medium})
          (line self (+ (get-left rect) 1) (+ (get-top rect) 1) (- (get-right rect) 2) (+ (get-top rect) 1))
          (line self (+ (get-left rect) 1) (+ (get-left rect) 1) (+ (get-left rect) 1) (- (get-bottom rect) 2))
          (set-color self {Color White})
          (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect))
          (line self (- (get-right rect) 1) (- (get-bottom rect) 1) (get-left rect) (- (get-bottom rect) 1)))
      (set-color self {Color White})
      (move-to self (get-left rect) (- (get-bottom rect) 1))
      (line-to-no-stroke self (get-left rect) (get-top rect))
      (line-to-no-stroke self (- (get-right rect) 1) (get-top rect))
      (stroke self)
      (set-line-width self 1)
      (set-color self {Color Draw-Edge-Dark})
      (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect))
      (line self (- (get-right rect) 1) (- (get-bottom rect) 1) (get-left rect) (- (get-bottom rect) 1))
      (set-color self {Color Draw-Edge-Medium})
      (line self (- (get-right rect) 2) (+ (get-top rect) 1) (- (get-right rect) 2) (- (get-bottom rect) 1))
      (line self (- (get-right rect) 2) (- (get-bottom rect) 2) (+ (get-left rect) 1) (- (get-bottom rect) 2))))
  
  
  ;;;
  ;;;; Surface
  ;;;
  
  
  (method public (set-source-surface self surface/handle x <fl> y <fl>)
    (cairo_set_source_surface context (if (is? surface/handle Surface)
                                          (get-handle surface/handle)
                                        surface/handle)
      x
      y))
  
  
  (method public (blit-surface self surface (destination: destination <Point> {Point 0 0}))
    (set-source-surface self surface (cast <fl> (get-h destination)) (cast <fl> (get-v destination)))
    (paint self))
  
  
  (method public (blit-surface-ext self surface h <fl> v <fl> width <fl> height <fl> destination-h <fl> destination-v <fl>)
    (set-source-surface self surface (- destination-h h) (- destination-v v))
    (cairo_rectangle context destination-h destination-v width height)
    (cairo_fill context))
  
  
  (method public (set-mask-surface self surface)
    (cairo_mask_surface context (get-handle surface) 0. 0.))
  
  
  ;;;
  ;;;; Select
  ;;;
  
  
  (method public (set-font self font <Font>)
    (set! self.font font)
    (cairo_set_scaled_font context (get-scaled-font font)))
  
  
  (method public (set-style self style)
    (case style
      ((solid) (cairo_set_solid context))
      ((alternate) (cairo_set_alternate context))
      (else (error "Unknown style: {s}" style))))
  
  
  (method public (draw-edge self rect <Rect> (edges: edges 'rectangle) (inner: inner #f) (outer: outer #f))
    (let ((edges (if (eq? edges 'rectangle) '(left right top bottom) edges)))
      (set-line-width self 1)
      (when (memq? 'top edges)
        (cond ((eq? inner 'raised)
               (set-color self {Color White})
               (if outer
                   (line self (get-left rect) (+ (get-top rect) 1) (get-right rect) (+ (get-top rect) 1))
                 (line self (get-left rect) (get-top rect) (get-right rect) (get-top rect))))
              ((eq? inner 'sunken)
               (set-color self {Color Draw-Edge-Dark})
               (if outer
                   (line self (get-left rect) (+ (get-top rect) 1) (get-right rect) (+ (get-top rect) 1))
                 (line self (get-left rect) (get-top rect) (get-right rect) (get-top rect))))))
      (when (memq? 'left edges)
        (cond ((eq? inner 'raised)
               (set-color self {Color White})
               (if outer
                   (line self (+ (get-left rect) 1) (get-top rect) (+ (get-left rect) 1) (get-bottom rect))
                 (line self (get-left rect) (get-top rect) (get-left rect) (get-bottom rect))))
              ((eq? inner 'sunken)
               (set-color self {Color Draw-Edge-Dark})
               (if outer
                   (line self (+ (get-left rect) 1) (get-top rect) (+ (get-left rect) 1) (get-bottom rect))
                 (line self (get-left rect) (get-top rect) (get-left rect) (get-bottom rect))))))
      (when (memq? 'right edges)
        (cond ((eq? inner 'raised)
               (set-color self {Color Draw-Edge-Medium})
               (if outer
                   (line self (- (get-right rect) 2) (get-top rect) (- (get-right rect) 2) (get-bottom rect))
                 (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect))))
              ((eq? inner 'sunken)
               (set-color self (new Color red: 241 green: 239 blue: 226))
               (if outer
                   (line self (- (get-right rect) 2) (get-top rect) (- (get-right rect) 2) (get-bottom rect))
                 (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect))))))
      (when (memq? 'bottom edges)
        (cond ((eq? inner 'raised)
               (set-color self {Color Draw-Edge-Medium})
               (if outer
                   (line self (get-left rect) (- (get-bottom rect) 2) (get-right rect) (- (get-bottom rect) 2))
                 (line self (get-left rect) (- (get-bottom rect) 1) (get-right rect) (- (get-bottom rect) 1))))
              ((eq? inner 'sunken)
               (set-color self {Color Draw-Edge-Light})
               (if outer
                   (line self (get-left rect) (- (get-bottom rect) 2) (get-right rect) (- (get-bottom rect) 2))
                 (line self (get-left rect) (- (get-bottom rect) 1) (get-right rect) (- (get-bottom rect) 1))))))
      (when (memq? 'top edges)
        (cond ((eq? outer 'raised)
               (set-color self {Color Draw-Edge-Light})
               (line self (get-left rect) (get-top rect) (get-right rect) (get-top rect)))
              ((eq? outer 'sunken)
               (set-color self {Color Draw-Edge-Medium})
               (line self (get-left rect) (get-top rect) (get-right rect) (get-top rect)))))
      (when (memq? 'left edges)
        (cond ((eq? outer 'raised)
               (set-color self {Color Draw-Edge-Light})
               (line self (get-left rect) (get-top rect) (get-left rect) (get-bottom rect)))
              ((eq? outer 'sunken)
               (set-color self {Color Draw-Edge-Medium})
               (line self (get-left rect) (get-top rect) (get-left rect) (get-bottom rect)))))
      (when (memq? 'right edges)
        (cond ((eq? outer 'raised)
               (set-color self {Color Draw-Edge-Dark})
               (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect)))
              ((eq? outer 'sunken)
               (set-color self {Color White})
               (line self (- (get-right rect) 1) (get-top rect) (- (get-right rect) 1) (get-bottom rect)))))
      (when (memq? 'bottom edges)
        (cond ((eq? outer 'raised)
               (set-color self {Color Draw-Edge-Dark})
               (line self (get-left rect) (- (get-bottom rect) 1) (get-right rect) (- (get-bottom rect) 1)))
              ((eq? outer 'sunken)
               (set-color self {Color White})
               (line self (get-left rect) (- (get-bottom rect) 1) (get-right rect) (- (get-bottom rect) 1)))))))
  

  (method public (fill-rect self rect <Rect> color <Color>)
    (set-color self color)
    (draw-rectangle self rect)
    (fill self))
  
  
  (method public (fill-insets self rect <Rect> insets <Rect> color <Color>)
    (let ((l (get-left rect))
          (t (get-top rect))
          (r (get-right rect))
          (b (get-bottom rect))
          (li (get-left insets))
          (ti (get-top insets))
          (ri (get-right insets))
          (bi (get-bottom insets)))
      (let ((tti (+ t ti))
            (bbi (- b bi)))
        (set-color self color)
        (draw-rectangle self (new Rect l t r tti))
        (draw-rectangle self (new Rect l bbi r b))
        (draw-rectangle self (new Rect l tti (+ l li) bbi))
        (draw-rectangle self (new Rect (- r ri) tti r bbi))
        (fill self))))
  
  
  (method public (draw-check self h <fx> v <fx>)
    (set-line-width self 1)
    (line self (+ h 0) (+ v 2) (+ h 0) (+ v 5))
    (line self (+ h 1) (+ v 3) (+ h 1) (+ v 6))
    (line self (+ h 2) (+ v 4) (+ h 2) (+ v 7))
    (line self (+ h 3) (+ v 3) (+ h 3) (+ v 6))
    (line self (+ h 4) (+ v 2) (+ h 4) (+ v 5))
    (line self (+ h 5) (+ v 1) (+ h 5) (+ v 4))
    (line self (+ h 6) (+ v 0) (+ h 6) (+ v 3))
    (stroke self))
  
  
  (method public (draw-raised self rect <Rect>)
    (set-color self {Color Light-Background})
    (set-line-width self 1)
    (move-to self (get-left rect) (- (get-bottom rect) 1))
    (line-to-no-stroke self (get-left rect) (get-top rect))
    (line-to-no-stroke self (- (get-right rect) 1) (get-top rect))
    (stroke self)
    (set-color self {Color Dark})
    (move-to self (- (get-right rect) 1) (get-top rect))
    (line-to-no-stroke self (- (get-right rect) 1) (- (get-bottom rect) 1))
    (line-to self (get-left rect) (- (get-bottom rect) 1)))
  
  
  (method public (draw-arrow-tip self h v size <fx> direction <symbol>)
    (set-line-width self 1)
    (case direction
      ((up)
       (let ((width (- (+ size size) 1)))
         (increase! v (- size 1))
         (for-each (lambda (n)
                     (line self h v (+ h width) v)
                     (increase! h)
                     (decrease! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((down)
       (let ((width (- (+ size size) 1)))
         (for-each (lambda (n)
                     (line self h v (+ h width) v)
                     (increase! h)
                     (increase! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((left)
       (let ((height (- (+ size size) 1)))
         (increase! h (- size 1))
         (for-each (lambda (n)
                     (line self h v h (+ v height))
                     (decrease! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))
      ((right)
       (let ((height (- (+ size size) 1)))
         (for-each (lambda (n)
                     (line self h v h (+ v height))
                     (increase! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))))

  
  (method public (draw-sorted self h v offset title sorted)
    (when sorted
      (set-color self {Color Dark})
      (let ((h (+ (- h 11) offset))
            (v (+ (+ v 7) offset))
            (size 4))
        (case sorted
          ((ascending) (draw-arrow-tip self h v size 'up))
          ((descending #f) (draw-arrow-tip self h v size 'down))))))
  
  
  (method public (draw-filtered self h v offset title filtered)
    
    (when filtered
      (set-color self {Color Dark})
      (let ((extent (get-text-extent self title)))
        (let ((h (+ (get-width extent) h 6 offset))
              (v (+ v 5 offset))
              (size 4))
          (draw-arrow-tip self h v size 'up)
          (draw-arrow-tip self h (+ v 4) size 'down)))))
  
  
  (method public (draw-highlighted self h v offset title highlighted color)
    (when highlighted
      (set-line-width self 1)
      (set-color self color)
      (let ((extent (get-text-extent self title)))
        (let ((h (+ (get-width extent) h 6 offset -0.5))
              (v (+ v 5 offset))
              (size 4))
          (move-to self h (+ v 4))
          (line-to-no-stroke self (+ h 4) v)
          (line-to-no-stroke self (+ h 8) (+ v 4))
          (move-to self h (+ v 4))
          (line-to-no-stroke self (+ h 4) (+ v 8))
          (line-to-no-stroke self (+ h 8) (+ v 4))
          (stroke self)))))
  
  
  ;;;
  ;;;; Printing
  ;;;
  
  @a
  (cond-expand
    (windows
      (method public (start-doc rec)
        (StartDoc (cairo_win32_surface_get_dc handle) rec))
  
  
      (method public (end-doc)
        (EndDoc (cairo_win32_surface_get_dc handle)))
  
  
      (method public (start-page)
        (StartPage (cairo_win32_surface_get_dc handle)))
  
  
      (method public (end-page)
        (EndPage (cairo_win32_surface_get_dc handle))))
    (else))
  
  
  (method public virtual (show-page self)
    (cairo_show_page context))
  
  
  (method (with-outside/inside self outside inside outside-proc inside-proc)
    (when inside
      (inside-proc)
      (if (is? inside Color)
          (set-color self inside)
        (inside self))
      (fill self))
    (when outside
      (outside-proc)
      (if (is? outside Color)
          (set-color self outside)
        (outside self))
      (stroke self)))
  
  
  (method virtual public (frame-rect self rect <Rect> color)
    (set-line-width self 1)
    (set-color self color)
    (draw-rectangle$fl$ self
      (new Rect$fl$
        (+ (get-left rect) 0.5)
        (+ (get-top rect) 0.5)
        (- (get-right rect) 0.5)
        (- (get-bottom rect) 0.5)))
    (stroke self))
  
  
  (method public (frame-partial-rect self rect <Rect> sides color)
    (set-line-width self 1)
    (set-color self color)
    (let ((left (get-left rect))
          (top (get-top rect))
          (right (get-right rect))
          (bottom (get-bottom rect)))
      (when (memq? 'left sides)
        (move-to self left top)
        (line-to self left bottom))
      (when (memq? 'top sides)
        (move-to self left top)
        (line-to self right top))
      (when (memq? 'right sides)
        (move-to self (- right 1) top)
        (line-to self (- right 1) (- bottom 1)))
      (when (memq? 'bottom sides)
        (move-to self left (- bottom 1))
        (line-to self right (- bottom 1)))))
  
  
  (method public (frame-round-rect self rect <Rect> color)
    (set-line-width self 1)
    (set-color self color)
    (let ((left (get-left rect))
          (top (get-top rect))
          (right (get-right rect))
          (bottom (get-bottom rect)))
      (move-to self (+ left 1) top)
      (line-to self (- right 1) top)
      (move-to self (- right 1) (+ top 1))
      (line-to self (- right 1) (- bottom 1))
      (move-to self left (+ top 1))
      (line-to self left (- bottom 1))
      (move-to self (+ left 1) (- bottom 1))
      (line-to self (- right 1) (- bottom 1))))
  
  
  (method public (rectangle self rect <Rect> outside inside)
    (with-outside/inside self outside inside
      (lambda ()
        (draw-rectangle$fl$ self (inflate-rect rect -0.5 -0.5)))
      (lambda ()
        (draw-rectangle$fl$ self (rect->rect$fl$ rect)))))
  
  
  ;;;
  ;;;; Cairo
  ;;;
  
  
  (method public (cairo-move-to self h <fl> v <fl>)
    (cairo_move_to context h v))
  
  
  (method public (cairo-line-to self h <fl> v <fl>)
    (cairo_line_to context h v))
  
  
  (method public (arc self hc <fl> vc <fl> radius <fl> angle1 <fl> angle2 <fl>)
    (cairo_arc context hc vc radius angle1 angle2))
  
  
  (method public (arc-negative self hc <fl> vc <fl> radius <fl> angle1 <fl> angle2 <fl>)
    (cairo_arc_negative context hc vc radius angle1 angle2))
  
  
  (method public (curve-to-relative self dx1 <fl> dy1 <fl> dx2 <fl> dy2 <fl> dx3 <fl> dy3 <fl>)
    (cairo_rel_curve_to context dx1 dy1 dx2 dy2 dx3 dy3))
  
  
  (method public (close-path self)
    (cairo_close_path context))
  
  
  (definition (create-linear-pattern sh <fl> sv <fl> eh <fl> ev <fl>)
    (cairo_pattern_create_linear sh sv eh ev))
  
  
  (method public (get-source self)
    (cairo_get_source context))
  
  
  (method public (set-source self pattern)
    (cairo_set_source context pattern))
  
  
  (method public (translate self th <fl> tv <fl>)
    (cairo_translate context th tv))
  
  
  (method public (scale self sh <fl> sv <fl>)
    (cairo_scale context sh sv))
  
  
  (method public (rotate self angle <fl>)
    (cairo_rotate context angle))
  
  
  ;;;
  ;;;; Primitives
  ;;;
  
  
  (method public (move-to self h <fl> v <fl>)
    (cairo_move_to context h v))
  
  
  (method public (line-path self h <fl> v <fl>)
    (cairo_line_to context h v))
  
  
  (method public (line-to self h <fl> v <fl>)
    (line-to-no-stroke self h v)
    (stroke self))
  
  
  (method public (line-to-preserve self h <fl> v <fl>)
    (line-to-no-stroke self h v)
    (stroke-preserve self))
  

  (method public (line-to-no-stroke self h <fl> v <fl>)
    (let ((pt (cairo_current_point context)))
      (let ((cur-h (get-h pt))
            (cur-v (get-v pt)))
        (let ((h (if (= cur-h h)
                     (begin
                       (move-to self (+ cur-h 0.5) cur-v)
                       (+ h 0.5))
                   h))
              (v (if (= cur-v v)
                     (begin
                       (move-to self cur-h (+ cur-v 0.5))
                       (+ v 0.5))
                   v)))
          (cairo_line_to context h v)))))
  
  
  (method public (line-to-rel self dh <fl> dv <fl>)
    (cairo_rel_line_to context dh dv))
  
  
  (method public (move-to-rel self dh <fl> dv <fl>)
    (cairo_rel_move_to context dh dv))
  
  
  (method public (line self h v dest-h dest-v)
    (move-to self h v)
    (line-to self dest-h dest-v))
  
  
  (method public (pixel-to self h <fl> v <fl>)
    (set-line-width self 1)
    (move-to self h v)
    (line-to self (+ h 1.) v))
  
  
  (method public (set-line-width self w <fl>)
    (cairo_set_line_width context w))
  
  
  (method public (get-line-width self)
    (cairo_get_line_width context))
  
  
  (method public (get-operator self)
    (cairo_get_operator context))
  
  
  (method public (set-operator self op)
    (cairo_set_operator context op))
  
  
  (method public (get-antialias self)
    (cairo_get_antialias context))
  
  
  (method public (set-antialias self antialias)
    (cairo_set_antialias context antialias))
  
  
  (method public (stroke self)
    (cairo_stroke context))
  
  
  (method public (stroke-preserve self)
    (cairo_stroke_preserve context))
  
  
  (method public (fill self)
    (cairo_fill context))
  
  
  (method public (fill-preserve self)
    (cairo_fill_preserve context))
  
  
  (method public (paint self)
    (cairo_paint context))
  
  
  (method public (paint-with-alpha self alpha <fl>)
    (cairo_paint_with_alpha context alpha))
  
  
  (method public (clear self)
    (let ((preserved (get-operator self)))
     (set-operator self CAIRO_OPERATOR_CLEAR)
     (paint self)
     (set-operator self preserved)))

  
  (method public (draw-rectangle self rect <Rect>)
    (let ((x (get-left rect))
          (y (get-top rect)))
      (let ((w (- (get-right rect) x))
            (h (- (get-bottom rect) y)))
        (cairo_rectangle context
                         (cast <fl> x)
                         (cast <fl> y)
                         (cast <fl> w)
                         (cast <fl> h)))))

  
  (method public (draw-rectangle$fl$ self rect <Rect$fl$>)
    (let ((x (get-left rect))
          (y (get-top rect)))
      (let ((w (- (get-right rect) x))
            (h (- (get-bottom rect) y)))
        (cairo_rectangle context
                         x
                         y
                         w
                         h))))
  
  
  (method public (draw-region self region)
    (iterate-rectangles region
      (lambda (rect)
        (draw-rectangle self rect))))
  
  
  (method public (set-color self color <Color>)
    (let ((r (get-red color))
          (g (get-green color))
          (b (get-blue color))
          (a (get-alpha color)))
      (cairo_set_source_rgba context r g b a)))
  
  
  (definition (add-color-stop pattern offset <fl> color <Color>)
    (let ((r (get-red color))
          (g (get-green color))
          (b (get-blue color))
          (a (get-alpha color)))
      (cairo_pattern_add_color_stop_rgba pattern offset r g b a)))
  
  
  (method public (export-to-png self file <File>)
    (cairo_surface_write_to_png handle (parse file)))
  

  (method public (cairo-status self)
    (cairo_status context))
  
  
  (method public (cairo-surface-status self)
    (cairo_surface_status handle))
  
  
  (proclaim (not warn optimizations))))
