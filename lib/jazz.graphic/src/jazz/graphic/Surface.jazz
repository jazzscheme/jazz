;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cairo Surface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.graphic.Surface jazz


(import (jazz.geometry)
        (jazz.graphic)
        (jazz.graphic.image)
        (jazz.io)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.cairo))


(class Surface extends Object
  
  
  (slot handle                                  getter generate)
  (slot context                                 getter generate)
  (slot font               <Font> initialize #f)
  (slot glyph-array               initialize #f)
  (slot glyph-array-length <fx>   initialize 0)

  
  (method override (initialize handle . rest)
    (nextmethod)
    (set! handle~self handle)
    (set! context~self (cairo_create handle))
    (destroy-mandatory))


  (method override (destroy)
    (destroy-glyph-array)
    (destroy-surface)
    (destroy-context)
    (nextmethod))
  
  
  (method (destroy-glyph-array)
    (when glyph-array
      (glyph-array-free glyph-array)
      (set! glyph-array #f)))
  
  
  (method (destroy-surface)
    (when handle
      (cairo_surface_destroy handle)
      @wait
      (let ((err (cairo-surface-status)))
        (when (/= err 0)
          (error "Cairo surface error: {t}" (cairo_status_to_string err))))
      (set! handle #f)))
  
  
  (method (destroy-context)
    (when context
      (cairo_destroy context)
      @wait
      (let ((err (cairo-status)))
        (when (/= err 0)
          (error "Cairo context error: {t}" (cairo_status_to_string err))))
      (set! context #f)))
  
  
  (method public (cairo-finish)
    (cairo_surface_finish handle))
  
  
  ;;;
  ;;;; Access
  ;;;


  (proclaim (warn optimizations))
  
  
  ;;;
  ;;;; Device
  ;;;

  
  (method public virtual (painting-tree-algorithm)
    #f)
  

  (method public (logical->device shape <Object>)
    (typecase shape
      ((Point)
       (receive (h v) (cairo_user_to_device context (cast <fl> (get-h~ shape)) (cast <fl> (get-v~ shape)))
         (new Point (fxfloor h) (fxfloor v))))
      ((Dimension)
       (receive (width height) (cairo_user_to_device_distance context (cast <fl> (get-width~ shape)) (cast <fl> (get-height~ shape)))
         (new Dimension (fxfloor width) (fxfloor height))))
      ((Distance)
       (receive (x y) (cairo_user_to_device_distance context (cast <fl> (get-x~ shape)) (cast <fl> (get-y~ shape)))
         (new Distance (fxfloor x) (fxfloor y))))
      ((Rect)
       (receive (left top) (cairo_user_to_device context (cast <fl> (get-left~ shape)) (cast <fl> (get-top~ shape)))
         (receive (right bottom) (cairo_user_to_device context (cast <fl> (get-right~ shape)) (cast <fl> (get-bottom~ shape)))
           (new Rect (fxfloor left) (fxfloor top) (fxfloor right) (fxfloor bottom)))))))
  
  
  (method public (device->logical shape <Object>)
    (typecase shape
      ((Point)
       (receive (h v) (cairo_device_to_user context (cast <fl> (get-h~ shape)) (cast <fl> (get-v~ shape)))
         (new Point (fxfloor h) (fxfloor v))))
      ((Dimension)
       (receive (width height) (cairo_device_to_user_distance context (cast <fl> (get-width~ shape)) (cast <fl> (get-height~ shape)))
         (new Dimension (fxfloor width) (fxfloor height))))
      ((Distance)
       (receive (x y) (cairo_device_to_user_distance context (cast <fl> (get-x~ shape)) (cast <fl> (get-y~ shape)))
         (new Distance (fxfloor x) (fxfloor y))))
      ((Rect)
       (receive (left top) (cairo_device_to_user context (cast <fl> (get-left~ shape)) (cast <fl> (get-top~ shape)))
         (receive (right bottom) (cairo_device_to_user context (cast <fl> (get-right~ shape)) (cast <fl> (get-bottom~ shape)))
           (new Rect (fxfloor left) (fxfloor top) (fxfloor right) (fxfloor bottom)))))))
  
  
  ;;;
  ;;;; Matrix
  ;;;
  
  
  (method public (with-preserved-matrix thunk <procedure>)
    (let ((preserved-matrix (cairo_get_matrix_raw context)))
      (prog1 (thunk)
        (cairo_set_matrix_raw context preserved-matrix))))
  
  
  (method public (debug-matrix)
    (let ((matrix (cairo_get_matrix_raw context)))
      (debug
        (cairo_matrix_t-xx-ref matrix)
        (cairo_matrix_t-yx-ref matrix)
        (cairo_matrix_t-xy-ref matrix)
        (cairo_matrix_t-yy-ref matrix)
        (cairo_matrix_t-x0-ref matrix)
        (cairo_matrix_t-y0-ref matrix))))
  
  
  ;;;
  ;;;; Transform
  ;;;
  
  
  (method public (with-transformation h <fx> v <fx> transformation <foreign+> thunk <procedure>)
    (with-preserved-matrix
      (lambda ()
        (cairo_translate context (cast <fl> h) (cast <fl> v))
        (when transformation
          (cairo_transform context transformation))
        (thunk))))
  
  
  (method public (with-pristine-transformation thunk <procedure>)
    (with-preserved-matrix
      (lambda ()
        (cairo_identity_matrix context)
        (thunk))))
  
  
  (method public (with-clipping-transformation h <fx> v <fx> width <fx> height <fx> transformation <foreign+> thunk <procedure>)
    (with-transformation h v transformation
      (lambda ()
        (with-clip (new Rect 0 0 width height)
          thunk))))
  
  
  (method public (with-pristine-clipping-transformation thunk <procedure>)
    (with-preserved-matrix
      (lambda ()
        (cairo_identity_matrix context)
        (with-preserved-clipper
          (lambda ()
            (cairo_reset_clip context)
            (thunk))))))
  
  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (get-clipper) <Rect>
    (cairo_get_clipper context))
  
  
  (method public (set-clipper rect <Rect>)
    (cairo_reset_clip context)
    (clip rect))
  
  
  (method public (clip rect <Rect>)
    (draw-rectangle rect)
    (cairo_clip context))
  
  
  (method public (with-preserved-clipper thunk <procedure>)
    (let ((preserved-clipper (cairo_get_clipper_raw context)))
      (prog1 (thunk)
        (cairo_set_clipper_raw context preserved-clipper))))
  
  
  (method public (with-clip clip-rect <Rect> thunk <procedure>)
    (with-preserved-clipper
      (lambda ()
        (clip clip-rect)
        (thunk))))

  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method public (set-text-color color <Color>)
    (set-color color))
  
  
  (method public (get-char-width n <fx>)
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let ((ch (glyph-index~ font n)))
        (cairo_glyph_t-index-set! gly ch)
        (cairo_glyph_t-x-set! gly 0.)
        (cairo_glyph_t-y-set! gly 0.)
        (cairo_glyph_extents context gly 1 ext)
        (let ((width (fxround (cairo_text_extents_t-x_advance-ref ext))))
          (cairo_glyph_t-free gly)
          (cairo_text_extents_t-free ext)
          width))))


  (method public (get-char-widths (first: first <fx> 0) (last: last <fx> 255))
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let ((vec (make-vector (+ (- last first) 1))))
        (loop (for i from first to last)
              (do (let ((ch (glyph-index~ font i)))
                    (cairo_glyph_t-index-set! gly ch)
                    (cairo_glyph_t-x-set! gly 0.)
                    (cairo_glyph_t-y-set! gly 0.)
                    (cairo_glyph_extents context gly 1 ext)
                    (vector-set! vec i (fxround (cairo_text_extents_t-x_advance-ref ext))))))
        (cairo_glyph_t-free gly)
        (cairo_text_extents_t-free ext)
        vec)))
  

  (method public (get-text-extent text <string>)
    (let ((extents (cairo_text_extents_t-make))
          (metrics (get-text-metrics)))
      (cairo_text_extents context text extents)
      (prog1 (new Dimension
               (fxround (cairo_text_extents_t-x_advance-ref extents))
               (fxround (cairo_font_extents_t-height-ref metrics)))
        (cairo_text_extents_t-free extents)
        (cairo_font_extents_t-free metrics))))
    
  
  (method public (get-font-height)
    (let ((extents (cairo_font_extents_t-make)))
      (cairo_font_extents context extents)
      (prog1 (fxround (cairo_font_extents_t-height-ref extents))
        (cairo_font_extents_t-free extents))))
  
  
  (method public (get-text-metrics)
    (let ((info (cairo_font_extents_t-make)))
      (cairo_font_extents context info)
      info))
  

  (method public (get-text-width text <string>)
    (let ((extents (cairo_text_extents_t-make)))
      (cairo_text_extents context text extents)
      (prog1 (fxceiling (cairo_text_extents_t-x_advance-ref extents))
        (cairo_text_extents_t-free extents))))
  
  
  (method public (draw-text h <fx> v <fx> str <string> color <Color> (shadow-color: shadow-color {Color Black}) (enabled?: enabled? #t))
    (define (draw-at h <fx> v <fx>)
      (let ((uph h)
            (font-ext (cairo_font_extents_t-make))
            (extents (cairo_text_extents_t-make))
            (len <fx> (cardinality str)))
        (when (< glyph-array-length len)
          (destroy-glyph-array)
          (set! glyph-array (glyph-array-make (* len 2)))
          (set! glyph-array-length (* len 2)))
        (cairo_font_extents context font-ext)
        (let ((y (+ v (fxround (cairo_font_extents_t-ascent-ref font-ext)))))
          (let (iter (i 0))
            (when (< i len)
              (let ((glyph (glyph-array-ref glyph-array i))
                    (ch (glyph-index~ font (char->integer (element str i)))))
                (cairo_glyph_t-index-set! glyph ch)
                (cairo_glyph_t-x-set! glyph (cast <fl> uph))
                (cairo_glyph_t-y-set! glyph (cast <fl> y))
                (cairo_glyph_extents context glyph 1 extents)
                (set! uph (+ uph (fxround (cairo_text_extents_t-x_advance-ref extents))))
                (iter (+ i 1)))))
          (cairo_show_glyphs context glyph-array len)
          (cairo_font_extents_t-free font-ext)
          (cairo_text_extents_t-free extents)
          (- uph h))))
    
    (case (get-shadow~ font)
      ((thin)
       (set-text-color shadow-color)
       (draw-at (+ h 1) (+ v 1)))
      ((thick)
       (set-text-color shadow-color)
       (draw-at (- h 1) (- v 1))
       (draw-at (+ h 1) (+ v 1))
       (draw-at (+ h 2) (+ v 2))))
    (set-text-color color)
    (draw-at h v))
  
  
  ;; should remove the subseq! and pass the bounds to draw-substring
  (method public (draw-tabbed-text h <fx> v <fx> str <Sequence> tabs origin <fx> color <Color> highlight-color <Color+>) <fx>
    ;; temp copy/pasted from above until templates
    (define (draw-substring h <fx> v <fx> str <Sequence> shadow? <bool>) <fx>
      (let ((uph h)
            (font-ext (cairo_font_extents_t-make))
            (extents (cairo_text_extents_t-make))
            (len <fx> (cardinality str)))
        (when (< glyph-array-length len)
          (destroy-glyph-array)
          (set! glyph-array (glyph-array-make (* len 2)))
          (set! glyph-array-length (* len 2)))
        (cairo_font_extents context font-ext)
        (let ((y (+ v (fxround (cairo_font_extents_t-ascent-ref font-ext)))))
          (let (iter (i 0))
            (when (< i len)
              (let ((glyph (glyph-array-ref glyph-array i))
                    (ch (glyph-index~ font (char->integer (element str i)))))
                (cairo_glyph_t-index-set! glyph ch)
                (cairo_glyph_t-x-set! glyph (cast <fl> uph))
                (cairo_glyph_t-y-set! glyph (cast <fl> y))
                (cairo_glyph_extents context glyph 1 extents)
                (set! uph (+ uph (fxround (cairo_text_extents_t-x_advance-ref extents))))
                (iter (+ i 1)))))
          (when highlight-color
            (fill-rect (new Rect h v uph (+ v (fxround (cairo_font_extents_t-height-ref font-ext)))) highlight-color))
          (set-text-color (if (not shadow?) color {Color Black}))
          (cairo_show_glyphs context glyph-array len)
          (cairo_font_extents_t-free font-ext)
          (cairo_text_extents_t-free extents)
          (- uph h))))
    
    (define (draw-at h <fx> v <fx> shadow? <bool>)
      (let ((uph h)
            (beginning 0)
            (stops tabs))
        (loop (for i from 0 below (cardinality str))
              (do (when (eqv? (element str i) #\tab)
                    (when (/= beginning i)
                      (set! uph (+ uph (draw-substring uph v (subseq! str beginning i) shadow?))))
                    (while (<= (+ origin (cast <fx> (car stops))) (+ uph 1))
                      (set! stops (cdr stops)))
                    (set! uph (+ origin (cast <fx> (car stops))))
                    (set! beginning (+ i 1))
                    (set! stops (cdr stops)))))
        (- (+ uph (draw-substring uph v (subseq! str beginning (cardinality str)) shadow?))
           h)))
    
    (case (get-shadow~ font)
      ((thin)
       (draw-at (+ h 1) (+ v 1) #t))
      ((thick)
       (draw-at (- h 1) (- v 1) #t)
       (draw-at (+ h 1) (+ v 1) #t)
       (draw-at (+ h 2) (+ v 2) #t)))
    (draw-at h v #f))

  
  ;;;
  ;;;; Region
  ;;;
  
  
  (method public (fill-region region <Region> color)
    (loop (for rect in (get-rectangles~ region))
          (do (fill-rect rect color))))
  
  
  (method public (gradient-fill rect <Rect> stops (direction: direction 'horizontal))
    (let* ((left (get-left~ rect))
           (top (get-top~ rect))
           (right (get-right~ rect))
           (bottom (get-bottom~ rect))
           (horzmid (fxfloor/ (- right left) 2))
           (vertmid (fxfloor/ (- bottom top) 2))
           (pattern (case direction
                      ((horizontal)
                       (create-linear-pattern left vertmid right vertmid))
                      ((vertical)
                       (create-linear-pattern horzmid top horzmid bottom)))))
      (for-each (lambda (stop)
                  (bind (offset color) stop
                    (add-color-stop pattern offset color)))
                stops)
      (draw-rectangle rect)
      (cairo_set_source context pattern)
      (fill)
      (cairo_pattern_destroy pattern)))
  
  
  (method public (ellipse rect <Rect> outside inside)
    (let ((left (get-left~ rect))
          (right (get-right~ rect))
          (top (get-top~ rect))
          (bottom (get-bottom~ rect)))
      (let ((w (- right left))
            (h (- bottom top)))
        (let ((tx (+ (cast <fl> left) (/ (cast <fl> w) 2.)))
              (ty (+ (cast <fl> top) (/ (cast <fl> h) 2.))))
          (cairo_translate context tx ty)
          (cairo_scale context (/ (cast <fl> w) 2.) (/ (cast <fl> h) 2.))
          (cairo_arc context 0. 0. 1. 0. PI*2)
          (cairo_scale context (/ 2. w) (/ 2. h))
          (cairo_translate context (- tx) (- ty)))))
    (when outside
      (if (is? outside Color)
          (set-color outside)
        (outside self)))
    (if (not inside)
        (stroke)
      (stroke-preserve)
      (if (is? inside Color)
          (set-color inside)
        (inside self))
      (fill)))

  
  (method public (draw-surface handle x y)
    (set-source-surface handle x y)
    (paint))
  
  
  (method public (fill-background rect background)
    (typecase background
      ((Color) (fill-rect rect background))
      ((Gradient) (fill-gradient rect background))
      ((Texture) (fill-texture rect background))
      ((List) (for-each (lambda (background)
                          (fill-background rect background))
                        background))
      (else (error "Unable to fill background with {s}" background))))
  
  
  (method public (fill-gradient rect <Rect> gradient <Gradient>)
    (let ((parts (get-parts~ gradient)))
      (let ((stops (if (every? (lambda (part)
                                 (is? part Color))
                               parts)
                       (let ((stop 0.)
                             (incr (/ 1. (- (fl (length parts)) 1.))))
                         (map (lambda (color)
                                (prog1 (list stop color)
                                  (increase! stop incr)))
                              parts))
                     parts))
            (direction (get-kind~ gradient)))
        (gradient-fill rect stops direction: direction))))
  
  
  (method public (fill-texture rect <Rect> texture <Texture>)
    (define (texture-image)
      (let ((content (get-content~ texture)))
        (typecase content
          ((Image-Resource) (new Image resource: content))
          ((File) (and (exists?~ content) (new Image moniker: content))))))
    
    (with ((image (texture-image)))
      (if (not image)
          (fill-rect rect {Color Red})
        (let ((mode (get-mode~ texture))
              (position (get-attribute~ texture 'position))
              (size (get-attribute~ texture 'size)))
          (fill-image rect image mode: mode position: position size: size)))))
  
  
  (method public (fill-image rect <Rect> image <Image> (mode: mode 'stretch) (position: position #f) (size: size #f))
    (define (draw-position)
      (let ((pos <Point> (or position {Point 0 0})))
        (draw-at~ image self #f (get-h~ pos) (get-v~ pos))))
    
    (define (draw-center)
      (let ((pos <Point> (center (image-size~ image) (rect-size rect))))
        (draw-at~ image self #f (get-h~ pos) (get-v~ pos))))
    
    (define (draw-fill)
      (draw-scale 'fill))
    
    (define (draw-fit)
      (draw-scale 'fit))
    
    (define (draw-scale mode)
      (let ((image-size (image-size~ image))
            (rect-size (rect-size rect)))
        (let ((ratio (fit-dimensions image-size rect-size mode)))
          (with ((resized (new Image handle: (resize-image (get-handle~ image) (fxround (* (cast <fl> (get-width~ image-size)) ratio)) (fxround (* (cast <fl> (get-height~ image-size)) ratio))))))
            (draw-at~ (cast <Image> resized) self #f 0 0)))))
    
    (define (draw-stretch)
      (with ((resized <Image> (new Image handle: (resize-image (get-handle~ image) (rect-width rect) (rect-height rect)))))
        (draw-at~ resized self #f 0 0)))
    
    (define (draw-tile)
      (let ((handle (get-handle~ image)))
        (set-source-surface handle 0 0)
        (cairo_pattern_set_extend (get-source) CAIRO_EXTEND_REPEAT)
        (cairo_rectangle context (cast <fl> (get-left~ rect)) (cast <fl> (get-top~ rect)) (cast <fl> (rect-width rect)) (cast <fl> (rect-height rect)))
        (cairo_fill context)))
    
    (case mode
      ((position) (draw-position))
      ((center) (draw-center))
      ((fill) (draw-fill))
      ((fit) (draw-fit))
      ((stretch) (draw-stretch))
      ((tile) (draw-tile))
      (else (error "Unknown fill mode: {s}" mode))))
  
  
  ;;;
  ;;;; Control
  ;;;
  
  
  (method public (draw-scroll-bar rect <Rect> direction)
    (draw-rectangle rect)
    (set-color {Color Draw-Edge-Light})
    (fill)
    (draw-edge rect inner: 'raised outer: 'raised edges: 'rectangle)
    (let ((dh (cond ((eq? direction 'left) 1)
                    ((eq? direction 'right) 2)
                    ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)))
          (dv (cond ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)
                    (else 0))))
      (set-color {Color Black})
      (draw-arrow-tip (+ (get-left~ rect) 3 dh) (+ (get-top~ rect) 4 dv) 3 direction)))
   
  
  (method public (draw-caption rect <Rect> type (pushed? #f) (in-rectangle? #t))
    (set-color {Color Dark})
    (set-line-width 1)
    (when in-rectangle?
      (draw-rectangle rect)
      (set-color {Color Draw-Edge-Light})
      (fill)
      (if pushed?
          (begin
            (draw-edge rect inner: 'sunken edges: 'rectangle)
            (draw-edge (new Rect (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (- (get-right~ rect) 1) (- (get-bottom~ rect) 1)) outer: 'sunken edges: 'rectangle))
        (draw-edge rect inner: 'raised outer: 'raised edges: 'rectangle))
      (set-color {Color Black}))
    (let ((rect (if pushed? (new Rect (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (+ (get-right~ rect) 1) (+ (get-bottom~ rect) 1)) rect)))
      (cond ((eq? type 'close)
             (unless in-rectangle?
               (set-color {Color red: 90 green: 90 blue: 90}))
             (move-to (+ (get-left~ rect) 4) (+ (get-top~ rect) 3))
             (line-to (- (get-right~ rect) 4) (- (get-bottom~ rect) 4))
             (move-to (- (get-right~ rect) 4) (+ (get-top~ rect) 3))
             (line-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 4))
             (stroke))
            ((eq? type 'minimize)
             (move-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 5))
             (line-to (- (get-right~ rect) 6) (- (get-bottom~ rect) 5))
             (move-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 4))
             (line-to (- (get-right~ rect) 6) (- (get-bottom~ rect) 4))
             (stroke))
            ((eq? type 'restore)
             (move-to (+ (get-left~ rect) 3) (- (cast <fl> (- (get-bottom~ rect) 3)) 0.5))
             (line-to-rel 5.5 0)
             (line-to-rel 0 -4)
             (line-to-rel -5.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 6 0)
             (move-to-rel -5.5 0)
             (line-to-rel 0 5)
             (move-to (+ (get-left~ rect) 8) (- (cast <fl> (- (get-bottom~ rect) 6)) 0.5))
             (line-to-rel 2.5 0)
             (line-to-rel 0 -4)
             (line-to-rel -5.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 6 0)
             (move-to-rel -5.5 0)
             (line-to-rel 0 3)
             (stroke))
            ((eq? type 'maximize)
             (move-to (+ (get-left~ rect) 3) (- (cast <fl> (- (get-bottom~ rect) 3)) 0.5))
             (line-to-rel 8.5 0)
             (line-to-rel 0 -7)
             (line-to-rel -8.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 9 0)
             (move-to-rel -8.5 0)
             (line-to-rel 0 7.5)
             (stroke)))))
  
  
  (method public (draw-radio-button rect <Rect> (radio-background: radio-background #f) (inactive?: inactive? #f) (selected?: selected? #f))
    (let ((x (+ (get-left~ rect) (/ (cast <fl> (- (get-right~ rect) (get-left~ rect))) 2)))
          (y (+ (get-top~ rect) (/ (cast <fl> (- (get-bottom~ rect) (get-top~ rect))) 2)))
          (r (/ (cast <fl> (- (get-right~ rect) (get-left~ rect))) 2)))
      (cairo_arc context x y r 0. PI*2)
      (set-color (if inactive?
                     {Color Medium}
                   (or radio-background {Color White})))
      (fill)
      (set-line-width 1)
      (cairo_arc context x y r (* 3 PI/4) (* 7 PI/4))
      (set-color {Color Draw-Edge-Medium})
      (stroke)
      (cairo_arc context x y (- r 1) (* 3 PI/4) (* 7 PI/4))
      (set-color {Color Draw-Edge-Dark})
      (stroke)
      (cairo_arc context x y r (* 7 PI/4) (* 3 PI/4))
      (set-color {Color White})
      (stroke)
      (cairo_arc context x y (- r 1) (* 7 PI/4) (* 3 PI/4))
      (set-color {Color Draw-Edge-Light})
      (stroke)
      (when selected?
        (cairo_arc context x y (/ r 3) 0. PI*2)
        (set-color {Color Black})
        (fill))))
  
  
  (method public (draw-push-button rect <Rect> (pushed? #f))
    (set-line-width 1)
    (if pushed?
        (begin
          (set-color {Color Draw-Edge-Dark})
          (line (get-left~ rect) (get-top~ rect) (- (get-right~ rect) 1) (get-top~ rect))
          (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (- (get-bottom~ rect) 1))
          (set-color {Color Draw-Edge-Medium})
          (line (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (- (get-right~ rect) 2) (+ (get-top~ rect) 1))
          (line (+ (get-left~ rect) 1) (+ (get-left~ rect) 1) (+ (get-left~ rect) 1) (- (get-bottom~ rect) 2))
          (set-color {Color White})
          (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))
          (line (- (get-right~ rect) 1) (- (get-bottom~ rect) 1) (get-left~ rect) (- (get-bottom~ rect) 1)))
      (set-color {Color White})
      (move-to (get-left~ rect) (- (get-bottom~ rect) 1))
      (line-to-no-stroke (get-left~ rect) (get-top~ rect))
      (line-to-no-stroke (- (get-right~ rect) 1) (get-top~ rect))
      (stroke)
      (set-line-width 1)
      (set-color {Color Draw-Edge-Dark})
      (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))
      (line (- (get-right~ rect) 1) (- (get-bottom~ rect) 1) (get-left~ rect) (- (get-bottom~ rect) 1))
      (set-color {Color Draw-Edge-Medium})
      (line (- (get-right~ rect) 2) (+ (get-top~ rect) 1) (- (get-right~ rect) 2) (- (get-bottom~ rect) 1))
      (line (- (get-right~ rect) 2) (- (get-bottom~ rect) 2) (+ (get-left~ rect) 1) (- (get-bottom~ rect) 2))))
  
  
  ;;;
  ;;;; Surface
  ;;;
  
  
  (method public (set-source-surface surface/handle x y)
    (cairo_set_source_surface context (if (is? surface/handle Surface)
                                          (get-handle~ surface/handle)
                                        surface/handle)
      (fl x)
      (fl y)))
  
  
  (method public (blit-surface surface (destination: destination <Point> {Point 0 0}))
    (set-source-surface surface (cast <fl> (get-h~ destination)) (cast <fl> (get-v~ destination)))
    (paint))
  
  
  (method public (blit-surface-ext surface h v width height destination-h destination-v)
    (let ((dest-h (fl destination-h))
          (dest-v (fl destination-v)))
      (set-source-surface surface (- dest-h (fl h)) (- dest-v (fl v)))
      (cairo_rectangle context dest-h dest-v (fl width) (fl height))
      (cairo_fill context)))
  
  
  ;;;
  ;;;; Select Object
  ;;;
  
  
  (method public (set-font font <Font>)
    (set! font~self font)
    (cairo_set_scaled_font context (get-scaled-font~ font)))
  
  
  (method public (set-style style)
    (case style
      ((solid) (cairo_set_solid context))
      ((alternate) (cairo_set_alternate context))
      (else (error "Unknown style: {s}" style))))
  
  
  (method public (draw-edge rect <Rect> (edges: edges 'rectangle) (inner: inner #f) (outer: outer #f))
    (let ((edges (if (eq? edges 'rectangle) '(left right top bottom) edges)))
      (set-line-width 1)
      (when (memq? 'top edges)
        (cond ((eq? inner 'raised)
               (set-color {Color White})
               (if outer
                   (line (get-left~ rect) (+ (get-top~ rect) 1) (get-right~ rect) (+ (get-top~ rect) 1))
                 (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect))))
              ((eq? inner 'sunken)
               (set-color {Color Draw-Edge-Dark})
               (if outer
                   (line (get-left~ rect) (+ (get-top~ rect) 1) (get-right~ rect) (+ (get-top~ rect) 1))
                 (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect))))))
      (when (memq? 'left edges)
        (cond ((eq? inner 'raised)
               (set-color {Color White})
               (if outer
                   (line (+ (get-left~ rect) 1) (get-top~ rect) (+ (get-left~ rect) 1) (get-bottom~ rect))
                 (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect))))
              ((eq? inner 'sunken)
               (set-color {Color Draw-Edge-Dark})
               (if outer
                   (line (+ (get-left~ rect) 1) (get-top~ rect) (+ (get-left~ rect) 1) (get-bottom~ rect))
                 (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect))))))
      (when (memq? 'right edges)
        (cond ((eq? inner 'raised)
               (set-color {Color Draw-Edge-Medium})
               (if outer
                   (line (- (get-right~ rect) 2) (get-top~ rect) (- (get-right~ rect) 2) (get-bottom~ rect))
                 (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))))
              ((eq? inner 'sunken)
               (set-color (new Color red: 241 green: 239 blue: 226))
               (if outer
                   (line (- (get-right~ rect) 2) (get-top~ rect) (- (get-right~ rect) 2) (get-bottom~ rect))
                 (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))))))
      (when (memq? 'bottom edges)
        (cond ((eq? inner 'raised)
               (set-color {Color Draw-Edge-Medium})
               (if outer
                   (line (get-left~ rect) (- (get-bottom~ rect) 2) (get-right~ rect) (- (get-bottom~ rect) 2))
                 (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1))))
              ((eq? inner 'sunken)
               (set-color {Color Draw-Edge-Light})
               (if outer
                   (line (get-left~ rect) (- (get-bottom~ rect) 2) (get-right~ rect) (- (get-bottom~ rect) 2))
                 (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1))))))
      (when (memq? 'top edges)
        (cond ((eq? outer 'raised)
               (set-color {Color Draw-Edge-Light})
               (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color Draw-Edge-Medium})
               (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect)))))
      (when (memq? 'left edges)
        (cond ((eq? outer 'raised)
               (set-color {Color Draw-Edge-Light})
               (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color Draw-Edge-Medium})
               (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect)))))
      (when (memq? 'right edges)
        (cond ((eq? outer 'raised)
               (set-color {Color Draw-Edge-Dark})
               (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color White})
               (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect)))))
      (when (memq? 'bottom edges)
        (cond ((eq? outer 'raised)
               (set-color {Color Draw-Edge-Dark})
               (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1)))
              ((eq? outer 'sunken)
               (set-color {Color White})
               (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1)))))))
  

  (method public (fill-rect rect <Rect> color <Color>)
    (set-color color)
    (draw-rectangle rect)
    (fill))
  
  
  (method public (fill-insets rect <Rect> insets <Rect> color <Color>)
    (let ((l (get-left~ rect))
          (t (get-top~ rect))
          (r (get-right~ rect))
          (b (get-bottom~ rect))
          (li (get-left~ insets))
          (ti (get-top~ insets))
          (ri (get-right~ insets))
          (bi (get-bottom~ insets)))
      (let ((tti (+ t ti))
            (bbi (- b bi)))
        (set-color color)
        (draw-rectangle (new Rect l t r tti))
        (draw-rectangle (new Rect l bbi r b))
        (draw-rectangle (new Rect l tti (+ l li) bbi))
        (draw-rectangle (new Rect (- r ri) tti r bbi))
        (fill))))
  
  
  (method public (draw-check h <fx> v <fx>)
    (set-line-width 1)
    (line (+ h 0) (+ v 2) (+ h 0) (+ v 5))
    (line (+ h 1) (+ v 3) (+ h 1) (+ v 6))
    (line (+ h 2) (+ v 4) (+ h 2) (+ v 7))
    (line (+ h 3) (+ v 3) (+ h 3) (+ v 6))
    (line (+ h 4) (+ v 2) (+ h 4) (+ v 5))
    (line (+ h 5) (+ v 1) (+ h 5) (+ v 4))
    (line (+ h 6) (+ v 0) (+ h 6) (+ v 3))
    (stroke))
  
  
  (method public (draw-raised rect <Rect>)
    (set-color {Color Light-Background})
    (set-line-width 1)
    (move-to (get-left~ rect) (- (get-bottom~ rect) 1))
    (line-to-no-stroke (get-left~ rect) (get-top~ rect))
    (line-to-no-stroke (- (get-right~ rect) 1) (get-top~ rect))
    (stroke)
    (set-color {Color Dark})
    (move-to (- (get-right~ rect) 1) (get-top~ rect))
    (line-to-no-stroke (- (get-right~ rect) 1) (- (get-bottom~ rect) 1))
    (line-to (get-left~ rect) (- (get-bottom~ rect) 1)))
  
  
  (method public (draw-arrow-tip h <fx> v <fx> size <fx> direction <symbol>)
    (set-line-width 1)
    (case direction
      ((up)
       (let ((width (- (+ size size) 1)))
         (increase! v (- size 1))
         (for-each (lambda (n)
                     (line h v (+ h width) v)
                     (increase! h)
                     (decrease! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((down)
       (let ((width (- (+ size size) 1)))
         (for-each (lambda (n)
                     (line h v (+ h width) v)
                     (increase! h)
                     (increase! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((left)
       (let ((height (- (+ size size) 1)))
         (increase! h (- size 1))
         (for-each (lambda (n)
                     (line h v h (+ v height))
                     (decrease! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))
      ((right)
       (let ((height (- (+ size size) 1)))
         (for-each (lambda (n)
                     (line h v h (+ v height))
                     (increase! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))))
  
  
  ;;;
  ;;;; Printing
  ;;;
  
  @a
  (cond-expand
    (windows
      (method public (start-doc rec)
        (StartDoc (cairo_win32_surface_get_dc handle) rec))
  
  
      (method public (end-doc)
        (EndDoc (cairo_win32_surface_get_dc handle)))
  
  
      (method public (start-page)
        (StartPage (cairo_win32_surface_get_dc handle)))
  
  
      (method public (end-page)
        (EndPage (cairo_win32_surface_get_dc handle))))
    (else))
  
  
  (method public virtual (show-page)
    (cairo_show_page context))
  
  
  (method (with-outside/inside outside inside outside-proc inside-proc)
    (when inside
      (inside-proc)
      (if (is? inside Color)
          (set-color inside)
        (inside self))
      (fill))
    (when outside
      (outside-proc)
      (if (is? outside Color)
          (set-color outside)
        (outside self))
      (stroke-preserve)))
  
  
  (method virtual public (frame-rect rect <Rect> color)
    (set-line-width 1)
    (set-color color)
    (draw-rectangle$fl$
      (new Rect$fl$
        (+ (get-left~ rect) 0.5)
        (+ (get-top~ rect) 0.5)
        (- (get-right~ rect) 0.5)
        (- (get-bottom~ rect) 0.5)))
    (stroke))
  
  
  (method public (frame-partial-rect rect <Rect> sides color)
    (set-line-width 1)
    (set-color color)
    (let ((left (get-left~ rect))
          (top (get-top~ rect))
          (right (get-right~ rect))
          (bottom (get-bottom~ rect)))
      (when (memq? 'top sides)
        (move-to left top)
        (line-to right top))
      (when (memq? 'right sides)
        (move-to (- right 1) top)
        (line-to (- right 1) (- bottom 1)))
      (when (memq? 'left sides)
        (move-to left top)
        (line-to left (- bottom 1)))
      (when (memq? 'bottom sides)
        (move-to left (- bottom 1))
        (line-to right (- bottom 1)))))
  
  
  (method public (frame-round-rect rect <Rect> color)
    (set-line-width 1)
    (set-color color)
    (let ((left (get-left~ rect))
          (top (get-top~ rect))
          (right (get-right~ rect))
          (bottom (get-bottom~ rect)))
      (move-to (+ left 1) top)
      (line-to (- right 1) top)
      (move-to (- right 1) (+ top 1))
      (line-to (- right 1) (- bottom 1))
      (move-to left (+ top 1))
      (line-to left (- bottom 1))
      (move-to (+ left 1) (- bottom 1))
      (line-to (- right 1) (- bottom 1))))
  
  
  (method public (rectangle rect <Rect> outside inside)
    (with-outside/inside outside inside
      (lambda ()
        (draw-rectangle$fl$ (inflate-rect rect -0.5 -0.5)))
      (lambda ()
        (draw-rectangle$fl$ (rect->rect$fl$ rect)))))
  
  
  ;;;
  ;;;; Primitives
  ;;;
  
  
  (method public (cairo-move-to h v)
    (cairo_move_to context (fl h) (fl v)))
  
  
  (method public (cairo-line-to h v)
    (cairo_line_to context (fl h) (fl v)))
  
  
  (method public (arc hc vc radius angle1 angle2)
    (cairo_arc context (fl hc) (fl vc) (fl radius) (fl angle1) (fl angle2)))
  
  
  (method public (curve-to-relative dx1 dy1 dx2 dy2 dx3 dy3)
    (cairo_rel_curve_to context (fl dx1) (fl dy1) (fl dx2) (fl dy2) (fl dx3) (fl dy3)))
  
  
  (method public (close-path)
    (cairo_close_path context))
  
  
  (definition (create-linear-pattern sh sv eh ev)
    (cairo_pattern_create_linear (fl sh) (fl sv) (fl eh) (fl ev)))
  
  
  (method public (get-source)
    (cairo_get_source context))
  
  
  (method public (set-source pattern)
    (cairo_set_source context pattern))
  
  
  (method public (translate th tv)
    (cairo_translate context (fl th) (fl tv)))
  
  
  (method public (scale sh sv)
    (cairo_scale context (fl sh) (fl sv)))
  
  
  (method public (rotate angle)
    (cairo_rotate context (fl angle)))
  
  
  ;;;
  ;;;; Cairo Primitives
  ;;;
  
  
  (method public (move-to h v)
    (cairo_move_to context (fl h) (fl v)))
  
  
  (method public (line-path h v)
    (cairo_line_to context (fl h) (fl v)))
  
  
  (method public (line-to h v)
    (line-to-no-stroke (fl h) (fl v))
    (stroke))
  
  
  (method public (line-to-preserve h v)
    (line-to-no-stroke (fl h) (fl v))
    (stroke-preserve))
  

  (method public (line-to-no-stroke h v)
    (let ((pt (cairo_current_point context))
          (h (fl h))
          (v (fl v)))
      (let ((cur-h (get-h~ pt))
            (cur-v (get-v~ pt)))
        (let ((h (if (= cur-h h)
                     (begin
                       (move-to (+ cur-h 0.5) cur-v)
                       (+ h 0.5))
                   h))
              (v (if (= cur-v v)
                     (begin
                       (move-to cur-h (+ cur-v 0.5))
                       (+ v 0.5))
                   v)))
          (cairo_line_to context h v)))))
  
  
  (method public (line-to-rel dh dv)
    (cairo_rel_line_to context (fl dh) (fl dv)))
  
  
  (method public (move-to-rel dh dv)
    (cairo_rel_move_to context (fl dh) (fl dv)))
  
  
  (method public (line h v dest-h dest-v)
    (move-to h v)
    (line-to dest-h dest-v))
  
  
  (method public (pixel-to h v)
    (set-line-width 1)
    (move-to h v)
    (line-to (+ (fl h) 1.) v))
  
  
  (method public (set-line-width w)
    (cairo_set_line_width context (fl w)))
  
  
  (method public (get-line-width)
    (cairo_get_line_width context))
  
  
  (method public (set-operator op)
    (cairo_set_operator context op))
  
  
  (method public (stroke)
    (cairo_stroke context))
  
  
  (method public (stroke-preserve)
    (cairo_stroke_preserve context))
  
  
  (method public (fill)
    (cairo_fill context))
  
  
  (method public (fill-preserve)
    (cairo_fill_preserve context))
  
  
  (method public (paint)
    (cairo_paint context))

  
  (method public (draw-rectangle rect <Rect>)
    (let ((x (get-left~ rect))
          (y (get-top~ rect)))
      (let ((w (- (get-right~ rect) x))
            (h (- (get-bottom~ rect) y)))
        (cairo_rectangle context
                         (cast <fl> x)
                         (cast <fl> y)
                         (cast <fl> w)
                         (cast <fl> h)))))

  
  (method public (draw-rectangle$fl$ rect <Rect$fl$>)
    (let ((x (get-left~ rect))
          (y (get-top~ rect)))
      (let ((w (- (get-right~ rect) x))
            (h (- (get-bottom~ rect) y)))
        (cairo_rectangle context
                         x
                         y
                         w
                         h))))
  
  
  (method public (set-color color <Color>)
    (let ((r (get-red~ color))
          (g (get-green~ color))
          (b (get-blue~ color))
          (a (get-alpha~ color)))
      (cairo_set_source_rgba context r g b a)))
  
  
  (definition (add-color-stop pattern offset color <Color>)
    (let ((r (get-red~ color))
          (g (get-green~ color))
          (b (get-blue~ color))
          (a (get-alpha~ color)))
      (cairo_pattern_add_color_stop_rgba pattern (fl offset) r g b a)))
  
  
  (method public (export-to-png file <File>)
    (cairo_surface_write_to_png handle (parse~ file)))
  

  (method public (cairo-status)
    (cairo_status context))
  
  
  (method public (cairo-surface-status)
    (cairo_surface_status handle))
  
  
  (proclaim (not warn optimizations))))
