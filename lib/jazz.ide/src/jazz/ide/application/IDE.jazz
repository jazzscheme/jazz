;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Integrated Development Environment
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ide.application.IDE jazz


(import (jazz.action)
        (jazz.application)
        (jazz.catalog)
        (jazz.catalog.edit)
        (jazz.catalog.entry)
        (jazz.clipboard)
        (jazz.component)
        (jazz.console)
        (jazz.debuggee)
        (jazz.debuggee.ui)
        (jazz.debuggee.view)
        (jazz.debugger)
        (jazz.debugger.jazz)
        (jazz.debugger.stub)
        (jazz.designer)
        (jazz.designer.ui)
        (jazz.designer.ui.view)
        (jazz.document)
        (jazz.editor)
        (jazz.editor.jazz)
        (jazz.editor.lisp)
        (jazz.event)
        (jazz.execution)
        (jazz.favorite)
        (jazz.feedback)
        (jazz.git.ui)
        (jazz.groupware)
        (jazz.handler)
        (jazz.ide)
        (jazz.ide.leaks)
        (jazz.ide.login)
        (jazz.ide.snapshots)
        (jazz.integrity)
        (jazz.io)
        (jazz.locale)
        (jazz.markup)
        (jazz.menu)
        (jazz.picker)
        (jazz.platform)
        (jazz.preferences)
        (jazz.presence)
        (jazz.presence.transmission)
        (jazz.process)
        (jazz.profile)
        (jazz.project)
        (jazz.recorder)
        (jazz.search)
        (jazz.settings)
        (jazz.text)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(class IDE extends Application


  (slot local-debugger    initialize #f)
  (slot snapshot-debugger initialize #f)
  (slot recorder          initialize (new Macro-Recorder))
  
  
  (method override (install-process self)
    (nextmethod self)
    (start-debuggers self))


  (method override (prepare-workbench self)
    (nextmethod self)
    (setup-cataloguer self)
    (setup-workbench self))
  
  
  (method override (finalize-process self)
    (nextmethod self)
    (add-application-listener self 'workspace (new Event-Handler target: self method-name: 'on-workspace)))
  
  
  (method override (finish-process self)
    (define (setup-caption-base)
      (let ((toplevel-title (effective-toplevel-title)))
        (cond (toplevel-title (set-caption-base toplevel toplevel-title))
              ((not (get-caption-base toplevel)) (set-caption-base toplevel "Application")))))
    
    (define (effective-toplevel-title)
      (or (and profile (toplevel-title profile))
          (get-toplevel-title (current-preferences #f))
          (find-setting 'jazz.ui.toplevel-title #f)))
    
    (set-debugger-manager (new Debugger-Manager)) ;; hack!!!!!
    (nextmethod self)
    (setup-caption-base)
    (preload-catalogs self))

  
  (method override (conclude-environment self)
    (nextmethod self)
    ;; toggle terminal is windows only at the moment
    (let ((menu (find-menu self 'debug)))
      (when menu
        (let ((label (find-component menu 'toggle-terminal)))
          (when (and label (neq? kernel-platform 'windows))
            (set-visible? label #f)
            (layout-menu menu)))))
    ;; do this at the last moment possible because any error beyond this point
    ;; will be handled by the IDE itself which must thus be fully functional
    (when (use-local-debugger? self)
      (if (get-controller-debugger)
          (attach-process local-debugger (get-local-process) #t)
        (add-debugger-release 'modal
          (lambda ()
            (enable-window (get-toplevel self))
            (set-current-modal #f)
            (update-modal-actions self)))
        (attach-to-controller (require-object (get-local-register 'debugging) 'debugger) #t)
        (with-system-exception-debugger
          (lambda ()
            (ready-to-controller)
            (transmit-runtime-information (get-local-process) 'all)
            (current-input-port (console-input-port))
            (current-output-port (console-output-port)))))))
  
  
  (method override (conclude-debuggee self)
    (nextmethod self)
    (unless (local-debugger?)
      (start-local-debugger-repl)))


  (method override (close-environment self)
    (unless (reloading-process?)
      (detach-debugger-processes self))
    (nextmethod self))
  
  
  (method override (safe-execution? self)
    #t)

  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-backward-history self)
    (get-backward-history history-manager))
  
  
  (method public (get-forward-history self)
    (get-forward-history history-manager))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method override (get-recorder self)
    recorder)


  ;;;
  ;;;; Profile
  ;;;
  
  
  (method override (use-profile? self)
    #t)
  
  
  (method override (use-profile-logging? self)
    #t)
  
  
  (method override (choose-profile-login self)
    (choose-login invite: (process-name self)))

  
  ;;;
  ;;;; Frames
  ;;;


  (method override (default-frame-class self)
    Plain-Text-View)


  (method override (known-extension-frame-class self ext)
    (cond ((member? ext '("txt" "text") test: extension=?) Plain-Text-View)
          ((member? ext '("ftx") test: extension=?) Plain-Formatted-Text-View)
          ((member? ext '("c" "cc" "cp" "cpp" "cxx" "h" "hpp" "m" "mm" "gn" "rc" "i") test: extension=?) jazz.editor.c:C-Text-View)
    @wait ((member? ext '("prop") test: extension=?) jazz.editor.prop:Prop-Text-View)
          ((member? ext '("java") test: extension=?) jazz.editor.java:Java-Text-View)
    @wait ((member? ext '("cs") test: extension=?) jazz.editor.csharp:CSharp-Text-View)
    @wait ((member? ext '("html" "htm")) jazz.editor.html:HTML-Text-View)
    @wait ((member? ext '("xml")) Plain-Text-View @wait XML-Text-View)
          ((member? ext '("jlog")) jazz.editor.jazz:Log-Viewer)
    @wait ((member? ext '("css")) jazz.editor.css:CSS-Text-View)
          ((member? ext '("dart")) jazz.editor.dart:Dart-Text-View)
    @wait ((member? ext '("properties")) jazz.editor.properties:Properties-Text-View)
          ((member? ext '("js")) jazz.editor.javascript:JavaScript-Text-View)
          ((member? ext '("lua")) jazz.editor.lua:Lua-Text-View)
          ((member? ext '("py")) jazz.editor.python:Python-Text-View)
          ((member? ext '("tex")) jazz.editor.tex:Tex-Text-View)
    @wait ((member? ext '("bmp" "jpg" "jpeg" "png" "tif" "tiff") test: extension=?) jazz.ui:Image-View)
          ((member? ext '("diff" "patch") test: extension=?) jazz.editor.diff:Diff-Text-View)
    @wait ((member? ext '("tpl") test: extension=?) jazz.editor.java:Java-Text-View)
          ((member? ext Scheme-Extensions test: extension=?) jazz.editor.scheme:Scheme-Text-View)
          ((member? ext Clojure-Extensions test: extension=?) jazz.editor.clojure:Clojure-Text-View)
          ((member? ext CommonLisp-Extensions test: extension=?) jazz.editor.commonlisp:CommonLisp-Text-View)
          ((member? ext Jazz-Extensions test: extension=?) Jazz-Text-View)
          ((member? ext '("jmf") test: extension=?) View-Editor)
          (else (nextmethod self ext))))
  
  
  (method override (unknown-extension-frame-class self)
    Plain-Text-View)


  ;;;
  ;;;; Files
  ;;;
  
  
  (method override (edit-file self file . rest)
    (let ((ext (get-extension file)))
      (cond ((extension=? ext "snapshot") (edit-snapshot self file))
            ((extension=? ext "jlog") (edit-log self file))
            (else (apply nextmethod self file rest)))))
  
  
  ;;;
  ;;;; Snapshot
  ;;;
  
  
  (method package (edit-snapshot self snapshot/file)
    (open-snapshot (get-processes-view) snapshot/file)
    (select-named-workspace 'debugger))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method (edit-log self file)
    (let ((manager (get-logs-manager self)))
      (if (not (get-player manager))
          (begin
            (message-box "Unable to find the Logs palette")
            (signal-cancel))
        (open-log manager file)
        (acquire-focus (get-tree manager)))))


  ;;;
  ;;;; Stage
  ;;;


  (method override (stage-class self)
    Wallpaper-Stage)

  
  ;;;
  ;;;; Search
  ;;;


  (method (search-result-update self icon msg)
    @wait
    (let ((status-bar (find-status-bar self)))
      (when status-bar
        (let ((label (find-component status-bar 'search-result)))
          (set-icon label icon)
          (set-title label (cond ((not msg) "")
                                  ((is? msg Locales) msg)
                                  (else (->string msg))))))))


  ;;;
  ;;;; Nicknames
  ;;;
  
  
  (method override (setup-nicknames self)
    (define (focus-editor)
      (let ((focus (active-focus)))
        (and focus
             (get-view-editor (get-guest focus)))))
    
    (define (search-manager)
      (get-guest (singleton-palette
                    (lambda ()
                      (new-palette (search-manager-class self)
                                   host-title: "Search"
                                   host-visible?: #f
                                   host-size: {Dimension 857 169}))
                    'search)))
    
    (define (search-results)
      (get-guest (singleton-docked Search-Results)))
    
    (nextmethod self)
    (register-nickname :focus-editor         focus-editor)
    (register-nickname :search-manager       search-manager)
    (register-nickname :search-results       search-results)
    (register-nickname :debugger             (lambda () (current-debugger)))
    (register-nickname :debugger-manager     (lambda () (get-debugger-manager)))
    (register-nickname :view-debugger        (lambda () (current-view-debugger)))
    (register-nickname :recorder             (lambda () recorder))
    (register-nickname :workbench-manager    (lambda () (get-workbench-manager self)))
    (register-nickname :repositories-manager (lambda () (get-repositories-manager self))))
  
  
  (method protected virtual (search-manager-class self)
    )


  ;;;
  ;;;; Services
  ;;;
  
  
  (method override (provide-services self)
    (nextmethod self)
    ;; search
    (provide-service 'search-result-update (~ search-result-update self))
    ;; debugger
    (provide-service 'update-focused-process (lambda () (update-focused-process (find-status-bar self))))
    ;; documentation
    (provide-service 'edit-documentation (~ edit-documentation self)))


  ;;;
  ;;;; Actions
  ;;;
  

  (method override (class-actions self)
    (cons (find-actions 'ide)
          (nextmethod self)))
  
  
  ;;;
  ;;;; Termination
  ;;;
  
  
  (method override (terminate-process self)
    (nextmethod self)
    (when (use-local-debugger? self)
      (unregister-object (get-local-register 'debugging) 'debugger error?: #f)))


  ;;;
  ;;;; Environment
  ;;;
  
  
  (method override (save-environment self)
    (nextmethod self)
    (save-catalogs self))
  
  
  ;;;
  ;;;; Quit
  ;;;
  

  (method override (reload-process self)
    (message-box "An IDE cannot be reloaded yet."))


  ;;;
  ;;;; Session
  ;;;

  
  @convert-to-session
  (method (load-session)
    (let ((dir (get-directory (get-preferences '(application session)))))
      (when dir
        (current-directory-set! dir))))
  
  
  @convert-to-session
  (method (reload-opened-windows)
    @convert-to-session
    (for-each (lambda (info)
                (bind (class . properties) info
                  (bind-keywords ((file #f) . others) properties
                    (when (or (not file) (exists? file))
                      (reload-component class properties)))))
              (get-opened-windows (get-preferences '(application session)))))
    
  
  (method override (reload-component self class properties)
    @to-convert
    (case class
      ((plain-text)          (apply new Plain-Text-Frame          properties))
      ((c-text)              (apply new C-Text-Frame              properties))
      ((java-text)           (apply new Java-Text-Frame           properties))
      ((prop-text)           (apply new Prop-Text-Frame           properties))
      ((html-text)           (apply new HTML-Text-Frame           properties))
      ((java-palette)        (apply new Java-Text-Palette         properties))
      ((image-frame)         (apply new Image-Frame               properties))
      ((browser-frame)       (apply new Browser-Frame             properties))
      ((projects-manager)    (apply new Projects-Manager          properties))
      @to-convert
      ((compare-directories) (apply new Compare-Directories-Frame properties))
      @to-convert
      ((compare-files)       (apply new Compare-Files-Frame       properties))
      (else                (nextmethod class properties))))

  
  ;;;
  ;;;; Workbench
  ;;;
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method protected virtual (default-workbench self)
    (new Workbench))
  
  
  (method public virtual (setup-workbench self)
    (define (load-workbench)
      (let ((file Workbench-File))
        (if (and (is-alias? 'Profile) (exists? file))
            (parameterize ((tag-reference-not-found-handler not-found-handler))
              (instantiate (read-form file)))
          (default-workbench self))))
    
    (define (not-found-handler ref)
      (let ((form
              (<form>
                (<Project-Not-Found>))))
        (let ((title
                (catch (Unknown-Alias-Exception exc
                         (get-message exc))
                  (format "{a} not found" (parse ref)))))
          (set-property form 'title title)
          form)))
    
    (with-safe-execution "loading the workbench"
      (lambda ()
        (with-execution-context
          (lambda ()
            (set-workbench (load-workbench)))
          title: "Load Workbench"))
      continue-handler:
      (lambda (err)
        (set-workbench (default-workbench self)))))
  
  
  (method public (update-project-actions self)
    (let ((project (active-project))
          @wait
          (project-file (let ((guest (current-document)))
                          (and (and guest (is? guest Document))
                               (let ((moniker (get-moniker (get-document-controller guest))))
                                 (and moniker
                                      (let ((workbench (get-workbench)))
                                        (find-source workbench moniker)))))))
          ;; quicky as this should probably be a test on the above project-file
          ;; so files from different languages can be build in their own ways
          (unit-name (let ((guest (current-document)))
                       (and (and guest (is? guest Document))
                            (let ((moniker (get-moniker (get-document-controller guest))))
                              (and moniker
                                   (find-pathname-unit (parse moniker))))))))
      @wait (set-action-enabled? {Action ide edit-project} project)
      @wait (set-action-enabled? {Action ide compile-file} (and project unit-name @wait project-file))
      @wait (set-action-enabled? {Action ide build-project} project)
      @wait (set-action-enabled? {Action ide view-project-log} project)
      @wait (set-action-enabled? {Action ide test-project} project)
      @wait (set-action-enabled? {Action ide validate-project} project)
      (set-action-enabled? {Action ide run-project} project)
      (set-action-enabled? {Action ide debug-project} project)))
  
  
  (method public (run-project self project (profile: profile #f) (command-action: command-action #f) (command-arguments: command-arguments #f) (show-console?: show-console? #f) (wait?: wait? #f))
    (project-run project
      profile: profile
      command-action: command-action
      command-arguments: command-arguments
      show-console?: show-console?
      wait?: wait?))


  (method public (debug-project self project (executable: executable #f) (debugger-interactive?: debugger-interactive? #f) (profile: profile #f) (command-action: command-action #f) (command-arguments: command-arguments #f) (show-console?: show-console? #f) (wait?: wait? #f))
    (project-debug project
      executable: executable
      debugger-interactive?: debugger-interactive?
      profile: profile
      command-action: command-action
      command-arguments: command-arguments
      show-console?: show-console?
      wait?: wait?))


  (method public (validate-project self project (executable: executable #f) (debugger-interactive?: debugger-interactive? #f) (profile: profile #f) (command-action: command-action #f) (command-arguments: command-arguments #f) (show-console?: show-console? #f) (wait?: wait? #f))
    (project-validate project
      executable: executable
      debugger-interactive?: debugger-interactive?
      profile: profile
      command-action: command-action
      command-arguments: command-arguments
      show-console?: show-console?
      wait?: wait?))


  ;;;
  ;;;; Console
  ;;;


  (method public (fresh-prompt self (text: text #f))
    (let ((text (or text (get-console-text))))
      (when text
        (fresh-prompt text))))
  
  
  (method package (on-console self evt)
    (let ((focus (active-focus))
          (text (show-console self)))
      (when (and text (eq? text focus))
        (cond ((or (not (at-end? text))
                   (extended? (console-last-block text)))
               (fresh-prompt text))
              ((not (cell-displayed? text (get-end text)))
               (ensure-displayed text))
              (else
               (select-next-console (get-console-manager-guest)))))))
  
  
  (method public (show-console self (class: class Lisp-Console-Manager)
                               (workspace: workspace 'home)
                               (focus?: focus? #t))
    (let ((manager (select-docked class workspace: workspace)))
      (when (and manager focus?)
        (let ((text (get-text manager)))
          (if (not text)
              (bell)
            (acquire-focus text))
          text))))
  
  
  (method package (on-clear-console self evt)
    (clear-console (get-console-text)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method override (get-logs-manager self)
    (get-guest (singleton-docked Logs-Manager)))
  
  
  (method override (get-output-log self)
    (get-guest (singleton-docked Output-Log)))
    
  
  ;;;
  ;;;; Profiling
  ;;;
  
  
  (method public (get-profiling-results self)
    (get-guest (singleton-docked Profile-Results)))
    
  
  ;;;
  ;;;; Dependencies
  ;;;
  
  
  (method public (get-dependencies-analyser self)
    (get-guest (singleton-docked Dependencies-Analyser)))

  
  ;;;
  ;;;; Register
  ;;;
  
  
  (method override (register-base-objects self)
    (nextmethod self)
    (when (use-local-debugger? self)
      (register-object (get-local-register 'debugging) 'debugger (new Jazz-Debugger-Local-Proxy (require-presence 'debugging) local-debugger))
      (set-presence-accept-handler
        (lambda (proc presence)
          (handle-exception-filter
            connection-exception?
            (lambda (exc)
              )
            (lambda ()
              (proc presence)))))
      (set-presence-process-handler
        (lambda (proc connection)
          (catch (connection-exception? exc)
            (proc connection)))
        purpose: 'debugging)))

  
  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method protected virtual (use-local-debugger? self)
    #t)
    
  
  (method override (get-local-debugger self)
    local-debugger)
    
  
  (method override (get-snapshot-debugger self)
    snapshot-debugger)

  
  (method package (start-debuggers self)
    (when (use-local-debugger? self)
      (when (not local-debugger)
        (set! local-debugger (new Jazz-Debugger))
        (start-debugger local-debugger)
        (register-debugger local-debugger)
        (set-current-debugger local-debugger))
      (when (not snapshot-debugger)
        (set! snapshot-debugger (new Snapshot-Debugger))
        (start-debugger snapshot-debugger)
        (register-debugger snapshot-debugger))))
  
  
  (method (detach-debugger-processes self)
    (when (use-local-debugger? self)
      (for-each detach-processes (get-debuggers))))
  
  
  ;;;
  ;;;; Debuggee
  ;;;
  
  
  (method override (initial-console-context self)
    (let ((pref (current-preferences '(tools console) error?: #f)))
      (if (not pref)
          :process
        (get-context pref))))
  
  
  ;;;
  ;;;; Forms
  ;;;
  
  
  (method override (former-class self)
    Designer)
  

  ;;;
  ;;;; Favorites
  ;;;

  
  (method (on-open-favorite self evt)
    (define (find-favorite char)
      (let ((pref (current-preferences 'favorites error?: #f)))
        (and pref
             (let ((favorites (get-children pref)))
               (find-if (lambda (favorite)
                          (eqv? (get-shortcut favorite) char))
                        favorites)))))
    
    (let* ((char (get-property evt char:))
           (favorite (find-favorite char)))
      (if (not favorite)
          (error "No favorite defined for {t}" char)
        (let ((target (get-target favorite)))
          (cond ((not target)
                 (message-box (format "No favorite defined for {a}" char))
                 (signal-cancel))
                ((file? target)
                 (edit-document self target))
                ((directory? target)
                 (open-files (current-application) directory: target))
                ((symbol? target)
                 (edit-definitions self target))
                ((is? target Event-Handler)
                 (invoke target self (apply make-event Event :launch self (get-properties target))))
                ((is? target Action)
                 (call-action target self '() event: evt))
                (else
                 (error "Unable to open favorite target: {s}" target)))))))


  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method override (edit-definition self entry object (context: context #f) (workspace: workspace #f) (history-item: history-item #f))
    (define (filter-hubs entries)
      (collect-if (lambda (entry)
                    (neq? (get-kind entry) 'hub))
                  entries))
    
    (let ((name (->string object)))
      (let ((entries (filter-hubs (entry-resolve entry name))))
        (if (null? entries)
            (bell)
          (add-history self history-item)
          (case (length entries)
            ((1) (edit-entry (car entries) workspace: workspace))
            (else (edit-definitions (get-search-manager) (new Projects-Search 'definitions name #f) entries sort?: #f)))))))

  
  (method override (edit-definitions self object (class: class #f) (context: context #f) (workspace: workspace #f) (history-item: history-item #f))
    ;; todo: show only entries belonging to class
    (define (filter-class entries class)
      entries)
    
    (define (filter-hubs entries)
      (collect-if (lambda (entry)
                    (neq? (get-kind entry) 'hub))
                  entries))
    
    (if (and (symbol? object)
             (composite-reference? object))
        (let ((entry (locator->entry object)))
          (if (not entry)
              (bell)
            (edit-entry entry)))
      (let ((name (->string object)))
        (let ((definitions (filter-hubs (filter-class (get-coalesced-definitions (get-cataloguer) name context: context) class))))
          (if (null? definitions)
              (bell)
            (add-history self history-item)
            (case (length definitions)
              ((1) (edit-entry (car definitions) workspace: workspace))
              (else (edit-definitions (get-search-manager) (new Projects-Search 'definitions name #f) definitions))))))))

  
  (method override (edit-references self object (context: context #f) (history-item: history-item #f))
    (let ((name (->string object)))
      (let ((definitions (get-references (get-cataloguer) name context: context)))
        (if (null? definitions)
            (bell)
          (add-history self history-item)
          (case (length definitions)
            ((1) (edit-textual-reference (car definitions) name))
            (else (edit-references (get-search-manager) (new Projects-Search 'references (make-search-context name whole-words?: #t) #f) definitions)))))))


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method override (designer-default-imports self)
    '(jazz.markup))
  
  
  (method override (designer-form-imports self form)
    (form-imports form))
  
  
  (method public virtual (view-editor-class self)
    View-Editor)
  
  
  (method public virtual (component-editor-class self)
    Grid-Component-Editor)
  
  
  (method public virtual (default-designer-imports self)
    '(jazz.markup))
  
  
  (method public virtual (text-editor-class self)
    Text-Editor)
  
  
  (method public virtual (make-traits-toolbox self class)
    (instantiate
      (parse-form
        `(data jazz.ide.data.toolbox
         (form
           (<Toolbox> title: "Traits"))))))


  (method package virtual (designer-process self)
    (let ((manager (get-debugger-manager)))
      (or (and (get-focused-mode? manager)
               (get-focused-process manager))
          (warn-cancel "Please focus the process used by the designer"))))
  
  
  (method public (get-designer-manager self)
    (get-guest (singleton-docked Designer-Manager)))
  
  
  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public (get-documentation self symbol)
    (and symbol
         (let ((cataloguer (get-documentation-cataloguer self)))
           (and cataloguer
                (get-definition cataloguer symbol)))))
  
  
  (method public (edit-documentation self symbol)
    (let ((doc (get-documentation self symbol)))
      (if (not doc)
          (bell)
        (let* ((form (get-form doc))
               (moniker (get-origin (get-toplevel form)))
               (frame (edit-document self moniker visible?: #f))
               (text (get-guest frame))
               (location (append (get-location form) (list 0)))
               (range (location-range text location)))
          (set-selection text range)
          (focus-host frame)))))


  @old-doc-editor
  (method public (edit-documentation location object text text-location)
    (let* ((class Doc-Editor)
           (editor (find-frame-guest class))
           (info (list location object text text-location)))
      (if (not editor)
          (new-frame class client: (get-documentation-catalog) entry: info)
        (set-entry editor info)
        (bring-to-front (get-host editor)))))
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (method override (navigable-results self)
    (list
      (get-guest (singleton-docked Search-Results))
      (get-guest (singleton-docked Dependencies-Analyser))
      @wait
      (get-guest (singleton-docked Output-Log))
      (get-guest (singleton-docked Violations-Manager))))


  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-new-project self evt)
    (add-project-to (get-workbench-manager self) (get-workbench)))
  

  (method package (on-open-text self evt)
    (receive (files char-encoding) (choose-file multiple-selection?: #t text?: #t)
      (for-each (lambda (file)
                  (edit-document self file class: Jazz-Plain-Text-View char-encoding: char-encoding))
                (sort string>? files key: get-name))))


  (method package (on-open-jazz-text self evt)
    (receive (files char-encoding) (choose-file title: "Choose Jazz Text File" multiple-selection?: #t text?: #t)
      (for-each (lambda (file)
                  (edit-document self file class: Jazz-Text-View char-encoding: char-encoding))
                (sort string>? files key: get-name))))
  
  
  (method package (on-terminal-repl self evt)
    (terminal-repl))
  
  
  (method package (on-toggle-terminal self evt)
    (toggle-terminal))
  
  
  (method package (on-clear-terminal self evt)
    (clear-terminal))


  (method package virtual (on-test self evt)
    (test (get-profile self)))


  (method (on-test-no self evt)
    (let ((profile (get-profile self)))
      (case (get-property evt no:)
        ((0) (test0 profile))
        ((1) (test1 profile))
        ((2) (test2 profile))
        ((3) (test3 profile))
        ((4) (test4 profile))
        ((5) (test5 profile))
        ((6) (test6 profile))
        ((7) (test7 profile))
        ((8) (test8 profile))
        ((9) (test9 profile)))))
  
  
  (method package (on-focus-next-process self evt)
    (let ((focused (get-focused-process (get-debugger-manager)))
          (processes (collect-processes)))
      (define (next-process rank)
        (if (not rank)
            (first processes)
          (let ((next-rank (modulo (+ rank 1) (length processes))))
            (element processes next-rank))))
      
      (unless (null? processes)
        (focus-process (get-debugger-manager) (next-process (find processes focused test: debugged=?))))))
  
  
  (method package (on-focus-previous-process self evt)
    (let ((focused (get-focused-process (get-debugger-manager)))
          (processes (collect-processes)))
      (define (previous-process rank)
        (if (not rank)
            (last processes)
          (let ((previous-rank (modulo (- rank 1) (length processes))))
            (element processes previous-rank))))
      
      (unless (null? processes)
        (focus-process (get-debugger-manager) (previous-process (find processes focused test: debugged=?))))))


  (method package (on-reload-process self evt)
    (let ((debugged (get-focused-process (get-debugger-manager))))
      (if (not debugged)
          (bell)
        (reload-process debugged))))
  

  (method package (on-debug-views self evt)
    (debug-views (current-view-debugger)))
  
  
  (method package (on-explore-views self evt)
    (explore-views (current-view-debugger)))
  
  
  (method package (on-processes self evt)
    (select-docked Processes-View workspace: 'debugger focus?: #t))
  
  
  (method package (on-threads self evt)
    (select-docked Threads-View workspace: 'debugger focus?: #t))
  
  
  (method package (on-frames self evt)
    (select-docked Frames-View workspace: 'debugger focus?: #t))
  
  
  (method package (on-restarts self evt)
    (select-docked Restarts-View workspace: 'debugger focus?: #t))
  
  
  (method package (on-exception self evt)
    (select-docked Exception-View workspace: 'debugger focus?: #t))
  
  
  (method package (on-variables self evt)
    (select-docked Variables-View workspace: 'debugger focus?: #t))
  
  
  (method (on-resources-monitor self evt)
    (show-palette Resources-Monitor))


  (method package (on-logs-viewer self evt)
    (show-palette Logs-Viewer))

  
  (method (on-browse-class self evt)
    (let ((target (determine-browse-target self)))
      (let ((host (new-frame Class-Browser initialize: (lambda (view)
                                                         (when target
                                                           (set-class-name view target))))))
        (let ((browser (get-guest host)))
          (focus-class-name browser)
          (when target
            (browse browser))))))

  
  (method (on-browse-method self evt)
    (let ((target (determine-browse-target self)))
      (let ((host (new-frame Class-Browser initialize: (lambda (view)
                                                         (when target
                                                           (set-method-name view target))))))
        (let ((browser (get-guest host)))
          (focus-method-name browser)
          (when target
            (browse browser))))))
  
  
  (method (determine-browse-target self)
    (let ((focus (active-focus)))
      (and (is? focus Code-Text-View)
           (let ((form (current-expr focus)))
             (and form
                  (standardize-form focus form #t))))))

  
  (method package (on-edit-clipboard self evt)
    (let ((clipboard (get-clipboard-text)))
      (if (string? clipboard)
          (edit-definitions self clipboard)
        (bell))))
  
  
  (method public (get-workbench-manager self)
    (get-guest (singleton-docked Workbench-Manager)))
  
  
  (method package (on-select-project self evt)
    (select-current (get-workbench-manager self)))
  
  
  (method package (on-edit-project self evt)
    (edit-current (get-workbench-manager self)))
  
  
  (method package (on-compile-file self evt)
    (compile-current (get-workbench-manager self)))
  
  
  (method package (on-preprocess-file self evt)
    (preprocess-current (get-workbench-manager self)))
  
  
  (method package (on-build-project self evt)
    (build-current (get-workbench-manager self)))
  
  
  (method package (on-clean-project self evt)
    (clean-current (get-workbench-manager self)))
  
  
  (method package (on-view-project-log self evt)
    (view-log (get-workbench-manager self)))
  
  
  (method package (on-configure-project self evt)
    (configure-current (get-workbench-manager self)))
  
  
  (method package (on-run-project self evt)
    (run-current (get-workbench-manager self)))
  
  
  (method package (on-debug-project self evt)
    (debug-current (get-workbench-manager self) executable: (if (get-shift? evt) (choose-kernel) #f)))
  
  
  (method package (on-test-project self evt)
    (test-current (get-workbench-manager self)))
  
  
  (method package (on-validate-project self evt)
    (validate-current (get-workbench-manager self)))
  
  
  (method package (on-distribute-project self evt)
    (distribute-current (get-workbench-manager self)))
  
  
  (method package (on-dependencies-analyser self evt)
    (select-docked Dependencies-Analyser focus?: #t))
  
  
  (method package (on-references-analyser self evt)
    (select-docked References-Analyser focus?: #t))
  
  
  (method (on-toolbox self evt)
    (select-docked Toolbox-Manager workspace: 'designer focus?: #t))
  
  
  (method (on-traits self evt)
    (select-docked Traits-Editor workspace: 'designer focus?: #t))
  
  
  (method (on-descendants self evt)
    (select-docked Descendants-Editor workspace: 'designer focus?: #t))
  
  
  (method (on-showcase self evt)
    (new-frame Showcase))

  
  ;;;
  ;;;; Analysis
  ;;;
  
  
  (definition debug-analysis?
    #f)
  
  
  (method (with-lisp-text-view self proc)
    (let ((focus (active-focus)))
      (if (is? focus Lisp-Text-View)
          (proc focus)
        (bell))))
  
  
  (method (on-analyse self evt)
    (with-lisp-text-view self
      (lambda (text)
        (analyse-selection self text))))
  
  
  (method (on-analyse-buffer self evt)
    (with-lisp-text-view
      (lambda (text)
        (analyse-buffer self text))))
  
  
  (method (analyse-selection self text)
    (with-safe-explore
      (lambda ()
        (let ((range (current-declaration-range text)))
          (if (not range)
              (bell)
            (analyse-range self text range))))))
  
  
  (method (analyse-buffer self text)
    (analyse-range self text (buffer-selection text)))
  
  
  (method (analyse-range self text range)
    (define (determine-kernel)
      (project-kernel (current-project (get-workbench-manager (current-application)))))
    
    (let ((moniker (get-moniker text)))
      (if (not moniker)
          (bell)
        (user-message "Analysing...")
        (let ((info (prepare-expressions text range)))
          (thread-start!
            (new-thread
              (lambda ()
                (let ((server-port (open-tcp-server 0)))
                  (let ((port-args (list "-port" (number->string (socket-info-port-number (tcp-server-socket-info server-port))))))
                    (if debug-analysis?
                        (let ((command (format "{s} {l}"
                                               (parse (determine-kernel))
                                               `("-run" "builder" "analyse" ,@port-args))))
                          (set-clipboard-text command)
                          (user-message "Clipboard set to shell command"))
                      (open-process
                        (list
                          path: (parse (determine-kernel))
                          arguments: `("-:daqQ-" "-run" "builder" "analyse" ,@port-args)
                          stdin-redirection: #f
                          stdout-redirection: #f
                          stderr-redirection: #f
                          show-console: #f))))
                  (let ((port (read server-port)))
                    (write-binary info port)
                    (force-output port)
                    (let ((info (read-binary port)))
                      (clear-user-message)
                      (unless (eof-object? info)
                        (bind (what expr detail) info
                          (post-event
                            (lambda ()
                              (case what
                                ((none)
                                 (message-box "Found no problems")
                                 (clear-problems (get-problems-view)))
                                ((walk)
                                 (let ((walk-debugger (get-local-debugger (current-application)))
                                       (walk-cookie #f))
                                   (report-walk-problems walk-debugger (get-local-process) detail walk-cookie)))
                                ((error)
                                 (message-box expr type: 'problem)))))))))))
              'analyse))))))


  ;;;
  ;;;; Tools-Menu
  ;;;
  
  
  (method package (on-properties self evt)
    (select-docked Properties-Manager focus?: #t))

  
  (method package (on-search-results self evt)
    (select-docked Search-Results focus?: #t))

  
  (method package (on-profile-results self evt)
    (select-docked Profile-Results focus?: #t))

  
  (method package (on-tracking-results self evt)
    (select-docked Tracking-Results focus?: #t))

  
  (method package (on-log-details self evt)
    (select-docked Logs-Manager focus?: #t))
  
  
  (method package (on-servers self evt)
    (select-docked Servers-Manager focus?: #t))

  
  (method package (on-output-log self evt)
    (select-docked Output-Log focus?: #t))

  
  (method package (on-user-log self evt)
    (let ((user-log (select-docked User-Log focus?: #t)))
      (refresh user-log)))

  
  (method package (on-activities self evt)
    (select-docked Activities-Manager focus?: #t))

  
  (method package (on-workbench self evt)
    (select-docked Workbench-Manager focus?: #t))
  
  
  (method package (get-repositories-manager self)
    (get-guest (singleton-docked Repositories-Manager)))

  
  (method package (on-repositories self evt)
    (select-docked Repositories-Manager focus?: #t))
  
  
  (method package (on-favorites self evt)
    (select-docked Favorites-Manager focus?: #t))

  
  (method package (on-chapters self evt)
    (select-docked Chapters-Browser workspace: 'text focus?: #t))

  
  (method package (on-hierarchy self evt)
    (select-docked Hierarchy-Browser workspace: 'text focus?: #t))

  
  (method package (on-summary self evt)
    (select-docked Summary-View workspace: 'text focus?: #t))

  
  (method package (on-problems self evt)
    (select-docked Problems-View workspace: 'text focus?: #t))
  
  
  (method package (on-bindings-manager self evt)
    (let ((frame (find-frame-host Bindings-Manager)))
      (if frame
          (focus-host frame)
        (new-frame Bindings-Manager))))
  
  
  (method package (on-view-bindings self evt)
    (get-modal Shortcut-Viewer))
  
  
  (method package (on-skins-manager self evt)
    (let ((frame (find-frame-host Skins-Manager)))
      (if frame
          (focus-host frame)
        (new-frame Skins-Manager))))
  
  
  (method package (on-designer-try-out self evt)
    (let ((manager (get-designer-manager (current-application))))
      (if (not manager)
          (bell)
        (on-try-out manager (make-event Event :action self)))))
  
  
  (method package (on-preferences self evt)
    (new-frame Preferences-Manager))
  
  
  (method package (on-recording self evt)
    (new-frame Recording-Manager))
  
  
  (method package (on-save-profile self evt)
    (with-cursor :wait
      (lambda ()
        (user-message "Saving profile...")
        (call-save-environment-listeners self)
        (call-quit-listeners self)
        (persist-preferences self)
        (save-bindings self)
        (save-workspaces self)
        (user-message "Done"))))
  
  
  (method package (on-quit-without-save self evt)
    (when (eq? (message-box "Are you sure you want to quit without saving?" type: 'question) 'yes)
      (quit)))
  
  
  (method package (on-compare-directories self evt)
    (if (get-shift? evt)
        (let ((default (get-active-configuration (current-preferences '(tools compare-directories)))))
          (if (not default)
              (new-frame Compare-Directories)
            (let ((frame (new-frame Compare-Directories host-visible?: #f)))
              (with-cursor :wait
                (lambda ()
                  (configure (get-guest frame) default)
                  (compare-trees (get-guest frame))
                  (focus-host frame))))))
      (new-frame Compare-Directories)))
  
  
  (method package (on-compare-files self evt)
    (new-frame Compare-Files))

  
  (method package (on-compare-databases self evt)
    @convert/wait
    (new-frame Compare-Databases))
  
  
  (method package (on-snapshots-explorer self evt)
    (new-frame Snapshots-Explorer))
  
  
  (method package (on-leaks-explorer self evt)
    (new-frame Leaks-Explorer))
  
  
  (method package (on-git-explorer self evt)
    (new-frame Git-Explorer))
  
  
  (method package (on-merge-git-conflict self evt)
    (let ((text (active-focus)))
      (if (is? text Text-View)
          (let ((frame (new-frame Threeway-Compare-Texts host-workspace: (get-name (selected-workspace)) host-visible?: #f)))
            (let ((threeway (get-guest frame)))
              (merge-conflict threeway text)
              (focus-host frame)))
        (message-box "No text currently focused"))))
  

  (method package (on-recording-manager self evt)
    (let ((frame (find-frame-host Recording-Manager)))
      (if frame
          (focus-host frame)
        (new-frame Recording-Manager))))
  

  ;;;
  ;;;; Catalog
  ;;;


  (method override (setup-cataloguer self)
    (set-cataloguer (new Workbench-Cataloguer)))
  
  
  (method protected virtual (preload-catalogs self)
    (let ((update? (or (get-first-startup? (current-preferences #f))
                       (get-startup-update? (current-preferences 'catalog)))))
      ;; using delay-event to load the catalogs after the run loop is
      ;; started ensures that the null? test on the load-stack passes
      (delay-event
        (lambda ()
          (load-catalogs-threaded (get-workbench) update?)))))
  
  
  (method package virtual (save-catalogs self)
    (when (use-profile? self)
      (save-catalogs (get-cataloguer))))
  
  
  (method (on-projects-manager self evt)
    (let ((frame (find-frame-host Projects-Manager)))
      (if frame
          (focus-host frame)
        (new-frame Projects-Manager))))

  
  (method (on-update-catalogs self evt)
    (with-cursor :wait
      (lambda ()
        (update-catalogs (get-workbench)))))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  (method (on-zoom-out self evt)
    (scale-view self (get-property evt what:) 0.75))
  
  
  (method (on-zoom-in self evt)
    (scale-view self (get-property evt what:) 1.25))
  
  
  (method (on-unzoom self evt)
    (scale-view self (get-property evt what:) #f))
  
  
  (method package (scale-view self what factor)
    (define (scaled-view what)
      (case what
        ((document) (current-document))
        ((mouse-view) (active-mouse-view))))
    
    (let ((view (scaled-view what)))
      (if (not view)
          (bell)
        (scale-view view factor)
        (user-message "Scaling set to {a}" (get-scaling view)))))


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (on-capture-document self evt)
    (pick-figure
      click: (lambda (view pos) (capture-document view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-document self evt)
    (let ((view (active-mouse-view)))
      (if (not view)
          (bell)
        (capture-document view))))
  
  
  (definition (capture-document view)
    (let ((host (get-host view)))
      (if (not host)
          (bell)
        (let ((guest (get-guest view)))
          (if (not guest)
              (bell)
            (export-picture guest))))))
  
  
  (method (on-capture-host self evt)
    (pick-figure
      click: (lambda (view pos) (capture-host view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-host self evt)
    (let ((view (active-mouse-view)))
      (if (not view)
          (bell)
        (capture-host view))))
  
  
  (definition (capture-host view)
    (let ((host (get-host view)))
      (if (not host)
          (bell)
        (export-picture host))))))
