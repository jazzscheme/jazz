;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; IO
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.io jazz


(import (time))


;;;
;;;; End of line
;;;


;; work around a bug where gambit doesn't save as cr-lf on windows


(definition *eol-encoding*
  (platform-eol-encoding kernel-platform))


(definition public (get-eol-encoding)
  *eol-encoding*)


(definition public (set-eol-encoding encoding)
  (set! *eol-encoding* encoding))


;;;
;;;; Path
;;;


(definition public (path-settings pathname . rest)
  (bind-keywords ((char-encoding #f) (eol-encoding #f) . others) rest
    `(path: ,(parse~ pathname)
      ,@(if char-encoding
            `(char-encoding: ,char-encoding)
          '())
      eol-encoding: ,(or eol-encoding *eol-encoding*)
      ,@others)))


;;;
;;;; Aliases
;;;


(class Alias extends Object
  
  
  (slot path   getter generate)
  (slot parent accessors generate)
  (slot table  getter explicit initialize #f)
  
  
  (method override (initialize path (parent: parent #f))
    (set! path~self path)
    (set! parent~self parent))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (cond ((eq? self *root-alias*)
               (format output ":root"))
              ((not parent)
               (format output ""))
              (else
               (format output "{a}" (get-anchor)))))))
  
  
  (method protected (get-anchor)
    (define (collect-names)
      (let (iterate (parent parent)
                    (alias self)
                    (names '()))
        (if (not parent)
            names
          (let ((name (table-find (get-table~ parent) alias)))
            (if (not name)
                names
              (iterate (get-parent~ parent) parent (cons (symbol->string name) names)))))))
    
    (if (not parent)
        #f
      (let ((names (collect-names)))
        (assert (not-null? names)
          (string->symbol (join names ":"))))))
  
  
  (method public (get-table)
    (or table (let ((table (make-table test: eq?)))
                (set! table~self table)
                table)))
  
  
  (method public (get-children)
    (table-values (get-table)))
  
  
  (method public (get-descendant-anchors)
    (let ((queue (new-queue)))
      (for-each-alias self
        (lambda (alias)
          (unless (eq? alias self)
            (enqueue queue (get-anchor~ alias)))))
      (queue-list queue)))
  
  
  (method public (get-anchors)
    (cons (get-anchor) (get-descendant-anchors))))


(class Unknown-Alias-Exception extends Exception
  
  
  (slot alias getter generate)
  
  
  (method override (initialize alias)
    (set! alias~self alias))
  
  
  (method override (get-message)
    (format "Unknown alias: {t}" alias)))


(definition *root-alias*
  (new Alias #f))

(definition public (get-aliases)
  (get-table~ *root-alias*))

(definition public (get-root-alias)
  *root-alias*)


(definition public (is-alias? name)
  (boolean (find-alias name)))


(definition public (valid-alias? name)
  (is-alias? name))


(definition public (get-alias name (error?: error? #t))
  (let ((result (find-alias name)))
    (if result
        (get-path~ result)
      (when error?
        (throw (new Unknown-Alias-Exception name))))))


(definition public (set-alias! name path)
  (let ((result (find-alias name)))
    (if result
        (table-set! (get-parent~ result)
                    (last (split-symbol name #\:))
                    path)
      (throw (new Unknown-Alias-Exception name)))))


(definition public (find-alias name (root: root #f) (error?: error? #f))
  (find-path-alias (split-symbol name #\:) root error?))


(definition protected (find-path-alias path root error?)
  (let (iterate (path path)
                (result (or root (get-root-alias))))
    (if (null? path)
        result
      (let ((name (car path)))
        (let ((alias (table-ref (get-table~ result) name #f)))
          (if alias
              (iterate (cdr path) alias)
            (when error?
              (throw (new Unknown-Alias-Exception name)))))))))


(definition public (require-alias name)
  (find-alias name error?: #t))


(definition protected (canonical-alias name root)
  (let ((root (cond ((not root) (get-root-alias))
                    ((is? root Alias) root)
                    (else (require-alias root))))
        (path (split-symbol name #\:)))
    (if (= (length path) 1)
        (values root name)
      (values (find-path-alias (butlast path) root #t) (last path)))))


(definition public (register-alias name path (root: root #f) (override?: override? #f))
  (define (expand-up path)
    (let ((dir (anchorize~ (get-parent~ (new Directory (list (car path)))) ignored-anchors: (list name)))
          (sub (cddr path)))
      (append (get-list~ dir) sub)))
  
  (define (process-up path)
    (if (and (pair? path)
             (>= (length path) 2)
             (eq? (second path) :up))
        (process-up (expand-up path))
      path))
  
  (define (set-alias root name alias)
    (let ((table (get-table~ root)))
      (if (and (table-ref table name #f) (not override?))
          (error "Alias already registered: {s}" name)
        (table-set! table name alias)
        alias)))
  
  (receive (root name) (canonical-alias name root)
    (typecase path
      ((Alias)
       (set-alias root name path))
      (else
       (set-alias root name (new Alias (process-up path) parent: root))))))


(definition public (unregister-alias name (root: root #f))
  (receive (root name) (canonical-alias name root)
    (let ((table (get-table~ root)))
      (if (table-ref table name #f)
          (table-clear table name)
        (error "The alias {s} does not exist" name)))))


(definition public (for-each-alias alias proc)
  (proc alias)
  (iterate-table (get-table~ alias)
    (lambda (name child)
      (for-each-alias child proc))))


(definition public initialize-aliases
  (let ((initialized? #f))
    (lambda ()
      (define (initialize-home)
        (let ((arg (command-argument "home")))
          (when arg
            (setenv "HOME" arg))))
      
      (define (register-home)
        (register-alias 'Home (tokenise-filename (pathname-normalize "~"))))
      
      (define (register-settings)
        (register-alias 'Jazz-Settings (if jazz-settings-directory
                                           (tokenise-filename jazz-settings-directory)
                                         '("~" ".jazz")))
        (register-alias 'Settings '(Jazz-Settings)))
      
      (define (register-repositories)
        (for-each register-repository-aliases (get-repositories)))
      
      (define (register-build-repository)
        (let ((repository (get-build-repository)))
          (when repository
            (register-repository-alias repository))))
      
      (when (not initialized?)
        (register-platform-aliases)
        (initialize-home)
        (register-home)
        (register-settings)
        (register-repositories)
        (register-build-repository)
        (set! initialized? #t)))))


(cond-expand
  (windows
    (definition (register-platform-aliases)
      (register-alias 'Network "\\\\")))
  (else
    (definition (register-platform-aliases)
      )))


(definition public (register-repository-aliases repository)
  (define (register-repository-packages repository repository-alias)
    (let ((name (repository-name repository)))
      (for-each (lambda (package)
                  (let ((package-name (package-name package))
                        (package-root (package-root package)))
                    (register-alias package-name
                                    `(,name ,@(tokenise-filename package-root))
                                    root: repository-alias)))
                (repository-packages repository))))
  
  (unless (repository-binary? repository)
    (let ((repository-alias (register-repository-alias repository)))
      (when repository-alias
        (register-repository-packages repository repository-alias)))))


(definition public (register-repository-alias repository)
  (let ((name (repository-name repository)))
    ;; this test is a quick fix for the .buildini that can register a repo twice
    (unless (is-alias? name)
      (let ((directory (remove-trailing-char (repository-directory repository) #\/)))
        (register-alias name (tokenise-filename directory))))))


(definition (validate-alias name path)
  (if (exists?~ (new Directory path))
      path
    (error "Unable to set alias {t} to inexistant directory: {t}" name path)))


;;;
;;;; Path
;;;


(definition public (extract-name filename <string>) <string>
  (let ((pos (find filename #\/ reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename (+ pos 1) (cardinality filename)))))


(definition public (extract-base filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename 0 pos))))


(definition public (extract-extension filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (when pos
      (subseq filename (+ pos 1) (cardinality filename)))))


(cond-expand
  (windows
    (definition public (filename=? x y)
      (ci=? x y))
    
    (definition public (extension=? x y)
      (ci=? x y))
    
    (definition public filename=?-hash
      string-ci=?-hash))
  (else
    (definition public (filename=? x y)
      (equal? x y))
    
    (definition public (extension=? x y)
      (equal? x y))
    
    (definition public filename=?-hash
      string=?-hash)))


(cond-expand
  (windows
   (definition (normalize-filename-separators filename <string>)
     (substitute #\\ #\/ filename)))
  (else
   (definition (normalize-filename-separators filename <string>)
     filename)))


(cond-expand
  (windows
    (definition public (platform-filename filename <string>)
      (substitute #\/ #\\ filename)))
  (else
   (definition public (platform-filename filename <string>)
     filename)))


(definition public (tokenise-filename filename <string>)
  (let ((lst (split (normalize-filename-separators filename) "/")))
    (if (empty-string? (car lst))
        (cons :root (remove-empty (cdr lst)))
      (remove-empty lst))))


(definition public (tokenise-windows filename <string>)
  (if (starts-with? filename "\\\\")
      (cons 'Network (remove-empty (split (subseq filename 2 (cardinality filename)) "\\")))
    (remove-empty (split filename "\\"))))


(definition public (make-filename base extension)
  (format "{a}.{a}" base extension))


;;;
;;;; Moniker
;;;


(class Moniker-Class extends Class
  
  
  (method public virtual (get-protocol)
    ))


(class Moniker metaclass Moniker-Class extends Object
  
  
  (method public virtual (compare-pathname object)
    #f)
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method public virtual (present)
    )
  
  
  (method public virtual (present-base)
    (->string (get-base)))
  
  
  (method public virtual (present-name)
    (->string (get-name)))
  
  
  (method public virtual (present-location)
    (format "{l detail: :human}" (get-list)))
  
  
  ;;;
  ;;;; Interface
  ;;;


  (method public virtual (exists?)
    )
  
  
  (method public (read-only?)
    (not (get-writable?)))
  
  
  (method public (read/write?)
    (get-writable?))
  
  
  (method public (set-read-only)
    (set-writable? #f))
  
  
  (method public (set-read/write)
    (set-writable? #t))
  
  
  (method public virtual (get-writable?)
    )
  
  
  (method public virtual (set-writable? flag)
    )
  
  
  (method public virtual (writable?)
    )


  (method public virtual (get-modification-time)
    )


  (method public virtual (get-file)
    )


  (method public virtual (get-name)
    )


  (method public virtual (get-base)
    )
  
  
  (method public virtual (get-extension)
    )


  (method public virtual (get-list)
    )
  
  
  (method public virtual (get-parent)
    )
  
  
  (method public (get-hierarchy)
    (let (loop (moniker self) (hierarchy '()))
      (if (not moniker)
          hierarchy
        (loop (get-parent~ moniker) (cons moniker hierarchy)))))
  
  
  (method public virtual (get-content . rest)
    )
  
  
  ;; I think this is only for depot monikers and should probably be removed
  (method public virtual (get-children . rest)
    )
  
  
  (method public virtual (is-different? moniker)
    )
  
  
  (method public (relocated-list old-root new-root)
    (append (get-list~ new-root) (tail (get-list) (length (get-list~ old-root)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;


  (method public virtual (load-lines . rest)
    )


  (method public virtual (save-lines lines . rest)
    )
  
  
  (method public virtual (load-form)
    ))


;;;
;;;; Pathname
;;;


(cond-expand
  (windows
    (definition platform-separator
      "\\"))
  (else
    (definition platform-separator
      "/")))


(class Pathname-Class extends (:class Moniker))


(class Pathname metaclass Pathname-Class extends Moniker
  
 
  (slot path)
  (slot context initialize #f accessors generate)
  
  
  (method override (initialize lst)
    (nextmethod)
    (validate-components lst)
    (set-list lst))
  
  
  (method protected virtual (validate-components object)
    (let ((original object))
      (define (validate object)
        (cond ((null? object))
              ((string? object))
              ((symbol? object))
              ((pair? object)
               (if (pair? (car object))
                   (error "Bad pathname component {t} of {t}" (car object) original)
                 (validate (car object))
                 (validate (cdr object))))
              (else (error "Bad pathname component {t} of {t}" object original))))
      
      (validate object)))
  
  
  (method public (parse . rest)
    (bind-optionals ((separator "/")) rest
      (let ((output (open-output-string))
            (first? #t)
            (aliases '()))
        (define (validate-recursive symbol)
          (unless (eq? symbol :context)
            (if (memq? symbol aliases)
                (error "Recursive alias {a} in {s}" symbol self)
              (set! aliases (cons symbol aliases)))))
        
        (define (parse path)
          (cond ((null? path))
                ((eq? path :root)
                 (display "/" output))
                ((string? path)
                 (if first?
                     (set! first? #f)
                   (display separator output))
                 (display path output))
                ((symbol? path)
                 (validate-recursive path)
                 (if (pathname-alias? path)
                     (parse (pathname-alias path))
                   (throw (new Unknown-Alias-Exception path))))
                ((pair? path)
                 (parse (car path))
                 (parse (cdr path)))
                (else
                 (error "Bad pathname component {t}" path))))
        
        (parse (get-list))
        (add-suffix output)
        (pathname-expand (get-output-string output)))))
  
  
  (method public (platform-parse)
    (parse platform-separator))
  
  
  (method protected virtual (add-suffix output)
    )
  
  
  (method override public (present-location)
    (format "{l detail: :human}"
            (if context
                (append (get-path~ context) (cdr (get-list)))
              (get-list))))
  
  
  (method public (relocated-pathname old-root new-root)
    (append (get-list~ new-root) (tail (get-list) (length (get-list~ old-root)))))


  (method public virtual (create)
    )


  (method public (move-pathname dst (error?: error? #t))
    (file-rename (parse) (parse~ dst)))
  
  
  (method override (compare-object target)
    (cond ((is-not? target (class-of self))
           :incompatible)
          ((= (get-list) (get-list~ target))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (compare-pathname object)
    (and (is? object Pathname)
         (filename=? (parse) (parse~ object))))
  
  
  (method public (context-alias?)
    (eq? (car path) :context))
  
  
  (method public (pathname-alias? alias)
    (or (is-alias? alias)
        (and (eq? alias :context) context)))
  
  
  (method public (pathname-alias alias)
    (if (eq? alias :context)
        (if context 
            (get-path~ context)
          (error "No context alias specified"))
      (get-alias alias)))
  
  
  (method public (expand)
    (let ((fact (new List-Factory)))
      (define (expand object)
        (cond ((eq? object #t))
              ((eq? object :root) (put~ fact :root))
              ((string? object) (put~ fact object))
              ((symbol? object) (expand (pathname-alias object)))
              ((pair? object)
               (expand (car object))
               (expand (cdr object)))))
      
      (expand (get-list))
      (get-output~ fact)))
  
  
  (method public (expand-context)
    (if context
        (append (get-path~ context) (cdr (get-list)))
      (get-list)))


  (method override (get-list)
    path)


  (method public (set-list value)
    (set! path value))

  (method override (get-name)
    (effective-name (get-list)))
  
  
  (method (effective-name lst)
    (let ((name (last lst)))
      (cond ((eq? name :root)
             "/")
            ((symbol? name)
             (effective-name (pathname-alias name)))
            (else
             (extract-name name)))))
  
  
  (method override (get-base)
    (let ((name (get-name)))
      (if (symbol? name)
          name
        (extract-base name))))
  
  
  (method override (get-extension)
    (extract-extension (get-name)))
  
  
  (method override (get-parent)
    (let ((path (expand-context)))
      (let ((effective-path (if (= (length path) 1) (expand) path)))
        (if (or (null? effective-path) (null? (cdr effective-path)))
            #f
          (new Directory (butlast effective-path))))))
  
  
  (method public (get-brother name)
    (new (class-of self) (append (get-list~ (get-parent)) (list name))))
  
  
  (method public virtual (new-brother name)
    )
  
  
  (method public virtual (get-directory)
    )
  
  
  (method public (get-attributes (error?: error? #t))
    (unimplemented 'get-attributes)
    @windows-specific
    (let ((attributes (GetFileAttributes (parse))))
      (if (= attributes -1)
          (when error?
            (error "Unable to get file attributes for {t}" self))
        attributes)))
  
  
  (method public (set-attributes flags)
    (unimplemented 'set-attributes)
    @windows-specific
    (let ((ok? (SetFileAttributes (parse) flags)))
      (when (not ok?)
        (error "Unable to set file attributes for {t}" self))))
  
  
  (method override (get-writable?)
    #t ;; super quicky
    @windows-specific
    (not (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_READONLY)))
  
  
  (method override (set-writable? flag)
    (unimplemented 'set-writable?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_READONLY (not flag))))


  (method override (exists?)
    (file-exists? (parse)))


  (method (is-directory?)
    (and (exists?)
         (eq? (pathname-type (parse))
              'directory)))
  
  
  (method public (create-directories)
    (let* ((base (get-directory))
           (scan (new Directory (expand~ base)))
           (dirs '()))
      ;; collect the directories reversed so that creation starts from the top
      (while scan
        (set! dirs (cons scan dirs))
        (set! scan (get-parent~ scan)))
      (for-each (lambda (dir)
                  (unless (exists?~ dir)
                    (create~ dir)))
                dirs)))
  
  
  (method public (subpath target)
    (let (iterate (path (expand))
                  (target-path (expand~ target)))
      (cond ((null? path)
             target-path)
            ((null? target-path)
             #f)
            ((filename=? (car path) (car target-path))
             (iterate (cdr path) (cdr target-path)))
            (else
             #f))))
  
  
  (method public (subpath? target)
    (boolean (subpath target)))


  ;;;
  ;;;; Anchoring
  ;;;
  
  
  (method public (anchor-to anchor (error?: error? #t))
    (let* ((base-list (get-list~ anchor))
           (base-expd (expand~ anchor))
           (base-length (length base-expd))
           (expd (expand))
           (rank (mismatch base-expd expd test: filename=?))
           (result-list (unspecified)))
      (continuation-capture
        (lambda (return)
          (cond ((not rank)
                 (set! result-list base-list))
                ((< rank base-length)
                 (if error?
                     (error "Unable to anchor pathname {t}, it is not a descendant of {t}" self anchor)
                   (continuation-return return #f)))
                (else
                 (set! result-list (append base-list (subseq expd base-length (length expd))))))
          (new (class-of self) result-list)))))
  
  
  (method public (anchorize (anchors: anchors #f) (ignored-anchors: ignored-anchors #f))
    (define (determine-anchors)
      (if (not anchors)
          (get-descendant-anchors~ (get-root-alias))
        (apply append (map get-anchors~ (map find-alias anchors)))))
    
    (let* ((anchors (difference (determine-anchors) (or ignored-anchors '())))
           (anchored (collect (lambda (anchor) (when (valid-alias? anchor) (anchor-to (new Directory (list anchor)) error?: #f))) anchors))
           (sorted (sort < anchored key: (lambda (path) (length (get-list~ path))))))
      (if (null? sorted)
          self
        (car sorted))))

  
  ;;;
  ;;;; Context
  ;;;


  (method override (setup-context toplevel-context)
    (when (context-alias?)
      (let ((data (get-data~ toplevel-context)))
        (when data
          (set! context (get-context~ data)))))))


(definition public inline (pathname? object)
  (is? object Pathname))


(definition public inline (pathname=? x <Moniker> y <Moniker>)
  (compare-pathname~ x y))


(definition public inline (pathname-exists? pathname <Pathname>)
  (file-exists? (parse~ pathname)))


(definition public inline (pathname-delete pathname <Pathname>)
  (file-delete (parse~ pathname)))


(definition public inline (pathname-modification-time pathname <Pathname>)
  (file-modification-time (parse~ pathname)))


(definition public (pathname-hash pathname <Pathname>)
  (filename=?-hash (parse~ pathname)))


;;;
;;;; File
;;;


(class File-Class extends (:class Pathname)
  
  
  (method override (get-protocol)
    'file))


(class File metaclass File-Class extends Pathname
  
  
  (method override (print output readably)
    (format output "~{File {l detail: :v}}"
            (get-list)
            readably))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother name)
    (new-file~ (get-parent) name))
  
  
  (method override (present)
    (format "{l}" (get-list)))
  
  
  ;;;
  ;;;; Operations
  ;;;


  (method override (get-file)
    self)
  
  
  (method override (get-directory)
    (get-parent))


  (method override (create)
    (unless (exists?)
      (create-directories)
      ;; is there any smarter way to do this in gambit?
      (call-with-output-file (path-settings self)
        (lambda (output)
          ))))


  (method public (copy-file dst (use-modification-time?: use-modification-time? #f) (overwrite?: overwrite? #t) (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback #f))
    (when (or (not use-modification-time?)
              (not (exists?~ dst))
              (/= (time->seconds (get-modification-time)) (time->seconds (get-modification-time~ dst))))
      (when feedback
        (feedback self))
      (overwrite-read-only~ dst overwrite-read-only?)
      (when (and overwrite? (exists?~ dst))
        (delete-file~ dst))
      (file-copy (parse) (parse~ dst))))
  
  
  (method public (delete-file (overwrite-read-only?: overwrite-read-only? #f) (error?: error? #t))
    (if (not (exists?))
        (when error?
          (error "Unable to delete inexistant file: {s}" self))
      (overwrite-read-only overwrite-read-only?)
      (file-delete (parse))))
  
  
  (method (overwrite-read-only overwrite-read-only?)
    @windows-specific
    (when (and overwrite-read-only? (exists?) (read-only?))
      (set-read/write)))
  
  
  (method public (get-size)
    (unimplemented 'get-size)
    @windows-specific
    (with ((input (new File-Reader self readable?: #f)))
      (get-size~ input)))


  (method override (get-modification-time)
    (seconds->time (fxfloor (file-modification-time (parse)))))


  (method public (set-modification-time time)
    (unimplemented 'set-modification-time)
    @windows-specific
    (let ((ft (get-filetime~ time))
          (at (get-attributes)))
      ;; this is ugly big time...
      (set-read/write)
      (call-with-output-file (path-settings self mode: 'append)
        (lambda (output)
          (SetFileTime (get-handle~ output) NULL NULL ft)))
      (set-attributes at)))
  
  
  (method public (touch)
    (unimplemented 'touch)
    @windows-specific
    (set-modification-time (get-time~ (universal-date))))
  
  
  (method public (get-hidden?)
    (unimplemented 'get-hidden?)
    @windows-specific
    (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_HIDDEN))
  
  
  (method public (set-hidden? flag)
    (unimplemented 'set-hidden?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_HIDDEN flag)))
  
  
  (method override (writable?)
    (and (exists?)
         (with-exception-filter
           os-exception?
           (lambda (exception) #f)
           (lambda ()
             (call-with-output-file (path-settings self append: #t)
               (lambda (port)
                 #t))))))
  
  
  (method public (clone-file extension)
    (new File (append (get-list~ (get-directory)) (list (format "{a}.{a}" (get-base) extension)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;


  (method override (load-lines (char-encoding: char-encoding #f) (char-encoding-errors: char-encoding-errors #t))
    (call-with-input-file (path-settings self char-encoding: (or char-encoding 'UTF) char-encoding-errors: char-encoding-errors eol-encoding: 'cr-lf)
      read-lines))


  (method override (save-lines lines (char-encoding: char-encoding #f) (eol-encoding: eol-encoding #f))
    (call-with-output-file (path-settings self char-encoding: (or char-encoding 'UTF-8) eol-encoding: eol-encoding)
      (lambda (output)
        (write-lines output lines)))))


(definition public inline (file? object)
  (is? object File))


(definition public (timestamped-file dir prefix ext)
  ;; if dir doesn't exists or is read-only we should provide a secondary dir that is always writable
  (let ((prefix (if prefix (format "{a}_" prefix) ""))
        (timestamp (date->string (system-date) "~Y-~m-~d_~H-~M-~S")))
    (let (iterate (n 0))
      (let ((suffix (if (= n 0) "" (format "_{a}" n))))
        (let ((file (new-file~ dir (format "{a}{a}{a}.{a}" prefix timestamp suffix ext))))
          (if (exists?~ file)
              (iterate (+ n 1))
            file))))))


;;;
;;;; Directory
;;;


(class Directory-Class extends (:class Pathname)
  
  
  (method override (get-protocol)
    'dir))


(class Directory metaclass Directory-Class extends Pathname
  
  
  (method override (print output readably)
    (format output "~{Directory {l detail: :v}}"
            (get-list)
            readably))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother name)
    (new-directory~ (get-parent) name))
  
  
  (method override (present)
    (format "{l}" (get-list)))
  
  
  ;;;
  ;;;; Operations
  ;;;
  
  
  (method override (get-directory)
    self)


  (method override (get-modification-time)
    #f)
  
  
  ;; ... give us this day our windows drives ...
  (cond-expand
    (windows
      (method override (get-parent)
        (let ((effective-path (if (= (length path) 1) (expand) path)))
          (if (= 1 (length effective-path))
              (new Windows-Meta-Root)
            (nextmethod)))))
    (else))
  
  
  (method override (create)
    (directory-create (parse)))
  
  
  (method public (new-file name)
    (add-context (new File (append (get-list) (if (null/pair? name) name (list name))))))
  
  
  (method public (new-directory name)
    (add-context (new Directory (append (get-list) (if (null/pair? name) name (list name))))))
  
  
  (method public (new-unique-file name (separator: separator "_"))
    (let ((file (new-file name)))
      (if (not (exists?~ file))
          file
        (let ((base (extract-base name))
              (ext (extract-extension name))
              (suffix 1))
          (while (exists?~ file)
            (set! file (new-file (format "{a}{a}{a width: 2 justify: :right padding: #\\0}.{a}" base (or separator "") suffix ext)))
            (increase! suffix))
          file))))
  
  
  (method (add-context pathname)
    (when context
      (set-context~ pathname context))
    pathname)


  (method public (copy-directory dst (copier: copier #f) (feedback: feedback #f) (touch-files?: touch-files? #f) (copy?: copy? #t) (use-modification-time?: use-modification-time? #f))
    (when feedback
      (feedback self))
    (create-directories~ dst)
    (let ((destination
            (lambda (path)
              (append (get-list~ dst) (list (get-name~ path))))))
      (iterate-directory
        (lambda (path)
          (when (or (eq? copy? #t) (copy? path))
            (if (is? path File)
                (let ((dest (new File (destination path))))
                  (if copier
                      (copier path dest)
                    (copy-file~ path dest use-modification-time?: use-modification-time? feedback: feedback)))
              (copy-directory~ path (new Directory (destination path)) feedback: feedback touch-files?: touch-files? copy?: copy? use-modification-time?: use-modification-time?))))
        files?: #t
        directories?: #t
        recursive?: #f)))
  
  
  (method public virtual (delete-directory (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback #f))
    (empty-directory overwrite-read-only?: overwrite-read-only? feedback: feedback)
    (remove-directory))
  
  
  (method public (empty-directory (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback #f))
    (iterate-directory
      (lambda (path)
        (if (is? path File)
            (delete-file~ path overwrite-read-only?: overwrite-read-only?)
          (delete-directory~ path overwrite-read-only?: overwrite-read-only? feedback: feedback)))
      files?: #t
      directories?: #t
      recursive?: #f))
  
  
  (method public (remove-directory)
    (directory-delete (parse)))
  
  
  (method override (get-content (nodes?: nodes? #t) (leaves?: leaves? #t))
    (define (collect-nodes fact)
      (iterate-directory
        (lambda (item)
          (put~ fact item))
        files?: #f
        directories?: #t
        recursive?: #f))
    
    (define (collect-leaves fact)
      (iterate-directory
        (lambda (item)
          (put~ fact item))
        files?: #t
        directories?: #f
        recursive?: #f))
    
    (let ((fact (new List-Factory)))
      (when nodes? (collect-nodes fact))
      (when leaves? (collect-leaves fact))
      (get-output~ fact)))
     
   
  ;;;
  ;;;; Parse
  ;;;
  
  
  (method override (add-suffix output)
    (write-char #\/ output))
     
   
  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (collect-files predicate)
    (let ((fact (new List-Factory)))
      (iterate-directory
        (lambda (file)
          (when (predicate file)
            (put~ fact file)))
        recursive?: #f)
      (get-output~ fact)))
     
   
  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (collect-directories)
    (let ((fact (new List-Factory)))
      (iterate-directory
        (lambda (dir)
          (put~ fact dir))
        files?: #f
        directories?: #t
        recursive?: #f)
      (get-output~ fact)))
  
  
  ;;;
  ;;;; Iterator
  ;;;
  
  
  (method public virtual (iterate-directory proc (full?: full? #t) (files?: files? #t) (directories?: directories? #f) (sort?: sort? #t) (recursive?: recursive? #t) (ignored-toplevel-dirnames: ignored-toplevel-dirnames #f) (ignored-toplevel-filenames: ignored-toplevel-filenames #f) (ignored-dirnames: ignored-dirnames #f))
    (define (iterate-directory-content files? directories? sort? recursive? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames prefix base proc)
      (iterate-content base 'directories sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
        (lambda (name)
          (when recursive?
            (iterate-directory-content files? directories? sort? recursive? #f #f ignored-dirnames (append prefix (list name)) (concatenate base "/" name) proc))
          (when directories?
            (proc (append prefix (list name)) 'directory))))
      (iterate-content base 'files sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
        (lambda (name)
          (when files?
            (proc (concatenate prefix (list name)) 'file)))))
    
    (define (iterate-content base kind sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
      (if (not sort?)
          (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
        (let ((list '()))
          (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
            (lambda (object)
              (set! list (cons object list))))
          (let ((sorted (sort ci<? list)))
            (for-each proc sorted)))))
    
    (define (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
      (define (ignored-name? name names)
        (and names (member? name names)))
      
      (for-each (lambda (name)
                  (let ((path (string-append base "/" name)))
                    ;; this extra test fixes problems on Windows with system files like C:/pagefile.sys
                    (when (file-exists? path)
                      (let ((type (pathname-type path)))
                        (when (or (and (eq? kind 'files) (eq? type 'regular) (not (ignored-name? name ignored-toplevel-filenames)))
                                  (and (eq? kind 'directories) (eq? type 'directory) (not (ignored-name? name ignored-toplevel-dirnames)) (not (ignored-name? name ignored-dirnames))))
                          (proc name))))))
                (directory-content-patch base)))
    
    (let ((directory (if full? (get-list) #f)))
      (iterate-directory-content files? directories? sort? recursive? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames '() (parse)
        (lambda (lst kind)
          (case kind
            ((file) (if full? (proc (new-file lst)) (proc lst 'file)))
            ((directory) (if full? (proc (new-directory lst)) (proc lst 'directory))))))))
  
  
  ;; quicky because showing .* files in the open dialog creates problems
  ;; on windows with the pagefile.sys file when getting its attributes...
  (cond-expand
    (windows
      (definition (directory-content-patch path)
        (directory-content path)))
    (else
      (definition (directory-content-patch path)
        (directory-content (list path: path ignore-hidden: 'dot-and-dot-dot)))))
  
  
  (method public (count-files (ignored-dirnames: ignored-dirnames #f) (filter: filter #f) (max-count: max-count #f))
    (let ((count 0))
      (continuation-capture
        (lambda (return)
          (iterate-directory
            (lambda (file)
              (when (or (not filter) (filter file))
                (increase! count)
                (when (and max-count (> count max-count))
                  (continuation-return return #f))))
            ignored-dirnames: ignored-dirnames)
          count)))))


;; class providing the ugly thing known as windows drives
(cond-expand
  (windows
    (class undocumented Windows-Meta-Root extends Pathname
      
      
      (method override (initialize)
        )

      
      (method override (get-name)
        "This Computer")
      
      
      (method override (present)
        (get-name))
      
      
      (method override (get-parent)
        #f)
      
      
      (method override (get-directory)
        (new Directory (list "C:")))
      
      
      (method override (exists?)
        #t)
      
      
      (method override (get-content (nodes?: nodes? #t) (leaves?: leaves? #t))
        (define (enumerate-drives)
          (reverse!
            (let (loop (drives (jazz.platform:GetLogicalDrives))
                       (letter (char->integer #\A))
                       (result '()))
              (if (= drives 0)
                  result
                (loop (arithmetic-shift drives -1) (+ letter 1)
                  (if (/= 0 (bitwise-and drives 1))
                      (cons (integer->char letter) result)
                    result))))))
        
        (let ((fact (new List-Factory)))
          (when nodes?
            (for-each (lambda (letter)
                        (put~ fact (new Directory (list (string letter #\:)))))
                      (enumerate-drives)))
          (get-output~ fact)))))

  (else))


(definition public inline (directory? obj)
  (is? obj Directory))


(definition public (get-current-directory)
  (new Directory (tokenise-filename (current-directory))))


(definition public (set-current-directory directory)
  (current-directory-set! (parse~ directory)))


(definition public (with-preserved-current-directory proc)
  (let ((preserved (get-current-directory)))
    (unwind-protect
        (proc)
      (set-current-directory preserved))))


;;;
;;;; Extension
;;;


(definition public Scheme-Extensions
  '("scm" "sch" "ss" "gambcini" "buildini" "jazzini" "jamini"))

(definition public Clojure-Extensions
  '("clj"))

(definition public CommonLisp-Extensions
  '("lisp"
    "el" ;; quick approximation until a dedicated emacs lisp class
    ))

(definition public Jazz-Extensions
  '("jazz" "jml" "dgs" "mnf" "otl" "repository" "package" "configuration" "settings" "project"))

(definition public Jazz-All-Extensions
  '("jazz" "jcat" "jlog" "jml" "dgs" "mnf" "otl" "repository" "package" "configuration" "settings" "snapshot" "project"))

(definition public Lisp-Extensions
  (append Scheme-Extensions
          Clojure-Extensions
          CommonLisp-Extensions
          Jazz-Extensions))

(definition public C-Extensions
  '("c" "cpp" "h" "hpp" "m"))

(definition public SQL-Extensions
  '("sql"))

(definition public Text-Extensions
  '(#f "conf" "css" "erl" "ftx" "htm" "java" "js" "log" "lua" "dgs" "mnf" "otl" "package" "prop" "properties" "py" "rc" "repository" "sh" "sql" "template" "txt"))

(definition public Textual-Extensions
  (append Lisp-Extensions
          C-Extensions
          Text-Extensions))

(definition public Binary-Extensions
  '("obj" "o" "o1" "o2" "o3" "o4" "o5" "o6" "o7" "o8" "o9" "a" "dll" "exe" "pack"))


(definition public (effective-extensions obj)
  (cond ((string? obj)
         (list obj))
        ((pair? obj)
         (apply union test: extension=? (map effective-extensions obj)))
        (else
         (case obj
           ((:scheme) Scheme-Extensions)
           ((:clojure) Clojure-Extensions)
           ((:commonlisp) CommonLisp-Extensions)
           ((:jazz) Jazz-Extensions)
           ((:lisp) Lisp-Extensions)
           ((:c) C-Extensions)
           ((:text) Text-Extensions)
           ((:textual) Textual-Extensions)
           (else obj)))))


(definition Scheme-Include-Extensions
  Scheme-Extensions)

(definition Clojure-Include-Extensions
  Clojure-Extensions)

(definition CommonLisp-Include-Extensions
  CommonLisp-Extensions)

(definition Jazz-Include-Extensions
  '("jazz" "jml" "repository" "package"))

(definition Lisp-Include-Extensions
  (append Scheme-Include-Extensions
          Clojure-Include-Extensions
          CommonLisp-Include-Extensions
          Jazz-Include-Extensions))

(definition C-Include-Extensions
  C-Extensions)

(definition Text-Include-Extensions
  Text-Extensions)

(definition Textual-Include-Extensions
  (append Lisp-Include-Extensions
          C-Include-Extensions
          Text-Include-Extensions))


(definition package (effective-include-extensions extensions)
  (if (not extensions)
      Textual-Include-Extensions
    (case extensions
      ((:scheme) Scheme-Include-Extensions)
      ((:clojure) Clojure-Include-Extensions)
      ((:commonlisp) CommonLisp-Include-Extensions)
      ((:jazz) Jazz-Include-Extensions)
      ((:lisp) Lisp-Include-Extensions)
      ((:c) C-Include-Extensions)
      ((:text) Text-Include-Extensions)
      ((:textual) Textual-Include-Extensions)
      (else extensions))))


(definition Scheme-Catalog-Extensions
  Scheme-Extensions)

(definition Clojure-Catalog-Extensions
  Clojure-Extensions)

(definition CommonLisp-Catalog-Extensions
  CommonLisp-Extensions)

(definition Jazz-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          '("jazz")))

(definition C-Catalog-Extensions
  C-Extensions)

(definition Text-Catalog-Extensions
  Text-Extensions)

(definition Textual-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          Clojure-Catalog-Extensions
          CommonLisp-Catalog-Extensions
          Jazz-Catalog-Extensions
          C-Catalog-Extensions
          Text-Catalog-Extensions))


(definition package (effective-catalog-extensions extensions)
  (if (not extensions)
      Textual-Catalog-Extensions
    (case extensions
      ((:scheme) Scheme-Catalog-Extensions)
      ((:clojure) Clojure-Catalog-Extensions)
      ((:commonlisp) CommonLisp-Catalog-Extensions)
      ((:jazz) Jazz-Catalog-Extensions)
      ((:c) C-Catalog-Extensions)
      ((:text) Text-Catalog-Extensions)
      ((:textual) Textual-Catalog-Extensions)
      (else extensions))))


(definition public (extension-constituent-test ext)
  (cond ((member? ext Jazz-Extensions test: extension=?) jazz-constituent?)
        ((member? ext Scheme-Extensions test: extension=?) scheme-constituent?)
        ((member? ext C-Extensions test: extension=?) c-constituent?)
        ((member? ext SQL-Extensions test: extension=?) sql-constituent?)
        (else word-constituent?))))
