;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; IO
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.io jazz


(hub anchorize)
(hub collect-files)
(hub compare-parse)
(hub context-alias?)
(hub context-setup?)
(hub copy-times)
(hub count-directories)
(hub count-files)
(hub create)
(hub create-directories)
(hub delete)
(hub delete-empty)
(hub duplicate)
(hub empty)
(hub exists?)
(hub expand)
(hub follow-component)
(hub follow-form)
(hub get-alias)
(hub get-anchor)
(hub get-anchors)
(hub get-attributes)
(hub get-base)
(hub get-children)
(hub get-content)
(hub get-context)
(hub get-descendant-anchors)
(hub get-directory)
(hub get-extension)
(hub get-file)
(hub get-hidden?)
(hub get-hierarchy)
(hub get-last-modification-seconds)
(hub get-last-modification-time)
(hub get-list)
(hub get-name)
(hub get-parent)
(hub get-path)
(hub get-protocol)
(hub get-size)
(hub get-table)
(hub get-title)
(hub install-directory)
(hub install-file)
(hub is-directory?)
(hub iterate-directory)
(hub load-binary)
(hub load-form)
(hub load-lines)
(hub meta-root?)
(hub new-brother)
(hub new-directory)
(hub new-file)
(hub new-unique-file)
(hub overwrite-read-only)
(hub parse)
(hub platform-parse)
(hub present)
(hub present-location)
(hub present-name)
(hub read-only?)
(hub rename)
(hub save-binary)
(hub save-lines)
(hub set-context)
(hub set-parent)
(hub set-path)
(hub set-read/write)
(hub subpath)


(export
  (jazz.io.Category-Moniker (autoload Category-Moniker))
  (jazz.io.Directory-Group (autoload Directory-Group Directory-Group-Class))
  (jazz.io.Manifest (autoload Manifest))
  (jazz.io.Path (autoload Path))
  (jazz.io.URL (autoload URL)))

(import (jazz.component.hubs)
        (jazz.time))


;;;
;;;; Settings
;;;


;; work around gambit not saving as cr-lf on windows
(definition *eol-encoding*
  (platform-eol-encoding kernel-platform))


(definition public (path-settings pathname . rest)
  (bind-keywords ((char-encoding #f) (eol-encoding #f) . others) rest
    `(path: ,(parse pathname)
      ,@(if char-encoding
            `(char-encoding: ,char-encoding)
          '())
      eol-encoding: ,(or eol-encoding *eol-encoding*)
      ,@others)))


;;;
;;;; Aliases
;;;


(class Alias extends Object
  
  
  (slot path   getter generate)
  (slot parent accessors generate)
  (slot table  getter explicit initialize #f)
  
  
  (method override (initialize self path (parent: parent #f))
    (set! self.path path)
    (set! self.parent parent))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (cond ((eq? self *root-alias*)
               (format output ":root"))
              ((not parent)
               (format output ""))
              (else
               (format output "{a}" (get-anchor self)))))))
  
  
  (method package (get-anchor self)
    (define (collect-names)
      (let (iterate (parent parent)
                    (alias self)
                    (names '()))
        (if (not parent)
            names
          (let ((name (table-find (get-table parent) alias)))
            (if (not name)
                names
              (iterate (get-parent parent) parent (cons (symbol->string name) names)))))))
    
    (if (not parent)
        #f
      (let ((names (collect-names)))
        (assert (not-null? names)
          (string->symbol (join names ":"))))))
  
  
  (method public (get-table self)
    (or table (let ((table (make-table test: eq?)))
                (set! self.table table)
                table)))
  
  
  (method public (get-children self)
    (table-values (get-table self)))
  
  
  (method public (get-descendant-anchors self)
    (let ((queue (new-queue)))
      (for-each-alias self
        (lambda (alias)
          (unless (eq? alias self)
            (enqueue queue (get-anchor alias)))))
      (queue-list queue)))
  
  
  (method public (get-anchors self)
    (cons (get-anchor self) (get-descendant-anchors self))))


(class Unknown-Alias-Exception extends Exception
  
  
  (slot alias getter generate)
  
  
  (method override (initialize self alias)
    (set! self.alias alias))
  
  
  (method override (get-message self)
    (format "Unknown alias: {t}" alias)))


(definition *root-alias*
  (new Alias #f))

(definition public (get-aliases)
  (get-table *root-alias*))

(definition public (get-root-alias)
  *root-alias*)


(definition public (is-alias? name)
  (boolean (find-alias name)))


(definition public (valid-alias? name)
  (is-alias? name))


(definition public (find-alias-path name (error?: error? #t))
  (let ((result (find-alias name)))
    (if result
        (get-path result)
      (and error? (throw (new Unknown-Alias-Exception name))))))


(definition public (set-alias! name path)
  (let ((result (find-alias name)))
    (if result
        (table-set! (get-parent result)
                    (last (split-symbol name #\:))
                    path)
      (throw (new Unknown-Alias-Exception name)))))


(definition public (find-alias name (root: root #f) (error?: error? #f))
  (find-path-alias (split-symbol name #\:) root error?))


(definition protected (find-path-alias path root error?)
  (let (iterate (path path)
                (result (or root (get-root-alias))))
    (if (null? path)
        result
      (let ((name (car path)))
        (let ((alias (table-ref (get-table result) name #f)))
          (if alias
              (iterate (cdr path) alias)
            (and error? (throw (new Unknown-Alias-Exception name)))))))))


(definition public (require-alias name)
  (find-alias name error?: #t))


(definition protected (canonical-alias name root)
  (let ((root (cond ((not root) (get-root-alias))
                    ((is? root Alias) root)
                    (else (require-alias root))))
        (path (split-symbol name #\:)))
    (if (= (length path) 1)
        (values root name)
      (values (find-path-alias (butlast path) root #t) (last path)))))


(definition public (register-alias name path (root: root #f) (override?: override? #f))
  (define (expand-up path)
    (let ((dir (anchorize (get-parent (new Directory (list (car path)))) ignored-anchors: (list name)))
          (sub (cddr path)))
      (append (get-list dir) sub)))
  
  (define (process-up path)
    (if (and (pair? path)
             (>= (length path) 2)
             (eq? (second path) :up))
        (process-up (expand-up path))
      path))
  
  (define (set-alias root name alias)
    (let ((table (get-table root)))
      (if (and (table-ref table name #f) (not override?))
          (error "Alias already registered: {s}" name)
        (table-set! table name alias)
        alias)))
  
  (receive (root name) (canonical-alias name root)
    (typecase path
      ((Alias)
       (set-alias root name path))
      (else
       (set-alias root name (new Alias (process-up path) parent: root))))))


(definition public (unregister-alias name (root: root #f))
  (receive (root name) (canonical-alias name root)
    (let ((table (get-table root)))
      (if (table-ref table name #f)
          (table-clear table name)
        (error "The alias {s} does not exist" name)))))


(definition public (for-each-alias alias proc)
  (proc alias)
  (iterate-table (get-table alias)
    (lambda (name child)
      (for-each-alias child proc))))


(definition public initialize-aliases
  (let ((initialized? #f))
    (lambda ()
      (define (initialize-home)
        (let ((arg (command-argument "home" error?: #f)))
          (when arg
            (setenv "HOME" arg))))
      
      (define (register-home)
        (register-alias 'Home (tokenise-filename (pathname-normalize (home-directory)))))
      
      (define (register-settings)
        (register-alias 'Jazz-Settings (if jazz-settings-directory
                                           (tokenise-filename jazz-settings-directory)
                                         '(Home ".jazz")))
        (register-alias 'Settings '(Jazz-Settings)))
      
      (define (register-repositories)
        (for-each register-repository-aliases (repositories-get)))
      
      (define (register-build-repository)
        (let ((repository (build-repository-get)))
          (when repository
            (register-repository-alias repository)
            (register-alias 'Libraries (tokenise-filename (parent-directory (repository-library-directory repository)))))))
      
      (define (register-bundle-repository)
        (when kernel-bundle-root
          (register-alias 'Bundle (tokenise-filename kernel-bundle-root))))
      
      (when (not initialized?)
        (register-platform-aliases)
        (initialize-home)
        (register-home)
        (register-settings)
        (register-repositories)
        (register-build-repository)
        (register-bundle-repository)
        (set! initialized? #t)))))


(cond-expand
  (windows
    (definition (register-platform-aliases)
      (register-alias 'Network "\\\\")))
  (else
    (definition (register-platform-aliases)
      )))


(definition public (register-repository-aliases repository)
  (define (register-repository-packages repository repository-alias)
    (let ((name (repository-name repository)))
      (for-each (lambda (package)
                  (let ((package-name (package-name package))
                        (package-root (package-root package)))
                    (register-alias package-name
                                    `(,name ,@(tokenise-filename package-root))
                                    root: repository-alias)))
                (repository-packages repository))))
  
  (unless (memq? (repository-name repository) '(Build Binaries))
    (let ((repository-alias (register-repository-alias repository)))
      (when repository-alias
        (register-repository-packages repository repository-alias)))))


(definition public (register-repository-alias repository)
  (let ((name (repository-name repository)))
    ;; this test is a quick fix for the .buildini that can register a repo twice
    (if (is-alias? name)
        #f
      (register-alias name (tokenise-filename (repository-directory repository))))))


(definition public (register-resources-alias app-alias product-name)
  (register-alias 'Resources
                  (cond ((is-alias? app-alias)
                         (list app-alias))
                        (bundle-depth
                         (append (butlast (tokenise-filename kernel-install)) (list "Resources")))
                        (else
                         (list 'Build)))))


(definition public (find-kernel-file filename)
  (let ((bundle-path (and kernel-bundle-install (string-append kernel-bundle-install filename))))
    (if (and bundle-path (file-exists? bundle-path))
        bundle-path
      (let ((install-path (string-append kernel-install filename)))
        (if (file-exists? install-path)
            install-path
          #f)))))


(definition public (require-kernel-file filename)
  (or (find-kernel-file filename)
      (error "Unable to find kernel file: {s}" filename)))


(definition (validate-alias name path)
  (if (exists? (new Directory path))
      path
    (error "Unable to set alias {t} to inexistant directory: {t}" name path)))


;;;
;;;; Filename
;;;


(definition public (filename-name filename <string>) <string>
  (let ((pos (find filename #\/ reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename (+ pos 1) (cardinality filename)))))


(definition public (filename-base filename <string>)
  (let ((name (filename-name filename)))
    (let ((pos (find name #\period reversed?: #t)))
      (if (not pos)
          name
        (subseq name 0 pos)))))


(definition public (filename-spine filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename 0 pos))))


(definition public (filename-extension filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (and pos (subseq filename (+ pos 1) (cardinality filename)))))


(definition public (filename-dir filename <string>)
  (let ((pos (find filename #\/ reversed?: #t)))
    (and pos (subseq filename 0 (+ pos 1)))))


;; case sensitivity
(cond-expand
  (linux
    (definition public (filename=? x y)
      (equal? x y))
    
    (definition public (extension=? x y)
      (equal? x y))
    
    (definition public filename=?-hash
      string=?-hash)
    
    (definition public filename-test
      nu<?)
    
    (definition public filename-compare
      compare))
  (else
    (definition public (filename=? x y)
      (ci=? x y))
    
    (definition public (extension=? x y)
      (ci=? x y))
    
    (definition public filename=?-hash
      string-ci=?-hash)
    
    (definition public filename-test
      ci<?)
    
    (definition public filename-compare
      ci-compare)))


;; separators
(cond-expand
  (windows
   (definition public (normalize-filename-separators filename <string>)
     (substitute #\\ #\/ filename)))
  (else
   (definition public (normalize-filename-separators filename <string>)
     filename)))


;; separators
(cond-expand
  (windows
    (definition public (platform-filename filename <string>)
      (substitute #\/ #\\ filename)))
  (else
   (definition public (platform-filename filename <string>)
     filename)))


(definition public (tokenise-filename filename <string>)
  (let ((lst (split (normalize-filename-separators filename) "/")))
    (if (empty-string? (car lst))
        (cons :root (remove-empty (cdr lst)))
      (remove-empty lst))))


(definition public (tokenise-windows filename <string>)
  (if (starts-with? filename "\\\\")
      (cons 'Network (remove-empty (split (subseq filename 2 (cardinality filename)) "\\")))
    (remove-empty (split filename "\\"))))


(definition inline (parse-file file)
  (if (string? file)
      file
    (parse file)))


;;;
;;;; Difference
;;;


(cond-expand
  (windows
    (definition default-tolerance
      2))
  (else
    (definition default-tolerance
      1)))


(definition public (different-times? time1 time2 (tolerance: tolerance default-tolerance))
  (> (abs (- (time->seconds time1) (time->seconds time2)))
     tolerance))


(definition public (different-file-times? file1 file2)
  (different-times? (get-last-modification-time file1)
                    (get-last-modification-time file2)))


(definition public (different-file-digests? file1 file2)
  (not (equal? (digest-file (parse file1) 'SHA-1)
               (digest-file (parse file2) 'SHA-1))))


(definition public (different-file-times/digests? file1 file2)
  (if (different-file-digests? file1 file2)
      (not (equal? (digest-file (parse file1) 'SHA-1)
                   (digest-file (parse file2) 'SHA-1)))
    #f))


;;;
;;;; Moniker
;;;


(class Moniker-Class extends Class
  
  
  (method public virtual (get-protocol self)
    ))


(class Moniker metaclass Moniker-Class extends Object
  
  
  (method public virtual (compare-parse self object)
    #f)
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method public virtual (present self)
    )
  
  
  (method public virtual (present-base self)
    (->string (get-base self)))
  
  
  (method public virtual (present-name self)
    (->string (get-name self)))
  
  
  (method public virtual (present-location self)
    (format "{l detail: :human}" (get-list self)))
  
  
  ;;;
  ;;;; Interface
  ;;;


  (method public virtual (exists? self)
    )
  
  
  (method public (read-only? self)
    (not (get-writable? self)))
  
  
  (method public (read/write? self)
    (get-writable? self))
  
  
  (method public (set-read-only self)
    (set-writable? self #f))
  
  
  (method public (set-read/write self)
    (set-writable? self #t))
  
  
  (method public virtual (get-writable? self)
    )
  
  
  (method public virtual (set-writable? self flag)
    )
  
  
  (method public virtual (writable? self)
    )


  (method public virtual (get-last-modification-seconds self)
    )


  (method public virtual (get-last-modification-time self)
    )


  (method public virtual (get-file self)
    )


  (method public virtual (get-name self)
    )


  (method public virtual (get-base self)
    )
  
  
  (method public virtual (get-extension self)
    )


  (method public virtual (get-list self)
    )
  
  
  (method public virtual (get-parent self)
    )
  
  
  (method public (get-hierarchy self)
    (let (loop (moniker self) (hierarchy '()))
      (if (not moniker)
          hierarchy
        (loop (get-parent moniker) (cons moniker hierarchy)))))
  
  
  (method public virtual (get-content self . rest)
    )
  
  
  ;; I think this is only for depot monikers and should probably be removed
  (method public virtual (get-children self . rest)
    )
  
  
  (method public virtual (is-different? self moniker)
    )
  
  
  (method public (relocated-list self old-root new-root)
    (append (get-list new-root) (tail (get-list self) (length (get-list old-root)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;


  (method public virtual (load-lines self . rest)
    )


  (method public virtual (save-lines self lines . rest)
    )
  
  
  (method public virtual (load-form self)
    ))


;;;
;;;; Pathname
;;;


(cond-expand
  (windows
    (definition platform-separator
      "\\"))
  (else
    (definition platform-separator
      "/")))


(class Pathname-Class extends (:class Moniker)
  
  
  (method override (marshall-object self obj)
    (serialize-object (class-of obj)
                      (vector (get-list obj))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (path) content
      (new self path))))


(class Pathname metaclass Pathname-Class extends Moniker
  
 
  (slot path)
  (slot context initialize #f accessors generate)
  
  
  (method override (initialize self lst)
    (nextmethod self)
    (validate-components self lst)
    (set-list self lst))
  
  
  (method protected virtual (validate-components self object)
    (let ((original object))
      (define (validate object)
        (cond ((null? object))
              ((string? object))
              ((symbol? object))
              ((pair? object)
               (if (pair? (car object))
                   (error "Bad pathname component {t} of {t}" (car object) original)
                 (validate (car object))
                 (validate (cdr object))))
              (else (error "Bad pathname component {t} of {t}" object original))))
      
      (validate object)))
  
  
  (method public (parse self . rest)
    (bind-optionals ((separator "/")) rest
      (let ((output (open-output-string))
            (first? #t)
            (aliases '()))
        (define (validate-recursive symbol)
          (unless (eq? symbol :context)
            (if (memq? symbol aliases)
                (error "Recursive alias {a} in {s}" symbol self)
              (set! aliases (cons symbol aliases)))))
        
        (define (parse path)
          (cond ((null? path))
                ((eq? path :root)
                 (display "/" output))
                ((string? path)
                 (if first?
                     (set! first? #f)
                   (display separator output))
                 (display path output))
                ((symbol? path)
                 (validate-recursive path)
                 (if (pathname-alias? self path)
                     (parse (pathname-alias self path))
                   (throw (new Unknown-Alias-Exception path))))
                ((pair? path)
                 (parse (car path))
                 (parse (cdr path)))
                (else
                 (error "Bad pathname component {t}" path))))
        
        (let ((path (get-list self)))
          (if (equal? path '(:root))
              "/"
            (parse path)
            (add-suffix self output)
            (path-expand (get-output-string output)))))))
  
  
  (method public (parse-uri self)
    (cond-expand
      (windows (format "file:///{a}" (parse self)))
      (else (format "file://{a}" (parse self)))))
  
  
  (method public (platform-parse self)
    (parse self platform-separator))
  
  
  (method package virtual (meta-root? self)
    #f)
  
  
  (method protected virtual (add-suffix self output)
    )
  
  
  (method override public (present-location self)
    (format "{l detail: :human}"
            (if context
                (append (get-path context) (cdr (get-list self)))
              (get-list self))))
  
  
  (method public (relocated-pathname self old-root new-root)
    (append (get-list new-root) (tail (get-list self) (length (get-list old-root)))))


  (method public virtual (create self)
    )
  
  
  (method public virtual (delete self)
    )
  
  
  (method public virtual (duplicate self dst)
    )


  (method public (rename self dst (error?: error? #t))
    (rename-file (parse self) (parse dst)))
  
  
  (method override (compare-object self target)
    (cond ((is-not? target (class-of self))
           :incompatible)
          ((= (get-list self) (get-list target))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (compare-parse self object)
    (and (is? object Pathname)
         (filename=? (parse self) (parse object))))
  
  
  (method public (context-alias? self)
    (eq? (car path) :context))
  
  
  (method public (context-setup? self)
    (or context (neq? (car path) :context)))
  
  
  (method public (pathname-alias? self alias)
    (or (is-alias? alias)
        (and (eq? alias :context) context)))
  
  
  (method public (pathname-alias self alias)
    (if (eq? alias :context)
        (if context 
            (get-path context)
          (error "No context alias specified"))
      (find-alias-path alias)))
  
  
  (method public (expand self)
    (let ((fact (new List-Factory)))
      (define (expand object)
        (cond ((eq? object #t))
              ((eq? object :root) (put fact :root))
              ((string? object) (put fact object))
              ((symbol? object) (expand (pathname-alias self object)))
              ((pair? object)
               (expand (car object))
               (expand (cdr object)))))
      
      (expand (get-list self))
      (get-output fact)))
  
  
  (method public (expand-context self)
    (if context
        (append (get-path context) (cdr (get-list self)))
      (get-list self)))


  (method override (get-list self)
    path)


  (method public (set-list self value)
    (set! path value))

  (method override (get-name self)
    (effective-name self (get-list self)))
  
  
  (method (effective-name self lst)
    (let ((name (last lst)))
      (cond ((eq? name :root)
             "/")
            ((symbol? name)
             (effective-name self (pathname-alias self name)))
            (else
             (filename-name name)))))
  
  
  (method override (get-base self)
    (let ((name (get-name self)))
      (if (symbol? name)
          name
        (filename-base name))))
  
  
  (method override (get-extension self)
    (filename-extension (get-name self)))
  
  
  (method override (get-parent self)
    (let ((path (expand-context self)))
      (let ((effective-path (if (= (length path) 1) (expand self) path)))
        (if (or (null? effective-path) (null? (cdr effective-path)))
            #f
          (new Directory (butlast effective-path))))))
  
  
  (method public (get-brother self name)
    (new (class-of self) (append (get-list (get-parent self)) (list name))))
  
  
  (method public virtual (new-brother self name)
    )
  
  
  (method public virtual (get-directory self)
    )
  
  
  (method public (get-attributes self (error?: error? #t))
    (unimplemented 'get-attributes)
    @windows-specific
    (let ((attributes (GetFileAttributes (parse))))
      (if (= attributes -1)
          (and error? (error "Unable to get file attributes for {t}" self))
        attributes)))
  
  
  (method public (set-attributes self flags)
    (unimplemented 'set-attributes)
    @windows-specific
    (let ((ok? (SetFileAttributes (parse) flags)))
      (when (not ok?)
        (error "Unable to set file attributes for {t}" self))))
  
  
  (method override (get-writable? self)
    #t ;; super quicky
    @windows-specific
    (not (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_READONLY)))
  
  
  (method override (set-writable? self flag)
    (unimplemented 'set-writable?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_READONLY (not flag))))


  (method override (exists? self)
    (file-exists? (parse self)))


  (method package (is-directory? self)
    (and (exists? self)
         (eq? (pathname-type (parse self))
              'directory)))
  
  
  (method public virtual (create-directories self)
    )
  
  
  (method public (subpath self target)
    (let (iterate (path (expand self))
                  (target-path (expand target)))
      (cond ((null? path)
             target-path)
            ((null? target-path)
             #f)
            ((filename=? (car path) (car target-path))
             (iterate (cdr path) (cdr target-path)))
            (else
             #f))))
  
  
  (method public (subpath? self target)
    (boolean (subpath self target)))


  ;;;
  ;;;; Anchoring
  ;;;
  
  
  (method public (anchor-to self anchor (error?: error? #t))
    (let* ((base-list (get-list anchor))
           (base-expd (expand anchor))
           (base-length (length base-expd))
           (expd (expand self))
           (rank (mismatch base-expd expd test: filename=?))
           (result-list (unspecified)))
      (continuation-capture
        (lambda (return)
          (cond ((not rank)
                 (set! result-list base-list))
                ((< rank base-length)
                 (if error?
                     (error "Unable to anchor pathname {t}, it is not a descendant of {t}" self anchor)
                   (continuation-return return #f)))
                (else
                 (set! result-list (append base-list (subseq expd base-length (length expd))))))
          (new (class-of self) result-list)))))
  
  
  (method public (anchorize self (anchors: anchors #f) (ignored-anchors: ignored-anchors #f))
    (define (determine-anchors)
      (if (not anchors)
          (get-descendant-anchors (get-root-alias))
        (apply append (map get-anchors (map find-alias anchors)))))
    
    (let* ((anchors (difference (determine-anchors) (or ignored-anchors '())))
           (anchored (collect (lambda (anchor) (and (valid-alias? anchor) (anchor-to self (new Directory (list anchor)) error?: #f))) anchors))
           (sorted (sort < anchored key: (lambda (path) (length (get-list path))))))
      (if (null? sorted)
          self
        (car sorted))))

  
  ;;;
  ;;;; Context
  ;;;


  (method override (setup-context self toplevel-context)
    (when (context-alias? self)
      (let ((data (get-data toplevel-context)))
        (when data
          (set! context (get-context data)))))))


(definition public inline (pathname? object)
  (is? object Pathname))


(definition public inline (pathname=? x <Moniker> y <Moniker>)
  (compare-parse x y))


(definition public inline (pathname-exists? pathname <Pathname>)
  (file-exists? (parse pathname)))


(definition public inline (pathname-delete pathname <Pathname>)
  (delete-file (parse pathname)))


(definition public inline (pathname-last-modification-seconds pathname <Pathname>)
  (file-last-modification-seconds (parse pathname)))


(definition public (pathname-hash pathname <Pathname>)
  (filename=?-hash (parse pathname)))


;;;
;;;; File
;;;


(class File-Class extends (:class Pathname)
  
  
  (method override (get-protocol self)
    'file))


(class File metaclass File-Class extends Pathname
  
  
  (method override (print self output readably)
    ;; gambit30
    (if (unspecified? (get-list self))
        (format output "~{File}")
      (format output "~{File {l detail: :v}}"
              (get-list self)
              readably)))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother self name)
    (new-file (get-parent self) name))
  
  
  (method override (present self)
    (format "{l}" (get-list self)))
  
  
  ;;;
  ;;;; Operations
  ;;;


  (method override (get-file self)
    self)
  
  
  (method override (get-directory self)
    (get-parent self))


  (method override (create self)
    (unless (exists? self)
      (create-directories self)
      ;; is there any smarter way to do this in gambit?
      (call-with-output-file (path-settings self)
        (lambda (output)
          ))))
  
  
  (method override (create-directories self)
    (create-directories (get-parent self)))
  
  
  (method public (copy-times self dst)
    (let ((src (parse self))
          (dst (parse dst)))
      (file-last-access-and-modification-times-set! dst (file-last-access-time src) (file-last-modification-time src))))


  (method override (duplicate self dst (overwrite?: overwrite? #t) (overwrite-read-only?: overwrite-read-only? #f) (preserve-times?: preserve-times? #f) (feedback: feedback #f))
    (when feedback
      (feedback self))
    (overwrite-read-only dst overwrite-read-only?)
    (when (and overwrite? (exists? dst))
      (delete dst))
    (copy-file (parse self) (parse dst))
    (when preserve-times?
      (copy-times self dst)))
  
  
  (method public (install-file self dst (feedback: feedback #f))
    (if (exists? dst)
        (when (different-file-times? self dst)
          (cond ((different-file-digests? self dst)
                 (when feedback
                   (feedback 'replacing self))
                 (duplicate self dst preserve-times?: #t))
                (else
                 (when feedback
                   (feedback 'touching self))
                 (copy-times self dst))))
      (when feedback
        (feedback 'copying self))
      (create-directories dst)
      (duplicate self dst preserve-times?: #t)))
  
  
  (method override (delete self (overwrite-read-only?: overwrite-read-only? #f) (error?: error? #t))
    (if (not (exists? self))
        (and error? (error "Unable to delete inexistant file: {s}" self))
      (overwrite-read-only self overwrite-read-only?)
      (delete-file (parse self))))
  
  
  (method package (overwrite-read-only self overwrite-read-only?)
    @windows-specific
    (when (and overwrite-read-only? (exists?) (read-only?))
      (set-read/write)))
  
  
  (method public (get-size self)
    (unimplemented 'get-size)
    @windows-specific
    (with ((input (new File-Reader self readable?: #f)))
      (get-size input)))


  (method override (get-last-modification-seconds self)
    (file-last-modification-seconds (parse self)))


  (method override (get-last-modification-time self)
    (seconds->time (file-last-modification-seconds (parse self))))


  (method public (set-modification-time self time)
    (unimplemented 'set-modification-time)
    @windows-specific
    (let ((ft (get-filetime time))
          (at (get-attributes)))
      ;; this is ugly big time...
      (set-read/write)
      (call-with-output-file (path-settings self mode: 'append)
        (lambda (output)
          (SetFileTime (get-handle output) NULL NULL ft)))
      (set-attributes at)))
  
  
  (method public (touch self)
    (unimplemented 'touch)
    @windows-specific
    (set-modification-time (get-time (universal-date))))
  
  
  (method public (get-hidden? self)
    (unimplemented 'get-hidden?)
    @windows-specific
    (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_HIDDEN))
  
  
  (method public (set-hidden? self flag)
    (unimplemented 'set-hidden?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_HIDDEN flag)))
  
  
  (method public (symbolic-link? self)
    (pathname-link? (parse self)))
  
  
  (method override (writable? self)
    (and (exists? self)
         (catch-exception-filter
           os-exception?
           (lambda (exception) #f)
           (lambda ()
             (call-with-output-file (path-settings self append: #t)
               (lambda (port)
                 #t))))))
  
  
  (method public (clone-file self extension)
    (new File (append (get-list (get-directory self)) (list (format "{a}.{a}" (get-base self) extension)))))
  
  
  ;;;
  ;;;; Lines
  ;;;


  (method override (load-lines self (char-encoding: char-encoding #f) (char-encoding-errors: char-encoding-errors #t))
    (call-with-input-file (path-settings self char-encoding: (or char-encoding 'UTF) char-encoding-errors: char-encoding-errors eol-encoding: 'cr-lf)
      read-lines))


  (method override (save-lines self lines (char-encoding: char-encoding #f) (eol-encoding: eol-encoding #f))
    (call-with-output-file (path-settings self char-encoding: (or char-encoding 'UTF-8) eol-encoding: eol-encoding)
      (lambda (output)
        (write-lines output lines))))
  
  
  ;;;
  ;;;; Binary
  ;;;


  (method package (load-binary self)
    (call-with-input-file (path-settings self)
      (lambda (port)
        (let ((fileSize <fx> (input-port-byte-position port 0 2)))
          (input-port-byte-position port 0)
          (let ((content (make-u8vector fileSize)))
            (read-subu8vector content 0 fileSize port)
            content)))))


  (method package (save-binary self content)
    (call-with-output-file (path-settings self)
      (lambda (port)
        (write-subu8vector content 0 (u8vector-length content) port)))))


(definition public inline (file? object)
  (is? object File))


(definition timestamped-mutex
  (make-mutex))


(definition public (timestamped-directory dir prefix)
  (mutex-lock! timestamped-mutex)
  ;; if dir doesn't exists or is read-only we should provide a secondary dir that is always writable
  (prog1 (let ((prefix (if prefix (format "{a}_" prefix) ""))
               (timestamp (date->string (system-date) "~Y-~m-~d_~H-~M-~S")))
           (let (iterate (n 0))
             (let ((suffix (if (= n 0) "" (format "_{a}" n))))
               (let ((directory (new-directory dir (format "{a}{a}" prefix timestamp))))
                 (if (exists? directory)
                     (iterate (+ n 1))
                   directory)))))
    (mutex-unlock! timestamped-mutex)))


(definition public (timestamped-file dir prefix ext)
  (mutex-lock! timestamped-mutex)
  ;; if dir doesn't exists or is read-only we should provide a secondary dir that is always writable
  (prog1 (let ((prefix (if prefix (format "{a}_" prefix) ""))
               (timestamp (date->string (system-date) "~Y-~m-~d_~H-~M-~S")))
           (let (iterate (n 0))
             (let ((suffix (if (= n 0) "" (format "_{a}" n))))
               (let ((file (new-file dir (add-extension (format "{a}{a}{a}" prefix timestamp suffix) ext))))
                 (if (exists? file)
                     (iterate (+ n 1))
                   file)))))
    (mutex-unlock! timestamped-mutex)))


(definition public (ensure-read/write moniker (cancel-action: cancel-action 'throw))
  @convert
  (let ((file (get-file moniker)))
    (if (or (not (exists? file)) (read/write? file))
        'no-action
      (let ((code (case (message-box (format "File {s} is read-only. Overwrite?" (get-name moniker))
                                     title: "File Status"
                                     type: 'question
                                     process-keys?: #f)
                    ((yes) 'set-read/write)
                    ((no) 'cancel))))
        (case code
          ((set-read/write)
           (set-read/write file)
           'read/write)
          ((cancel)
           (signal-cancel)))))))


(definition public (backup-file file)
  (new-unique-file (get-parent file) (format "{a}.back.{a}" (get-base file) (get-extension file)) separator: #f))


(definition public (fail-safe-save file proc)
  (unimplemented 'fail-safe-save)
  @unwind-protect
  (let ((temp (clone-file file "tmp"))
        (back (backup-file file))
        (completed? #f))
    (unwind-protect
        (begin
          (proc temp)
          (set! completed? #t))
      (cond ((not completed?)
             (delete temp error?: #f))
            ((exists? file)
             (rename file back)
             (rename temp file)
             (delete back))
            (else
             (rename temp file))))))


;;;
;;;; Directory
;;;


(class Directory-Class extends (:class Pathname)
  
  
  (method override (get-protocol self)
    'dir))


(class Directory metaclass Directory-Class extends Pathname
  
  
  (method override (print self output readably)
    ;; gambit30
    (if (unspecified? (get-list self))
        (format output "~{Directory}")
      (format output "~{Directory {l detail: :v}}"
              (get-list self)
              readably)))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother self name)
    (new-directory (get-parent self) name))
  
  
  (method override (present self)
    (format "{l}" (get-list self)))
  
  
  ;;;
  ;;;; Operations
  ;;;
  
  
  (method override (get-directory self)
    self)


  (method override (get-last-modification-time self)
    #f)
  
  
  ;; ... give us this day our windows drives ...
  (cond-expand
    (windows
      (method override (get-parent self)
        (let ((effective-path (if (= (length path) 1) (expand self) path)))
          (if (= 1 (length effective-path))
              (new Windows-Meta-Root)
            (nextmethod self)))))
    (else))
  
  
  (method override (create self)
    (create-directory (parse self)))
  
  
  (method override (create-directories self)
    (unless (exists? self)
      (let ((parent (get-parent self)))
        (when parent
          (create-directories parent)))
      (create self)))
  
  
  (method public (new-file self name) <File>
    (add-context self (new File (append (get-list self) (if (null/pair? name) name (list name))))))
  
  
  (method public (new-directory self name) <Directory>
    (add-context self (new Directory (append (get-list self) (if (null/pair? name) name (list name))))))
  
  
  (method public (new-unique-file self name (separator: separator "_"))
    (let ((file (new-file self name)))
      (if (not (exists? file))
          file
        (let ((base (filename-base name))
              (ext (filename-extension name))
              (suffix 1))
          (while (exists? file)
            (set! file (new-file self (format "{a}{a}{a width: 2 justify: :right padding: #\\0}.{a}" base (or separator "") suffix ext)))
            (increase! suffix))
          file))))
  
  
  (method (add-context self pathname)
    (when context
      (set-context pathname context))
    pathname)


  (method override (duplicate self dst (overwrite?: overwrite? #t) (overwrite-read-only?: overwrite-read-only? #f) (copier: copier #f) (copy?: copy? #t) (preserve-times?: preserve-times? #f) (feedback: feedback #f))
    (when feedback
      (feedback self))
    (when (and overwrite? (exists? dst))
      (delete dst overwrite-read-only?: overwrite-read-only?))
    (create-directories dst)
    (let ((destination
            (lambda (path)
              (append (get-list dst) (list (get-name path))))))
      (iterate-directory self
        (lambda (path)
          (when (or (eq? copy? #t) (copy? path))
            (if (is? path File)
                (let ((dest (new File (destination path))))
                  (if copier
                      (copier path dest)
                    (duplicate path dest preserve-times?: preserve-times? feedback: feedback)))
              (duplicate path (new Directory (destination path)) feedback: feedback copy?: copy?))))
        files?: #t
        directories?: #t
        recursive?: #f)))
  
  
  (method public (install-directory self dst (filter: filter #f) (feedback: feedback #f) (force-feedback?: force-feedback? #f) (progress-feedback: progress-feedback #f))
    (define (merge-into src-dir dst-dir feedback)
      (merge-ordered (lambda (what key left right)
                       (case what
                         ((:left)
                          (when (or (not filter) (filter 'copy left))
                            (typecase left
                              ((File)
                               (when feedback
                                 (feedback 'copying left))
                               (duplicate left (new-file dst-dir (get-name left)) preserve-times?: #t))
                              ((Directory)
                               (when feedback
                                 (feedback 'copying left))
                               (let ((right (new-directory dst-dir (get-name left))))
                                 (create right)
                                 (merge-into left right (if force-feedback? feedback #f)))))))
                         ((:right)
                          (when (or (not filter) (filter 'delete right))
                            (typecase right
                              ((File)
                               (when feedback
                                 (feedback 'deleting right))
                               (delete right))
                              ((Directory)
                               (when feedback
                                 (feedback 'deleting right))
                               (delete right)))))
                         ((:same)
                          (when (or (not filter) (filter 'replace left))
                            (typecase left
                              ((File)
                               (typecase right
                                 ((File)
                                  (if (not (different-file-times? left right))
                                      (when (and force-feedback? feedback)
                                        (feedback 'skippin left))
                                    (cond ((different-file-digests? left right)
                                           (when feedback
                                             (feedback 'replacing left))
                                           (duplicate left right preserve-times?: #t))
                                          (else
                                           (when feedback
                                             (feedback 'touching left))
                                           (copy-times left right)))))
                                 ((Directory)
                                  (when feedback
                                    (feedback 'replacing left))
                                  (delete right)
                                  (duplicate left (new-file dst-dir (get-name left)) preserve-times?: #t))))
                              ((Directory)
                               (typecase right
                                 ((File)
                                  (when feedback
                                    (feedback 'replacing left))
                                  (delete right)
                                  (let ((right (new-directory dst-dir (get-name left))))
                                    (create right)
                                    (merge-into left right (if force-feedback? feedback #f))))
                                 ((Directory)
                                  (when (and force-feedback? feedback)
                                    (feedback 'entering left))
                                  (when progress-feedback
                                    (progress-feedback 'entering left))
                                  (merge-into left right feedback)))))))))
                     (sort filename-test (get-content src-dir) key: get-name)
                     (sort filename-test (get-content dst-dir) key: get-name)
                     left-key: get-name
                     right-key: get-name
                     compare: filename-compare))
    
    (if (exists? dst)
        (merge-into self dst feedback)
      (when feedback
        (feedback 'copying self))
      (create-directories dst)
      (merge-into self dst (if force-feedback? feedback #f))))
  
  
  (method override (delete self (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback #f))
    (empty self overwrite-read-only?: overwrite-read-only? feedback: feedback)
    (delete-empty self))
  
  
  (method public (empty self (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback #f))
    (iterate-directory self
      (lambda (path)
        (if (is? path File)
            (delete path overwrite-read-only?: overwrite-read-only?)
          (delete path overwrite-read-only?: overwrite-read-only? feedback: feedback)))
      files?: #t
      directories?: #t
      recursive?: #f))
  
  
  (method public (delete-empty self)
    (delete-directory (parse self)))
  
  
  (method override (get-content self (nodes?: nodes? #t) (leaves?: leaves? #t))
    (define (collect-nodes fact)
      (iterate-directory self
        (lambda (item)
          (put fact item))
        files?: #f
        directories?: #t
        recursive?: #f))
    
    (define (collect-leaves fact)
      (iterate-directory self
        (lambda (item)
          (put fact item))
        files?: #t
        directories?: #f
        recursive?: #f))
    
    (let ((fact (new List-Factory)))
      (when nodes? (collect-nodes fact))
      (when leaves? (collect-leaves fact))
      (get-output fact)))
     
   
  ;;;
  ;;;; Parse
  ;;;
  
  
  (method override (add-suffix self output)
    (write-char #\/ output))
     
   
  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (collect-files self predicate)
    (let ((fact (new List-Factory)))
      (iterate-directory self
        (lambda (file)
          (when (predicate file)
            (put fact file)))
        recursive?: #f)
      (get-output fact)))
     
   
  ;;;
  ;;;; Directories
  ;;;
  
  
  (method public (collect-directories self)
    (let ((fact (new List-Factory)))
      (iterate-directory self
        (lambda (dir)
          (put fact dir))
        files?: #f
        directories?: #t
        recursive?: #f)
      (get-output fact)))
  
  
  (method public (count-directories self)
    (let ((count 0))
      (iterate-directory self
        (lambda (dir)
          (increase! count))
        full?: #t
        files?: #f
        directories?: #t
        recursive?: #f)
      count))
  
  
  ;;;
  ;;;; Iterator
  ;;;
  
  
  (method public virtual (iterate-directory self proc (full?: full? #t) (files?: files? #t) (directories?: directories? #f) (sort?: sort? #t) (sort-type?: sort-type? #t) (sort-test: sort-test #f) (recursive?: recursive? #t) (ignored-toplevel-dirnames: ignored-toplevel-dirnames #f) (ignored-toplevel-filenames: ignored-toplevel-filenames #f) (ignored-dirnames: ignored-dirnames #f))
    (declare (proper-tail-calls))
    (let ()
      (define (iterate-directory-content files? directories? sort? recursive? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames prefix base proc)
        (if (not sort-type?)
            (iterate-content base #f sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
              (lambda (name type)
                (case type
                  ((file)
                   (when files?
                     (proc (concatenate prefix (list name)) 'file)))
                  ((directory)
                   (when recursive?
                     (iterate-directory-content files? directories? sort? recursive? #f #f ignored-dirnames (append prefix (list name)) (concatenate base "/" name) proc))
                   (when directories?
                     (proc (append prefix (list name)) 'directory))))))
          (iterate-content base 'directories sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
            (lambda (name type)
              (when recursive?
                (iterate-directory-content files? directories? sort? recursive? #f #f ignored-dirnames (append prefix (list name)) (concatenate base "/" name) proc))
              (when directories?
                (proc (append prefix (list name)) 'directory))))
          (iterate-content base 'files sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
            (lambda (name type)
              (when files?
                (proc (concatenate prefix (list name)) 'file))))))
      
      (define (iterate-content base kind sort? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
        (if (not sort?)
            (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
          (let ((list '()))
            (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames
              (lambda (object type)
                (set! list (cons (cons object type) list))))
            (let ((sorted (sort (or sort-test ci<?) list key: car)))
              (for-each (lambda (pair)
                          (proc (car pair) (cdr pair)))
                        sorted)))))
      
      (define (iterate-content-unsorted base kind ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames proc)
        (define (ignored-name? name names)
          (and names (member? name names)))
        
        (for-each (lambda (name)
                    (let ((path (string-append base "/" name)))
                      ;; this extra test fixes problems on Windows with system files like C:/pagefile.sys
                      (when (file-exists? path)
                        (let ((type (pathname-type path)))
                          (when (or (and (or (not kind) (eq? kind 'files)) (eq? type 'file) (not (ignored-name? name ignored-toplevel-filenames)))
                                    (and (or (not kind) (eq? kind 'directories)) (eq? type 'directory) (not (ignored-name? name ignored-toplevel-dirnames)) (not (ignored-name? name ignored-dirnames))))
                            (proc name type))))))
                  (directory-content-patch base)))
      
      (let ((directory (if full? (get-list self) #f)))
        (iterate-directory-content files? directories? sort? recursive? ignored-toplevel-dirnames ignored-toplevel-filenames ignored-dirnames '() (parse self)
          (lambda (lst type)
            (case type
              ((file) (if full? (proc (new-file self lst)) (proc lst 'file)))
              ((directory) (if full? (proc (new-directory self lst)) (proc lst 'directory)))))))))
  
  
  ;; quicky because showing .* files in the open dialog creates problems
  ;; on windows with the pagefile.sys file when getting its attributes...
  (cond-expand
    (windows
      (definition (directory-content-patch path)
        (directory-content path)))
    (else
      (definition (directory-content-patch path)
        (directory-content (list path: path ignore-hidden: 'dot-and-dot-dot)))))
  
  
  (method public (count-files self (ignored-dirnames: ignored-dirnames #f) (filter: filter #f) (max-count: max-count #f))
    (let ((count 0))
      (continuation-capture
        (lambda (return)
          (iterate-directory self
            (lambda (file)
              (when (or (not filter) (filter file))
                (increase! count)
                (when (and max-count (> count max-count))
                  (continuation-return return #f))))
            ignored-dirnames: ignored-dirnames)
          count)))))


;; class providing the ugly thing known as windows drives
(cond-expand
  (windows
    (class undocumented Windows-Meta-Root extends Pathname
      
      
      (method override (initialize self)
        (set-list self '(:root)))

      
      (method override (get-name self)
        "This Computer")
      
      
      (method override (present self)
        (get-name self))
      
      
      (method override (get-parent self)
        #f)
      
      
      (method override (get-directory self)
        (new Directory (list "C:")))
  
  
      (method override (meta-root? self)
        #t)
      
      
      (method override (exists? self)
        #t)
      
      
      (method override (get-content self (nodes?: nodes? #t) (leaves?: leaves? #t))
        (define (enumerate-drives)
          (reverse!
            (let (loop (drives (jazz.platform:GetLogicalDrives))
                       (letter (char->integer #\A))
                       (result '()))
              (if (= drives 0)
                  result
                (loop (arithmetic-shift drives -1) (+ letter 1)
                  (if (/= 0 (bitwise-and drives 1))
                      (cons (integer->char letter) result)
                    result))))))
        
        (let ((fact (new List-Factory)))
          (when nodes?
            (for-each (lambda (letter)
                        (put fact (new Directory (list (string letter #\:)))))
                      (enumerate-drives)))
          (get-output fact)))))

  (else))


(definition public inline (directory? obj)
  (is? obj Directory))


;; quick solution
(definition public (digest-directory dir algorithm)
  (let ((output (open-output-string)))
    (iterate-directory dir
      (lambda (path)
        (typecase path
          ((File)
           (display (digest-file (parse path) algorithm) output))
          ((Directory)
           (display (get-name path) output))))
      files?: #t
      directories?: #t
      recursive?: #t)
    (digest-string (get-output-string output) algorithm)))


(definition public (current-directory-get)
  (new Directory (tokenise-filename (current-directory))))


(definition public (current-directory-set! directory)
  (current-directory (parse directory)))


(definition public (with-preserved-current-directory proc)
  (let ((preserved (current-directory-get)))
    (unwind-protect
        (proc)
      (current-directory-set! preserved))))


(definition public (normalize-directory dirname)
  (if (ends-with? dirname "/")
      dirname
    (string-append dirname "/")))


;;;
;;;; Contents
;;;


(definition public (different-file-contents? file1 file2)
  (define (different-text-file-content? file1 file2)
    (not (equal? (load-lines file1 char-encoding-errors: #f)
                 (load-lines file2 char-encoding-errors: #f))))
  
  (declare (proper-tail-calls))
  (if (and (member? (get-extension file1) Text-Extensions test: extension=?)
           (member? (get-extension file2) Text-Extensions test: extension=?))
      (different-text-file-content? file1 file2)
    (call-with-input-file (path-settings file1 eol-encoding: 'cr-lf)
      (lambda (input1)
        (call-with-input-file (path-settings file2 eol-encoding: 'cr-lf)
          (lambda (input2)
            (or @convert
                (/= (get-size input1)
                    (get-size input2))
                (let (iterate)
                  (let ((u1 (read-u8 input1))
                        (u2 (read-u8 input2)))
                    (cond ((and (eof-object? u1)
                                (eof-object? u2))
                           #f)
                          ((eqv? u1 u2)
                           (iterate))
                          (else
                           #t)))))))))))


(definition public (different-file-contents-no-whitespace? file1 file2)
  (call-with-input-file (path-settings file1 char-encoding: 'UTF char-encoding-errors: #f eol-encoding: 'cr-lf)
    (lambda (input1)
      (call-with-input-file (path-settings file2 char-encoding: 'UTF char-encoding-errors: #f eol-encoding: 'cr-lf)
        (lambda (input2)
          (not (wi=? (read-content-string input1)
                     (read-content-string input2))))))))


;;;
;;;; Extension
;;;


(definition public Scheme-Extensions
  '("scm" "sch" "ss" "gambcini" "buildini" "jazzini" "jamini"))

(definition public Clojure-Extensions
  '("clj"))

(definition public CommonLisp-Extensions
  '("lisp"
    "el" ;; quick approximation until a dedicated emacs lisp class
    ))

(definition public Jazz-Extensions
  '("jazz" "jml" "dgs" "mnf" "otl" "repository" "package" "configuration" "settings" "project" "dependencies"))

(definition public Jazz-All-Extensions
  '("jazz" "jcat" "jlog" "jml" "dgs" "mnf" "otl" "repository" "package" "configuration" "settings" "snapshot" "project"))

(definition public Lisp-Extensions
  (append Scheme-Extensions
          Clojure-Extensions
          CommonLisp-Extensions
          Jazz-Extensions))

(definition public C-Extensions
  '("c" "cpp" "h" "hpp" "m"))

(definition public Java-Extensions
  '("java"))

(definition public SQL-Extensions
  '("sql"))

(definition public Text-Extensions
  '(#f "build" "conf" "css" "dart" "erl" "ftx" "htm" "java" "js" "log" "lua" "prop" "properties" "py" "rc" "sh" "sql" "template" "txt"))

(definition public Textual-Extensions
  (append Lisp-Extensions
          C-Extensions
          Text-Extensions))

(definition public Binary-Extensions
  '("obj" "o" "o1" "o2" "o3" "o4" "o5" "o6" "o7" "o8" "o9" "a" "dll" "exe" "pack"))


(definition public (effective-extensions obj)
  (cond ((string? obj)
         (list obj))
        ((pair? obj)
         (apply union test: extension=? (map effective-extensions obj)))
        (else
         (case obj
           ((:scheme) Scheme-Extensions)
           ((:clojure) Clojure-Extensions)
           ((:commonlisp) CommonLisp-Extensions)
           ((:jazz) Jazz-Extensions)
           ((:lisp) Lisp-Extensions)
           ((:c) C-Extensions)
           ((:java) Java-Extensions)
           ((:text) Text-Extensions)
           ((:textual) Textual-Extensions)
           (else obj)))))


(definition Scheme-Include-Extensions
  Scheme-Extensions)

(definition Clojure-Include-Extensions
  Clojure-Extensions)

(definition CommonLisp-Include-Extensions
  CommonLisp-Extensions)

(definition Jazz-Include-Extensions
  '("jazz" "jml" "otl"))

(definition Lisp-Include-Extensions
  (append Scheme-Include-Extensions
          Clojure-Include-Extensions
          CommonLisp-Include-Extensions
          Jazz-Include-Extensions))

(definition C-Include-Extensions
  C-Extensions)

(definition Java-Include-Extensions
  Java-Extensions)

(definition Text-Include-Extensions
  Text-Extensions)

(definition Textual-Include-Extensions
  (append Lisp-Include-Extensions
          C-Include-Extensions
          Text-Include-Extensions))


(definition package (effective-include-extensions extensions)
  (if (not extensions)
      Textual-Include-Extensions
    (case extensions
      ((:scheme) Scheme-Include-Extensions)
      ((:clojure) Clojure-Include-Extensions)
      ((:commonlisp) CommonLisp-Include-Extensions)
      ((:jazz) Jazz-Include-Extensions)
      ((:lisp) Lisp-Include-Extensions)
      ((:c) C-Include-Extensions)
      ((:java) Java-Include-Extensions)
      ((:text) Text-Include-Extensions)
      ((:textual) Textual-Include-Extensions)
      (else extensions))))


(definition Scheme-Catalog-Extensions
  Scheme-Extensions)

(definition Clojure-Catalog-Extensions
  Clojure-Extensions)

(definition CommonLisp-Catalog-Extensions
  CommonLisp-Extensions)

(definition Jazz-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          '("jazz" "otl")))

(definition C-Catalog-Extensions
  C-Extensions)

(definition Java-Catalog-Extensions
  Java-Extensions)

(definition Text-Catalog-Extensions
  Text-Extensions)

(definition Textual-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          Clojure-Catalog-Extensions
          CommonLisp-Catalog-Extensions
          Jazz-Catalog-Extensions
          C-Catalog-Extensions
          Text-Catalog-Extensions))


(definition package (effective-catalog-extensions extensions)
  (if (not extensions)
      Textual-Catalog-Extensions
    (case extensions
      ((:scheme) Scheme-Catalog-Extensions)
      ((:clojure) Clojure-Catalog-Extensions)
      ((:commonlisp) CommonLisp-Catalog-Extensions)
      ((:jazz) Jazz-Catalog-Extensions)
      ((:c) C-Catalog-Extensions)
      ((:java) Java-Catalog-Extensions)
      ((:text) Text-Catalog-Extensions)
      ((:textual) Textual-Catalog-Extensions)
      (else extensions))))


(definition public (extension-constituent-test ext)
  (cond ((member? ext Jazz-Extensions test: extension=?) jazz-constituent?)
        ((member? ext Scheme-Extensions test: extension=?) scheme-constituent?)
        ((member? ext C-Extensions test: extension=?) c-constituent?)
        ((member? ext SQL-Extensions test: extension=?) sql-constituent?)
        (else word-constituent?))))
