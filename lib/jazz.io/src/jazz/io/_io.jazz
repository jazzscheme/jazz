;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; IO
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.io jazz


(import (jazz.system.access)
        (time))


;;;
;;;; End of line
;;;


(cond-expand
  (windows
   (definition *eol-encoding*
     'cr-lf))
  (else
   (definition *eol-encoding*
     'lf)))


(definition public (get-eol-encoding)
  *eol-encoding*)


(definition public (set-eol-encoding encoding)
  (set! *eol-encoding* encoding))


;;;
;;;; Aliases
;;;


(definition *aliases*
  (make-table test: eq?))


(definition public (get-aliases)
  *aliases*)


(definition public (is-alias? name)
  (boolean (find-alias name)))


(definition public (valid-alias? name)
  (is-alias? name))


(definition public (get-alias name (error?: error? #t))
  (either (find-alias name)
          (when error?
            (error "Unknown alias: {t}" name))))


(definition public (find-alias name)
  (either (table-ref (get-aliases) name #f)
          (let ((process (get-process)))
            (when process
              (resolve-alias~ process name)))))


(definition public (register-alias name path)
  (define (expand-up path)
    (let ((dir (anchorize~ (get-parent~ (new Directory (list (car path)))) ignored-anchors: (list name)))
          (sub (cddr path)))
      (append (get-list~ dir) sub)))
  
  (define (process-up path)
    (if (and (pair? path)
             (>= (length path) 2)
             (eq? (second path) :up))
        (process-up (expand-up path))
      path))
  
  (let ((actual (table-ref (get-aliases) name {}))
        (new (process-up path)))
    (if (or (not actual) (equal? new actual))
        (set-alias name new)
      (error "Alias already registered: {s}" name))))


(definition public (unregister-alias name)
  (table-clear (get-aliases) name))


(definition public (set-alias name path)
  (table-set! (get-aliases) name path))


(definition public (initialize-aliases)
  (initialize-platform-aliases)
  (register-alias 'Home (tokenise-filename (pathname-normalize "~")))
  (register-repositories-aliases))


(cond-expand
  (windows
    (definition (initialize-platform-aliases)
      (register-alias 'Network "\\")))
  (else
    (definition (initialize-platform-aliases)
      )))


(definition (register-repositories-aliases)
  (define (register-repository repository)
    (let ((name (repository-name repository))
          (directory (remove-trailing-char (repository-directory repository) #\/)))
      (register-alias name (tokenise-filename directory))
      (unless (repository-binary? repository)
        (for-each (lambda (package)
                    (let ((package-name (package-name package))
                          (package-root (package-root package)))
                      (register-alias package-name
                                      `(,name ,@(tokenise-filename package-root)))))
                  (repository-packages repository)))))
  
  (for-each register-repository (get-repositories)))


(definition (validate-alias name path)
  (if (exists?~ (new Directory path))
      path
    (error "Unable to set alias {t} to inexistant directory: {t}" name path)))


;;;
;;;; Path
;;;


(definition public (extract-name filename <string>) <string>
  (let ((pos (find filename #\/ reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename (+ pos 1) (cardinality filename)))))


(definition public (extract-base filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (if (not pos)
        filename
      (subseq filename 0 pos))))


(definition public (extract-extension filename <string>)
  (let ((pos (find filename #\period reversed?: #t)))
    (when pos
      (subseq filename (+ pos 1) (cardinality filename)))))


(cond-expand
  (windows
   (definition (normalize-filename-separators filename <string>)
     (substitute #\\ #\/ filename)))
  (else
   (definition (normalize-filename-separators filename <string>)
     filename)))


(definition public (tokenise-filename filename <string>)
  (let ((lst (split (normalize-filename-separators filename) "/")))
    (if (empty-string? (car lst))
        (cons :root (remove-empty-strings (cdr lst)))
      (remove-empty-strings lst))))


(definition public (tokenise-windows filename <string>)
  (if (starts-with? filename "\\\\")
      (cons 'Network (remove-empty-strings (split (subseq filename 2 (cardinality filename)) "\\")))
    (remove-empty-strings (split filename "\\"))))


(definition public (make-filename base extension)
  (format "{a}.{a}" base extension))


(definition public (get-tmp-directory)
  (unimplemented 'get-tmp-directory)
  @windows-specific
  (let* ((size (GetTempPath 0 NULL))
         (path (make-string size)))
    (GetTempPath size path)
    (new Directory (tokenise-windows path))))


;;;
;;;; Protocol
;;;


(definition public (get-protocol-handler protocol)
  (let ((protocol (if (keyword? protocol) (keyword->symbol protocol) protocol)))
    (case protocol
      ((file) File)
      ((dir) Directory)
      (else (signal (new Parse-Error message: (format "Unknown protocol: {t}" protocol)))))))


;;;
;;;; Moniker
;;;


(class Moniker-Class extends Class
  
  
  (method public virtual (get-protocol)
    ))


(class Moniker metaclass Moniker-Class extends Object
  
  
  (method public virtual (compare-pathname object)
    #f)
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method public virtual (present)
    )
  
  
  (method public virtual (present-base)
    (->string (get-base)))
  
  
  (method public virtual (present-name)
    (->string (get-name)))
  
  
  (method public virtual (present-location)
    (format "{l detail: :human}" (get-list)))
  
  
  ;;;
  ;;;; Interface
  ;;;


  (method public virtual (exists?)
    )
  
  
  (method public (read-only?)
    (not (get-writable?)))
  
  
  (method public (read/write?)
    (get-writable?))
  
  
  (method public (set-read-only)
    (set-writable? #f))
  
  
  (method public (set-read/write)
    (set-writable? #t))
  
  
  (method public virtual (get-writable?)
    )
  
  
  (method public virtual (set-writable? flag)
    )
  
  
  (method public virtual (writable?)
    )


  (method public virtual (get-modification-time)
    )


  (method public virtual (get-file)
    )


  (method public virtual (get-name)
    )


  (method public virtual (get-base)
    )
  
  
  (method public virtual (get-extension)
    )


  (method public virtual (get-list)
    )
  
  
  (method public virtual (get-parent)
    )
  
  
  (method public (get-hierarchy)
    (let (loop (moniker self) (hierarchy '()))
      (if (not moniker)
          hierarchy
        (loop (get-parent~ moniker) (cons moniker hierarchy)))))
  
  
  (method public virtual (get-content . rest)
    )
  
  
  ;; I think this is only for depot monikers and should probably be removed
  (method public virtual (get-children . rest)
    )
  
  
  (method public virtual (is-different? moniker)
    )
  
  
  (method public (relocated-list old-root new-root)
    (append (get-list~ new-root) (tail (get-list) (length (get-list~ old-root)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;


  (method public virtual (load-lines . rest)
    )


  (method public virtual (save-lines lines . rest)
    )
  
  
  (method public virtual (load-form)
    ))


;;;
;;;; Pathname
;;;


(cond-expand
  (windows
    (definition platform-separator
      "\\"))
  (else
    (definition platform-separator
      "/")))


(class Pathname-Class extends (:class Moniker))


(class Pathname metaclass Pathname-Class extends Moniker
  
  
  (slot path)
  
  
  (method override (initialize lst)
    (nextmethod)
    (validate-component lst)
    (set-list lst))
  
  
  (definition (validate-component object)
    (let ((original object))
      (letrec ((validate
                 (lambda (object)
                   (cond ((null? object))
                         ((string? object))
                         ((symbol? object))
                         ((pair? object)
                          (if (pair? (car object))
                              (error "Bad pathname component {t} of {t}" (car object) original)
                            (validate (car object))
                            (validate (cdr object))))
                         (else (error "Bad pathname component {t} of {t}" object original))))))
        (validate object))))
  
  
  (method public (parse . rest)
    (bind-optionals ((separator "/")) rest
      (let ((printer (open-output-string))
            (first? #t)
            (aliases '()))
        (letrec ((parse
                   (lambda (path)
                     (cond ((null? path))
                           ((eq? path :root)
                            (display "/" printer))
                           ((string? path)
                            (if first?
                                (set! first? #f)
                              (display separator printer))
                            (display path printer))
                           ((symbol? path)
                            (if (memq? path aliases)
                                (error "Recursive alias {a} in {s}" path self)
                              (set! aliases (cons path aliases))
                              (if (is-alias? path)
                                  (parse (get-alias path))
                                (error "Unknown alias: {s}" path))))
                           ((pair? path)
                            (parse (car path))
                            (parse (cdr path)))
                           (else
                            (error "Bad pathname component {t}" path))))))
          (parse (get-list)))
        (add-suffix printer)
        (pathname-expand (get-output-string printer)))))
  
  
  (method public (platform-parse)
    (parse platform-separator))
  
  
  (method protected virtual (add-suffix printer)
    )
  
  
  (method public (relocated-pathname old-root new-root)
    (append (get-list~ new-root) (tail (get-list) (length (get-list~ old-root)))))


  (method public virtual (create)
    )


  (method public (move-pathname dst (error?: error? #t))
    (file-rename (parse) (parse~ dst)))
  

  (method override (compare-object target)
    (cond ((is-not? target (class-of self))
           :incompatible)
          ((= (get-list) (get-list~ target))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (compare-pathname object)
    (and (is? object Pathname)
         (ci=? (parse) (parse~ object))))
  
  
  (method public (valid-aliases?)
    (letrec ((valid?
              (lambda (list)
                (or (eq? list #t)
                    (every? (lambda (item)
                              (or (not (symbol? item))
                                  (and (is-alias? item)
                                       (valid? (get-alias item)))))
                            list)))))
      (valid? (get-list))))
  
  
  (method public (expand)
    (let ((fact (new List-Factory)))
      (letrec ((expand
                (lambda (object)
                  (cond ((eq? object #t))
                        ((eq? object :root) (put~ fact :root))
                        ((string? object) (put~ fact object))
                        ((symbol? object) (expand (get-alias object)))
                        ((pair? object)
                         (expand (car object))
                         (expand (cdr object)))))))
        (expand (get-list)))
      (get-output~ fact)))


  (method override (get-list)
    path)


  (method public (set-list value)
    (set! path value))


  (method override (get-name)
    (effective-name (get-list)))
  
  
  (method (effective-name lst)
    (let ((name (last lst)))
      (cond ((eq? name :root)
             "/")
            ((symbol? name)
             (effective-name (get-alias name)))
            (else
             name))))
  
  
  (method override (get-base)
    (let ((name (get-name)))
      (if (symbol? name)
          name
        (extract-base name))))
  
  
  (method override (get-extension)
    (extract-extension (get-name)))
  
  
  (method override (get-parent)
    (let ((effective-path (if (= (length path) 1) (expand) path)))
      (if (or (null? effective-path) (null? (cdr effective-path)))
          #f
        (new Directory (butlast effective-path)))))
  
  
  (method public (get-brother name)
    (new (class-of self) (append (get-list~ (get-parent)) (list name))))
  
  
  (method public virtual (new-brother name)
    )
  
  
  (method public virtual (get-directory)
    )
  
  
  (method public (get-attributes (error?: error? #t))
    (unimplemented 'get-attributes)
    @windows-specific
    (let ((attributes (GetFileAttributes (parse))))
      (if (= attributes -1)
          (when error?
            (error "Unable to get file attributes for {t}" self))
        attributes)))
  
  
  (method public (set-attributes flags)
    (unimplemented 'set-attributes)
    @windows-specific
    (let ((ok? (SetFileAttributes (parse) flags)))
      (when (not ok?)
        (error "Unable to set file attributes for {t}" self))))
  
  
  (method override (get-writable?)
    #t ;; super quicky
    @windows-specific
    (not (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_READONLY)))
  
  
  (method override (set-writable? flag)
    (unimplemented 'set-writable?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_READONLY (not flag))))


  (method override (exists?)
    (file-exists? (parse)))
  
  
  (method public (create-directories)
    (let* ((base (get-directory))
           (scan (new Directory (expand~ base)))
           (dirs '()))
      ;; collect the directories reversed so that creation starts from the top
      (while scan
        (set! dirs (cons scan dirs))
        (set! scan (get-parent~ scan)))
      (for-each (lambda (dir)
                  (unless (exists?~ dir)
                    (create~ dir)))
                dirs)))


  ;;;
  ;;;; Anchoring
  ;;;
  
  
  (method public (anchor-to anchor (error?: error? #t))
    (let* ((base-list (get-list~ anchor))
           (base-expd (expand~ anchor))
           (base-length (length base-expd))
           (expd (expand))
           (rank (mismatch base-expd expd test: ci=?))
           (result-list (unspecified)))
      (continuation-capture
        (lambda (return)
          (cond ((not rank)
                 (set! result-list base-list))
                ((< rank base-length)
                 (if error?
                     (error "Unable to anchor pathname {t}, it is not a descendant of {t}" self anchor)
                   (continuation-return return {})))
                (else
                 (set! result-list (append base-list (subseq expd base-length (length expd))))))
          (new (class-of self) result-list)))))
  
  
  (method public (anchorize (anchors: anchors {}) (ignored-anchors: ignored-anchors {}))
    (define (default-anchors)
      (application-anchors~ (get-application)))
    
    (let* ((anchors (difference (either anchors (default-anchors)) (either ignored-anchors '())))
           (anchored (collect (lambda (anchor) (when (valid-alias? anchor) (anchor-to (new Directory (list anchor)) error?: #f))) anchors))
           (sorted (sort < anchored key: (lambda (path) (length (get-list~ path))))))
      (if (null? sorted)
          self
        (car sorted)))))


(definition public inline (pathname? object)
  (is? object Pathname))


(definition public inline (pathname=? x <Moniker> y <Moniker>)
  (compare-pathname~ x y))


(definition public inline (pathname-exists? pathname <Pathname>)
  (file-exists? (parse~ pathname)))


(definition public inline (pathname-delete pathname <Pathname>)
  (file-delete (parse~ pathname)))


(definition public inline (pathname-modification-time pathname <Pathname>)
  (file-modification-time (parse~ pathname)))


;;;
;;;; File
;;;


(class File-Class extends (:class Pathname)
  
  
  (method override (get-protocol)
    'file))


(definition public (create-temporary-file (directory: directory {}) (prefix: prefix "JZZ"))
  (unimplemented 'create-temporary-file)
  @windows-specific
  (let* ((directory (either directory (get-tmp-directory)))
         (dir (parse~ directory)))
    (if (empty-string? dir)
        (error "Unable to use {t} as a temporary directory" directory)
      (let ((filename (make-string MAX_PATH)))
        (GetTempFileName (parse~ directory) prefix 0 filename)
        (adjust-string filename)
        (new File (tokenise-windows filename))))))


(class File metaclass File-Class extends Pathname
  
  
  (method override (print printer readably)
    (format printer "~{File {l detail: :v}}"
            (get-list)
            readably))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother name)
    (new-file~ (get-parent) name))
  
  
  (method override (present)
    (format "{l}" (get-list)))
  
  
  ;;;
  ;;;; Operations
  ;;;


  (method override (get-file)
    self)
  
  
  (method override (get-directory)
    (get-parent))


  (method override (create)
    (unless (exists?)
      (create-directories)
      ;; is there any smarter way to do this in gambit?
      (call-with-output-file (parse)
        (lambda (output)
          ))))


  (method public (copy-file dst (overwrite?: overwrite? #t) (overwrite-read-only?: overwrite-read-only? #f))
    (overwrite-read-only~ dst overwrite-read-only?)
    (when (and overwrite? (exists?~ dst))
      (delete-file~ dst))
    (file-copy (parse) (parse~ dst)))
  
  
  (method public (delete-file (overwrite-read-only?: overwrite-read-only? #f) (error?: error? #t))
    (if (not (exists?))
        (when error?
          (error "Unable to delete inexistant file: {s}" self))
      (overwrite-read-only overwrite-read-only?)
      (file-delete (parse))))
  
  
  (method (overwrite-read-only overwrite-read-only?)
    @windows-specific
    (when (and overwrite-read-only? (exists?) (read-only?))
      (set-read/write)))
  
  
  (method public (get-size)
    (unimplemented 'get-size)
    @windows-specific
    (with-closed ((reader (new File-Reader self readable?: #f)))
      (get-size~ reader)))


  (method override (get-modification-time)
    (seconds->time (inexact->exact (floor (file-modification-time (parse))))))


  (method public (set-modification-time time)
    (unimplemented 'set-modification-time)
    @windows-specific
    (let ((ft (get-filetime~ time))
          (at (get-attributes)))
      ;; this is ugly big time...
      (set-read/write)
      (call-with-output-file (list (parse) mode: 'append)
        (lambda (printer)
          (SetFileTime (get-handle~ printer) NULL NULL ft)))
      (set-attributes at)))
  
  
  (method public (touch)
    (unimplemented 'touch)
    @windows-specific
    (set-modification-time (get-time~ (universal-date))))
  
  
  (method public (get-hidden?)
    (unimplemented 'get-hidden?)
    @windows-specific
    (mask-bit-set? (get-attributes) FILE_ATTRIBUTE_HIDDEN))
  
  
  (method public (set-hidden? flag)
    (unimplemented 'set-hidden?)
    @windows-specific
    (set-attributes (mask-bit-set (get-attributes) FILE_ATTRIBUTE_HIDDEN flag)))
  
  
  (method override (writable?)
    (unimplemented 'writable?)
    @windows-specific
    (let ((handle (CreateFile (parse) GENERIC_WRITE 0 NULL OPEN_EXISTING FILE_ATTRIBUTE_NORMAL NULL)))
      (if (= handle INVALID_HANDLE_VALUE)
          #f
        (CloseHandle handle)
        #t)))
  
  
  (method public (clone-file extension)
    (new File (append (get-list~ (get-directory)) (list (format "{a}.{a}" (get-base) extension)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;


  (method override (load-lines (char-encoding: char-encoding {}) (char-encoding-errors: char-encoding-errors #t))
    (call-with-input-file (list path: (parse) char-encoding: (either char-encoding 'UTF) char-encoding-errors: char-encoding-errors eol-encoding: 'cr-lf)
      read-lines))


  (method override (save-lines lines (char-encoding: char-encoding {}) (eol-encoding: eol-encoding {}))
    (call-with-output-file (list path: (parse) char-encoding: (either char-encoding 'UTF-8) eol-encoding: (either eol-encoding (get-eol-encoding)))
      (lambda (printer)
        (write-lines printer lines)))))


(definition public inline (file? object)
  (is? object File))


(definition public (timestamped-file dir base ext)
  ;; if dir doesn't exists or is read-only we should provide a secondary dir that is always writable
  (let ((prefix (if base (format "{a}_" base) ""))
        (timestamp (date->string (current-date) "~Y-~m-~d_~H-~M-~S")))
    (let (iterate (n 0))
      (let ((suffix (if (= n 0) "" (format "_{a}" n))))
        (let ((file (new-file~ dir (format "{a}{a}{a}.{a}" prefix timestamp suffix ext))))
          (if (exists?~ file)
              (iterate (+ n 1))
            file))))))


;;;
;;;; Directory
;;;


(class Directory-Class extends (:class Pathname)
  
  
  (method override (get-protocol)
    'dir))


(class Directory metaclass Directory-Class extends Pathname
  
  
  (method override (print printer readably)
    (format printer "~{Directory {l detail: :v}}"
            (get-list)
            readably))
  
  
  ;;;
  ;;;; Protocol
  ;;;
  
  
  (method override (new-brother name)
    (new-directory~ (get-parent) name))
  
  
  (method override (present)
    (format "{l}" (get-list)))
  
  
  ;;;
  ;;;; Operations
  ;;;
  
  
  (method override (get-directory)
    self)


  (method override (get-modification-time)
    {})
  
  
  ;; ... give us this day our windows drives ...
  (cond-expand
    (windows
      (method override (get-parent)
        (let ((effective-path (if (= (length path) 1) (expand) path)))
          (if (= 1 (length effective-path))
              (new Windows-Meta-Root)
            (nextmethod)))))
    (else))
  
  
  (method override (create)
    (directory-create (parse)))
  
  
  (method public (new-file name)
    (new File (append (get-list) (if (null/pair? name) name (list name)))))
  
  
  (method public (new-directory name)
    (new Directory (append (get-list) (if (null/pair? name) name (list name)))))
  
  
  (method public (new-unique-file name (separator: separator "_"))
    (let ((file (new-file name)))
      (if (not (exists?~ file))
          file
        (let ((base (extract-base name))
              (ext (extract-extension name))
              (suffix 1))
          (while (exists?~ file)
            (set! file (new-file (format "{a}{a}{a width: 2 justify: :right padding: #\\0}.{a}" base (either separator "") suffix ext)))
            (increase! suffix))
          file))))


  (method public (copy-directory dst (copier: copier {}) (feedback: feedback {}) (touch-files?: touch-files? #f) (copy?: copy? #t))
    (when feedback
      (feedback self))
    (create-directories~ dst)
    (let ((destination
            (lambda (path)
              (append (get-list~ dst) (list (get-name~ path))))))
      (iterate-directory
        (lambda (path)
          (when (or (eq? copy? #t) (copy? path))
            (if (is? path File)
                (let ((dest (new File (destination path))))
                  (if copier
                      (copier path dest)
                    (copy-file~ path dest))
                  @convert
                  (when touch-files?
                    (touch~ dest)))
              (copy-directory~ path (new Directory (destination path)) feedback: feedback touch-files?: touch-files? copy?: copy?))))
        files?: #t
        directories?: #t
        recursive?: #f)))
  
  
  (method public virtual (delete-directory (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback {}))
    (empty-directory overwrite-read-only?: overwrite-read-only? feedback: feedback)
    (remove-directory))
  
  
  (method public (empty-directory (overwrite-read-only?: overwrite-read-only? #f) (feedback: feedback {}))
    (iterate-directory
      (lambda (path)
        (if (is? path File)
            (delete-file~ path overwrite-read-only?: overwrite-read-only?)
          (delete-directory~ path overwrite-read-only?: overwrite-read-only? feedback: feedback)))
      files?: #t
      directories?: #t
      recursive?: #f))
  
  
  (method public (remove-directory)
    (directory-delete (parse)))
  
  
  (method override (get-content (nodes?: nodes? #t) (leaves?: leaves? #t))
    (let ((fact (new List-Factory)))
      (when nodes? (collect-nodes fact))
      (when leaves? (collect-leaves fact))
      (get-output~ fact)))
  
  
  (method (collect-nodes fact)
    (iterate-directory
      (lambda (item)
        (put~ fact item))
      files?: #f
      directories?: #t
      recursive?: #f))
  
  
  (method (collect-leaves fact)
    (iterate-directory
      (lambda (item)
        (put~ fact item))
      files?: #t
      directories?: #f
      recursive?: #f))
     
   
  ;;;
  ;;;; Parse
  ;;;
  
  
  (method override (add-suffix printer)
    (write-char #\/ printer))
     
   
  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (collect-files predicate)
    (let ((fact (new List-Factory)))
      (iterate-directory
        (lambda (file)
          (when (predicate file)
            (put~ fact file)))
        recursive?: #f)
      (get-output~ fact)))
  
  
  ;;;
  ;;;; Iterator
  ;;;
  
  
  (method public virtual (iterate-directory proc (full?: full? #t) (files?: files? #t) (directories?: directories? #f) (sort?: sort? #t) (recursive?: recursive? #t) (ignored-directories: ignored-directories '()))
    (define (iterate-directory-content files? directories? sort? recursive? ignored-directories prefix base proc)
      (iterate-content base 'directories sort? ignored-directories
        (lambda (name)
          (when recursive?
            (iterate-directory-content files? directories? sort? recursive? ignored-directories (append prefix (list name)) (concatenate base "/" name) proc))
          (when directories?
            (proc (append prefix (list name)) 'directory))))
      (iterate-content base 'files sort? ignored-directories
        (lambda (name)
          (when files?
            (proc (concatenate prefix (list name)) 'file)))))
    
    (define (iterate-content base kind sort? ignored-directories proc)
      (if (not sort?)
          (iterate-content-unsorted base kind ignored-directories proc)
        (let ((list '()))
          (iterate-content-unsorted base kind ignored-directories
            (lambda (object)
              (set! list (cons object list))))
          (let ((sorted (sort ci<? list)))
            (for-each proc sorted)))))
    
    (define (iterate-content-unsorted base kind ignored-directories proc)
      (for-each (lambda (name)
                  (let ((path (string-append base "/" name)))
                    ;; this extra test fixes problems on Windows with system files like C:/pagefile.sys
                    (when (file-exists? path)
                      (let ((type (pathname-type path)))
                        (when (or (and (eq? kind 'files) (eq? type 'regular))
                                  (and (eq? kind 'directories) (eq? type 'directory) (not (member? name ignored-directories))))
                          (proc name))))))
                (directory-content-patch base)))
    
    (let ((directory (if full? (get-list) {})))
      (iterate-directory-content files? directories? sort? recursive? ignored-directories '() (parse)
        (lambda (list kind)
          (case kind
            ((file) (if full? (proc (new File (append directory list))) (proc list 'file)))
            ((directory) (if full? (proc (new Directory (append directory list))) (proc list 'directory))))))))
  
  
  ;; quicky because showing .* files in the open dialog creates problems
  ;; on windows with the pagefile.sys file when getting its attributes...
  (cond-expand
    (windows
      (definition (directory-content-patch path)
        (directory-content path)))
    (else
      (definition (directory-content-patch path)
        (directory-content (list path: path ignore-hidden: 'dot-and-dot-dot)))))
  
  
  (method public (count-files (filter: filter {}) (max-count: max-count #f))
    (let ((count 0))
      (continuation-capture
        (lambda (return)
          (iterate-directory
            (lambda (file)
              (when (or (not filter) (filter file))
                (increase! count)
                (when (and max-count (> count max-count))
                  (continuation-return return #f)))))
          count)))))


;; class providing the ugly thing known as windows drives
(cond-expand
  (windows
    (class undocumented Windows-Meta-Root extends Pathname
      
      
      (method override (initialize)
        )

      
      (method override (get-name)
        "This Computer")
      
      
      (method override (present)
        (get-name))
      
      
      (method override (get-parent)
        #f)
      
      
      (method override (get-directory)
        (new Directory (list "C:")))
      
      
      (method override (exists?)
        #t)
      
      
      (method override (get-content (nodes?: nodes? #t) (leaves?: leaves? #t))
        (define (enumerate-drives)
          (reverse!
            (let (loop (drives (jazz.platform.windows.GetLogicalDrives))
                       (letter (char->integer #\A))
                       (result '()))
              (if (= drives 0)
                  result
                (loop (arithmetic-shift drives -1) (+ letter 1)
                  (if (/= 0 (bitwise-and drives 1))
                      (cons (integer->char letter) result)
                    result))))))
        
        (let ((fact (new List-Factory)))
          (when nodes?
            (for-each (lambda (letter)
                        (put~ fact (new Directory (list (string letter #\:)))))
                      (enumerate-drives)))
          (get-output~ fact)))))

  (else))


(definition public inline (directory? obj)
  (is? obj Directory))


(definition public (get-current-directory)
  (new Directory (tokenise-filename (current-directory))))


(definition public (set-current-directory directory)
  (current-directory-set! (parse~ directory)))


(definition public (with-preserved-current-directory proc)
  (let ((preserved (get-current-directory)))
    (unwind-protect
        (proc)
      (set-current-directory preserved))))


;;;
;;;; Extension
;;;


(definition public Scheme-Extensions
  '("scm" "sch" "ss" "gambcini" "buildini" "jazzini"))

(definition public CommonLisp-Extensions
  '("lisp"))

(definition public Jazz-Extensions
  '("jazz" "jcat" "jml" "mnf" "repository" "package" "settings" "snapshot"))

(definition public C-Extensions
  '("c" "cpp" "h" "hpp"))

(definition public SQL-Extensions
  '("sql"))

(definition public Textual-Extensions
  '("conf" "css" "erl" "ftx" "htm" "java" "js" "log" "lua" "mnf" "package" "prop" "properties" "py" "rc" "repository" "sh" "sql" "template" "txt"))

(definition public Text-Extensions
  (append Scheme-Extensions
          CommonLisp-Extensions
          Jazz-Extensions
          C-Extensions
          Textual-Extensions))


(definition public (effective-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Extensions)
    ((:commonlisp) CommonLisp-Extensions)
    ((:jazz) Jazz-Extensions)
    ((:c) C-Extensions)
    ((:text) Text-Extensions)
    (else extensions)))


(definition Scheme-Include-Extensions
  Scheme-Extensions)

(definition CommonLisp-Include-Extensions
  CommonLisp-Extensions)

(definition Jazz-Include-Extensions
  (append Scheme-Include-Extensions
          '("jazz" "jml" "mnf" "repository" "package")))

(definition C-Include-Extensions
  C-Extensions)

(definition Textual-Include-Extensions
  Textual-Extensions)

(definition Text-Include-Extensions
  (append Scheme-Include-Extensions
          CommonLisp-Include-Extensions
          Jazz-Include-Extensions
          C-Include-Extensions
          Textual-Include-Extensions))


(definition package (effective-include-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Include-Extensions)
    ((:commonlisp) CommonLisp-Include-Extensions)
    ((:jazz) Jazz-Include-Extensions)
    ((:c) C-Include-Extensions)
    ((:text) Text-Include-Extensions)
    (else extensions)))


(definition Scheme-Catalog-Extensions
  Scheme-Extensions)

(definition CommonLisp-Catalog-Extensions
  CommonLisp-Extensions)

(definition Jazz-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          '("jazz")))

(definition C-Catalog-Extensions
  C-Extensions)

(definition Textual-Catalog-Extensions
  Textual-Extensions)

(definition Text-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          CommonLisp-Catalog-Extensions
          Jazz-Catalog-Extensions
          C-Catalog-Extensions
          Textual-Catalog-Extensions))


(definition package (effective-catalog-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Catalog-Extensions)
    ((:commonlisp) CommonLisp-Catalog-Extensions)
    ((:jazz) Jazz-Catalog-Extensions)
    ((:c) C-Catalog-Extensions)
    ((:text) Text-Catalog-Extensions)
    (else extensions)))


(definition public (extension-constituent-test ext)
  (cond ((member? ext Jazz-Extensions test: ci=?) jazz-constituent?)
        ((member? ext Scheme-Extensions test: ci=?) scheme-constituent?)
        ((member? ext C-Extensions test: ci=?) c-constituent?)
        ((member? ext SQL-Extensions test: ci=?) sql-constituent?)
        (else word-constituent?))))
