;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; JML
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.jml jazz


(export (jazz.jml.syntax (phase syntax))
        (jazz.jml.autoload))
(import (jazz.jml.autoload)
        (jazz.library))


;;;
;;;; Tag
;;;


(definition public (tag? expr)
  (and (symbol? expr)
       (tag-string? (symbol->string expr))))


(definition public (tag-string? string)
  (and (> (string-length string) 2)
       (starts-with? string "<")
       (ends-with? string ">")))


(definition public (tag->name tag)
  (let ((extract
          (lambda (string <string>)
            (subseq string 1 (- (cardinality string) 1)))))
    (if (string? tag)
        (extract tag)
      (string->symbol (extract (symbol->string tag))))))


(definition public (name->tag name)
  (string->symbol (string-append "<" (symbol->string name) ">")))


;;;
;;;; Form
;;;


;; Not ideal to use the class locator to register forms but will do for now as
;; it is not easy to access the metaclass at the point where forms are expanded


(definition Forms
  (make-table test: eq?))


(definition package (register-form class-locator form)
  (table-set! Forms class-locator form))

(definition package (get-registered-form class-locator)
  (table-ref Forms class-locator #f))


;;;
;;;; Source
;;;


(definition Autoclasses
  (make-table test: eq?))


(definition public (get-autoclass name)
  (table-ref Autoclasses name #f))


(definition public (set-autoclass name class)
  (table-set! Autoclasses name class))


(definition public (register-autoclass class)
  (set-autoclass (category-name class) class))


(definition public (autoload-class name)
  (either (get-autoclass name)
          (when (get-autoload name)
            (autoload name))))


;;;
;;;; Parse
;;;


(definition public (parse-jml jml (preferences-class: preferences-class {}) (parser-class: parser-class {}))
  (let* ((pref (new (either preferences-class JML-Preferences)))
         (parser (new (either parser-class JML-Parser) preferences: pref)))
    (parse~ parser jml)))


;;;
;;;; Transform
;;;


(definition public (transform-jml node transformation)
  (transform~ transformation node))


;;;
;;;; Render
;;;


(definition public (render-jml node printer (preferences-class: preferences-class {}) (renderer-class: renderer-class {}))
  (let* ((pref (new (either preferences-class JML-Preferences)))
         (renderer (new (either renderer-class JML-Renderer) pref)))
    (render~ renderer node printer)))


;;;
;;;; Parsing
;;;


(definition public (parse-jml-properties/children list)
  (let ((properties {})
        (content {}))
    (let (iterate (scan list))
      (if (null? scan)
          (values (if properties (queue-list properties) '())
                  (if content (queue-list content) '()))
        (let ((element (car scan)))
          (if (and (not content) (keyword? element))
              (begin
                (when (not properties)
                  (set! properties (new-queue)))
                (enqueue properties element)
                (enqueue properties (cadr scan))
                (iterate (cddr scan)))
            (when (not content)
              (set! content (new-queue)))
            (enqueue content element)
            (iterate (cdr scan))))))))


(definition public (get-jml-property list property (not-found: not-found '()))
  (let ((scan list))
    (continuation-capture
      (lambda (return)
        (while (not-null? scan)
          (when (eqv? (car scan) property)
            (continuation-return return (cadr scan)))
          (set! scan (cddr scan)))
        not-found))))


;;;
;;;; Form
;;;


;; ALL THIS IS A VERY NAIVE FIRST DRAFT IMPLEMENTATION


(definition public (jml->form expr)
  (let* ((parser (new JML-Parser))
         (node (parse~ parser expr)))
    (node->form node)))


(definition public (jml->form>> expr class)
  (let ((form (jml->form expr)))
    (setup-toplevel-context~ form class)
    form))


(definition public (node->form node)
  (define (extract-node-properties node)
    (let ((fact (new List-Factory)))
      (for-each-property (lambda (property value)
                           (when (not (memq? property '(name tag-symbolic? tag-unit)))
                             (put~ fact property)
                             (put~ fact value)))
                         (get-properties~ node))
      (get-output~ fact)))
  
  (letrec ((node->form
             (lambda (node parent)
               (if (is? node JML-Text)
                   node
                 (let* ((tag (get-tag~ node))
                        (tag-name (symbol->string tag))
                        (tag-modify? (and (neq? tag '!) (ends-with? tag-name "!")))
                        (tag-locate? (and (neq? tag '~) (ends-with? tag-name "~")))
                        (tag-symbolic? (or tag-modify? tag-locate?))
                        (action (cond ((or (eq? tag '!) tag-modify?) 'modify)
                                      ((or (eq? tag '~) tag-symbolic?) 'locate)
                                      (else 'new)))
                        (model-name (if (or (memq? tag '(! ~)) tag-symbolic?) {} tag))
                        (name (if tag-symbolic? (string->symbol (butlast tag-name)) (get-property~ node 'name)))
                        (form (new Form textual?: #f action: action model-name: model-name name: name tag-symbolic?: tag-symbolic? tag-unit: (get-property~ node 'tag-unit #f) properties: (extract-node-properties node)))
                        (children (map (lambda (node)
                                         (node->form node form))
                                       (get-children~ node))))
                   (set-parent-value~ form parent)
                   (if (branch-model? tag)
                       ;; not 100% sure about this way of testing for a branch form with no install
                       (if (null? children)
                           (begin
                             (set-property~ form 'client-form (new Form action: 'new model-name: 'install))
                             (set-children~ form '()))
                         (set-property~ form 'client-form (car children))
                         (set-children~ form (cdr children)))
                     (set-children~ form children))
                   form)))))
    (node->form node {})))


(definition public (form->node form)
  (define (add-client-form form children)
    (let ((client-form (get-property~ form 'client-form)))
      (if (not client-form)
          children
        (cons (form->node client-form) children))))
  
  (define (extract-form-properties form symbolic?)
    (let ((fact (new List-Factory))
          (name (get-name~ form))
          (tag-unit (get-tag-unit~ form)))
      (when (and name (not symbolic?))
        (put~ fact 'name)
        (put~ fact name))
      (when tag-unit
        (put~ fact 'tag-unit)
        (put~ fact tag-unit))
      (for-each-property (lambda (property value)
                           (let ((name (if (property? property) (field-name property) property)))
                             (when (neq? name 'client-form)
                               (put~ fact name)
                               (put~ fact value))))
                         (get-properties~ form))
      (get-output~ fact)))
  
  (letrec ((form->node
             (lambda (form parent)
               (if (is? form JML-Text)
                   form
                 (let* ((action (get-action~ form))
                        (model-name (get-model-name~ form))
                        (name (get-name~ form))
                        (symbolic? (get-tag-symbolic?~ form))
                        (tag (if symbolic?
                                 (string->symbol (string-append (symbol->string name) (case action ((modify) "!") ((locate) "~"))))
                               (case action ((install) 'install) ((new) model-name) ((modify) '!) ((locate) '~))))
                        (element (new JML-Element parent tag))
                        (properties (extract-form-properties form symbolic?))
                        (children (map (lambda (form)
                                         (form->node form element))
                                       (get-children~ form))))
                   (set-properties~ element properties)
                   (set-children~ element (if (branch-model? model-name) (add-client-form form children) children))
                   element)))))
    (form->node form {})))


(definition (branch-model? model-name)
  (memq? model-name '(Branch Design-Diagram Design-Model Slide Basic-Slide Documentation-Slide Concept-Slide Heading-Slide Test-Branch Test-Branch-Aux Test-Model)))


;;;
;;;; Load
;;;


(definition public (read-jml file)
  (parameterize ((walk-for #f))
    (call-with-input-file (list path: (parse~ file) eol-encoding: 'cr-lf readtable: jazz-readtable)
      read)))


(definition public (load-jml file)
  (let ((parser (new JML-Parser preferences: (new JML-Preferences))))
    (parse~ parser (read-jml file)))))
