;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Remote Method Invocation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; OVERVIEW
;;   Socket is persistent between two connected processes
;;   and messages and responses travel through the bidirectional
;;   socket pipe. Initial connection is done with connect-uuid.
;;
;; LEXICON
;;   uuid
;;     used to uniquely identify processes
;;   ior
;;     marshalled object sent remotely
;;   listener
;;     tcp server receiving a connection request
;;     and that starts the pump called jrm-connection
;;   pumps
;;     waits on socket for messages client and server side
;;   switchboard
;;     handles client and server side requests
;;   stub
;;     interface common to local and remote objects
;;   proxy local / remote
;;     objects implementing transparent communication
;;   register
;;     used to register remotely accessible objects
;;
;; CALL
;;   local <-> remote call
;;     local code calls invoke-remote from some local thread
;;       message is sent to local switchboard mailbox
;;         local thread then calls wait-for-result
;;         when first time connection
;;           persistent socket is established and pump started
;;           note that there is only one socket between processes
;;         remote pump receives message and sends it to switchboard
;;           remote switchboard calls message in a thread
;;             remote thread sends result back
;;         local pump receives message and sends it to switchboard
;;           local switchboard sends result to local thread
;;
;; TODO
;; - need to really think about exception handling
;;   - make sure exceptions internal to jrm are handled correctly
;;   - maybe we should just let user code exceptions by handled by
;;     the current exception handler!?


(module jazz.jrm jazz


(export (jazz.jrm.autoload))
(import (jazz.jrm.autoload)
        (jazz.jrm.protocol)
        (jazz.jrm.transmission)
        (jazz.event)
        (jazz.network)
        (jazz.settings)
        (jazz.version))


(definition *jrm-marker*
  (list 'jrm))


;;;
;;;; UUID
;;;


(definition *jrm-uuid*
  #f)


(definition public (listening-uuid)
  (or *jrm-uuid*
      (let ((uuid (make-uuid)))
        (set! *jrm-uuid* uuid)
        uuid)))


;;;
;;;; Debug
;;;


(definition (debug-jrm side action message/delayed)
  (define (simplify message)
    (cond ((not *debug-simplify?*)
           message)
          ((pair? message)
           (map (lambda (message)
                  (cond ((pair? message)
                         '<pair>)
                        ((object? message)
                         '<object>)
                        (else
                         message)))
                message))
          (else
           message)))
  
  (when *debug?*
    (let ((message (if (procedure? message/delayed) (message/delayed) message/delayed)))
      (format :terminal "{r precision: 6} {a} {a} {s} {s}{%}" (current-seconds) (listening-uuid) side action (simplify message)))))


;;;
;;;; Server
;;;


(definition Remote-Listener-Host
  localhost)

(definition Remote-Listener-Service
  'any)


(definition remote-listener
  #f)


(definition public (get-remote-listener)
  remote-listener)

(definition public (set-remote-listener server)
  (set! remote-listener server))


(definition public (require-remote-listener)
  (if (not remote-listener)
      (error "Unable to complete operation because the remote listener is not running")
    remote-listener))


(definition public (listen-parameter)
  (host/service-parameter "listen" 'listen (values #f #f #f)))


(definition public (host/service-parameter arg setting (default (unspecified)))
  (get-parameter arg parse-host/service setting parse-host/service default))


(definition public (start-remote-listener (host: host #f) (service: service #f) (alternate-service: alternate-service #f))
  (unless remote-listener
    (receive (listen-host listen-service listen-alternate-service) (listen-parameter)
      (let ((host (or host listen-host Remote-Listener-Host))
            (service (or service listen-service Remote-Listener-Service))
            (alternate-service (or alternate-service listen-alternate-service)))
        (let ((server (new Remote-Listener host: host service: service alternate-service: alternate-service)))
          (start~ server)
          (set-remote-listener server)
          (start-remote-switchboard))))))


(definition public (stop-remote-listener)
  (when remote-listener
    (stop~ remote-listener)
    (set-remote-listener #f)))


;;;
;;;; Liveliness
;;;


(definition public live-timeout
  0.5)

(definition live-request
  'live?)

(definition live-response
  'alive)


(definition package (remote-proxy-live? remote-proxy)
  (catch (Connection-Broke exc
           #f)
    (parameterize ((send-timeout live-timeout)
                   (receive-timeout live-timeout))
      (let ((result (invoke-remote 'live? 'live? remote-proxy '())))
        (eq? result live-response)))))


;;;
;;;; Connection
;;;


(definition public (connect-uuid host service (slave? #f))
  (debug-jrm '-pump- 'start (list host service))
  (let ((port (open-tcp-client (list server-address: host port-number: service readtable: jazz-readtable))))
    (with-exception-catcher
      (lambda (exc)
        (debug-jrm '-pump- 'closed (list host service))
        (with-exception-catcher
          (lambda (exc)
            #f)
          (lambda ()
            ;; open-tcp-client may silently fail
            (close-port port)))
        (throw exc))
      (lambda ()
        (let ((local-uuid (listening-uuid)))
          (send-remote-message (list 'connect local-uuid simulated-protocol) port))
        (let ((uuid (read-port port)))
          (when (eof-object? uuid)
            (throw-connection-broke))
          (if (eq? uuid 'already-connected)
              (error "Already connected to {a} {a}" host service)
            (let ((protocol (read-port port)))
              (thread-start! (new-thread
                               (lambda ()
                                 (process-pump uuid protocol port slave?))
                               'jrm-pump))
              (set-pump-port uuid port)
              (debug-jrm '-pump- 'started (list host service port))
              uuid)))))))


;;;
;;;; Client
;;;


(definition public send-timeout
  (make-parameter 2))

(definition public receive-timeout
  (make-parameter 10))


(definition public (post-remote method-name remote-proxy . arguments)
  (invoke-remote 'post method-name remote-proxy arguments))


(definition public (exec-remote method-name remote-proxy . arguments)
  (invoke-remote 'exec method-name remote-proxy arguments))


(definition public (call-remote method-name remote-proxy . arguments)
  (invoke-remote 'call method-name remote-proxy arguments))


(definition (send-remote-message info port)
  (let ((timeout (send-timeout)))
    (when timeout
      (output-port-timeout-set! port timeout throw-connection-broke)))
  (write-port port (cons (current-seconds) info)))


(definition (wait-for-result method-name invoke-thread)
  (define (skip-to-message)
    (declare (proper-tail-calls))
    (let (iter)
      (let ((next (thread-mailbox-next)))
        (cond ((and (pair? next) (eq? (car next) *jrm-marker*))
               (thread-mailbox-extract-and-rewind)
               (cdr next))
              (else
               (iter))))))
  
  (let ((message (skip-to-message)))
    (debug-jrm 'client 'read (list method-name (object->serial invoke-thread)))
    (debug-jrm 'client 'read message)
    (bind (kind cookie result) message
      (case kind
        ((result)
         result)
        ((broke)
         (throw-connection-broke))
        ((error)
         (error "Remote error while executing {s}: {a}" method-name result))))))


;; quick hack to improve
(definition public post-problem-handler
  (make-parameter #f))


(definition (invoke-remote kind method-name remote-proxy arguments)
  (define (make-absolute-timeout timeout)
    (+ (current-seconds) timeout))
  
  (let ((proxy-ior (proxy->ior remote-proxy))
        (invoke-thread (current-thread))
        (post-problem-handler (post-problem-handler)))
    (let ((uuid (get-uuid~ proxy-ior))
          (cookie (object->serial invoke-thread))
          (timeout (and (neq? kind 'post) (make-absolute-timeout (receive-timeout)))))
      (debug-jrm 'client 'send (list kind cookie method-name (get-ior~ remote-proxy) (and *debug-arguments?* arguments)))
      (thread-send (require-remote-switchboard) (values 'invoke uuid (values invoke-thread post-problem-handler timeout kind method-name proxy-ior arguments)))
      (case kind
        ((post)
         (unspecified))
        ((call live?)
         (wait-for-result method-name invoke-thread))
        ((exec)
         (wait-for-result method-name invoke-thread)
         (unspecified))))))


;;;
;;;; Remote
;;;


;; aec quick hack
(definition protected remote-problem-handler
  #f)

(definition protected (set-remote-problem-handler problem-handler)
  (set! remote-problem-handler problem-handler))


(definition package (connect-remote port)
  (define (receive-remote-message port)
    (let ((timeout (receive-timeout)))
      (when timeout
        (input-port-timeout-set! port timeout)))
    (let ((info (read-port port)))
      (if (eof-object? info)
          (throw-connection-broke)
        info)))
  
  (define (process)
    (bind (sent . message) (receive-remote-message port)
      ;; connect-uuid might already have created a pump
      ;; when both processes invoke simultaneously
      (case (car message)
        ((connect)
         (bind (kind uuid protocol) message
           ;; already connected!
           (if (find-pump-port uuid)
               (write-port port 'already-connected)
             (set-pump-port uuid port)
             (let ((local-uuid (listening-uuid))
                   (local-protocol simulated-protocol))
               (write-port port local-uuid)
               (write-port port local-protocol))
             (process-pump uuid protocol port)))))))
  
  (if remote-problem-handler
      (remote-problem-handler process)
    (process)))


;;;
;;;; Pump
;;;


(definition pump-mutex
  (make-mutex 'pump))


(definition (with-pump-mutex thunk)
  (dynamic-wind
    (lambda ()
      (mutex-lock! pump-mutex))
    thunk
    (lambda ()
      (mutex-unlock! pump-mutex))))


(definition protected pump-ports
  (make-table))


(definition protected (find-pump-port uuid)
  (with-pump-mutex
    (lambda ()
      (table-ref pump-ports uuid #f))))


(definition protected (require-pump-port uuid)
  (or (find-pump-port uuid)
      (throw-connection-broke)))


(definition protected (set-pump-port uuid port)
  (with-pump-mutex
    (lambda ()
      (table-set! pump-ports uuid port))))


(definition protected (close-pump-port uuid port)
  (with-pump-mutex
    (lambda ()
      (table-clear pump-ports uuid)
      (close-port port))))


(definition (process-pump uuid protocol port (slave? #f))
  (declare (proper-tail-calls))
  (let ((wait-port (open-vector)))
    (let (loop)
      (input-port-timeout-set! port +inf.0)
      (let ((data (catch (connection-problem? exc
                           (when slave?
                             (delay-event (lambda () (quit))))
                           (eof-object))
                    (read-port port))))
        ;; simulated protocol
        (when (and protocol (not (eof-object? data)))
          (let ((lag protocol)
                (sent (car data)))
            (let ((wait (- (+ sent lag) (current-seconds))))
              (when (> wait 0.)
                (input-port-timeout-set! wait-port wait)
                (read wait-port)))))
        (let ((message (if (eof-object? data) data (cdr data))))
          (debug-jrm '-pump- 'read message)
          (thread-send (require-remote-switchboard) (values 'pump uuid message))
          (if (eof-object? message)
              (close-pump-port uuid port)
            (loop)))))))


(definition (process-pump-message invocations uuid message)
  (define (dispatch-remote message)
    (bind (kind cookie method-name proxy-ior arguments) message
      (debug-jrm 'server 'dispatch (list kind cookie method-name proxy-ior (and *debug-arguments?* arguments)))
      (let ((local-proxy (ior->proxy proxy-ior)))
        (apply (dispatch (class-of local-proxy) method-name) local-proxy arguments))))
  
  (define (execute-remote message)
    (bind (kind cookie method-name proxy-ior arguments) message
      (define (dispatch-result message)
        (let ((result (dispatch-remote message)))
          (case kind
            ((exec) (list 'result cookie (unspecified)))
            ((call) (list 'result cookie result)))))
      
      (if (or (not transmit-exceptions?)
              (jazz.debuggee:get-controller-debugger))
          (dispatch-result message)
        (continuation-capture
          (lambda (return)
            (with-exception-handler
              (lambda (exc)
                (continuation-capture
                  (lambda (cont)
                    (debug-jrm 'server 'exception
                      (lambda ()
                        (list method-name
                              (with-output-to-string ""
                                (lambda ()
                                  (display-exception exc)))
                              (with-output-to-string ""
                                (lambda ()
                                  (display-continuation-backtrace cont))))))
                    (continuation-return return (list 'error cookie (exception-reason exc))))))
              (lambda ()
                (dispatch-result message))))))))
  
  (define (cleanup-pump-invocations invocations pump-uuid)
    (table-for-each
      (lambda (thread rest)
        (bind (timeout uuid message) rest
          (when (equal? uuid pump-uuid)
            (invocation-broke thread 'connection-closed))))
      invocations))
  
  (debug-jrm 'server 'pump message)
  (if (eof-object? message)
      (cleanup-pump-invocations invocations uuid)
    (let ((kind (car message)))
      (case kind
        ((error result)
         (bind (kind cookie result) message
           (let ((thread (serial->object cookie)))
             (when (table-ref invocations thread #f)
               (table-clear invocations thread)
               (thread-send thread (cons *jrm-marker* message))))))
        ((live?)
         (bind (kind cookie method-name proxy-ior arguments) message
           (catch Connection-Broke
             (let ((port (require-pump-port uuid)))
               (send-remote-message (list 'result cookie live-response) port)))))
        ((post)
         (thread-start!
           (new-thread (lambda ()
                         (dispatch-remote message))
                       'jrm-post)))
        ((exec call)
         (thread-start!
           (new-thread (lambda ()
                         (let ((reply (execute-remote message)))
                           (debug-jrm 'server 'reply message)
                           (debug-jrm 'server 'reply reply)
                           (let ((port (require-pump-port uuid)))
                             (when port
                               (send-remote-message reply port)))))
                       (case kind
                         ((exec) 'jrm-exec)
                         ((call) 'jrm-call)))))))))


;;;
;;;; Switchboard
;;;


(definition *jrm-switchboard*
  #f)


(definition public (require-remote-switchboard)
  (if (not *jrm-switchboard*)
      (error "Unable to complete operation because the remote switchboard is not running")
    *jrm-switchboard*))


(definition public (start-remote-switchboard)
  (unless *jrm-switchboard*
    ;; main thread has load-lock on jazz.debuggee.setup
    ;; switchboard-thread will need to load jazz.jrm.register.Register
    (load-unit 'jazz.jrm.register.Register)
    (set! *jrm-switchboard*
          (new-thread (lambda ()
                        (process-switchboard))
                      'jrm-switchboard))
    (thread-start! *jrm-switchboard*)))


(definition public (flush-remote-switchboard)
  (when *jrm-switchboard*
    (let ((invoke-thread (current-thread)))
      (thread-send (require-remote-switchboard) (values 'flush #f invoke-thread))
      (catch (Connection-Broke exc
               #f)
        (wait-for-result 'flush invoke-thread)))))


(definition (process-switchboard)
  (define (find-best-timeout invocations)
    (let ((best-thread #f)
          (best-timeout +inf.0)
          (best-message #f))
      (table-for-each
        (lambda (thread data)
          (bind (timeout uuid message) data
            (when (or (not best-thread)
                      (> best-timeout timeout))
              (set! best-thread thread)
              (set! best-timeout timeout)
              (set! best-message message))))
        invocations)
      (values best-thread best-timeout best-message)))
  
  (declare (proper-tail-calls))
  (let ((invocations (make-table)))
    (let (loop)
      (receive (best-thread best-timeout best-message) (find-best-timeout invocations)
        (let ((msg (thread-receive best-timeout (eof-object))))
          (if (eof-object? msg)
              (begin
                (table-clear invocations best-thread)
                (invocation-broke best-thread 'timeout))
            (receive (origin uuid message) msg
              (case origin
                ((pump)
                 (process-pump-message invocations uuid message))
                ((flush)
                 (let ((timeout 0)
                       (invoke-thread message))
                   (table-set! invocations invoke-thread (list timeout uuid message))))
                ((invoke)
                 (receive (invoke-thread post-problem-handler timeout kind method-name proxy-ior arguments) message
                   (debug-jrm 'server 'invoke (list (object->serial invoke-thread) timeout kind method-name proxy-ior arguments))
                   (assert (thread? invoke-thread))
                   (let ((cookie (object->serial invoke-thread)))
                     (with-exception-filter
                       (lambda (exc)
                         (connection-problem? exc))
                       (lambda (exc)
                         ;; post doesn't wait on mailbox
                         (if (eq? kind 'post)
                             (if post-problem-handler
                                 (post-problem-handler exc)
                               (post-event
                                 (lambda ()
                                   (throw exc))))
                           (invocation-broke invoke-thread exc)))
                       (lambda ()
                         (let ((port (require-pump-port uuid))
                               (message (list kind cookie method-name proxy-ior arguments)))
                           (send-remote-message message port))
                         (when timeout
                           (table-set! invocations invoke-thread (list timeout uuid message))))))))
                (else
                 (error "Unknown origin: {s}" origin)))))))
      (loop))))


(definition (invocation-broke thread exception)
  (debug-jrm 'server 'broke (list thread exception))
  (let ((cookie (object->serial thread)))
    (thread-send thread (cons *jrm-marker* (list 'broke cookie exception)))))


;;;
;;;; IOR
;;;


(definition public (ior? object)
  (is? object IOR))


(definition public (local-ior? ior)
  (uuid=? (get-uuid~ ior) (listening-uuid)))


(definition public (ior=? x y)
  (and (host=? (get-host~ x) (get-host~ y))
       (service=? (get-service~ x) (get-service~ y))
       (reference=? (get-reference~ x) (get-reference~ y))))


(definition public (ior-server=? x y)
  (and (host=? (get-host~ x) (get-host~ y))
       (service=? (get-service~ x) (get-service~ y))))


(definition public (host=? x y)
  (equal? x y))


(definition public (service=? x y)
  (eqv? x y))


(definition public (reference=? x y)
  (eqv? x y))


(definition public (ior->proxy ior)
  (define (local->proxy stub-interface ior)
    (define (reference->local-proxy stub-interface reference)
      (if (not reference)
          (get-local-register)
        (new (local-class~ stub-interface) (serial->object reference))))
    
    (reference->local-proxy stub-interface (get-reference~ ior)))
  
  (define (remote->proxy stub-interface ior)
    (let ((remote-class (remote-class~ stub-interface)))
      (new remote-class ior (get-values~ ior))))
  
  (let ((stub-interface (resolve-runtime-reference (deserialize-runtime-reference (get-stub-interface~ ior)))))
    (if (local-ior? ior)
        (local->proxy stub-interface ior)
      (remote->proxy stub-interface ior))))


;;;
;;;; Proxy
;;;


(definition public (proxy? object)
  (is? object Proxy))


(definition public (proxy=? x y)
  (cond ((and (remote-proxy? x) (remote-proxy? y))
         (remote-proxy=? x y))
        ((and (local-proxy? x) (local-proxy? y))
         (local-proxy=? x y))
        (else
         #f)))


(definition public (proxy-server=? x y)
  (cond ((and (remote-proxy? x) (remote-proxy? y))
         (ior-server=? (get-ior~ x)
                       (get-ior~ y)))
        ((and (local-proxy? x) (local-proxy? y))
         #t)
        (else
         #f)))


(definition public (proxy->ior proxy)
  (define (local->ior local-proxy)
    (define (local-proxy->reference local-proxy)
      (if (proxy=? local-proxy (get-local-register))
          #f
        (let ((object (get-object~ local-proxy)))
          (gc-protect object)
          (object->serial object))))
    
    (let ((server (require-remote-listener)))
      (new IOR
        (listening-uuid)
        (listening-host~ server)
        (listening-port~ server)
        (serialize-runtime-reference (stub-reference~ local-proxy))
        (local-proxy->reference local-proxy)
        (proxy-values~ local-proxy))))
  
  (define (remote->ior proxy)
    (get-ior~ proxy))
  
  (if (remote-proxy? proxy)
      (remote->ior proxy)
    (local->ior proxy)))


;;;
;;;; Local Proxy
;;;


(definition public (local-proxy? object)
  (is? object Local-Proxy))


(definition public (local-proxy=? x y)
  (eq? (get-object~ x)
       (get-object~ y)))


;;;
;;;; Remote Proxy
;;;


(definition public (remote-proxy? object)
  (is? object Remote-Proxy))


(definition public (remote-proxy=? x y)
  (ior=? (get-ior~ x)
         (get-ior~ y)))


(definition public (connect-remote-proxy proxy)
  (let ((ior (get-ior~ proxy)))
    (let ((uuid (get-uuid~ ior)))
      ;; already connected
      (unless (find-pump-port uuid)
        (let ((host (get-host~ ior))
              (service (get-service~ ior)))
          (assert (uuid=? (connect-uuid (or host localhost) service)
                          uuid)))))))


;;;
;;;; Register
;;;


(definition *local-register*
  #f)


(definition public (get-local-register)
  (when (not *local-register*)
    (set! *local-register* (new-local-proxy~ Register)))
  *local-register*)


(definition public (get-remote-register remote-proxy)
  (let ((ior (get-ior~ remote-proxy)))
    (new-remote-register (get-uuid~ ior) (get-host~ ior) (get-service~ ior))))


(definition public (new-remote-register uuid host port)
  (ior->proxy (new IOR uuid host port (serialize-runtime-reference (reference Register-Stub)) #f '())))


(definition public (connect-remote-register host port (slave? #f))
  (let ((uuid (connect-uuid host port slave?)))
    (new-remote-register uuid host port)))


;;;
;;;; GC
;;;


;; Need to think about how the objects should be GC protected
;; One possible approach is to use a refcounted table of shared
;; objects. For this we need to always use IOR, e.g. wrap
;; serial numbers in IOR and define a will on IOR that calls
;; the IOR's ownwer process to release the object's refcount


(definition protected *Mega-Patch*
  '())


(definition public (gc-protect obj)
  (set! *Mega-Patch* (cons obj *Mega-Patch*)))


;;;
;;;; Marshall
;;;


(definition protected (marshall-local-proxy proxy)
  (define (local-proxy->reference)
    (if (proxy=? proxy (get-local-register))
        #f
      (let ((object (get-object~ proxy)))
        (gc-protect object)
        (object->serial object))))
  
  (let ((server (require-remote-listener)))
    (let ((ior
            (new IOR
              (listening-uuid)
              (listening-host~ server)
              (listening-port~ server)
              (serialize-runtime-reference (stub-reference~ proxy))
              (local-proxy->reference)
              (proxy-values~ proxy))))
      (serialize-object (class-of proxy) (encode-ior ior)))))


(definition protected (marshall-remote-proxy proxy)
  (serialize-object (class-of proxy) (encode-ior (get-ior~ proxy))))


(definition (encode-ior ior)
  (vector (get-uuid~ ior)
          (get-host~ ior)
          (get-service~ ior)
          (get-stub-interface~ ior)
          (get-reference~ ior)
          (get-values~ ior)))


;;;
;;;; Unmarshall
;;;


(definition protected (unmarshall-proxy content)
  (ior->proxy (decode-ior content)))


(definition (decode-ior content)
  (new IOR
    (vector-ref content 0)
    (vector-ref content 1)
    (vector-ref content 2)
    (vector-ref content 3)
    (vector-ref content 4)
    (vector-ref content 5)))


;;;
;;;; Protocol
;;;


(definition public *jazz-code*
  (code-string->32-bit-integer "JAZZ"))

(definition public *jazz-version*
  {Version 2 0 0})


(definition (write-port port info)
  (with-connection
    (lambda ()
      (write-header *jazz-code* *jazz-version* port)
      (write-data info port)
      (force-output port))))


(definition (read-port port)
  (with-connection
    (lambda ()
      (receive (application-code client-version) (read-header port)
        ;;(validate-application-code application-code)
        (read-data port))))))
