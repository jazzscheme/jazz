;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Remote Method Invocation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.jrm jazz


(export (jazz.jrm.autoload))
(import (jazz.jrm.autoload)
        (jazz.jrm.protocol)
        (jazz.network)
        (jazz.version))


(definition *debug?*
  #f)

(definition *debug-arguments?*
  #f)

(definition *debug-locally?*
  #f)


;;;
;;;; Server
;;;


(definition Remote-Listener-Host
  ;; host-name is only available when connected to the internet
  ;; (host-name)
  "localhost")

(definition Remote-Listener-Service
  'any)


(definition (remote-listener-host)
  (receive (host port) (command-host/service "listener")
    (or host Remote-Listener-Host)))

(definition (remote-listener-service)
  (receive (host port) (command-host/service "listener")
    (or port Remote-Listener-Service)))


(definition remote-listener
  #f)


(definition public (get-remote-listener)
  remote-listener)

(definition public (set-remote-listener server)
  (set! remote-listener server))


(definition public (require-remote-listener)
  (if (not remote-listener)
      (error "Unable to complete operation because the remote listener is not running")
    remote-listener))


(definition public (start-remote-listener (default-host: default-host #f) (default-service: default-service #f))
  (unless remote-listener
    (receive (host service) (command-host/service "listen")
      (let ((server (new Remote-Listener host: (or host default-host (remote-listener-host)) service: (or service default-service (remote-listener-service)))))
        (start~ server)
        (if (wait-started~ server error?: #f)
            (set-remote-listener server)
          (error "Unable to start remote listener"))))))


(definition public (stop-remote-listener)
  (when remote-listener
    (stop~ remote-listener)
    (set-remote-listener #f)))


;;;
;;;; Liveliness
;;;


(definition public live-timeout
  0.5)

(definition live-request
  'live?)

(definition live-response
  'alive)


(definition package (remote-proxy-live? remote-proxy)
  (catch (Remote-Connection-Broke exc
           #f)
    (let ((proxy-ior (proxy->ior remote-proxy)))
      (let ((host (get-host~ proxy-ior))
            (service (get-service~ proxy-ior)))
        (when *debug?*
          (terminal '***client*** 'live? (get-ior~ remote-proxy)))
        (let ((port (open-tcp-client (list server-address: host port-number: service))))
          (with-exception-catcher
            (lambda (exc)
              #f)
            (lambda ()
              (parameterize ((send-timeout live-timeout)
                             (receive-timeout live-timeout))
                (send-remote-message live-request port)
                (let ((result (receive-remote-message port)))
                  (close-port port)
                  (eq? result live-response))))))))))


;;;
;;;; Persistence
;;;


(definition *jrm-connections*
  (make-table))


(definition public (get-jrm-connections)
  *jrm-connections*)


(definition public (find-jrm-connection host service)
  (let ((key (list host service)))
    (table-ref *jrm-connections* key #f)))


(definition public (establish-jrm-connection host service)
  (let ((port (open-tcp-client (list server-address: host port-number: service))))
    (dynamic-wind
      (lambda ()
        #f)
      (lambda ()
        (let ((server (require-remote-listener)))
          (let ((local-host (listening-host~ server))
                (local-service (listening-port~ server)))
            (send-remote-message (list 'connect local-host local-service) port))
          (let ((key (list host service)))
            (table-set! *jrm-connections* key port))
          (thread-start! (new-thread (lambda () (process-jrm-messages host service port))
                                     'persistent))
          port))
      (lambda ()
        (unless (find-jrm-connection host service)
          (close-port port))))))


(definition public (terminate-jrm-connection host service)
  (let ((port (find-jrm-connection host service)))
    (close-port port)))


(definition *jrm-invocations*
  (make-table))


;;;
;;;; Client
;;;


(definition public send-timeout
  (make-parameter 2))

(definition public receive-timeout
  (make-parameter 10))


(definition public (post-remote method-name remote-proxy . arguments)
  (invoke-remote 'post method-name remote-proxy arguments))


(definition public (exec-remote method-name remote-proxy . arguments)
  (invoke-remote 'exec method-name remote-proxy arguments))


(definition public (call-remote method-name remote-proxy . arguments)
  (invoke-remote 'call method-name remote-proxy arguments))


@w (new Debuggee-Process-Remote-Proxy {IOR #u8(127 0 0 1) 49895 (module-private jazz.debuggee.stub:Debuggee-Process-Stub) 2 (title: "Uranos" traits: #f icon: #f)} (list title: "Uranos" traits: "<Release>" icon: #f))
@w (call-remote 'get-threads #173)
@w (invoke-jrm-message 'call 'get-threads #173 '())
(definition (invoke-remote kind method-name remote-proxy arguments)
  @w
  (terminal kind method-name remote-proxy arguments)
  @w
  (invoke-remote-old kind method-name remote-proxy arguments)
  (invoke-jrm-message kind method-name remote-proxy arguments))


(definition (invoke-remote-old kind method-name remote-proxy arguments)
  (let ((proxy-ior (proxy->ior remote-proxy)))
    (let ((host (get-host~ proxy-ior))
          (service (get-service~ proxy-ior))
          (cookie (object->serial (current-thread))))
      (when *debug?*
        (terminal '***client*** kind cookie method-name (get-ior~ remote-proxy) (and *debug-arguments?* arguments)))
      (call-with-tcp-client (list server-address: host port-number: service)
        (lambda (port)
          (send-remote-message (list kind cookie method-name proxy-ior arguments) port)
          (case kind
            ((post)
             (unspecified))
            ((exec)
             (when *debug?*
               (terminal '***client*** 'wait method-name))
             (let ((received (receive-remote-message port)))
               (when *debug?*
                 (terminal '***client*** 'received method-name '-> received))
               (bind (err result) received
                 (if err
                     (error "Remote error while executing {s}: {a}" method-name err)
                   (unspecified)))))
            ((call)
             (when *debug?*
               (terminal '***client*** 'wait method-name))
             (let ((received (receive-remote-message port)))
               (when *debug?*
                 (terminal '***client*** 'received method-name '-> received))
               (bind (err result) received
                 (if err
                     (error "Remote error while executing {s}: {a}" method-name err)
                   result))))))))))


(definition (send-remote-message info port)
  (let ((timeout (send-timeout)))
    (when timeout
      (output-port-timeout-set! port timeout throw-remote-connection-broke)))
  (write-port port info))


(definition (receive-remote-message port)
  (let ((timeout (receive-timeout)))
    (when timeout
      (input-port-timeout-set! port timeout)))
  (let ((info (read-port port)))
    (if (eof-object? info)
        (throw-remote-connection-broke)
      info)))


(definition public (invoke-jrm-message kind method-name remote-proxy arguments)
  (let ((proxy-ior (proxy->ior remote-proxy)))
    (let ((host (get-host~ proxy-ior))
          (service (get-service~ proxy-ior)))
      (let ((port (or (find-jrm-connection host service)
                      (establish-jrm-connection host service))))
        (let ((cookie (object->serial (current-thread))))
          (define (skip-to-message)
            (table-set! *jrm-invocations* cookie (list host service))
            (let (iter)
              (let ((message (thread-mailbox-next)))
                ;; mailbox contains 2 types of message:
                ;; (kind cookie method-name result) from process-jrm-messages
                ;; (<thunk> . <continuation-chain>) from post-event et al.
                (cond ((and (pair? message) (symbol? (car message)))
                       (thread-mailbox-extract-and-rewind)
                       message)
                      (else
                       (iter))))))
          
          (define (wait-for-result)
            (when *debug?*
              (terminal '***client*** 'wait method-name))
            (let ((message (skip-to-message)))
              (when *debug?*
                (terminal '***client*** 'read method-name '-> message))
              (bind (kind cookie result) message
                (case kind
                  ((result)
                   result)
                  ((close)
                   (throw-remote-connection-broke))
                  ((error)
                   (error "Remote error while executing {s}: {a}" method-name result))))))
          
          (when *debug?*
            (terminal '***client*** kind cookie method-name (get-ior~ remote-proxy) (and *debug-arguments?* arguments)))
          (send-remote-message (list kind cookie method-name proxy-ior arguments) port)
          (case kind
            ((post)
             (unspecified))
            ((exec)
             (wait-for-result)
             (unspecified))
            ((call)
             (wait-for-result))))))))


;;;
;;;; Server
;;;


(definition (process-jrm-messages host service port)
  (define (wait-read-remote)
    (input-port-timeout-set! port +inf.0)
    (catch (Remote-Connection-Broke exc
             (eof-object))
      (read-port port)))
  
  (define (write-remote info)
    (send-remote-message info port))
  
  (define (dispatch-remote message)
    (bind (kind cookie method-name proxy-ior arguments) message
      (when *debug?*
        (terminal '***server*** kind cookie method-name proxy-ior (and *debug-arguments?* arguments)))
      (let ((local-proxy (ior->proxy proxy-ior)))
        (apply (dispatch (class-of local-proxy) method-name) local-proxy arguments))))
  
  (define (execute-remote message)
    (bind (kind cookie method-name proxy-ior arguments) message
      (define (dispatch-result message)
        (let ((result (dispatch-remote message)))
          (case kind
            ((exec) (list 'result cookie (unspecified)))
            ((call) (list 'result cookie result)))))
      
      (if *debug-locally?*
          (dispatch-result message)
        (continuation-capture
          (lambda (return)
            (with-exception-handler
              (lambda (exc)
                (continuation-capture
                  (lambda (cont)
                    (when *debug?*
                      (terminal '***server*** 'exception method-name)
                      (display-exception exc)
                      (display-continuation-backtrace cont))
                    (continuation-return return (list 'error cookie (exception-reason exc))))))
              (lambda ()
                (dispatch-result message))))))))
  
  (define (invoke-result cookie message)
    (let ((thread (serial->object cookie)))
      (table-clear *jrm-invocations* cookie)
      (thread-send thread message)))
  
  (let (loop)
    (let ((message (wait-read-remote)))
      (if (eof-object? message)
          (let ((key (list host service)))
            (iterate-table-safe *jrm-invocations*
                                (lambda (cookie connection)
                                  (when (equal? connection key)
                                    (invoke-result cookie (list 'close cookie #f)))))
            (table-clear *jrm-connections* key))
        (let ((kind (if (pair? message) (car message) message)))
          (case kind
            ((live?)
             (write-remote live-response))
            ((error result)
             (bind (kind cookie result) message
               (invoke-result cookie message)))
            ((post)
             (thread-start!
               (new-thread (lambda ()
                             (dispatch-remote message))
                           kind)))
            ((exec call)
             (thread-start!
               (new-thread (lambda ()
                             (let ((reply (execute-remote message)))
                               (when *debug?*
                                 (terminal '***server*** reply))
                               (write-remote reply)))
                           kind))))
          (loop))))))


(definition package (process-remote port)
  (define (execute-remote method-name proxy-ior arguments)
    (if *debug-locally?*
        (values #f (dispatch-remote method-name proxy-ior arguments))
      (continuation-capture
        (lambda (return)
          (with-exception-handler
            (lambda (exc)
              (continuation-capture
                (lambda (cont)
                  (when *debug?*
                    (terminal '***server*** 'exception method-name)
                    (display-exception exc)
                    (display-continuation-backtrace cont))
                  (continuation-return return (values (exception-reason exc) #f)))))
            (lambda ()
              (values #f (dispatch-remote method-name proxy-ior arguments))))))))
  
  (define (dispatch-remote method-name proxy-ior arguments)
    (let ((local-proxy (ior->proxy proxy-ior)))
      (apply (dispatch (class-of local-proxy) method-name) local-proxy arguments)))
  
  (let ((message (receive-remote-message port)))
    (let ((kind (if (pair? message) (car message) message)))
      (cond ((eq? kind live-request)
             (send-remote-message live-response port))
            ((eq? kind 'connect)
             (bind (kind host service) message
               (let ((key (list host service)))
                 (table-set! *jrm-connections* key port))
               (process-jrm-messages host service port)))
            (else
             (bind (kind cookie method-name proxy-ior arguments) message
               (when *debug?*
                 (terminal '***server*** kind cookie method-name proxy-ior (and *debug-arguments?* arguments)))
               (case kind
                 ((post)
                  (dispatch-remote method-name proxy-ior arguments))
                 ((exec)
                  (receive (err result) (execute-remote method-name proxy-ior arguments)
                    (when *debug?*
                      (terminal '***server*** 'return cookie method-name err result))
                    (send-remote-message (list err (unspecified)) port)))
                 ((call)
                  (receive (err result) (execute-remote method-name proxy-ior arguments)
                    (when *debug?*
                      (terminal '***server*** 'return cookie method-name err result))
                    (send-remote-message (list err result) port))))))))))

;;;
;;;; IOR
;;;


(definition public (ior? object)
  (is? object IOR))


(definition public (local-ior? ior)
  (let ((server (require-remote-listener)))
    (and (host=? (get-host~ ior) (listening-host~ server))
         (service=? (get-service~ ior) (listening-port~ server)))))


(definition public (ior=? x y)
  (and (host=? (get-host~ x) (get-host~ y))
       (service=? (get-service~ x) (get-service~ y))
       (reference=? (get-reference~ x) (get-reference~ y))))


(definition public (ior-server=? x y)
  (and (host=? (get-host~ x) (get-host~ y))
       (service=? (get-service~ x) (get-service~ y))))


(definition public (host=? x y)
  (equal? x y))


(definition public (service=? x y)
  (eqv? x y))


(definition public (reference=? x y)
  (eqv? x y))


(definition public (ior->proxy ior)
  (define (local->proxy stub-interface ior)
    (define (reference->local-proxy stub-interface reference)
      (if (not reference)
          (get-local-register)
        (new (local-class~ stub-interface) (serial->object reference))))
    
    (reference->local-proxy stub-interface (get-reference~ ior)))
  
  (define (remote->proxy stub-interface ior)
    (let ((remote-class (remote-class~ stub-interface)))
      (new remote-class ior (get-values~ ior))))
  
  (let ((stub-interface (resolve-runtime-reference (deserialize-runtime-reference (get-stub-interface~ ior)))))
    (if (local-ior? ior)
        (local->proxy stub-interface ior)
      (remote->proxy stub-interface ior))))


;;;
;;;; Proxy
;;;


(definition public (proxy? object)
  (is? object Proxy))


(definition public (proxy=? x y)
  (cond ((and (remote-proxy? x) (remote-proxy? y))
         (remote-proxy=? x y))
        ((and (local-proxy? x) (local-proxy? y))
         (local-proxy=? x y))
        (else
         #f)))


(definition public (proxy-server=? x y)
  (cond ((and (remote-proxy? x) (remote-proxy? y))
         (ior-server=? (get-ior~ x)
                       (get-ior~ y)))
        ((and (local-proxy? x) (local-proxy? y))
         #t)
        (else
         #f)))


(definition public (proxy->ior proxy)
  (define (local->ior local-proxy)
    (define (local-proxy->reference local-proxy)
      (if (proxy=? local-proxy (get-local-register))
          #f
        (let ((object (get-object~ local-proxy)))
          (gc-protect object)
          (object->serial object))))
    
    (let ((server (require-remote-listener)))
      (new IOR
        (listening-host~ server)
        (listening-port~ server)
        (serialize-runtime-reference (stub-reference~ local-proxy))
        (local-proxy->reference local-proxy)
        (proxy-values~ local-proxy))))
  
  (define (remote->ior proxy)
    (get-ior~ proxy))
  
  (if (remote-proxy? proxy)
      (remote->ior proxy)
    (local->ior proxy)))


;;;
;;;; Local Proxy
;;;


(definition public (local-proxy? object)
  (is? object Local-Proxy))


(definition public (local-proxy=? x y)
  (eq? (get-object~ x)
       (get-object~ y)))


;;;
;;;; Remote Proxy
;;;


(definition public (remote-proxy? object)
  (is? object Remote-Proxy))


(definition public (remote-proxy=? x y)
  (ior=? (get-ior~ x)
         (get-ior~ y)))


;;;
;;;; Register
;;;


(definition *local-register*
  #f)


(definition public (get-local-register)
  (when (not *local-register*)
    (set! *local-register* (new-local-proxy~ Register)))
  *local-register*)


(definition public (get-remote-register remote-proxy)
  (let ((ior (get-ior~ remote-proxy)))
    (new-remote-register (get-host~ ior) (get-service~ ior))))


(definition public (new-remote-register host port)
  (ior->proxy (new IOR host port (serialize-runtime-reference (reference Register-Stub)) #f '())))


;;;
;;;; GC
;;;


;; Need to think about how the objects should be GC protected
;; One possible approach is to use a refcounted table of shared
;; objects. For this we need to always use IOR, e.g. wrap
;; serial numbers in IOR and define a will on IOR that calls
;; the IOR's ownwer process to release the object's refcount


(definition *Mega-Patch*
  '())


(definition public (gc-protect obj)
  (set! *Mega-Patch* (cons obj *Mega-Patch*)))


;;;
;;;; Marshall
;;;


(definition protected (marshall-local-proxy proxy)
  (define (local-proxy->reference)
    (if (proxy=? proxy (get-local-register))
        #f
      (let ((object (get-object~ proxy)))
        (gc-protect object)
        (object->serial object))))
  
  (let ((server (require-remote-listener)))
    (let ((ior
            (new IOR
              (listening-host~ server)
              (listening-port~ server)
              (serialize-runtime-reference (stub-reference~ proxy))
              (local-proxy->reference)
              (proxy-values~ proxy))))
      (serialize-object (class-of proxy) (encode-ior ior)))))


(definition protected (marshall-remote-proxy proxy)
  (serialize-object (class-of proxy) (encode-ior (get-ior~ proxy))))


(definition (encode-ior ior)
  (vector (get-host~ ior)
          (get-service~ ior)
          (get-stub-interface~ ior)
          (get-reference~ ior)
          (get-values~ ior)))


;;;
;;;; Unmarshall
;;;


(definition protected (unmarshall-proxy content)
  (ior->proxy (decode-ior content)))


(definition (decode-ior content)
  (new IOR
    (vector-ref content 0)
    (vector-ref content 1)
    (vector-ref content 2)
    (vector-ref content 3)
    (vector-ref content 4)))


;;;
;;;; Protocol
;;;


(definition public *jazz-code*
  (code-string->32-bit-integer "JAZZ"))

(definition public *jazz-version*
  {Version 1 0 0})


(definition (write-port port info)
  (with-communication
    (lambda ()
      (write-header *jazz-code* *jazz-version* port)
      (write-data info port)
      (force-output port))))


(definition (read-port port)
  (with-communication
    (lambda ()
      (receive (application-code client-version) (read-header port)
        ;;(validate-application-code application-code)
        (read-data port))))))
