;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Library
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.library jazz


(export (jazz.library.autoload)
        (jazz.library.syntax))

(import (jazz.library.autoload)
        (jazz.io)
        (time))


;;;
;;;; Form
;;;


(define *forms*
  (make-table test: eq?))


(definition public (register-form name form)
  (table-set! *forms* name form))

(definition public (unregister-form name)
  (table-clear *forms* name))

(definition public (registered-form name)
  (table-ref *forms* name #f))


(definition public (load-form name)
  (or (registered-form name)
      (error "Unable to load form: {s}" name)))


(definition public (resolve-form name/form)
  (if (is? name/form Form)
      name/form
    (bind (name . path) (split-symbol name/form "/")
      (let ((form (load-form name)))
        (if (null? path)
            form
          (child~ form path))))))


;;;
;;;; Trait
;;;


(define *traits*
  (make-table test: eq?))


(definition public (register-trait name trait)
  (table-set! *traits* name trait))

(definition public (unregister-trait name)
  (table-clear *traits* name))

(definition public (registered-trait name)
  (table-ref *traits* name #f))


(definition public (load-trait name)
  (or (registered-trait name)
      (error "Unable to load trait: {s}" name)))


(definition public (resolve-trait name/trait)
  (if (is? name/trait Trait)
      name/trait
    (bind (name . path) (split-symbol name/trait "/")
      (let ((trait (registered-trait name)))
        (if trait
            (if (null? path)
                trait
              (child~ trait path))
          (let ((form (registered-form name)))
            (if form
                (assert (not-null? path)
                  ;; quicky to test
                  (let ((component (instantiate~ form)))
                    (child~ component path)))
              (error "Unable to load trait: {s}" name))))))))


;;;
;;;; Version
;;;


(definition public (32-bit-integer->version version)
  (let ((major (quotient version 100000))
        (minor (modulo (quotient version 1000) 100))
        (revision (modulo version 1000)))
    (new Version major minor revision)))


;;;
;;;; System
;;;


(definition public (find-process)
  ((module-ref 'jazz.system 'get-process)))


(definition public (find-application)
  ((module-ref 'jazz.system 'get-application)))


;;;
;;;; Resource
;;;


(definition public inline (resource? object)
  (is? object Resource))


;;;
;;;; Execution
;;;


(definition public undocumented (with-execution-context proc (title: title #f) (details: details '()) (reporter: reporter #f))
  (proc)
  ;; to convert
  @unimp
  (with ((context (new Execution-Context title: title details: details reporter: reporter)))
    (proc)))


(definition public undocumented (with-execution-node proc (title: title #f) (details: details '()) (reporter: reporter #f))
  (proc)
  ;; to convert
  @unimp
  (with ((node (new Execution-Node title: title details: details reporter: reporter)))
    (proc)))


(definition public undocumented (get-execution-context)
  (unimplemented 'get-execution-context)
  @active-thread
  (let ((thread (current-thread)))
    (get-active-context~ thread)))


(definition public undocumented (get-execution-stack)
  (unimplemented 'get-execution-stack)
  @active-thread
  (let* ((thread (current-thread))
         (node (get-active-node~ thread))
         (lst '()))
    (while node
      (set! lst (cons node lst))
      (set! node (and (is-not? node Execution-Context) (get-previous-node~ node))))
    lst))

@unimplemented
(class Execution-Node extends Object
  
  
  (slot title)
  (slot details)
  (slot reporter)
  (slot previous-node)
  
  
  (definition (initialize (title: title #f) (details: details '()) (reporter: reporter #f))
    (nextmethod)
    (set! title~self title)
    (set! details~self details)
    (set! reporter~self reporter)
    (let ((thread (current-thread)))
      (set! previous-node~self (get-active-node~ thread))
      (set-active-node~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (current-thread)))
      (set-active-node~ thread previous-node))
    (nextmethod))
  
  
  (definition public (get-title)
    title)
  
  
  (definition public (get-details)
    details)
  
  
  (definition public (get-reporter)
    reporter))

@unimplemented
(class Execution-Context extends Execution-Node
  
  
  (slot previous-context)
  (slot continuable?     initialize #f)
  (slot auto-continue?   initialize #f)
  
  
  (definition (initialize . rest)
    (apply nextmethod rest)
    (let ((thread (current-thread)))
      (set! previous-context~self (get-active-context~ thread))
      (set-active-context~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (current-thread)))
      (set-active-context~ thread previous-context))
    (nextmethod))
  
  
  (definition public (get-continuable?)
    continuable?)
  
  
  (definition public (set-continuable? value)
    (set! continuable? value))
  
  
  (definition public (get-auto-continue?)
    auto-continue?)
  
  
  (definition public (set-auto-continue? value)
    (set! auto-continue? value)))


;;;
;;;; Continue
;;;


@convert
(definition public (with-continue proc)
  (unimplemented 'with-continue)
  @call-cc?
  (let ((context (get-execution-context)))
    (if (not context)
        (error "Registering a continuable error outside an execution context is not allowed")
      (let ((preserved (get-continuable?~ context)))
        (unwind-protect
            (begin
              (set-continuable?~ context #t)
              (catch Continue
                (proc)))
          (set-continuable?~ context preserved))))))


@convert
(definition public (continuable? exception)
  (unimplemented 'continuable?)
  @call-cc?
  (let ((context (get-execution-context)))
    (and context (get-continuable?~ context))))


@convert
(definition public (continue-exception exception)
  (unimplemented 'continue)
  @call-cc
  (throw (new Continue)))


;;;
;;;; Restart
;;;


@convert
(definition public Restartable?
  #f)


@convert
(definition public (with-restart proc (cleanup #f))
  (unimplemented 'with-restart)
  @call-cc?
  (let ((preserved Restartable?))
    (unwind-protect
        (begin
          (set! Restartable? #t)
          (while #t
            (catch Restart
              (proc)
              (return))
            (when cleanup
              (cleanup))))
      (set! Restartable? preserved))))


@convert
(definition public (restartable? exception)
  Restartable?)


@convert
(definition public (restart (exception #f))
  (unimplemented 'restart)
  @call-cc?
  (throw (new Restart)))


;;;
;;;; Time
;;;


(definition public (different-times? time1 time2 (tolerance: tolerance 2))
  (> (abs (- (time->seconds time1) (time->seconds time2)))
     tolerance))


(definition public (different-file-content? file1 file2)
  (define (different-text-file-content? file1 file2)
    (not (equal? (load-lines~ file1 char-encoding-errors: #f)
                 (load-lines~ file2 char-encoding-errors: #f))))
  
  (if (and (member? (get-extension~ file1) Text-Extensions test: ci=?)
           (member? (get-extension~ file2) Text-Extensions test: ci=?))
      (different-text-file-content? file1 file2)
    (call-with-input-file (parse~ file1)
      (lambda (input1)
        (call-with-input-file (parse~ file2)
          (lambda (input2)
            (or @convert
                (/= (get-size~ input1)
                    (get-size~ input2))
                (let (iterate)
                  (let ((u1 (read-u8 input1))
                        (u2 (read-u8 input2)))
                    (cond ((and (eof-object? u1)
                                (eof-object? u2))
                           #f)
                          ((eqv? u1 u2)
                           (iterate))
                          (else
                           #t)))))))))))


(definition public (different-file-content-no-whitespace? file1 file2)
  (call-with-input-file (list path: (parse~ file1) char-encoding: 'UTF char-encoding-errors: #f)
    (lambda (input1)
      (call-with-input-file (list path: (parse~ file2) char-encoding: 'UTF char-encoding-errors: #f)
        (lambda (input2)
          (not (wi= (read-content-string input1)
                    (read-content-string input2))))))))


;;;
;;;; Designer
;;;


;; quick support for the designer until we find a clean solution
(definition public designing?
  (make-parameter #f))


;;;
;;;; Descriptors
;;;


(definition Class-Descriptors
  (make-table test: eq?))


(definition public undocumented (get-descriptor model)
  (let ((name (category-identifier model)))
    (or (table-ref Class-Descriptors name #f)
        (let ((form (get-class-descriptor~ model)))
          (when form
            (let ((descriptor (if (is? form Form) (instantiate~ form) form)))
              (set-name~ descriptor name)
              (table-set! Class-Descriptors name descriptor)
              descriptor))))))


(definition public undocumented (get-properties-descriptor model)
  (let ((class-descriptor (get-descriptor model)))
    (when class-descriptor
      (find-component~ class-descriptor 'properties))))


(definition public undocumented (get-property-descriptor model name)
  (let ((properties-descriptor (get-properties-descriptor model)))
    (when properties-descriptor
      (find-component~ properties-descriptor name))))


;;;
;;;; Tabulated
;;;


(definition public undocumented (display-tabulated data printer)
  (unimplemented 'display-tabulated)
  @Column-Display-Display-Column
  (let* ((display (new Columns-Display))
         (sample (car data))
         (last (- (length sample) 1))
         (columns (loop (for ignore in sample)
                        (for n from 0)
                        (collect (if (= n last)
                                     (new Display-Column display)
                                   (new Aligned-Column display border-after: 1 alignment: 'left))))))
    (add-columns~ display columns)
    (for-each (lambda (row)
                (for-each (lambda (object column)
                            (output~ column (->string object)))
                          row
                          columns)
                (newline~ display))
              data)
    (print-to~ display printer))))
