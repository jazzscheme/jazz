;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Component
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.library.component.Component jazz


(import (jazz.designer)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.locale))


(class Component extends Object implements Event-Consumer
  
  
  ;; prepare      -> before the form gets installed
  ;; install      -> installs the class form and sets installed? -> #t
  ;; finish       -> before form structure from a containing form gets installed and sets finished? -> #t
  ;; conclude     -> after all initialization done, but before calling show
  
  
  (definition Installed-Flag    #x00000001)
  (definition Finished-Flag     #x00000002)
  (definition Initialized-Flag  #x00000004)
  (definition Visible-Flag      #x00000008)
  (definition Destroying-Flag   #x00000020)
  (definition Destroyed-Flag    #x00000040)
  (definition Layout-Valid-Flag #x00000100)
  
  
  (slot name                         initialize #f)
  (slot parent                       initialize #f)
  (slot traits                       initialize #f)
  (slot branch                       initialize #f)   ;; the immediatly installed branch
  (slot form                         initialize #f)   ;; the form that created the component
  (slot creator                      initialize #f)   ;; the root component of the class form (used for indexing and as inner class instantiation context)
  (slot creator-branch               initialize #f)   ;; the branch that created the component (#f if none)
  (slot event-consumer               initialize self)
  (slot designers                    initialize '())
  (slot surrogate                    initialize #f accessors generate)
  (slot index                        initialize #f)
  (slot flags                 <fx>   initialize Visible-Flag)
  
  
  (property before                   initialize #f  accessors explicit)
  (property children                 initialize '() accessors explicit)
  (property visible?          <void>                accessors explicit)
  (property class-info        <void>                getter get-class-info)
  (property name-info         <void>                getter get-name-info)
  (property presentation-info <void>                getter get-presentation-info)
  

  ;;;
  ;;;; Access
  ;;;
  
  
  (method public inline (get-name)
    name)
  
  
  (method public inline (set-name value)
    (set! name value))
  
  
  (method public inline (get-parent)
    parent)
  
  
  (method public virtual (set-parent value)
    (when parent
      (remove-child~ parent self))
    (set! parent value)
    (when parent
      (install-in-parent)))


  (method public inline (get-before)
    before)


  (method public (set-before value)
    (set! before value)
    (when (get-finished?)
      (send-child-before~ parent self (child~ parent before))))
  
  
  (method public inline (get-children)
    children)
  
  
  (method public virtual (set-children lst <Sequence>)
    (set! children '())
    (loop (for child in lst)
          (do (set-parent~ child self))))
  
  
  (method public inline (get-branch)
    branch)
  
  
  (method public inline (set-branch value)
    (set! branch value))


  (method public inline (get-form)
    form)
  
  
  (method public inline (set-form value)
    (set! form value))


  (method public inline (get-creator)
    creator)
  
  
  (method public inline (set-creator value)
    (set! creator value))


  (method public inline (get-creator-branch)
    creator-branch)
  
  
  (method public inline (set-creator-branch value)
    (set! creator-branch value))
  
  
  (method (get-class-info)
    (get-class-presentation~ (class-of self)))


  (method meta virtual (get-class-form)
    #f)


  (method meta virtual (get-class-forms)
    '())
  
  
  (method (get-name-info)
    (if (not name)
        "{}"
      (->string name)))
  
  
  (method (get-presentation-info)
    (get-presentation-property))


  ;;;
  ;;;; Flags
  ;;;
  
  
  (method protected (get-installed?)
    (mask-bit-set? flags Installed-Flag))
  
  (method protected (set-installed? flag <bool>)
    (set! flags (mask-bit-set flags Installed-Flag flag)))
  
  
  (method protected (get-finished?)
    (mask-bit-set? flags Finished-Flag))
  
  (method (set-finished? flag <bool>)
    (set! flags (mask-bit-set flags Finished-Flag flag)))
  
  
  (method protected (get-initialized?)
    (mask-bit-set? flags Initialized-Flag))
  
  (method (set-initialized? flag <bool>)
    (set! flags (mask-bit-set flags Initialized-Flag flag)))
    
  
  (method public (get-visible-flag)
    (mask-bit-set? flags Visible-Flag))
  
  (method public (set-visible-flag flag <bool>)
    (set! flags (mask-bit-set flags Visible-Flag flag)))

  
  (method (get-destroying?)
    (mask-bit-set? flags Destroying-Flag))
  
  (method (set-destroying? flag <bool>)
    (set! flags (mask-bit-set flags Destroying-Flag flag)))

  
  (method (get-destroyed?)
    (mask-bit-set? flags Destroyed-Flag))
  
  (method (set-destroyed? flag <bool>)
    (set! flags (mask-bit-set flags Destroyed-Flag flag)))

  
  (method (get-layout-valid?)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  (method (set-layout-valid? flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))


  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (call-print output detail)
    (if (get-initialized?)
        (print output detail)
      (print-unreadable self output
        (lambda (output)
          ))))

  
  (method override (print printer readably)
    (print-unreadable self printer
      (lambda (printer)
        (format printer "{a}" name))))


  ;;;
  ;;;; Initialization
  ;;;


  (method override (initialize . rest)
    (nextmethod)
    (initialize-component rest))
  
  
  (method protected virtual (initialize-component rest)
    (prepare rest)
    (install rest)
    (set-installed? #t)
    (finish rest)
    (install-in-parent)
    (set-finished? #t)
    (conclude rest)
    (set-initialized? #t)
    (let ((visible? (get-visible?)))
      (when (neq? visible? (initially-visible?))
        (if visible?
            (show)
          (hide)))))


  (method protected virtual (default-name)
    #f)


  (method protected virtual (default-parent)
    #f)
  
  
  (method protected virtual (setup-parent)
    )


  (method protected chained (prepare initargs <Object>)
    (define (prepare-parent)
      (let ((arg (getf initargs parent: not-found: #f)))
        (set! parent (if (not arg) (default-parent) arg))
        (setup-parent)))
    
    (define (prepare-component)
      (set-name (or (getf initargs name:) (default-name)))
      (set-form (or (getf initargs form:) (get-class-form~ (class-of self))))
      (set-creator (getf initargs creator:))
      (set-creator-branch (getf initargs creator-branch:)))
    
    (prepare-parent)
    (prepare-component))


  (method protected chained (install initargs <Object>)
    (define (install-component)
      (install-inherited (get-class-forms~ (class-of self))))
    
    (define (install-inherited forms)
      (when (not-null? forms)
        (install-inherited (cdr forms))
        (install-form (car forms) self #f #f)))
    
    (install-component))
  
  
  (method (install-traits initargs)
    (let ((traits (or (getf initargs 'traits) (getf initargs traits:))))
      (when traits
        (set-active-traits (listify traits)))))
  
  
  (method public (install-form form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (when form
      (install-traits (get-properties~ form))
      (install-properties (get-properties~ form) restore-form)
      (install-children (get-children~ form) creator creator-branch restore-form)))
  
  
  (method protected virtual (install-children children <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (loop (for child in children)
          (do (install-child child creator creator-branch restore-form))))
  
  
  (method public virtual (install-child form <Object> creator <Object> creator-branch <Object> restore-form <Object>)
    (let ((action (get-action~ form))
          (name (get-name~ form)))
      (define (new-component)
        (let ((reference (get-tag-reference~ form)))
          (if (and (eq? action 'instantiate) (file? reference))
              (let ((child (instantiate-file reference parent: self name: name form: form creator: creator creator-branch: creator-branch)))
                (set-form~ child form)
                child)
            (let ((model (if reference (module-ref reference (get-model~ form)) (form-model~ (or creator self) form))))
              (if model
                  (new model parent: self name: name form: form creator: creator creator-branch: creator-branch)
                (error "Unable to resolve model: {s}" (get-model~ form)))))))
      
      (case action
        ((new instantiate)
         (let ((component (new-component)))
           (when creator
             (add-to-index~ creator (get-name~ component) component))
           (when restore-form
             (remember-creation~ restore-form self component))))
        ((modify locate)
         (when restore-form
           (set! restore-form (remember-reference~ restore-form self name)))
         (install-form~ (find-to-modify name equal?) form creator creator-branch restore-form))
        ((remove)
         (let ((child (get-component~ form)))
           (close~ child)))
        (else
         (error "Unknown form action: {t} in {t}" action form)))))
  

  (method (install-properties properties <Object> restore-form <Object>)
    (while (not-null? properties)
      (let ((expr (car properties))
            (value (cadr properties)))
        (unless (initer-property? expr)
          (when (symbol? expr)
            (set! expr (component-property (class-of self) expr))
            (set-car! properties expr))
          (when restore-form
            (remember-property~ restore-form self expr))
          (write-property-to self expr value)))
      (set! properties (cddr properties))))
  
  
  (method public virtual (find-to-modify name <Object> test <procedure>)
    (or (find-component-with name test)
        (locate name)))
  
  
  ;; This is a very poor version of automatically being able to override subform classes.
  ;; For now, it will have to do because a clean efficient solution completely eludes me!
  (method public virtual (form-model form <Form>)
    (resolve-model~ form))


  (method protected chained (finish initargs <Object>)
    (bind-keywords ((form #f) (creator #f) . others) initargs
      (when form
        ;; setting the creator to #t is a service for Form instantiate
        (if (neq? creator #t)
            (install-form form creator #f #f)
          (install-form form self #f #f)
          (set! creator~self self)))
      (install-traits initargs)
      (write-properties initargs)))
  
  
  (method public (write-properties properties <Object>)
    (define (write-initarg-to object <Object> property <Object> value <Object>)
      (let ((property-name (keyword->symbol property)))
        (unless (initer-property? property-name)
          (write-property-to object (component-property (class-of object) property-name) value))))
    
    (loop (for (property value) in-properties properties)
          (do (write-initarg-to self property value))))
  
  
  ;; Only done after the component is fully initialized so as not to install
  ;; an invalid component should an error occur during the initialization phase.
  (method protected virtual (install-in-parent)
    (when parent
      (let ((designers (get-designers~ parent)))
        (when (not-null? designers)
          (set-designers designers)))
      (let ((surrogate (get-surrogate~ parent)))
        (when surrogate
          (remove-surrogate)
          (install-surrogate (get-editor~ surrogate)))))
    (parent-add-child))
  
  
  (method public (parent-add-child)
    (when parent
      (add-child~ parent self)))


  (method protected chained (conclude initargs <Object>)
    )


  (method override (initialized?)
    (get-initialized?))


  ;;;
  ;;;; Destruction
  ;;;


  (method override (destroying?)
    (get-destroying?))


  (method override (destroyed?)
    (get-destroyed?))


  (method override (close)
    (unless (destroyed?)
      (destroy-component)))


  ;; called before children are destroyed
  (method chained (destroy-component)
    (set-destroying? #t)
    (for-each (lambda (child)
                (when (is? child Component)
                  (destroy-component~ child)))
              children)
    (destroy)
    (set-destroyed? #t))
  
  
  ;; called after children are destroyed
  (method override (destroy)
    (when parent
      (remove-child~ parent self))
    (when creator
      (remove-from-index~ creator name self))
    (nextmethod))
  
  
  (method public (close-children)
    (for-each close~ children))
  
  
  (method public virtual (confirm-close . rest)
    #t)


  ;;;
  ;;;; Visibility
  ;;;


  (method public virtual (initially-visible?)
    #t)


  (method public virtual (get-visible?)
    (get-visible-flag))
  
  
  (method public virtual (set-visible? flag <bool>)
    (if (not (get-finished?))
        (set-visible-flag flag)
      (when (neq? (get-visible-flag) flag)
        (if flag
            (show)
          (hide)))))
  
  
  (method public virtual (show)
    (set-visible-flag #t))
  
  
  (method public virtual (hide)
    (set-visible-flag #f))


  ;;;
  ;;;; Properties
  ;;;
  
  
  (definition initer-properties
    (list->table
      '((name . #t)
        (parent . #t)
        (traits . #t)
        (form . #t)
        (creator . #t)
        (creator-branch . #t))))
  
  
  (method chained (initer-property? name)
    (table-ref initer-properties name #f))
  
  
  (method meta public (get-properties)
    (collect-if (lambda (property)
                  (and (property? property)
                       (property-getter property)))
                (get-instance-slots~ self)))
  
  
  (method (component-property category <Object> name <Object>)
    (let ((field (mop-category-field~ category name)))
      (if (property? field)
          field
        (error "Unknown property: {t}" name))))


  (definition (write-property-to object <Object> property <Object> value <Object>)
    (let ((setter (property-setter property)))
      (if setter
          (setter object value)
        (error "Property {s} has no setter" property))))
  
  
  (method public (get-filtered-properties (filter: filter 'categorized))
    (define (get-all-properties filter)
      (sort (lambda (x y)
              (let ((xr (get-rank~ (get-category~ (class-of self) x)))
                    (yr (get-rank~ (get-category~ (class-of self) y))))
                (or (< xr yr)
                    (and (= xr yr)
                         (string<? (symbol->string (field-name x)) (symbol->string (field-name y)))))))
            (collect-if (lambda (property)
                          (display-filtered-property? property filter))
                        (mop-instance-slots~ (class-of self) self))))
    
    (define (display-filtered-property? property filter)
      (and (property? property)
           (property-getter property)
           (or (memq? filter '(all categorized))
               (let ((name (get-name~ (get-category~ (class-of self) property))))
                 (if (symbol? filter)
                     (eq? name filter)
                   (memq? name filter))))
           (display-property? property)))
    
    (if (eq? filter 'categorized)
        (let ((properties (get-categorized-properties)))
          (if (eq? properties #t)
              (get-all-properties '(infos properties))
            (let ((class (class-of self)))
              (letrec ((standardize
                         (lambda (object)
                           (cond ((string? object)
                                  object)
                                 ((symbol? object)
                                  (or (category-field class object)
                                      (error "Field {t} is undefined in {t}" object class)))
                                 (else
                                  (map standardize object))))))
                (standardize properties)))))
      (get-all-properties filter)))


  ;;;
  ;;;; Children
  ;;;


  (method public (name? object <Object>)
    (or (symbol? object)
        (integer? object)
        (null? object)
        (pair? object)))


  (method public virtual (add-child child <Object>)
    (let ((before (and (is? child Component) (get-before~ child))))
      (if (not before)
          (set! children (append! children (list child)))
        (send-child-before child (find-component before)))))
  
  
  (method public (add-child-at child <Object> rank <Integer+>)
    (set! children (insert! children rank child)))
  
  
  (method public (append-child child <Object>)
    (set! children (append! children (list child))))


  (method public virtual (remove-child child <Object>)
    (set! children (remove! child children)))
    
  
  (method public virtual (replace-child rank <fx> replacement <Object>)
    (let ((child (element children rank)))
      (set-parent~ replacement self)
      (set-parent~ child #f)
      (set! children (insert! (remove! replacement children) rank replacement))))
  
  
  (method public virtual (front-child? child)
    (eq? child (first children)))
  
  
  (method public virtual (back-child? child)
    (eq? child (last children)))


  (method public virtual (send-child-to-front child <Object>)
    (set! children (move-to-head! child children)))


  (method public virtual (send-child-to-back child <Object>)
    (set! children (move-to-tail! child children)))
  
  
  (method public (send-child-before child <Object> target)
    (let* ((removed (remove! child children))
           (rank (and target (or (find removed target) (error "Unable to find: {t}" target)))))
      (set! children (insert! removed rank child))))
  
  
  (method public (child name <Object>)
    (or (find-component name)
        (error "Could not find child {t}" name)))
  
  
  (method public (find-component name <Object>)
    (find-component-with name equal?))
  
  
  (method public (find-component-with name <Object> test <procedure>)
    (cond ((null? name)
           (error "Invalid location: {t}" name))
          ((integer? name)
           (if (= name 0)
               self
             (find-component~ parent (- name 1))))
          ((pair? name)
           (let ((sub (find-component (car name))))
             (when sub
               (let ((next (cdr name)))
                 (if (null? next)
                     sub
                   (find-component~ sub next))))))
          (else
           (or (component-alias name)
               (find-child-with name test)))))
  
  
  (method public (brother name <Object>)
    (child~ parent name))
  
  
  (method public (next-brother (type: type #f))
    (if (not parent)
        self
      (next-child~ parent self type: type)))
  
  
  (method public (previous-brother (type: type #f))
    (if (not parent)
        self
      (previous-child~ parent self type: type)))
  
  
  (method public (child-ranked rank <fx>)
    (element children rank))
  
  
  (method public virtual (component-alias name <Object>)
    (case name
      ((:self) self)
      ((:parent) parent)
      ((:creator) creator)
      (else (let ((process (find-process)))
              (when process
                (process-alias~ process name))))))


  (method public (find-child name <Object>)
    (find-if (lambda (child)
               (equal? (get-name~ child) name))
             children))


  (method public (find-child-with name <Object> test <procedure>)
    (find-if (lambda (child)
               (test (get-name~ child) name))
             children))


  (method public (find-type type)
    (find-if (lambda (child)
               (is? child type))
             children))
  
  
  (method public (find-key key value)
    (find-if (lambda (child)
               (equal? (key child) value))
             children))
  
  
  (method public (find-ascendant type)
    (let ((parent (get-parent)))
      (while (and parent (is-not? parent type))
        (set! parent (get-parent~ parent)))
      parent))
  
  
  (method public (find-descendant predicate)
    (continuation-capture
      (lambda (return)
        (for-each-descendant
          (lambda (component level)
            (when (predicate component)
              (continuation-return return component))))
        #f)))
  
  
  (method public (collect-ascendants (type #f))
    (let ((ascendants '())
          (parent (get-parent)))
      (while (and parent (or (not type) (is-not? parent type)))
        (set! ascendants (cons parent ascendants))
        (set! parent (get-parent~ parent)))
      (if (or (not parent) (and type (is? parent type)))
          ascendants
        (cons parent ascendants))))
  
  
  (method public (child-rank child <Object>)
    (find children child))
  
  
  (method public (get-brothers)
    (when parent
      (remove self (get-children~ parent))))
  
  
  (method public (has-parent? component <Component>)
    (and parent (or (eq? parent component) (has-parent?~ parent component))))
  
  
  (method public (has-ascendant? component <Component>)
    (or (eq? self component) (has-parent? component)))
  
  
  (method public (get-root-parent)
    (if (not parent)
        self
      (get-root-parent~ parent)))
  
  
  (method public (get-visible-children)
    (collect-if get-visible?~ children))
  
  
  (method public (first-visible-child)
    (let ((visible (get-visible-children)))
      (if (null? visible)
          #f
        (car visible))))
  
  
  (method public (get-ancestry root)
    (let ((ancestry '())
          (scan self))
      (while (neq? scan root)
        (set! ancestry (cons scan ancestry))
        (set! scan (get-parent~ scan))
        (when (null? scan)
          (error "{t} is not a descendant of the root component {t}" self root)))
      ancestry))


  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (for-each-parent proc <procedure>)
    (when parent
      (proc parent)
      (for-each-parent~ parent proc)))
  
  
  (method public (for-each-ascendant proc <procedure>)
    (proc self)
    (for-each-parent proc))
  
  
  (method public (for-each-descendant proc <procedure> (include-self?: include-self? #t) (stop-test: stop-test #f))
    (when include-self?
      (proc self 0))
    (let (iter (component self)
                  (level 1))
      (loop (for child in (get-children~ component))
            (proc child level)
            (unless (and stop-test (stop-test child))
              (iter child (+ level 1))))))
  
  
  (method public (for-each-sibling proc <procedure>)
    (loop (for child in (get-children~ parent))
          (when (neq? child self)
            (proc child))))


  (method public (collect-family)
    (let ((factory (new List-Factory)))
      (for-each-descendant
        (lambda (child . rest)
          (put~ factory child)))
      (get-output~ factory)))
  
  
  ;;;
  ;;;; Outer
  ;;;
  
  
  (method public (outer-component limit)
    (let ((outer parent)
          (component self))
      (while (and outer (inner?~ outer component) (neq? component limit))
        (set! component outer)
        (set! outer (get-parent~ outer)))
      component))
  
  
  (method public virtual (inner? component)
    #f)
  
  
  ;;;
  ;;;; Form
  ;;;
  
  
  (method public virtual (add-form parent-form <Form> child-form <Form>)
    (append-parent~ child-form parent-form))


  ;;;
  ;;;; Index
  ;;;
  
  
  (method public virtual (add-to-index name <Object> component <Component>)
    (when name
      (when (not index)
        (set! index (new-index)))
      (if (table-ref index name #f)
          (table-set! index name #t)
        (table-set! index name component))))
  
  
  (method public virtual (remove-from-index name <Object> component <Component>)
    (when (and name index)
      (table-clear index name)))
  
  
  (method protected virtual (new-index)
    (make-table test: eq?))
  
  
  (method public virtual (locate name <Object>)
    (let ((component (locate-component name)))
      (cond ((not component) (error "Unable to locate {t}" name))
            ((eq? #t component) (error "Ambigious name: {t}" name))
            (else component))))
  
  
  (method public (locate-component name <Object>)
    (cond ((pair? name)
           (let ((sub (locate-component (car name))))
             (when sub
               (let ((next (cdr name)))
                 (if (null? next)
                     sub
                   (locate-component~ sub next))))))
          (else
           (and index (table-ref index name #f)))))


  ;;;
  ;;;; Database
  ;;;
  
  
  (method public (get-database-component)
    (get-root-parent))


  ;;;
  ;;;; Consumer
  ;;;
  

  (method override (get-event-consumer)
    event-consumer)
  
  
  (method override (set-event-consumer consumer <Event-Consumer>)
    (set! event-consumer consumer))


  (method override (deliver-event handler target proc event)
    (proc target event))


  ;;;
  ;;;; Layering
  ;;;
  
  
  (method public (first-child)
    (if (null? children)
        #f
      (car children)))
  
  
  (method public (last-child)
    (last children))
  
  
  (method public (next-child child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (+ rank 1) (length children))))))
  
  
  (method public (previous-child child (type: type #f))
    (let ((children (if type (collect-type type children) children)))
      (let ((rank (find children child)))
        (element children (modulo (- rank 1) (length children))))))
  
  
  (method public (front?)
    (or (not parent) (front-child?~ parent self)))
  
  
  (method public (back?)
    (or (not parent) (back-child?~ parent self)))
  
  
  (method public virtual (bring-to-front)
    (when parent
      (send-child-to-front~ parent self)))
  
  
  (method public virtual (send-to-back)
    (when parent
      (send-child-to-back~ parent self)))
  
  
  (method public virtual (send-before target)
    (when parent
      (send-child-before~ parent self target)))


  ;;;
  ;;;; Traits
  ;;;
  
  
  (method public (get-traits)
    traits)
  
  
  (method public (set-traits value)
    (set! traits (listify value))
    (set-active-traits traits))
  
  
  (method public (child-traits)
    (collect-type Trait children))


  ;;;
  ;;;; Branches
  ;;;
  
  
  (method public (branch-installed?)
    branch)
  
  
  (method public (get-active-branch)
    (if (not branch)
        #f
      (let (iterate (branch branch))
        (if (get-branch~ branch)
            (iterate (get-branch~ branch))
          branch))))
  
  
  (method public (get-active-trait-name)
    (let ((trait (get-active-trait)))
      (when trait
        (get-name~ trait))))
  
  
  (method public (get-active-trait-presentation)
    (let ((trait (get-active-trait)))
      (if (not trait)
          (get-presentation-property)
        (get-presentation-property~ trait))))
  
  
  (method public (get-active-trait)
    (let ((branch (get-active-branch)))
      (when branch
        (get-trait~ branch))))
  
  
  (method public (set-active-trait trait)
    (set-active-traits (if trait (list trait) '())))
  
  
  (method public (set-active-traits traits)
    (replace-traits #f traits))
  
  
  (method public (push-trait trait)
    (replace-traits (get-active-branch) (list trait)))
  
  
  (method public (pop-trait)
    (let ((active (get-active-branch)))
      (assert active)
      (let ((traits (compute-effective-traits~ (get-trait~ active))))
        (for-each-reversed (lambda (trait)
                             (if (and (neq? active self) (eq? trait (get-trait~ active)))
                                 (set! active (get-parent~ active))
                               (error "Cannot pop trait")))
                           traits)
        (replace-traits active '()))))
  
  
  (method public (replace-traits target-branch traits)
    (define (install-traits root-branch effective-traits)
      (let ((parent-branch root-branch))
        (for-each (lambda (trait)
                    (let ((new-branch (configure-client~ trait self parent-branch)))
                      (set-branch~ parent-branch new-branch)
                      (set! parent-branch new-branch)))
                  effective-traits)))
    
    (define (install-in-branch current-branch current-traits)
      (let ((old-branch (get-branch~ current-branch)))
        (when old-branch
          (restore-client~ old-branch)
          (set-branch~ current-branch #f)))
      (install-traits current-branch current-traits))
    
    (define (install-in-self effective-traits)
      (when branch
        (restore-client~ branch)
        (set! branch #f))
      (when (not-null? effective-traits)
        (let ((new-branch (configure-client~ (car effective-traits) self self)))
          (set! branch new-branch)
          (install-traits new-branch (cdr effective-traits)))))
    
    (define (change-installed? current-branch current-traits)
      (let ((match? (and current-branch (pair? current-traits) (eq? (get-trait~ current-branch) (car current-traits)))))
        (when (and match? (not (change-installed? (get-branch~ current-branch) (cdr current-traits))))
          (install-in-branch current-branch (cdr current-traits)))
        match?))
    
    (let ((effective-traits (apply append! (map compute-effective-traits~ (map (lambda (trait)
                                                                                 (resolve-trait self trait))
                                                                               traits))))
          (base-branch (if target-branch (get-branch~ target-branch) branch)))
      (when (not (change-installed? base-branch effective-traits))
        (if target-branch
            (install-in-branch target-branch effective-traits)
          (install-in-self effective-traits)))))
  
  
  (method public (for-each-trait proc)
    (for-each (lambda (trait)
                (proc trait)
                (for-each-trait~ trait proc))
              (child-traits)))
  
  
  (method public (with-each-trait proc)
    (let ((active-branch (get-branch)))
      (for-each-trait
        (lambda (trait)
          (set-active-trait trait)
          (proc)))
      (set-active-trait (get-trait~ active-branch))))
  
  
  (method public (get-branches)
    (if (not branch)
        '()
      (cons branch (get-branches~ branch))))
  
  
  (method public (find-trait-branch trait)
    (find-if (lambda (branch)
               (eq? (get-trait~ branch) trait))
             (get-branches)))
  
  
  (method public (iterate-branch-spine proc (trait: trait #f))
    (let ((branch (get-branch)))
      (while (is? branch Branch)
        (proc branch (get-client-form~ (get-trait~ branch)))
        (set! branch (get-branch~ branch)))
      (proc self (creator-effective-form))))
  
  
  ;; For a creator that was install in another creator, it is
  ;; very tricky because it's form is pointing to the form that
  ;; created it inside the other creator but sometimes we need
  ;; the install form that defines its own structure...
  (method public (creator-effective-form)
    (if (eq? self creator)
        form
      (get-class-form~ (class-of self))))
  

  ;;;
  ;;;; Session
  ;;;
  
  
  (method public virtual (save-session)
    )


  ;;;
  ;;;; Integrity
  ;;;
  
  
  (method public virtual (get-integrity-manager)
    #f)
  
  
  (method public virtual (validate-component root client context manager)
    (for-each (lambda (symbol)
                (let ((property (property-field (class-of self) symbol)))
                  (validate-property property root client context manager)))
              (get-categorized-properties)))
  
  
  (method public virtual (validate-property property root client context manager)
    (let ((domain (property-domain property))
          (value (read-property self property)))
      (validate~ domain property value self root client context manager)))


  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual (search-component target <Object>)
    (define (search-name name)
      (let ((presentation (localize (get-presentation-property))))
        (search presentation name ignore-case?: #t)))
    
    (define (search-type type)
      (is? self type))
    
    (let ((name (getf target name:))
          (type (getf target type:)))
      (and (or (not name) (search-name name))
           (or (not type) (search-type type)))))
  
  
  (method protected (search-text text <Object> target <Object>)
    (define (search-plain-text text <Object> target <Object>)
      (some? (lambda (line)
               (search line target ignore-case?: #t))
             (get-paragraphs~ text)))
    
    (define (search-formatted-text text <Object> target <Object>)
      (some? (lambda (info)
               (bind (format . runs) info
                 (some? (lambda (run)
                          (let ((string (car run)))
                            (search string target ignore-case?: #t)))
                        runs)))
             (get-paragraphs~ text)))
    
    (unimplemented 'search-text)
    @Unimplemented
    (typecase text
      ((Formatted-Text)
       (search-formatted-text text target))
      ((Text)
       (search-plain-text text target))
      (else
       #f)))
  
  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public virtual (launch . rest)
    )
  
  
  ;;;
  ;;;; Path
  ;;;
  
  
  (method public virtual (component-path (root creator))
    (let ((path '())
          (scan self))
      (while (neq? scan root)
        (let ((name (get-name~ scan)))
          (if (not name)
              (error "Component {t} must be named to be part of a path" scan)
            (set! path (cons name path))
            (set! scan (get-parent-component~ scan))
            (when (null? scan)
              (error "{t} is not a descendant of the root component {t}" self root)))))
      (new Path path)))
  
  
  (method public virtual (present-path root)
    (let ((path '())
          (pres #f)
          (scan self))
      (while (neq? scan root)
        (let ((name (get-name~ scan)))
          (if (not name)
              (error "Component {t} must be named to be part of a path" scan)
            (when (present-in-path?~ scan)
              (set! pres (cons name pres)))
            (set! path (cons name path))
            (set! scan (get-parent-component~ scan))
            (when (null? scan)
              (error "{t} is not a descendant of the root component {t}" self root)))))
      (values (new Path path) pres)))
  
  
  (method public virtual (present-in-path?)
    #t)

  
  ;;;
  ;;;; Unfold
  ;;;
  
  
  (method public (unfold-branches (branches: branches #t) (properties: properties '()) (include-root?: include-root? #t))
    (let* ((form (get-form~ (get-creator)))
           (active-branch (get-branch))
           (active-branch-name (and active-branch (get-name~ active-branch)))
           (all-branch-names (map get-name~ (child-traits)))
           (instantiate
             (lambda (branch-name)
               (if (eq? branch-name active-branch-name)
                   self
                 (let ((client (apply (~ instantiate form) properties)))
                   (when branch-name
                     (let ((branch (child~ client branch-name)))
                       (set-restoreable?~ branch #f)
                       (set-active-branch~ client branch)))
                   client)))))
      (if (eq? branches #t)
          (if include-root?
              (cons (instantiate #f) (map instantiate all-branch-names))
            (map instantiate all-branch-names))
        (map instantiate branches))))


  ;;;
  ;;;; Foreign
  ;;;
  
  
  (method public virtual (search-descendants criteria)
    (if (not criteria)
        (get-children)
      (unimplemented 'search-descendants)))


  ;;;
  ;;;; Descriptor
  ;;;


  (method meta public virtual (get-class-descriptor)
    (new (module-ref 'jazz.designer 'Component-Descriptor)))
  
  
  (method meta public virtual (get-domain property)
    (class-get-domain~ (get-descriptor self) self property))
  
  
  (method meta public virtual (get-category property)
    (class-get-category~ (get-descriptor self) self property))
  
  
  (method meta public (get-class-presentation)
    (class-presentation~ (get-descriptor self) self))
  
  
  (method meta public (get-class-image)
    (class-image~ (get-descriptor self) self))
  
  
  (method meta public (get-name-prohibited?)
    (class-name-prohibited?~ (get-descriptor self) self))
  
  
  (method meta public (get-name-mandatory?)
    (class-name-mandatory?~ (get-descriptor self) self))
  
  
  (method meta public (get-name-unicity?)
    (class-name-unicity?~ (get-descriptor self) self))
  
  
  (method meta public (presentation->name presentation)
    (class-presentation->name~ (get-descriptor self) self presentation))
  
  
  (method meta public (name->presentation name)
    (class-name->presentation~ (get-descriptor self) self name))
  
  
  (method meta public (property-presentation property)
    (class-property-presentation~ (get-descriptor self) self property))
  
  
  (method meta public (detail-presentation property)
    (class-detail-presentation~ (get-descriptor self) self property))
  
  
  (method meta public (persist-property? property)
    (class-persist-property?~ (get-descriptor self) self property))
  
  
  (method public (presentation-property? property)
    (component-presentation-property?~ (get-descriptor (class-of self)) self property))
  
  
  (method public (get-presentation-property)
    (component-get-presentation~ (get-descriptor (class-of self)) self))
  
  
  (method public (set-presentation-property designer presentation)
    (component-set-presentation~ (get-descriptor (class-of self)) self designer presentation))
  
  
  (method protected (get-string-presentation)
    (component-get-string-presentation~ (get-descriptor (class-of self)) self))
  
  
  (method protected (set-string-presentation designer presentation)
    (component-set-string-presentation~ (get-descriptor (class-of self)) self designer presentation))
  
  
  (method public (present-property property value)
    (component-present-property~ (get-descriptor (class-of self)) self property value))
  
  
  (method public (get-parent-component)
    (component-get-parent~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-components)
    (component-get-components~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-component-image)
    (component-get-component-image~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-cut-component?)
    (component-can-cut-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-copy-component?)
    (component-can-copy-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-paste-component?)
    (component-can-paste-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-paste-properties-component?)
    (component-can-paste-properties-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-rename-component?)
    (component-can-rename-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-select-all-component?)
    (component-can-select-all-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-delete-component?)
    (component-can-delete-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-move-component?)
    (component-can-move-component?~ (get-descriptor (class-of self)) self))
  
  
  (method public (can-view-properties?)
    (component-can-view-properties?~ (get-descriptor (class-of self)) self))
  
  
  (method public (determine-can-paste (try-parent? #t))
    (component-determine-can-paste~ (get-descriptor (class-of self)) self try-parent?))
  
  
  (method public (determine-paster (try-parent? #t))
    (component-determine-paster~ (get-descriptor (class-of self)) self try-parent?))
  
  
  (method public (can-send-before? types father before)
    (component-can-send-before?~ (get-descriptor (class-of self)) self types father before))
  
  
  (method public (sort-components?)
    (component-sort-components?~ (get-descriptor (class-of self)) self))
  
  
  (method public (sort-components predicate components)
    (component-sort-components~ (get-descriptor (class-of self)) self predicate components))
  
  
  (method public (indexable?)
    (component-indexable?~ (get-descriptor (class-of self)) self))
  
  
  (method public (component-surrogate)
    (component-surrogate-class~ (get-descriptor (class-of self)) self))


  (method public (install-surrogate editor)
    (component-install-surrogate~ (get-descriptor (class-of self)) self editor))
  
  
  (method public (install-children-surrogates editor)
    (component-install-children-surrogates~ (get-descriptor (class-of self)) self editor))


  (method public (remove-surrogate)
    (component-remove-surrogate~ (get-descriptor (class-of self)) self))


  (method public (remove-component-surrogate)
    (component-remove-component-surrogate~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-default-property)
    (component-get-default-property~ (get-properties-descriptor (class-of self)) self))
  
  
  (method public (get-categorized-properties)
    (component-get-categorized-properties~ (get-properties-descriptor (class-of self)) self))
  
  
  (method public (display-property? property)
    (component-display-property?~ (get-descriptor (class-of self)) self property))
  
  
  (method public (property-domain property)
    (component-property-domain~ (get-descriptor (class-of self)) self property))
  
  
  (method public (get-addable-default)
    (component-get-addable-default~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-classes)
    (component-get-addable-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (addable-class? class)
    (component-addable-class?~ (get-descriptor (class-of self)) self class))
  
  
  (method public (get-component-classes)
    (component-get-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-traits)
    (component-get-addable-traits~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-default-trait)
    (component-get-addable-default-trait~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-base)
    (component-get-addable-base~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-addable-details)
    (component-get-addable-details~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-recursive-details?)
    (component-get-recursive-details?~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-class-searchable-classes)
    (component-get-class-searchable-classes~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-custom-details)
    (component-get-custom-details~ (get-descriptor (class-of self)) self))
  
  
  (method public (get-custom-card)
    (component-get-custom-card~ (get-descriptor (class-of self)) self))
  
  
  (method public (save-component-properties designer)
    (component-save-properties~ (get-descriptor (class-of self)) self designer))


  ;;;
  ;;;; Designers
  ;;;
  
  
  (method public (get-designers)
    designers)
  
  
  (method public (set-designers lst)
    (set! designers lst)
    (for-each (lambda (child)
                (set-designers~ child lst))
              children))
  
  
  (method public (install-designer designer)
    (set! designers (cons designer designers))
    (for-each (lambda (child)
                (install-designer~ child designer))
              (get-components)))
  
  
  (method public (uninstall-designer designer)
    (set! designers (remove! designer designers))
    (for-each (lambda (child)
                (uninstall-designer~ child designer))
              (get-components)))


  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (print-component formatter printer)
    (unimplemented 'print-component)
    @Component-HTML-Printer
    (let ((printer (new Component-HTML-Printer self formatter printer)))
      (print-html~ printer)
      printer))
  
  
  (method public (export-text)
    (unimplemented 'export-text)
    @convert
    (let ((printer (open-output-string)))
      (generate-text printer)
      (set-clipboard-text (get-output-string printer))))
  
  
  (method public virtual (generate-text printer)
    (let ((formatter (new-text-formatter)))
      (print-text formatter printer)))
  
  
  (method protected virtual (new-text-formatter)
    (unimplemented 'new-text-formatter)
    @Formatter
    (new Formatter))
  
  
  (method public virtual (print-text formatter printer)
    )
  
  
  (method public virtual (output-component text)
    )
  
  
  (method public virtual (output-properties text)
    (unimplemented 'output-properties)
    @get-properties
    (for-each (lambda (property)
                (let ((title (localize (property-presentation~ (class-of self) property)))
                      (value (->string (read-property self property))))
                  (insert-bulleted-line~ text (format "{a} : {a}" title value))))
              (get-properties)))))
