;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exemplars
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.library.exemplar jazz


(import (jazz.library)
        (jazz.library.node))


(specialize inline as exemplar=? (= e1 <Exemplar> e2 <Exemplar>) <bool>
  (and (node=? e1 e2)
       (eq? (get-base~ e1) (get-base~ e2))))


;;;
;;;; Exemplar
;;;


(class Exemplar extends Node
  
  
  (slot protected domain)
  (slot protected base)
  (slot protected ascendant)
  (slot protected inited?     accessors generate)
  (slot protected persistent? accessors generate)
  
  
  (method override (initialize . rest)
    (bind-keywords ((domain {}) (base {}) . others) rest
      (apply nextmethod others)
      (set! domain~self domain)
      (set! base~self base)
      (set! ascendant~self {})
      (set! inited?~self #f)
      (set! persistent?~self #t)
      (when domain
        (install))))
  
  
  (method override (copy-object deep?)
    (let ((exemplar (nextmethod deep?)))
      (set-domain-value~ exemplar domain)
      (set-base-value~ exemplar base)
      exemplar))


  (method override (compare-object target)
    (cond ((is-not? target (class-of self))
           :incompatible)
          ((and (= (nextmethod target) :equal)
                (= base (get-base~ target)))
           :equal)
          (else
           :not-equal)))


  (method (fold-exemplar class-name)
    `(new ,class-name
       name: ',name
       base: ',base
       ,@(owned-properties)))

  
  (method override (print printer readably)
    (format printer "~{{a}{k empty-value: {}}{k}}"
            (identifier-name (category-name (class-of self)))
            (list
             name: name
             base: base)
            (owned-properties)))
  
  
  ;;;
  ;;;; Inheritance
  ;;;
  
  
  (method (install)
    (init))
  
  
  (method (init)
    (define (setup-inherited)
      (for-each (lambda (property)
                  (unless (memq? property owned)
                    (set-value property (get-value~ ascendant property))))
                (node-properties)))
    
    (unless inited?
      (if (not base)
          (set! ascendant {})
        (set! ascendant (locate~ domain base))
        (setup-inherited))
      (set! inited? #t)))
  
  
  (method public (inherits? target)
    (if (eq? name target)
        #t
      (continuation-capture
        (lambda (return)
          (for-each-ascendant
            (lambda (ascendant)
              (when (eq? (get-name~ ascendant) target)
                (continuation-return return #t))))
          #f))))
  
  
  (method public (has-ascendant? base)
    (has-ascendant?~ domain self base))
  
  
  (method public (for-each-ascendant proc)
    (when ascendant
      (proc ascendant)
      (for-each-ascendant~ ascendant proc)))
    
  
  (method public (extend (domain: domain domain))
    (define (copy-properties exemplar)
      (for-each (lambda (property)
                  (set-value~ exemplar property (get-value property)))
                (node-properties)))
    
    (let ((exemplar (new (class-of self))))
      (set-domain-value~ exemplar domain)
      (cond ((not name)
             (set-base-value~ exemplar base)
             (copy-properties exemplar)
             (set-owned~ exemplar (copy owned))
             (set-inited?~ exemplar #t))
            (else
             (set-base-value~ exemplar name)
             (install~ exemplar)))
      exemplar))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method protected (update)
    (reset)
    (init)
    (when (named?)
      (update-descendants)))
  
  
  (method (update-descendants)
    (when domain
      (update-descendants~ domain self)))
  
  
  ;;;
  ;;;; Modify
  ;;;
  
  
  (method public (modify-from from)
    (unless (eq? self from)
      (set! name (get-name~ from))
      (set! base (get-base~ from))
      (for-each (lambda (property)
                  (set-value property (get-value~ from property)))
                (node-properties))
      (set! owned (copy (get-owned~ from)))
      (set! persistent? (get-persistent?~ from))
      (update)))
  
  
  ;;;
  ;;;; Reset
  ;;;
  
  
  (method (reset)
    (define (reset-property property <Object>)
      (unless (memq? property owned)
        (set-value property {})))
    
    (when inited?
      @should-not-reset-to-nil-but-to-slot-initalize--we-skip-since-init-also-*set-value*
      (for-each reset-property (node-properties))
      (set! inited? #f)))
  
  
  ;;;
  ;;;; Domain
  ;;;
  
  
  (method public inline (set-domain-value d)
    (set! domain d))
  
  
  (method public (get-domain)
    domain)
  
  
  (method public (set-domain d)
    (set! domain d)
    (install))
  
  
  (method public (register)
    (add~ domain self))
  
  
  ;;;
  ;;;; Base
  ;;;
  
  
  (method public inline (set-base-value b)
    (set! base b))
  
  
  (method public (get-base)
    base)
  
  
  (method public (set-base b)
    (set! base b)
    (update)))


;;;
;;;; Exemplar-Domain
;;;


(class undocumented Exemplar-Domain extends Object
  
  
  (slot protected content <Axis> initialize (new Axis 0))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-content)
    content)
  
  
  (method public (set-content value)
    (set! content (coerce value Axis)))
  
  
  (method public (empty-content (remove-named?: remove-named? #f))
    (set! content (collect-if (lambda (exemplar)
                                (and (not remove-named?) (named?~ exemplar)))
                              content)))
  
  
  ;;;
  ;;;; Exemplars
  ;;;
  
  
  (method public (add exemplar)
    (axis-add content exemplar))
  
  
  (method public (reference rank/name)
    (if (integer? rank/name)
        (element content rank/name)
      (locate rank/name)))
  
  
  (method public (locate name (error?: error? #t))
    ;; (assert name)
    (either (find-in content name key: get-name~)
            (when error?
              (error "Unable to locate {t}" name))))
  
  
  (method public (similar exemplar)
    ; domain-free exemplar must call (setup-inherited) to inherit default properties
    (when (not (get-domain~ exemplar))
      (set-domain~ exemplar self))
    (find-in content exemplar test: exemplar=?))
  
  
  (method public (get-rank exemplar)
    (find content exemplar))
  
  
  ;;;
  ;;;; Inheritance
  ;;;
  
  
  (method public (has-ascendant? exemplar base)
    (continuation-capture
      (lambda (return)
        (for-each-ascendant~ exemplar
          (lambda (ascendant)
            (when (eq? ascendant base)
              (continuation-return return #t))))
        #f)))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method protected (update-descendants base)
    (for-each (lambda (exemplar)
                (when (has-ascendant? exemplar base)
                  (update~ exemplar)))
              content))
  
  
  ;;;
  ;;;; Persistence
  ;;;
  
  
  (method public (collect-persistent)
    (collect-if get-persistent?~ content))))
