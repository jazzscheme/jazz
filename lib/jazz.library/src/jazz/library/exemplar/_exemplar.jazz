
;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exemplars
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.library.exemplar jazz


(import (jazz.library))


;;;
;;;; Exemplar
;;;


(class Exemplar extends Object
  
  
  (slot protected domain)
  (slot protected base)
  (slot protected ascendants)
  (slot protected name        accessors generate)
  (slot protected persistent? accessors generate)
  
  
  (method override (initialize . rest)
    (bind-keywords ((domain #f) (base '()) (ascendants #f) (name #f) (persistent? #t) . others) rest
      (nextmethod)
      (set! domain~self domain)
      (set! base~self (listify base))
      (set! ascendants~self ascendants)
      (set! name~self name)
      (set! persistent?~self persistent?)
      (for-each-property (lambda (key value)
                           (set-attribute (keyword->symbol key) value))
                         others)))
  
  
  (method override (copy-object deep?)
    (let ((exemplar (new (class-of self))))
      (set-domain~ exemplar domain)
      (set-base~ exemplar base)
      (set-name~ exemplar name)
      (for-each (lambda (attribute)
                  (set-attribute~ exemplar attribute (get-attribute attribute)))
                (get-attributes))
      exemplar))


  (method override (compare-object target)
    (cond ((is-not? target (class-of self))
           :incompatible)
          ((and (equal? base (get-base~ target))
                (eqv? name (get-name~ target))
                (every? (lambda (attribute)
                          (equal? (get attribute) (get~ target attribute)))
                        (get-attributes)))
           :equal)
          (else
           :not-equal)))

  
  (method override (print printer readably)
    (define (owned-attributes)
      (let ((fact (new List-Factory)))
        (for-each (lambda (attribute)
                    (let ((value (get-attribute attribute)))
                      (when (specified? value)
                        (put~ fact (symbol->keyword attribute))
                        (put~ fact value))))
                  (get-attributes))
        (get-output~ fact)))
    
    (format printer "~{{a}{?: {l}~}{k empty-value: #f}{k}}"
            (identifier-name (category-name (class-of self)))
            (not-null? base) (reverse base)
            (list
             name: name)
            (owned-attributes)))
  
  
  ;;;
  ;;;; Inheritance
  ;;;
  
  
  (method public (inherits? target)
    (if (eq? name target)
        #t
      (continuation-capture
        (lambda (return)
          (for-each-ascendant
            (lambda (ascendant)
              (when (eq? (get-name~ ascendant) target)
                (continuation-return return #t))))
          #f))))
  
  
  (method public (for-each-ascendant proc)
    (for-each (lambda (ascendant)
                (proc ascendant)
                (for-each-ascendant~ ascendant proc))
              (get-ascendants)))
  
  
  (method public (extend (domain: domain domain))
    (let ((exemplar (new (class-of self))))
      (set-domain~ exemplar domain)
      (set-base~ exemplar (or name base))
      exemplar))
  
  
  ;;;
  ;;;; Modify
  ;;;
  
  
  (method public (modify-from from)
    (unless (eq? self from)
      (set! base (get-base~ from))
      (set! ascendants #f)
      (set! name (get-name~ from))
      (for-each (lambda (attribute)
                  (set-attribute attribute (get-attribute~ from attribute)))
                (get-attributes))
      (set! persistent? (get-persistent?~ from))))
  
  
  ;;;
  ;;;; Domain
  ;;;
  
  
  (method public (get-domain)
    domain)
  
  
  (method public (set-domain d)
    (set! domain d))
  
  
  (method public (register)
    (add~ domain self))
  
  
  ;;;
  ;;;; Base
  ;;;
  
  
  (method public (get-base)
    base)
  
  
  (method public (set-base b)
    (set! base b)
    (set! ascendants #f))
  
  
  ;;;
  ;;;; Ascendants
  ;;;
  
  
  (method public (get-ascendants)
    (when (not ascendants)
      (set! ascendants (map (lambda (name)
                              (locate~ domain name))
                            base)))
    ascendants)
  
  
  ;;;
  ;;;; Name
  ;;;
  
  
  (method public (named?)
    name)
  
  
  ;;;
  ;;;; Attributes
  ;;;
  
  
  (method public (supports? attribute)
    (memq? attribute (get-attributes)))
  
  
  (method protected virtual (get-attributes)
    '())
  
  
  (method protected virtual (get-attribute attribute)
    (unspecified))
  
  
  (method protected virtual (get-attribute-default attribute)
    (unspecified))
  
  
  (method protected virtual (set-attribute attribute value)
    )
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public virtual (get attribute)
    (unspecified))
  
  
  (method public virtual (set attribute value)
    (error "Unknown attribute: {t}" attribute)))


(definition public (construct-exemplar class rest)
  (let (iterate (base '()) (scan rest))
    (if (or (null? scan) (not (symbol? (car scan))))
        (apply new class base: base scan)
      (iterate (cons (car scan) base) (cdr scan)))))


(specialize inline as exemplar=? (= e1 <Exemplar> e2 <Exemplar>) <bool>
  (and (eq? (get-name~ e1) (get-name~ e2))
       (eq? (get-base~ e1) (get-base~ e2))
       (every? (lambda (attribute)
                 (equal? (get~ e1 attribute) (get~ e2 attribute)))
               (get-attributes~ e1))))


;;;
;;;; Exemplar-Domain
;;;


(class undocumented Exemplar-Domain extends Object
  
  
  (slot initer)
  (slot content <Axis> initialize (new Axis 0))
  
  
  (method override (initialize (initer: initer #f))
    (nextmethod)
    (set! initer~self initer))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-content)
    (when initer
      (let ((thunk initer))
        (set! initer #f)
        (thunk)))
    content)
  
  
  (method public (set-content value)
    (set! content (coerce value Axis)))
  
  
  (method public (empty-content (remove-named?: remove-named? #f))
    (set! content (collect-if (lambda (exemplar)
                                (and (not remove-named?) (named?~ exemplar)))
                              content)))
  
  
  ;;;
  ;;;; Exemplars
  ;;;
  
  
  (method public (add exemplar)
    (axis-add (get-content) exemplar))
  
  
  (method public (reference rank/name)
    (if (integer? rank/name)
        (element (get-content) rank/name)
      (locate rank/name)))
  
  
  (method public (locate name (error?: error? #t))
    (or (find-in (get-content) name key: get-name~)
        (when error?
          (error "Unable to locate: {t}" name))))
  
  
  (method public (similar exemplar)
    (when (not (get-domain~ exemplar))
      (set-domain~ exemplar self))
    (find-in (get-content) exemplar test: exemplar=?))
  
  
  (method public (get-rank exemplar)
    (find (get-content) exemplar))
  
  
  ;;;
  ;;;; Persistence
  ;;;
  
  
  (method public (collect-persistent)
    (collect-if get-persistent?~ (get-content)))))
