;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Display Outlines
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.library.outline.Display-Outline jazz


(import (jazz.library))


(class undocumented Display-Outline extends Outline
  
  
  (slot first-displayed               initialize {} getter generate)   ;; first row that is displayed even if only partially
  (slot first-displayed-rank   <fx>   initialize 0  getter generate)   ;; first displayed row's rank
  (slot first-displayed-offset <fx>   initialize 0  getter generate)   ;; amount of scroll that would be needed to uncover a partially displayed row
  
  
  ;;;
  ;;;; Outline
  ;;;
  
  
  (method override (get-row n)
    (if (and first-displayed (>= n first-displayed-rank))
        (get-row-from first-displayed (- n first-displayed-rank))
      (nextmethod n)))


  (method override (call-with-v->row v scrolled proc)
    (if first-displayed
        (let* ((displayed? (>= v (- scrolled)))
               (v (if displayed? (+ v scrolled) v))
               (row (if displayed? first-displayed (first-visible-row)))
               (rank (if displayed? first-displayed-rank 0))
               (top (if displayed? (- first-displayed-offset) 0))
               (bottom (+ top (get-height~ row) row-spacing)))
          (while (and row (or (< v top) (>= v bottom)))
            (increase! rank)
            (set! row (get-next~ row))
            (when row
              (set! top bottom)
              (set! bottom (+ top (get-height~ row) row-spacing))))
          (if (and row (< v (- bottom row-spacing)))
              (proc rank (- v top) (- bottom top))
            (proc {} {} {})))
      (proc {} {} {})))
  
  
  ;;;
  ;;;; Displayed
  ;;;
  
  
  (method (update-displayed display-v)
    (let ((row (first-visible-son~ root-row))
          (rank <fx> 0)
          (v display-v))
      (when row
        (let ((bottom <fx> (- v (get-height~ row))))
          (while (> bottom 0)
            (let ((next (get-next~ row)))
              (if (not next)
                  (set! bottom 0)
                (set! row next)
                (increase! rank)
                (set! v (- bottom row-spacing))
                (set! bottom (- v (get-height~ row))))))))
      (set! first-displayed row)
      (set! first-displayed-rank rank)
      (set! first-displayed-offset (if row v 0))))
  
  
  (method (follow display-v v)
    ;; This is a patch for a bug I don't want to debug as the whole
    ;; approach about first-displayed needs to be rethought completly
    ;; See the Outline-View.follow Bug.jazz file to reproduce it...
    (let ((succeeded?
            (cond ((> v 0) (follow-forward v))
                  ((< v 0) (follow-backward (- v))))))
      (when (not succeeded?)
        (update-displayed display-v))))
  
  
  (method (follow-forward v)
    (while (> v 0)
      (let* ((height (+ (get-height~ first-displayed) row-spacing))
             (remaining (- height first-displayed-offset)))
        (if (< v remaining)
            (begin
              (increase! first-displayed-offset v)
              (set! v 0))
          (set! first-displayed (get-next~ first-displayed))
          (increase! first-displayed-rank)
          (decrease! v remaining)
          (set! first-displayed-offset 0))))
    #t)
  
  
  (method (follow-backward v)
    (continuation-capture
      (lambda (return)
        (while (> v 0)
          (if (<= v first-displayed-offset)
              (begin
                (decrease! first-displayed-offset v)
                (set! v 0))
            (set! first-displayed (get-previous~ first-displayed))
            (if (not first-displayed)
                (continuation-return return #f)
              (decrease! first-displayed-rank)
              (decrease! v (+ first-displayed-offset 1))
              (set! first-displayed-offset (- (+ (get-height~ first-displayed) row-spacing) 1)))))
        #t)))))
