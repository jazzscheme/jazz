;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Localized Strings
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.locale.components jazz


(import (jazz.designer.view)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.ui))


;;;
;;;; Locale-Node
;;;


(class Locale-Node extends Component
  
  
  (property title initialize #f accessors generate)
    
  
  (method public (get-locale)
    (and name
         (symbol->keyword name)))
  
  
  (method protected (register-node-locale locale-state)
    (register-locale~ locale-state (new Locale name (and parent (get-name~ parent)) title))
    (for-each (lambda (child)
                (when (is? child Locale-Node)
                  (register-node-locale~ child locale-state)))
              children))
  
  
  (method override (validate-component validation-context)
    (nextmethod validation-context)
    (unless name
      (add-violation~ validation-context message: "unnamed Locale-Node"))
    (unless (find-ascendant Locale-Tree include-self?: #t)
      (add-violation~ validation-context message: "Locale-Node must descend from Locale-Tree")))
  
  
  (method meta override (get-class-descriptor)
    (new Locale-Node-Descriptor)))


;;;
;;;; Locale-Tree
;;;


(class Locale-Tree extends Locale-Node implements Locales-Provider
  
  
  (form
    (<install> name: all title: ""))
  
  
  (method override (default-name)
    'all)
  
  
  (method override (validate-component validation-context)
    (nextmethod validation-context)
    (let ((result (for-each-pair (provide-locales)
                                 test: (lambda (sublist)
                                         (not (memq? (car sublist) (cdr sublist)))))))
      (unless (null? result)
        (add-violation~ validation-context message: (format "multiple descendants named {a}" (car result)))))
    (unless (find-ascendant Locale-Tree include-self?: #t)
      (add-violation~ validation-context message: "Locale-Node must descend from Locale-Tree")))
  
  
  (method public (collect-missing-localizations object)
    (if (is-not? object Locales-Provider)
        (collect-if (lambda (locale) (neq? all: locale)) (provide-locales))
      (let ((object-locales (provide-locales~ object))
            (result '()))
        (unless (memq? all: object-locales)
          (for-each-descendant
            do-nothing
            stop-test: (lambda (locale-node)
                         (let ((node-locale (get-locale~ locale-node)))
                           (unless (memq? node-locale object-locales)
                             (set! result (cons node-locale result))
                             #t)))))
        result)))
  

  (method public (register-locales locale-state)
    (for-each-descendant 
      (lambda (component level)
        (when (is? component Locale-Node)
          (register-locale~ locale-state (new Locale (get-name~ component) (get-name~ (get-parent~ component)) (get-title~ component)))))
      include-self?: #f))
  
  
  (method override (provide-locales)
    (map (compose symbol->keyword get-name~) (collect-descendants Locale-Node))))


;;;
;;;; Locale-Tree singleton cache
;;;


(definition *locale-tree-cache* (make-table))


(definition public (find-locale-tree root-class/unit)
  (let ((unit (if (class? root-class/unit)
                  (string->symbol (car (split (symbol->string (get-name~ root-class/unit)) ":")))
                root-class/unit)))
    (when unit
      (let ((toolbox-module (find (append-map get-toolbox-modules~ (get-toolbox-managers)) unit key: get-module-name~ return: 'item)))
        (if toolbox-module
            (let ((locale-tree-class-reference (get-locale-tree-class~ toolbox-module)))
              (assert (is? locale-tree-class-reference Class-Reference))
              (let ((locale-tree-class (resolve-reference~ locale-tree-class-reference)))
                (assert (subclass? locale-tree-class Locale-Tree))
                (or (table-ref *locale-tree-cache* locale-tree-class #f)
                    (let ((locale-tree (new locale-tree-class)))
                      (table-set! *locale-tree-cache* locale-tree-class locale-tree)
                      locale-tree))))
          (error "Unit {a} is not referred to by any toolbox modules in any toolbox managers" unit))))))


;;;
;;;; Validation
;;;


(definition public (validate-locales value root-class/unit violation-adder)
  (let ((tree (find-locale-tree root-class/unit)))
    (cond (tree
           (let ((missing-locales (collect-missing-localizations~ tree value)))
             (unless (null? missing-locales)
               (violation-adder "must be localized in: {a}" (join (map keyword->string missing-locales) ", "))))
           ((not (or (string? value) (is? value Locales)))
            (violation-adder "must be a string or a Locales object"))))))


;;;
;;;; Design
;;;


(submodule design


(import (jazz.designer))


(class Locale-Node-Descriptor extends Component-Descriptor
  
  
  (form
    (<install>
      (<properties~>
        (<Property-Descriptor> name: title
          (<Localized-Domain>  name: domain)))))
  
  
  (method override (component-get-categorized-addable-classes component)
    `((,(reference Locale-Node)))))))
