;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Highlevel Logger
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.log jazz


(import (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.ui.view))


;;;
;;;; Log
;;;


(class undocumented Log extends Object
  
  
  (slot name           initialize {} getter generate)
  (slot file           initialize {} getter generate)
  (slot last-mark      initialize {})
  (slot read-error?    initialize #f)
  (slot current-node   initialize {} getter generate)
  (slot toplevel-nodes initialize '())
  
  
  (method override (initialize (name: name {}) (file: file {}) (load?: load? #f))
    (nextmethod)
    (set! name~self name)
    (set! file~self file)
    (set! current-node~self {})
    (set! toplevel-nodes~self (new List-Factory))
    (when load?
      (load-toplevel-nodes)))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-toplevel-nodes)
    (get-list~ toplevel-nodes))
  
  
  ;;;
  ;;;; I/O
  ;;;
  
  
  (method public (reload)
    (if (null? file)
        (error "Log {s} has no associated file" name)
      (load-toplevel-nodes)))
  
  
  ;; Should create a Mark class to encapsulate those four values
  (method (get-mark-position mark)
    (first mark))
  
  
  (method (get-mark-line mark)
    (third mark))
  
  
  (method (get-mark-column mark)
    (fourth mark))
  
  
  (method (handle-read-error current-mark)
    (if (and read-error? (= (get-mark-position last-mark)
                            (get-mark-position current-mark)))
        (let ((file-path (parse~ file))
               (line (+ 1 (get-mark-line current-mark)))
               (column (+ 1 (get-mark-column current-mark))))
          (message-box (format "Cannot process log file {a}{%}at line {a}, column {a}" file-path line column)))
      (set! read-error? #t)))
  
  
  (method (load-toplevel-nodes)
    @convert
    (with-closed ((reader (new File-Reader file sharing: 'read/write)))
      (when last-mark
        (set-reader-file-mark reader last-mark))
      (let ((done? #f)
            (current-mark last-mark))
        (catch (Error err
                      (handle-read-error current-mark))
          (while (not done?)
            (set! current-mark (reader-file-mark reader))
            (let ((expr (read reader)))
              (if (eof-object? expr)
                  (set! done? #t)
                (let ((node (parse-jml expr)))
                  (put~ toplevel-nodes node)))))
          (set! read-error? #f))
        (set! last-mark current-mark))))
  
  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (add-toplevel-node node)
    (when (null? file)
      (put~ toplevel-nodes node)))
  
  
  (method (output-toplevel-node node)
    (when file
      (call-with-output-file (list (parse~ file) mode: 'append sharing: 'read)
        (lambda (printer)
          (pretty-print~ node printer)))))
  
  
  ;;;
  ;;;; Logging
  ;;;
  
  
  (method public (with-node node proc)
    (let ((parent current-node)
          (preserved current-node))
      (when (not parent)
        (add-toplevel-node node))
      (prog1 (unwind-protect
                 (begin
                   (set-parent~ node parent)
                   (set! current-node node)
                   (proc node))
               (set! current-node preserved))
        (when (not parent)
          (output-toplevel-node node)))))
  
  
  (method public (log-node node)
    (let ((parent current-node))
      (set-parent~ node parent)
      (when (not parent)
        (add-toplevel-node node)
        (output-toplevel-node node))
      node))
  
  
  (method public (log-entry tag name message data)
    (log-node (new-entry tag name message data)))
  
  
  (method public (new-entry tag name message data)
    (let ((entry (new JML-Element {} (either tag 'entry))))
      (set-property~ entry 'name name)
      (set-property~ entry 'message message)
      (set-property~ entry 'data data)
      entry))
  
  
  (method public (clear)
    ;; clear memory and file content
    (unimplemented 'clear)))


;;;
;;;; Logging
;;;


(definition public undocumented Logs
  (new List-Factory))


(definition public undocumented (get-logs)
  (get-list~ Logs))

@unimplemented
(definition public undocumented Add-Log-Lock
  (new Lock))


(definition public undocumented (add-log log)
  (unimplemented 'add-log)
  @Mutex?
  (synchronize Add-Log-Lock
    (unless (memq? log (get-logs))
      (put~ Logs log))))


(definition public undocumented (current-log)
  (either (get-current-log)
          (let ((log (default-log)))
            (set-current-log log)
            (add-log log)
            log)))


(definition (default-log)
  (unimplemented 'default-log)
  @Logs
  (new Log name: "Default"))


(definition public undocumented (get-current-log)
  (unimplemented 'get-current-log)
  @Parameters
  (get-parameter 'current-log))


(definition public undocumented (set-current-log log)
  (unimplemented 'set-current-log)
  @Parameters
  (set-parameter 'current-log log))


(definition public undocumented (with-log log proc (name: name {}) (file: file {}))
  (unimplemented 'with-log)
  @unwind-protect
  (let ((preserved (get-current-log)))
    (unwind-protect
        (begin
          (set-current-log log)
          (proc))
      (set-current-log preserved))
    (let ((name (get-name~ log)))
      (when (and name (not file))
        (add-log log)))))


(definition public undocumented (with-node proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (let ((node (either node (new-entry~ log tag name message data))))
    (with-node~ log node proc)))


(definition public undocumented (log-node node (log: log (current-log)))
  (log-node~ log node))


(definition public undocumented (log-entry (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (log-entry~ log tag name message data))


(definition public undocumented (log-properties properties (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (let ((printer (open-output-string))
        (first? #t))
    (for-each-property (lambda (property value)
                         (if first?
                             (set! first? #f)
                           (format printer ", "))
                         (format printer "{a}: {a}" (keyword->symbol property) value))
      properties)
    (let ((message (get-output-string printer)))
      (log-entry tag: tag name: name message: message data: data log: log))))


(definition public undocumented (new-log-node (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (new-entry~ log tag name message data))


;;;
;;;; Profiling
;;;


(definition public undocumented (with-profile proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (unimplemented 'with-profile)
  @Profiling-later
  (with-node
    (lambda (node)
      (let ((result))
        (log-profile name: 'before log: log)
        ;; this is ugly but necessary not to change stack depth
        (set! result (proc node))
        (log-profile name: 'after log: log)
        result))
    node: (either node (new-entry~ log tag name message data))))


(definition public undocumented (log-profile (name: name {}) (log: log (current-log)))
  (unimplemented 'log-profile)
  @Profiling-later (
  (gc)
  (log-node (resources-snapshot~ Performance name: name) log: log)))


(definition public undocumented (log-stack (tag: tag {}) (name: name {}) (message: message {}) (log: log (current-log)))
  (unimplemented 'log-stack)
  @later
  (let ((data (new Stack-Snapshot)))
    (log-entry tag: tag name: name message: message data: data log: log)))


(definition public undocumented (profiles->jml profiles)
  (unimplemented 'profiles->jml)
  @later
  (let ((nodes '()))
    (iterate-table (get-profiles)
      (lambda (name profile)
        (when (not (profile-parent profile))
          (set! nodes (cons (profile->jml {} profile) nodes)))))
    (sort < nodes key: (lambda (node) (get-property~ node 'name)))))


(definition (profile->jml parent profile)
  (unimplemented 'profile->jml)
  @later
  (let ((node (profile-content parent profile)))
    (insert-profile-children node profile)
    node))


(definition (profile-content parent profile)
  (unimplemented 'profile-content)
  @later
  (let ((name (profile-name profile))
        (count (profile-count profile 0))
        (total (profile-total profile 0)))
    (new JML-Element parent 'profile properties: (list 'name name 'count count 'total total))))


(definition (insert-profile-children parent profile)
  (unimplemented 'insert-profile-children)
  @later
  (map (lambda (child)
         (profile->jml parent child))
       (collect-profile-children profile)))


(definition (collect-profile-children profile)
  (unimplemented 'collect-profile-children)
  @later
  (let ((children '())
        (child (profile-last-child profile)))
    (while child
      (set! children (cons child children))
      (set! child (profile-previous-brother child)))
    children)))
