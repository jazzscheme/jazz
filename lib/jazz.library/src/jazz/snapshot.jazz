;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Process Snapshots
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.snapshot jazz


(import (jazz.debuggee)
        (jazz.editor.jazz.inspector)
        (jazz.io)
        (jazz.locale)
        (jazz.platform)
        (jazz.system)
        (time))


(definition *snapshots-directory*
  {Directory Jazz-Settings "crashes"})


(definition *snapshot-process-mutex*
  (make-mutex 'snapshot-process))


(definition public (snapshot-process . rest)
  (define (with-mutex proc)
    (mutex-lock! *snapshot-process-mutex*)
    (unwind-protect
        (proc)
      (mutex-unlock! *snapshot-process-mutex*)))
  
  (with-mutex
    (lambda ()
      (bind-keywords ((directory #f) . others) rest
        (let ((file (timestamped-file (or directory *snapshots-directory*) (current-process-present) "snapshot")))
          (create-directories~ file)
          (call-with-output-file (path-settings file)
            (lambda (output)
              (apply print-process-snapshot output others)))
          file)))))


(definition (print-process-snapshot output (reason: reason #f) (exception: exception #f) (max-depth: max-depth 2) (max-width: max-width 256) (max-content: max-content 100) (max-entries: max-entries #f))
  (let ((values (make-table test: eq?)))
    (define package-info-serial first)
    (define package-info-presentation second)
    (define package-info-more? third)
    
    (define (register-package-info info depth)
      (let ((serial (package-info-serial info)))
        (cond ((table-ref values serial #f)
               serial)
              ((and max-entries (>= (table-length values) max-entries))
               #f)
              (else
               (let ((presentation (package-info-presentation info))
                     (content (if (package-info-more? info) (register-content serial (+ depth 1)) '())))
                 (table-set! values serial (cons presentation content))
                 serial)))))
    
    (define (register-content serial depth)
      (if (< depth max-depth)
          (let ((value (serial->object serial)))
            (map (lambda (name+info)
                   (bind (name . info) name+info
                     (list name (register-package-info info depth))))
                 (inspect-value value max-width: max-width max-content: max-content)))
        '()))
    
    (define (print-process)
      (define (present-process-version)
        (let ((process (get-process)))
          (when process
            (present~ (process-version~ process)))))
      
      (let ((name (current-process-present))
            (version (present-process-version))
            (date (present-date (current-date)))
            (id (current-process-id)))
        (format output "(<process> name: {s}{? version: {s}~} date: {s} id: {s}" name version date id))
      (when reason
        (format output " reason: {s}" reason))
      (when exception
        (format output " exception: {s}" (exception-reason exception)))
      (force-output output)
      (print-threads)
      (force-output output)
      (print-values)
      (format output "){%}"))
    
    (define (print-threads)
      (format output "{%}")
      (format output "  (<threads>")
      (continuation-capture
        (lambda (continuation)
          (print-thread (current-thread) continuation)))
      (let ((mutex (make-mutex 'snapshot)))
        (mutex-lock! mutex)
        (for-each (lambda (thread)
                    (with-exception-filter
                      inactive-thread-exception?
                      inactive-thread-exception?
                      (lambda ()
                        (when (and (neq? thread (current-thread)) (thread-state-active? (thread-state thread)))
                          (thread-interrupt! thread
                                             (lambda ()
                                               (continuation-capture
                                                 (lambda (continuation)
                                                   (print-thread thread continuation)))
                                               (mutex-unlock! mutex)))
                          (mutex-lock! mutex)))))
                  (top-threads)))
      (format output ")"))
    
    (define (print-thread thread continuation)
      (define (stop-kind thread)
        (let ((stops (get-thread-stops thread)))
          (when (not-null? stops)
            (get-kind~ (last stops)))))
      
      (format output "{%}")
      (let ((name (thread-name thread))
            (state (present-thread-state (thread-state thread)))
            (stop (stop-kind thread)))
        (format output "    (<thread>")
        (when (and name (specified? name))
          (format output " name: {s}" name))
        (when state
          (format output " state: {s}" state))
        (when stop
          (format output " stop: {s}" stop)))
      (force-output output)
      (when continuation
        (print-stack continuation))
      (format output ")"))
    
    (define (print-stack continuation)
      (define (skip-snapshot-frames frames)
        (let (iterate (frames frames) (scan frames))
          (cond ((null? scan) frames)
                ((eq? (get-continuation-name (car scan)) 'jazz.snapshot.snapshot-process) (iterate scan (cdr scan)))
                (else (iterate frames (cdr scan))))))
      
      (let ((stack (skip-snapshot-frames (get-continuation-stack continuation #f))))
        (loop (for cont in stack)
              (do (let ((name (get-continuation-name cont))
                        (variables (get-continuation-lexical-environment cont)))
                    (format output "{%}")
                    (format output "      (<frame> name: {a}" name)
                    (loop (for variable in variables)
                          (do (format output "{%}")
                              (bind (name value mutable?) variable
                                (let ((info (package-info value mutable?: mutable? max-width: max-width)))
                                  (let ((serial (register-package-info info 0))
                                        (presentation (package-info-presentation info)))
                                    (let ((atomic? (and (atom? value)
                                                        ;; this test is necessary as object->string can return a truncated unreadable string
                                                        (< (string-length presentation) max-width))))
                                      (format output "        (<variable> name: {s} serial: {s}{?: presentation: {a}~})" name serial atomic? presentation)))))))
                    (format output ")")
                    (force-output output))))))
    
    (define (print-values)
      (format output "{%}")
      (format output "    (<values>")
      (for-each (lambda (info)
                  (bind (serial presentation . content) info
                    (format output "{%}")
                    (format output "      (<value> serial: {a} presentation: {s}" serial presentation)
                    (when (not-null? content)
                      (format output " content: {s}" content))
                    (format output ")")))
                (sort < (table->list values) key: car))
      (format output ")"))
  
    (print-process)))


(definition public (snapshot-exception-debugger (feedback: feedback #f))
  (lambda (exception)
    (with-system-exception-debugger
      (lambda ()
        (let ((snapshot (snapshot-process exception: exception)))
          (when feedback
            (feedback exception snapshot)))
        (exit 1)))))


(definition public (application-exception-debugger)
  (snapshot-exception-debugger
    feedback: application-exception-feedback))


(definition public (application-exception-feedback exception snapshot)
  (let ((process (get-process)))
    (system-message (format "{a} {a}{%}{%}{a}.{%}{a}.{%}{%}{a}{%}    {a}{a}"
                            (localize {Locales english: "An unexpected problem occured while executing" french: "Une erreur imprévue s'est produite lors de l'exécution de"})
                            (current-process-present)
                            (localize {Locales english: "This will terminate the application immediately" french: "Ceci entraine la terminaision immédiate de l'application"})
                            (localize {Locales english: "Unsaved work currently in progress will be lost" french: "Tout travaux en cours non sauvegardés seront perdus"})
                            (localize {Locales english: "A log file has been generated at" french: "Un fichier de log a été généré à"})
                            (parse~ snapshot)
                            (if process
                                (let ((email (process-email~ process)))
                                  (if email
                                      (format "{%}{%}{a}{%}{a}: {a}."
                                              (localize {Locales english: "Help us fix this problem by sending the log file and any comments" french: "Aidez nous à corriger ce problème en fesant parvenir le fichier de log"})
                                              (localize {Locales english: "about how the problem occured to" french: "ainsi que tout commentaires explicatifs à"})
                                              email)
                                    ""))
                              ""))
                    title: (localize {Locales english: "Application Error" french: "Erreur d'application"})
                    type: 'problem))))
