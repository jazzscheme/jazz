;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Server Panel
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.network.server.Server-Panel jazz


(import (jazz.io)
        (jazz.system))


(class Server-Panel extends Object
  
  
  ;;;
  ;;;; Loop
  ;;;
  
  
  (definition version
    "1.0")
  
  (definition prompt
    "% ")
  
  (definition display-backtrace?
    #f)
  
  
  (method (run-loop server)
    (define input
      (console-input-port))
    
    (define output
      (console-output-port))
    
    (define (process-command command)
      (call-with-input-string command
        (lambda (input)
          (let ((command (read input))
                (arguments (read-all input read)))
            (case command
              ((start) (start-command arguments))
              ((stop) (stop-command arguments))
              ((restart) (restart-command arguments))
              ((info) (info-command arguments))
              ((debug) (debug-command arguments))
              ((help ?) (help-command arguments))
              ((quit) (quit-command arguments))
              (else (error "Unknown command: {s}" command)))))))
    
    (define (start-command arguments)
      (start-server))
    
    (define (stop-command arguments)
      (stop-server))
    
    (define (restart-command arguments)
      (restart-server))
    
    (define (info-command arguments)
      (server-info))
    
    (define (debug-command arguments)
      (server-debug (if (null? arguments)
                        (not (get-debug?~ server))
                      (car arguments))))
    
    (define (help-command arguments)
      (format output "Commands are{%}")
      (format output "  start        : Start the server{%}")
      (format output "  stop         : Stop the server{%}")
      (format output "  restart      : Restart the server{%}")
      (format output "  info         : Show server information{%}")
      (format output "  debug [flag] : Toggle or set debugging to flag{%}")
      (format output "  help or ?    : Display available commands{%}")
      (format output "  quit         : Quit the server panel{%}")
      (force-output output))
    
    (define (quit-command arguments)
      (exit-process~ (get-process)))
    
    ;;;
    ;;;; Server
    ;;;
    
    (define (server-at)
      (format "{a}:{a}"
              (either (server-host~ server) "localhost")
              (server-service~ server)))
    
    (define (start-server)
      (let ((state (get-state~ server)))
        (case state
          ((stopped)
           (start~ server)
           (if (not (wait-started~ server error?: #f))
               (error "Unable to start server")
             (format output "Server started at {a}{%}" (server-at))))
          (else
           (format output "Server is {s}{%}" state)))))
    
    (define (stop-server)
      (let ((state (get-state~ server)))
        (case state
          ((started)
           (stop~ server)
           (if (not (wait-stopped~ server error?: #f))
               (error "Unable to stop server")
             (format output "Server stopped{%}")))
          (else
           (format output "Server is {s}{%}" state)))))
    
    (define (restart-server)
      (let ((state (get-state~ server)))
        (case state
          ((stopped started)
           (restart~ server)
           (if (not (wait-started~ server error?: #f))
               (error "Unable to restart server")
             (format output "Server restarted at {a}{%}" (server-at))))
          (else
           (format output "Server is {s}{%}" state)))))
    
    (define (server-info)
      (format output "Server {a}{%}" (get-state~ server))
      (format output "  name                    : {a}{%}" (server-name~ server))
      (format output "  class                   : {a}{%}" (category-name (class-of server)))
      (format output "  host                    : {a}{%}" (either (server-host~ server) "localhost"))
      (format output "  service                 : {a}{%}" (server-service~ server))
      (format output "  hits                    : {a}{%}" (get-hits~ server))
      (format output "  debug?                  : {a}{%}" (get-debug?~ server)))
    
    (define (server-debug debug?)
      (set-debug?~ server debug?)
      (format output "Server {a}being debugged{%}" (if debug? "" "not ")))
    
    ;;;
    ;;;; Panel
    ;;;
    
    (format output "{a} Server {a}{%}{%}" (server-name~ server) (server-version~ server))
    (force-output output)
    
    (start-server)
    
    (let (loop (newline? #t))
      (when newline?
        (newline output))
      (display prompt output)
      (force-output output)
      (let ((command (read-line input)))
        (cond ((eof-object? command)
               (exit-process~ (get-process)))
              ((empty-string? command)
               (loop #f))
              (else
               (continuation-capture
                 (lambda (stop)
                   (with-exception-handler
                     (lambda (exc)
                       (display-exception exc)
                       (if display-backtrace?
                           (continuation-capture
                             (lambda (cont)
                               (display-continuation-backtrace cont))))
                       (continuation-return stop #f))
                     (lambda ()
                       (process-command command)))))
               (loop #t))))))))
