;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; SMTP Utilities
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.network.smtp jazz


(import time)


(class MIME-Message extends Object
  
  
  (slot from getter generate)
  (slot to getter generate)
  (slot subject getter generate)
  (slot message getter generate)
  (slot cc getter generate)
  (slot bcc getter generate)
  (slot content-type getter generate)
  (slot attachments getter generate)  
  
  
  (method override (initialize from to subject message (cc: cc '()) (bcc: bcc '()) (content-type: content-type #f) (attachments: attachments '()))
    (set! from~self from)
    (set! to~self to)
    (set! subject~self subject)
    (set! message~self message)
    (set! cc~self cc)
    (set! bcc~self bcc)
    (set! content-type~self content-type)
    (set! attachments~self attachments))
  
  
  (method (format-mime-date date)
    (date->string date "~d ~b ~Y ~H:~M:~S ~z"))
  
  
  (method (make-mime-header)
    (string-append (format "From: {a}{%}" from)
                   (format "To: {a}{%}" (join to ", "))
                   (format "{?:Cc: {a}{%}~}" (not-null? cc) (join cc ", "))
                   (format "{?:Bcc: {a}{%}~}" (not-null? bcc) (join bcc ", "))
                   (format "Date: {a}{%}" (format-mime-date (system-date)))
                   (format "Subject: {a}{%}" subject)
                   "MIME-Version: 1.0\n"))
  
  
  (method (make-plain-mime-message)
    (string-append (make-mime-header)
                   (format "Content-Type: {a};\n\n" (or content-type 'text/plain))
                   message
                   "\n\n"))


  (method (make-multipart-mime-message)
    ;; Generate this boundary
    (let* ((boundary "CF69BC42-C9CB-11E0-82A0-A5C34824019B")
           (parts (append (list (format "Content-Type: multipart/mixed; boundary={a}\n" boundary)
                                (format "Content-Type: text/plain;\n\n{a}\n\n" message))
                          (map (lambda (file)
                                 (string-append (format "Content-Type: application/octet-stream\n")
                                                (format "Content-Disposition: attachment; filename={s}\n" (get-name~ file))
                                                "Content-Transfer-Encoding: base64\n\n"
                                                (separate-lines (file->base64-string file) 72)
                                                "\n"))
                               attachments))))
      (string-append (make-mime-header)
                     (join parts (format "--{a}\n" boundary))
                     (format "--{a}--\n" boundary))))
  
  
  (method public (format-for-delivery)
    (if (null? attachments)
        (make-plain-mime-message)
      (make-multipart-mime-message))))


(class SMTP-Client extends Object
  
  
  (slot port)
  
  
  (method override (initialize server-address (port-number: port-number 25) (username: username "") (password: password ""))
    (set! port (open-tcp-client (list
                                  server-address: server-address
                                  port-number: port-number
                                  eol-encoding: 'cr-lf
                                  buffering: 'line
                                  keep-alive: #t)))
    (get-reply "220" #f)
    (display (format "EHLO {a}\n" server-address) port)
    (let* ((commands (cdr (get-reply "250" #f)))
           (login-methods (get-login-methods commands)))
      (cond ((member? "LOGIN" login-methods)
             (auth-login username password))
            ((member? "PLAIN" login-methods)
             (auth-plain username password))
            (else
             (error "No supported login methods")))))
  
  
  (method override (destroy)
    (display "QUIT\n" port)
    (close-port port)
    (nextmethod))
  
  
  (method (get-reply code (invalid #f))
    (let ((reply (read-line port)))
      (if (eof-object? reply)
          (error "Unexpected end of file")
        (unless (string-starts-with? reply code)
          (if invalid
              (invalid)
            (error "Expected {a}, received {a}" code reply)))
        (if (string-starts-with? reply (format "{a}-" code))
            (cons (substring reply 4 (string-length reply))
                  (get-reply code invalid))
          '()))))
  
  
  (method (get-login-methods commands)
    (cdr (split (find commands "AUTH" test: (lambda (target str) (string-starts-with? str target)) return: 'item) " ")))
  
  
  (method (auth-login username password)
    (display "AUTH LOGIN\n" port)
    (get-reply "334")
    (display (ascii-string->base64-string username) port)
    (newline port)
    (get-reply "334" (lambda () (error "Invalid username.")))
    (display (ascii-string->base64-string password) port)
    (newline port)
    (get-reply "235" (lambda () (error "Invalid credentials."))))
  
  
  (method (auth-plain username password)
    (display "AUTH PLAIN\n" port)
    (get-reply "334")
    (display (ascii-string->base64-string 
               (list->string
                 (append '(#\nul) (string->list username) '(#\nul) (string->list password)))) port)
    (newline port)
    (get-reply "235" (lambda ()
                       (throw "Invalid credentials."))))
  
  
  (method (send-mail-string from to mail-string)
    (display "RSET\n" port)
    (get-reply "250")
    
    (display (format "MAIL FROM:<{a}>\n" from) port)
    (get-reply "250" (lambda () (error (format "Error adding sender {a}." from))))
      
    (for-each (lambda (recipient)
                (display (format "RCPT TO: {a}\n" recipient) port)
                (get-reply "250" (lambda () (error (format "Error adding recipient {a}." recipient)))))
              to)
    
    (display "data\n" port)
    (get-reply "354" (lambda () (error "Error sending the message. Server not accepting data.")))
    
    (display mail-string port)
    (display "\n.\n" port)
    (get-reply "250" (lambda () (error "Error sending the message."))))
  
  
  (method (send-mail mail <MIME-Message>)
    (send-mail-string (get-from~ mail) (get-to~ mail) (format-for-delivery~ mail))))
  


(definition public (separate-lines string ch-size)
  (let ((length (string-length string)))
    (let (recurse (index 0))
      (cond ((>= index length)
             "\n")
            ((< (- length index) ch-size)
             (string-append (substring string index length) "\n"))
            (else
             (string-append (substring string index (+ index ch-size))
                            "\n"
                            (recurse (+ index ch-size))))))))


(definition public (file->u8vector file)
  (with-input-from-file (parse~ file)
    (lambda ()
      (define (read-vectors)
        (let* ((vector (make-u8vector 1024))
               (l (read-subu8vector vector 0 1024)))
          (if (zero? l)
              '()
            (u8vector-shrink! vector l)
            (cons vector (read-vectors)))))
      
      (append-u8vectors (read-vectors)))))


(definition public (file->base64-string file)
  (u8vector->base64-string (file->u8vector file)))


(definition public (send-message message server (port-number: port-number 25) (username: username "") (password: password ""))
  (let ((mail-string (format-for-delivery~ message)))
    (let ((client (new SMTP-Client server port-number: port-number username: username password: password)))
      (send-mail-string~ client (get-from~ message) (get-to~ message) mail-string)
      (close~ client))))


(definition public (base64-string->ascii-string str)
  (list->string
    (map
      integer->char
      (u8vector->list
        (base64-string->u8vector str)))))


(definition public (ascii-string->base64-string str)
  (u8vector->base64-string 
    (list->u8vector
      (map char->integer
           (string->list str))))))
