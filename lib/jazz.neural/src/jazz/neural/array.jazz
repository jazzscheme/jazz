;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Neural Network Arrays
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.neural.array jazz


(import (jazz.neural.math))


(definition public (array? obj)
  (vector? obj))


(definition public (make-array rows cols)
  (let ((array (make-vector rows)))
    (loop (for row from 0 below rows)
          (vector-set! array row (make-f64vector cols)))
    array))

(definition public (array-rows array)
  (vector-length array))

(definition public (array-cols array)
  (f64vector-length (vector-ref array 0)))

(definition public (array-shape array)
  (list (array-rows array)
        (array-cols array)))


(definition public (array-copy array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (array-ref array row col))))
      result)))


(definition public (subarray array start (end #f))
  (let ((end (or end (array-rows array))))
    (let ((rows (- end start))
          (cols (array-cols array)))
      (let ((result (make-array rows cols)))
        (loop (for row from 0 below rows)
              (loop (for col from 0 below cols)
                    (array-set! result row col (array-ref array (+ start row) col))))
        result))))


(definition public (array-index array idx)
  (let ((len (length idx))
        (cols (array-cols array)))
    (let ((result (make-array len cols)))
      (loop (for i in idx)
            (for row from 0)
            (loop (for col from 0 below cols)
                  (array-set! result row col (array-ref array i col))))
      result)))


(definition public (array-ref array row col)
  (f64vector-ref (vector-ref array row) col))

(definition public (array-set! array row col val)
  (f64vector-set! (vector-ref array row) col val))

(definition public (array-row array row)
  (vector-ref array row))

(definition public (array-col array col)
  (let ((rows (vector-length array)))
    (let ((vec (make-f64vector rows)))
      (loop (for row from 0 below rows)
            (f64vector-set! vec row (array-ref array row col)))
      vec)))


(definition (vector->array vec rows)
  (let ((cols (f64vector-length vec)))
    (let ((array (make-array rows cols)))
      (loop (for row from 0 below rows)
            (vector-set! array row (f64vector-copy vec)))
      array)))


(definition public (vector-dot x y)
  (let ((result 0.))
    (loop (for n from 0 below (f64vector-length x))
          (increase! result (* (f64vector-ref x n) (f64vector-ref y n))))
    result))


(definition public (array-dot x y)
  (let ((rows (array-rows x))
        (cols (array-cols y)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (vector-dot (array-row x row) (array-col y col)))))
      result)))


(definition public (array-transpose array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array cols rows)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result col row (array-ref array row col))))
      result)))


(definition public (array-mean array)
  (let ((rows (array-rows array))
        (total 0)
        (count 0))
    (loop (for row from 0 below rows)
          (increase! total (array-ref array row 0))
          (increase! count))
    (/ total count)))


(definition public (array-max array (axis: axis 0))
  (case axis
    ((0)
     (let ((rows (array-rows array))
           (cols (array-cols array)))
       (let ((sum (make-array 1 cols)))
         (loop (for col from 0 below cols)
               (array-set! sum 0 col (let ((max -inf.0))
                                       (loop (for row from 0 below rows)
                                             (let ((val (array-ref array row col)))
                                               (when (> val max)
                                                 (set! max val))))
                                       max)))
         sum)))
    ((1)
     (let ((rows (array-rows array))
           (cols (array-cols array)))
       (let ((sum (make-array rows 1)))
         (loop (for row from 0 below rows)
               (array-set! sum row 0 (let ((max -inf.0))
                                       (loop (for col from 0 below cols)
                                             (let ((val (array-ref array row col)))
                                               (when (> val max)
                                                 (set! max val))))
                                       max)))
         sum)))
    (else
     (error "Invalid axis: {s}" axis))))


(definition public (array-sum array (axis: axis 0))
  (case axis
    ((0)
     (let ((rows (array-rows array))
           (cols (array-cols array)))
       (let ((sum (make-array 1 cols)))
         (loop (for col from 0 below cols)
               (array-set! sum 0 col (loop (for row from 0 below rows)
                                           (sum (array-ref array row col)))))
         sum)))
    ((1)
     (let ((rows (array-rows array))
           (cols (array-cols array)))
       (let ((sum (make-array rows 1)))
         (loop (for row from 0 below rows)
               (array-set! sum row 0 (loop (for col from 0 below cols)
                                           (sum (array-ref array row col)))))
         sum)))
    (else
     (error "Invalid axis: {s}" axis))))


(definition public (array+ x y)
  (bind (rows cols) (array-shape x)
    (bind (y-rows y-cols) (array-shape y)
      (assert (= cols y-cols)
        ;; non-general quicky
        (when (and (/= y-rows rows)
                   (= y-rows 1))
          (set! y (vector->array (array-row y 0) rows)))
        (assert (= rows (array-rows y))
          (let ((result (make-array rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (array-set! result row col (+ (array-ref x row col)
                                                      (array-ref y row col)))))
            result))))))


(definition public (array- x y)
  (bind (rows cols) (array-shape x)
    (bind (y-rows y-cols) (array-shape y)
      (assert (= rows y-rows)
        (if (and (/= cols 1) (= y-cols 1))
            (let ((result (make-array rows cols)))
              (loop (for row from 0 below rows)
                    (loop (for col from 0 below cols)
                          (array-set! result row col (- (array-ref x row col)
                                                        (array-ref y row 0)))))
              result)
          (assert (= cols (array-cols y))
            (let ((result (make-array rows cols)))
              (loop (for row from 0 below rows)
                    (loop (for col from 0 below cols)
                          (array-set! result row col (- (array-ref x row col)
                                                        (array-ref y row col)))))
              result)))))))


(definition public (array* x y)
  (bind (rows cols) (array-shape x)
    (bind (y-rows y-cols) (array-shape y)
      (assert (= rows y-rows)
        (assert (= cols y-cols)
          (let ((result (make-array rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (array-set! result row col (* (array-ref x row col)
                                                      (array-ref y row col)))))
            result))))))


(definition public (array/ x y)
  (bind (rows cols) (array-shape x)
    (bind (y-rows y-cols) (array-shape y)
      (assert (= rows y-rows)
        (if (and (/= cols 1) (= y-cols 1))
            (let ((result (make-array rows cols)))
              (loop (for row from 0 below rows)
                    (loop (for col from 0 below cols)
                          (array-set! result row col (/ (array-ref x row col)
                                                        (array-ref y row 0)))))
              result)
          (assert (= cols y-cols)
            (let ((result (make-array rows cols)))
              (loop (for row from 0 below rows)
                    (loop (for col from 0 below cols)
                          (array-set! result row col (/ (array-ref x row col)
                                                        (array-ref y row col)))))
              result)))))))


(definition public (array-scalar+ scalar array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (+ scalar (array-ref array row col)))))
      result)))


(definition public (array-scalar- scalar array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (- scalar (array-ref array row col)))))
      result)))


(definition public (array-scalar* scalar array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (* scalar (array-ref array row col)))))
      result)))


(definition public (array-scalar/ scalar array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (/ scalar (array-ref array row col)))))
      result)))


(definition public (array-negate array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (- (array-ref array row col)))))
      result)))


(definition public (array-sqrt array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (sqrt (array-ref array row col)))))
      result)))


(definition public (array-expt array power)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (expt (array-ref array row col) power))))
      result)))


(definition public (array-exp array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (exp (array-ref array row col)))))
      result)))


(definition public (array-log array)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (log (array-ref array row col)))))
      result)))


(definition public (array-clip array min max)
  (let ((rows (array-rows array))
        (cols (array-cols array)))
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (array-set! result row col (between min (array-ref array row col) max))))
      result)))


(definition public (random-unit-vector cols)
  (let ((vec (make-f64vector cols)))
    (loop (for col from 0 below cols)
          (f64vector-set! vec col (random-unit)))
    vec))


(definition public (random-between-vector cols min <fl> max <fl>)
  (let ((vec (make-f64vector cols)))
    (loop (for col from 0 below cols)
          (f64vector-set! vec col (random-between min max)))
    vec))


(definition public (random-array rows cols (min #f) (max #f))
  (let ((array (make-vector rows)))
    (loop (for row from 0 below rows)
          (vector-set! array row (if min
                                     (random-between-vector cols min max)
                                   (random-unit-vector cols))))
    array))


(definition (->shape rest)
  (case (length rest)
    ((1) (car rest))
    ((2) rest)
    (else (error "Ill-formed shape: {l}" rest))))


(definition public (zero-vector cols)
  (make-f64vector cols 0.))


(definition public (zero-array . rest)
  (bind (rows cols) (->shape rest)
    (let ((array (make-vector rows)))
      (loop (for row from 0 below rows)
            (vector-set! array row (zero-vector cols)))
      array)))


(definition public (array-map1 proc x)
  (bind (rows cols) (array-shape x)
    (let ((result (make-array rows cols)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (let ((x-value (array-ref x row col)))
                    (array-set! result row col (exact->inexact (proc x-value))))))
      result)))


(definition public (array-map2 proc x y)
  (bind (rows cols) (array-shape x)
    (bind (y-rows y-cols) (array-shape y)
      (assert (= rows y-rows)
        (assert (= cols y-cols)
          (let ((result (make-array rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (let ((x-value (array-ref x row col))
                              (y-value (array-ref y row col)))
                          (array-set! result row col (exact->inexact (proc x-value y-value))))))
            result))))))


;;;
;;;; Print
;;;


(definition public (print-vector vec (output :terminal))
  (format output "[")
  (let ((cols (f64vector-length vec)))
    (define (print-col col)
      (when (/= col 0)
        (format output " "))
      (let ((val (f64vector-ref vec col)))
        (if (>= val 0.)
            (format output " ")
          (format output "-")
          (set! val (- val)))
        (when (< val 1.)
          (format output "0"))
        (format output "{r precision: 3 justify: :right width: 3}" val)))
    
    (if (<= cols 10)
        (loop (for col from 0 below cols)
              (print-col col))
      (loop (for col from 0 below 5)
            (print-col col))
      (format output " ...")
      (loop (for col from (- cols 5) below cols)
            (print-col col))))
  (format output "]"))


(definition public (print-array array (output :terminal))
  (let ((rows (vector-length array)))
    (define (print-row row)
      (if (= row 0)
          (format output "[")
        (format output " "))
      (let ((vec (vector-ref array row)))
        (print-vector vec output)
        (if (= row (- rows 1))
            (format output "]")
          (format output "{%}"))))
    
    (if (<= rows 20)
        (loop (for row from 0 below rows)
              (print-row row))
      (loop (for row from 0 below 10)
            (print-row row))
      (format output " ...{%}")
      (loop (for row from (- rows 10) below rows)
            (print-row row)))))


(definition public (present-array array)
  (let ((port (open-output-string)))
    (print-array array port)
    (get-output-string port))))
