;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Tensors
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.neural.tensor jazz


(import (jazz.foreign)
        (jazz.listener)
        (jazz.neural.blas)
        (jazz.neural.math)
        (jazz.platform.types)
        (jazz.settings))


(proclaim (not check bounds types)
          (warn optimizations))


;;;
;;;; Foreign
;;;


@nonblocking (
(c-include "<glib.h>")
(c-include "<unistd.h>")


(c-declare jazz.neural.tensor #/C/
#ifdef BLIS_H
    #include <blis.h>
#else
    #include <cblas.h>
#endif

static void gst_listener_set(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "!", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "!", 1);
#endif
}

typedef struct dgemm_call_struct
{
    int a_rows;
    int b_cols;
    int a_cols;
    double* a;
    double* b;
    double* c;
    void* listener;
    GThread* thread;
} dgemm_call;

static void* call_dgemm(void* data)
{
    dgemm_call* dc = (dgemm_call*) data;

    int a_rows = dc->a_rows;
    int b_cols = dc->b_cols;
    int a_cols = dc->a_cols;
    int a_stride = a_cols;
    int b_stride = b_cols;
    int c_stride = b_cols;

    void* listener = dc->listener;
  
    cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, a_rows, b_cols, a_cols, 1.0, dc->a, a_stride, dc->b, b_stride, 0.0, dc->c, c_stride);
    
    gst_listener_set(listener);
  
    return NULL;
}

static void* cblas_dgemm_threaded(int a_rows, int b_cols, int a_cols, ___SCMOBJ a, int a_offset, ___SCMOBJ b, ___SCMOBJ c, int c_offset, void* listener)
{
    dgemm_call* dc = malloc(sizeof(dgemm_call));
    dc->a_rows = a_rows;
    dc->b_cols = b_cols;
    dc->a_cols = a_cols;
    dc->a = ___CAST(___F64*,___BODY(a)) + a_offset;
    dc->b = ___CAST(___F64*,___BODY(b));
    dc->c = ___CAST(___F64*,___BODY(c)) + c_offset;
    dc->listener = listener;
    dc->thread = g_thread_new("dgemm_call", call_dgemm, (void*) dc);
    
    return (void*) dc;
}

static void cblas_dgemm_free(void* data)
{
    dgemm_call* dc = (dgemm_call*) data;
    g_thread_join(dc->thread);
    g_thread_unref(dc->thread);
    free(data);
}
//#)


(c-external (cblas_dgemm_threaded int int int scheme-object int scheme-object scheme-object int void*) void*)
(c-external (cblas_dgemm_free void*) void)


(definition cblas-listener
  #f)

(definition (require-cblas-listener)
  (or cblas-listener
      (let ((listener (open-stream-listener)))
        (set! cblas-listener listener)
        listener)))


(definition public (call-dgemm a-rows b-cols a-cols a b c)
  (let ((listener (require-cblas-listener)))
    (let ((data (cblas_dgemm_threaded a-rows b-cols a-cols a 0 b c 0 (get-write-file listener))))
      (wait listener)
      (cblas_dgemm_free data)))))


;;;
;;;; Tensor
;;;


(class Tensor extends Object
  
  
  (slot rows <fx>        getter generate)
  (slot cols <fx>        getter generate)
  (slot data <f64vector> getter generate)
  
  
  (method override (initialize self rows cols)
    (set! self.rows rows)
    (set! self.cols cols)
    (set! self.data (make-f64vector (* rows cols))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a} {a}" rows cols))))
  
  
  (method (get-size self) <fx>
    (* rows cols)))


(definition inline (tidx cols <fx> row <fx> col <fx>) <fx>
  (+ (* row cols) col))


(definition public (tensor vec) <Tensor>
  (let ((rows (vector-length vec))
        (cols (f64vector-length (vector-ref vec 0))))
    (let ((tensor (new Tensor rows cols)))
      (let ((data (get-data tensor)))
        (loop (for row from 0 below rows)
              (loop (for col from 0 below cols)
                    (f64vector-set! data (tidx cols row col) (f64vector-ref (vector-ref vec row) col)))))
      tensor)))


(definition public (tensor? obj)
  (is? obj Tensor))


(definition public (make-tensor rows <fx> cols <fx>) <Tensor>
  (new Tensor rows cols))

(definition public (tensor-rows tensor <Tensor>) <fx>
  (get-rows tensor))

(definition public (tensor-cols tensor <Tensor>) <fx>
  (get-cols tensor))

(definition public (tensor-size tensor <Tensor>) <fx>
  (get-size tensor))

(definition public (tensor-shape tensor <Tensor>)
  (list (get-rows tensor)
        (get-cols tensor)))


(definition public inline (tensor-ref tensor <Tensor> row <fx> col <fx>) <fl>
  (f64vector-ref (get-data tensor) (tidx (get-cols tensor) row col)))

(definition public inline (tensor-set! tensor <Tensor> row <fx> col <fx> val <fl>)
  (f64vector-set! (get-data tensor) (tidx (get-cols tensor) row col) val))


(definition public (tensor-copy tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (f64vector-ref data n))))
      result)))


(definition public (subtensor tensor <Tensor> start <fx> (end <fx+> #f)) <Tensor>
  (let ((end (or end (tensor-rows tensor))))
    (let ((rows (- end start))
          (cols (tensor-cols tensor)))
      (let ((result (make-tensor rows cols)))
        (loop (for row from 0 below rows)
              (loop (for col from 0 below cols)
                    (tensor-set! result row col (tensor-ref tensor (+ start row) col))))
        result))))


(definition public (tensor-index tensor <Tensor> idx) <Tensor>
  (let ((len (length idx))
        (cols (tensor-cols tensor)))
    (let ((result (make-tensor len cols)))
      (loop (for i in idx)
            (for row from 0)
            (loop (for col from 0 below cols)
                  (tensor-set! result row col (tensor-ref tensor i col))))
      result)))


(definition public (tensor-dot x <Tensor> y <Tensor> (blas #f)) <Tensor>
  (let ((x-rows (tensor-rows x))
        (x-cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= x-cols y-rows)
      (let ((result (make-tensor x-rows y-cols)))
        @nonblocking
        (call-dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result))
        (case (or blas default-blas)
          ((accelerate)
           (jazz.neural.blas.accelerate:cblas_dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result)))
          ((blis)
           (jazz.neural.blas.blis:cblas_dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result)))
          ((openblas)
           (jazz.neural.blas.openblas:cblas_dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result)))
          ((npopenblas)
           (jazz.neural.blas.npopenblas:cblas_dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result)))
          (else
           (loop (for row from 0 below x-rows)
                 (loop (for col from 0 below y-cols)
                       (tensor-set! result row col (let ((result 0.))
                                                     (loop (for n from 0 below x-cols)
                                                           (increase! result (* (tensor-ref x row n) (tensor-ref y n col))))
                                                     result))))))
        result))))


@wait
(definition public (tensor-dot! x <Tensor> y <Tensor> result <Tensor>) <Tensor>
  (let ((x-rows (tensor-rows x))
        (x-cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= x-cols y-rows)
      (cblas_dgemm x-rows y-cols x-cols (get-data x) (get-data y) (get-data result))
      result)))


(definition public (tensor-transpose tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor)))
    (let ((result (make-tensor cols rows)))
      (loop (for row from 0 below rows)
            (loop (for col from 0 below cols)
                  (tensor-set! result col row (tensor-ref tensor row col))))
      result)))


(definition public (tensor-mean tensor <Tensor>) <fl>
  (let ((rows (tensor-rows tensor))
        (total 0.)
        (count 0))
    (loop (for row from 0 below rows)
          (increase! total (tensor-ref tensor row 0))
          (increase! count))
    (/ total (cast <fl> count))))


(definition public (tensor-max tensor <Tensor> (axis: axis 0)) <Tensor>
  (case axis
    ((0)
     (let ((rows (tensor-rows tensor))
           (cols (tensor-cols tensor)))
       (let ((sum (make-tensor 1 cols)))
         (loop (for col from 0 below cols)
               (tensor-set! sum 0 col (let ((max -inf.0))
                                        (loop (for row from 0 below rows)
                                              (let ((val (tensor-ref tensor row col)))
                                                (when (> val max)
                                                  (set! max val))))
                                        max)))
         sum)))
    ((1)
     (let ((rows (tensor-rows tensor))
           (cols (tensor-cols tensor)))
       (let ((sum (make-tensor rows 1)))
         (loop (for row from 0 below rows)
               (tensor-set! sum row 0 (let ((max -inf.0))
                                        (loop (for col from 0 below cols)
                                              (let ((val (tensor-ref tensor row col)))
                                                (when (> val max)
                                                  (set! max val))))
                                        max)))
         sum)))
    (else
     (error "Invalid axis: {s}" axis))))


(definition public (tensor-argmax tensor <Tensor> (axis: axis 1)) <Tensor>
  (case axis
    ((1)
     (let ((rows (tensor-rows tensor))
           (cols (tensor-cols tensor)))
       (let ((indices (make-vector rows)))
         (loop (for row from 0 below rows)
               (let ((max -inf.0))
                 (loop (for col from 0 below cols)
                       (let ((val (tensor-ref tensor row col)))
                         (when (> val max)
                           (set! max val)
                           (vector-set! indices row col))))))
         indices)))
    (else
     (error "Invalid axis: {s}" axis))))


(definition public (tensor-sum tensor <Tensor> (axis: axis 0)) <Tensor>
  (case axis
    ((0)
     (let ((rows (tensor-rows tensor))
           (cols (tensor-cols tensor)))
       (let ((sum (make-tensor 1 cols)))
         (loop (for col from 0 below cols)
               (tensor-set! sum 0 col (loop (for row from 0 below rows)
                                            (sum (tensor-ref tensor row col)))))
         sum)))
    ((1)
     (let ((rows (tensor-rows tensor))
           (cols (tensor-cols tensor)))
       (let ((sum (make-tensor rows 1)))
         (loop (for row from 0 below rows)
               (tensor-set! sum row 0 (loop (for col from 0 below cols)
                                            (sum (tensor-ref tensor row col)))))
         sum)))
    (else
     (error "Invalid axis: {s}" axis))))


(definition public (tensor+ x <Tensor> y <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= cols y-cols)
      (if (and (/= y-rows rows)
               (= y-rows 1))
          (let ((result (make-tensor rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (tensor-set! result row col (+ (tensor-ref x row col)
                                                       (tensor-ref y 0 col)))))
            result)
        (assert (= rows y-rows)
          (let ((result (make-tensor rows cols)))
            (let ((size (tensor-size x))
                  (x-data (get-data x))
                  (y-data (get-data y))
                  (r-data (get-data result)))
              (loop (for n from 0 below size)
                    (f64vector-set! r-data n (+ (f64vector-ref x-data n)
                                                (f64vector-ref y-data n)))))
            result))))))


(definition public (tensor- x <Tensor> y <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= rows y-rows)
      (if (and (/= cols 1) (= y-cols 1))
          (let ((result (make-tensor rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (tensor-set! result row col (- (tensor-ref x row col)
                                                       (tensor-ref y row 0)))))
            result)
        (assert (= cols (tensor-cols y))
          (let ((result (make-tensor rows cols)))
            (let ((size (tensor-size x))
                  (x-data (get-data x))
                  (y-data (get-data y))
                  (r-data (get-data result)))
              (loop (for n from 0 below size)
                    (f64vector-set! r-data n (- (f64vector-ref x-data n)
                                                (f64vector-ref y-data n)))))
            result))))))


(definition public (tensor* x <Tensor> y <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= rows y-rows)
      (assert (= cols y-cols)
        (let ((result (make-tensor rows cols)))
          (let ((size (tensor-size x))
                (x-data (get-data x))
                (y-data (get-data y))
                (r-data (get-data result)))
            (loop (for n from 0 below size)
                  (f64vector-set! r-data n (* (f64vector-ref x-data n)
                                              (f64vector-ref y-data n)))))
          result)))))


(definition public (tensor/ x <Tensor> y <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= rows y-rows)
      (if (and (/= cols 1) (= y-cols 1))
          (let ((result (make-tensor rows cols)))
            (loop (for row from 0 below rows)
                  (loop (for col from 0 below cols)
                        (tensor-set! result row col (/ (tensor-ref x row col)
                                                       (tensor-ref y row 0)))))
            result)
        (assert (= cols y-cols)
          (let ((result (make-tensor rows cols)))
            (let ((size (tensor-size x))
                  (x-data (get-data x))
                  (y-data (get-data y))
                  (r-data (get-data result)))
              (loop (for n from 0 below size)
                    (f64vector-set! r-data n (/ (f64vector-ref x-data n)
                                                (f64vector-ref y-data n)))))
            result))))))


(definition public (tensor-scalar+ scalar <fl> tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (+ scalar (f64vector-ref data n)))))
      result)))


(definition public (tensor-scalar- scalar <fl> tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (- scalar (f64vector-ref data n)))))
      result)))


(definition public (tensor-scalar* scalar <fl> tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (* scalar (f64vector-ref data n)))))
      result)))


(definition public (tensor-scalar/ scalar <fl> tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (/ scalar (f64vector-ref data n)))))
      result)))


(definition public (tensor-negate tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (- (f64vector-ref data n)))))
      result)))


(definition public (tensor-sqrt tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (sqrt (f64vector-ref data n)))))
      result)))


(definition public (tensor-expt tensor <Tensor> power <fx>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (expt (f64vector-ref data n) power))))
      result)))


(definition public (tensor-exp tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (exp (f64vector-ref data n)))))
      result)))


(definition public (tensor-log tensor <Tensor>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (log (f64vector-ref data n)))))
      result)))


(definition public (tensor-clip tensor <Tensor> min <fl> max <fl>) <Tensor>
  (let ((rows (tensor-rows tensor))
        (cols (tensor-cols tensor))
        (size (tensor-size tensor)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (r-data (get-data result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (between min (f64vector-ref data n) max))))
      result)))


(definition public (random-tensor rows <fx> cols <fx> (min #f) (max #f)) <Tensor>
  (let ((tensor (make-tensor rows cols)))
    (let ((data (get-data tensor))
          (size (tensor-size tensor)))
      (loop (for n from 0 below size)
            (f64vector-set! data n (if min
                                       (random-between min max)
                                     (random-unit)))))
    tensor))


(definition (->shape rest)
  (case (length rest)
    ((1) (car rest))
    ((2) rest)
    (else (error "Ill-formed shape: {l}" rest))))


(definition public (zero-tensor . rest) <Tensor>
  (bind (rows cols) (->shape rest)
    (let ((tensor (make-tensor rows cols)))
      (let ((data (get-data tensor))
            (size (tensor-size tensor)))
        (loop (for n from 0 below size)
              (f64vector-set! data n 0.)))
      tensor)))


(definition public (tensor-map1 proc x <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x)))
    (let ((result (make-tensor rows cols)))
      (let ((data (get-data x))
            (r-data (get-data result))
            (size (get-size result)))
        (loop (for n from 0 below size)
              (f64vector-set! r-data n (exact->inexact (proc (f64vector-ref data n))))))
      result)))


(definition public (tensor-map2 proc x <Tensor> y <Tensor>) <Tensor>
  (let ((rows (tensor-rows x))
        (cols (tensor-cols x))
        (y-rows (tensor-rows y))
        (y-cols (tensor-cols y)))
    (assert (= rows y-rows)
      (assert (= cols y-cols)
        (let ((result (make-tensor rows cols)))
          (let ((x-data (get-data x))
                (y-data (get-data y))
                (r-data (get-data result))
                (size (get-size result)))
            (loop (for n from 0 below size)
                  (f64vector-set! r-data n (exact->inexact (proc (f64vector-ref x-data n)
                                                                 (f64vector-ref y-data n))))))
          result)))))


;;;
;;;; Print
;;;


(definition (print-tensor-row tensor <Tensor> row (output :terminal))
  (format output "[")
  (let ((cols (tensor-cols tensor)))
    (define (print-col col)
      (when (/= col 0)
        (format output " "))
      (let ((val (tensor-ref tensor row col)))
        (if (>= val 0.)
            (format output " ")
          (format output "-")
          (set! val (- val)))
        (when (< val 1.)
          (format output "0"))
        (format output "{r precision: 3 justify: :right width: 3}" val)))
    
    (if (<= cols 10)
        (loop (for col from 0 below cols)
              (print-col col))
      (loop (for col from 0 below 5)
            (print-col col))
      (format output " ...")
      (loop (for col from (- cols 5) below cols)
            (print-col col))))
  (format output "]"))


(definition public (print-tensor tensor <Tensor> (output :terminal))
  (let ((rows (tensor-rows tensor)))
    (define (print-row row)
      (if (= row 0)
          (format output "[")
        (format output " "))
      (print-tensor-row tensor row output)
      (if (= row (- rows 1))
          (format output "]")
        (format output "{%}")))
    
    (if (<= rows 20)
        (loop (for row from 0 below rows)
              (print-row row))
      (loop (for row from 0 below 10)
            (print-row row))
      (format output " ...{%}")
      (loop (for row from (- rows 10) below rows)
            (print-row row)))))


(definition public (present-tensor tensor <Tensor>)
  (let ((port (open-output-string)))
    (print-tensor tensor port)
    (get-output-string port))))
