;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Optimize Syntax
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.optimize.syntax jazz


(import (jazz.core (phase syntax))
        (jazz.dialect.classes.foundation))

(import (fmt (except fl upcase downcase))
        (fmt.fmt-c))


;; TODO
;; - compare performance of
;;   - pure gambit compilation
;;   - optimize using c-lambda
;;   - optimize using c-code
;; - defoptimize
;;   - generate C-level fn
;;   - generate Lisp wrapper
;;   - generate C linking code
;;     - probably through a global vector in the Jazz kernel that is
;;       populated and accessed by static code. note that we should be
;;       able to create a C global variable for every fn called from
;;       another module. note that this is really similar to what
;;       Gambit does for linking user code
;;   - I think the Lisp side should only generate fn and no fn! and fn&
;;     as in a thread-safe world there is no sensible place we can pass
;;     to fn! to put the result. All critical pieces should then be
;;     wrapped in an optimize

;; SUPPORT
;; - fx& make-fx& (obsolete)
;; - f32& f64& make-f32& make-f64& (obsolete)
;; ! = /= < <= > >= (TODO: /= is an inline function, not primitive)
;; ! + - * /
;; ! modulo bitwise-and ...
;; ! set!
;; !~ let let* ...
;; !~ if cond case ...
;; - (cast <fx> <fl> ...)
;; - (get-slot~ obj)
;; - (fn a b c)
;; ! (for (init test update) body)
;; * f64vector-ref f64vector-set! ...
;;   --> see gambit ch. 10
;; - macro calls
;; - inline calls
;; - cffi calls like randomInt
;; - internal defines like evaluate-morph
;; ! constants
;; - continuation-capture/return that becomes break, continue, ...
;; 2 vertex&, matrix&, ... e.g. type extensible (together with next)
;;    --> vertex is f64vector[3], matrix is f64vector[16]
;; 2 fn fn! fn& constant space and thread-safe
;; - typed variables like <fx> <fl> ...
;; - set! gambit boxing
;; - (cast <Tangent> <KeyFrame> ...)
;; - and or
;; - allege
;; 2 defoptimize (no linking by putting all code in same module)
;; 3 linking

;; KNOWLEDGE
;; - ___argn is a macro that refers to the Scheme stack and so should be
;;   updated when a gc occurs. we should be able to use this to reacquire
;;   entry parameters after a call to the Lisp world
;; - it is not possible to make callbacks from inside a ##c-code (validate
;;   that this is really the case) as some work c-lambda does is skipped
;; - according to Marc, callbacks could be done efficiently by having a
;;   c-define for each type signatures, like callback-int/int-int!?

;; THINK
;; - need to think about a satisfactory solution for non-compiled code
;;   for example for a user not have installed gcc
;;   - maybe we should keep (hidden!?) the lisp-level fn fn! fn& the main
;;     problem being that they are not thread-safe
;;   - spectrum: C - optimize generated C code - hand optimized Lisp code (fn fn! fn&) - pure Lisp code
;; - when generating C code, never forget
;;   - independant compilation
;;   - dynamic evaluation

;; IDEAS
;; - do without the type prefixes!?
;;   - for example (+ vert1 (scalar* vert2 2.3))
;; - enable optimize at a higher level where it will automatically determine
;;   what parts of its tree should be optimized. and then maybe optimize based
;;   on a proclaim
;; - can optimize fix the annoying having to (+ (cast <fl> n) y) and having
;;   to (+ y 1.0) instead of just (+ y 1)
;; - support for hand-coded embedded C code!?
;; - can optimize give use abstract vertex, matrix, ... types!?
;; - maybe disable interrupts when doing a callback!? (hmmm I do not think this
;;   really solves the gc moving objects around problem as a gc could still occur)
;; - for the interpreted expansion, maybe disable interrupts to make the fn&
;;   approach thread-safe!?
;; - generate c-lambda or ##c-code based on the presence of callbacks!?
;; - add gcc flags like -O3 or even more specific ones!?

;; LAYERS
;; - Pure Lisp
;; - Optimized using types to generate
;;   - ## low-level code
;;   - C code using Gambit's CFFI

;; MODULES
;; - (geometry) world.geometry world.geometry.base world.polygon
;; - (generation) world.procedural world.biome
;; - (animation) world.animation
;; - (collision) world.collision

;; FUNCTIONS
;; - ray-triangle-distance!

;; TYPES
;; - bool
;; - fx
;; - fl
;; - homogeneous vectors
;; - vertex fl(3)
;; - quaternion fl(4)
;; - matrix fl(16)
;; - LookAt vertex vertex vertex
;; - Movement vertex vertex vertex fl
;; - Plane vertex vertex
;; - Polygon plane object vertex(n) fl fl fl fl fl
;;   - Triangle Quad
;; - values !?
;; - type+

;; HOMOGENEOUS
;; - ___F64* content = ___CAST(___F64*, ___BODY(___arg1));
;; - allocate a new f64vector of count elements
;;   ___SCMOBJ r = ___EXT(___alloc_scmobj) (NULL, ___sF64VECTOR, count*sizeof(___F64));
;;   ___F64* ptr = ___CAST(___F64*, ___BODY(r));
;;   fill / copy / ... the content using ptr
;;   ___result = r;
;;   ___EXT(___release_scmobj)(r);


;; hack around calling emit-expression from within an emit-expression method
(native jazz:emit-expr)


;;;
;;;; Emit
;;;


(definition (emit-optimize body declaration environment backend (defoptimize? #f))
  (let ((free '())
        (bailout? #f))
    (define (emit-list lst env tail?)
      (cond ((null? lst)
             '())
            ((null? (cdr lst))
             (list (emit (car lst) env tail?)))
            (else
             (cons (emit (car lst) env #f)
                   (emit-list (cdr lst) env tail?)))))
    
    (define (emit expr env tail?)
      (typecase expr
        ((Constant) (emit-constant expr env tail?))
        ((Call) (emit-call expr env tail?))
        ((Binding-Reference) (emit-reference expr env tail?))
        ((Let) (emit-let expr env tail?))
        ((Letstar) (emit-letstar expr env tail?))
        ((Body) (emit-body expr env tail?))
        ((Begin) (emit-begin expr env tail?))
        ((And) (emit-and expr env tail?))
        ((Or) (emit-or expr env tail?))
        ((If) (emit-if expr env tail?))
        ((For) (emit-for expr env tail?))
        ((Assignment) (emit-assignment expr env tail?))
        ((Dispatch) (emit-dispatch expr env tail?))
        ((Cast) (emit-cast expr env tail?))
        (else (emit-unsupported expr))))
    
    (define (emit-constant expr env tail?)
      (emit-tail (source-code (get-expansion~ expr)) tail?))
    
    (define (emit-call expr env tail?)
      (let ((operator (get-operator~ expr))
            (arguments (get-arguments~ expr)))
        (let ((binding (and (is? operator Binding-Reference) (get-binding~ operator))))
          (cond ((is? binding Export-Declaration)
                 (emit-export-call binding arguments env tail?))
                ((is? binding Definition-Optimize-Declaration)
                 (emit-defoptimize-call binding arguments env tail?))
                ((is? binding Definition-Declaration)
                 (emit-definition-call binding arguments env tail?))
                (else
                 (bailout `(unable-to-optimize ,operator)))))))
    
    (define (emit-export-call binding arguments env tail?)
      (let ((symbol (get-symbol~ binding)))
        (let ((primitive (primitive-reference symbol)))
          (cond (primitive
                 (emit-tail `(,primitive ,@(emit-list arguments env #f)) tail?))
                ((eq? symbol 's32vector-ref)
                 (emit-tail `(vector-ref ,@(emit-list arguments env #f)) tail?))
                ((eq? symbol 's32vector-set!)
                 (emit-tail `(vector-set! ,@(emit-list arguments env #f)) tail?))
                ((eq? symbol 'f64vector-ref)
                 (emit-tail `(vector-ref ,@(emit-list arguments env #f)) tail?))
                ((eq? symbol 'f64vector-set!)
                 (emit-tail `(vector-set! ,@(emit-list arguments env #f)) tail?))
                (else
                 (bailout `(export-call-not-implemented ,symbol)))))))
    
    (define (emit-defoptimize-call binding arguments env tail?)
      (emit-tail `(,(name->c (get-name~ binding)) ,@(emit-list arguments env #f)) tail?))
    
    (define (emit-definition-call binding arguments env tail?)
      (let ((name (get-name~ binding)))
        (let ((primitive (primitive-reference name)))
          (if primitive
              (emit-tail `(,primitive ,@(emit-list arguments env #f)) tail?)
            (let ((value (get-value~ binding)))
              (if #f @nice-try-but-doesnt-work-as-is-with-c
                  (and (is? value Lambda)
                       (eq? (get-expansion~ binding) 'inline))
                  (emit-inline-call binding arguments env tail?)
                (bailout `(definition-call-not-implemented ,name))))))))
    
    (define (emit-inline-call binding arguments env tail?)
      (let ((signature (get-signature~ binding))
            (value (get-value~ binding)))
        (let ((bindings (map (lambda (parameter argument)
                               (cons parameter argument))
                             (get-positional~ signature)
                             arguments))
              (body (get-body~ value)))
          (emit (new Let bindings body) env tail?))))

    (define (primitive-reference name)
      (let ((pair (assq name primitives)))
        (if pair
            (cdr pair)
          #f)))
    
    (define (emit-tail expr tail?)
      (if (and tail? (not defoptimize?))
          `(___return ,expr)
        expr))
    
    (define (emit-reference expr env tail?)
      (let ((binding (get-binding~ expr)))
        (cond ((is? binding Variable)
               (let ((name (name->c (get-name~ binding))))
                 (when (find-annotated binding environment)
                   (unless (memq? binding free)
                     (set! free (cons binding free))))
                 (emit-tail name tail?)))
              ((is? binding Definition-Optimize-Declaration)
               (if (is? (get-value~ binding) Constant)
                   (name->c (get-name~ binding))
                 (bailout `(unsupported-reference ,binding))))
              (else
               (bailout `(unsupported-reference ,binding))))))
    
    (define (emit-let expr env tail?)
      (annotate-let expr declaration env backend
        (lambda (augmented-environment)
          (let ((bindings (get-bindings~ expr))
                (body (get-body~ expr)))
            `(%begin
               ,@(map (lambda (binding)
                        (let ((variable (car binding))
                              (value (cdr binding)))
                          (let ((type (find-annotated-type variable augmented-environment)))
                            `(%var ,(safe-type->c type) ,(get-name~ variable) ,(emit value augmented-environment #f)))))
                      bindings)
               ,@(emit body augmented-environment tail?))))))
    
    (define (emit-letstar expr env tail?)
      ;stub
      )
    
    (define (emit-body expr env tail?)
      (let ((expressions (get-expressions~ expr)))
        (emit-list expressions env tail?)))
    
    (define (emit-begin expr env tail?)
      (let ((expressions (get-expressions~ expr)))
        `(%begin ,@(emit-list expressions env tail?))))
    
    (define (emit-and expr env tail?)
      `(%and ,@(emit-list (get-expressions~ expr) env tail?)))
    
    (define (emit-or expr env tail?)
      `(%or ,@(emit-list (get-expressions~ expr) env tail?)))
    
    (define (emit-if expr env tail?)
      (let ((test (get-test~ expr))
            (yes (get-yes~ expr))
            (no (get-no~ expr)))
        `(if ,(emit test env #f)
             ,(emit yes env tail?)
           ,(emit no env tail?))))
    
    (define (emit-for expr env tail?)
      (let ((variable (get-variable~ expr)))
        (let ((var (get-name~ variable))
              (type (get-type~ (emit-expr (get-init~ expr) declaration env backend))))
          (let ((init (emit (get-init~ expr) env #f)))
            (with-annotated-frame (annotate-bindings (list (list variable)))
              (lambda (frame)
                (let ((augmented-environment (cons frame environment)))
                  (let ((test (emit (get-test~ expr) augmented-environment #f))
                        (update (emit (get-update~ expr) augmented-environment #f))
                        (body (emit-list (get-body~ expr) augmented-environment #f)))
                    `(%begin
                       (%var ,(safe-type->c type) ,var)
                       (for (= ,var ,init) ,test ,update
                         ,@body))))))))))
    
    (define (emit-assignment expr env tail?)
      (let ((binding (get-binding~ expr))
            (value (get-value~ expr)))
        `(= ,(get-name~ binding) ,(emit value env #f))))
    
    (define (emit-dispatch expr env tail?)
      (bailout `(todo ,expr))
      @todo
      (let ((object-argument (car (get-arguments~ expr))))
        (let ((object-type (get-type~ (emit-expr object-argument declaration env backend))))
          (let ((optimize (find-class-optimize object-type)))
            (if (not optimize)
                (bailout `(not-class-optimize ,(get-name~ object-type)))
              (debug optimize)
              (bailout `(todo ,expr)))))))
    
    (define (emit-cast expr env tail?)
      `(%cast ,(type->c (get-type~ expr)) ,(emit (get-expression~ expr) env tail?)))
    
    (define (emit-unsupported expr)
      (bailout `(unsupported ,expr)))
    
    (define (bailout expr)
      (set! bailout? #t)
      expr)
    
    (define (safe-type->lisp type)
      (or (type->lisp type)
          (bailout `(unknown-lisp-type ,type))))
    
    (define (safe-type->c type)
      (or (type->c type)
          (bailout `(unknown-c-type ,type))))
    
    (define (wrap code)
      (let ((free (reverse free)))
        (let ((expr `(%begin
                       ,@(map (lambda (binding rank)
                                (let ((name (name->c (get-name~ binding)))
                                      (type (find-annotated-type binding environment)))
                                  (cond ((is? type S32Vector-Class)
                                         `(%var ___S32* ,name (___CAST ___S32* (___BODY ,(string->symbol (format "___arg{a}" rank))))))
                                        ((is? type F64Vector-Class)
                                         `(%var ___F64* ,name (___CAST ___F64* (___BODY ,(string->symbol (format "___arg{a}" rank))))))
                                        (else
                                         `(%var ,(safe-type->c type) ,name ,(string->symbol (format "___arg{a}" rank)))))))
                              free
                              (naturals 1 (+ (length free) 1)))
                       ,@code)))
          (let ((code (c-expr/sexp expr))
                (statements-code (emit-statements-code body declaration environment backend)))
            (let ((return-type (get-type~ statements-code)))
              (let ((lisp-return-type (type->lisp return-type)))
                (when (not lisp-return-type)
                  (debug 'unsupported-return-type return-type)
                  (newline))
                ;(pp expr) (newline)
                (fmt #t code) (newline)
                (if bailout?
                    `(begin ,@(get-form~ statements-code))
                  `((c-lambda ,(map (lambda (binding)
                                      (let ((name (name->c (get-name~ binding)))
                                            (type (find-annotated-type binding environment)))
                                        (cond ((is? type S32Vector-Class)
                                               'scheme-object)
                                              ((is? type F64Vector-Class)
                                               'scheme-object)
                                              (else
                                               (safe-type->lisp type)))))
                                    free)
                        ,lisp-return-type
                      ,(fmt #f "" code))
                    ,@(map get-name~ free)))))))))
    
    (let ((code (emit-list body environment #t)))
      (if defoptimize?
          code
        (wrap code)))))


(definition (emit-defoptimize-constant name type constant declaration environment backend)
  (let ((name (name->c name))
        (value (source-code (cadr (get-expansion~ constant)))))
    (define (extract)
      (cond ((f64vector? value)
             (values 'double (f64vector-length value) (coerce value Vector)))
            (else
             (values #f #f #f))))
    
    (receive (type size initializer) (extract)
      (if type
          (let ((expr `(%var (%array ,type ,size) ,name ,initializer)))
            (let ((code (c-expr/sexp expr)))
              (fmt #t code) (newline)
              `(c-declare ,(fmt #f "" code))))
        (error "Unsupported optimize constant: {s}" value)))))
        


(definition (emit-defoptimize-function name signature return-type body expansion declaration environment backend)
  (let ((body (emit-optimize (get-expressions~ body) declaration environment backend #t)))
    (let ((arguments (map (lambda (parameter)
                            (list (type->c (get-type~ parameter)) (name->c (get-name~ parameter))))
                          (get-positional~ signature)))
          (return-type (type->c return-type)))
      (let ((expr `(%fun ,return-type ,(name->c name) ,arguments ,@body)))
        (let ((expr (if (eq? expansion 'inline) `(inline ,expr) expr)))
          (let ((code (c-expr/sexp expr)))
            (fmt #t code) (newline)
            `(c-declare ,(fmt #f "" code))))))))


(definition primitives
  '(;; arithmetic operators
    (+ . +)
    (- . -)
    (* . *)
    (/ . /)
    (modulo . %)
    ;; relational operators
    (= . ==)
    (/= . !=)
    (< . <)
    (<= . <=)
    (> . >)
    (>= . >=)
    ;; logical operators (or and and have their own AST nodes)
    (not . !)
    ;; bitwise operators
    (bitwise-and . bitwise-and)
    (bitwise-ior . bitwise-ior)
    (bitwise-xor . bitwise-xor)
    (bitwise-not . bitwise-not)
    ;; language
    (fxfloor . floor)))


(definition (type->lisp type)
  (typecase type
    ((Fixnum-Class) 'int)
    ((Flonum-Class) 'double)
    (else #f)))


(definition (type->c type)
  (typecase type
    ((Fixnum-Class) 'int)
    ((Flonum-Class) 'double)
    (else #f)))


(definition (name->c name)
  (string->symbol (substitute #\- #\_ (symbol->string name))))


;; quick hack
(definition (optimize-name name)
  (string->symbol (string-append (symbol->string name) "$optimize")))


;;;
;;;; Definition
;;;


(class Definition-Optimize-Declaration extends Definition-Declaration
  
  
  (method override (emit-declaration environment backend)
    (let ((expression (emit-expression value self environment backend)))
      (cond ((is? value Constant)
             (emit-defoptimize-constant name (get-type~ value) value self environment backend))
            ((is? value Lambda)
             (let ((signature (get-signature~ value))
                   (body (get-body~ value)))
               (with-annotated-frame (annotate-signature signature)
                 (lambda (frame)
                   (let ((augmented-environment (cons frame environment)))
                     (emit-defoptimize-function name signature (get-type~ value) body expansion self augmented-environment backend))))))
            (else
             (error "Unsupported optimize: {s}" value))))))


(define (walk-defoptimize-declaration walker resume declaration environment form-src)
  (walk-extended-definition-declaration walker resume declaration environment form-src
    (lambda (name type access compatibility attributes parent expansion signature)
      (new Definition-Optimize-Declaration name: name type: type access: access compatibility: compatibility attributes: attributes parent: parent expansion: expansion))))


(define (walk-defoptimize walker resume declaration environment form-src)
  (walk-extended-definition walker resume declaration environment form-src))


(define-walker-declaration defoptimize jazz walk-defoptimize-declaration walk-defoptimize)


;;;
;;;; Optimize
;;;


(class Optimize extends Expression
  
  
  (slot body getter generate)
  
  
  (method override (initialize body . rest)
    (apply nextmethod rest)
    (set! body~self body))
  
  
  (method override (emit-expression declaration environment backend)
    (new-code
      (emit-optimize body declaration environment backend)
      Any
      #f)))


(special-form (optimize walker resume declaration environment form-src)
  (let ((body (cdr (source-code form-src))))
    (new Optimize
      (walk-list walker resume declaration environment body))))


;;;
;;;; For
;;;


(class For extends Expression
  
  
  (slot variable  getter generate)
  (slot init      getter generate)
  (slot test      getter generate)
  (slot update    getter generate)
  (slot body      getter generate)
  (slot expansion getter generate)
  
  
  (method override (initialize variable init test update body expansion . rest)
    (apply nextmethod rest)
    (set! variable~self variable)
    (set! init~self init)
    (set! test~self test)
    (set! update~self update)
    (set! body~self body)
    (set! expansion~self expansion))
  
  
  (method override (emit-expression declaration environment backend)
    (emit-expr expansion declaration environment backend)))


(special-form (for walker resume declaration environment form-src)
  (let ((form (source-code (cdr (source-code form-src)))))
    (let ((header (car form))
          (body (cdr form)))
      (bind (name init test update) (source-code header)
        (let ((variable (new Variable (source-code name) #f name)))
          (let ((augmented-environment (cons variable environment))
                (iter (generate-symbol "iter")))
            (new For
              variable
              (walk walker resume declaration environment init)
              (walk walker resume declaration augmented-environment test)
              (walk walker resume declaration augmented-environment update)
              (walk-list walker resume declaration augmented-environment body)
              (walk walker resume declaration environment
                `(let ((,name ,init))
                   (let (,iter)
                     (when ,test
                       ,@body
                       ,update
                       (,iter)))))))))))))
