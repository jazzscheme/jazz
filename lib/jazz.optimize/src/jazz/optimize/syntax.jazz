;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Optimize Syntax
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.optimize.syntax jazz


(import (jazz.core (phase syntax))
        (fmt (except fl upcase downcase))
        (fmt.fmt-c (except c-inline)))


;; TODO
;; - compare performance of
;;   - pure gambit compilation
;;   - optimize using c-lambda
;;   - optimize using c-code
;; - defoptimize
;;   - generate C-level fn
;;   - generate Lisp wrapper
;;   - generate C linking code
;;     - probably through a global vector in the Jazz kernel that is
;;       populated and accessed by static code. note that we should be
;;       able to create a C global variable for every fn called from
;;       another module. note that this is really similar to what
;;       Gambit does for linking user code
;;   - I think the Lisp side should only generate fn and no fn! and fn&
;;     as in a thread-safe world there is no sensible place we can pass
;;     to fn! to put the result. All critical pieces should then be
;;     wrapped in an optimize

;; SUPPORT
;; - fx& make-fx& (obsolete)
;; - f32& f64& make-f32& make-f64& (obsolete)
;; ! = /= < <= > >= (TODO: /= is an inline function, not primitive)
;; ! + - * /
;; ! modulo bitwise-and ...
;; ! set!
;; !~ let let* ...
;; !~ if cond case ...
;; - (cast <fx> <fl> ...)
;; - (get-slot obj)
;; - (fn a b c)
;; ! (for (init test update) body)
;; ! f64vector-ref f64vector-set! ...
;; - macro calls
;; - inline calls
;; - cffi calls like randomInt
;; - internal defines like evaluate-morph
;; ! constants
;; - continuation-capture/return that becomes break, continue, ...
;; 2 vertex&, matrix&, ... e.g. type extensible (together with next)
;;    --> vertex is f64vector[3], matrix is f64vector[16]
;; 2 fn fn! fn& constant space and thread-safe
;; - typed variables like <fx> <fl> ...
;; - set! gambit boxing
;; - (cast <Tangent> <KeyFrame> ...)
;; - and or
;; - allege
;; 3 linking

;; KNOWLEDGE
;; - ___argn is a macro that refers to the Scheme stack and so should be
;;   updated when a gc occurs. we should be able to use this to reacquire
;;   entry parameters after a call to the Lisp world
;; - it is not possible to make callbacks from inside a c-code (validate
;;   that this is really the case) as some work c-lambda does is skipped
;; - according to Marc, callbacks could be done efficiently by having a
;;   c-define for each type signatures, like callback-int/int-int!?

;; THINK
;; - need to think about a satisfactory solution for non-compiled code
;;   for example for a user not have installed gcc
;;   - maybe we should keep (hidden!?) the lisp-level fn fn! fn& the main
;;     problem being that they are not thread-safe
;;   - spectrum: C - optimize generated C code - hand optimized Lisp code (fn fn! fn&) - pure Lisp code
;; - when generating C code, never forget
;;   - independant compilation
;;   - dynamic evaluation

;; IDEAS
;; - do without the type prefixes!?
;;   - for example (+ vert1 (scalar* vert2 2.3))
;; - enable optimize at a higher level where it will automatically determine
;;   what parts of its tree should be optimized. and then maybe optimize based
;;   on a proclaim
;; - can optimize fix the annoying having to (+ (cast <fl> n) y) and having
;;   to (+ y 1.0) instead of just (+ y 1)
;; - for the interpreted expansion, maybe disable interrupts to make the fn&
;;   approach thread-safe!?
;; - add gcc flags like -O3 or even more specific ones!?

;; LAYERS
;; - Pure Lisp
;; - Optimized using types to generate
;;   - ## low-level code
;;   - C code using Gambit's CFFI

;; MODULES
;; - (geometry) world.geometry world.geometry.base world.polygon
;; - (generation) world.procedural world.biome
;; - (animation) world.animation
;; - (collision) world.collision

;; FUNCTIONS
;; - ray-triangle-distance!

;; TYPES
;; - bool
;; - fx
;; - fl
;; - homogeneous vectors
;; - vertex fl(3)
;; - quaternion fl(4)
;; - matrix fl(16)
;; - LookAt vertex vertex vertex
;; - Movement vertex vertex vertex fl
;; - Plane vertex vertex
;; - Polygon plane object vertex(n) fl fl fl fl fl
;;   - Triangle Quad
;; - values !?
;; - type+

;; HOMOGENEOUS
;; - ___F64* content = ___CAST(___F64*, ___BODY(___arg1));
;; - allocate a new f64vector of count elements
;;   ___SCMOBJ r = ___EXT(___alloc_scmobj) (___ps, ___sF64VECTOR, count*sizeof(___F64));
;;   ___F64* ptr = ___CAST(___F64*, ___BODY(r));
;;   fill / copy / ... the content using ptr
;;   ___EXT(___release_scmobj)(r);
;;   ___return(r);

;; GUILLAUME
;; - probably an emit-optimize-body fn
;; - maybe delegate the inline to C
;;   - and maybe this is not even necessary (test)
;;     if gcc smartly inlines as needed
;; - solution to generate-symbol for Lisp and C
;; - make lisp stack allocation automatic and safe using optimize
;; - the best solution is probably to make loop into a special-form

;; MARC
;; - better way of doing ptr->origin.head = ___MAKE_HD(___HD_BYTES(ptr->origin.head), ___sJAZZSTRUCT, ___PERM)
;; - with 2 ADDR types, one could be used for len=1 which is 99% case with no lookup for container


;; hack around calling emit-expression from within an emit-expression method
(native jazz:call-emit-expression)


;; development
(native ienv)
(native iframe)


(definition protected debug-optimize?
  (make-parameter #f))

(definition protected debug-lambda?
  (make-parameter #f))


(definition protected disable-optimize?
  #f)


;;;
;;;; Emit
;;;


(definition (emit-optimize body declaration walker resume environment (defoptimize? #f))
  (let ((globals '())
        (inputs '())
        (bailout? #f)
        (bailout-expr #f))
    (define (emit-list lst env tail?)
      (cond ((null? lst)
             '())
            ((null? (cdr lst))
             (list (emit (car lst) env tail?)))
            (else
             (cons (emit (car lst) env #f)
                   (emit-list (cdr lst) env tail?)))))
    
    (define (emit expr env tail?)
      (typecase expr
        ((Constant) (emit-constant expr env tail?))
        ((Binding-Reference) (emit-reference expr env tail?))
        ((Call) (emit-call expr env tail?))
        ((Let) (emit-let expr env tail?))
        ((Letstar) (emit-letstar expr env tail?))
        ((Body) (emit-body expr env tail?))
        ((Begin) (emit-begin expr env tail?))
        ((Unspecific) (emit-unspecific expr env tail?))
        ((And) (emit-and expr env tail?))
        ((Or) (emit-or expr env tail?))
        ((If) (emit-if expr env tail?))
        ((Cond) (emit-cond expr env tail?))
        ((C-Inline) (emit-inline expr env tail?))
        ((For) (emit-for expr env tail?))
        ((Assignment) (emit-assignment expr env tail?))
        ((Cast) (emit-cast expr env tail?))
        (else (emit-unsupported expr))))
    
    (define (emit-constant expr env tail?)
      (let ((value (source-code (unquote-expr (get-expansion expr)))))
        (emit-tail (cond ((eq? value #f) 0 @wait-correct-boolean '___FAL)
                         ((eq? value #t) 1 @wait-correct-boolean '___TRU)
                         (else value))
                   tail?)))
    
    (define (emit-reference expr env tail?)
      (let ((binding (get-binding expr)))
        (cond ((is? binding Variable)
               (let ((lisp-name (get-name binding)))
                 (let ((name (name->c lisp-name)))
                   (when (find-annotated binding environment)
                     (register-input (list lisp-name (find-annotated-type binding environment) name)))
                   (emit-tail name tail?))))
              ((is? binding Definition-Optimize-Declaration)
               (if (is? (get-value binding) Constant)
                   (name->c (get-name binding))
                 (bailout `(unsupported-reference ,binding))))
              ((is? binding Definition-Declaration)
               (let ((lisp-name (get-name binding)))
                 (let ((name (name->c lisp-name)))
                   (register-global/input (list (get-locator binding) (get-type binding) name))
                   (emit-tail name tail?))))
              ((is? binding Slot-Declaration)
               (register-input (list 'self 'category @too-much (get-parent binding) 'self))
               (emit-slot-reference binding 'self env tail?))
              (else
               (bailout `(unsupported-reference ,binding))))))
    
    (define (emit-slot-reference binding object env tail?)
      (let ((name (get-name binding)))
        (let ((c-name (string->symbol (string-append (symbol->string (name->c name)) "_offset"))))
          (let ((offset-locator (compose-helper (get-locator binding) 'offset)))
            (register-global/input (list offset-locator Fixnum c-name))
            (emit-tail (safe-lisp->c (get-type binding) `(vector-ref (___BODY ,object) ,c-name)) tail?)))))
    
    (define (emit-slot-assignment binding object value env tail?)
      (let ((name (get-name binding)))
        ;; the _set is a mega quick hack around duplication problems because of no linking yet
        (let ((c-name (string->symbol (string-append (symbol->string (name->c name)) "_offset_set"))))
          (let ((offset-locator (compose-helper (get-locator binding) 'offset)))
            (register-global/input (list offset-locator Fixnum c-name))
            (emit-tail `(vector-set! (___BODY ,object) ,c-name ,(argument->lisp (get-type binding) value)) tail?)))))
    
    (define (emit-call expr env tail?)
      (define (emit-export-call binding arguments env tail?)
        (define (vector-reference symbol)
          (cond ((memq? symbol '(vector-ref s8vector-ref u8vector-ref s16vector-ref u16vector-ref s32vector-ref u32vector-ref s64vector-ref u64vector-ref f32vector-ref f64vector-ref))
                 'vector-ref)
                ((memq? symbol '(vector-set! s8vector-set! u8vector-set! s16vector-set! u16vector-set! s32vector-set! u32vector-set! s64vector-set! u64vector-set! f32vector-set! f64vector-set!))
                 'vector-set!)
                (else
                 #f)))
        
        (let ((symbol (get-symbol binding)))
          (case symbol
            ((continuation-capture)
             (let ((lambda (car arguments)))
               (if (is? lambda Lambda)
                   `(%begin ,@(emit-body (get-body lambda) env tail?))
                 (bailout `(non-lambda-continuation-capture ,lambda)))))
            ((continuation-return)
             (let ((name (get-name (get-binding (car arguments)))))
               (case name
                 ((return)
                  (if (null? (cdr arguments))
                      `(return)
                    `(return ,(emit (cadr arguments) env #f))))
                 ((break)
                  `(break))
                 ((continue)
                  `(continue))
                 (else
                  (bailout `(non-supported-continuation-return ,name))))))
            (else
             ;; quick try to generalize
             (if (eq? symbol 'vector-set!)
                 (emit-tail `(vector-set! ,(emit (car arguments) env #f) ,(emit (cadr arguments) env #f) ,(convert (get-type (call-emit-expression (caddr arguments) declaration walker resume env)) Object (emit (caddr arguments) env #f))) tail?)
               (let ((caller (or (primitive-reference symbol)
                                 (vector-reference symbol))))
                 (if caller
                     (let ((emitted `(,caller ,@(emit-list arguments env #f))))
                       ;; ultra quick hack for test
                       (when (equal? emitted '(vector-ref heightmap (+ i (* k 16))))
                         (set! emitted `(___INT ,emitted)))
                       emitted)
                   (bailout `(export-call-not-implemented ,symbol)))))))))
      
      (define (emit-defoptimize-call binding arguments env tail?)
        (emit-tail `(,(name->c (get-name binding)) ,@(emit-list arguments env #f)) tail?))
      
      (define (emit-definition-call binding arguments env tail?)
        (define (emit-inline-call binding arguments env tail?)
          (let ((signature (get-signature binding))
                (value (get-value binding)))
            (let ((bindings (map (lambda (parameter argument)
                                   (cons parameter argument))
                                 (get-positional signature)
                                 arguments))
                  (body (get-body value)))
              (emit (new Let bindings body) env tail?))))
        
        (define (emit-onsite-call binding arguments env tail?)
          (let ((name (get-name binding))
                (signature (get-signature binding))
                (value (get-value binding)))
            (let ((c-name (name->c name)))
              (register-input (list (get-locator binding) Procedure c-name))
              (let ((caller (emit-caller arguments)))
                (if #f @wait-no-onsite-call-for-now caller
                    (emit-result (get-type value) `(,caller ,c-name ,@(emit-arguments arguments)))
                  (bailout `(unsupported-definition-call ,name)))))))
        
        (let ((name (get-name binding)))
          (let ((primitive (primitive-reference name)))
            (if primitive
                (emit-tail `(,primitive ,@(emit-list arguments env #f)) tail?)
              (let ((value (get-value binding)))
                (if #f @nice-try-but-doesnt-work-as-is-with-c-but-could-try-and-use-gnus-statement-expr
                    (and (is? value Lambda)
                         #f
                         @fix-me-was-working-in-c++
                         (eq? (get-expansion binding) 'inline))
                    (emit-inline-call binding arguments env tail?)
                  (emit-onsite-call binding arguments env tail?)))))))
      
      (define (emit-hub-call binding arguments env tail?)
        (or (let ((name (get-name binding)))
              (let ((object-argument (car arguments))
                    (rest-arguments (cdr arguments)))
                (let ((object-type (get-type (call-emit-expression object-argument declaration walker resume env)))
                      (str (symbol->string name)))
                  (cond ;; quick solution for getter
                        ((and (starts-with? str "get-") (null? rest-arguments))
                         (let ((slot-name (string->symbol (substring str 4 (string-length str)))))
                           (if (is? object-type Namespace-Declaration)
                               (let ((slot-declaration (find-declaration-child object-type slot-name)))
                                 (if (is? slot-declaration Slot-Declaration)
                                     (emit-slot-reference slot-declaration (emit object-argument env #f) env tail?)
                                   #f))
                             #f)))
                        ;; quick solution for setter
                        ((and (starts-with? str "set-") (not-null? rest-arguments) (null? (cdr rest-arguments)))
                         (let ((slot-name (string->symbol (substring str 4 (string-length str)))))
                           (if (is? object-type Namespace-Declaration)
                               (let ((slot-declaration (find-declaration-child object-type slot-name)))
                                 (if (is? slot-declaration Slot-Declaration)
                                     (let ((value-argument (car rest-arguments)))
                                       (emit-slot-assignment slot-declaration (emit object-argument env #f) (emit value-argument env #f) env tail?))
                                   #f))
                             #f)))
                        (else
                         #f)))))
            (bailout `(todo-dispatch ,(get-name expr)))))
      
      (define (emit-variable-call binding arguments env tail?)
        (let ((name (get-name binding)))
          (let ((c-name (name->c name)))
            (register-input (list (get-name binding) Procedure c-name))
            (let ((caller (emit-caller arguments)))
              (if caller
                  (let ((type (get-type binding)))
                    (if (is? type Function-Type)
                        (emit-result (get-result type) `(,caller ,c-name ,@(emit-arguments arguments)))
                      (bailout `(unsupported-variable-call-return ,name ,type))))
                (bailout `(unsupported-variable-call-arity ,name)))))))
      
      (define (emit-caller arguments)
        (let ((len (length arguments)))
          (if (<= len 4)
              (string->symbol (string-append "call" (number->string len)))
            #f)))
      
      (define (emit-arguments arguments)
        (map (lambda (arg)
               (let ((type (get-type (call-emit-expression arg declaration walker resume env))))
                 (let ((code (argument->lisp type (emit arg env #f))))
                   (or code
                       (bailout `(unsupported-argument-type ,type))))))
             arguments))
      
      (define (emit-result type code)
        (if (is? type Void-Class)
            code
          (let ((code (lisp->argument type code)))
            (if code
                (emit-tail code tail?)
              (bailout `(unsupported-result-type ,type))))))
      
      (define (primitive-reference name)
        (let ((pair (assq name primitives)))
          (if pair
              (cdr pair)
            #f)))
      
      (let ((operator (get-operator expr))
            (arguments (get-arguments expr)))
        (let ((binding (and (is? operator Binding-Reference) (get-binding operator))))
          (cond ((is? binding Export-Declaration)
                 (emit-export-call binding arguments env tail?))
                ((is? binding Definition-Optimize-Declaration)
                 (emit-defoptimize-call binding arguments env tail?))
                ((is? binding Definition-Declaration)
                 (emit-definition-call binding arguments env tail?))
                ((is? binding Hub-Declaration)
                 (emit-hub-call binding arguments env tail?))
                ((is? binding Variable)
                 (emit-variable-call binding arguments env tail?))
                (else
                 (bailout `(unsupported-call ,operator)))))))
    
    (define (emit-let expr env tail?)
      (annotate-let expr declaration walker resume env
        (lambda (augmented-environment)
          (let ((bindings (get-bindings expr))
                (body (get-body expr)))
            `(%begin
               ,@(map (lambda (binding)
                        (let ((variable (car binding))
                              (value (cdr binding)))
                          (let ((type (find-annotated-type variable augmented-environment)))
                            `(%var ,(safe-type->c type) ,(name->c (get-name variable)) ,(emit value augmented-environment #f)))))
                      bindings)
               ,@(emit body augmented-environment tail?))))))
    
    (define (emit-letstar expr env tail?)
      (bailout `(todo-let*)))
    
    (define (emit-body expr env tail?)
      (let ((expressions (get-expressions expr)))
        (emit-list expressions env tail?)))
    
    (define (emit-begin expr env tail?)
      (let ((expressions (get-expressions expr)))
        `(%begin ,@(emit-list expressions env tail?))))
    
    (define (emit-unspecific expr env tail?)
      (let ((expressions (get-expressions expr)))
        `(%begin ,@(emit-list expressions env tail?))))
    
    (define (emit-and expr env tail?)
      `(%and ,@(emit-list (get-expressions expr) env tail?)))
    
    (define (emit-or expr env tail?)
      `(%or ,@(emit-list (get-expressions expr) env tail?)))
    
    (define (emit-if expr env tail?)
      (let ((test (get-test expr))
            (yes (get-yes expr))
            (no (get-no expr)))
        `(if ,(emit test env #f)
             ,(emit yes env tail?)
           ,@(if no
                 (list (emit no env tail?))
               '()))))
    
    (define (emit-cond expr env tail?)
      `(%cond ,@(let ((clauses (get-clauses expr)))
                  (map (lambda (clause)
                         (bind (test arrow? . body) clause
                           `(,(if (not test) #t (emit test env #f))
                             ,@(if arrow?
                                   `(=>)
                                 '())
                             ,(emit body env #f))))
                       clauses))))
    
    (define (emit-inline expr env tail?)
      `(%inline ,(get-code expr)))
    
    (define (emit-for expr env tail?)
      (let ((variable (get-variable expr)))
        (if (not variable)
            (let ((body (emit-list (get-body expr) env #f)))
              `(while 1
                 ,@body))
          (let ((var (name->c (get-name variable)))
                (type (get-type (call-emit-expression (get-init expr) declaration walker resume env))))
            (let ((init (emit (get-init expr) env #f)))
              (with-annotated-frame (list (new Annotated-Variable variable Fixnum Fixnum))
                (lambda (frame)
                  (let ((augmented-environment (cons frame env)))
                    (let ((test (emit (get-test expr) augmented-environment #f))
                          (update (emit (get-update expr) augmented-environment #f))
                          (body (emit-list (get-body expr) augmented-environment #f)))
                      `(%begin
                         (%var ,(safe-type->c type) ,var)
                         (for (= ,var ,init) ,test ,update
                           ,@body)))))))))))
    
    (define (emit-assignment expr env tail?)
      (let ((binding (get-binding expr))
            (value (get-value expr)))
        `(= ,(name->c (get-name binding)) ,(emit value env #f))))
    
    (define (emit-cast expr env tail?)
      `(%cast ,(type->c (get-type expr)) ,(emit (get-expression expr) env tail?)))
    
    (define (emit-tail expr tail?)
      (if (and tail? (not defoptimize?))
          `(___return ,expr)
        expr))
    
    (define (emit-unsupported expr)
      (bailout `(unsupported ,expr)))
    
    (define (register-global global)
      (unless (member? global globals)
        (set! globals (cons global globals))))
    
    (define (register-input input)
      (unless (member? input inputs)
        (set! inputs (cons input inputs))))
    
    (define (register-global/input info)
      (if defoptimize?
          (register-global info)
        (register-input info)))
    
    (define (bailout expr)
      (set! bailout? #t)
      (set! bailout-expr expr)
      expr)
    
    (define (safe-type->lisp type)
      (or (type->lisp type)
          (bailout `(unknown-lisp-type ,type))))
    
    (define (safe-type->c type)
      (or (type->c type)
          (bailout `(unknown-c-type ,type))))
    
    (define (safe-lisp->c type expr)
      (or (lisp->c type expr)
          (bailout `(unable-to-convert-lisp-type ,type))))
    
    (define (safe-arg->c type expr)
      (or (arg->c type expr)
          (bailout `(unable-to-convert-arg-type ,type))))
    
    (define (wrap code)
      (let ((inputs (reverse inputs)))
        (let ((expr `(%begin
                       ,@(map (lambda (input rank)
                                (bind (argument type name) input
                                  `(%var ,(safe-type->c type) ,name ,(safe-arg->c type (string->symbol (format "___arg{a}" rank))))))
                              inputs
                              (naturals 1 (+ (length inputs) 1)))
                       ,@code)))
          (let ((code (c-expr/sexp expr))
                (statements-code (emit-statements-code body declaration walker resume environment)))
            (let ((return-type (get-type statements-code)))
              (let ((lisp-return-type (or (type->lisp return-type) 'void))
                    (lisp-types (map (lambda (input)
                                       (bind (argument type name) input
                                         (safe-type->lisp type)))
                                     inputs)))
                (when (and (or (debug-optimize?) bailout?) (not disable-optimize?))
                  (when bailout?
                    (display '***BAILOUT***)
                    (display " ")
                    (display bailout-expr)
                    (newline))
                  ;(pp expr) (newline)
                  (when (debug-lambda?)
                    (display "// ")
                    (display (get-name declaration))
                    (newline)
                    (display "((")
                    (display 'c-lambda)
                    (display " ")
                    (display lisp-types)
                    (display " ")
                    (display lisp-return-type)
                    (newline)
                    (display "#/C/")
                    (newline))
                  (fmt #t code) (newline))
                (prog1
                    (if (or bailout? disable-optimize?)
                        `(begin ,@(get-form statements-code))
                      `((c-lambda ,lisp-types ,lisp-return-type
                          ,(fmt #f "" code))
                        ,@(map (lambda (input)
                                 (bind (argument type name) input
                                   argument))
                               inputs)))
                  (when (debug-lambda?)
                    (display "//#)")
                    (for-each (lambda (input)
                                (bind (argument type name) input
                                  (newline)
                                  (display " ")
                                  (display argument)))
                              inputs)
                    (display ")")
                    (newline)
                    (newline)))))))))
    
    (let ((code (emit-list body environment #t)))
      (if defoptimize?
          (values bailout? bailout-expr (reverse globals) code)
        (wrap code)))))


(definition (emit-defoptimize-constant locator name type constant declaration walker resume environment)
  (let ((name (name->c name))
        (value (source-code (unquote-expr (get-expansion constant)))))
    (define (extract)
      (cond ((flonum? value)
             `(%var double ,name ,value))
            ((f64vector? value)
             (extract-homogeneous 'double (f64vector-length value) (coerce value Vector)))
            (else
             #f)))
    
    (define (extract-homogeneous type size initializer)
      `(%var (%array ,type ,size) ,name ,initializer))
    
    (let ((expr (extract)))
      (if expr
          (let ((code (c-expr/sexp expr)))
            (when (and (debug-optimize?) (not disable-optimize?))
              (fmt #t code) (newline))
            `(begin
               (c-declare ,(fmt #f "" code))
               (define ,locator ,(get-form (call-emit-expression constant declaration walker resume environment)))))
        (error "Unsupported optimize constant: {s}" value)))))


(definition (emit-defoptimize-function name signature return-type body expansion declaration walker resume environment)
  (receive (bailout? bailout-expr globals body) (emit-optimize (get-expressions body) declaration walker resume environment #t)
    (let ((arguments (map (lambda (parameter)
                            (list (type->c (get-type parameter)) (name->c (get-name parameter))))
                          (get-positional signature)))
          (return-type (type->c return-type)))
      (let ((expr `(%fun ,return-type ,(name->c name) ,arguments ,@body)))
        (let ((expr (if #f @fix-me-was-working-in-c++ (eq? expansion 'inline) `(c-inline ,expr) expr)))
          (let ((code (c-expr/sexp expr)))
            (when (and (or (debug-optimize?) bailout?) (not disable-optimize?))
              (when bailout?
                (debug '***BAILOUT*** bailout-expr))
              ;(pp expr) (newline)
              (for-each (lambda (global)
                          (bind (argument type name) global
                            (fmt #t (c-expr/sexp `(%var int ,name)))))
                        globals)
              (fmt #t code) (newline))
            (if bailout?
                `(begin)
              `(begin
                 ,@(map (lambda (global)
                          (bind (argument type name) global
                            `(c-declare ,(fmt #f (c-expr/sexp `(%var int ,name))))))
                        globals)
                 (c-declare ,(fmt #f "" code))
                 ,@(map (lambda (global)
                          (bind (argument type name) global
                            `(c-code ,(format "{a} = ___INT(___ARG1);" name) ,argument)))
                        globals)))))))))


(definition primitives
  '(;; arithmetic
    (+ . +)
    (- . -)
    (* . *)
    (/ . /)
    (modulo . %)
    (quotient . /)
    (even? . even)
    (odd? . odd)
    (abs . abs)
    (min . min)
    (max . max)
    (sin . sin)
    (cos . cos)
    (square . square)
    ;; relational
    (= . ==)
    (/= . !=)
    (< . <)
    (<= . <=)
    (> . >)
    (>= . >=)
    ;; logical
    (not . !)
    ;; bitwise
    (bitwise-and . bitwise-and)
    (bitwise-ior . bitwise-ior)
    (bitwise-xor . bitwise-xor)
    (bitwise-not . bitwise-not)
    ;; shift
    (jazz:arithmetic-shift-left . <<)
    (jazz:arithmetic-shift-right . >>)
    ;; language
    (fxfloor . floor)
    (fxfloor/ . floor_divide)
    (quotient/ . floor_divide)))


(definition (type->lisp type)
  ;; quick hack
  (if (eq? type 'category)
      'scheme-object
  (typecase type
    ((Fixnum-Class) 'int)
    ((Flonum-Class) 'double)
    ((S64-Class) 'int64)
    ((Vector-Class) 'scheme-object)
    ((S8Vector-Class) 'scheme-object)
    ((U8Vector-Class) 'scheme-object)
    ((S16Vector-Class) 'scheme-object)
    ((U16Vector-Class) 'scheme-object)
    ((S32Vector-Class) 'scheme-object)
    ((U32Vector-Class) 'scheme-object)
    ((S64Vector-Class) 'scheme-object)
    ((U64Vector-Class) 'scheme-object)
    ((F32Vector-Class) 'scheme-object)
    ((F64Vector-Class) 'scheme-object)
    ((Category-Declaration) 'scheme-object)
    ((Procedure-Class) 'scheme-object)
    (else #f))))


(definition (type->c type)
  ;; quick hack
  (if (eq? type 'category)
      '___SCMOBJ
  (typecase type
    ((Bool-Class) 'int)
    ((Boolean-Class) 'int)
    ((Fixnum-Class) 'int)
    ((Flonum-Class) 'double)
    ((S64-Class) '___S64)
    ((Vector-Class) '___SCMOBJ*)
    ((S8Vector-Class) '___S8*)
    ((U8Vector-Class) '___U8*)
    ((S16Vector-Class) '___S16*)
    ((U16Vector-Class) '___U16*)
    ((S32Vector-Class) '___S32*)
    ((U32Vector-Class) '___U32*)
    ((S64Vector-Class) '___S64*)
    ((U64Vector-Class) '___U64*)
    ((F32Vector-Class) '___F32*)
    ((F64Vector-Class) '___F64*)
    ((Category-Declaration) '___SCMOBJ)
    ((Procedure-Class) '___SCMOBJ)
    ((Void-Class) 'void)
    (else #f))))


(definition (lisp->c type expr)
  (typecase type
    ((Fixnum-Class) `(___INT ,expr))
    ((Flonum-Class) `(___F64UNBOX ,expr))
    ((Vector-Class) `(___CAST ___SCMOBJ* (___BODY ,expr)))
    ((S8Vector-Class) `(___CAST ___S8* (___BODY ,expr)))
    ((U8Vector-Class) `(___CAST ___U8* (___BODY ,expr)))
    ((S16Vector-Class) `(___CAST ___S16* (___BODY ,expr)))
    ((U16Vector-Class) `(___CAST ___U16* (___BODY ,expr)))
    ((S32Vector-Class) `(___CAST ___S32* (___BODY ,expr)))
    ((U32Vector-Class) `(___CAST ___U32* (___BODY ,expr)))
    ((S64Vector-Class) `(___CAST ___S64* (___BODY ,expr)))
    ((U64Vector-Class) `(___CAST ___U64* (___BODY ,expr)))
    ((F32Vector-Class) `(___CAST ___F32* (___BODY ,expr)))
    ((F64Vector-Class) `(___CAST ___F64* (___BODY ,expr)))
    (else #f)))


(definition (arg->c type expr)
  ;; quick hack
  (if (eq? type 'category)
      expr
  (typecase type
    ((Fixnum-Class) expr)
    ((Flonum-Class) expr)
    ((Vector-Class) `(___CAST ___SCMOBJ* (___BODY ,expr)))
    ((S8Vector-Class) `(___CAST ___S8* (___BODY ,expr)))
    ((U8Vector-Class) `(___CAST ___U8* (___BODY ,expr)))
    ((S16Vector-Class) `(___CAST ___S16* (___BODY ,expr)))
    ((U16Vector-Class) `(___CAST ___U16* (___BODY ,expr)))
    ((S32Vector-Class) `(___CAST ___S32* (___BODY ,expr)))
    ((U32Vector-Class) `(___CAST ___U32* (___BODY ,expr)))
    ((S64Vector-Class) `(___CAST ___S64* (___BODY ,expr)))
    ((U64Vector-Class) `(___CAST ___U64* (___BODY ,expr)))
    ((F32Vector-Class) `(___CAST ___F32* (___BODY ,expr)))
    ((F64Vector-Class) `(___CAST ___F64* (___BODY ,expr)))
    ((Category-Declaration) expr)
    ((Procedure-Class) expr)
    (else #f))))


(definition (argument->lisp type expr)
  (typecase type
    ((Fixnum-Class) `(___FIX ,expr))
    (else #f)))


(definition (lisp->argument type expr)
  (typecase type
    ((Fixnum-Class) `(___INT ,expr))
    (else #f)))


(definition (convert from to expr)
  (cond ((and (is? from Fixnum-Class) (is? to Object-Class))
         `(___FIX ,expr))
        (else
         expr)))


(definition (name->c name)
  (let ((str (symbol->string name))
        (output (open-output-string)))
    (let ((len (string-length str)))
      (let (iter (n 0))
        (if (< n len)
            (begin
              (let ((c (string-ref str n)))
                (cond ((memv? c '(#\- #\/)) (write-char #\_ output))
                      ((eqv? c #\!))
                      ((eqv? c #\?))
                      (else (write-char c output))))
              (iter (+ n 1)))
          (string->symbol (get-output-string output)))))))


;; quick hack
(definition (optimize-name name)
  (string->symbol (string-append (symbol->string name) "$optimize")))


(definition (unquote-expr expr)
  (if (and (pair? expr)
           (eq? (car expr) 'quote))
      (cadr expr)
    expr))


;;;
;;;; Definition
;;;


(class Definition-Optimize-Declaration extends Definition-Declaration
  
  
  (method override (emit-declaration self walker resume environment)
    (let ((expression (emit-expression value self walker resume environment)))
      (cond ((is? value Constant)
             (emit-defoptimize-constant locator name (get-type value) value self walker resume environment))
            ((is? value Lambda)
             (let ((signature (get-signature value))
                   (body (get-body value)))
               ;; warning for a really sneaky bug
               (let ((expressions (get-expressions body)))
                 (when (= (length expressions) 1)
                   (let ((expr (car expressions)))
                     (when (and (is? expr Constant)
                                (string? (source-code (get-expansion expr))))
                       (format :console "Warning: defoptimize {a} is missing an inline{%}" name)))))
               (with-annotated-frame (annotate-signature signature)
                 (lambda (frame)
                   (let ((augmented-environment (cons frame environment)))
                     (emit-defoptimize-function name signature (get-type value) body expansion self walker resume augmented-environment))))))
            (else
             (error "Unsupported optimize: {s}" value))))))


(define (walk-defoptimize-declaration walker resume declaration environment form-src)
  (walk-extended-definition-declaration walker resume declaration environment form-src
    (lambda (name type access compatibility modifiers attributes parent expansion signature specifier-source)
      (new Definition-Optimize-Declaration name: name type: type access: access compatibility: compatibility modifiers: modifiers attributes: attributes parent: parent expansion: expansion))))


(define (walk-defoptimize walker resume declaration environment form-src)
  (walk-extended-definition walker resume declaration environment form-src))


(define-walker-declaration defoptimize jazz walk-defoptimize-declaration walk-defoptimize)


;;;
;;;; Optimize
;;;


(class Optimize extends Expression
  
  
  (slot debug? getter generate)
  (slot body   getter generate)
  
  
  (method override (initialize self debug? body . rest)
    (apply nextmethod self rest)
    (set! self.debug? debug?)
    (set! self.body body))
  
  
  (method override (emit-expression self declaration walker resume environment)
    (new-code
      (if debug?
          (parameterize ((debug-optimize? #t)
                         (debug-lambda? #t))
            (emit-optimize body declaration walker resume environment))
        (emit-optimize body declaration walker resume environment))
      Any
      #f)))


(special-form (optimize walker resume declaration environment form-src)
  (define (parse form)
    (if (and (pair? form) (eq? (source-code (car form)) 'debug))
        (values #t (cdr form))
      (values #f form)))
  
  (receive (debug? body) (parse (cdr (source-code form-src)))
    (new Optimize
      debug?
      (walk-list walker resume declaration environment body))))


;;;
;;;; C-Inline
;;;


(class C-Inline extends Expression
  
  
  (slot code      getter generate)
  (slot expansion getter generate)
  
  
  (method override (initialize self code expansion . rest)
    (apply nextmethod self rest)
    (set! self.code code)
    (set! self.expansion expansion))
  
  
  (method override (emit-expression self declaration walker resume environment)
    (call-emit-expression expansion declaration walker resume environment)))


(special-form (c-inline walker resume declaration environment form-src)
  (let ((form (source-code (cdr (source-code form-src)))))
    (let ((code (car form)))
      (new C-Inline
        (source-code code)
        (walk walker resume declaration environment
          code)))))


;;;
;;;; For
;;;


(class For extends Expression
  
  
  (slot variable  getter generate)
  (slot init      getter generate)
  (slot test      getter generate)
  (slot update    getter generate)
  (slot body      getter generate)
  (slot expansion getter generate)
  
  
  (method override (initialize self variable init test update body expansion . rest)
    (apply nextmethod self rest)
    (set! self.variable variable)
    (set! self.init init)
    (set! self.test test)
    (set! self.update update)
    (set! self.body body)
    (set! self.expansion expansion))
  
  
  (method override (emit-expression self declaration walker resume environment)
    (call-emit-expression expansion declaration walker resume environment)))


(special-form (for walker resume declaration environment form-src)
  (let ((form (source-code (cdr (source-code form-src)))))
    (let ((header (car form))
          (body (cdr form))
          (iter (generate-symbol "iter")))
      (if (null? (source-code header))
          (new For
            #f
            #f
            #f
            #f
            (walk-list walker resume declaration environment body)
            (walk walker resume declaration environment
              `(let (,iter)
                 ,@body
                 (,iter))))
        (bind (name init test update) (source-code header)
          (let ((variable (new Variable (source-code name) #f name #f)))
            (let ((augmented-environment (cons variable environment)))
              (new For
                variable
                (walk walker resume declaration environment init)
                (walk walker resume declaration augmented-environment test)
                (walk walker resume declaration augmented-environment update)
                (walk-list walker resume declaration augmented-environment body)
                (walk walker resume declaration environment
                  `(let ((,name ,init))
                     (let (,iter)
                       (when ,test
                         ,@body
                         ,update
                         (,iter))))))))))))))
