;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cocoa
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.platform.cocoa jazz


(import (jazz.foreign)
        (jazz.platform.types)
        (jazz.system.access))


;;;
;;;; Objective C
;;;


(c-declare cocoa #"

#include <objc/objc.h>
#include <Foundation/NSString.h>

const char *class_getName(Class cls);
id objc_getClass(const char *name);
id objc_msgSend(id self, SEL op, ...);

id retain_id(id x)
{
  if (x != nil)
    [x retain];
  return x;
}

___SCMOBJ release_id(void *ptr)
{
  id x = ___CAST(id,ptr);
  if (x != nil)
    [x release];
  return ___FIX(___NO_ERR);
}

Class retain_Class(Class x)
{
  if (x != nil)
    [x retain];
  return x;
}

___SCMOBJ release_Class(void *ptr)
{
  Class x = ___CAST(Class,ptr);
  if (x != nil)
    [x release];
  return ___FIX(___NO_ERR);
}

"#)


;;;
;;;; Objective C Types
;;;


(c-type id (pointer (struct "objc_object") (id Class) "release_id"))
(c-type Class_ (pointer (struct "objc_class") (Class id) "release_Class"))
(c-type SEL (pointer (struct "objc_selector") (SEL)))

(c-external (string->Class nonnull-char-string) Class_
    "___result = retain_Class(objc_getClass(___arg1));")

(c-external (Class->string Class_) nonnull-char-string
    "___result = ___CAST(char*,class_getName(___arg1));") ;;;TODO: remove cast

(c-external (string->SEL nonnull-UTF-8-string) SEL
    "___result = sel_registerName(___arg1);")

(c-external (SEL->string SEL) nonnull-UTF-8-string
    "___result = ___CAST(char*,sel_getName(___arg1));") ;;;TODO: remove cast


;;;
;;;; Objective C Messages
;;;


(c-external (send0 id SEL) id
    "___result = retain_id(___CAST(id (*)(id, SEL),objc_msgSend)(___arg1, ___arg2));")

(c-external (send1 id SEL id) id
    "___result = retain_id(___CAST(id (*)(id, SEL, id),objc_msgSend)(___arg1, ___arg2, ___arg3));")

(c-external (send2 id SEL id id) id
    "___result = retain_id(___CAST(id (*)(id, SEL, id, id),objc_msgSend)(___arg1, ___arg2, ___arg3, ___arg4));")


;;;
;;;; Objective C Conversions
;;;


(c-external (id->string id) nonnull-UTF-8-string
    "___result = ___CAST(char*,[___CAST(NSString*,___arg1) UTF8String]);") ;;;TODO: remove cast

(c-external (string->id nonnull-UTF-8-string) id
    "___result = retain_id([NSString stringWithUTF8String: ___arg1]);")

(c-external (id->bool id) bool
    "___result = [___CAST(NSNumber*,___arg1) boolValue];")

(c-external (bool->id bool) id
    "___result = retain_id([NSNumber numberWithBool:___arg1]);")

(c-external (id->int id) int
    "___result = [___CAST(NSNumber*,___arg1) intValue];")

(c-external (int->id int) id
    "___result = retain_id([NSNumber numberWithInt:___arg1]);")

(c-external (id->float id) float
    "___result = [___CAST(NSNumber*,___arg1) floatValue];")

(c-external (float->id float) id
    "___result = retain_id([NSNumber numberWithFloat:___arg1]);")

(c-external (id->double id) double
    "___result = [___CAST(NSNumber*,___arg1) doubleValue];")

(c-external (double->id double) id
    "___result = retain_id([NSNumber numberWithDouble:___arg1]);")


;;;
;;;; Cocoa NSString
;;;


(c-declare cocoa #"

___SCMOBJ SCMOBJ_to_NSStringSTAR(___SCMOBJ src, NSString **dst, int arg_num)
{
  /*
   * Convert a Scheme string to NSString* .
   */

  NSString *result;
  ___SCMOBJ ___temp;

  if (src == ___FAL)
    result = nil;
  else if (!___STRINGP(src))
    return ___FIX(___STOC_WCHARSTRING_ERR+arg_num);
  else
    {
      int i;
      int len = ___INT(___STRINGLENGTH(src));
      unichar *buf = ___alloc_mem(sizeof(unichar)*len);

      if (buf == 0)
        return ___FIX(___STOC_HEAP_OVERFLOW_ERR+arg_num);

      for (i=0; i<len; i++)
        {
          ___UCS_4 c = ___INT(___STRINGREF(src,___FIX(i)));
          buf[i] = c;
        }

      result = retain_id([NSString stringWithCharacters:buf length:len]);

      ___free_mem(buf);
    }

  *dst = result;

  return ___FIX(___NO_ERR);
}

___SCMOBJ NSStringSTAR_to_SCMOBJ(NSString *src, ___SCMOBJ *dst, int arg_num)
{
  ___SCMOBJ result;

  if (src == nil)
    result = ___FAL;
  else
    {
      int i;
      int len = [src length];

      result = ___alloc_scmobj(___PSTATE, ___sSTRING, len<<___LCS);

      if (___FIXNUMP(result))
        return ___FIX(___CTOS_HEAP_OVERFLOW_ERR+arg_num);

      for (i=0; i<len; i++)
        {
          ___UCS_4 c = [src characterAtIndex:i];
          ___STRINGSET(result,___FIX(i),___CHR(c))
        }
    }

  *dst = result;

  return ___FIX(___NO_ERR);
}

#define ___BEGIN_CFUN_SCMOBJ_to_NSStringSTAR(src,dst,i) \\
if ((___err = SCMOBJ_to_NSStringSTAR(src, &dst, i)) == ___FIX(___NO_ERR)) {
#define ___END_CFUN_SCMOBJ_to_NSStringSTAR(src,dst,i) }

#define ___BEGIN_CFUN_NSStringSTAR_to_SCMOBJ(src,dst) \\
if ((___err = NSStringSTAR_to_SCMOBJ(src, &dst, ___RETURN_POS)) == ___FIX(___NO_ERR)) {
#define ___END_CFUN_NSStringSTAR_to_SCMOBJ(src,dst) \\
___EXT(___release_scmobj)(dst); }

#define ___BEGIN_SFUN_NSStringSTAR_to_SCMOBJ(src,dst,i) \\
if ((___err = NSStringSTAR_to_SCMOBJ(src, &dst, i)) == ___FIX(___NO_ERR)) {
#define ___END_SFUN_NSStringSTAR_to_SCMOBJ(src,dst,i) \\
___EXT(___release_scmobj)(dst); }

#define ___BEGIN_SFUN_SCMOBJ_to_NSStringSTAR(src,dst) \\
{ ___err = SCMOBJ_to_NSStringSTAR(src, &dst, ___RETURN_POS);
#define ___END_SFUN_SCMOBJ_to_NSStringSTAR(src,dst) }

"#)

(c-type NSString* "NSString*"
  "NSStringSTAR_to_SCMOBJ"
  "SCMOBJ_to_NSStringSTAR"
  #t)


;;;
;;;; Cocoa NSArray
;;;


(c-type NSArray "NSArray")
(c-type NSArray* (pointer NSArray))


(definition public NSArray-length
  (c-function NSArray-length (NSArray*) int "___result = [___arg1 count];"))

(definition public NSArray-ref
  (c-function NSArray-ref (NSArray* int) id #<<end-c-code
   ___result_voidstar = [___arg1 objectAtIndex:___arg2];
end-c-code
))


;;;
;;;; Cocoa NSDate
;;;


(define NSDate      (string->Class "NSDate"))
(define alloc       (string->SEL "alloc"))
(define init        (string->SEL "init"))
(define description (string->SEL "description"))

(define (date)
  (id->string
   (send0 (send0 (send0 NSDate alloc) init) description)))


;;;
;;;; Cocoa NSBundle
;;;


(define NSBundle    (string->Class "NSBundle"))
(define mainBundle  (string->SEL "mainBundle"))
(define objectForInfoDictionaryKey (string->SEL "objectForInfoDictionaryKey:"))

(define (mainBundle-info key)
  (let ((info
         (send1 (send0 NSBundle mainBundle)
                objectForInfoDictionaryKey (string->id key))))
    (and info
         (id->string info))))

(define CFBundleName (mainBundle-info "CFBundleName"))
(define CFBundleDisplayName (mainBundle-info "CFBundleDisplayName"))


;;;
;;;; Cocoa UIDevice
;;;


@wait (
(c-include "<Foundation/UIDevice.h>")

(c-external (currentDevice-batteryLevel ) float
    "___result = [[UIDevice currentDevice] batteryLevel];")

(c-external (currentDevice-batteryMonitoringEnabled ) bool
    "___result = [UIDevice currentDevice].batteryMonitoringEnabled;")

(c-external (currentDevice-batteryMonitoringEnabled-set! bool) void
    "[UIDevice currentDevice].batteryMonitoringEnabled = ___arg1;")

(c-external (currentDevice-multitaskingSupported ) bool
    "___result = [UIDevice currentDevice].multitaskingSupported;")

(c-external (currentDevice-model ) NSString*
    "___result = [[UIDevice currentDevice] model];")

(c-external (currentDevice-name ) NSString*
    "___result = [[UIDevice currentDevice] name];")

(c-external (currentDevice-systemName ) NSString*
    "___result = [[UIDevice currentDevice] systemName];")

(c-external (currentDevice-systemVersion ) NSString*
    "___result = [[UIDevice currentDevice] systemVersion];")

(c-external (currentDevice-uniqueIdentifier ) NSString*
    "___result = [[UIDevice currentDevice] uniqueIdentifier];")

(define (device-status)
  (currentDevice-batteryMonitoringEnabled-set! #t)
  (list (currentDevice-batteryLevel)
        (currentDevice-batteryMonitoringEnabled)
        (currentDevice-multitaskingSupported)
        (currentDevice-model)
        (currentDevice-name)
        (currentDevice-systemName)
        (currentDevice-systemVersion)
        (currentDevice-uniqueIdentifier)))

(define (device-model)
  (let ((m (currentDevice-model)))
    (cond ((has-prefix? m "iPhone")
           'iPhone)
          ((has-prefix? m "iPod touch")
           'iPod-touch)
          ((has-prefix? m "iPad")
           'iPad)
          (else
           #f))))

(define (UDID)
  (currentDevice-uniqueIdentifier))
)

(define (has-prefix? str prefix)
  (and (string? str)
       (string? prefix)
       (let ((len-str (string-length str))
             (len-prefix (string-length prefix)))
         (and (>= len-str len-prefix)
              (string=? (substring str 0 len-prefix) prefix)
              (substring str len-prefix len-str)))))


;;;
;;;; Cocoa AudioToolbox
;;;


(c-declare cocoa #"

#import <AudioToolbox/AudioToolbox.h>

"#)

(c-type SystemSoundID unsigned-int32)

(c-external (AudioServicesPlayAlertSound SystemSoundID) void "AudioServicesPlayAlertSound")

(c-external (AudioServicesPlaySystemSound SystemSoundID) void "AudioServicesPlaySystemSound")

(define kSystemSoundID_FlashScreen        #x00000FFE)
(define kSystemSoundID_Vibrate            #x00000FFF)
(define kSystemSoundID_UserPreferredAlert #x00001000)


;;;
;;;; Cocoa Region
;;;


@port-from-carbon (
(c-type RgnHandle (pointer (struct "OpaqueRgnHandle")))


(c-external (NewRgn) RgnHandle)
(c-external (DisposeRgn RgnHandle) void)
(c-external (OffsetRgn RgnHandle short short) void)
(c-external (UnionRgn RgnHandle RgnHandle RgnHandle) void)


(definition (GetRegionBounds region)
  (let ((rect ((c-function GetRegionBounds (RgnHandle) Rect*
                 "Rect *rect = malloc(sizeof(rect));
                  GetRegionBounds( ___arg1, rect);
                  ___result_voidstar = rect;")
               region)))
    (let ((l (Rect-left-ref rect))
          (t (Rect-top-ref rect))
          (b (Rect-bottom-ref rect))
          (r (Rect-right-ref rect)))
      (Rect-free rect)
      (values l t r b))))


(c-external (RectRgn short short short short) RgnHandle
  "RgnHandle reg = NewRgn();
   Rect rect = {___arg2, ___arg1,  ___arg4, ___arg3};
   RectRgn( reg, &rect );
   ___result_voidstar = reg;")


(c-external (RectInRgn short short short short RgnHandle) bool
  "Rect rect = {___arg2, ___arg1,  ___arg4, ___arg3};
   ___result = RectInRgn( &rect, ___arg5 );"))


;;;
;;;; Platform Internal
;;;


(c-declare cocoa #"

#include <stdarg.h>

extern void glfwprint(char* string);
extern void glfwvprint(char* format, va_list arguments);
extern void glfwprintlog(char* format, ...);


//========================================================================
// Internal type declarations
//========================================================================

typedef struct _GLFWhints       _GLFWhints;
typedef struct _GLFWwndconfig   _GLFWwndconfig;
typedef struct _GLFWfbconfig    _GLFWfbconfig;
typedef struct _GLFWwindow      _GLFWwindow;
typedef struct _GLFWlibrary     _GLFWlibrary;
typedef struct _GLFWinputstate  _GLFWinputstate;



/*************************************************************************
 * Global definitions
 *************************************************************************/

/* Include the chosen OpenGL header and, optionally, the GLU header.
 */
#if defined(__APPLE_CC__)
  #if defined(GLFW_INCLUDE_GLCOREARB)
    #include <OpenGL/gl3.h>
  #else
    #define GL_GLEXT_LEGACY
    #include <OpenGL/gl.h>
  #endif
  #if defined(GLFW_INCLUDE_GLU)
    #include <OpenGL/glu.h>
  #endif
#else
  #if defined(GLFW_INCLUDE_GLCOREARB)
    #include <GL/glcorearb.h>
  #else
    #include <GL/gl.h>
  #endif
  #if defined(GLFW_INCLUDE_GLU)
    #include <GL/glu.h>
  #endif
#endif


#define GLFWAPI


/*************************************************************************
 * GLFW version
 *************************************************************************/

#define GLFW_VERSION_MAJOR    3
#define GLFW_VERSION_MINOR    0
#define GLFW_VERSION_REVISION 0


/*************************************************************************
 * Input handling definitions
 *************************************************************************/

/* Key and button state/action definitions */
#define GLFW_RELEASE            0
#define GLFW_PRESS              1

/* Keyboard raw key codes.
 * These key codes are inspired by the USB HID Usage Tables v1.12 (p. 53-60),
 * but re-arranged to map to 7-bit ASCII for printable keys (function keys are
 * put in the 256+ range).
 * The naming of the key codes follow these rules:
 *  - The US keyboard layout is used.
 *  - Names of printable alpha-numeric characters are used (e.g. "A", "R",
 *    "3", etc).
 *  - For non-alphanumeric characters, Unicode:ish names are used (e.g.
 *    "COMMA", "LEFT_SQUARE_BRACKET", etc). Note that some names do not
 *    correspond to the Unicode standard (usually for brevity).
 *  - Keys that lack a clear US mapping are named "WORLD_x".
 *  - For non-printable keys, custom names are used (e.g. "F4",
 *    "BACKSPACE", etc).
 */

/* Printable keys */
#define GLFW_KEY_SPACE                  32
#define GLFW_KEY_APOSTROPHE             39  /* ' */
#define GLFW_KEY_COMMA                  44  /* , */
#define GLFW_KEY_MINUS                  45  /* - */
#define GLFW_KEY_PERIOD                 46  /* . */
#define GLFW_KEY_SLASH                  47  /* / */
#define GLFW_KEY_0                      48
#define GLFW_KEY_1                      49
#define GLFW_KEY_2                      50
#define GLFW_KEY_3                      51
#define GLFW_KEY_4                      52
#define GLFW_KEY_5                      53
#define GLFW_KEY_6                      54
#define GLFW_KEY_7                      55
#define GLFW_KEY_8                      56
#define GLFW_KEY_9                      57
#define GLFW_KEY_SEMICOLON              59  /* ; */
#define GLFW_KEY_EQUAL                  61  /* = */
#define GLFW_KEY_A                      65
#define GLFW_KEY_B                      66
#define GLFW_KEY_C                      67
#define GLFW_KEY_D                      68
#define GLFW_KEY_E                      69
#define GLFW_KEY_F                      70
#define GLFW_KEY_G                      71
#define GLFW_KEY_H                      72
#define GLFW_KEY_I                      73
#define GLFW_KEY_J                      74
#define GLFW_KEY_K                      75
#define GLFW_KEY_L                      76
#define GLFW_KEY_M                      77
#define GLFW_KEY_N                      78
#define GLFW_KEY_O                      79
#define GLFW_KEY_P                      80
#define GLFW_KEY_Q                      81
#define GLFW_KEY_R                      82
#define GLFW_KEY_S                      83
#define GLFW_KEY_T                      84
#define GLFW_KEY_U                      85
#define GLFW_KEY_V                      86
#define GLFW_KEY_W                      87
#define GLFW_KEY_X                      88
#define GLFW_KEY_Y                      89
#define GLFW_KEY_Z                      90
#define GLFW_KEY_LEFT_BRACKET           91  /* [ */
#define GLFW_KEY_BACKSLASH              92  /* \ */
#define GLFW_KEY_RIGHT_BRACKET          93  /* ] */
#define GLFW_KEY_GRAVE_ACCENT           96  /* ` */
#define GLFW_KEY_WORLD_1                161 /* non-US #1 */
#define GLFW_KEY_WORLD_2                162 /* non-US #2 */

/* Function keys */
#define GLFW_KEY_ESCAPE                 256
#define GLFW_KEY_ENTER                  257
#define GLFW_KEY_TAB                    258
#define GLFW_KEY_BACKSPACE              259
#define GLFW_KEY_INSERT                 260
#define GLFW_KEY_DELETE                 261
#define GLFW_KEY_RIGHT                  262
#define GLFW_KEY_LEFT                   263
#define GLFW_KEY_DOWN                   264
#define GLFW_KEY_UP                     265
#define GLFW_KEY_PAGE_UP                266
#define GLFW_KEY_PAGE_DOWN              267
#define GLFW_KEY_HOME                   268
#define GLFW_KEY_END                    269
#define GLFW_KEY_CAPS_LOCK              280
#define GLFW_KEY_SCROLL_LOCK            281
#define GLFW_KEY_NUM_LOCK               282
#define GLFW_KEY_PRINT_SCREEN           283
#define GLFW_KEY_PAUSE                  284
#define GLFW_KEY_F1                     290
#define GLFW_KEY_F2                     291
#define GLFW_KEY_F3                     292
#define GLFW_KEY_F4                     293
#define GLFW_KEY_F5                     294
#define GLFW_KEY_F6                     295
#define GLFW_KEY_F7                     296
#define GLFW_KEY_F8                     297
#define GLFW_KEY_F9                     298
#define GLFW_KEY_F10                    299
#define GLFW_KEY_F11                    300
#define GLFW_KEY_F12                    301
#define GLFW_KEY_F13                    302
#define GLFW_KEY_F14                    303
#define GLFW_KEY_F15                    304
#define GLFW_KEY_F16                    305
#define GLFW_KEY_F17                    306
#define GLFW_KEY_F18                    307
#define GLFW_KEY_F19                    308
#define GLFW_KEY_F20                    309
#define GLFW_KEY_F21                    310
#define GLFW_KEY_F22                    311
#define GLFW_KEY_F23                    312
#define GLFW_KEY_F24                    313
#define GLFW_KEY_F25                    314
#define GLFW_KEY_KP_0                   320
#define GLFW_KEY_KP_1                   321
#define GLFW_KEY_KP_2                   322
#define GLFW_KEY_KP_3                   323
#define GLFW_KEY_KP_4                   324
#define GLFW_KEY_KP_5                   325
#define GLFW_KEY_KP_6                   326
#define GLFW_KEY_KP_7                   327
#define GLFW_KEY_KP_8                   328
#define GLFW_KEY_KP_9                   329
#define GLFW_KEY_KP_DECIMAL             330
#define GLFW_KEY_KP_DIVIDE              331
#define GLFW_KEY_KP_MULTIPLY            332
#define GLFW_KEY_KP_SUBTRACT            333
#define GLFW_KEY_KP_ADD                 334
#define GLFW_KEY_KP_ENTER               335
#define GLFW_KEY_KP_EQUAL               336
#define GLFW_KEY_LEFT_SHIFT             340
#define GLFW_KEY_LEFT_CONTROL           341
#define GLFW_KEY_LEFT_ALT               342
#define GLFW_KEY_LEFT_SUPER             343
#define GLFW_KEY_RIGHT_SHIFT            344
#define GLFW_KEY_RIGHT_CONTROL          345
#define GLFW_KEY_RIGHT_ALT              346
#define GLFW_KEY_RIGHT_SUPER            347
#define GLFW_KEY_MENU                   348
#define GLFW_KEY_LAST                   GLFW_KEY_MENU

/* GLFW 2.x key name aliases (deprecated) */
#define GLFW_KEY_ESC            GLFW_KEY_ESCAPE
#define GLFW_KEY_DEL            GLFW_KEY_DELETE
#define GLFW_KEY_PAGEUP         GLFW_KEY_PAGE_UP
#define GLFW_KEY_PAGEDOWN       GLFW_KEY_PAGE_DOWN
#define GLFW_KEY_KP_NUM_LOCK    GLFW_KEY_NUM_LOCK
#define GLFW_KEY_LCTRL          GLFW_KEY_LEFT_CONTROL
#define GLFW_KEY_LSHIFT         GLFW_KEY_LEFT_SHIFT
#define GLFW_KEY_LALT           GLFW_KEY_LEFT_ALT
#define GLFW_KEY_LSUPER         GLFW_KEY_LEFT_SUPER
#define GLFW_KEY_RCTRL          GLFW_KEY_RIGHT_CONTROL
#define GLFW_KEY_RSHIFT         GLFW_KEY_RIGHT_SHIFT
#define GLFW_KEY_RALT           GLFW_KEY_RIGHT_ALT
#define GLFW_KEY_RSUPER         GLFW_KEY_RIGHT_SUPER

/* Mouse button definitions */
#define GLFW_MOUSE_BUTTON_1      0
#define GLFW_MOUSE_BUTTON_2      1
#define GLFW_MOUSE_BUTTON_3      2
#define GLFW_MOUSE_BUTTON_4      3
#define GLFW_MOUSE_BUTTON_5      4
#define GLFW_MOUSE_BUTTON_6      5
#define GLFW_MOUSE_BUTTON_7      6
#define GLFW_MOUSE_BUTTON_8      7
#define GLFW_MOUSE_BUTTON_LAST   GLFW_MOUSE_BUTTON_8

/* Mouse button aliases */
#define GLFW_MOUSE_BUTTON_LEFT   GLFW_MOUSE_BUTTON_1
#define GLFW_MOUSE_BUTTON_RIGHT  GLFW_MOUSE_BUTTON_2
#define GLFW_MOUSE_BUTTON_MIDDLE GLFW_MOUSE_BUTTON_3


/*************************************************************************
 * Other definitions
 *************************************************************************/

/* glfwCreateWindow modes */
#define GLFW_WINDOWED             0x00010001
#define GLFW_FULLSCREEN           0x00010002

/* glfwCreateWindow kinds */
#define GLFW_WINDOW               0x00010011
#define GLFW_DIALOG               0x00010012
#define GLFW_POPUP                0x00010013

/* glfwGetWindowParam tokens */
#define GLFW_ACTIVE               0x00020001
#define GLFW_ICONIFIED            0x00020002
#define GLFW_CLOSE_REQUESTED      0x00020003
#define GLFW_OPENGL_REVISION      0x00020004

/* glfwWindowHint tokens */
#define GLFW_RED_BITS             0x00021000
#define GLFW_GREEN_BITS           0x00021001
#define GLFW_BLUE_BITS            0x00021002
#define GLFW_ALPHA_BITS           0x00021003
#define GLFW_DEPTH_BITS           0x00021004
#define GLFW_STENCIL_BITS         0x00021005
#define GLFW_REFRESH_RATE         0x00021006
#define GLFW_ACCUM_RED_BITS       0x00021007
#define GLFW_ACCUM_GREEN_BITS     0x00021008
#define GLFW_ACCUM_BLUE_BITS      0x00021009
#define GLFW_ACCUM_ALPHA_BITS     0x0002100A
#define GLFW_AUX_BUFFERS          0x0002100B
#define GLFW_STEREO               0x0002100C
#define GLFW_FSAA_SAMPLES         0x0002100E

/* The following constants are used with both glfwGetWindowParam
 * and glfwWindowHint
 */
#define GLFW_CLIENT_API           0x00022000
#define GLFW_OPENGL_VERSION_MAJOR 0x00022001
#define GLFW_OPENGL_VERSION_MINOR 0x00022002
#define GLFW_OPENGL_FORWARD_COMPAT 0x00022003
#define GLFW_OPENGL_DEBUG_CONTEXT 0x00022004
#define GLFW_OPENGL_PROFILE       0x00022005
#define GLFW_OPENGL_ROBUSTNESS    0x00022006
#define GLFW_RESIZABLE            0x00022007
#define GLFW_VISIBLE              0x00022008

/* GLFW_CLIENT_API tokens */
#define GLFW_OPENGL_API           0x00000001
#define GLFW_OPENGL_ES_API        0x00000002

/* GLFW_OPENGL_ROBUSTNESS mode tokens */
#define GLFW_OPENGL_NO_ROBUSTNESS         0x00000000
#define GLFW_OPENGL_NO_RESET_NOTIFICATION 0x00000001
#define GLFW_OPENGL_LOSE_CONTEXT_ON_RESET 0x00000002

/* GLFW_OPENGL_PROFILE bit tokens */
#define GLFW_OPENGL_NO_PROFILE    0x00000000
#define GLFW_OPENGL_CORE_PROFILE  0x00000001
#define GLFW_OPENGL_COMPAT_PROFILE 0x00000002

/* glfwGetInputMode/glfwSetInputMode tokens */
#define GLFW_CURSOR_MODE          0x00030001

/* GLFW_CURSOR_MODE values */
#define GLFW_CURSOR_NORMAL       0x00040001
#define GLFW_CURSOR_HIDDEN       0x00040002
#define GLFW_CURSOR_CAPTURED     0x00040003

/* glfwGetError/glfwErrorString tokens */
#define GLFW_NO_ERROR             0
#define GLFW_NOT_INITIALIZED      0x00070001
#define GLFW_NO_CURRENT_CONTEXT   0x00070002
#define GLFW_INVALID_ENUM         0x00070003
#define GLFW_INVALID_VALUE        0x00070004
#define GLFW_OUT_OF_MEMORY        0x00070005
#define GLFW_OPENGL_UNAVAILABLE   0x00070006
#define GLFW_VERSION_UNAVAILABLE  0x00070007
#define GLFW_PLATFORM_ERROR       0x00070008
#define GLFW_WINDOW_NOT_ACTIVE    0x00070009
#define GLFW_FORMAT_UNAVAILABLE   0x0007000A

/*************************************************************************
 * Typedefs
 *************************************************************************/

/* OpenGL function pointer type */
typedef void (*GLFWglproc)(void);

/* Window handle type */
typedef _GLFWwindow* GLFWwindow;

/* Function pointer types */
typedef void (* GLFWerrorfun)(int,const char*);
typedef void (* GLFWwindowsizefun)(GLFWwindow,int,int);
typedef int  (* GLFWwindowclosefun)(GLFWwindow);
typedef void (* GLFWwindowrefreshfun)(GLFWwindow);
typedef void (* GLFWwindowfocusfun)(GLFWwindow,int);
typedef void (* GLFWwindowiconifyfun)(GLFWwindow,int);
typedef void (* GLFWmousebuttonfun)(GLFWwindow,int,int);
typedef void (* GLFWcursorposfun)(GLFWwindow,int,int);
typedef void (* GLFWcursorenterfun)(GLFWwindow,int);
typedef void (* GLFWscrollfun)(GLFWwindow,double,double);
typedef void (* GLFWkeyfun)(GLFWwindow,int,int);
typedef void (* GLFWcharfun)(GLFWwindow,int);

/* The video mode structure used by glfwGetVideoModes */
typedef struct
{
    int width;
    int height;
    int redBits;
    int blueBits;
    int greenBits;
} GLFWvidmode;


/*************************************************************************
 * Prototypes
 *************************************************************************/

/* Initialization, termination and version querying */
GLFWAPI int  glfwInit(void);
GLFWAPI void glfwTerminate(void);
GLFWAPI void glfwGetVersion(int* major, int* minor, int* rev);

/* Error handling */
GLFWAPI int glfwGetError(void);
GLFWAPI const char* glfwErrorString(int error);
GLFWAPI void glfwSetErrorCallback(GLFWerrorfun cbfun);

/* Video mode functions */
GLFWAPI GLFWvidmode* glfwGetVideoModes(int* count);
GLFWAPI void glfwGetDesktopMode(GLFWvidmode* mode);

/* Window handling */
GLFWAPI void glfwDefaultWindowHints(void);
GLFWAPI void glfwWindowHint(int target, int hint);
GLFWAPI GLFWwindow glfwCreateWindow(int width, int height, int mode, int kind, const char* title, GLFWwindow share, bool opengl);
GLFWAPI void glfwDestroyWindow(GLFWwindow window);
GLFWAPI void glfwSetWindowTitle(GLFWwindow window, const char* title);
GLFWAPI void glfwGetWindowSize(GLFWwindow window, int* width, int* height);
GLFWAPI void glfwSetWindowSize(GLFWwindow window, int width, int height);
GLFWAPI void glfwGetWindowPos(GLFWwindow window, int* xpos, int* ypos);
GLFWAPI void glfwSetWindowPos(GLFWwindow window, int xpos, int ypos);
GLFWAPI void glfwIconifyWindow(GLFWwindow window);
GLFWAPI void glfwRestoreWindow(GLFWwindow window);
GLFWAPI void glfwShowWindow(GLFWwindow window);
GLFWAPI void glfwHideWindow(GLFWwindow window);
GLFWAPI int  glfwGetWindowParam(GLFWwindow window, int param);
GLFWAPI void glfwSetWindowUserPointer(GLFWwindow window, void* pointer);
GLFWAPI void* glfwGetWindowUserPointer(GLFWwindow window);
GLFWAPI void glfwSetWindowSizeCallback(GLFWwindow window, GLFWwindowsizefun cbfun);
GLFWAPI void glfwSetWindowCloseCallback(GLFWwindow window, GLFWwindowclosefun cbfun);
GLFWAPI void glfwSetWindowRefreshCallback(GLFWwindow window, GLFWwindowrefreshfun cbfun);
GLFWAPI void glfwSetWindowFocusCallback(GLFWwindow window, GLFWwindowfocusfun cbfun);
GLFWAPI void glfwSetWindowIconifyCallback(GLFWwindow window, GLFWwindowiconifyfun cbfun);

/* Event handling */
GLFWAPI void glfwPollEvents(void);
GLFWAPI void glfwWaitEvents(void);

/* Input handling */
GLFWAPI int  glfwGetInputMode(GLFWwindow window, int mode);
GLFWAPI void glfwSetInputMode(GLFWwindow window, int mode, int value);
GLFWAPI int  glfwGetKey(int key);
GLFWAPI int  glfwGetMouseButton(GLFWwindow window, int button);
GLFWAPI void glfwGetCursorPos(GLFWwindow window, int* xpos, int* ypos);
GLFWAPI void glfwSetCursorPos(GLFWwindow window, int xpos, int ypos);
GLFWAPI void glfwGetScrollOffset(GLFWwindow window, double* xoffset, double* yoffset);
GLFWAPI void glfwSetKeyCallback(GLFWwindow window, GLFWkeyfun cbfun);
GLFWAPI void glfwSetCharCallback(GLFWwindow window, GLFWcharfun cbfun);
GLFWAPI void glfwSetMouseButtonCallback(GLFWwindow window, GLFWmousebuttonfun cbfun);
GLFWAPI void glfwSetCursorPosCallback(GLFWwindow window, GLFWcursorposfun cbfun);
GLFWAPI void glfwSetCursorEnterCallback(GLFWwindow window, GLFWcursorenterfun cbfun);
GLFWAPI void glfwSetScrollCallback(GLFWwindow window, GLFWscrollfun cbfun);

/* Clipboard */
GLFWAPI void glfwSetClipboardString(GLFWwindow window, const char* string);
GLFWAPI const char* glfwGetClipboardString(GLFWwindow window);

/* Time */
GLFWAPI double glfwGetTime(void);
GLFWAPI void   glfwSetTime(double time);

/* OpenGL support */
GLFWAPI void glfwMakeContextCurrent(GLFWwindow window);
GLFWAPI GLFWwindow glfwGetCurrentContext(void);
GLFWAPI void  glfwSwapBuffers(GLFWwindow window);
GLFWAPI void  glfwSwapInterval(int interval);
GLFWAPI int   glfwExtensionSupported(const char* extension);
GLFWAPI GLFWglproc glfwGetProcAddress(const char* procname);
GLFWAPI void  glfwCopyContext(GLFWwindow src, GLFWwindow dst, unsigned long mask);


/*************************************************************************
 * Global definition cleanup
 *************************************************************************/


#include "GL/glext.h"

#include <stdint.h>


#if defined(__OBJC__)
#import <Cocoa/Cocoa.h>
#else
#include <ApplicationServices/ApplicationServices.h>
typedef void* id;
#endif


//========================================================================
// GLFW platform specific types
//========================================================================

//------------------------------------------------------------------------
// Pointer length integer
//------------------------------------------------------------------------
typedef intptr_t GLFWintptr;


//------------------------------------------------------------------------
// Platform-specific OpenGL context structure
//------------------------------------------------------------------------
typedef struct _GLFWcontextNSGL
{
    id           pixelFormat;
    id	         context;
} _GLFWcontextNSGL;


//------------------------------------------------------------------------
// Platform-specific window structure
//------------------------------------------------------------------------
typedef struct _GLFWwindowNS
{
    id           object;
    id	        delegate;
    id           view;
} _GLFWwindowNS;


//------------------------------------------------------------------------
// Platform-specific library global data for Cocoa
//------------------------------------------------------------------------
typedef struct _GLFWlibraryNS
{
    struct {
        double base;
        double resolution;
    } timer;

    CGDisplayModeRef desktopMode;
    CGEventSourceRef eventSource;
    id               delegate;
    id               autoreleasePool;

    char*            clipboardString;
} _GLFWlibraryNS;


//------------------------------------------------------------------------
// Platform-specific library global data for NSGL
//------------------------------------------------------------------------
typedef struct _GLFWlibraryNSGL
{
    // dlopen handle for dynamically loading OpenGL extension entry points
    void*            framework;
} _GLFWlibraryNSGL;


//========================================================================
// Prototypes for platform specific internal functions
//========================================================================

// Time
void _glfwInitTimer(void);

// Fullscreen
GLboolean _glfwSetVideoMode(int* width, int* height, int* bpp, int* refreshRate);
void _glfwRestoreVideoMode(void);

// OpenGL support
int _glfwInitOpenGL(void);
void _glfwTerminateOpenGL(void);


//------------------------------------------------------------------------
// Window hints, set by glfwWindowHint and consumed by glfwCreateWindow
// A bucket of semi-random stuff lumped together for historical reasons
// This is used only by the platform independent code and only to store
// parameters passed to us by glfwWindowHint
//------------------------------------------------------------------------
struct _GLFWhints
{
    int         redBits;
    int         greenBits;
    int         blueBits;
    int         alphaBits;
    int         depthBits;
    int         stencilBits;
    int         refreshRate;
    int         accumRedBits;
    int         accumGreenBits;
    int         accumBlueBits;
    int         accumAlphaBits;
    int         auxBuffers;
    GLboolean   stereo;
    GLboolean   resizable;
    GLboolean   visible;
    int         samples;
    int         clientAPI;
    int         glMajor;
    int         glMinor;
    GLboolean   glForward;
    GLboolean   glDebug;
    int         glProfile;
    int         glRobustness;
};


//------------------------------------------------------------------------
// Parameters relating to the creation of the context and window but not
// directly related to the properties of the framebuffer
// This is used to pass window and context creation parameters from the
// platform independent code to the platform specific code
//------------------------------------------------------------------------
struct _GLFWwndconfig
{
    int           mode;
    const char*   title;
    int           refreshRate;
    GLboolean     resizable;
    GLboolean     visible;
    int           clientAPI;
    int           glMajor;
    int           glMinor;
    GLboolean     glForward;
    GLboolean     glDebug;
    int           glProfile;
    int           glRobustness;
    _GLFWwindow*  share;
};


//------------------------------------------------------------------------
// Framebuffer configuration descriptor, i.e. buffers and their sizes
// Also a platform specific ID used to map back to the actual backend APIs
// This is used to pass framebuffer parameters from the platform independent
// code to the platform specific code, and also to enumerate and select
// available framebuffer configurations
//------------------------------------------------------------------------
struct _GLFWfbconfig
{
    int         redBits;
    int         greenBits;
    int         blueBits;
    int         alphaBits;
    int         depthBits;
    int         stencilBits;
    int         accumRedBits;
    int         accumGreenBits;
    int         accumBlueBits;
    int         accumAlphaBits;
    int         auxBuffers;
    GLboolean   stereo;
    int         samples;
    GLFWintptr  platformID;
};


struct _GLFWinputstate
{
    char      key[GLFW_KEY_LAST + 1];
    unsigned int modifierFlags;
};


//------------------------------------------------------------------------
// Window structure
//------------------------------------------------------------------------
struct _GLFWwindow
{
    struct _GLFWwindow* next;

    // Window settings and state
    GLboolean iconified;       // GL_TRUE if this window is iconified
    GLboolean closeRequested;  // GL_TRUE if this window should be closed
    int       width, height;
    int       positionX, positionY;
    int       mode;            // GLFW_WINDOW or GLFW_FULLSCREEN
    GLboolean resizable;       // GL_TRUE if user may resize this window
    GLboolean visible;         // GL_TRUE if this window is visible
    int       refreshRate;     // monitor refresh rate
    void*     userPointer;

    // Window input state
    int       cursorPosX, cursorPosY;
    int       cursorMode;
    double    scrollX, scrollY;
    char      mouseButton[GLFW_MOUSE_BUTTON_LAST + 1];

    // OpenGL extensions and context attributes
    int       clientAPI;
    int       glMajor, glMinor, glRevision;
    GLboolean glForward, glDebug;
    int       glProfile;
    int       glRobustness;

    GLFWwindowsizefun    windowSizeCallback;
    GLFWwindowclosefun   windowCloseCallback;
    GLFWwindowrefreshfun windowRefreshCallback;
    GLFWwindowfocusfun   windowFocusCallback;
    GLFWwindowiconifyfun windowIconifyCallback;
    GLFWmousebuttonfun   mouseButtonCallback;
    GLFWcursorposfun     cursorPosCallback;
    GLFWcursorenterfun   cursorEnterCallback;
    GLFWscrollfun        scrollCallback;
    GLFWkeyfun           keyCallback;
    GLFWcharfun          charCallback;

    // These are defined in the current port's platform.h
    _GLFWwindowNS NS;
    _GLFWcontextNSGL NSGL;
};


//------------------------------------------------------------------------
// Library global data
//------------------------------------------------------------------------
struct _GLFWlibrary
{
    _GLFWhints    hints;

    _GLFWwindow*  windowListHead;
    _GLFWwindow*  activeWindow;

    GLFWwindowsizefun    windowSizeCallback;
    GLFWwindowclosefun   windowCloseCallback;
    GLFWwindowrefreshfun windowRefreshCallback;
    GLFWwindowfocusfun   windowFocusCallback;
    GLFWwindowiconifyfun windowIconifyCallback;
    GLFWmousebuttonfun   mouseButtonCallback;
    GLFWcursorposfun     cursorPosCallback;
    GLFWcursorenterfun   cursorEnterCallback;
    GLFWscrollfun        scrollCallback;
    GLFWkeyfun           keyCallback;
    GLFWcharfun          charCallback;

    GLFWvidmode*  modes;

    // This is defined in the current port's platform.h
    _GLFWlibraryNS NS;
    _GLFWlibraryNSGL NSGL;
};


//------------------------------------------------------------------------
// Global state shared between compilation units of GLFW
// These are exported from and documented in init.c
//------------------------------------------------------------------------
extern GLboolean _glfwInitialized;
extern _GLFWlibrary _glfwLibrary;
_GLFWinputstate _glfwInputState;


//========================================================================
// Prototypes for the platform API
// This is the interface exposed by the platform-specific code for each
// platform and is called by the shared code of the public API
// It mirrors the public API except it uses objects instead of handles
//========================================================================

// Platform init and version
int _glfwPlatformInit(void);
int _glfwPlatformTerminate(void);

// Input mode support
void _glfwPlatformSetCursorPos(_GLFWwindow* window, int x, int y);
void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode);

// Video mode support
GLFWvidmode* _glfwPlatformGetVideoModes(int* count);
void _glfwPlatformGetDesktopMode(GLFWvidmode* mode);

// Clipboard support
void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string);
const char* _glfwPlatformGetClipboardString(_GLFWwindow* window);

// Time input
double _glfwPlatformGetTime(void);
void _glfwPlatformSetTime(double time);

// Window management
int  _glfwPlatformCreateWindow(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWfbconfig* fbconfig,int kind, bool opengl);
void _glfwPlatformDestroyWindow(_GLFWwindow* window);
void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title);
void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height);
void _glfwPlatformSetWindowPos(_GLFWwindow* window, int x, int y);
void _glfwPlatformIconifyWindow(_GLFWwindow* window);
void _glfwPlatformRestoreWindow(_GLFWwindow* window);
void _glfwPlatformShowWindow(_GLFWwindow* window);
void _glfwPlatformHideWindow(_GLFWwindow* window);

// Event processing
void _glfwPlatformPollEvents(void);
void _glfwPlatformWaitEvents(void);

// OpenGL context management
void _glfwPlatformMakeContextCurrent(_GLFWwindow* window);
_GLFWwindow* _glfwPlatformGetCurrentContext(void);
void _glfwPlatformSwapBuffers(_GLFWwindow* window);
void _glfwPlatformSwapInterval(int interval);
void _glfwPlatformRefreshWindowParams(_GLFWwindow* window);
int  _glfwPlatformExtensionSupported(const char* extension);
GLFWglproc _glfwPlatformGetProcAddress(const char* procname);
void _glfwPlatformCopyContext(_GLFWwindow* src, _GLFWwindow* dst, unsigned long mask);


//========================================================================
// Prototypes for the event API
// This is used by the platform-specific code to notify the shared code of
// events that can be translated into state changes and/or callback calls,
// instead of directly calling callbacks or modifying shared state
//========================================================================

// Window event notification (window.c)
void _glfwInputWindowFocus(_GLFWwindow* window, GLboolean activated);
void _glfwInputWindowPos(_GLFWwindow* window, int x, int y);
void _glfwInputWindowSize(_GLFWwindow* window, int width, int height);
void _glfwInputWindowIconify(_GLFWwindow* window, int iconified);
void _glfwInputWindowVisibility(_GLFWwindow* window, int visible);
void _glfwInputWindowDamage(_GLFWwindow* window);
void _glfwInputWindowCloseRequest(_GLFWwindow* window);

// Input event notification (input.c)
bool _glfwInputKey(_GLFWwindow* window, int key, int action);
void _glfwInputChar(_GLFWwindow* window, int character);
void _glfwInputScroll(_GLFWwindow* window, double x, double y);
void _glfwDrawRect( _GLFWwindow* window, NSRect dirtyRect);
void _glfwInputMouseClick(_GLFWwindow* window, int button, int clickCount, int action);
void _glfwInputCursorMotion(_GLFWwindow* window, int x, int y);
void _glfwInputCursorEnter(_GLFWwindow* window, int entered);


//========================================================================
// Prototypes for internal utility functions
// These functions are shared code and may be used by any part of GLFW
// Each platform may add its own utility functions, but those may only be
// called by the platform-specific code
//========================================================================

// Fullscren management (fullscreen.c)
int _glfwCompareVideoModes(const GLFWvidmode* first, const GLFWvidmode* second);
void _glfwSplitBPP(int bpp, int* red, int* green, int* blue);

// Error handling (init.c)
void _glfwSetError(int error, const char* format, ...);

// OpenGL context helpers (opengl.c)
int _glfwStringInExtensionString(const char* string, const GLubyte* extensions);
const _GLFWfbconfig* _glfwChooseFBConfig(const _GLFWfbconfig* desired,
                                         const _GLFWfbconfig* alternatives,
                                         unsigned int count);
GLboolean _glfwRefreshContextParams(void);
GLboolean _glfwIsValidContextConfig(_GLFWwndconfig* wndconfig);
GLboolean _glfwIsValidContext(_GLFWwndconfig* wndconfig);

"#)


;;;
;;;; Platform Types
;;;


(c-type CGFloat (native double))


(c-structure NSPoint
  (CGFloat x)
  (CGFloat y))


(c-structure NSSize
  (CGFloat width)
  (CGFloat height))


(c-structure NSRect
  (NSPoint origin)
  (NSSize size))


(c-type CGContextRef (pointer (struct "CGContext")))


;;;
;;;; Platform Conversions
;;;


(definition public (new-NSPoint x <fx> y <fx>)
  (let ((point (NSPoint-make)))
    (NSPoint-x-set! point (fl x))
    (NSPoint-y-set! point (fl y))
    point))


(definition public (with-NSPoint point proc)
  (let ((pt (if point (point->NSPoint point) (NSPoint-make))))
    (prog1 (proc pt)
      (NSPoint-free pt))))


(definition public (NSPoint->point pt) <Point>
  (if (not pt)
      #f
    (new Point
      (fxround (NSPoint-x-ref pt))
      (fxround (NSPoint-y-ref pt)))))


(definition public (point->NSPoint point)
  (new-NSPoint (get-h~ point) (get-v~ point)))


(definition public (new-NSSize width <fx> height <fx>)
  (let ((size (NSSize-make)))
    (NSSize-width-set! size (fl width))
    (NSSize-height-set! size (fl height))
    size))


(definition public (with-NSSize dim proc)
  (let ((size (if dim (dimension->NSSize dim) (NSSize-make))))
    (prog1 (proc size)
      (NSSize-free size))))


(definition public (NSSize->dimension size) <Point>
  (if (not size)
      #f
    (new Dimension
      (fxround (NSSize-width-ref size))
      (fxround (NSSize-height-ref size)))))


(definition public (dimension->NSSize dim)
  (new-NSSize (get-width~ dim) (get-height~ dim)))


(definition public (new-NSRect left <fx> top <fx> right <fx> bottom <fx>)
  (let ((rect (NSRect-make)))
    (let ((orig (NSRect-origin-ref rect))
          (size (NSRect-size-ref rect)))
      (NSPoint-x-set!     orig (fl left))
      (NSPoint-y-set!     orig (fl top))
      (NSSize-width-set!  size (fl (- right left)))
      (NSSize-height-set! size (fl (- bottom top)))
      rect)))


(definition public (with-NSRect rect proc)
  (let ((rect (if rect (rect->NSRect rect) (NSRect-make))))
    (prog1 (proc rect)
      (NSRect-free rect))))


(definition public (rect->NSRect rect)
  (new-NSRect (get-left~ rect)
              (get-top~ rect)
              (get-right~ rect)
              (get-bottom~ rect)))


(definition public (NSRect->rect rect) <Rect>
  (if (not rect)
      #f
    (let ((orig (NSRect-origin-ref rect))
          (size (NSRect-size-ref rect)))
      (new Rect
        (fxround (NSPoint-x-ref orig))
        (fxround (NSPoint-y-ref orig))
        (fxround (+ (NSPoint-x-ref orig) (NSSize-width-ref size)))
        (fxround (+ (NSPoint-y-ref orig) (NSSize-height-ref size)))))))


;;;
;;;; Platform Callbacks
;;;


(c-declare cocoa #"

void call_error(char* msg);
void call_debug(char* msg);
void call_terminal(char* msg);
void reshape_callback(_GLFWwindow* window, int width, int height);
void close_callback(_GLFWwindow* window);
void paint_callback(_GLFWwindow* window, CGContextRef context, NSRect* dirtyRect);
int key_press_callback(_GLFWwindow* window, int key, int action);
void char_callback(_GLFWwindow* window, int c);
void button_callback(_GLFWwindow* window, int x, int y, int button, int clickCount, int action);
void move_callback(_GLFWwindow* window, int x, int y);
void wheel_callback(_GLFWwindow* window, double x, double y);
void file_callback(NSString* filename);
void drop_callback(_GLFWwindow* window, NSArray* filenames);
void activate_callback(_GLFWwindow* window);
void deactivate_callback(_GLFWwindow* window);

"#)


;;;
;;;; Platform Debug
;;;


(c-declare cocoa #"

void debug(NSString* str)
{
    call_debug([str UTF8String]);
}

void terminal(NSString* str)
{
    call_terminal([str UTF8String]);
}

"#)


;;;
;;;; Platform Init
;;;


(c-declare cocoa #"

#include <sys/param.h> // For MAXPATHLEN

_GLFWwindow* currentWindow;

//========================================================================
// Change to our application bundle's resources directory, if present
//========================================================================

static void changeToResourcesDirectory(void)
{
    char resourcesPath[MAXPATHLEN];

    CFBundleRef bundle = CFBundleGetMainBundle();
    if (!bundle)
        return;

    CFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(bundle);

    CFStringRef last = CFURLCopyLastPathComponent(resourcesURL);
    if (CFStringCompare(CFSTR("Resources"), last, 0) != kCFCompareEqualTo)
    {
        CFRelease(last);
        CFRelease(resourcesURL);
        return;
    }

    CFRelease(last);

    if (!CFURLGetFileSystemRepresentation(resourcesURL,
                                          true,
                                          (UInt8*) resourcesPath,
                                          MAXPATHLEN))
    {
        CFRelease(resourcesURL);
        return;
    }

    CFRelease(resourcesURL);

    chdir(resourcesPath);
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Initialize the GLFW library
//========================================================================

int _glfwPlatformInit(void)
{
    _glfwLibrary.NS.autoreleasePool = [[NSAutoreleasePool alloc] init];

    _glfwLibrary.NSGL.framework =
        CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));
    if (_glfwLibrary.NSGL.framework == NULL)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR,
                      "glfwInit: Failed to locate OpenGL framework");
        return GL_FALSE;
    }

    changeToResourcesDirectory();

    _glfwLibrary.NS.desktopMode = CGDisplayCopyDisplayMode(CGMainDisplayID());

    _glfwInitTimer();

    if (!_glfwInitOpenGL())
        return GL_FALSE;

    _glfwLibrary.NS.eventSource = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);
    if (!_glfwLibrary.NS.eventSource)
        return GL_FALSE;

    CGEventSourceSetLocalEventsSuppressionInterval(_glfwLibrary.NS.eventSource,
                                                   0.0);

    return GL_TRUE;
}


//========================================================================
// Close window, if open, and shut down GLFW
//========================================================================

int _glfwPlatformTerminate(void)
{
    // TODO: Probably other cleanup

    if (_glfwLibrary.NS.eventSource)
    {
        CFRelease(_glfwLibrary.NS.eventSource);
        _glfwLibrary.NS.eventSource = NULL;
    }

    CGDisplayModeRelease(_glfwLibrary.NS.desktopMode);

    [NSApp setDelegate:nil];
    [_glfwLibrary.NS.delegate release];
    _glfwLibrary.NS.delegate = nil;

    [_glfwLibrary.NS.autoreleasePool release];
    _glfwLibrary.NS.autoreleasePool = nil;

    _glfwTerminateOpenGL();

    return GL_TRUE;
}

"#)


;;;
;;;; Platform Clipboard
;;;


(c-declare cocoa #"

#include <limits.h>
#include <string.h>


//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Set the clipboard contents
//========================================================================

void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string)
{
    NSArray* types = [NSArray arrayWithObjects:NSStringPboardType, nil];

    NSPasteboard* pasteboard = [NSPasteboard generalPasteboard];
    [pasteboard declareTypes:types owner:nil];
    [pasteboard setString:[NSString stringWithUTF8String:string]
                  forType:NSStringPboardType];
}


//========================================================================
// Return the current clipboard contents
//========================================================================

const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
{
    NSPasteboard* pasteboard = [NSPasteboard generalPasteboard];

    if (![[pasteboard types] containsObject:NSStringPboardType])
    {
        _glfwSetError(GLFW_FORMAT_UNAVAILABLE, NULL);
        return NULL;
    }

    NSString* object = [pasteboard stringForType:NSStringPboardType];
    if (!object)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR,
                      "Cocoa: Failed to retrieve object from pasteboard");
        return NULL;
    }

    free(_glfwLibrary.NS.clipboardString);
    _glfwLibrary.NS.clipboardString = strdup([object UTF8String]);

    return _glfwLibrary.NS.clipboardString;
}

"#)


;;;
;;;; Platform Fullscreen
;;;


(c-declare cocoa #"

#include <stdlib.h>
#include <limits.h>


//========================================================================
// Check whether the display mode should be included in enumeration
//========================================================================

static GLboolean modeIsGood(CGDisplayModeRef mode)
{
    uint32_t flags = CGDisplayModeGetIOFlags(mode);
    if (!(flags & kDisplayModeValidFlag) || !(flags & kDisplayModeSafeFlag))
        return GL_FALSE;

    if (flags & kDisplayModeInterlacedFlag)
        return GL_FALSE;

    if (flags & kDisplayModeTelevisionFlag)
        return GL_FALSE;

    if (flags & kDisplayModeStretchedFlag)
        return GL_FALSE;

    CFStringRef format = CGDisplayModeCopyPixelEncoding(mode);
    if (CFStringCompare(format, CFSTR(IO16BitDirectPixels), 0) &&
        CFStringCompare(format, CFSTR(IO32BitDirectPixels), 0))
    {
        CFRelease(format);
        return GL_FALSE;
    }

    CFRelease(format);
    return GL_TRUE;
}


//========================================================================
// Convert Core Graphics display mode to GLFW video mode
//========================================================================

static GLFWvidmode vidmodeFromCGDisplayMode(CGDisplayModeRef mode)
{
    GLFWvidmode result;
    result.width = CGDisplayModeGetWidth(mode);
    result.height = CGDisplayModeGetHeight(mode);

    CFStringRef format = CGDisplayModeCopyPixelEncoding(mode);

    if (CFStringCompare(format, CFSTR(IO16BitDirectPixels), 0) == 0)
    {
        result.redBits = 5;
        result.greenBits = 5;
        result.blueBits = 5;
    }
    else
    {
        result.redBits = 8;
        result.greenBits = 8;
        result.blueBits = 8;
    }

    CFRelease(format);
    return result;
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Change the current video mode
//========================================================================

GLboolean _glfwSetVideoMode(int* width, int* height, int* bpp, int* refreshRate)
{
    CGDisplayModeRef bestMode = NULL;
    CFArrayRef modes;
    CFIndex count, i;
    unsigned int leastSizeDiff = UINT_MAX;
    double leastRateDiff = DBL_MAX;

    modes = CGDisplayCopyAllDisplayModes(CGMainDisplayID(), NULL);
    count = CFArrayGetCount(modes);

    for (i = 0;  i < count;  i++)
    {
        CGDisplayModeRef mode = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);
        if (!modeIsGood(mode))
            continue;

        int modeBPP;

        // Identify display mode pixel encoding
        {
            CFStringRef format = CGDisplayModeCopyPixelEncoding(mode);

            if (CFStringCompare(format, CFSTR(IO16BitDirectPixels), 0) == 0)
                modeBPP = 16;
            else
                modeBPP = 32;

            CFRelease(format);
        }

        int modeWidth = (int) CGDisplayModeGetWidth(mode);
        int modeHeight = (int) CGDisplayModeGetHeight(mode);

        unsigned int sizeDiff = (abs(modeBPP - *bpp) << 25) |
                                ((modeWidth - *width) * (modeWidth - *width) +
                                 (modeHeight - *height) * (modeHeight - *height));

        double rateDiff;

        if (*refreshRate > 0)
            rateDiff = fabs(CGDisplayModeGetRefreshRate(mode) - *refreshRate);
        else
        {
            // If no refresh rate was specified, then they're all the same
            rateDiff = 0;
        }

        if ((sizeDiff < leastSizeDiff) ||
            (sizeDiff == leastSizeDiff && (rateDiff < leastRateDiff)))
        {
            bestMode = mode;

            leastSizeDiff = sizeDiff;
            leastRateDiff = rateDiff;
        }
    }

    if (!bestMode)
    {
        CFRelease(modes);
        return GL_FALSE;
    }

    CGDisplayCapture(CGMainDisplayID());
    CGDisplaySetDisplayMode(CGMainDisplayID(), bestMode, NULL);

    CFRelease(modes);
    return GL_TRUE;
}


//========================================================================
// Restore the previously saved (original) video mode
//========================================================================

void _glfwRestoreVideoMode(void)
{
    CGDisplaySetDisplayMode(CGMainDisplayID(),
                            _glfwLibrary.NS.desktopMode,
                            NULL);

    CGDisplayRelease(CGMainDisplayID());
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Get a list of available video modes
//========================================================================

GLFWvidmode* _glfwPlatformGetVideoModes(int* found)
{
    CFArrayRef modes;
    CFIndex count, i;
    GLFWvidmode* result;

    modes = CGDisplayCopyAllDisplayModes(CGMainDisplayID(), NULL);
    count = CFArrayGetCount(modes);

    result = (GLFWvidmode*) malloc(sizeof(GLFWvidmode) * count);
    *found = 0;

    for (i = 0;  i < count;  i++)
    {
        CGDisplayModeRef mode;

        mode = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);
        if (modeIsGood(mode))
        {
            result[*found] = vidmodeFromCGDisplayMode(mode);
            (*found)++;
        }
    }

    CFRelease(modes);
    return result;
}


//========================================================================
// Get the desktop video mode
//========================================================================

void _glfwPlatformGetDesktopMode(GLFWvidmode *mode)
{
    *mode = vidmodeFromCGDisplayMode(_glfwLibrary.NS.desktopMode);
}

"#)


;;;
;;;; Platform OpenGL
;;;


(c-declare cocoa #"

//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Initialize OpenGL support
//========================================================================

int _glfwInitOpenGL(void)
{
    return GL_TRUE;
}


//========================================================================
// Terminate OpenGL support
//========================================================================

void _glfwTerminateOpenGL(void)
{
}


//========================================================================
// Make the OpenGL context associated with the specified window current
//========================================================================

void _glfwPlatformMakeContextCurrent(_GLFWwindow* window)
{
    if (window)
        [window->NSGL.context makeCurrentContext];
    else
        [NSOpenGLContext clearCurrentContext];

    currentWindow = window;
}


//========================================================================
// Return the window object whose context is current
//========================================================================

_GLFWwindow* _glfwPlatformGetCurrentContext(void)
{
    return currentWindow;
}


//========================================================================
// Swap buffers
//========================================================================

void _glfwPlatformSwapBuffers(_GLFWwindow* window)
{
    // ARP appears to be unnecessary, but this is future-proof
    [window->NSGL.context flushBuffer];
}


//========================================================================
// Set double buffering swap interval
//========================================================================

void _glfwPlatformSwapInterval(int interval)
{
    _GLFWwindow* window = _glfwPlatformGetCurrentContext();

    GLint sync = interval;
    [window->NSGL.context setValues:&sync forParameter:NSOpenGLCPSwapInterval];
}


//========================================================================
// Check if an OpenGL extension is available at runtime
//========================================================================

int _glfwPlatformExtensionSupported(const char* extension)
{
    // There are no NSGL extensions
    return GL_FALSE;
}


//========================================================================
// Get the function pointer to an OpenGL function
//========================================================================

GLFWglproc _glfwPlatformGetProcAddress(const char* procname)
{
    CFStringRef symbolName = CFStringCreateWithCString(kCFAllocatorDefault,
                                                       procname,
                                                       kCFStringEncodingASCII);

    GLFWglproc symbol = CFBundleGetFunctionPointerForName(_glfwLibrary.NSGL.framework,
                                                          symbolName);

    CFRelease(symbolName);

    return symbol;
}


//========================================================================
// Copies the specified OpenGL state categories from src to dst
//========================================================================

void _glfwPlatformCopyContext(_GLFWwindow* src, _GLFWwindow* dst, unsigned long mask)
{
    [dst->NSGL.context copyAttributesFromContext:src->NSGL.context withMask:mask];
}

"#)


;;;
;;;; Platform Native
;;;


(c-declare cocoa #"

//////////////////////////////////////////////////////////////////////////
//////                        GLFW native API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Returns the X11 handle of the specified window
//========================================================================

GLFWAPI id platformGetWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return 0;
    }

    return window->NS.object;
}


//========================================================================
// Return the GLX context of the specified window
//========================================================================

GLFWAPI id glfwGetNSGLContext(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    return window->NSGL.context;
}

"#)


;;;
;;;; Platform Window
;;;


(c-declare cocoa #"

#include <crt_externs.h>


//========================================================================
// Delegate for window related notifications
//========================================================================

@interface GLFWWindowDelegate : NSObject <NSDraggingDestination>
{
    _GLFWwindow* window;
}

- (id)initWithGlfwWindow:(_GLFWwindow *)initWndow;

@end

@implementation GLFWWindowDelegate

- (id)initWithGlfwWindow:(_GLFWwindow *)initWindow
{
    self = [super init];
    if (self != nil)
        window = initWindow;

    return self;
}

- (BOOL)windowShouldClose:(id)sender
{
    _glfwInputWindowCloseRequest(window);
    return NO;
}

- (void)windowDidResize:(NSNotification *)notification
{
    [window->NSGL.context update];

    NSRect contentRect =
        [window->NS.object contentRectForFrameRect:[window->NS.object frame]];

    _glfwInputWindowSize(window, contentRect.size.width, contentRect.size.height);
}

- (void)windowDidMove:(NSNotification *)notification
{
    [window->NSGL.context update];

    NSRect contentRect =
        [window->NS.object contentRectForFrameRect:[window->NS.object frame]];

    CGPoint mainScreenOrigin = CGDisplayBounds(CGMainDisplayID()).origin;
    double mainScreenHeight = CGDisplayBounds(CGMainDisplayID()).size.height;
    CGPoint flippedPos = CGPointMake(contentRect.origin.x - mainScreenOrigin.x,
                                      mainScreenHeight - contentRect.origin.y -
                                          mainScreenOrigin.y - window->height);

    _glfwInputWindowPos(window, flippedPos.x, flippedPos.y);
}

- (void)windowDidMiniaturize:(NSNotification *)notification
{
    _glfwInputWindowIconify(window, GL_TRUE);
}

- (void)windowDidDeminiaturize:(NSNotification *)notification
{
    _glfwInputWindowIconify(window, GL_FALSE);
}

- (void)windowDidBecomeKey:(NSNotification *)notification
{
    _glfwInputWindowFocus(window, GL_TRUE);
}

- (void)windowDidResignKey:(NSNotification *)notification
{
    _glfwInputWindowFocus(window, GL_FALSE);
}

- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender
{
    return NSDragOperationGeneric;
}

- (BOOL)performDragOperation:(id )sender
{
    NSPasteboard* pboard = [sender draggingPasteboard];
    NSArray* filenames = [pboard propertyListForType:NSFilenamesPboardType];
    drop_callback(window, retain_id(filenames));
    return YES;
}

@end


//========================================================================
// Delegate for application related notifications
//========================================================================

@interface GLFWApplicationDelegate : NSObject
@end

@implementation GLFWApplicationDelegate

/* causes the application to hang on terminate
- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
{
    _GLFWwindow* window;

    for (window = _glfwLibrary.windowListHead;  window;  window = window->next)
        _glfwInputWindowCloseRequest(window);

    return NSTerminateCancel;
}*/

- (void)applicationDidHide:(NSNotification *)notification
{
    _GLFWwindow* window;

    for (window = _glfwLibrary.windowListHead;  window;  window = window->next)
        _glfwInputWindowVisibility(window, GL_FALSE);
}

- (void)applicationDidUnhide:(NSNotification *)notification
{
    _GLFWwindow* window;

    for (window = _glfwLibrary.windowListHead;  window;  window = window->next)
    {
        if ([window->NS.object isVisible])
            _glfwInputWindowVisibility(window, GL_TRUE);
    }
}

- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
{
    file_callback(filename);
    return YES;
}


@end


//========================================================================
// Converts a Mac OS X keycode to a GLFW keycode
//========================================================================

static int convertMacKeyCode(unsigned int macKeyCode)
{
    // Keyboard symbol translation table
    // TODO: Need to find mappings for F13-F15, volume down/up/mute, and eject.
    static const unsigned int table[128] =
    {
        /* 00 */ GLFW_KEY_A,
        /* 01 */ GLFW_KEY_S,
        /* 02 */ GLFW_KEY_D,
        /* 03 */ GLFW_KEY_F,
        /* 04 */ GLFW_KEY_H,
        /* 05 */ GLFW_KEY_G,
        /* 06 */ GLFW_KEY_Z,
        /* 07 */ GLFW_KEY_X,
        /* 08 */ GLFW_KEY_C,
        /* 09 */ GLFW_KEY_V,
        /* 0a */ GLFW_KEY_GRAVE_ACCENT,
        /* 0b */ GLFW_KEY_B,
        /* 0c */ GLFW_KEY_Q,
        /* 0d */ GLFW_KEY_W,
        /* 0e */ GLFW_KEY_E,
        /* 0f */ GLFW_KEY_R,
        /* 10 */ GLFW_KEY_Y,
        /* 11 */ GLFW_KEY_T,
        /* 12 */ GLFW_KEY_1,
        /* 13 */ GLFW_KEY_2,
        /* 14 */ GLFW_KEY_3,
        /* 15 */ GLFW_KEY_4,
        /* 16 */ GLFW_KEY_6,
        /* 17 */ GLFW_KEY_5,
        /* 18 */ GLFW_KEY_EQUAL,
        /* 19 */ GLFW_KEY_9,
        /* 1a */ GLFW_KEY_7,
        /* 1b */ GLFW_KEY_MINUS,
        /* 1c */ GLFW_KEY_8,
        /* 1d */ GLFW_KEY_0,
        /* 1e */ GLFW_KEY_RIGHT_BRACKET,
        /* 1f */ GLFW_KEY_O,
        /* 20 */ GLFW_KEY_U,
        /* 21 */ GLFW_KEY_LEFT_BRACKET,
        /* 22 */ GLFW_KEY_I,
        /* 23 */ GLFW_KEY_P,
        /* 24 */ GLFW_KEY_ENTER,
        /* 25 */ GLFW_KEY_L,
        /* 26 */ GLFW_KEY_J,
        /* 27 */ GLFW_KEY_APOSTROPHE,
        /* 28 */ GLFW_KEY_K,
        /* 29 */ GLFW_KEY_SEMICOLON,
        /* 2a */ GLFW_KEY_BACKSLASH,
        /* 2b */ GLFW_KEY_COMMA,
        /* 2c */ GLFW_KEY_SLASH,
        /* 2d */ GLFW_KEY_N,
        /* 2e */ GLFW_KEY_M,
        /* 2f */ GLFW_KEY_PERIOD,
        /* 30 */ GLFW_KEY_TAB,
        /* 31 */ GLFW_KEY_SPACE,
        /* 32 */ GLFW_KEY_WORLD_1,
        /* 33 */ GLFW_KEY_BACKSPACE,
        /* 34 */ -1,
        /* 35 */ GLFW_KEY_ESCAPE,
        /* 36 */ GLFW_KEY_RIGHT_SUPER,
        /* 37 */ GLFW_KEY_LEFT_SUPER,
        /* 38 */ GLFW_KEY_LEFT_SHIFT,
        /* 39 */ GLFW_KEY_CAPS_LOCK,
        /* 3a */ GLFW_KEY_LEFT_ALT,
        /* 3b */ GLFW_KEY_LEFT_CONTROL,
        /* 3c */ GLFW_KEY_RIGHT_SHIFT,
        /* 3d */ GLFW_KEY_RIGHT_ALT,
        /* 3e */ GLFW_KEY_RIGHT_CONTROL,
        /* 3f */ -1, /* Function */
        /* 40 */ GLFW_KEY_F17,
        /* 41 */ GLFW_KEY_KP_DECIMAL,
        /* 42 */ -1,
        /* 43 */ GLFW_KEY_KP_MULTIPLY,
        /* 44 */ -1,
        /* 45 */ GLFW_KEY_KP_ADD,
        /* 46 */ -1,
        /* 47 */ GLFW_KEY_NUM_LOCK, /* Really KeypadClear... */
        /* 48 */ -1, /* VolumeUp */
        /* 49 */ -1, /* VolumeDown */
        /* 4a */ -1, /* Mute */
        /* 4b */ GLFW_KEY_KP_DIVIDE,
        /* 4c */ GLFW_KEY_KP_ENTER,
        /* 4d */ -1,
        /* 4e */ GLFW_KEY_KP_SUBTRACT,
        /* 4f */ GLFW_KEY_F18,
        /* 50 */ GLFW_KEY_F19,
        /* 51 */ GLFW_KEY_KP_EQUAL,
        /* 52 */ GLFW_KEY_KP_0,
        /* 53 */ GLFW_KEY_KP_1,
        /* 54 */ GLFW_KEY_KP_2,
        /* 55 */ GLFW_KEY_KP_3,
        /* 56 */ GLFW_KEY_KP_4,
        /* 57 */ GLFW_KEY_KP_5,
        /* 58 */ GLFW_KEY_KP_6,
        /* 59 */ GLFW_KEY_KP_7,
        /* 5a */ GLFW_KEY_F20,
        /* 5b */ GLFW_KEY_KP_8,
        /* 5c */ GLFW_KEY_KP_9,
        /* 5d */ -1,
        /* 5e */ -1,
        /* 5f */ -1,
        /* 60 */ GLFW_KEY_F5,
        /* 61 */ GLFW_KEY_F6,
        /* 62 */ GLFW_KEY_F7,
        /* 63 */ GLFW_KEY_F3,
        /* 64 */ GLFW_KEY_F8,
        /* 65 */ GLFW_KEY_F9,
        /* 66 */ -1,
        /* 67 */ GLFW_KEY_F11,
        /* 68 */ -1,
        /* 69 */ GLFW_KEY_F13,
        /* 6a */ GLFW_KEY_F16,
        /* 6b */ GLFW_KEY_F14,
        /* 6c */ -1,
        /* 6d */ GLFW_KEY_F10,
        /* 6e */ -1,
        /* 6f */ GLFW_KEY_F12,
        /* 70 */ -1,
        /* 71 */ GLFW_KEY_F15,
        /* 72 */ GLFW_KEY_INSERT, /* Really Help... */
        /* 73 */ GLFW_KEY_HOME,
        /* 74 */ GLFW_KEY_PAGE_UP,
        /* 75 */ GLFW_KEY_DELETE,
        /* 76 */ GLFW_KEY_F4,
        /* 77 */ GLFW_KEY_END,
        /* 78 */ GLFW_KEY_F2,
        /* 79 */ GLFW_KEY_PAGE_DOWN,
        /* 7a */ GLFW_KEY_F1,
        /* 7b */ GLFW_KEY_LEFT,
        /* 7c */ GLFW_KEY_RIGHT,
        /* 7d */ GLFW_KEY_DOWN,
        /* 7e */ GLFW_KEY_UP,
        /* 7f */ -1,
    };

    if (macKeyCode >= 128)
        return -1;

    return table[macKeyCode];
}


//========================================================================
// Content view class for the GLFW window
//========================================================================

@interface GLFWContentView : NSView
{
    _GLFWwindow* window;
    NSTrackingArea* trackingArea;
}

- (id)initWithGlfwWindow:(_GLFWwindow *)initWindow;

@end

@implementation GLFWContentView

- (BOOL)isFlipped
{
    return YES;
}

- (id)initWithGlfwWindow:(_GLFWwindow *)initWindow
{
    self = [super init];
    if (self != nil)
    {
        window = initWindow;
        trackingArea = nil;

        [self updateTrackingAreas];
    }

    return self;
}

-(void)dealloc
{
    [trackingArea release];
    [super dealloc];
}

- (BOOL)isOpaque
{
    return YES;
}

- (BOOL)canBecomeKeyView
{
    return YES;
}

- (BOOL)acceptsFirstResponder
{
    return YES;
}

- (void)drawRect:(NSRect)dirtyRect
{
    _glfwDrawRect(window, dirtyRect);
}

- (void)mouseDown:(NSEvent *)event
{
    _glfwInputMouseClick(window, GLFW_MOUSE_BUTTON_LEFT, [event clickCount], GLFW_PRESS);
}

- (void)mouseDragged:(NSEvent *)event
{
    [self mouseMoved:event];
}

- (void)mouseUp:(NSEvent *)event
{
    _glfwInputMouseClick(window, GLFW_MOUSE_BUTTON_LEFT, [event clickCount], GLFW_RELEASE);
}

- (void)mouseMoved:(NSEvent *)event
{
    if (window->cursorMode == GLFW_CURSOR_CAPTURED)
        _glfwInputCursorMotion(window, [event deltaX], [event deltaY]);
    else
    {
        const NSPoint p = [event locationInWindow];

        // Cocoa coordinate system has origin at lower left
        const int x = lround(floor(p.x));
        const int y = window->height - lround(ceil(p.y));

        _glfwInputCursorMotion(window, x, y);
    }
}

- (void)rightMouseDown:(NSEvent *)event
{
    _glfwInputMouseClick(window, GLFW_MOUSE_BUTTON_RIGHT, [event clickCount], GLFW_PRESS);
}

- (void)rightMouseDragged:(NSEvent *)event
{
    [self mouseMoved:event];
}

- (void)rightMouseUp:(NSEvent *)event
{
    _glfwInputMouseClick(window, GLFW_MOUSE_BUTTON_RIGHT, [event clickCount], GLFW_RELEASE);
}

- (void)otherMouseDown:(NSEvent *)event
{
    _glfwInputMouseClick(window, [event buttonNumber], [event clickCount], GLFW_PRESS);
}

- (void)otherMouseDragged:(NSEvent *)event
{
    [self mouseMoved:event];
}

- (void)otherMouseUp:(NSEvent *)event
{
    _glfwInputMouseClick(window, [event buttonNumber], [event clickCount], GLFW_RELEASE);
}

- (void)mouseExited:(NSEvent *)event
{
    _glfwInputCursorEnter(window, GL_FALSE);
}

- (void)mouseEntered:(NSEvent *)event
{
    _glfwInputCursorEnter(window, GL_TRUE);
}

- (void)updateTrackingAreas
{
    if (trackingArea != nil)
    {
        [self removeTrackingArea:trackingArea];
        [trackingArea release];
    }

    NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited |
                                    NSTrackingActiveAlways |
                                    NSTrackingInVisibleRect;

    trackingArea = [[NSTrackingArea alloc] initWithRect:[self bounds]
                                                options:options
                                                  owner:self
                                               userInfo:nil];

    [self addTrackingArea:trackingArea];
	 [super updateTrackingAreas];
}

- (void)keyDown:(NSEvent *)event
{
    NSUInteger i, length;
    NSString* characters;
    int key = convertMacKeyCode([event keyCode]);

    if (key != -1)
    {
        if (!_glfwInputKey(window, key, GLFW_PRESS))
        {
            if ([event modifierFlags] & NSCommandKeyMask)
            {
                [super keyDown:event];
            }
            else
            {
                characters = [event characters];
                length = [characters length];
    
                for (i = 0;  i < length;  i++)
                    _glfwInputChar(window, [characters characterAtIndex:i]);
            }
        }
    }
}

- (void)flagsChanged:(NSEvent *)event
{
    int mode, key;
    unsigned int newModifierFlags =
        [event modifierFlags] | NSDeviceIndependentModifierFlagsMask;

    if (newModifierFlags > _glfwInputState.modifierFlags)
        mode = GLFW_PRESS;
    else
        mode = GLFW_RELEASE;

    _glfwInputState.modifierFlags = newModifierFlags;

    key = convertMacKeyCode([event keyCode]);
    if (key != -1)
      _glfwInputKey(window, key, mode);
}

- (void)keyUp:(NSEvent *)event
{
    int key = convertMacKeyCode([event keyCode]);
    if (key != -1)
        _glfwInputKey(window, key, GLFW_RELEASE);
}

- (void)scrollWheel:(NSEvent *)event
{
    double deltaX = [event deltaX];
    double deltaY = [event deltaY];

    if (fabs(deltaX) > 0.0 || fabs(deltaY) > 0.0)
        _glfwInputScroll(window, deltaX, deltaY);
}

@end


//========================================================================
// GLFW application class
//========================================================================

@interface GLFWApplication : NSApplication
@end

@implementation GLFWApplication

// From http://cocoadev.com/index.pl?GameKeyboardHandlingAlmost
// This works around an AppKit bug, where key up events while holding
// down the command key don't get sent to the key window.
- (void)sendEvent:(NSEvent *)event
{
    if ([event type] == NSKeyUp && ([event modifierFlags] & NSCommandKeyMask))
        [[self keyWindow] sendEvent:event];
    else
        [super sendEvent:event];
}

@end


//========================================================================
// Try to figure out what the calling application is called
//========================================================================

static NSString* findAppName(void)
{
    unsigned int i;
    NSDictionary* infoDictionary = [[NSBundle mainBundle] infoDictionary];

    // Keys to search for as potential application names
    NSString* GLFWNameKeys[] =
    {
        @"CFBundleDisplayName",
        @"CFBundleName",
        @"CFBundleExecutable",
    };

    for (i = 0;  i < sizeof(GLFWNameKeys) / sizeof(GLFWNameKeys[0]);  i++)
    {
        id name = [infoDictionary objectForKey:GLFWNameKeys[i]];
        if (name &&
            [name isKindOfClass:[NSString class]] &&
            ![@"" isEqualToString:name])
        {
            return name;
        }
    }

    // If we get here, the application is unbundled
    ProcessSerialNumber psn = { 0, kCurrentProcess };
    TransformProcessType(&psn, kProcessTransformToForegroundApplication);

    // Having the app in front of the terminal window is also generally
    // handy.  There is an NSApplication API to do this, but...
    SetFrontProcess(&psn);

    char** progname = _NSGetProgname();
    if (progname && *progname)
        return [NSString stringWithUTF8String:*progname];

    // Really shouldn't get here
    return @"GLFW Application";
}


//========================================================================
// Set up the menu bar (manually)
// This is nasty, nasty stuff -- calls to undocumented semi-private APIs that
// could go away at any moment, lots of stuff that really should be
// localize(d|able), etc.  Loading a nib would save us this horror, but that
// doesn't seem like a good thing to require of GLFW's clients.
//========================================================================

static void createMenuBar(void)
{
    NSString* appName = findAppName();

    NSMenu* bar = [[NSMenu alloc] init];
    [NSApp setMainMenu:bar];

    NSMenuItem* appMenuItem =
        [bar addItemWithTitle:@"" action:NULL keyEquivalent:@""];
    NSMenu* appMenu = [[NSMenu alloc] init];
    [appMenuItem setSubmenu:appMenu];

    [appMenu addItemWithTitle:[NSString stringWithFormat:@"About %@", appName]
                       action:@selector(orderFrontStandardAboutPanel:)
                keyEquivalent:@""];
    [appMenu addItem:[NSMenuItem separatorItem]];
    NSMenu* servicesMenu = [[NSMenu alloc] init];
    [NSApp setServicesMenu:servicesMenu];
    [[appMenu addItemWithTitle:@"Services"
                       action:NULL
                keyEquivalent:@""] setSubmenu:servicesMenu];
    [appMenu addItem:[NSMenuItem separatorItem]];
    [appMenu addItemWithTitle:[NSString stringWithFormat:@"Hide %@", appName]
                       action:@selector(hide:)
                keyEquivalent:@"h"];
    [[appMenu addItemWithTitle:@"Hide Others"
                       action:@selector(hideOtherApplications:)
                keyEquivalent:@"h"]
        setKeyEquivalentModifierMask:NSAlternateKeyMask | NSCommandKeyMask];
    [appMenu addItemWithTitle:@"Show All"
                       action:@selector(unhideAllApplications:)
                keyEquivalent:@""];
    [appMenu addItem:[NSMenuItem separatorItem]];
    [appMenu addItemWithTitle:[NSString stringWithFormat:@"Quit %@", appName]
                       action:@selector(terminate:)
                keyEquivalent:@"q"];

    NSMenuItem* windowMenuItem =
        [bar addItemWithTitle:@"" action:NULL keyEquivalent:@""];
    NSMenu* windowMenu = [[NSMenu alloc] initWithTitle:@"Window"];
    [NSApp setWindowsMenu:windowMenu];
    [windowMenuItem setSubmenu:windowMenu];

    [windowMenu addItemWithTitle:@"Miniaturize"
                          action:@selector(performMiniaturize:)
                   keyEquivalent:@"m"];
    [windowMenu addItemWithTitle:@"Zoom"
                          action:@selector(performZoom:)
                   keyEquivalent:@""];
    [windowMenu addItem:[NSMenuItem separatorItem]];
    [windowMenu addItemWithTitle:@"Bring All to Front"
                          action:@selector(arrangeInFront:)
                   keyEquivalent:@""];

    // Prior to Snow Leopard, we need to use this oddly-named semi-private API
    // to get the application menu working properly.
    [NSApp performSelector:@selector(setAppleMenu:) withObject:appMenu];
}


//========================================================================
// Initialize the Cocoa Application Kit
//========================================================================

static GLboolean initializeAppKit(void)
{
    if (NSApp)
        return GL_TRUE;

    // Implicitly create shared NSApplication instance
    [GLFWApplication sharedApplication];

    // Menu bar setup must go between sharedApplication above and
    // finishLaunching below, in order to properly emulate the behavior
    // of NSApplicationMain
    createMenuBar();

    [NSApp finishLaunching];

    return GL_TRUE;
}


//========================================================================
// Create the Cocoa window
//========================================================================

static GLboolean createWindow(_GLFWwindow* window,
                              const _GLFWwndconfig* wndconfig,
                              int kind)
{
    unsigned int styleMask = 0;

    if (wndconfig->mode == GLFW_WINDOWED)
    {
        if (kind == GLFW_DIALOG)
        {
            styleMask = NSTitledWindowMask | NSClosableWindowMask |
                        NSMiniaturizableWindowMask;

            if (wndconfig->resizable)
                styleMask |= NSResizableWindowMask;
        }
        else if (kind == GLFW_POPUP)
        {
            styleMask = NSBorderlessWindowMask;

            if (wndconfig->resizable)
                styleMask |= NSResizableWindowMask;
        }
        else
        {
            styleMask = NSTitledWindowMask | NSClosableWindowMask |
                        NSMiniaturizableWindowMask;

            if (wndconfig->resizable)
                styleMask |= NSResizableWindowMask;
        }
    }
    else
        styleMask = NSBorderlessWindowMask;

    window->NS.object = [[NSWindow alloc]
        initWithContentRect:NSMakeRect(0, 0, window->width, window->height)
                  styleMask:styleMask
                    backing:NSBackingStoreBuffered
                      defer:NO];

    if (window->NS.object == nil)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR, "Cocoa: Failed to create window");
        return GL_FALSE;
    }

    window->NS.view = [[GLFWContentView alloc] initWithGlfwWindow:window];

    [window->NS.object setTitle:[NSString stringWithUTF8String:wndconfig->title]];
    [window->NS.object setContentView:window->NS.view];
    [window->NS.object setDelegate:window->NS.delegate];
    [window->NS.object setAcceptsMouseMovedEvents:YES];
    [window->NS.object center];

    if ([window->NS.object respondsToSelector:@selector(setRestorable:)])
        [window->NS.object setRestorable:NO];

    return GL_TRUE;
}


//========================================================================
// Create the OpenGL context
//========================================================================

static GLboolean createContext(_GLFWwindow* window,
                               const _GLFWwndconfig* wndconfig,
                               const _GLFWfbconfig* fbconfig)
{
    unsigned int attributeCount = 0;

    // Mac OS X needs non-zero color size, so set resonable values
    int colorBits = fbconfig->redBits + fbconfig->greenBits + fbconfig->blueBits;
    if (colorBits == 0)
        colorBits = 24;
    else if (colorBits < 15)
        colorBits = 15;

    if (wndconfig->clientAPI == GLFW_OPENGL_ES_API)
    {
        _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                      "Cocoa/NSOpenGL: NSOpenGL does not support OpenGL ES");
        return GL_FALSE;
    }

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
    // Fail if any OpenGL version above 2.1 other than 3.2 was requested
    if (wndconfig->glMajor > 3 ||
        (wndconfig->glMajor == 3 && wndconfig->glMinor != 2))
    {
        _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                      "NSOpenGL: The targeted version of Mac OS X does not "
                      "support any OpenGL version above 2.1 except 3.2");
        return GL_FALSE;
    }

    if (wndconfig->glMajor > 2)
    {
        if (!wndconfig->glForward)
        {
            _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                          "NSOpenGL: The targeted version of Mac OS X only "
                          "supports OpenGL 3.2 contexts if they are "
                          "forward-compatible");
            return GL_FALSE;
        }

        if (wndconfig->glProfile != GLFW_OPENGL_CORE_PROFILE)
        {
            _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                          "NSOpenGL: The targeted version of Mac OS X only "
                          "supports OpenGL 3.2 contexts if they use the "
                          "core profile");
            return GL_FALSE;
        }
    }
#else
    // Fail if OpenGL 3.0 or above was requested
    if (wndconfig->glMajor > 2)
    {
        _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                      "NSOpenGL: The targeted version of Mac OS X does not "
                      "support OpenGL version 3.0 or above");
        return GL_FALSE;
    }
#endif /*MAC_OS_X_VERSION_MAX_ALLOWED*/

    // Fail if a robustness strategy was requested
    if (wndconfig->glRobustness)
    {
        _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                      "NSOpenGL: Mac OS X does not support OpenGL robustness "
                      "strategies");
        return GL_FALSE;
    }

#define ADD_ATTR(x) { attributes[attributeCount++] = x; }
#define ADD_ATTR2(x, y) { ADD_ATTR(x); ADD_ATTR(y); }

    // Arbitrary array size here
    NSOpenGLPixelFormatAttribute attributes[40];

    ADD_ATTR(NSOpenGLPFADoubleBuffer);

    if (wndconfig->mode == GLFW_FULLSCREEN)
    {
        ADD_ATTR(NSOpenGLPFANoRecovery);
        ADD_ATTR2(NSOpenGLPFAScreenMask,
                  CGDisplayIDToOpenGLDisplayMask(CGMainDisplayID()));
    }

#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1070
    if (wndconfig->glMajor > 2)
        ADD_ATTR2(NSOpenGLPFAOpenGLProfile, NSOpenGLProfileVersion3_2Core);
#endif /*MAC_OS_X_VERSION_MAX_ALLOWED*/

    ADD_ATTR2(NSOpenGLPFAColorSize, colorBits);

    if (fbconfig->alphaBits > 0)
        ADD_ATTR2(NSOpenGLPFAAlphaSize, fbconfig->alphaBits);

    if (fbconfig->depthBits > 0)
        ADD_ATTR2(NSOpenGLPFADepthSize, fbconfig->depthBits);

    if (fbconfig->stencilBits > 0)
        ADD_ATTR2(NSOpenGLPFAStencilSize, fbconfig->stencilBits);

    int accumBits = fbconfig->accumRedBits + fbconfig->accumGreenBits +
                    fbconfig->accumBlueBits + fbconfig->accumAlphaBits;

    if (accumBits > 0)
        ADD_ATTR2(NSOpenGLPFAAccumSize, accumBits);

    if (fbconfig->auxBuffers > 0)
        ADD_ATTR2(NSOpenGLPFAAuxBuffers, fbconfig->auxBuffers);

    if (fbconfig->stereo)
        ADD_ATTR(NSOpenGLPFAStereo);

    if (fbconfig->samples > 0)
    {
        ADD_ATTR2(NSOpenGLPFASampleBuffers, 1);
        ADD_ATTR2(NSOpenGLPFASamples, fbconfig->samples);
    }

    ADD_ATTR(0);

#undef ADD_ATTR
#undef ADD_ATTR2

    window->NSGL.pixelFormat =
        [[NSOpenGLPixelFormat alloc] initWithAttributes:attributes];
    if (window->NSGL.pixelFormat == nil)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR,
                      "NSOpenGL: Failed to create OpenGL pixel format");
        return GL_FALSE;
    }

    NSOpenGLContext* share = NULL;

    if (wndconfig->share)
        share = wndconfig->share->NSGL.context;

    window->NSGL.context =
        [[NSOpenGLContext alloc] initWithFormat:window->NSGL.pixelFormat
                                   shareContext:share];
    if (window->NSGL.context == nil)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR,
                      "NSOpenGL: Failed to create OpenGL context");
        return GL_FALSE;
    }

    return GL_TRUE;
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Here is where the window is created, and the OpenGL rendering context is
// created
//========================================================================

int _glfwPlatformCreateWindow(_GLFWwindow* window,
                              const _GLFWwndconfig* wndconfig,
                              const _GLFWfbconfig* fbconfig,
                              int kind,
                              bool opengl)
{
    if (!initializeAppKit())
        return GL_FALSE;

    // There can only be one application delegate, but we allocate it the
    // first time a window is created to keep all window code in this file
    if (_glfwLibrary.NS.delegate == nil)
    {
        _glfwLibrary.NS.delegate = [[GLFWApplicationDelegate alloc] init];
        if (_glfwLibrary.NS.delegate == nil)
        {
            _glfwSetError(GLFW_PLATFORM_ERROR,
                          "Cocoa: Failed to create application delegate");
            return GL_FALSE;
        }

        [NSApp setDelegate:_glfwLibrary.NS.delegate];
    }

    window->NS.delegate = [[GLFWWindowDelegate alloc] initWithGlfwWindow:window];
    if (window->NS.delegate == nil)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR,
                      "Cocoa: Failed to create window delegate");
        return GL_FALSE;
    }

    // Mac OS X needs non-zero color size, so set resonable values
    int colorBits = fbconfig->redBits + fbconfig->greenBits + fbconfig->blueBits;
    if (colorBits == 0)
        colorBits = 24;
    else if (colorBits < 15)
        colorBits = 15;

    // Don't use accumulation buffer support; it's not accelerated
    // Aux buffers probably aren't accelerated either

    if (!createWindow(window, wndconfig, kind))
        return GL_FALSE;

    if (opengl)
    {
        if (!createContext(window, wndconfig, fbconfig))
            return GL_FALSE;
    }

    [window->NSGL.context setView:[window->NS.object contentView]];

    if (wndconfig->mode == GLFW_FULLSCREEN)
    {
        int bpp = colorBits + fbconfig->alphaBits;

        if (!_glfwSetVideoMode(&window->width,
                               &window->height,
                               &bpp,
                               &window->refreshRate))
        {
            return GL_FALSE;
        }

        _glfwPlatformShowWindow(window);
        [[window->NS.object contentView] enterFullScreenMode:[NSScreen mainScreen]
                                                 withOptions:nil];
    }

    NSPoint point = [[NSCursor currentCursor] hotSpot];
    window->cursorPosX = point.x;
    window->cursorPosY = point.y;

    return GL_TRUE;
}


//========================================================================
// Properly kill the window / video display
//========================================================================

void _glfwPlatformDestroyWindow(_GLFWwindow* window)
{
    [window->NS.object orderOut:nil];

    if (window->mode == GLFW_FULLSCREEN)
    {
        [[window->NS.object contentView] exitFullScreenModeWithOptions:nil];

        _glfwRestoreVideoMode();
    }

    [window->NSGL.pixelFormat release];
    window->NSGL.pixelFormat = nil;

    [window->NSGL.context release];
    window->NSGL.context = nil;

    [window->NS.object setDelegate:nil];
    [window->NS.delegate release];
    window->NS.delegate = nil;

    [window->NS.view release];
    window->NS.view = nil;

    [window->NS.object close];
    window->NS.object = nil;

    // TODO: Probably more cleanup
}


//========================================================================
// Get the window title
//========================================================================

NSString* _glfwPlatformGetWindowTitle(_GLFWwindow* window)
{
    return [window->NS.object title];
}


//========================================================================
// Set the window title
//========================================================================

void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char *title)
{
    [window->NS.object setTitle:[NSString stringWithUTF8String:title]];
}


//========================================================================
// Set the window size
//========================================================================

void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
{
    [window->NS.object setContentSize:NSMakeSize(width, height)];
}


//========================================================================
// Set the window position
//========================================================================

void _glfwPlatformSetWindowPos(_GLFWwindow* window, int x, int y)
{
    NSRect contentRect =
        [window->NS.object contentRectForFrameRect:[window->NS.object frame]];

    // We assume here that the client code wants to position the window within the
    // screen the window currently occupies
    NSRect screenRect = [[window->NS.object screen] visibleFrame];
    contentRect.origin = NSMakePoint(screenRect.origin.x + x,
                                     screenRect.origin.y + screenRect.size.height -
                                         y - contentRect.size.height);

    [window->NS.object setFrame:[window->NS.object frameRectForContentRect:contentRect]
                        display:YES];
}


//========================================================================
// Iconify the window
//========================================================================

void _glfwPlatformIconifyWindow(_GLFWwindow* window)
{
    [window->NS.object miniaturize:nil];
}


//========================================================================
// Restore (un-iconify) the window
//========================================================================

void _glfwPlatformRestoreWindow(_GLFWwindow* window)
{
    [window->NS.object deminiaturize:nil];
}


//========================================================================
// Show window
//========================================================================

void _glfwPlatformShowWindow(_GLFWwindow* window)
{
    [window->NS.object orderFront:nil];
    _glfwInputWindowVisibility(window, GL_TRUE);
}


//========================================================================
// Hide window
//========================================================================

void _glfwPlatformHideWindow(_GLFWwindow* window)
{
    [window->NS.object orderOut:nil];
    _glfwInputWindowVisibility(window, GL_FALSE);
}

//========================================================================
// Write back window parameters into GLFW window structure
//========================================================================

void _glfwPlatformRefreshWindowParams(_GLFWwindow* window)
{
}


//========================================================================
// Check for new window and input events
//========================================================================

bool _glfwPlatformEventAvailable(void)
{
    NSEvent* event;

    event = [NSApp nextEventMatchingMask:NSAnyEventMask
                                   untilDate:[NSDate distantPast]
                                      inMode:NSDefaultRunLoopMode
                                     dequeue:NO];

     return event != NULL;
}


//========================================================================
// Poll for new window and input events
//========================================================================

void _glfwPlatformPollEvents(void)
{
    NSEvent* event;

    do
    {
        event = [NSApp nextEventMatchingMask:NSAnyEventMask
                                   untilDate:[NSDate distantPast]
                                      inMode:NSDefaultRunLoopMode
                                     dequeue:YES];

        if (event)
            [NSApp sendEvent:event];
    }
    while (event);

    [_glfwLibrary.NS.autoreleasePool drain];
    _glfwLibrary.NS.autoreleasePool = [[NSAutoreleasePool alloc] init];
}


//========================================================================
// Wait for new window and input events
//========================================================================

void _glfwPlatformWaitEvents( void )
{
    // I wanted to pass NO to dequeue:, and rely on PollEvents to
    // dequeue and send.  For reasons not at all clear to me, passing
    // NO to dequeue: causes this method never to return.
    NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask
                                        untilDate:[NSDate distantFuture]
                                           inMode:NSDefaultRunLoopMode
                                          dequeue:YES];
    [NSApp sendEvent:event];

    _glfwPlatformPollEvents();
}


//========================================================================
// Set physical cursor position
//========================================================================

void _glfwPlatformSetCursorPos(_GLFWwindow* window, int x, int y)
{
    if (window->mode == GLFW_FULLSCREEN)
    {
        CGPoint globalPoint = CGPointMake(x, y);
        CGDisplayMoveCursorToPoint(CGMainDisplayID(), globalPoint);
    }
    else
    {
        NSPoint localPoint = NSMakePoint(x, window->height - y - 1);
        NSPoint globalPoint = [window->NS.object convertBaseToScreen:localPoint];
        CGPoint mainScreenOrigin = CGDisplayBounds(CGMainDisplayID()).origin;
        double mainScreenHeight = CGDisplayBounds(CGMainDisplayID()).size.height;
        CGPoint targetPoint = CGPointMake(globalPoint.x - mainScreenOrigin.x,
                                          mainScreenHeight - globalPoint.y -
                                            mainScreenOrigin.y);
        CGDisplayMoveCursorToPoint(CGMainDisplayID(), targetPoint);
    }
}


//========================================================================
// Set physical mouse cursor mode
//========================================================================

void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
{
    switch (mode)
    {
        case GLFW_CURSOR_NORMAL:
            [NSCursor unhide];
            CGAssociateMouseAndMouseCursorPosition(true);
            break;
        case GLFW_CURSOR_HIDDEN:
            [NSCursor hide];
            break;
        case GLFW_CURSOR_CAPTURED:
            [NSCursor hide];
            CGAssociateMouseAndMouseCursorPosition(false);
            break;
    }
}

"#)


;;;
;;;; Platform Time
;;;


(c-declare cocoa #"

#include <mach/mach_time.h>


//========================================================================
// Return raw time
//========================================================================

static uint64_t getRawTime(void)
{
    return mach_absolute_time();
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Initialise timer
//========================================================================

void _glfwInitTimer(void)
{
    mach_timebase_info_data_t info;
    mach_timebase_info(&info);

    _glfwLibrary.NS.timer.resolution = (double) info.numer / (info.denom * 1.0e9);
    _glfwLibrary.NS.timer.base = getRawTime();
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW platform API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Return timer value in seconds
//========================================================================

double _glfwPlatformGetTime(void)
{
    return (double) (getRawTime() - _glfwLibrary.NS.timer.base) *
        _glfwLibrary.NS.timer.resolution;
}


//========================================================================
// Set timer value in seconds
//========================================================================

void _glfwPlatformSetTime(double time)
{
    _glfwLibrary.NS.timer.base = getRawTime() -
        (uint64_t) (time / _glfwLibrary.NS.timer.resolution);
}

"#)


;;;
;;;; GLFW Init
;;;


(c-declare cocoa #"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>


//------------------------------------------------------------------------
// Flag indicating whether GLFW has been successfully initialized
//------------------------------------------------------------------------
GLboolean _glfwInitialized = GL_FALSE;


//------------------------------------------------------------------------
// All shared and API-specific global data protected by _glfwInitialized
// This should only be touched after a call to glfwInit that has not been
// followed by a call to glfwTerminate
//------------------------------------------------------------------------
_GLFWlibrary _glfwLibrary;


//------------------------------------------------------------------------
// The current GLFW error code
// This is outside of _glfwLibrary so it can be initialized and usable
// before glfwInit is called, which lets that function report errors
// TODO: Make this thread-local
//------------------------------------------------------------------------
static int _glfwError = GLFW_NO_ERROR;


//------------------------------------------------------------------------
// The current error callback
// This is outside of _glfwLibrary so it can be initialized and usable
// before glfwInit is called, which lets that function report errors
//------------------------------------------------------------------------
static GLFWerrorfun _glfwErrorCallback = NULL;


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Sets the current error value
//========================================================================

void _glfwSetError(int error, const char* format, ...)
{
        char buffer[16384];
        const char* description;

        if (format)
        {
            int count;
            va_list vl;

            va_start(vl, format);
            count = vsnprintf(buffer, sizeof(buffer), format, vl);
            va_end(vl);

            if (count < 0)
                buffer[sizeof(buffer) - 1] = '\0';

            description = buffer;
        }
        else
            description = glfwErrorString(error);

        call_error((char *) description);
}


//////////////////////////////////////////////////////////////////////////
//////                        GLFW public API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Initialize various GLFW state
//========================================================================

GLFWAPI int glfwInit(void)
{
    if (_glfwInitialized)
        return GL_TRUE;

    memset(&_glfwLibrary, 0, sizeof(_glfwLibrary));

    if (!_glfwPlatformInit())
    {
        _glfwPlatformTerminate();
        return GL_FALSE;
    }

    _glfwInitialized = GL_TRUE;

    // Not all window hints have zero as their default value
    glfwDefaultWindowHints();

    return GL_TRUE;
}


//========================================================================
// Close window and shut down library
//========================================================================

GLFWAPI void glfwTerminate(void)
{
    if (!_glfwInitialized)
        return;

    // Close all remaining windows
    while (_glfwLibrary.windowListHead)
        glfwDestroyWindow(_glfwLibrary.windowListHead);

    if (!_glfwPlatformTerminate())
        return;

    if (_glfwLibrary.modes)
        free(_glfwLibrary.modes);

    _glfwInitialized = GL_FALSE;
}


//========================================================================
// Get GLFW version
// This function may be called without GLFW having been initialized
//========================================================================

GLFWAPI void glfwGetVersion(int* major, int* minor, int* rev)
{
    if (major != NULL)
        *major = GLFW_VERSION_MAJOR;

    if (minor != NULL)
        *minor = GLFW_VERSION_MINOR;

    if (rev != NULL)
        *rev = GLFW_VERSION_REVISION;
}


//========================================================================
// Returns the current error value
// This function may be called without GLFW having been initialized
//========================================================================

GLFWAPI int glfwGetError(void)
{
    int error = _glfwError;
    _glfwError = GLFW_NO_ERROR;
    return error;
}


//========================================================================
// Returns a string representation of the specified error value
// This function may be called without GLFW having been initialized
//========================================================================

GLFWAPI const char* glfwErrorString(int error)
{
    switch (error)
    {
        case GLFW_NO_ERROR:
            return "No error";
        case GLFW_NOT_INITIALIZED:
            return "The GLFW library is not initialized";
        case GLFW_NO_CURRENT_CONTEXT:
            return "There is no current OpenGL context";
        case GLFW_INVALID_ENUM:
            return "Invalid argument for enum parameter";
        case GLFW_INVALID_VALUE:
            return "Invalid value for parameter";
        case GLFW_OUT_OF_MEMORY:
            return "Out of memory";
        case GLFW_OPENGL_UNAVAILABLE:
            return "OpenGL is not available on this machine";
        case GLFW_VERSION_UNAVAILABLE:
            return "The requested OpenGL version is unavailable";
        case GLFW_PLATFORM_ERROR:
            return "A platform-specific error occurred";
        case GLFW_WINDOW_NOT_ACTIVE:
            return "The specified window is not active";
        case GLFW_FORMAT_UNAVAILABLE:
            return "The requested format is unavailable";
    }

    return "ERROR: UNKNOWN ERROR TOKEN PASSED TO glfwErrorString";
}


//========================================================================
// Sets the callback function for GLFW errors
// This function may be called without GLFW having been initialized
//========================================================================

GLFWAPI void glfwSetErrorCallback(GLFWerrorfun cbfun)
{
    _glfwErrorCallback = cbfun;
}

"#)


;;;
;;;; GLFW Time
;;;


(c-declare cocoa #"

//========================================================================
// Return timer value in seconds
//========================================================================

GLFWAPI double glfwGetTime(void)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return 0.0;
    }

    return _glfwPlatformGetTime();
}


//========================================================================
// Set timer value in seconds
//========================================================================

GLFWAPI void glfwSetTime(double time)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    _glfwPlatformSetTime(time);
}



"#)


;;;
;;;; GLFW OpenGL
;;;


(c-declare cocoa #"

#include <stdio.h>
#include <string.h>
#include <limits.h>


//========================================================================
// Parses the client API version string and extracts the version number
//========================================================================

static GLboolean parseGLVersion(int* api, int* major, int* minor, int* rev)
{
    int i, _api = GLFW_OPENGL_API, _major, _minor = 0, _rev = 0;
    const char* version;
    const char* prefixes[] =
    {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        NULL
    };

    version = (const char*) glGetString(GL_VERSION);
    if (!version)
    {
        _glfwSetError(GLFW_PLATFORM_ERROR, "Failed to retrieve version string");
        return GL_FALSE;
    }

    for (i = 0;  prefixes[i];  i++)
    {
        const size_t length = strlen(prefixes[i]);

        if (strncmp(version, prefixes[i], length) == 0)
        {
            version += length;
            _api = GLFW_OPENGL_ES_API;
            break;
        }
    }

    if (!sscanf(version, "%d.%d.%d", &_major, &_minor, &_rev))
    {
        _glfwSetError(GLFW_PLATFORM_ERROR, "No version found in version string");
        return GL_FALSE;
    }

    *api = _api;
    *major = _major;
    *minor = _minor;
    *rev = _rev;

    return GL_TRUE;
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Return the available framebuffer config closest to the desired values
// This is based on the manual GLX Visual selection from 2.6
//========================================================================

const _GLFWfbconfig* _glfwChooseFBConfig(const _GLFWfbconfig* desired,
                                         const _GLFWfbconfig* alternatives,
                                         unsigned int count)
{
    unsigned int i;
    unsigned int missing, leastMissing = UINT_MAX;
    unsigned int colorDiff, leastColorDiff = UINT_MAX;
    unsigned int extraDiff, leastExtraDiff = UINT_MAX;
    const _GLFWfbconfig* current;
    const _GLFWfbconfig* closest = NULL;

    for (i = 0;  i < count;  i++)
    {
        current = alternatives + i;

        if (desired->stereo > 0 && current->stereo == 0)
        {
            // Stereo is a hard constraint
            continue;
        }

        // Count number of missing buffers
        {
            missing = 0;

            if (desired->alphaBits > 0 && current->alphaBits == 0)
                missing++;

            if (desired->depthBits > 0 && current->depthBits == 0)
                missing++;

            if (desired->stencilBits > 0 && current->stencilBits == 0)
                missing++;

            if (desired->auxBuffers > 0 && current->auxBuffers < desired->auxBuffers)
                missing += desired->auxBuffers - current->auxBuffers;

            if (desired->samples > 0 && current->samples == 0)
            {
                // Technically, several multisampling buffers could be
                // involved, but that's a lower level implementation detail and
                // not important to us here, so we count them as one
                missing++;
            }
        }

        // These polynomials make many small channel size differences matter
        // less than one large channel size difference

        // Calculate color channel size difference value
        {
            colorDiff = 0;

            if (desired->redBits > 0)
            {
                colorDiff += (desired->redBits - current->redBits) *
                             (desired->redBits - current->redBits);
            }

            if (desired->greenBits > 0)
            {
                colorDiff += (desired->greenBits - current->greenBits) *
                             (desired->greenBits - current->greenBits);
            }

            if (desired->blueBits > 0)
            {
                colorDiff += (desired->blueBits - current->blueBits) *
                             (desired->blueBits - current->blueBits);
            }
        }

        // Calculate non-color channel size difference value
        {
            extraDiff = 0;

            if (desired->alphaBits > 0)
            {
                extraDiff += (desired->alphaBits - current->alphaBits) *
                             (desired->alphaBits - current->alphaBits);
            }

            if (desired->depthBits > 0)
            {
                extraDiff += (desired->depthBits - current->depthBits) *
                             (desired->depthBits - current->depthBits);
            }

            if (desired->stencilBits > 0)
            {
                extraDiff += (desired->stencilBits - current->stencilBits) *
                             (desired->stencilBits - current->stencilBits);
            }

            if (desired->accumRedBits > 0)
            {
                extraDiff += (desired->accumRedBits - current->accumRedBits) *
                             (desired->accumRedBits - current->accumRedBits);
            }

            if (desired->accumGreenBits > 0)
            {
                extraDiff += (desired->accumGreenBits - current->accumGreenBits) *
                             (desired->accumGreenBits - current->accumGreenBits);
            }

            if (desired->accumBlueBits > 0)
            {
                extraDiff += (desired->accumBlueBits - current->accumBlueBits) *
                             (desired->accumBlueBits - current->accumBlueBits);
            }

            if (desired->accumAlphaBits > 0)
            {
                extraDiff += (desired->accumAlphaBits - current->accumAlphaBits) *
                             (desired->accumAlphaBits - current->accumAlphaBits);
            }

            if (desired->samples > 0)
            {
                extraDiff += (desired->samples - current->samples) *
                             (desired->samples - current->samples);
            }
        }

        // Figure out if the current one is better than the best one found so far
        // Least number of missing buffers is the most important heuristic,
        // then color buffer size match and lastly size match for other buffers

        if (missing < leastMissing)
            closest = current;
        else if (missing == leastMissing)
        {
            if ((colorDiff < leastColorDiff) ||
                (colorDiff == leastColorDiff && extraDiff < leastExtraDiff))
            {
                closest = current;
            }
        }

        if (current == closest)
        {
            leastMissing = missing;
            leastColorDiff = colorDiff;
            leastExtraDiff = extraDiff;
        }
    }

    return closest;
}


//========================================================================
// Checks whether the OpenGL part of the window config is sane
// It blames glfwCreateWindow because that's the only caller
//========================================================================

GLboolean _glfwIsValidContextConfig(_GLFWwndconfig* wndconfig)
{
    if (wndconfig->clientAPI != GLFW_OPENGL_API &&
        wndconfig->clientAPI != GLFW_OPENGL_ES_API)
    {
        _glfwSetError(GLFW_INVALID_ENUM,
                      "glfwCreateWindow: Invalid client API requested");
        return GL_FALSE;
    }

    if (wndconfig->clientAPI == GLFW_OPENGL_API)
    {
        if (wndconfig->glMajor < 1 || wndconfig->glMinor < 0)
        {
            // OpenGL 1.0 is the smallest valid version
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL version requested");
            return GL_FALSE;
        }
        if (wndconfig->glMajor == 1 && wndconfig->glMinor > 5)
        {
            // OpenGL 1.x series ended with version 1.5
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL version requested");
            return GL_FALSE;
        }
        else if (wndconfig->glMajor == 2 && wndconfig->glMinor > 1)
        {
            // OpenGL 2.x series ended with version 2.1
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL version requested");
            return GL_FALSE;
        }
        else if (wndconfig->glMajor == 3 && wndconfig->glMinor > 3)
        {
            // OpenGL 3.x series ended with version 3.3
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL version requested");
            return GL_FALSE;
        }
        else
        {
            // For now, let everything else through
        }

        if (wndconfig->glProfile)
        {
            if (wndconfig->glProfile != GLFW_OPENGL_CORE_PROFILE &&
                wndconfig->glProfile != GLFW_OPENGL_COMPAT_PROFILE)
            {
                _glfwSetError(GLFW_INVALID_ENUM,
                              "glfwCreateWindow: Invalid OpenGL profile requested");
                return GL_FALSE;
            }

            if (wndconfig->glMajor < 3 ||
                (wndconfig->glMajor == 3 && wndconfig->glMinor < 2))
            {
                // Desktop OpenGL context profiles are only defined for version 3.2
                // and above

                _glfwSetError(GLFW_INVALID_VALUE,
                              "glfwCreateWindow: Context profiles only exist for "
                              "OpenGL version 3.2 and above");
                return GL_FALSE;
            }
        }

        if (wndconfig->glForward && wndconfig->glMajor < 3)
        {
            // Forward-compatible contexts are only defined for OpenGL version 3.0 and above
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Forward compatibility only exist "
                          "for OpenGL version 3.0 and above");
            return GL_FALSE;
        }
    }
    else if (wndconfig->clientAPI == GLFW_OPENGL_ES_API)
    {
        if (wndconfig->glMajor < 1 || wndconfig->glMinor < 0)
        {
            // OpenGL ES 1.0 is the smallest valid version
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL ES version requested");
            return GL_FALSE;
        }
        if (wndconfig->glMajor == 1 && wndconfig->glMinor > 1)
        {
            // OpenGL ES 1.x series ended with version 1.1
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL ES version requested");
            return GL_FALSE;
        }
        else
        {
            // For now, let everything else through
        }

        if (wndconfig->glProfile)
        {
            // OpenGL ES does not support profiles
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Context profiles are not supported "
                          "by OpenGL ES");
            return GL_FALSE;
        }

        if (wndconfig->glForward)
        {
            // OpenGL ES does not support forward-compatibility
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Forward compatibility is not "
                          "supported by OpenGL ES");
            return GL_FALSE;
        }
    }

    if (wndconfig->glRobustness)
    {
        if (wndconfig->glRobustness != GLFW_OPENGL_NO_RESET_NOTIFICATION &&
            wndconfig->glRobustness != GLFW_OPENGL_LOSE_CONTEXT_ON_RESET)
        {
            _glfwSetError(GLFW_INVALID_VALUE,
                          "glfwCreateWindow: Invalid OpenGL robustness mode "
                          "requested");
            return GL_FALSE;
        }
    }

    return GL_TRUE;
}


//========================================================================
// Reads back context properties
// It blames glfwCreateWindow because that's the only caller
//========================================================================

GLboolean _glfwRefreshContextParams(void)
{
    _GLFWwindow* window = _glfwPlatformGetCurrentContext();

    if (!parseGLVersion(&window->clientAPI,
                        &window->glMajor,
                        &window->glMinor,
                        &window->glRevision))
    {
        return GL_FALSE;
    }

    /* CONVERT
    if (window->glMajor > 2)
    {
        // OpenGL 3.0+ uses a different function for extension string retrieval
        // We cache it here instead of in glfwExtensionSupported mostly to alert
        // users as early as possible that their build may be broken

        window->GetStringi = (PFNGLGETSTRINGIPROC) glfwGetProcAddress("glGetStringi");
        if (!window->GetStringi)
        {
            _glfwSetError(GLFW_PLATFORM_ERROR,
                          "glfwCreateWindow: Entry point retrieval is broken");
            return GL_FALSE;
        }
    }
    */

    // Read back forward-compatibility flag
    {
      window->glForward = GL_FALSE;

      if (window->clientAPI == GLFW_OPENGL_API && window->glMajor >= 3)
      {
          GLint flags;
          glGetIntegerv(GL_CONTEXT_FLAGS, &flags);

          if (flags & GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT)
              window->glForward = GL_TRUE;
          if (flags & 0)
              window->glDebug = GL_TRUE;
      }
    }

    // Read back OpenGL context profile
    {
      window->glProfile = 0;

      if (window->glMajor > 3 || (window->glMajor == 3 && window->glMinor >= 2))
      {
          GLint mask;
          glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &mask);

          if (mask & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT)
              window->glProfile = GLFW_OPENGL_COMPAT_PROFILE;
          else if (mask & GL_CONTEXT_CORE_PROFILE_BIT)
              window->glProfile = GLFW_OPENGL_CORE_PROFILE;
      }
    }

    return GL_TRUE;
}


//========================================================================
// Checks whether the current context fulfils the specified requirements
// It blames glfwCreateWindow because that's the only caller
//========================================================================

GLboolean _glfwIsValidContext(_GLFWwndconfig* wndconfig)
{
    _GLFWwindow* window = _glfwPlatformGetCurrentContext();

    if (window->glMajor < wndconfig->glMajor ||
        (window->glMajor == wndconfig->glMajor &&
         window->glMinor < wndconfig->glMinor))
    {
        // The desired OpenGL version is greater than the actual version
        // This only happens if the machine lacks {GLX|WGL}_ARB_create_context
        // /and/ the user has requested an OpenGL version greater than 1.0

        // For API consistency, we emulate the behavior of the
        // {GLX|WGL}_ARB_create_context extension and fail here

        _glfwSetError(GLFW_VERSION_UNAVAILABLE,
                      "glfwCreateWindow: The requested OpenGL version is not available");
        return GL_FALSE;
    }

    return GL_TRUE;
}


//========================================================================
// Check if a string can be found in an OpenGL extension string
//========================================================================

int _glfwStringInExtensionString(const char* string,
                                 const GLubyte* extensions)
{
    const GLubyte* start;
    GLubyte* where;
    GLubyte* terminator;

    // It takes a bit of care to be fool-proof about parsing the
    // OpenGL extensions string. Don't be fooled by sub-strings,
    // etc.
    start = extensions;
    for (;;)
    {
        where = (GLubyte*) strstr((const char*) start, string);
        if (!where)
            return GL_FALSE;

        terminator = where + strlen(string);
        if (where == start || *(where - 1) == ' ')
        {
            if (*terminator == ' ' || *terminator == '\0')
                break;
        }

        start = terminator;
    }

    return GL_TRUE;
}


//////////////////////////////////////////////////////////////////////////
//////                        GLFW public API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Make the OpenGL context associated with the specified window current
//========================================================================

GLFWAPI void glfwMakeContextCurrent(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (_glfwPlatformGetCurrentContext() == window)
        return;

    _glfwPlatformMakeContextCurrent(window);
}


//========================================================================
// Return the window object whose context is current
//========================================================================

GLFWAPI GLFWwindow glfwGetCurrentContext(void)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    return _glfwPlatformGetCurrentContext();
}


//========================================================================
// Swap buffers (double-buffering)
//========================================================================

GLFWAPI void glfwSwapBuffers(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    _glfwPlatformSwapBuffers(window);
}


//========================================================================
// Set double buffering swap interval (0 = vsync off)
//========================================================================

GLFWAPI void glfwSwapInterval(int interval)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (!_glfwPlatformGetCurrentContext())
    {
        _glfwSetError(GLFW_NO_CURRENT_CONTEXT, NULL);
        return;
    }

    _glfwPlatformSwapInterval(interval);
}


//========================================================================
// Check if an OpenGL extension is available at runtime
//========================================================================

GLFWAPI int glfwExtensionSupported(const char* extension)
{
    const GLubyte* extensions;
    _GLFWwindow* window;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return GL_FALSE;
    }

    window = _glfwPlatformGetCurrentContext();
    if (!window)
    {
        _glfwSetError(GLFW_NO_CURRENT_CONTEXT, NULL);
        return GL_FALSE;
    }

    if (extension == NULL || *extension == '\0')
    {
        _glfwSetError(GLFW_INVALID_VALUE, NULL);
        return GL_FALSE;
    }

    if (window->glMajor < 3)
    {
        // Check if extension is in the old style OpenGL extensions string

        extensions = glGetString(GL_EXTENSIONS);
        if (extensions != NULL)
        {
            if (_glfwStringInExtensionString(extension, extensions))
                return GL_TRUE;
        }
    }
    else
    {
        int i;
        GLint count;

        // Check if extension is in the modern OpenGL extensions string list

        glGetIntegerv(GL_NUM_EXTENSIONS, &count);

        /* CONVERT
        for (i = 0;  i < count;  i++)
        {
             if (strcmp((const char*) window->GetStringi(GL_EXTENSIONS, i),
                         extension) == 0)
             {
                 return GL_TRUE;
             }
        }
        */
    }

    // Check if extension is in the platform-specific string
    return _glfwPlatformExtensionSupported(extension);
}


//========================================================================
// Get the function pointer to an OpenGL function.
// This function can be used to get access to extended OpenGL functions.
//========================================================================

GLFWAPI GLFWglproc glfwGetProcAddress(const char* procname)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    if (!_glfwPlatformGetCurrentContext())
    {
        _glfwSetError(GLFW_NO_CURRENT_CONTEXT, NULL);
        return NULL;
    }

    return _glfwPlatformGetProcAddress(procname);
}


//========================================================================
// Copies the specified OpenGL state categories from src to dst
//========================================================================

GLFWAPI void glfwCopyContext(GLFWwindow hsrc, GLFWwindow hdst, unsigned long mask)
{
    _GLFWwindow* src;
    _GLFWwindow* dst;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    src = (_GLFWwindow*) hsrc;
    dst = (_GLFWwindow*) hdst;

    if (_glfwPlatformGetCurrentContext() == dst)
    {
        _glfwSetError(GLFW_INVALID_VALUE,
                      "glfwCopyContext: Cannot copy OpenGL state to a current context");
        return;
    }

    _glfwPlatformCopyContext(src, dst, mask);
}

"#)


;;;
;;;; GLFW Clipboard
;;;


(c-declare cocoa #"

//========================================================================
// Set the clipboard contents
//========================================================================

GLFWAPI void glfwSetClipboardString(GLFWwindow handle, const char* string)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    _glfwPlatformSetClipboardString(window, string);
}


//========================================================================
// Return the current clipboard contents
//========================================================================

GLFWAPI const char* glfwGetClipboardString(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    return _glfwPlatformGetClipboardString(window);
}

"#)


;;;
;;;; GLFW Fullscreen
;;;


(c-declare cocoa #"

//========================================================================
// Lexical comparison function for GLFW video modes, used by qsort
//========================================================================

static int compareVideoModes(const void* firstPtr, const void* secondPtr)
{
    int firstBPP, secondBPP, firstSize, secondSize;
    GLFWvidmode* first = (GLFWvidmode*) firstPtr;
    GLFWvidmode* second = (GLFWvidmode*) secondPtr;

    // First sort on color bits per pixel

    firstBPP = first->redBits +
               first->greenBits +
               first->blueBits;
    secondBPP = second->redBits +
                second->greenBits +
                second->blueBits;

    if (firstBPP != secondBPP)
        return firstBPP - secondBPP;

    // Then sort on screen area, in pixels

    firstSize = first->width * first->height;
    secondSize = second->width * second->height;

    return firstSize - secondSize;
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Lexical comparison of GLFW video modes
//========================================================================

int _glfwCompareVideoModes(const GLFWvidmode* first, const GLFWvidmode* second)
{
    return compareVideoModes(first, second);
}


//========================================================================
// Convert BPP to RGB bits based on "best guess"
//========================================================================

void _glfwSplitBPP(int bpp, int* red, int* green, int* blue)
{
    int delta;

    // We assume that by 32 the user really meant 24
    if (bpp == 32)
        bpp = 24;

    // Convert "bits per pixel" to red, green & blue sizes

    *red = *green = *blue = bpp / 3;
    delta = bpp - (*red * 3);
    if (delta >= 1)
        *green = *green + 1;

    if (delta == 2)
        *red = *red + 1;
}


//////////////////////////////////////////////////////////////////////////
//////                        GLFW public API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Get a list of available video modes
//========================================================================

GLFWAPI GLFWvidmode* glfwGetVideoModes(int* count)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    if (count == NULL)
    {
        _glfwSetError(GLFW_INVALID_VALUE, NULL);
        return NULL;
    }

    free(_glfwLibrary.modes);

    _glfwLibrary.modes = _glfwPlatformGetVideoModes(count);
    if (_glfwLibrary.modes)
        qsort(_glfwLibrary.modes, *count, sizeof(GLFWvidmode), compareVideoModes);

    return _glfwLibrary.modes;
}


//========================================================================
// Get the desktop video mode
//========================================================================

GLFWAPI void glfwGetDesktopMode(GLFWvidmode* mode)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (mode == NULL)
    {
        _glfwSetError(GLFW_INVALID_VALUE,
                      "glfwGetDesktopMode: Parameter 'mode' cannot be NULL");
        return;
    }

    _glfwPlatformGetDesktopMode(mode);
}

"#)


;;;
;;;; GLFW Input
;;;


(c-declare cocoa #"

//========================================================================
// Sets the cursor mode for the specified window
//========================================================================

static void setCursorMode(_GLFWwindow* window, int newMode)
{
    int oldMode, centerPosX, centerPosY;

    if (newMode != GLFW_CURSOR_NORMAL &&
        newMode != GLFW_CURSOR_HIDDEN &&
        newMode != GLFW_CURSOR_CAPTURED)
    {
        _glfwSetError(GLFW_INVALID_ENUM, NULL);
        return;
    }

    oldMode = window->cursorMode;
    if (oldMode == newMode)
        return;

    centerPosX = window->width / 2;
    centerPosY = window->height / 2;

    if (oldMode == GLFW_CURSOR_CAPTURED || newMode == GLFW_CURSOR_CAPTURED)
        _glfwPlatformSetCursorPos(window, centerPosX, centerPosY);

    _glfwPlatformSetCursorMode(window, newMode);
    window->cursorMode = newMode;

    if (oldMode == GLFW_CURSOR_CAPTURED)
        _glfwInputCursorMotion(window, window->cursorPosX, window->cursorPosY);
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Draw
//========================================================================

void _glfwDrawRect(_GLFWwindow* window, NSRect dirtyRect)
{
    int width, height;
    CGContextRef context;

    width = window->width;
    height = window->height;

    context = [[NSGraphicsContext currentContext] graphicsPort];
    //CGContextTranslateCTM (context, 0.0, height);
    //CGContextScaleCTM (context, 1.0, -1.0);
  
    paint_callback(window, context, &dirtyRect);
}

//========================================================================
// Register keyboard activity
//========================================================================

bool _glfwInputKey(_GLFWwindow* window, int key, int action)
{
    if (key < 0 || key > GLFW_KEY_LAST)
        return 0;

    // Are we trying to release an already released key?
    if (action == GLFW_RELEASE && _glfwInputState.key[key] != GLFW_PRESS)
        return 0;

    // Register key action
    _glfwInputState.key[key] = (char) action;
    
    return key_press_callback(window, key, action);
}


//========================================================================
// Register (keyboard) character activity
//========================================================================

void _glfwInputChar(_GLFWwindow* window, int character)
{
    // Valid Unicode (ISO 10646) character?
    if (!((character >= 32 && character <= 126) || character >= 160))
        return;

    char_callback(window, character);
}


//========================================================================
// Register scroll events
//========================================================================

void _glfwInputScroll(_GLFWwindow* window, double xoffset, double yoffset)
{
    window->scrollX += xoffset;
    window->scrollY += yoffset;

    if (window->scrollCallback)
        window->scrollCallback(window, xoffset, yoffset);
    
    wheel_callback(window, xoffset, yoffset);
}


//========================================================================
// Register mouse button clicks
//========================================================================

void _glfwInputMouseClick(_GLFWwindow* window, int button, int clickCount, int action)
{
    if (button < 0 || button > GLFW_MOUSE_BUTTON_LAST)
        return;

    // Register mouse button action
    window->mouseButton[button] = (char) action;

    // for jazz
    int x;
    int y;
    glfwGetCursorPos(window, &x, &y);
    button_callback(window, x, y, button, clickCount, action);
}


//========================================================================
// Register cursor moves
//========================================================================

void _glfwInputCursorMotion(_GLFWwindow* window, int x, int y)
{
    if (window->cursorMode == GLFW_CURSOR_CAPTURED)
    {
        if (!x && !y)
            return;

        window->cursorPosX += x;
        window->cursorPosY += y;
    }
    else
    {
        if (window->cursorPosX == x && window->cursorPosY == y)
            return;

        window->cursorPosX = x;
        window->cursorPosY = y;
    }

    move_callback(window,
                                  window->cursorPosX,
                                  window->cursorPosY);
}


//========================================================================
// Register cursor enter/leave events
//========================================================================

void _glfwInputCursorEnter(_GLFWwindow* window, int entered)
{
    if (window->cursorEnterCallback)
        window->cursorEnterCallback(window, entered);
}


//////////////////////////////////////////////////////////////////////////
//////                        GLFW public API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Returns the specified input mode of the specified window
//========================================================================

GLFWAPI int glfwGetInputMode(GLFWwindow handle, int mode)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return 0;
    }

    switch (mode)
    {
        case GLFW_CURSOR_MODE:
            return window->cursorMode;
        default:
            _glfwSetError(GLFW_INVALID_ENUM, NULL);
            return 0;
    }
}


//========================================================================
// Sets the specified input mode of the specified window
//========================================================================

GLFWAPI void glfwSetInputMode(GLFWwindow handle, int mode, int value)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    switch (mode)
    {
        case GLFW_CURSOR_MODE:
            setCursorMode(window, value);
            break;
        default:
            _glfwSetError(GLFW_INVALID_ENUM, NULL);
            break;
    }
}


//========================================================================
// Returns the state of the specified key
//========================================================================

GLFWAPI int glfwGetKey(int key)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return GLFW_RELEASE;
    }

    if (key < 0 || key > GLFW_KEY_LAST)
    {
        _glfwSetError(GLFW_INVALID_ENUM,
                      "glfwGetKey: The specified key is invalid");
        return GLFW_RELEASE;
    }

    return (int) _glfwInputState.key[key];
}


//========================================================================
// Returns the state of the specified mouse button for the specified window
//========================================================================

GLFWAPI int glfwGetMouseButton(GLFWwindow handle, int button)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return GLFW_RELEASE;
    }

    if (button < 0 || button > GLFW_MOUSE_BUTTON_LAST)
    {
        _glfwSetError(GLFW_INVALID_ENUM,
                      "glfwGetMouseButton: The specified mouse button is invalid");
        return GLFW_RELEASE;
    }

    return (int) window->mouseButton[button];
}


//========================================================================
// Returns the last reported cursor position for the specified window
//========================================================================

GLFWAPI void glfwGetCursorPos(GLFWwindow handle, int* xpos, int* ypos)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (xpos != NULL)
        *xpos = window->cursorPosX;

    if (ypos != NULL)
        *ypos = window->cursorPosY;
}


//========================================================================
// Sets the cursor position relative to the position of the client area of
// the specified window
//========================================================================

GLFWAPI void glfwSetCursorPos(GLFWwindow handle, int xpos, int ypos)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (_glfwLibrary.activeWindow != window)
    {
        _glfwSetError(GLFW_WINDOW_NOT_ACTIVE, NULL);
        return;
    }

    // Don't do anything if the cursor position did not change
    if (xpos == window->cursorPosX && ypos == window->cursorPosY)
        return;

    // Set GLFW cursor position
    window->cursorPosX = xpos;
    window->cursorPosY = ypos;

    // Do not move physical cursor in locked cursor mode
    if (window->cursorMode == GLFW_CURSOR_CAPTURED)
        return;

    // Update physical cursor position
    _glfwPlatformSetCursorPos(window, xpos, ypos);
}


//========================================================================
// Returns the scroll offset for the specified window
//========================================================================

GLFWAPI void glfwGetScrollOffset(GLFWwindow handle, double* xoffset, double* yoffset)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (xoffset)
      *xoffset = window->scrollX;

    if (yoffset)
      *yoffset = window->scrollY;
}


//========================================================================
// Set callback function for keyboard input
//========================================================================

GLFWAPI void glfwSetKeyCallback(GLFWwindow handle, GLFWkeyfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->keyCallback = cbfun;
}


//========================================================================
// Set callback function for character input
//========================================================================

GLFWAPI void glfwSetCharCallback(GLFWwindow handle, GLFWcharfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->charCallback = cbfun;
}


//========================================================================
// Set callback function for mouse clicks
//========================================================================

GLFWAPI void glfwSetMouseButtonCallback(GLFWwindow handle, GLFWmousebuttonfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->mouseButtonCallback = cbfun;
}


//========================================================================
// Set callback function for mouse moves
//========================================================================

GLFWAPI void glfwSetCursorPosCallback(GLFWwindow handle, GLFWcursorposfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->cursorPosCallback = cbfun;
}


//========================================================================
// Set callback function for cursor enter/leave events
//========================================================================

GLFWAPI void glfwSetCursorEnterCallback(GLFWwindow handle, GLFWcursorenterfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->cursorEnterCallback = cbfun;
}


//========================================================================
// Set callback function for scroll events
//========================================================================

GLFWAPI void glfwSetScrollCallback(GLFWwindow handle, GLFWscrollfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->scrollCallback = cbfun;
}

"#)


;;;
;;;; GLFW Window
;;;


(c-declare cocoa #"

//========================================================================
// Return the maxiumum of the specified values
//========================================================================

static int Max(int a, int b)
{
    return (a > b) ? a : b;
}


//========================================================================
// Clear scroll offsets for all windows
//========================================================================

static void clearScrollOffsets(void)
{
    _GLFWwindow* window;

    for (window = _glfwLibrary.windowListHead;  window;  window = window->next)
    {
        window->scrollX = 0;
        window->scrollY = 0;
    }
}


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Register window focus events
//========================================================================

void _glfwInputWindowFocus(_GLFWwindow* window, GLboolean activated)
{
    if (activated)
    {
        if (_glfwLibrary.activeWindow != window)
        {
            _glfwLibrary.activeWindow = window;

            if (window->windowFocusCallback)
                window->windowFocusCallback(window, activated);
            
            activate_callback(window);
        }
    }
    else
    {
        if (_glfwLibrary.activeWindow == window)
        {
            int i;

            // Release all pressed keyboard keys
            for (i = 0;  i <= GLFW_KEY_LAST;  i++)
            {
                if (_glfwInputState.key[i] == GLFW_PRESS)
                    _glfwInputKey(window, i, GLFW_RELEASE);
            }

            // Release all pressed mouse buttons
            for (i = 0;  i <= GLFW_MOUSE_BUTTON_LAST;  i++)
            {
                if (window->mouseButton[i] == GLFW_PRESS)
                    _glfwInputMouseClick(window, i, 1, GLFW_RELEASE);
            }

            _glfwLibrary.activeWindow = NULL;

            if (window->windowFocusCallback)
                window->windowFocusCallback(window, activated);
            
            deactivate_callback(window);
        }
    }
}


//========================================================================
// Register window position events
//========================================================================

void _glfwInputWindowPos(_GLFWwindow* window, int x, int y)
{
    window->positionX = x;
    window->positionY = y;
}


//========================================================================
// Register window size events
//========================================================================

void _glfwInputWindowSize(_GLFWwindow* window, int width, int height)
{
    if (window->width == width && window->height == height)
        return;

    window->width = width;
    window->height = height;

    if (window->windowSizeCallback)
        window->windowSizeCallback(window, width, height);
    
    reshape_callback(window, width, height);
}


//========================================================================
// Register window size events
//========================================================================

void _glfwInputWindowIconify(_GLFWwindow* window, int iconified)
{
    if (window->iconified == iconified)
        return;

    window->iconified = iconified;

    if (window->windowIconifyCallback)
        window->windowIconifyCallback(window, iconified);
}


//========================================================================
// Register window visibility events
//========================================================================

void _glfwInputWindowVisibility(_GLFWwindow* window, int visible)
{
    window->visible = visible;
}


//========================================================================
// Register window damage events
//========================================================================

void _glfwInputWindowDamage(_GLFWwindow* window)
{
    if (window->windowRefreshCallback)
        window->windowRefreshCallback(window);
}


//========================================================================
// Register window close request events
//========================================================================

void _glfwInputWindowCloseRequest(_GLFWwindow* window)
{
    close_callback(window);
}


//////////////////////////////////////////////////////////////////////////
//////                        GLFW public API                       //////
//////////////////////////////////////////////////////////////////////////

//========================================================================
// Create the GLFW window and its associated context
//========================================================================

GLFWAPI GLFWwindow glfwCreateWindow(int width, int height,
                                    int mode, int kind, const char* title,
                                    GLFWwindow share,
                                    bool opengl)
{
    _GLFWfbconfig fbconfig;
    _GLFWwndconfig wndconfig;
    _GLFWwindow* window;
    _GLFWwindow* previous;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    // We need to copy these values before doing anything that can fail, as the
    // window hints should be cleared after each call even if it fails

    // Set up desired framebuffer config
    fbconfig.redBits        = Max(_glfwLibrary.hints.redBits, 0);
    fbconfig.greenBits      = Max(_glfwLibrary.hints.greenBits, 0);
    fbconfig.blueBits       = Max(_glfwLibrary.hints.blueBits, 0);
    fbconfig.alphaBits      = Max(_glfwLibrary.hints.alphaBits, 0);
    fbconfig.depthBits      = Max(_glfwLibrary.hints.depthBits, 0);
    fbconfig.stencilBits    = Max(_glfwLibrary.hints.stencilBits, 0);
    fbconfig.accumRedBits   = Max(_glfwLibrary.hints.accumRedBits, 0);
    fbconfig.accumGreenBits = Max(_glfwLibrary.hints.accumGreenBits, 0);
    fbconfig.accumBlueBits  = Max(_glfwLibrary.hints.accumBlueBits, 0);
    fbconfig.accumAlphaBits = Max(_glfwLibrary.hints.accumAlphaBits, 0);
    fbconfig.auxBuffers     = Max(_glfwLibrary.hints.auxBuffers, 0);
    fbconfig.stereo         = _glfwLibrary.hints.stereo ? GL_TRUE : GL_FALSE;
    fbconfig.samples        = Max(_glfwLibrary.hints.samples, 0);

    // Set up desired window config
    wndconfig.mode           = mode;
    wndconfig.title          = title;
    wndconfig.refreshRate    = Max(_glfwLibrary.hints.refreshRate, 0);
    wndconfig.resizable      = _glfwLibrary.hints.resizable ? GL_TRUE : GL_FALSE;
    wndconfig.visible        = GL_FALSE;
    wndconfig.clientAPI      = _glfwLibrary.hints.clientAPI;
    wndconfig.glMajor        = _glfwLibrary.hints.glMajor;
    wndconfig.glMinor        = _glfwLibrary.hints.glMinor;
    wndconfig.glForward      = _glfwLibrary.hints.glForward ? GL_TRUE : GL_FALSE;
    wndconfig.glDebug        = _glfwLibrary.hints.glDebug ? GL_TRUE : GL_FALSE;
    wndconfig.glProfile      = _glfwLibrary.hints.glProfile;
    wndconfig.glRobustness   = _glfwLibrary.hints.glRobustness ? GL_TRUE : GL_FALSE;
    wndconfig.share          = (_GLFWwindow*) share;

    // Check the OpenGL bits of the window config
    if (opengl && !_glfwIsValidContextConfig(&wndconfig))
        return GL_FALSE;

    // Save the currently current context so it can be restored later
    if (opengl)
        previous = glfwGetCurrentContext();

    if (mode != GLFW_WINDOWED && mode != GLFW_FULLSCREEN)
    {
        _glfwSetError(GLFW_INVALID_ENUM,
                      "glfwCreateWindow: Invalid window mode");
        return GL_FALSE;
    }

    if (opengl)
    {
    // Check width & height
    if (width > 0 && height <= 0)
    {
        // Set the window aspect ratio to 4:3
        height = (width * 3) / 4;
    }
    else if (width <= 0 && height > 0)
    {
        // Set the window aspect ratio to 4:3
        width = (height * 4) / 3;
    }
    else if (width <= 0 && height <= 0)
    {
        // Default window size
        width  = 640;
        height = 480;
    }
    }

    window = (_GLFWwindow*) calloc(1, sizeof(_GLFWwindow));
    if (!window)
    {
        _glfwSetError(GLFW_OUT_OF_MEMORY, NULL);
        return NULL;
    }

    window->next = _glfwLibrary.windowListHead;
    _glfwLibrary.windowListHead = window;

    // Remember window settings
    window->width      = width;
    window->height     = height;
    window->mode       = mode;
    window->resizable  = wndconfig.resizable;
    window->cursorMode = GLFW_CURSOR_NORMAL;

    // Open the actual window and create its context
    if (!_glfwPlatformCreateWindow(window, &wndconfig, &fbconfig, kind, opengl))
    {
        glfwDestroyWindow(window);
        if (opengl)
            glfwMakeContextCurrent(previous);
        return GL_FALSE;
    }

    // Cache the actual (as opposed to requested) window parameters
    _glfwPlatformRefreshWindowParams(window);

    if (opengl)
        glfwMakeContextCurrent(window);

    // Cache the actual (as opposed to requested) context parameters
    if (opengl && !_glfwRefreshContextParams())
    {
        glfwDestroyWindow(window);
        glfwMakeContextCurrent(previous);
        return GL_FALSE;
    }

    // Verify the context against the requested parameters
    if (opengl && !_glfwIsValidContext(&wndconfig))
    {
        glfwDestroyWindow(window);
        glfwMakeContextCurrent(previous);
        return GL_FALSE;
    }

    if (opengl)
    {
    // Clearing the front buffer to black to avoid garbage pixels left over
    // from previous uses of our bit of VRAM
    glClear(GL_COLOR_BUFFER_BIT);
    _glfwPlatformSwapBuffers(window);

    // Restore the previously current context (or NULL)
    glfwMakeContextCurrent(previous);
    }

    // The GLFW specification states that fullscreen windows have the cursor
    // captured by default
    if (mode == GLFW_FULLSCREEN)
        glfwSetInputMode(window, GLFW_CURSOR_MODE, GLFW_CURSOR_CAPTURED);
    
    // Register drag & drop pasteboard types
    [window->NS.object registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType, nil]];

    if (mode == GLFW_WINDOWED && wndconfig.visible)
        glfwShowWindow(window);

    return window;
}


//========================================================================
// Reset all window hints to their default values
//========================================================================

void glfwDefaultWindowHints(void)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    memset(&_glfwLibrary.hints, 0, sizeof(_glfwLibrary.hints));

    // The default is OpenGL with minimum version 1.0
    _glfwLibrary.hints.clientAPI = GLFW_OPENGL_API;
    _glfwLibrary.hints.glMajor = 1;
    _glfwLibrary.hints.glMinor = 0;

    // The default is to show the window and allow window resizing
    _glfwLibrary.hints.resizable = GL_TRUE;
    _glfwLibrary.hints.visible   = GL_TRUE;

    // The default is 24 bits of color, 24 bits of depth and 8 bits of stencil
    _glfwLibrary.hints.redBits     = 8;
    _glfwLibrary.hints.greenBits   = 8;
    _glfwLibrary.hints.blueBits    = 8;
    _glfwLibrary.hints.depthBits   = 24;
    _glfwLibrary.hints.stencilBits = 8;
}


//========================================================================
// Set hints for creating the window
//========================================================================

GLFWAPI void glfwWindowHint(int target, int hint)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    switch (target)
    {
        case GLFW_RED_BITS:
            _glfwLibrary.hints.redBits = hint;
            break;
        case GLFW_GREEN_BITS:
            _glfwLibrary.hints.greenBits = hint;
            break;
        case GLFW_BLUE_BITS:
            _glfwLibrary.hints.blueBits = hint;
            break;
        case GLFW_ALPHA_BITS:
            _glfwLibrary.hints.alphaBits = hint;
            break;
        case GLFW_DEPTH_BITS:
            _glfwLibrary.hints.depthBits = hint;
            break;
        case GLFW_STENCIL_BITS:
            _glfwLibrary.hints.stencilBits = hint;
            break;
        case GLFW_REFRESH_RATE:
            _glfwLibrary.hints.refreshRate = hint;
            break;
        case GLFW_ACCUM_RED_BITS:
            _glfwLibrary.hints.accumRedBits = hint;
            break;
        case GLFW_ACCUM_GREEN_BITS:
            _glfwLibrary.hints.accumGreenBits = hint;
            break;
        case GLFW_ACCUM_BLUE_BITS:
            _glfwLibrary.hints.accumBlueBits = hint;
            break;
        case GLFW_ACCUM_ALPHA_BITS:
            _glfwLibrary.hints.accumAlphaBits = hint;
            break;
        case GLFW_AUX_BUFFERS:
            _glfwLibrary.hints.auxBuffers = hint;
            break;
        case GLFW_STEREO:
            _glfwLibrary.hints.stereo = hint;
            break;
        case GLFW_RESIZABLE:
            _glfwLibrary.hints.resizable = hint;
            break;
        case GLFW_VISIBLE:
            _glfwLibrary.hints.visible = hint;
            break;
        case GLFW_FSAA_SAMPLES:
            _glfwLibrary.hints.samples = hint;
            break;
        case GLFW_CLIENT_API:
            _glfwLibrary.hints.clientAPI = hint;
            break;
        case GLFW_OPENGL_VERSION_MAJOR:
            _glfwLibrary.hints.glMajor = hint;
            break;
        case GLFW_OPENGL_VERSION_MINOR:
            _glfwLibrary.hints.glMinor = hint;
            break;
        case GLFW_OPENGL_FORWARD_COMPAT:
            _glfwLibrary.hints.glForward = hint;
            break;
        case GLFW_OPENGL_DEBUG_CONTEXT:
            _glfwLibrary.hints.glDebug = hint;
            break;
        case GLFW_OPENGL_PROFILE:
            _glfwLibrary.hints.glProfile = hint;
            break;
        case GLFW_OPENGL_ROBUSTNESS:
            _glfwLibrary.hints.glRobustness = hint;
            break;
        default:
            _glfwSetError(GLFW_INVALID_ENUM, NULL);
            break;
    }
}


//========================================================================
// Properly kill the window / video display
//========================================================================

GLFWAPI void glfwDestroyWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    // Allow closing of NULL (to match the behavior of free)
    if (window == NULL)
        return;

    // The window's context must not be current on another thread when the
    // window is destroyed
    if (window == _glfwPlatformGetCurrentContext())
        _glfwPlatformMakeContextCurrent(NULL);

    // Clear the active window pointer if this is the active window
    if (window == _glfwLibrary.activeWindow)
        _glfwLibrary.activeWindow = NULL;

    _glfwPlatformDestroyWindow(window);

    // Unlink window from global linked list
    {
        _GLFWwindow** prev = &_glfwLibrary.windowListHead;

        while (*prev != window)
            prev = &((*prev)->next);

        *prev = window->next;
    }

    free(window);
}


//========================================================================
// Get the window title
//========================================================================

GLFWAPI NSString* glfwGetWindowTitle(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    return _glfwPlatformGetWindowTitle(window);
}


//========================================================================
// Set the window title
//========================================================================

GLFWAPI void glfwSetWindowTitle(GLFWwindow handle, const char* title)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    _glfwPlatformSetWindowTitle(window, title);
}


//========================================================================
// Get the window size
//========================================================================

GLFWAPI void glfwGetWindowSize(GLFWwindow handle, int* width, int* height)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (width != NULL)
        *width = window->width;

    if (height != NULL)
        *height = window->height;
}


//========================================================================
// Set the window size
//========================================================================

GLFWAPI void glfwSetWindowSize(GLFWwindow handle, int width, int height)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (window->iconified)
    {
        // TODO: Figure out if this is an error
        return;
    }

    // Don't do anything if the window size did not change
    if (width == window->width && height == window->height)
        return;

    _glfwPlatformSetWindowSize(window, width, height);

    if (window->mode == GLFW_FULLSCREEN)
    {
        // Refresh window parameters (may have changed due to changed video
        // modes)
        _glfwPlatformRefreshWindowParams(window);
    }
}


//========================================================================
// Get the window position
//========================================================================

GLFWAPI void glfwGetWindowPos(GLFWwindow handle, int* xpos, int* ypos)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (xpos != NULL)
        *xpos = window->positionX;

    if (ypos != NULL)
        *ypos = window->positionY;
}


//========================================================================
// Set the window position
//========================================================================

GLFWAPI void glfwSetWindowPos(GLFWwindow handle, int xpos, int ypos)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (window->mode == GLFW_FULLSCREEN || window->iconified)
    {
        // TODO: Figure out if this is an error
        return;
    }

    _glfwPlatformSetWindowPos(window, xpos, ypos);
}


//========================================================================
// Window iconification
//========================================================================

GLFWAPI void glfwIconifyWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (window->iconified)
        return;

    _glfwPlatformIconifyWindow(window);
}


//========================================================================
// Window un-iconification
//========================================================================

GLFWAPI void glfwRestoreWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (!window->iconified)
        return;

    _glfwPlatformRestoreWindow(window);

    if (window->mode == GLFW_FULLSCREEN)
        _glfwPlatformRefreshWindowParams(window);
}


//========================================================================
// Window show
//========================================================================

GLFWAPI void glfwShowWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (window->mode == GLFW_FULLSCREEN)
        return;

    _glfwPlatformShowWindow(window);
}


//========================================================================
// Window hide
//========================================================================

GLFWAPI void glfwHideWindow(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    if (window->mode == GLFW_FULLSCREEN)
        return;

    _glfwPlatformHideWindow(window);
}


//========================================================================
// Get window parameter
//========================================================================

GLFWAPI int glfwGetWindowParam(GLFWwindow handle, int param)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return 0;
    }

    switch (param)
    {
        case GLFW_ACTIVE:
            return window == _glfwLibrary.activeWindow;
        case GLFW_ICONIFIED:
            return window->iconified;
        case GLFW_CLOSE_REQUESTED:
            return window->closeRequested;
        case GLFW_REFRESH_RATE:
            return window->refreshRate;
        case GLFW_RESIZABLE:
            return window->resizable;
        case GLFW_VISIBLE:
            return window->visible;
        case GLFW_CLIENT_API:
            return window->clientAPI;
        case GLFW_OPENGL_VERSION_MAJOR:
            return window->glMajor;
        case GLFW_OPENGL_VERSION_MINOR:
            return window->glMinor;
        case GLFW_OPENGL_REVISION:
            return window->glRevision;
        case GLFW_OPENGL_FORWARD_COMPAT:
            return window->glForward;
        case GLFW_OPENGL_DEBUG_CONTEXT:
            return window->glDebug;
        case GLFW_OPENGL_PROFILE:
            return window->glProfile;
        case GLFW_OPENGL_ROBUSTNESS:
            return window->glRobustness;
    }

    _glfwSetError(GLFW_INVALID_ENUM, NULL);
    return 0;
}


//========================================================================
// Set the user pointer for the specified window
//========================================================================

GLFWAPI void glfwSetWindowUserPointer(GLFWwindow handle, void* pointer)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->userPointer = pointer;
}


//========================================================================
// Get the user pointer for the specified window
//========================================================================

GLFWAPI void* glfwGetWindowUserPointer(GLFWwindow handle)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return NULL;
    }

    return window->userPointer;
}


//========================================================================
// Set callback function for window size changes
//========================================================================

GLFWAPI void glfwSetWindowSizeCallback(GLFWwindow handle, GLFWwindowsizefun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->windowSizeCallback = cbfun;
}


//========================================================================
// Set callback function for window close events
//========================================================================

GLFWAPI void glfwSetWindowCloseCallback(GLFWwindow handle, GLFWwindowclosefun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->windowCloseCallback = cbfun;
}


//========================================================================
// Set callback function for window refresh events
//========================================================================

GLFWAPI void glfwSetWindowRefreshCallback(GLFWwindow handle, GLFWwindowrefreshfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->windowRefreshCallback = cbfun;
}


//========================================================================
// Set callback function for window focus events
//========================================================================

GLFWAPI void glfwSetWindowFocusCallback(GLFWwindow handle, GLFWwindowfocusfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    _glfwLibrary.windowFocusCallback = cbfun;
}


//========================================================================
// Set callback function for window iconification events
//========================================================================

GLFWAPI void glfwSetWindowIconifyCallback(GLFWwindow handle, GLFWwindowiconifyfun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;

    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    window->windowIconifyCallback = cbfun;
}


//========================================================================
// Poll for new window and input events
//========================================================================

GLFWAPI void glfwPollEvents(void)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    clearScrollOffsets();

    _glfwPlatformPollEvents();
}


//========================================================================
// Wait for new window and input events
//========================================================================

GLFWAPI void glfwWaitEvents(void)
{
    if (!_glfwInitialized)
    {
        _glfwSetError(GLFW_NOT_INITIALIZED, NULL);
        return;
    }

    clearScrollOffsets();

    _glfwPlatformWaitEvents();
}

"#)


;;;
;;;; Test
;;;


(c-declare cocoa #"

void platformInit()
{
    glfwInit();
    
    glfwWindowHint(GLFW_OPENGL_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_OPENGL_VERSION_MINOR, 2);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
}


_GLFWwindow* platformGetPrimaryScreen()
{
    return [[NSScreen screens] objectAtIndex:0];
}


_GLFWwindow* platformCreateWindow(int mode, int kind, bool opengl)
{
    return glfwCreateWindow(600, 400, mode, kind, "Test", NULL, opengl);
}


void platformMakeContextCurrent(_GLFWwindow* window)
{
	glfwMakeContextCurrent(window);
}


_GLFWwindow* platformGetWindowParent(_GLFWwindow* window)
{
    return [window->NS.object parentWindow];
}


NSString* platformGetWindowTitle(_GLFWwindow* window)
{
    return glfwGetWindowTitle(window);
}


void platformSetWindowTitle(_GLFWwindow* window, char* title)
{
    glfwSetWindowTitle(window, title);
}


void platformGetWindowPos(_GLFWwindow* window, NSPoint* pos)
{
    int x, y;
    glfwGetWindowPos(window, x, y);
    pos->x = [window->NS.object frame].origin.x;
    pos->y = [window->NS.object frame].origin.y;
}


void platformSetWindowPos(_GLFWwindow* window, NSPoint* pos)
{
    glfwSetWindowPos(window, pos->x, pos->y);
}


void platformGetContentSize(_GLFWwindow* window, NSSize* size)
{
    NSRect frame = [window->NS.object frame];
    NSRect content = [window->NS.object contentRectForFrameRect:frame];
    size->width = content.size.width;
    size->height = content.size.height;
}


void platformGetWindowSize(_GLFWwindow* window, NSSize* size)
{
    NSRect frame = [window->NS.object frame];
    size->width = frame.size.width;
    size->height = frame.size.height;
}


void platformSetWindowSize(_GLFWwindow* window, NSSize* size)
{
    glfwSetWindowSize(window, size->width, size->height);
}


void platformGetWindowFrame(_GLFWwindow* window, NSRect* rect)
{
    *rect = [window->NS.object frame];
}


void platformSetWindowFrame(_GLFWwindow* window, NSRect* rect)
{
    [window->NS.object setFrame: *rect display: YES];
}


void platformGetWindowBounds(_GLFWwindow* window, NSRect* rect)
{
    *rect = [window->NS.view rect];
}


void platformShowWindow(_GLFWwindow* window)
{
    glfwShowWindow(window);
}


void platformHideWindow(_GLFWwindow* window)
{
    glfwHideWindow(window);
}


void platformSwapBuffers(_GLFWwindow* window)
{
    glfwSwapBuffers(window);
}


void platformGetMousePosition(_GLFWwindow* window, NSPoint* pos)
{
    int x;
    int y;
    glfwGetCursorPos(window, &x, &y);
    pos->x = x;
    pos->y = y;
}


void platformSetMousePosition(_GLFWwindow* window, NSPoint* pos)
{
    glfwSetCursorPos(window, pos->x, pos->y);
}


void platformHideCursor(_GLFWwindow* window)
{
    setCursorMode(window, GLFW_CURSOR_HIDDEN);
}


void platformShowCursor(_GLFWwindow* window)
{
    setCursorMode(window, GLFW_CURSOR_NORMAL);
}


bool platformKeyDown(int key)
{
    return glfwGetKey(key) == GLFW_PRESS;
}


const char* platformGetClipboardString()
{
    return glfwGetClipboardString(NULL);
}


void platformSetClipboardString(const char* string)
{
    glfwSetClipboardString(NULL, string);
}


void platformInvalidateRect(_GLFWwindow* window, NSRect* rect)
{
    [window->NS.view setNeedsDisplayInRect:*rect];
}


// COCOA quick hack
static _GLFWwindow* currentFocus = NULL;


_GLFWwindow* platformGetFocus()
{
    return currentFocus;
}


void platformSetFocus(_GLFWwindow* window)
{
    currentFocus = window;
    [window->NS.object makeKeyAndOrderFront:nil];
}


bool platformEventAvailable(void)
{
    return _glfwPlatformEventAvailable();
}


void platformPollEvents(void)
{
    glfwPollEvents();
}


bool platformContinueLoop(_GLFWwindow* window)
{
    return glfwGetWindowParam(window, GLFW_CLOSE_REQUESTED) == GL_FALSE && glfwGetKey(GLFW_KEY_ESCAPE) != GLFW_PRESS;
}


void platformDestroyWindow(_GLFWwindow* window)
{
    glfwDestroyWindow(window);
}


void platformLog(char* msg)
{
    NSLog(@"%@", [NSString stringWithUTF8String:msg]);
}

"#)


(c-type glfwwindow (pointer (struct "_GLFWwindow")))


(c-external (platformInit) void)
(c-external (platformGetPrimaryScreen) glfwwindow)
(c-external (platformCreateWindow int int bool) glfwwindow)
(c-external (platformMakeContextCurrent glfwwindow) void)
(c-external (platformGetWindowParent glfwwindow) glfwwindow)
(c-external (platformGetWindowTitle glfwwindow) NSString*)
(c-external (platformSetWindowTitle glfwwindow char-string) void)
(c-external (platformGetWindowPos glfwwindow NSPoint*) void)
(c-external (platformSetWindowPos glfwwindow NSPoint*) void)
(c-external (platformGetContentSize glfwwindow NSSize*) void)
(c-external (platformGetWindowSize glfwwindow NSSize*) void)
(c-external (platformSetWindowSize glfwwindow NSSize*) void)
(c-external (platformGetWindowFrame glfwwindow NSRect*) void)
(c-external (platformSetWindowFrame glfwwindow NSRect*) void)
(c-external (platformGetWindowBounds glfwwindow NSRect*) void)
(c-external (platformShowWindow glfwwindow) void)
(c-external (platformHideWindow glfwwindow) void)
(c-external (platformSwapBuffers glfwwindow) void)
(c-external (platformGetMousePosition glfwwindow NSPoint*) void)
(c-external (platformSetMousePosition glfwwindow NSPoint*) void)
(c-external (platformHideCursor glfwwindow) void)
(c-external (platformShowCursor glfwwindow) void)
(c-external (platformKeyDown int) bool)
(c-external (platformGetClipboardString) char-string)
(c-external (platformSetClipboardString char-string) void)
(c-external (platformInvalidateRect glfwwindow NSRect*) void)
(c-external (platformGetFocus) glfwwindow)
(c-external (platformSetFocus glfwwindow) void)
(c-external (platformEventAvailable) bool)
(c-external (platformPollEvents) void)
(c-external (platformContinueLoop glfwwindow) bool)
(c-external (platformDestroyWindow glfwwindow) void)
(c-external (platformGetWindow glfwwindow) id)
(c-external (platformLog char-string) void)


;; quicky
(constant GLFW_WINDOWED             #x00010001)
(constant GLFW_FULLSCREEN           #x00010002)

(constant GLFW_WINDOW               #x00010011)
(constant GLFW_DIALOG               #x00010012)
(constant GLFW_POPUP                #x00010013)

(constant GLFW_RELEASE 0)
(constant GLFW_PRESS 1)

(constant GLFW_MOUSE_BUTTON_LEFT 0)
(constant GLFW_MOUSE_BUTTON_RIGHT 1)
(constant GLFW_MOUSE_BUTTON_MIDDLE 2)


;; quicky
(define translate-shortcut-hook
  #f)

(definition public (set-translate-shortcut-hook hook)
  (set! translate-shortcut-hook hook))


(definition get-window
  #f)

(definition public (set-get-window proc)
  (set! get-window proc))


(c-definition (call-error msg) (char-string) void "call_error" ""
  (error msg))

(c-definition (call-debug msg) (char-string) void "call_debug" ""
  (debug-string msg))

(c-definition (call-terminal msg) (char-string) void "call_terminal" ""
  (terminal-string msg))


(definition log-callbacks?
  #f)


(c-definition (reshape-callback handle width height) (glfwwindow int int) void "reshape_callback" ""
  (when log-callbacks?
    (system-log (list 'reshape width height)))
  (when get-window
    (let ((window (get-window handle)))
      (call-size-change~ window 'restored width height))))

(c-definition (close-callback handle) (glfwwindow) void "close_callback" ""
  (when log-callbacks?
    (system-log (list 'close)))
  (when get-window
    (let ((window (get-window handle)))
      (close-window~ window))))

(c-definition (paint-callback handle context rect) (glfwwindow CGContextRef NSRect*) void "paint_callback" ""
  (when log-callbacks?
    (system-log (list 'paint)))
  (when get-window
    (let ((window (get-window handle)))
      (paint-cocoa~ window context rect))))

(c-definition (key-press-callback handle key action) (glfwwindow int int) int "key_press_callback" ""
  (when log-callbacks?
    (system-log (list 'key key action)))
  (let ()
    (define (translate key)
      (case key
        ((256) 'Escape)
        ((257) 'Return)
        ((258) 'Tab)
        ((259 261) 'Backspace)
        (else (integer->char key))))
    
    (if (when get-window
          (let ((window (get-window handle)))
            (let ((translated (translate key)))
              (if (eq? action GLFW_PRESS)
                  (begin
                    (key-down~ window translated)
                    (translate-shortcut-hook translated))
                (key-up~ window translated)
                #f))))
        1
      0)))

(c-definition (char-callback handle c) (glfwwindow int) void "char_callback" ""
  (when log-callbacks?
    (system-log (list 'char c)))
  (when get-window
    (let ((window (get-window handle))
          (c (integer->char c)))
      (call-key-press~ window c))))

(c-definition (button-callback handle x y button click-count action) (glfwwindow int int int int int) void "button_callback" ""
  (when log-callbacks?
    (system-log (list 'button x y button action)))
  (when get-window
    (let ((window (get-window handle)))
      (ecase button
        ((GLFW_MOUSE_BUTTON_LEFT)
         (ecase action
           ((GLFW_PRESS) (if (= click-count 2) (double-click~ window x y) (mouse-down~ window x y)))
           ((GLFW_RELEASE) (mouse-up~ window x y))))
        ((GLFW_MOUSE_BUTTON_RIGHT)
         (ecase action
           ((GLFW_PRESS) (right-mouse-down~ window x y) (call-context-menu~ window x y))
           ((GLFW_RELEASE) (right-mouse-up~ window x y))))))))

(c-definition (move-callback handle x y) (glfwwindow int int) void "move_callback" ""
  @too-much
  (when log-callbacks?
    (system-log (list 'move x y)))
  (when get-window
    (let ((window (get-window handle)))
      (mouse-move~ window x y))))

(c-definition (wheel-callback handle x y) (glfwwindow double double) void "wheel_callback" ""
  (when log-callbacks?
    (system-log (list 'wheel x y)))
  (when get-window
    (let ((window (get-window handle)))
      (mouse-wheel~ window #f #f (new Point (* 10 (fxround x)) (* 10 (fxround y)))))))

(c-definition (file-callback filename) (NSString*) void "file_callback" ""
  (when log-callbacks?
    (system-log (list 'file filename)))
  (let ((appl (get-application)))
    (when appl
      (drop-file~ appl filename))))

(c-definition (drop-callback handle filenames) (glfwwindow NSArray*) void "drop_callback" ""
  (when log-callbacks?
    (system-log (list 'drop filenames)))
  (when get-window
    (let ((window (get-window handle)))
      (drop-files~ window filenames))))

(c-definition (activate-callback handle) (glfwwindow) void "activate_callback" ""
  (when log-callbacks?
    (system-log (list 'activate)))
  (when get-window
    (let ((window (get-window handle)))
      (when window
        (focus-gain~ window)
        (activate-application~ window)))))

(c-definition (deactivate-callback handle) (glfwwindow) void "deactivate_callback" ""
  (when log-callbacks?
    (system-log (list 'deactivate)))
  (when get-window
    (let ((window (get-window handle)))
      (when window
        (deactivate-application~ window)
        (focus-lose~ window)))))


;; quicky
(definition public VK_LEFT 0)
(definition public VK_RIGHT 0)
(definition public VK_DOWN 0)
(definition public VK_UP 0)
(definition public VK_RBUTTON 0)


;;;
;;;; Process
;;;


(c-external (getpid) int)


(definition (relinquish-process)
  )


(definition public (current-process-id)
  (getpid))


(definition protected (bell-internal)
  ;; todo
  )

                                                                
;;;
;;;; Input
;;;


(definition public (milliseconds-since-startup)
  0)


(definition public (milliseconds-at-last-input)
  0)


;;;
;;;; Log
;;;


(definition public (system-log msg)
  (platformLog (->string msg)))


;;;
;;;; Message
;;;


(definition public (system-message text . rest)
  (display text)
  (newline))


;;;
;;;; Temporary Path
;;;


(definition public (get-temporary-directory)
  (unimplemented))


(definition public (get-temporary-file . rest)
  (unimplemented))


@what-does-this-do?
(TransformProcessType))
