;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Library
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.platform.library.cocoa jazz


(import (jazz.io))


;;;
;;;; Relocate
;;;


(definition public (relocate-name file old-prefix new-prefix (feedback?: feedback? #t))
  (when feedback?
    (format :terminal "relocating {a}...{%}" (get-name file)))
  (receive (name dependencies) (library-name/dependencies file)
    (change-name file name old-prefix new-prefix)))


(definition protected (change-name file name old-prefix new-prefix)
  (let ((new-name (relocate-path name old-prefix new-prefix)))
    (when new-name
      (let ((port (open-process (list path: "install_name_tool" arguments: `("-id" ,new-name ,(parse file))))))
        (let ((status (process-status port)))
          (unless (= status 0)
            (error "System call install_name_tool -id failed")))))))


(definition public (relocate-dependencies file old-prefix new-prefix (feedback?: feedback? #t))
  (when feedback?
    (format :terminal "relocating {a}...{%}" (get-name file)))
  (receive (name dependencies) (library-name/dependencies file)
    (change-dependencies file dependencies old-prefix new-prefix)))


(definition protected (change-dependencies file dependencies old-prefix new-prefix)
  (for-each (lambda (dependency)
              (let ((new-dependency (relocate-path dependency old-prefix new-prefix)))
                (when new-dependency
                  (let ((port (open-process (list path: "install_name_tool" arguments: `("-change" ,dependency ,new-dependency ,(parse file))))))
                    (let ((status (process-status port)))
                      (unless (= status 0)
                        (error "System call install_name_tool -change failed")))))))
            dependencies))


(definition protected (add-rpath file rpath)
  (let ((port (open-process (list path: "install_name_tool" arguments: `("-add_rpath" ,rpath ,(parse file))))))
    (let ((status (process-status port)))
      (unless (= status 0)
        (error "System call install_name_tool -add_rpath failed")))))


(definition protected (executable-rpath dir file)
  (let ((level (length (subpath dir file))))
    (let ((up (map (lambda (n) "..") (naturals 0 level))))
      (join (cons "@executable_path" up) "/"))))


(definition public (relocate-subfile dir file kind old-prefix new-prefix (feedback?: feedback? #t))
  (when feedback?
    (format :terminal "relocating {a}...{%}" (get-name file)))
  (when (eq? kind 'executable)
    (add-rpath file (executable-rpath dir file)))
  (receive (name dependencies) (library-name/dependencies file)
    (when (eq? kind 'shared)
      (change-name file name old-prefix new-prefix))
    (change-dependencies file dependencies old-prefix new-prefix)))


(definition (relocate-path path old-prefix new-prefix)
  (and (starts-with? path old-prefix)
       (string-append new-prefix (substring path (string-length old-prefix) (string-length path)))))


;;;
;;;; Dependencies
;;;


(definition public (library-name/dependencies file)
  (define (remove-tabulation path)
    (substring path 1 (string-length path)))
  
  (define (remove-version path)
    (let ((pos (search path " (compatibility version")))
      (if pos
          (substring path 0 pos)
        path)))
  
  (let ((port (open-process (list path: "otool" arguments: `("-L" ,(parse file))))))
    (let ((status (process-status port)))
      (if (= status 0)
          (let ((lines (read-all port read-line)))
            (close-port port)
            (let ((all (map (lambda (path)
                              (remove-version (remove-tabulation path)))
                            (cdr lines))))
              (values (car all) (cdr all))))
        (error "System call otool -L failed")))))


(definition public (library-dependencies-tree rpath-dir file)
  (receive (rpath direct) (library-name/dependencies file)
    (map (lambda (info)
           (let ((prefix "@rpath/"))
             (if (starts-with? info prefix)
                 (let ((path (substring info (string-length prefix) (string-length info))))
                   (let ((file (new-file rpath-dir path)))
                     (if (exists? file)
                         (cons path (library-dependencies-tree rpath-dir file))
                       (list path "Not found"))))
               info)))
         direct)))


(definition public (present-dependencies-tree lst)
  (define (present node level)
    (if (string? node)
        (format :terminal "{_ :v}{a}{%}" (* level 2) node)
      (bind (lib . deps) node
        (format :terminal "{_ :v}{a}{%}" (* level 2) lib)
        (present-list deps (+ level 1)))))
  
  (define (present-list lst level)
    (for-each (lambda (dep)
                (present dep level))
              lst))
  
  (present-list lst 0)))
