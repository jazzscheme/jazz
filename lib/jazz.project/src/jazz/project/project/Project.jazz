;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Projects
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.project.project.Project jazz


(import (jazz.debugger)
        (jazz.designer)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.project)
        (jazz.system)
        (jazz.ui.view))


(class Project extends Project-File implements Project-Container
  
  
  (property title              initialize #f accessors generate)
  (property icon               initialize #f accessors generate)
  (property owner              initialize #f accessors generate)
  (property copyright          initialize #f accessors generate)
  (property version            initialize #f accessors generate)
  (property include-extensions initialize #f accessors generate)
  (property documentation      initialize #f accessors generate)
  (property editable?                        accessors generate)
  (property active?            initialize #t accessors generate)
  (property catalog-extensions initialize #f accessors generate)
  (property catalog-heuristics initialize #f accessors generate)
  (property description-file   initialize #f accessors generate)
  (property active-project     initialize #f accessors generate)
  (property active-traits      initialize #f accessors generate)


  (slot catalog initialize #f accessors generate)
  
  
  (property deprecated catalog? initialize #t accessors generate)
  
  
  (form
    (<install> build?: #f))
  
  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" (project-title)))))


  ;;;
  ;;;; Access
  ;;;


  (method public virtual (project-title)
    (or title (if name
                  (symbol->string name)
                "<project>")))
  
  
  (method public (get-parent-project)
    (find-ascendant Project))


  ;;;
  ;;;; Concrete
  ;;;
  
  
  (method public virtual (concrete?)
    #f)


  ;;;
  ;;;; Context
  ;;;
  
  
  (method public (project-context)
    (get-context~ (get-data~ (get-file-form))))
  
  
  (method public (contextualize-pathname pathname)
    (let ((context (project-context)))
      (if (not context)
          pathname
        (let ((subpath (subpath~ (new File (get-path~ context)) pathname)))
          (if (not subpath)
              pathname
            (let ((context-pathname (new (class-of pathname) (cons :context subpath))))
              (set-context~ context-pathname context)
              context-pathname))))))


  ;;;
  ;;;; Name
  ;;;
  
  
  (method override (catalog-name)
    (if title
        (string->symbol title)
      name))


  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method public (save-catalogs)
    (for-each-catalog save~))
  
  
  (method public (load-catalogs (include-inactives?: include-inactives? #f))
    (for-each-project load-catalog~))
  
  
  (method public (load-catalog)
    (require-catalog))
  
  
  (method public (require-catalog (report?: report? #f))
    (define (create/register-catalog)
      (let ((catalog (create-catalog)))
        (add-catalog~ (get-cataloguer~ (get-application)) catalog)
        catalog))
    
    (unless catalog
      (set! catalog (create/register-catalog)))
    (load-content~ catalog report?: report?)
    catalog)
  
  
  (method (create-catalog)
    (new Project-Catalog self (catalog-name) (catalog-output) #f #f #f #f #t))
  
  
  (method protected virtual (catalog-output-base)
    (let (iterate (project self)
                  (name (catalog-name)))
      (let ((parent (get-parent~ project)))
        (if (or (not parent)
                (is? parent Workbench))
            name
          (iterate parent (format "{a}${a}" (catalog-name~ parent) name))))))
  
  
  (method protected virtual (catalog-output)
    (new File (list 'Profile "catalogs" (format "{a}.jcat" (catalog-output-base)))))
  
  
  (method package (has-content?)
    (not-null? children))
  
  
  (method public (for-each-catalog proc)
    (for-each-project
      (lambda (project)
        (let ((catalog (require-catalog~ project report?: #t)))
          (when catalog
            (when (get-active?~ catalog)
              (proc catalog)))))))


  ;;;
  ;;;; Editable
  ;;;
  
  
  (method public virtual (get-effective-editable?)
    (if (unspecified? editable?)
        (get-effective-editable?~ (get-parent-project))
      editable?))


  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (for-each-project proc (include-self?: include-self? #t) (include-inactives?: include-inactives? #f) (stop-test: stop-test #f))
    (define (inactive? project)
      (and (not include-inactives?)
           (neq? project self)
           (is? project Project)
           (not (get-active?~ project))))
    
    (for-each-descendant
      (lambda (descendant level)
        (when (and (is? descendant Project)
                   (not (inactive? descendant)))
          (proc descendant)))
      include-self?: include-self?
      stop-test: (lambda (descendant)
                   (or (inactive? descendant)
                       (and stop-test
                            (stop-test descendant))))))
  
  
  (method public (fold-projects proc seed (include-inactives?: include-inactives? #f))
    (define (fold x f s)
      (let ((ps (if (and (is? x Project)
                         (or include-inactives?
                             (get-active?~ x)))
                    (f x s)
                  s)))
        (if (eq? ps :skip)
            #f
          (for-each (lambda (c)
                      (fold c f ps))
                    (get-children~ x))
          ps)))
    
    (fold self proc seed))


  ;;;
  ;;;; Projects
  ;;;
  
  
  (method public (find-project name (include-inactives?: include-inactives? #f) (error?: error? #t))
    (define (find project path)
      (cond ((not project)
             (when error?
               (error "Unable to find project: {s}" name)))
            ((null? path)
             project)
            ((symbol? path)
             (find-name project path))
            ((pair? path)
             (find (find project (car path)) (cdr path)))
            (else
             #f)))
    
    (define (find-name project name)
      (continuation-capture
        (lambda (return)
          (for-each-project~ project
            (lambda (project)
              (when (eq? (get-name~ project) name)
                (continuation-return return project)))
            include-self?: #f
            include-inactives?: include-inactives?
            stop-test: (lambda (descendant)
                         (is? descendant Project)))
          #f)))
    
    (find self (split-symbol name #\:)))
  
  
  (method public (require-project name)
    (or (find-project name)
        (error "Unable to find project: {a}" name)))


  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (for-each-file proc (type Project-File))
    (for-each-descendant
      (lambda (descendant level)
        (when (is? descendant type)
          (proc descendant)))))


  (method public (collect-files (type Project-File))
    (let ((fact (new List-Factory)))
      (for-each-file
        (lambda (file)
          (when (is? file type)
            (put~ fact file))))
      (get-output~ fact)))
  
  
  (method public (fold-files proc seed (type Project-File))
    (define (fold x f s)
      (let ((ps (if (is? x type)
                    (f x s)
                  s)))
        (if (eq? ps :skip)
            #f
          (for-each (lambda (c)
                      (fold c f ps))
                    (get-children~ x))
          ps)))
    
    (fold self proc seed))
  
  
  (method public (iterate-files proc (extensions: extensions #f))
    (fold-files
      (lambda (project-file seed)
        (if (and (neq? project-file self) (is? project-file Project))
            :skip
          (let ((file (get-source~ project-file)))
            (when file
              (let ((ext (get-extension~ file)))
                (when (or (not extensions) (member? ext extensions test: extension=?))
                  (proc file)))))))
      #f))
  
  
  (method public (iterate-catalog-files proc)
    (iterate-files proc extensions: (effective-catalog-extensions catalog-extensions)))


  ;;;
  ;;;; Name
  ;;;
  
  
  (method public virtual (project-name)
    )


  ;;;
  ;;;; Action
  ;;;
  
  
  (method public virtual (project-action . rest)
    (message-box "This project doesn't define a project-action method"))


  ;;;
  ;;;; Run
  ;;;
  
  
  (method public virtual (project-run . rest)
    (message-box "This project doesn't define a project-run method"))
  
  
  (method public virtual (run-arguments)
    #f)


  ;;;
  ;;;; Debug
  ;;;
  
  
  (method public virtual (project-debug . rest)
    (message-box "This project doesn't define a project-debug method"))
  
  
  (method public virtual (debug-arguments)
    #f)


  ;;;
  ;;;; Test
  ;;;


  (method public virtual (project-test . rest)
    (message-box "This project doesn't define a project-test method"))


  ;;;
  ;;;; Validate
  ;;;
  
  
  (method public virtual (project-validate . rest)
    (message-box "This project doesn't define a project-validate method"))


  ;;;
  ;;;; Build
  ;;;


  (method public virtual (project-build)
    (message-box "This project doesn't define a project-build method"))


  ;;;
  ;;;; Clean
  ;;;


  (method public virtual (project-clean)
    (message-box "This project doesn't define a project-clean method"))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor)
    (new Project-Descriptor)))


;;;
;;;; Design
;;;


(submodule design


(import (jazz.designer)
        (jazz.ui))


(class Project-Descriptor extends Project-File-Descriptor
  
  
  (form
    (<install>                                          image: {Image-Resource "Project"}
      (<properties~>
        (<Property-Descriptor> name: title
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: icon
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: owner
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: copyright
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: version
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: include-extensions
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: documentation
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: editable?
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: active?
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: catalog-extensions
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: catalog-heuristics
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: description-file
          (<Value-Domain>      name: domain))
        (<Property-Descriptor> name: catalog?
          (<Boolean-Domain>    name: domain)))))
  
  
  (method override (component-presentation-property? component property)
    (memq? (field-name property) '(title)))
  
  
  (method override (component-get-presentation component)
    (let ((title (project-title~ component))
          (traits (get-default-traits~ component)))
      (if (not traits)
          title
        (format "{a}{a}" title (present-process-traits traits)))))
  
  
  (method override (component-set-presentation component designer presentation)
    (set-property~ designer component title: presentation))
  
  
  (method override (component-get-component-image component)
    (let ((description-file (get-description-file~ component)))
      (cond ((not description-file) (nextmethod component))
            ((filename=? (get-name~ description-file) ".repository") {Image-Resource "CompareManager"})
            ((filename=? (get-name~ description-file) ".package") {Image-Resource "Catalog"})
            (else (nextmethod component)))))
  
  
  (method override (component-addable-class? component class)
    (or (subtype? class Project-File)
        (subtype? class Project-Group)))
  
  
  (method override (component-get-categorized-addable-classes component)
    (list
      (list
        (reference Project-Group))
      ;#f
      ;Jazz-File
      ;C-File
      ))
    
  
  (method override (component-property-domain component property)
    (case (field-name property)
      ((title) (new Localized-Domain))
      ((include-extensions catalog-extensions catalog-heuristics) (new Value-Domain))
      ((documentation) (new File-Domain))
      ((active?) (new Boolean-Domain))
      (else (nextmethod component property)))))))
