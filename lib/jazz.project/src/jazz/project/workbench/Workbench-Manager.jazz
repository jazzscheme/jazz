;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.project.workbench.Workbench-Manager jazz


(import (jazz.catalog)
        (jazz.designer)
        (jazz.designer.menu)
        (jazz.editor.jazz)
        (jazz.graphic)
        (jazz.groupware)
        (jazz.ide)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.template)
        (jazz.platform)
        (jazz.project)
        (jazz.runtime)
        (jazz.system)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view))


(class Workbench-Manager extends Component-Editor implements Exit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" resource: {Image-Resource "Synchronize"} portfolio: :images action-handler: {Event-Handler :guest on-highlight-document}))
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           style: tool)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Project" width: 291 highlight-color: {Color Dark-Blue})))))
  
  
  (method meta override (external-name . rest)
    'workbench-manager)

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta override (host-icon)
    {Image-Resource "Workbench"})
  
  
  (method meta override (host-title)
    "Workbench")
  
  
  (method override (install-in-host host)
    (define (setup-active-project)
      (let* ((pref (get-preferences 'workbench))
             (project (get-active-project~ pref))
             (workbench (get-workbench)))
        (when (and project workbench)
          (activate-project (find-project~ workbench project)))))
    
    (setup-active-project))
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method override (get-tools-view)
    (locate 'tools))
  
  
  (method override (focus-default)
    (let ((tree (get-tree)))
      (acquire-focus~ tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (get-tree)
    (locate '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  (method override (new-controller)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (install rest)
    (nextmethod rest)
    (set-shown?~ (locate-component '(descendants header)) #f)
    (set-editor~ (locate 'descendants) self)
    (set-client (get-workbench))
    (add-exit-listener~ (get-application) self))
  
  
  (method override (get-designer-class)
    Workbench-Designer)
  
  
  (method override (prepare-exit)
    (when (and designer (file? (get-origin~ (get-form~ designer))))
      (save-designer~ designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method override (on-designer evt)
    (nextmethod evt)
    (case (get-kind~ evt)
      ((:child-add) (child-add (get-property~ evt child:) (get-property~ evt parent:)))
      ((:child-remove) (child-remove (get-property~ evt child:)))))
  
  
  (method (child-add child parent)
    (when (is? child Project)
      (project-add~ designer child)))
  
  
  (method (child-remove child)
    (when (is? child Project)
      (project-remove~ designer child)))

  
  ;;;
  ;;;; Events
  ;;;
    
  
  (method override (key-press key)
    (case key
      ((#\return) (launch-selection))))
  
  
  (method (on-highlight-document evt)
    (highlight-document))
  
  
  (method (on-add-project evt)
    (add-project))
  
  
  (method (on-add-document evt)
    (add-document))
  
  
  (method (on-add-group evt)
    (add-group))
  
  
  (method (on-install-project evt)
    (let* ((current-directory? (get-shift?~ evt))
           (parent (selected-object))
           (file (with-import-directory current-directory? parent
                   (lambda (directory)
                     (choose-file extensions: '(("Project Files" . "project")) directory: directory)))))
      (install-project file parent #f)))
  
  
  (method (on-import-files evt)
    (import-files (get-shift?~ evt)))
  
  
  (method (on-import-directory evt)
    (import-directory (get-shift?~ evt)))
  
  
  (method (on-synchronize-content evt)
    (synchronize-content))
  
  
  (method (on-set-current-directory evt)
    (let ((group (selected-object)))
      (let ((dir (get-directory~ group)))
        (set-current-directory dir)
        (user-message "Current directory set to {a}" (parse~ dir)))))
  
  
  (method (on-update-catalog evt)
    (update-catalog))
  
  
  (method (on-edit-source evt)
    (edit-selection))
  
  
  (method (on-activate evt)
    (activate-selection))
  
  
  (method (on-run evt)
    (run-selection))
  
  
  (method (on-debug evt)
    (debug-selection))
  
  
  (method (on-launch evt)
    (launch-selection))
  
  
  (method (on-distribute evt)
    (distribute-selection))
  
  
  (method (on-properties evt)
    (show-properties))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-controller~ guest))
               (moniker (get-moniker~ controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (project-file (find-source~ workbench moniker)))
              (if (not project-file)
                  (bell)
                (acquire-focus~ (get-tree))
                (highlight-document-component project-file))))))))
  
  
  (method (highlight-document-component component)
    (let* ((tree (get-tree))
           (row (component-row~ tree component)))
      (if (not row)
          (bell)
        (ensure-expanded~ tree row)
        (set-single-selection~ tree (row->line~ tree row)))))

  
  ;;;
  ;;;; Select
  ;;;
  
  
  (method public (select-current)
    (select-project))
  
  
  (method (select-project)
    (let ((project (get-modal Project-Selector)))
      (when project
        (activate-project project))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current)
    (edit-project (current-project)))
  
  
  (method (edit-selection)
    (let ((objects (selected-objects)))
      (for-each (lambda (object)
                  (typecase object
                    ((Workbench) (edit-workbench))
                    ((Project) (edit-project object))))
                objects)))
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method (edit-workbench)
    (let ((appl (get-application))
          (file Workbench-File))
      (edit-document~ appl file)))
  
  
  (method (edit-project project)
    (define (project-file)
      (let ((form (get-form~ project)))
        (and (is? project Project)
             (get-tag-reference~ form))))
    
    (let ((file (project-file)))
      (if (not file)
          (bell)
        (edit-document~ (get-application) file))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (method protected (add-project)
    (add-project-to (or (selected-object) (get-workbench))))
  
  
  (method protected (add-project-to parent)
    (let ((tree (get-tree)))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (receive (kind template project directory) (get-modal New-Project-Dialog)
          (let* ((project-parts (map ->string (split-identifier (string->symbol project))))
                 (package project)
                 (product (last project-parts))
                 (product-title (capitalize product))
                 (project-name (capitalize product))
                 (project-title project-name)
                 (project-templates (new-directory~ (templates-directory~ (get-application)) "project"))
                 (template (new-directory~ project-templates template))
                 (destination directory)
                 (associations (list (cons 'project project)
                                     (cons 'project-name project-name)
                                     (cons 'project-title project-title)
                                     (cons 'package package)
                                     (cons 'product product)
                                     (cons 'product-title product-title)
                                     (cons 'product-unit package)
                                     (cons 'product-directories project-parts))))
            (copy-template template destination associations)
            (with-update-locked~ tree
              (lambda ()
                (let ((project-file (new-file~ destination (list project ".project"))))
                  (let ((project-component (install-project project-file parent #f)))
                    (let ((src-directory (new-directory~ destination (list project "src"))))
                      (let ((src-content (if (exists?~ src-directory) (get-content~ src-directory nodes?: #t leaves?: #f) '())))
                        (when (not-null? src-content)
                          (let ((src-component (import-pathname project-component src-directory project-component #t recursive?: #f)))
                            (for-each (lambda (dir)
                                        (import-pathname project-component dir src-component #t))
                                      src-content)))))
                    (save~ (get-project-designer~ designer project-component))
                    (update-project-catalog project-component)
                    (acquire-focus~ tree)
                    (process-refresh~ designer project-component 'descendants)
                    (select-component~ tree project-component)
                    (let ((projects (collect-projects project-component)))
                      (when (not-null? projects)
                        (activate-project (car projects))))
                    (user-message "Project {a} created" project))))))))))
  
  
  (method protected (add-document)
    (let ((parent (or (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (or (default-import-directory parent must-exist?: #f) {Directory Profile} @not-sure-this-is-best (get-current-directory))))
          (when (or (exists?~ default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list~ default-directory)) type: 'question) 'yes))
            (create-directories~ default-directory)
            (receive (kind template directory name) (get-modal New-Document-Dialog directory: default-directory)
              (let* ((extension (extract-extension template))
                     (file-templates (new-directory~ (templates-directory~ (get-application)) "file"))
                     (template (new-file~ file-templates (concatenate template ".template")))
                     (destination (new-file~ directory (format "{a}.{a}" name extension)))
                     (unit (find-pathname-unit (parse~ destination)))
                     (associations (list (cons 'name name) (cons 'unit unit))))
                (copy-template template destination associations)
                (let ((component (import-pathname (ascendant-project parent) destination parent #f)))
                  (select-component~ (get-tree) component)))))))))
  
  
  (method protected (add-group)
    (let ((parent (or (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (add-component-class~ (get-tree) Project-Group parent: parent))))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method (install-project file parent descendant?)
    (let ((workbench (get-workbench))
          (parent-project (ascendant-project parent)))
      (let ((project (instantiate-file file workbench: workbench parent: parent)))
        (if (is-not? project Project)
            (error "The file \"{a}\" does not contain a project" (get-name~ file))
          (let ((form (get-form~ project)))
            (add-child~ designer project parent tag-reference: file)
            (reorder-component~ (get-tree) project)
            (load-catalogs~ project)
            (user-message "{s} installed" (get-presentation-property~ project))
            project)))))
    
  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  
  (definition (import-filter? project file)
    (let ((ext (get-extension~ file))
          (extensions (effective-include-extensions (get-include-extensions~ project))))
      (if extensions
          (or (member? ext extensions test: ci=?)
              ;; special case for those annoying extensionless files
              (member? (get-name~ file) '("README" "INSTALL")))
        (known-extension-frame-class~ (get-application) ext))))
  
  
  (method (import-directory current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (directory (with-import-directory current-directory? parent
                        (lambda (directory)
                          (choose-directory directory: directory))))
           (count (count-files~ directory filter: (lambda (file) (import-filter? project file)) max-count: MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) type: 'question) 'yes))
        (when (validate-pathnames project (list directory))
          (let ((component (import-pathname project directory parent #f)))
            (process-refresh~ designer component 'descendants))
          (user-message "{a} imported"
                        (parse~ directory))))))
  
  
  (method (import-files current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (files (with-import-directory current-directory? parent
                    (lambda (directory)
                      (choose-file multiple-selection?: #t directory: directory)))))
      (import-pathnames project files parent)))
  
  
  (method protected (import-pathnames project pathnames parent)
    (when (validate-pathnames project pathnames)
      (for-each (lambda (pathname)
                  (let ((component (import-pathname project pathname parent #f)))
                    (process-refresh~ designer component 'descendants)))
                (sort nu<? pathnames key: get-name~))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (capitalize (format-cardinality count))
                      (format-plural count)))))
  
  (method (import-pathname project pathname parent descendant? (recursive?: recursive? #t))
    (typecase pathname
      ((Directory)
       (let ((project-file (new-file~ pathname ".project")))
         (if (exists?~ project-file)
             (install-project project-file parent #t)
           (let ((subgroup (new Project-Directory directory: pathname)))
             (add-child~ designer subgroup parent design-events?: (not descendant?) descendant?: descendant?)
             (set-property~ designer subgroup 'directory pathname design-events?: (not descendant?))
             (when recursive?
               (iterate-directory~ pathname
                 (lambda (pathname)
                   (import-pathname project pathname subgroup #t))
                 files?: #f
                 directories?: #t
                 sort?: #t
                 recursive?: #f)
               (iterate-directory~ pathname
                 (lambda (pathname)
                   (import-pathname project pathname subgroup #t))
                 files?: #t
                 directories?: #f
                 sort?: #t
                 recursive?: #f))
             subgroup))))
      ((File)
       (when (or (not descendant?) (import-filter? project pathname))
         (if (string-ci=? (get-extension~ pathname) "project")
             (install-project pathname parent descendant?)
           (import-file pathname parent descendant?))))))
  
  
  (method (import-file file parent descendant?)
    (let ((reference (extension-reference (get-extension~ file))))
      (match reference
        ((module-public ?module-name ?class-name)
         (let ((file (contextualize-file~ (ascendant-project parent) file)))
           (let ((name (if (eq? ?class-name 'Jazz-File) (string->symbol (get-base~ file)) #f))
                 (model (resolve-runtime-reference (deserialize-runtime-reference reference)))
                 (import (if (eq? ?module-name 'jazz.ide) #f ?module-name)))
             (let ((project-file (new model name: name source: file))
                   (workbench (get-workbench)))
               (add-child~ designer project-file parent import: import design-events?: (not descendant?) descendant?: descendant?)
               (set-property~ designer project-file 'source file design-events?: (not descendant?))
               (when (eq? ?class-name 'Jazz-File)
                 (set-name~ designer project-file name design-events?: (not descendant?))
                 (add-entry~ workbench name project-file))
               project-file)))))))
  
  
  (definition (default-import-directory object (must-exist?: must-exist? #t))
    (define (default object)
      (typecase object
        ((Project)
         #f)
        ((Project-Directory)
         (get-directory~ object))
        (else
         #f)))
    
    (let ((dir (default object)))
      (when dir
        (anchorize~ dir))))
  
  
  (method (with-import-directory current-directory? object proc)
    (let ((default-directory (and (not current-directory?) (default-import-directory object))))
      (if (and default-directory (exists?~ default-directory))
          (with-preserved-current-directory
            (lambda ()
              (proc default-directory)))
        (proc #f))))
  
  
  (definition (extension-reference ext)
    (cond ((member? ext '("jazz") test: ci=?)    '(module-public jazz.editor.jazz Jazz-File))
    @wait ((member? ext '("java") test: ci=?)    '(module-public jazz.editor.java Java-File))
          ((member? ext '("c" "cpp") test: ci=?) '(module-public jazz.editor.c C-File))
          ((member? ext '("bmp") test: ci=?)     '(module-public jazz.project Bitmap-File))
          ((member? ext '("cur") test: ci=?)     '(module-public jazz.project Cursor-File))
          ((member? ext '("ico") test: ci=?)     '(module-public jazz.project Icon-File))
          ((member? ext '("wav") test: ci=?)     '(module-public jazz.project Sound-File))
          (else                                  '(module-public jazz.project Project-File))))
  
  
  (method protected (ascendant-project component)
    (if (is? component Project)
        component
      (ascendant-project (get-parent~ component))))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content)
    @wait-complete
    (let* ((object (selected-object))
           (project (ascendant-project object))
           (directory (default-import-directory object must-exist?: #f)))
      (if (not (exists?~ directory))
          (error "Directory {s} not found" directory)
        (let ((fact (new List-Factory)))
          (define (component-name component)
            (->string (get-name~ component)))
          
          (define (pathname-name pathname)
            (get-name~ pathname))
          
          (define (fold component pathname path)
            (let ((children (get-children~ component))
                  (content (get-content~ pathname)))
              (merge-ordered (lambda (what key left right)
                               (let ((path (cons key path)))
                                 (case what
                                   ((:left) (put~ fact (list what path)))
                                   ((:right) (put~ fact (list what path)))
                                   ((:same)
                                    (when (directory? right)
                                      (fold left right path))))))
                             (sort ci<? children key: component-name)
                             (sort ci<? content key: pathname-name)
                             left-key: component-name
                             right-key: pathname-name
                             case-insensitive?: #t)))
          
          (fold object directory '())
          (let ((out-of-synch (get-output~ fact)))
            (if (null? out-of-synch)
                (message-box "Content is already synchronized")
              (let* ((border (new Synchronize-Border size: {Dimension 500 200}))
                     (tree (locate~ border 'tree))
                     (add
                       (lambda (what path)
                         (let ((c0 (new Tree-Node title: (join path "/") image: {Image-Resource "OpenedFolder"})))
                           (add-row~ tree children: (list c0 #f #f #f))))))
                (for-each (lambda (info)
                            (bind (what path) info
                              (add what (reverse path))))
                          out-of-synch)
                (message-box "The following elements are out of synch. Synchronize?" class: Synchronize-Box type: 'confirmation content: border))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames project pathnames)
    @convert-to-checking-conflicts-with-an-understanding-of-the-unit-hierarchy
    (validate
      (lambda (report)
        (let ((workbench (get-workbench)))
          (define (iterate pathname)
            (typecase pathname
              ((Directory)
               (iterate-directory~ pathname iterate
                 files?: #t
                 directories?: #t
                 sort?: #t
                 recursive?: #f))
              ((File)
               (when (import-filter? project pathname)
                 (let ((model (extension-model (get-extension~ pathname))))
                   (when (eq? model Jazz-File)
                     (let* ((name (string->symbol (get-base~ pathname)))
                            (jazz-file (get-entry~ workbench name)))
                       (when jazz-file
                         (report jazz-file)))))))))
          
          (for-each iterate pathnames)))))
  
  
  (method (validate iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (lambda (jazz-file)
          (put~ already-defined jazz-file)))
      (let ((already-defined (get-output~ already-defined)))
        (if (null? already-defined)
            #t
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following categor{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-y/ies count)
                                 (format-is/are count)))
                 (text
                  `(,header
                    ()
                    ,@(map (lambda (jazz-file)
                             (let ((project (get-project~ jazz-file))
                                   (action
                                    (lambda ()
                                      (close-modal-dialog
                                        (lambda ()
                                          (highlight-document-component jazz-file))))))
                               (list :bulleted
                                     (list :link action
                                           (format "{a} defined in {a}"
                                                   (get-name~ jazz-file)
                                                   (get-presentation-property~ project))))))
                           (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                    ,@(when too-many?
                        (list (list :bulleted "..."))))))
            (message-box text)
            #f)))))
  
  
  ;;;
  ;;;; Active
  ;;;
  
  
  (method package (set-project-active? project flag)
    (set-property~ designer project 'active? flag use-owner?: #f)
    (let ((tree (get-tree)))
      (let ((row (component-row~ tree project)))
        (when row
          (let ((node (first-child~ row)))
            (set-image~ node (component-image~ tree project))
            (let ((line (row->line~ tree row)))
              (when line
                (invalidate-cell~ tree (new Cell line 0)))))))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection)
    (activate-object (selected-object)))
  
  
  (method (activate-object object)
    (define (find-concrete-descendant)
      (continuation-capture
        (lambda (return)
          (for-each-descendant~ object
            (lambda (descendant level)
              (when (and (is? descendant Project)
                         (concrete?~ descendant))
                (continuation-return return descendant)))
            include-self?: #f)
          #f)))
    
    (if (is? object Project)
        (if (concrete?~ object)
            (activate-project object)
          (let ((concrete-descendant (find-concrete-descendant)))
            (if concrete-descendant
                (activate-project concrete-descendant)
              (bell))))
      (bell)))
  
  
  (method (activate-project project)
    (unless (eq? project (get-active-project))
      (let ((tree (get-tree)))
        (when (get-active-project)
          (unhighlight-component~ tree (get-active-project)))
        (set-active-project project)
        (when (get-active-project)
          (let ((row (user-data-row~ tree (get-active-project) visible?: #f)))
            (when row
              (ensure-expanded~ tree row)))
          (highlight-component~ tree (get-active-project))))
      (let ((appl (get-application)))
        (update-project-actions~ appl))))
  
  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (define (update object)
      (typecase object
        ((Project)
         (update-project-catalog object))
        ((Project-Group)
         (for-each update (get-children~ object)))))
    
    (with-cursor :wait
      (lambda ()
        (let ((objects (selected-objects)))
          (for-each update objects)))))
  
  
  (method (update-project-catalog project)
    (let ((catalog (require-catalog~ project)))
      (post-catalog
        (lambda ()
          (load-content~ catalog report?: #f)
          (update~ catalog)))))
    
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method public (test-current)
    (let ((project (current-project)))
      (project-test~ project)))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method public (run-current)
    (let ((project (current-project)))
      (run-project project)))


  (method public (run-selection)
    )

  
  (method (run-project project)
    (run-project~ (get-application) project))

  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method public (debug-current (executable: executable #f))
    (debug-project (current-project) executable: executable))
  
  
  (method public (debug-selection)
    (let ((project (current-project)))
      (debug-project project)))
      
  
  (method (debug-project project (executable: executable #f))
    (debug-project~ (get-application) project executable: executable debugger-interactive?: #t))

  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-selection)
    (let ((appl (get-application))
          (tree (get-tree)))
      (for-each (lambda (component)
                  (typecase component
                    ((Project)
                     (debug-project component))
                    ((Project-File)
                     (let* ((file (get-effective-source~ component))
                            (ext (get-extension~ file)))
                       (edit-document~ appl file)))))
                (selected-components~ tree))))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current evt)
    (let ((project (current-project)))
      (if (not project)
          (bell)
        (build-project project))))
  
  
  (method public (build-current)
    (let ((project (current-project)))
      (build-project project)))
  
  
  (method (build-project project)
    (project-build~ project))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let ((moniker (get-moniker~ (get-controller~ guest))))
          (compile-moniker moniker)))))
  
  
  (method public (compile-moniker moniker)
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file moniker project-file))))
  
  
  (method (compile-file moniker project-file)
    (let ((name (find-pathname-unit (parse~ moniker))))
      (if (not name)
          (bell)
        (let ((kernel (project-kernel~ (get-project~ project-file))))
          (launch-executable kernel arguments: (list "-compile" (->string name)) show-console?: #t)))))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current)
    (define (preprocess-file moniker file)
      (let ((proc
              (lambda (thread)
                (let ((project (get-project~ file)))
                  (prepare-maps~ project)
                  (prepare-directories~ project)
                  (user-message "Preprocessing {a}..." moniker)
                  (let ((output (get-output-log))
                        (timer (new Timer)))
                    (clear-results~ output)
                    (select-results~ output)
                    (select-docked Output-Log)
                    (preprocess~ file project #f #f output force?: #t)
                    (user-message "Preprocessing done in {a}" (cpu-duration~ timer)))))))
        (proc #f)))
    
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let* ((moniker (get-moniker~ (get-controller~ guest)))
               (workbench (get-workbench))
               (file (find-source~ workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current)
    (let ((project (current-project)))
      (clean-project project)))
  
  
  (method (clean-project project)
    (if (concrete?~ project)
        ;; to complete
        #f
      (bell)))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current evt)
    (let ((project (selected-project)))
      (if (not project)
          (bell)
        (distribute-project project))))
  
  
  (method public (distribute-current)
    (let ((project (current-project)))
      (distribute-project project)))
  
  
  (method (distribute-selection)
    (distribute-project (selected-project)))
  
  
  (method (distribute-project project)
    (let* ((mode         'backup)
           (left         (project-distribution~ project))
           (right        (project-distribution-directory~ project))
           (content      (project-distribution-list~ project))
           (ignored-dirs (list ".git" ".hg" "bin" "build" "bootstrap" "gambit"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories left-moniker: left right-moniker: right left-content: content ignored-nodes: ignored-dirs ignored-leaves: files ignored-extensions: extensions host-visible?: #f)))
      (with-cursor :wait
        (lambda ()
          (compare-trees~ (get-guest~ frame))
          (focus-host~ frame)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object)
    (let ((tree (get-tree)))
      (selected-component~ tree)))
  
  
  (method (selected-objects)
    (let ((tree (get-tree)))
      (selected-components~ tree)))
  
  
  (method (selected-project)
    (let ((object (selected-object)))
      (when (is? object Project)
        object)))
  
  
  (method (selected-concrete-project)
    (let ((object (selected-object)))
      (when (and (is? object Project)
                 (concrete?~ object))
        object)))
  
  
  (method (current-project)
    (if (not (get-active-project))
        (error "No active project")
      (get-active-project)))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu)
    (let ((tree (get-tree)))
      (define (new-group-menu object)
        (let ((menu (new Group-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-workbench-menu object)
        (let ((menu (new Workbench-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (has-content?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-concrete-project-menu object)
        (let ((menu (new Concrete-Project-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (has-content?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-project-menu object)
        (let ((menu (new Project-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (has-content?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-element-menu object)
        (let ((menu (new Element-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          menu))
      
      (define (update-group/project-menu menu)
        (define (hide-item name)
          (let ((item (locate-component~ menu name)))
            (when item
              (set-visible?~ item #f))))
        
        (when (> (length (get-selection~ tree)) 1)
          (hide-item 'add-project)
          (hide-item 'add-document)
          (hide-item 'install-project)
          (hide-item 'import-files)
          (hide-item 'import-directory)))
      
      (let ((object (selected-object)))
        (typecase object
          ((Workbench) (new-workbench-menu object))
          ((Project-Group) (new-group-menu object))
          ((Project)
           (if (concrete?~ object)
               (new-concrete-project-menu object)
             (new-project-menu object)))
          (else
           (when object
             (new-element-menu object)))))))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-project = {s}" (get-active-project))
      (format :console "{%}project-designers =")
      (let* ((pairs (sort < (get-project-designers~ designer) key: (lambda (pair) (category-identifier (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (project . designer) pair
                      (format :console "{%}  {a} {a}" (category-identifier (class-of project)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}projects-table =")
      (let* ((pairs (sort < (table-keys/values (get-projects-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . project) pair
                      (format :console "{%}  {a} {a}" name project)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}categories-table =")
      (let* ((pairs (sort < (table-keys/values (get-categories-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . category) pair
                      (format :console "{%}  {a} {a}" name category)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}resources-table =")
      (let* ((pairs (sort < (table-keys/values (get-resources-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . resource) pair
                      (format :console "{%}  {a} {a}" name resource)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Controller
;;;


(class Workbench-Manager-Controller extends Component-Editor-Controller
  
  
  (method override (document-status)
    "Workbench"))


;;;
;;;; Synchronize-Border
;;;


(class Synchronize-Border extends Border-View
  
  
  (form
    (<install>                                     border-type: solid border-color: {Color Outline-Border}
      (<Scroller-View>                             style: tool hscroll?: #t vscroll?: #t
        (<!>                         name: content layout-type: fill
          (<Tree-Header>                           style: tool
            (<!>                     name: content
              (<Synchronize-Tree>    name: tree))))))))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-project           title: "New Project..." before: add-item action-handler: {Action workbench-manager add-project})
      (<Label-Item>     name: add-document          title: "New Document..." before: add-item icon: {Image-Resource "Add"} action-handler: {Action workbench-manager add-document})
      (<Label-Item>     name: install-project       title: "Install Project..." before: cut icon: {Image-Resource "Import"} action-handler: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files          title: "Import Files..." before: cut action-handler: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory      title: "Import Directory..." before: cut action-handler: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content   title: "Synchronize Content..." before: cut action-handler: {Action workbench-manager synchronize-content})
      (<Separator-Item>                             before: cut)
      (<Label-Item>     name: update-catalog        title: "Update Catalog" before: cut icon: {Image-Resource "Catalog"} action-handler: {Action workbench-manager update-catalog})
      (<Separator-Item>                             before: cut)
      (<Label-Item>     name: set-current-directory title: "Set as Current Directory" before: cut action-handler: {Action workbench-manager set-current-directory})
      (<Separator-Item>                             before: cut)
      (<!>              name: delete-selection      title: "Remove"))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit-source         title: "Edit" before: add-item icon: {Image-Resource "Edit"} action-handler: {Action workbench-manager edit-source})
      (<Separator-Item>                           before: add-item)
      (<Label-Item>     name: add-project         title: "New Project..." before: add-item action-handler: {Action workbench-manager add-project})
      (<Label-Item>     name: add-document        title: "New Document..." before: add-item icon: {Image-Resource "Add"} action-handler: {Action workbench-manager add-document})
      (<Label-Item>     name: install-project     title: "Install Project..." before: cut icon: {Image-Resource "Import"} action-handler: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action-handler: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action-handler: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action-handler: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut)
      (<Label-Item>     name: update-catalog      title: "Update Catalog" before: cut icon: {Image-Resource "Catalog"} action-handler: {Action workbench-manager update-catalog})
      (<Separator-Item>                           before: cut)
      (<!>              name: delete-selection    title: "Remove"))))


;;;
;;;; Concrete-Project-Menu
;;;


(class Concrete-Project-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "Select as Active Project" before: cut default?: #t action-handler: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Workbench-Menu
;;;


(class Workbench-Menu extends Project-Menu
  
  
  (form
    (<install>
      @wait-complete
      (<!>              name: synchronize-content visible?: #f))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit-source      title: "Edit" before: cut default?: #t icon: {Image-Resource "Edit"} action-handler: {Action workbench-manager launch})
      (<Separator-Item>                        before: cut)
      (<!>              name: delete-selection title: "Remove")))))
