;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.project.workbench.Workbench-Manager jazz


(import (jazz.action)
        (jazz.application)
        (jazz.catalog)
        (jazz.component)
        (jazz.debugger.jazz)
        (jazz.descriptor)
        (jazz.designer)
        (jazz.designer.ui)
        (jazz.designer.ui.menu)
        (jazz.doc)
        (jazz.document)
        (jazz.editor.jazz)
        (jazz.event)
        (jazz.feedback)
        (jazz.git.ui)
        (jazz.graphic)
        (jazz.groupware)
        (jazz.handler)
        (jazz.ide)
        (jazz.io)
        (jazz.markup)
        (jazz.menu)
        (jazz.outline)
        (jazz.preferences)
        (jazz.process)
        (jazz.project)
        (jazz.resource)
        (jazz.search)
        (jazz.template)
        (jazz.text)
        (jazz.time)
        (jazz.tree)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.workspace))


(class Workbench-Manager extends Component-Editor implements Quit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" resource: {Image-Resource "Synchronize"} portfolio: :images action-handler: {Event-Handler :guest on-highlight-document})
        (<Push-Tool>      name: reload             size: {Dimension 22 22} tooltip?: #t tooltip-text: "Reload Workbench" resource: {Image-Resource "Refresh"} portfolio: :images action-handler: {Event-Handler :guest on-reload-workbench}))
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           style: tool)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Project" width: 291 highlight-color: {Color Dark-Blue})))))
  
  
  (method meta override (external-name self . rest)
    'Workbench)

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta override (host-icon self)
    {Image-Resource "Workbench"})
  
  
  (method meta override (host-title self)
    "Workbench")
  
  
  (method override (install-in-host self host)
    (define (setup-active-project)
      (let ((workbench (get-workbench))
            (preferences (current-preferences 'workbench)))
        (let ((active-project (get-active-project preferences))
              (active-traits (get-active-traits preferences)))
          (when (and workbench active-project)
            (activate-descendant self workbench active-project active-traits)))))
    
    (setup-active-project))
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method override (get-tools-view self)
    (locate self 'tools))
  
  
  (method override (focus-default self)
    (let ((tree (get-tree self)))
      (acquire-focus tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method package (get-tree self)
    (locate self '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  (method override (new-document-controller self)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set-shown? (locate-component self '(descendants header)) #f)
    (set-editor (locate self 'descendants) self)
    (set-client self (get-workbench))
    (add-quit-listener (current-application) self))
  
  
  (method override (get-designer-class self)
    Workbench-Designer)
  
  
  (method override (prepare-quit self)
    (when (and designer (file? (get-origin (get-form designer))))
      (save-designer designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method override (on-designer self evt)
    (nextmethod self evt)
    (case (get-kind evt)
      ((:child-add) (child-add self (get-property evt child:) (get-property evt parent:)))
      ((:child-remove) (child-remove self (get-property evt child:)))))
  
  
  (method package (child-add self child parent)
    (when (is? child Project)
      (project-add designer child)))
  
  
  (method package (child-remove self child)
    (when (is? child Project)
      (project-remove designer child)))
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method override (remove-selection self selection)
    (let ((projects (remove-duplicates (map (~ ascendant-project self) selection))))
      (nextmethod self selection)
      (for-each (~ update-project-catalog self) projects)))

  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\return) (launch-selection self))))
  
  
  (method (on-highlight-document self evt)
    (highlight-document self))
  
  
  (method (on-reload-workbench self evt)
    (let ((tree (get-tree self)))
      (with-cursor :wait
        (lambda ()
          (with-preserved-selection tree
            (lambda ()
              (with-preserved-expand-state tree
                (lambda ()
                  (with-update-locked self
                    (lambda ()
                      (with-design-locked client
                        (lambda ()
                          (setup-workbench (current-application))
                          (set-client self (get-workbench)))))))))
            use: 'text
            ensure-expanded?: #t)))))
  
  
  (method (on-add-project self evt)
    (add-project self))
  
  
  (method (on-add-document self evt)
    (add-document self))
  
  
  (method (on-add-directory self evt)
    (add-directory self))
  
  
  (method (on-add-group self evt)
    (add-group self))
  
  
  (method (on-install-project self evt)
    (let* ((current-directory? (get-shift? evt))
           (parent (selected-object self))
           (file (with-import-directory self current-directory? parent
                   (lambda (directory)
                     (choose-file extensions: '(("Project Files" . "project")) directory: directory)))))
      (install-project self file parent #f)))
  
  
  (method (on-import-files self evt)
    (import-files self (get-shift? evt)))
  
  
  (method (on-import-directory self evt)
    (import-directory self (get-shift? evt)))
  
  
  (method (on-synchronize-content self evt)
    (with-cursor :wait
      (lambda ()
        (synchronize-content self))))
  
  
  (method (on-set-current-directory self evt)
    (let ((group (selected-object self)))
      (let ((dir (get-directory group)))
        (current-directory-set! dir)
        (user-message "Current directory set to {a}" (parse dir)))))
  
  
  (method (on-update-catalog self evt)
    (update-catalog self))
  
  
  (method (on-update-dynamic self evt)
    (update-dynamic-dependencies self)
    (on-reload-workbench self evt))
  
  
  (method (on-search-project self evt)
    (search-project self))
  
  
  (method (on-dependencies self evt)
    (let ((project (selected-object self))
          (analyser (get-dependencies-analyser (current-application))))
      (let ((text (locate analyser 'package))
            (tree (get-tree analyser)))
        (set-string-content text (->string (get-name project)))
        (ensure-focusable tree)
        (acquire-focus tree)
        (analyse analyser))))
  
  
  (method (on-explore-depot self evt)
    (explore-depot self))
  
  
  (method (on-edit-project self evt)
    (edit-selection self))
  
  
  (method (on-edit-descriptor self evt)
    (edit-descriptor self))
  
  
  (method (on-edit-documentation self evt)
    (edit-documentation self))
  
  
  (method (on-activate self evt)
    (activate-selection self))
  
  
  (method (on-run self evt)
    (run-selection self))
  
  
  (method (on-debug self evt)
    (debug-selection self))
  
  
  (method (on-launch self evt)
    (launch-selection self))
  
  
  (method (on-distribute self evt)
    (distribute-selection self))
  
  
  (method (on-properties self evt)
    (show-properties self))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document self)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-document-controller guest))
               (moniker (get-moniker controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (project-file (find-source workbench moniker)))
              (if (not project-file)
                  (bell)
                (acquire-focus (get-tree self))
                (highlight-document-component self project-file))))))))
  
  
  (method (highlight-document-component self component)
    (define (dynamic-root tree component)
      (if (dynamic-component? tree component)
          (component-row tree component)
        (let ((parent (get-parent component)))
          (and parent (dynamic-root tree parent)))))
    
    (define (force-expand-dynamic tree component)
      (let ((dynamic-row (dynamic-root tree component)))
        (when dynamic-row
          (update-row tree dynamic-row)
          (set-state dynamic-row 'collapsed)
          (component-row tree component))))
    
    (let* ((tree (get-tree self))
           (row (or (component-row tree component)
                    (force-expand-dynamic tree component))))
      (if (not row)
          (bell)
        (ensure-expanded tree row)
        (set-single-selection tree (row->line tree row)))))

  
  ;;;
  ;;;; Select
  ;;;
  
  
  (method public (select-current self)
    (select-project self))
  
  
  (method (select-project self)
    (let ((project (get-modal Project-Selector)))
      (when project
        (activate-project self project))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current self)
    (edit-project self (current-project self)))
  
  
  (method package (edit-selection self)
    (let ((objects (selected-objects self)))
      (for-each (lambda (object)
                  (typecase object
                    ((Workbench) (edit-workbench self))
                    ((Project) (edit-project self object))))
                objects)))
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method (edit-workbench self)
    (let ((appl (current-application))
          (file Workbench-File))
      (edit-document appl file)))
  
  
  (method (edit-project self project)
    (define (project-file)
      (or (let ((form (get-form project)))
            (and (is? project Project)
                 (get-tag-reference form)))
          (let ((description-file (get-description-file project)))
            (and description-file
                 (new-brother description-file ".project")))))
    
    (let ((file (project-file)))
      (if (not file)
          (bell)
        (edit-document (current-application) file))))
  
  
  (method package (edit-descriptor self)
    (for-each (lambda (project)
                (let ((description-file (get-description-file project)))
                  (edit-document (current-application) description-file)))
              (selected-objects self)))
  
  
  (method package (edit-documentation self)
    (let ((project (selected-project self)))
      (let ((documentation (get-documentation project)))
        (let ((doc (instantiate (read-form documentation))))
          (new-frame Doc-Editor client: doc)))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (method package (add-project self)
    (add-project-to self (or (selected-object self) (get-workbench))))
  
  
  (method package (add-project-to self parent)
    (let ((tree (get-tree self)))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (default-import-directory self parent)))
          (receive (kind template empty? project directory) (get-modal New-Project-Dialog directory: default-directory)
            (define (empty-associations)
              (list (cons 'project project)))
            
            (define (associations)
              (let* ((project-parts (map ->string (split-identifier (string->symbol project))))
                     (package project)
                     (product (last project-parts))
                     (product-title (capitalize product))
                     (project-name (capitalize product))
                     (project-title project-name))
                (list (cons 'project project)
                      (cons 'project-name project-name)
                      (cons 'project-title project-title)
                      (cons 'package package)
                      (cons 'product product)
                      (cons 'product-title product-title)
                      (cons 'product-unit package)
                      (cons 'product-directories project-parts))))
            
            (let ((template (new-directory (templates-directory (current-application)) (list "project" template)))
                  (associations (if empty? (empty-associations) (associations))))
              (copy-template template directory associations)
              (with-update-locked tree
                (lambda ()
                  (let ((project-file (new-file directory (if empty? (list (format "{a}.project" project)) (list project ".project")))))
                    (let ((project-component (install-project self project-file parent #f)))
                      (unless empty?
                        (let ((src-directory (new-directory directory (list project "src"))))
                          (let ((src-content (if (exists? src-directory) (get-content src-directory nodes?: #t leaves?: #f) '())))
                            (when (not-null? src-content)
                              (let ((src-component (import-pathname self project-component src-directory project-component #t recursive?: #f)))
                                (when src-component
                                  (for-each (lambda (dir)
                                              (import-pathname self project-component dir src-component #t))
                                            src-content)))))))
                      (save (get-project-designer designer project-component))
                      (update-project-catalogs self project-component)
                      (acquire-focus tree)
                      (process-refresh designer project-component 'descendants)
                      (select-component tree project-component)
                      (let ((projects (collect-concrete-projects project-component)))
                        (when (not-null? projects)
                          (activate-project self (car projects))))
                      (user-message "Project {a} created" project)))))
              (ensure-displayed tree)))))))
  
  
  (method package (add-document self)
    (let ((parent (or (selected-object self) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (or (default-import-directory self parent must-exist?: #f) {Directory Profile} @not-sure-this-is-best (get-directory))))
          (when (or (exists? default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list default-directory)) type: 'question) 'yes))
            (create-directories default-directory)
            (receive (kind template directory name) (get-modal New-Document-Dialog directory: default-directory)
              (let* ((extension (filename-extension template))
                     (file-templates (new-directory (templates-directory (current-application)) "file"))
                     (template (new-file file-templates (concatenate template ".template")))
                     (destination (new-file directory (format "{a}.{a}" name extension)))
                     (unit (find-pathname-unit (parse destination)))
                     (associations (list (cons 'name name) (cons 'unit unit))))
                (copy-template template destination associations)
                (let ((component (import-pathname self (ascendant-project self parent) destination parent #f)))
                  (select-component (get-tree self) component)))))))))
  
  
  (method package (add-directory self)
    (let ((parent (or (selected-object self) (get-workbench))))
      (when (or (is? parent Project)
                (is? parent Project-Directory))
        (let ((parent-directory (default-import-directory self parent)))
          (let ((dirname (request-string title: "Enter Directory Name" prefix: "Name:" accepts-empty?: #f)))
            (let ((dir (new-directory parent-directory dirname)))
              (if (exists? dir)
                  (message-box "Directory already exists")
                (create dir)
                (let ((component (import-pathname self (ascendant-project self parent) dir parent #f recursive?: #f)))
                  (select-component (get-tree self) component)))))))))
  
  
  (method package (add-group self)
    (let ((parent (or (selected-object self) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (add-component-class (get-tree self) Project-Group parent: parent))))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method package (install-project self file parent descendant?)
    (let ((parent-project (ascendant-project self parent)))
      (let ((file (contextualize-pathname parent-project file)))
        (let ((project (instantiate-file file parent: parent)))
          (if (is-not? project Project)
              (error "The file \"{a}\" does not contain a project" (get-name file))
            (let ((form (get-form project)))
              (add-child designer project parent tag-reference: file)
              (reorder-component (get-tree self) project)
              (load-catalogs project)
              (user-message "{s} installed" (get-presentation-property project))
              project))))))
    
  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  (definition Ignored-Dirnames
    '(".git" ".hg" "templates"))
  
  
  (definition (import-filter? project file)
    (let ((ext (get-extension file))
          (extensions (effective-include-extensions (get-include-extensions project))))
      (if extensions
          (member? ext extensions test: extension=?)
        (known-extension-frame-class (current-application) ext))))
  
  
  (definition (filter-pathname? project pathname (filter: filter #f))
    (and (import-filter? project pathname)
         (or (not filter) (filter project pathname))))
  
  
  (method (import-directory self current-directory?)
    (let* ((parent (selected-object self))
           (project (ascendant-project self parent))
           (directory (with-import-directory self current-directory? parent
                        (lambda (directory)
                          (choose-directory directory: directory))))
           (count (count-files directory ignored-dirnames: Ignored-Dirnames filter: (lambda (file) (import-filter? project file)) max-count: MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) type: 'question) 'yes))
        (when (validate-pathnames self project (list directory))
          (let ((component (import-pathname self project directory parent #f)))
            (process-refresh designer component 'descendants))
          (update-project-catalog self project)
          (user-message "{a} imported" (parse directory))))))
  
  
  (method (import-files self current-directory?)
    (let* ((parent (selected-object self))
           (project (ascendant-project self parent))
           (files (with-import-directory self current-directory? parent
                    (lambda (directory)
                      (choose-file multiple-selection?: #t directory: directory)))))
      (import-pathnames self project files parent)
      (update-project-catalog self project)))
  
  
  (method package (import-pathnames self project pathnames parent)
    (when (validate-pathnames self project pathnames)
      (for-each (lambda (pathname)
                  (let ((component (import-pathname self project pathname parent #f)))
                    (process-refresh designer component 'descendants)))
                (sort nu<? pathnames key: get-name))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (capitalize (format-cardinality count))
                      (format-plural count)))))
  
  
  (method (import-pathname self project pathname parent descendant? (filter: filter #f) (recursive?: recursive? #t))
    (define (import-dir dir parent descendant?)
      (let ((dir (contextualize-pathname (ascendant-project self parent) dir)))
        (let ((subgroup (new Project-Directory directory: dir)))
          (add-child designer subgroup parent design-events?: (not descendant?) descendant?: descendant?)
          (set-property designer subgroup 'directory dir design-events?: (not descendant?))
          (import-content self project dir subgroup #t recursive?: recursive?))))
    
    (define (import-file file parent descendant?)
      (let ((reference (extension-reference (get-extension file))))
        (bind (module-public module-name class-name) reference
          (let ((file (contextualize-pathname (ascendant-project self parent) file)))
            (let ((name (if (eq? class-name 'Jazz-File) (string->symbol (get-base file)) #f))
                  (model (resolve-runtime-reference (deserialize-runtime-reference reference)))
                  (import (if (eq? module-name 'jazz.ide) #f module-name)))
              (let ((project-file (new model name: name source: file))
                    (workbench (get-workbench)))
                (add-child designer project-file parent import: import design-events?: (not descendant?) descendant?: descendant?)
                (set-property designer project-file 'source file design-events?: (not descendant?))
                (when (eq? class-name 'Jazz-File)
                  (set-name designer project-file name design-events?: (not descendant?)))
                project-file))))))
    
    (typecase pathname
      ((Directory)
       (let ((project-file (new-file pathname ".project")))
         (if (exists? project-file)
             (install-project self project-file parent #t)
           (import-dir pathname parent descendant?))))
      ((File)
       (when (and (or (not descendant?) (import-filter? project pathname))
                  (or (not filter) (filter project pathname)))
         (let ((ext (get-extension pathname)))
           (if (and ext (string-ci=? ext "project"))
               (install-project self pathname parent descendant?)
             (import-file pathname parent descendant?)))))))
  
  
  (method (import-content self project dir parent descendant? (filter: filter #f) (recursive?: recursive? #t))
    (when recursive?
      (iterate-directory dir
        (lambda (pathname)
          (import-pathname self project pathname parent descendant? filter: filter))
        files?: #f
        directories?: #t
        sort?: #t
        recursive?: #f
        ignored-dirnames: Ignored-Dirnames)
      (iterate-directory dir
        (lambda (pathname)
          (import-pathname self project pathname parent descendant? filter: filter))
        files?: #t
        directories?: #f
        sort?: #t
        recursive?: #f
        ignored-dirnames: Ignored-Dirnames))
    (if (or (not recursive?)
            (not descendant?)
            (not-null? (get-children parent)))
        parent
      (remove-child designer parent design-events?: (not descendant?))
      #f))
  
  
  (method (default-import-directory self object (must-exist?: must-exist? #t))
    (define (default object)
      (typecase object
        ((Project)
         (let ((tag-reference (get-tag-reference (get-form object))))
           (and tag-reference (get-parent tag-reference))))
        ((Project-Directory)
         (get-directory object))
        (else
         #f)))
    
    (let ((dir (default object)))
      (and dir
           (anchorize dir))))
  
  
  (method (with-import-directory self current-directory? object proc)
    (let ((default-directory (and (not current-directory?) (default-import-directory self object))))
      (if (and default-directory (exists? default-directory))
          (with-preserved-current-directory
            (lambda ()
              (proc default-directory)))
        (proc #f))))
  
  
  (definition (extension-reference ext)
    (cond ((member? ext '("jazz") test: extension=?)    '(module-public jazz.editor.jazz Jazz-File))
    @wait ((member? ext '("java") test: extension=?)    '(module-public jazz.editor.java Java-File))
          ((member? ext '("c" "cpp" "m") test: extension=?) '(module-public jazz.editor.c C-File))
          ((member? ext '("bmp") test: extension=?)     '(module-public jazz.project Bitmap-File))
          ((member? ext '("cur") test: extension=?)     '(module-public jazz.project Cursor-File))
          ((member? ext '("ico") test: extension=?)     '(module-public jazz.project Icon-File))
          ((member? ext '("wav") test: extension=?)     '(module-public jazz.project Sound-File))
          (else                                         '(module-public jazz.project Project-File))))
  
  
  (method package (ascendant-project self component)
    (define (ascendant component)
      (cond ((not component) #f)
            ((is? component Project) component)
            (else (ascendant (get-parent component)))))
    
    (or (ascendant component)
        (error "Unable to find ascendant project for {s}" component)))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content self)
    (define (synchronize-filter project pathname)
      (let ((ext (get-extension pathname))
            (ignored-extensions '("project" "package")))
        (not (member? ext ignored-extensions test: extension=?))))
    
    (let ((object (selected-object self)))
      (if (find-descendant object (lambda (descendant) (is? descendant Project)) include-self?: #f)
          (message-box "Cannot yet synchronize an element containing a project")
        (let ((project (ascendant-project self object))
              (directory (default-import-directory self object must-exist?: #f)))
          (if (not (exists? directory))
              (error "Directory {s} not found" directory)
            (let ((fact (new List-Factory)))
              (define (component-name component)
                (typecase component
                  ((Project-File)
                   (get-name (get-source component)))
                  ((Project-Directory)
                   (get-name (get-directory component)))
                  (else
                   (->string (get-name component)))))
              
              (define (pathname-name pathname)
                (get-name pathname))
              
              (define (fold component pathname path)
                (let ((children (get-children component))
                      (content (collect-if (lambda (pathname)
                                             (filter-pathname? project pathname filter: synchronize-filter))
                                           (get-content pathname))))
                  (merge-ordered (lambda (what key left right)
                                   (let ((path (cons key path)))
                                     (case what
                                       ((:left :right) (put fact (list what (reverse path) left right component)))
                                       ((:same)
                                        (when (directory? right)
                                          (fold left right path))))))
                                 (sort ci<? children key: component-name)
                                 (sort ci<? content key: pathname-name)
                                 left-key: component-name
                                 right-key: pathname-name
                                 case-insensitive?: #t)))
              
              (fold object directory '())
              (let ((out-of-synch (get-output fact)))
                (if (null? out-of-synch)
                    (message-box "Content already synchronized")
                  (let ((border (new Synchronize-Border size: {Dimension 500 200})))
                    (let ((tree (locate border 'tree)))
                      (define (add info)
                        (bind (what path left right) info
                          (let ((title (join path "/"))
                                (image (if (or (is? left Group) (directory? right)) {Image-Resource "OpenedFolder"} {Image-Resource "File"})))
                            (let ((c0 (new Tree-Node title: title image: image)))
                              (add-row tree children: (list c0 what (cons 'left info) what))))))
                      
                      (for-each add out-of-synch)
                      (let ((code (message-box "The following elements are out of synch. Synchronize?" class: Synchronize-Box type: 'confirmation content: border)))
                        (case code
                          ((yes)
                           (with-cursor :wait
                             (lambda ()
                               (let ((added 0)
                                     (removed 0))
                                 (for-each-visible-row tree
                                   (lambda (row rank)
                                     (let ((cell (new Cell rank 2)))
                                       (let ((data (get-cell-data tree cell)))
                                         (bind (action . info) data
                                           (unless (eq? action 'none)
                                             (bind (what path left right parent) info
                                               (case action
                                                 ((left)
                                                  (case what
                                                    ((:left)
                                                     (remove-child designer left)
                                                     (increase! removed))
                                                    ((:right)
                                                     (let ((component (import-pathname self project right parent #f)))
                                                       (process-refresh designer component 'descendants))
                                                     (increase! added))))
                                                 ((right)
                                                  (case what
                                                    ((:left)
                                                     ;; unsupported
                                                     )
                                                    ((:right)
                                                     (if (directory? right)
                                                         (delete right)
                                                       (delete right))
                                                     (increase! removed))))))))))))
                                 (update-project-catalog self project)
                                 (user-message "{a} added, {a} removed"
                                               added
                                               removed)))))))))))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames self project pathnames)
    @convert-to-checking-conflicts-with-an-understanding-of-the-unit-hierarchy
    (validate
      (lambda (report)
        (let ((workbench (get-workbench)))
          (define (iterate pathname)
            (typecase pathname
              ((Directory)
               (iterate-directory pathname iterate
                 files?: #t
                 directories?: #t
                 sort?: #t
                 recursive?: #f
                 ignored-dirnames: Ignored-Dirnames))
              ((File)
               (when (import-filter? project pathname)
                 (let ((model (extension-model (get-extension pathname))))
                   (when (eq? model Jazz-File)
                     (let* ((name (string->symbol (get-base pathname)))
                            (jazz-file (get-entry workbench name)))
                       (when jazz-file
                         (report jazz-file)))))))))
          
          (for-each iterate pathnames)))))
  
  
  (method package (validate self iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (lambda (jazz-file)
          (put already-defined jazz-file)))
      (let ((already-defined (get-output already-defined)))
        (if (null? already-defined)
            #t
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following categor{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-y/ies count)
                                 (format-is/are count)))
                 (text
                  `(<span>
                     ,header
                     (<paragraph>)
                     ,@(map (lambda (jazz-file)
                              (let ((project (get-project jazz-file)))
                                (define (action . rest)
                                  (close-modal-dialog
                                    (lambda ()
                                      (highlight-document-component self jazz-file))))
                                
                                `(<bulleted>
                                   (<text> action: ,action
                                     ,(format "{a} defined in {a}"
                                              (get-name jazz-file)
                                              (get-presentation-property project))))))
                            (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                     ,@(if too-many?
                           `((<bulleted> "..."))
                         '()))))
            (message-box text)
            #f)))))
  
  
  ;;;
  ;;;; Active
  ;;;
  
  
  (method package (set-project-active? self project flag)
    (when (not flag)
      (save-catalogs project))
    (reset-workbench-active-catalogs (get-cataloguer))
    (set-property designer project 'active? flag use-owner?: #f)
    (when flag
      (load-catalogs project))
    (let ((tree (get-tree self)))
      (let ((row (component-row tree project)))
        (when row
          (let ((node (first-child row))
                (owned (component-owned tree project)))
            (set-image node (component-image tree project))
            (set-font node (component-font tree project owned))
            (set-color node (component-color tree project owned))
            (let ((line (row->line tree row)))
              (when line
                (invalidate-cell tree (new Cell line 0))))))))
    (when flag
      (let ((active-project (get-active-project project))
            (active-traits (get-active-traits project)))
        (when active-project
          (activate-descendant self project active-project active-traits)))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection self)
    (activate-object self (selected-object self)))
  
  
  (method (activate-object self object)
    (define (find-concrete-descendant)
      (continuation-capture
        (lambda (return)
          (for-each-descendant object
            (lambda (descendant level)
              (when (and (is? descendant Project)
                         (concrete? descendant))
                (continuation-return return descendant)))
            include-self?: #f)
          #f)))
    
    (if (is? object Project)
        (if (concrete? object)
            (activate-project self object)
          (let ((concrete-descendant (find-concrete-descendant)))
            (if concrete-descendant
                (activate-project self concrete-descendant)
              (bell))))
      (bell)))
  
  
  (method (activate-project self project (traits: traits #f))
    (unless (eq? project (active-project))
      (let ((tree (get-tree self)))
        (when (active-project)
          (unhighlight-component tree (active-project)))
        (when traits
          (set-default-traits project traits))
        (set-active-project project)
        (set-preference (current-preferences 'workbench) 'active-project (project-path project))
        (when (active-project)
          (let ((row (user-data-row tree (active-project) include-invisibles?: #t)))
            (when row
              (ensure-expanded tree row)))
          (highlight-component tree (active-project))))
      (let ((appl (current-application)))
        (update-project-actions appl))))
    
  
  (method (activate-descendant self project active-project active-traits)
    (let ((descendant (find-project project active-project use-name?: #f error?: #f)))
      (when descendant
        (activate-project self descendant traits: active-traits)
        (when active-traits
          (update-project-title self descendant)))))

  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method package (update-dynamic-dependencies self)
    (define (update object)
      (typecase object
        ((Project)
         (when (get-dynamic? object)
           (update-dynamic-dependencies object)))
        ((Project-Group)
         (for-each update (get-children object)))))
    
    (with-cursor :wait
      (lambda ()
        (let ((objects (selected-objects self)))
          (for-each update objects)))))
  
  
  (method (update-catalog self)
    (define (update object)
      (typecase object
        ((Project)
         (update-project-catalogs self object))
        ((Project-Group)
         (for-each update (get-children object)))))
    
    (with-cursor :wait
      (lambda ()
        (let ((objects (selected-objects self)))
          (for-each update objects)))))
  
  
  (method (update-project-catalog self project)
    (post-catalog
      (lambda ()
        (let ((catalog (require-catalog project report?: #f)))
          (load-content catalog report?: #f)
          (update catalog report?: #t))
        (user-feedback "Done"))))
  
  
  (method (update-project-catalogs self project)
    (post-catalog
      (lambda ()
        (for-each-project project
          (lambda (project)
            (let ((catalog (require-catalog project report?: #f)))
              (load-content catalog report?: #f)
              (update catalog report?: #t))))
        (user-feedback "Done"))))
  
  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method (search-project self)
    (update-search 'projects
      selector: (lambda (projects-search)
                  (let ((project (selected-object self))
                        (combo (locate projects-search 'project)))
                    (set-value combo project)))))
  
  
  ;;;
  ;;;; Depot
  ;;;
  
  
  (method (explore-depot self)
    (let ((project (selected-project self)))
      (let ((depot (project-depot project)))
        (if (not depot)
            (bell)
          (new-frame Git-Explorer depot: depot)))))
  
  
  ;;;
  ;;;; Configure
  ;;;
  
  
  (method public (configure-current self)
    (let ((project (current-project self)))
      (let ((traits (get-modal Configuration-Selector project: project)))
        (set-default-traits project traits)
        (update-project-title self project))))
    
  
  ;;;
  ;;;; Update
  ;;;

  
  (method (update-project-title self project)
    (let ((tree (get-tree self)))
      (let ((row (user-data-row tree project)))
        (when row
          (let ((cell (new Cell (row->line tree row) 0)))
            (set-cell-title tree cell (get-presentation-property project))
            (invalidate-cell tree cell))))))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method public (run-current self)
    (let ((project (current-project self)))
      (run-project self project)))


  (method public (run-selection self)
    )

  
  (method package (run-project self project)
    (run-project (current-application) project))

  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method public (debug-current self (executable: executable #f))
    (debug-project self (current-project self) executable: executable))
  
  
  (method public (debug-selection self)
    (let ((project (current-project self)))
      (debug-project self project)))
      
  
  (method package (debug-project self project (executable: executable #f))
    (define (dependencies-arguments)
      (let ((file (get-effective-dependencies-file project)))
        (and (and file (exists? file))
             (list "-dependencies" (parse file)))))
    
    (debug-project (current-application) project executable: executable command-arguments: (dependencies-arguments) debugger-interactive?: #t))
  
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method public (test-current self)
    (let ((project (current-project self)))
      (project-test project)))

  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method public (validate-current self (executable: executable #f))
    (validate-project self (current-project self) executable: executable))
  
  
  (method public (validate-selection self)
    (let ((project (current-project self)))
      (validate-project self project)))
      
  
  (method package (validate-project self project (executable: executable #f))
    (validate-project (current-application) project executable: executable debugger-interactive?: #t))

  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-selection self)
    (let ((appl (current-application)))
      (for-each (lambda (component)
                  (typecase component
                    ((Project)
                     (debug-project self component))
                    ((Project-File)
                     (let* ((file (get-source component))
                            (ext (get-extension file)))
                       (edit-document appl file)))))
                (selected-objects self))))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current self evt)
    (let ((project (current-project self)))
      (if (not project)
          (bell)
        (build-project self project))))
  
  
  (method public (build-current self)
    (let ((project (current-project self)))
      (build-project self project)))
  
  
  (method (build-project self project)
    (project-build project))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current self)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified? guest)
          (save guest))
        (let ((moniker (get-moniker (get-document-controller guest))))
          (compile-moniker self moniker)))))
  
  
  (method public (compile-moniker self moniker)
    (let* ((workbench (get-workbench))
           (project-file (find-source workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file self moniker project-file))))
  
  
  (method (compile-file self moniker project-file)
    (let ((name (find-pathname-unit (parse moniker))))
      (if (not name)
          (bell)
        (let ((kernel (project-kernel (get-project project-file))))
          (launch-executable kernel arguments: (list "-compile" (->string name)) show-console?: #t)))))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current self)
    (define (preprocess-file moniker file)
      (let ((proc
              (lambda (thread)
                (let ((project (get-project file)))
                  @cant-find
                  (prepare-maps project)
                  @cant-find
                  (prepare-directories project)
                  (user-message "Preprocessing {a}..." moniker)
                  (let ((output (get-output-log (current-application)))
                        (timer (new Timer)))
                    (clear-results output)
                    (select-resultset output)
                    (select-docked Output-Log)
                    (preprocess file project #f #f output force?: #t)
                    (user-message "Preprocessing done in {a}" (cpu-duration timer)))))))
        (proc #f)))
    
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified? guest)
          (save guest))
        (let* ((moniker (get-moniker (get-document-controller guest)))
               (workbench (get-workbench))
               (file (find-source workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current self)
    (let ((project (current-project self)))
      (clean-project self project)))
  
  
  (method (clean-project self project)
    (if (concrete? project)
        ;; to complete
        #f
      (bell)))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current self evt)
    (let ((project (selected-project self)))
      (if (not project)
          (bell)
        (distribute-project self project))))
  
  
  (method public (distribute-current self)
    (let ((project (current-project self)))
      (distribute-project self project)))
  
  
  (method (distribute-selection self)
    (distribute-project self (selected-project self)))
  
  
  (method (distribute-project self project)
    @cant-find
    (let* ((mode         'backup)
           (left         (project-distribution project))
           (right        (project-distribution-directory project))
           (content      (project-distribution-list project))
           (ignored-dirs (list ".git" ".hg" "bin" "build" "bootstrap" "deploy" "gambit"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories left-moniker: left right-moniker: right left-content: content ignored-nodes: ignored-dirs ignored-leaves: files ignored-extensions: extensions host-visible?: #f)))
      (with-cursor :wait
        (lambda ()
          (compare-trees (get-guest frame))
          (focus-host frame)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object self)
    (let ((tree (get-tree self)))
      (selected-component tree)))
  
  
  (method (selected-objects self)
    (let ((tree (get-tree self)))
      (selected-components tree)))
  
  
  (method (selected-project self)
    (let ((object (selected-object self)))
      (and (is? object Project)
           object)))
  
  
  (method (selected-concrete-project self)
    (let ((object (selected-object self)))
      (and (is? object Project)
           (concrete? object)
           object)))
  
  
  (method package (current-project self)
    (if (not (active-project))
        (begin
          (message-box "No active project")
          (signal-cancel))
      (active-project)))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu self)
    (let ((tree (get-tree self)))
      (define (new-group-menu object)
        (let ((menu (new Group-Menu client: (get-tree self)))
              (objects (selected-objects self)))
          (update-component-menu menu objects '() #f '() #f)
          (update-group/project-menu menu object)
          (layout-menu menu)
          menu))
      
      (define (new-workbench-menu object)
        (let ((menu (new Workbench-Menu client: (get-tree self)))
              (objects (selected-objects self)))
          (update-component-menu menu objects '() #f '() #f)
          (update-project-menu menu object objects)
          (update-group/project-menu menu object)
          (layout-menu menu)
          menu))
      
      (define (new-concrete-project-menu object)
        (let ((menu (new Concrete-Project-Menu client: (get-tree self)))
              (objects (selected-objects self)))
          (update-component-menu menu objects '() #f '() #f)
          (update-project-menu menu object objects)
          (update-group/project-menu menu object)
          (layout-menu menu)
          menu))
      
      (define (new-project-menu object)
        (let ((menu (new Project-Menu client: (get-tree self)))
              (objects (selected-objects self)))
          (update-component-menu menu objects '() #f '() #f)
          (update-project-menu menu object objects)
          (update-group/project-menu menu object)
          (layout-menu menu)
          menu))
      
      (define (new-element-menu object)
        (let ((menu (new Element-Menu client: (get-tree self))))
          (update-component-menu menu (selected-objects self) '() #f '() #f)
          menu))
      
      (define (update-project-menu menu object objects)
        (let ((kind (uniform objects key: (lambda (object)
                                            (and (is? object Project)
                                                 (let ((description-file (get-description-file object)))
                                                   (and description-file
                                                        (let ((name (get-name description-file)))
                                                          (cond ((ci=? name ".repository") 'repository)
                                                                ((ci=? name ".package") 'package)
                                                                (else #f))))))))))
          (set-visible? (locate menu 'edit-descriptor) (boolean kind))
          (when kind
            (set-title (locate menu 'edit-descriptor)
              (case kind
                ((repository) "Edit Repository")
                ((package) "Edit Package"))))
          (when (neq? kind 'package)
            (set-visible? (locate menu 'dependencies) #f)))
        (let ((documentation (and (is? object Project) (get-documentation object))))
          (when (not documentation)
            (set-visible? (locate menu 'edit-documentation) #f)))
        (let ((depot (and (is? object Project) (project-depot object))))
          (when (not depot)
            (set-visible? (locate menu 'explore-depot) #f)))
        (let ((dynamic? (and (is? object Project) (get-dynamic? object))))
          (set-visible? (locate menu 'update-dynamic) dynamic?))
        (let ((content? (has-content? object)))
          (set-visible? (locate menu 'update-catalog) content?)
          (set-visible? (locate menu 'search-project) content?)))
      
      (define (update-group/project-menu menu object)
        (define (hide-item name)
          (let ((item (locate-component menu name)))
            (when item
              (set-visible? item #f))))
        
        (when (> (length (get-selection tree)) 1)
          (hide-item 'add-project)
          (hide-item 'add-document)
          (hide-item 'add-directory)
          (hide-item 'install-project)
          (hide-item 'import-files)
          (hide-item 'import-directory)
          (hide-item 'synchronize-content)
          (hide-item 'set-current-directory))
        
        (when (is-not? object Project-Directory)
          (hide-item 'set-current-directory))
        
        (when (not (and (or (is? object Project)
                            (is? object Project-Directory))
                        (default-import-directory self object)))
          (hide-item 'add-directory)))
      
      (let ((object (selected-object self)))
        (typecase object
          ((Workbench) (new-workbench-menu object))
          ((Project-Group) (new-group-menu object))
          ((Project)
           (if (concrete? object)
               (new-concrete-project-menu object)
             (new-project-menu object)))
          (else
           (and object
                (new-element-menu object)))))))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state self pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-project = {s}" (active-project))
      (format :console "{%}project-designers =")
      @cant-find-get-project-designers
      (let* ((pairs (sort < (get-project-designers designer) key: (lambda (pair) (category-identifier (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (project . designer) pair
                      (format :console "{%}  {a} {a}" (category-identifier (class-of project)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}categories-table =")
      @cant-find
      (let* ((pairs (sort < (table-keys/values (get-categories-table workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . category) pair
                      (format :console "{%}  {a} {a}" name category)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Controller
;;;


(class Workbench-Manager-Controller extends Component-Editor-Controller
  
  
  (method override (document-status self)
    "Workbench"))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-project           title: "New Project..." before: add-item action-handler: {Action workbench-manager add-project})
      (<Label-Item>     name: add-document          title: "New Document..." before: add-item icon: {Image-Resource "Add"} action-handler: {Action workbench-manager add-document})
      (<Label-Item>     name: add-directory         title: "New Directory..." before: add-item action-handler: {Action workbench-manager add-directory})
      (<Label-Item>     name: install-project       title: "Install Project..." before: cut icon: {Image-Resource "Import"} action-handler: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files          title: "Import Files..." before: cut action-handler: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory      title: "Import Directory..." before: cut action-handler: {Action workbench-manager import-directory})
      (<Label-Item>     name: synchronize-content   title: "Synchronize..." before: cut action-handler: {Action workbench-manager synchronize-content})
      (<Separator-Item>                             before: cut)
      (<Label-Item>     name: set-current-directory title: "Set as Current Directory" before: cut action-handler: {Action workbench-manager set-current-directory})
      (<Separator-Item>                             before: cut)
      (<!>              name: delete-selection      title: "Remove"))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit-project         title: "Edit Project" before: add-item icon: {Image-Resource "Edit"} action-handler: {Action workbench-manager edit-project})
      (<Label-Item>     name: edit-descriptor      title: "Edit Descriptor" before: add-item action-handler: {Action workbench-manager edit-descriptor})
      (<Label-Item>     name: edit-documentation   title: "Edit Documentation" before: add-item action-handler: {Action workbench-manager edit-documentation})
      (<Separator-Item>                            before: add-item)
      (<Label-Item>     name: add-project          title: "New Project..." before: add-item action-handler: {Action workbench-manager add-project})
      (<Label-Item>     name: add-document         title: "New Document..." before: add-item icon: {Image-Resource "Add"} action-handler: {Action workbench-manager add-document})
      (<Label-Item>     name: add-directory        title: "New Directory..." before: add-item action-handler: {Action workbench-manager add-directory})
      (<Label-Item>     name: install-project      title: "Install Project..." before: cut icon: {Image-Resource "Import"} action-handler: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files         title: "Import Files..." before: cut action-handler: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory     title: "Import Directory..." before: cut action-handler: {Action workbench-manager import-directory})
      (<Label-Item>     name: synchronize-content  title: "Synchronize..." before: cut action-handler: {Action workbench-manager synchronize-content})
      (<Separator-Item>                            before: cut)
      (<Label-Item>     name: search-project       title: "Search Project" before: cut icon: {Image-Resource "Find"} action-handler: {Action workbench-manager search-project})
      (<Label-Item>     name: update-catalog       title: "Update Catalog" before: cut icon: {Image-Resource "Catalog"} action-handler: {Action workbench-manager update-catalog})
      (<Label-Item>     name: update-dynamic       title: "Update Dynamic" before: cut action-handler: {Action workbench-manager update-dynamic})
      (<Label-Item>     name: dependencies         title: "Dependencies" before: cut icon: {Image-Resource "Class"} action-handler: {Action workbench-manager dependencies})
      (<Separator-Item>                            before: cut)
      (<Label-Item>     name: explore-depot        title: "Explore Depot" before: cut icon: {Image-Resource "Configure"} action-handler: {Action workbench-manager explore-depot})
      (<Separator-Item>                            before: cut)
      (<!>              name: delete-selection     title: "Remove"))))


;;;
;;;; Concrete-Project-Menu
;;;


(class Concrete-Project-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "Select as Active Project" before: cut default?: #t action-handler: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Workbench-Menu
;;;


(class Workbench-Menu extends Project-Menu
  
  
  (form
    (<install>
      @wait-complete
      (<!>              name: synchronize-content visible?: #f))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: launch           title: "Edit" before: cut default?: #t icon: {Image-Resource "Edit"} action-handler: {Action workbench-manager launch})
      (<Separator-Item>                        before: cut)
      (<!>              name: delete-selection title: "Remove")))))
