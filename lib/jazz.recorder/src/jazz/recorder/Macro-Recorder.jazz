;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Macro Recording
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.recorder.Macro-Recorder jazz


(import (jazz.library)
        (jazz.recorder)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window))


(definition public Recording-Factory
  (new List-Factory))

(definition public Registered-Recordings
  (make-table test: eqv?))

(definition public Active-Recording
  #f)


(class Macro-Recorder extends Object
  
  
  (slot recording? initialize #f getter generate)
  (slot playing?   initialize #f getter generate)
  (slot hooked?    initialize #f getter generate)
  
  
  ;;;
  ;;;; Hooks
  ;;;
  
  
  ;; Todo
  ;; - can even interpolate missing mouse-position to simulate mouse movement between registered positions!!
  ;; - coalesce context menus same as menubar!?
  ;; - coalesce double-click + up
  ;; - drag & drop support
  ;; - events
  ;;   - scrap event-type parameter!?
  ;; - script management
  ;;   - define-script
  ;;     - or as a jazz script!?
  ;;     - or as a designer toolbox element!?
  ;;   - initial conditions
  ;;     - maybe we can save database snapshots as the volume will be very small for the test database
  ;;       - this is a first step in unifying with unit tests
  ;;     - serialize and deserialize database
  ;;     - need a test profile
  ;;     - other initial conditions?
  ;;     - Uranos initial conditions
  ;;       - version (client & server)
  ;;       - settings (client)
  ;;       - login, ...
  ;;       - time, date, ...
  ;;       - database
  ;;       - external systems
  ;;         - import
  ;;       - os
  ;;       - screen, application size
  ;;       - multiple screens
  ;;       - backend (32bit, 64bits, ...)
  ;;       - internet accessibility
  ;;   - code vs data (tree structure of scripts)
  ;;   - dependencies between scripts
  ;;   - expected conditions
  ;;     - what's on screen
  ;;     - errors
  ;;     - feedback dialogs
  ;;     - generated files
  ;;       - generated pdf
  ;; - asynchronous behaviors
  ;;   - threads
  ;;   - timers
  ;; - error management
  ;; - result management
  ;; - control UI
  ;;   - remote debugger!?
  ;; - code coverage
  ;;   - automatic determination of what tests need to be rerun for changes to code based on code coverage!?
  ;; - nightly test
  ;; - maybe we can include load and performance tests here by generating volume data on the fly!?
  ;;
  ;; Host
  ;; - :modal
  ;; - :popup
  ;; - :menubar
  ;; - :toolbar
  ;; - :status-bar
  ;; - :palette name
  ;; - :docked name
  ;; - :frame
  
  
  (method (event-hook event)
    (event-hook-impl event))
  
  
  (method (event-hook-impl event)
    (define (identify object)
      (cond ((enumerator? object)
             (list object))
            ((is? object View)
             (identify-view object))
            (else
             (unidentifiable "object"))))
    
    (define (identify-view view)
      (let ((host (get-host~ view)))
        (if host
            (let ((guest (get-guest~ host)))
              (if guest
                  (let ((host-identifier (identify-host host guest)))
                    (if host-identifier
                        (let ((view-identifier (identify-in guest view)))
                          (if view-identifier
                              (if (and (pair? view-identifier)
                                       (null? (cdr view-identifier)))
                                  (list host-identifier (car view-identifier))
                                (list host-identifier view-identifier))
                            (let ((view-identifier (identify-in host view)))
                              (if view-identifier
                                  (list host-identifier (cons :host view-identifier))
                                (unidentifiable (format "view: {s}" view))))))
                      (unidentifiable "host")))
                (unidentifiable "guest")))
          (unidentifiable "no host"))))
    
    (define (identify-host host guest)
      (let ((appl (get-application)))
        (cond ((eq? host (current-modal)) :modal)
              ((eq? host (current-popup)) :popup)
              ((eq? guest (find-menubar~ appl)) :menubar)
              ((eq? guest (find-toolbar~ appl)) :toolbar)
              ((eq? guest (find-status-bar~ appl)) :statusbar)
              ((eq? host (current-frame)) :frame)
              ((singleton-palette-name host) => (lambda (name) (list :palette name)))
              ((singleton-docked-name host) => (lambda (name) (list :docked name)))
              (else #f))))
    
    (define (identify-in in view)
      (if (eq? view in)
          (list)
        (identify-descendant~ in view)))
    
    (define (unidentifiable msg)
      @debug
      (error "Unidentifiable {a}" msg)
      (list :unidentifiable msg))
    
    (when (and recording? (eq? (effective-recording-level) 'event))
      (let ((kind (get-kind~ event))
            (sender (get-sender~ event)))
        (let ((locator (if (or (not sender) (eq? kind :char))
                           #f
                         (identify sender))))
          (let ((action (cons locator event)))
            (put~ Recording-Factory action))))))
  
  
  (method (event-access-hook event)
    (event-access-hook-impl event))
  
  
  (method (event-access-hook-impl event)
    (when (and recording?
               (eq? (effective-recording-level) 'event)
               (memq? (get-kind~ event) '(:mouse-down :mouse-up)))
      (access-event event)))
  
  
  (method (action-hook action/handler event)
    (action-hook-impl action/handler event))
  
  
  (method (action-hook-impl action/handler event)
    (when (and recording? (eq? (effective-recording-level) 'action))
      (record action/handler event)))
    
  
  ;;;
  ;;;; Events
  ;;;

  
  (method (on-start-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)
      (set! Recording-Factory (new List-Factory))
      (when (not hooked?)
        (register-event-hook event-hook)
        (register-event-access-hook event-access-hook)
        (register-action-hook action-hook)
        (set! hooked? #t))))
  
  
  (method (on-stop-recording evt)
    (when recording?
      (user-message "Stopped")
      (set! recording? #f)
      (set! Recording-Factory (coalesce-recording Recording-Factory))
      (set! Active-Recording #f)
      ;; this doesn't work yet because getting method value twice doesn't return eq? objects
      @wait (
      (unregister-event-hook event-hook)
      (unregister-event-access-hook event-access-hook)
      (unregister-action-hook action-hook))))

  
  (method (on-resume-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)))
  
  
  (method (on-play-recording evt)
    (if (not recording?)
        (begin
          (user-message "Playing...")
          (let ((no (get-property~ evt no:)))
            (if (not no)
                (play-current-recording)
              (play-recording (get-recording no))))
          (user-message "Done"))
      (error "You cannot play while a recording is in progress")))
  
  
  (method (on-output-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (output-recording actions))))
  
  
  (method (on-present-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (present-recording actions))))
  
  
  (method (on-register-recording evt)
    (let ((no (parse-integer (request-string title: "Register Recording (1 to 5)" prefix: "No:" initial-value: "1"))))
      (assert (between? no 1 5))
      (let ((recording (get-output~ Recording-Factory)))
        (register-recording no recording)
        (user-message "Recording {a} registered" no))))
  
  
  (method (on-set-active-recording evt)
    (let ((name (request-string title: "Enter Recording Name" prefix: "Name:")))
      (if (not name)
          (begin
            (set! Active-Recording #f)
            (user-message "Active recording reset to default"))
        (let ((no (read-string-element name)))
          (get-recording no)
          (set! Active-Recording no)
          (user-message "Active recording set to {a}" no)))))
  
  
  ;;;
  ;;;; Coalesce
  ;;;
  
  
  (method (coalesce-recording recording)
    (case (effective-recording-level)
      ((event)
       (let ((debug? #f))
         (define (pretty what recording)
           (when debug?
             (debug what)
             (for-each debug (get-output~ recording))))
         
         (pretty recording: recording)
         (let ((coalesced (coalesce-events (coalesce-events recording 0) 1)))
           (pretty coalesced: coalesced)
           (let ((condensed (condense-events coalesced)))
             (pretty condensed: condensed)
             condensed))))
      (else
       (coalesce-actions recording))))
  
  
  (method (coalesce-events recording pass)
    (define (normalize-action action)
      (bind (where . event) action
        (if (eq? (get-kind~ event) :char)
            (let ((key (get-key~ event)))
              (if (and (char? key)
                       (let ((modifiers (get-modifiers~ event)))
                         (or (= modifiers NoModifiers)
                             (= modifiers Shift-Bit))))
                  (make-string-action (format "{c}" key))
                action))
          action)))
    
    (define (coalesce-action current held)
      (bind (top-where . top-event) (car held)
        (bind (where . event) current
          (let ((top-kind (get-kind~ top-event))
                (top-sender (get-sender~ top-event))
                (top-modifiers (get-modifiers~ top-event))
                (kind (get-kind~ event))
                (sender (get-sender~ event))
                (modifiers (get-modifiers~ event)))
            (cond ((and (eq? top-kind :string)
                        (eq? kind :string))
                   (let ((top-content (get-property~ top-event content:))
                         (content (get-property~ event content:)))
                     (cons (make-string-action (concatenate top-content content)) (cdr held))))
                  ((and (eq? top-kind :mouse-down)
                        (eq? kind :mouse-up)
                        (eq? top-sender sender)
                        (= top-modifiers modifiers)
                        (near? (get-position~ top-event) (get-position~ event) 5))
                   (let ((click-event (new Mouse-Event :click top-sender top-modifiers position: (get-position~ top-event))))
                     (when (or (accessed-event? top-event)
                               (accessed-event? event))
                       (access-event click-event))
                     (let ((action (cons top-where click-event)))
                       (cons action (cdr held)))))
                  ((and (pair? top-where)
                        (eq? (car top-where) :menubar)
                        (pair? where)
                        (eq? (car where) :popup)
                        (eq? top-kind :click)
                        (eq? kind :click)
                        (is? top-sender Item)
                        (is? sender Item))
                   (let ((menu-event (new Event :menubar top-sender top-modifiers path: (cons (cadr top-where) (cdr where)))))
                     (let ((action (cons (list :menubar) menu-event)))
                       (cons action (cdr held)))))
                  ((and (pair? where)
                        (eq? (car where) :popup)
                        (eq? top-kind :menubar)
                        (eq? kind :click)
                        (is? sender Item))
                   (let ((menu-event (new Event :menubar top-sender top-modifiers path: (append (get-property~ top-event path:) (cdr where)))))
                     (let ((action (cons (list :menubar) menu-event)))
                       (cons action (cdr held)))))
                  (else
                   #f))))))
    
    (define (make-string-action content)
      (cons #f (new Event :string #f NoModifiers content: content)))
    
    (let (iter (scan (get-output~ recording))
               (held '()))
      (if (null? scan)
          (let ((fact (new List-Factory)))
            (put-sequence~ fact (reverse held))
            fact)
        (let ((current (normalize-action (car scan))))
          (if (null? held)
              (iter (cdr scan) (cons current held))
            (iter (cdr scan) (or (coalesce-action current held)
                                 (cons current held))))))))
  
  
  (method (coalesce-actions recording)
    recording
    @buggy-with-translate-key
    (let* ((fact (new List-Factory))
           (result #f)
           (coalesce
            (lambda ()
              (when result
                (let ((handler {Event-Handler :focus on-insert})
                      (event (make-event Event :string self content: result)))
                  (put~ fact (cons handler event))
                  (set! result #f))))))
      (for-each (lambda (action)
                  (bind (action/handler . event) action
                    (if (and (eq? (get-target-name action/handler) :focus)
                             (eq? (get-action/method-name action/handler) 'on-insert))
                        (let ((added (string (get-property~ event content:))))
                          (if (not result)
                              (set! result added)
                            (set! result (string-append result added))))
                      (coalesce)
                      (put~ fact action))))
                (get-output~ recording))
      (coalesce)
      fact))
  
  
  ;;;
  ;;;; Condense
  ;;;
  
  
  (method (condense-events recording)
    (define (condense-kind kind)
      (case kind
        ((:mouse-down) :down)
        ((:mouse-up) :up)
        (else kind)))
    
    (define (condense-position event)
      (if (and (memq? (get-kind~ event) '(:mouse-down :down :mouse-up :up :click))
               (unaccessed-event? event))
          #f
        (get-position~ event)))
    
    (let ((fact (new List-Factory)))
      (for-each (lambda (action)
                  (bind (where . event) action
                    (let ((kind (condense-kind (get-kind~ event)))
                          (modifiers (modifiers->keys (get-modifiers~ event))))
                      (put~ fact
                        (case kind
                          ((:char)
                           `(,kind ,(get-key~ event) ,@modifiers))
                          ((:string)
                           `(,kind ,(get-property~ event content:) ,@modifiers))
                          ((:menubar)
                           `(,kind ,(get-property~ event path:) ,@modifiers))
                          (else
                           (let ((host (car where))
                                 (view (cadr where))
                                 (position (condense-position event)))
                             `(,kind ,host ,view ,@(if position (list position) '()) ,@modifiers))))))))
                (get-output~ recording))
      fact))
  
  
  ;;;
  ;;;; Present
  ;;;
  
  
  (method (present-recording actions)
    (let* ((focus (get-focus))
           (output (open-output-string)))
      (loop (for action in actions)
            (for first? first #t then #f)
            (do (bind (action/handler . event) action
                  (if (pair? action/handler)
                      (format output "{?:{%}~}{l} {a}"
                        (not first?)
                        action/handler
                        event)
                    (format output "{?:{%}~}{a} {a} {a}"
                      (not first?)
                      (get-target-name action/handler)
                      (get-action/method-name action/handler)
                      event)))))
      (message-box (get-output-string output)
        title: "Recording")))
  
  
  (method (output-recording actions)
    (let ((text (get-focus)))
      (if (is-not? text Text-View)
          (bell)
        (let ((model (get-model~ text)))
          (with-atomic-undo~ (get-undoer~ model)
            (lambda ()
              (loop (for first? first #t then #f)
                    (for action in actions)
                    (do (unless first?
                          (insert-newline~ text))
                        (insert-string~ text (->string action :reader))
                      (unless first?
                        (tabulate~ text))))))))))
  
  
  ;;;
  ;;;; Patch
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...
  
  
  (definition (get-target-name action/handler)
    (typecase action/handler
      ((Action) (get-target-name~ action/handler))
      (else (get-target-name~ action/handler))))
  
  
  (definition (get-action/method-name action/handler)
    (typecase action/handler
      ((Action) (get-action-name~ action/handler))
      (else (get-method-name~ action/handler))))
  
  
  ;;;
  ;;;; Recording
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...

  
  (method public (record action/handler event)
    (unless (or (eq? (get-target-name action/handler) :recorder)
                ;; quick fix that needs to be thought out as it will make any extended command non-recordable amongst other things
                (memq? (get-action/method-name action/handler) '(on-start-recording on-command-extended)))
      (put~ Recording-Factory (cons action/handler event))))
  
  
  (method public (register-recording name recording)
    (table-set! Registered-Recordings name recording))
  
  
  (method public (get-recording name)
    (or (table-ref Registered-Recordings name #f)
        (begin
          (message-box (format "No recording {a} registered" name))
          (signal-cancel))))
    
  
  ;;;
  ;;;; Playback
  ;;;
  
  
  (method public (get-current-recording)
    (get-output~ Recording-Factory))
  
  
  (method public (play-current-recording)
    (if (not Active-Recording)
        (let ((profile (get-profile~ (get-application))))
          (unless (play-recording~ profile)
            (play-recording (get-output~ Recording-Factory))))
      (play-recording (get-recording Active-Recording))))


  (method public (play-recording recording)
    (if (not recording?)
        (case (effective-recording-level)
          ((event)
           (thread-start!
             (new-thread
               (lambda ()
                 (play-events recording))
               'recording)))
          (else
           (let ((old playing?))
             (unwind-protect
                 (begin
                   (set! playing? #t)
                   (let ((focus (get-focus)))
                     (if (is? focus Text-View)
                         (let ((model (get-model~ focus)))
                           (with-atomic-undo~ (get-undoer~ model)
                             (lambda ()
                               (for-each play-action recording)
                               (end-completion~ focus))))
                       (for-each play-action recording))))
               (set! playing? old)))))
      (error "You cannot play a recording while another is being recorded")))
  
  
  (method public (find-target target)
    (process-alias~ (get-process) target))))
