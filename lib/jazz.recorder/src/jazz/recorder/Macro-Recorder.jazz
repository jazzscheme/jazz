;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Macro Recording
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.recorder.Macro-Recorder jazz


(import (jazz.library)
        (jazz.recorder)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window))


(definition public Recording-Factory
  (new List-Factory))

(definition public Registered-Recordings
  (make-table test: eqv?))

(definition public Active-Recording
  #f)


(class Macro-Recorder extends Object
  
  
  (slot recording? initialize #f getter generate)
  (slot playing?   initialize #f getter generate)
  (slot hooked?    initialize #f getter generate)
  
  
  (slot previous initialize #f)
  
  
  ;;;
  ;;;; Hooks
  ;;;
  
  
  ;; Todo
  ;; - identify consoles in console manager
  ;; - mouse events (all events) need to use an event that encapsulates modifiers
  ;; - how to fix mouse-up in a popup menu that is broken because a submenu was poped on mouse-down
  ;; - fix fragility of play-root that can find another view (especially fragile to scroll)
  ;;   - pass the view explicitly to dispatch-* methods!?
  ;; - enter & leave would be very nice for visual feedback of what is happening
  ;; - can even interpolate missing mouse-position to simulate mouse movement between registered positions!!
  ;;
  ;; Host
  ;; - :modal
  ;; - :menubar
  ;; - :toolbar
  ;; - :status-bar
  ;; - :docked name
  ;; - :frame
  
  
  (method (event-hook object event)
    (event-hook-impl object event))
  
  
  (method (event-hook-impl object event)
    (define (identify)
      (cond ((enumerator? object)
             (list object))
            ((is? object View)
             (identify-view object))
            (else
             (unidentifiable "object"))))
    
    (define (identify-view view)
      (let ((host (get-host~ object)))
        (if host
            (let ((guest (get-guest~ host)))
              (if guest
                  (let ((host-identifier (identify-host host guest)))
                    (if host-identifier
                        (let ((view-identifier (identify-in guest view)))
                          (if view-identifier
                              (if (and (pair? view-identifier)
                                       (null? (cdr view-identifier)))
                                  (list host-identifier (car view-identifier))
                                (list host-identifier view-identifier))
                            (let ((view-identifier (identify-in host view)))
                              (if view-identifier
                                  (list host-identifier (cons :host view-identifier))
                                (unidentifiable (format "view: {s}" view))))))
                      (unidentifiable "host")))
                (unidentifiable "guest")))
          (unidentifiable "no host"))))
    
    (define (identify-host host guest)
      (let ((appl (get-application)))
        (cond ((eq? host (current-modal)) :modal)
              ((eq? host (current-popup)) :popup)
              ((eq? guest (find-menubar~ appl)) :menubar)
              ((eq? guest (find-toolbar~ appl)) :toolbar)
              ((eq? guest (find-status-bar~ appl)) :statusbar)
              ((eq? host (current-frame)) :frame)
              ((singleton-docked-name host) => (lambda (name) (list :docked name)))
              (else #f))))
    
    (define (identify-in in view)
      (if (eq? view in)
          (list)
        (or (identify-component~ in view)
            (identify-child~ in view))))
    
    (define (unidentifiable msg)
      @debug
      (error "Unidentifiable {a}" msg)
      (list :unidentifiable msg))
    
    (when (and recording? (eq? (effective-recording-level) 'event))
      (if (and (eq? (get-kind~ event) :mouse-leave)
               previous
               (eq? object (car previous))
               (eq? (get-kind~ (cddr previous)) :mouse-enter))
          (set! previous #f)
        (event-hook-previous)
        (let ((locator (if (or (not object) (eq? (get-kind~ event) :char))
                           #f
                         (identify))))
          (let ((action (cons locator event)))
            (set! previous (cons object action)))))))
  
  
  (method (event-hook-previous)
    (when previous
      (put~ Recording-Factory (cdr previous))
      (set! previous #f)))
  
  
  (method (action-hook action/handler event)
    (when (and recording? (eq? (effective-recording-level) 'action))
      (record action/handler event)))
    
  
  ;;;
  ;;;; Events
  ;;;

  
  (method (on-start-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)
      (set! previous #f)
      (set! Recording-Factory (new List-Factory))
      (when (not hooked?)
        (register-event-hook event-hook)
        (register-action-hook action-hook)
        (set! hooked? #t))))
  
  
  (method (on-stop-recording evt)
    (when recording?
      (when (eq? (effective-recording-level) 'event)
        (event-hook-previous))
      (user-message "Stopped")
      (set! recording? #f)
      (set! previous #f)
      (set! Recording-Factory (coalesce-recording Recording-Factory))
      (set! Active-Recording #f)
      ;; this doesn't work yet because getting method value twice doesn't return eq? objects
      @wait (
      (unregister-event-hook event-hook)
      (unregister-action-hook action-hook))))

  
  (method (on-resume-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)))
  
  
  (method (on-play-recording evt)
    (if (not recording?)
        (begin
          (user-message "Playing...")
          (let ((no (get-property~ evt no:)))
            (if (not no)
                (play-current-recording)
              (play-recording (get-recording no))))
          (user-message "Done"))
      (error "You cannot play while a recording is in progress")))
  
  
  (method (on-output-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (output-recording actions))))
  
  
  (method (on-present-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (present-recording actions))))
  
  
  (method (on-register-recording evt)
    (let ((no (parse-integer (request-string title: "Register Recording (1 to 5)" prefix: "No:" initial-value: "1"))))
      (assert (between? no 1 5))
      (let ((recording (get-output~ Recording-Factory)))
        (register-recording no recording)
        (user-message "Recording {a} registered" no))))
  
  
  (method (on-set-active-recording evt)
    (let ((name (request-string title: "Enter Recording Name" prefix: "Name:")))
      (if (not name)
          (begin
            (set! Active-Recording #f)
            (user-message "Active recording reset to default"))
        (let ((no (read-string-element name)))
          (get-recording no)
          (set! Active-Recording no)
          (user-message "Active recording set to {a}" no)))))
  
  
  ;;;
  ;;;; Coalesce
  ;;;
  
  
  (method (coalesce-recording recording)
    (case (effective-recording-level)
      ((event)
       (let ((debug? #f))
         (define (pretty what recording)
           (when debug?
             (debug what)
             (for-each debug (get-output~ recording))))
         
         (pretty recording: recording)
         (let ((coalesced (coalesce-events recording)))
           (pretty coalesced: coalesced)
           (let ((condensed (condense-events coalesced)))
             (pretty condensed: condensed)
             condensed))))
      (else
       (coalesce-actions recording))))
  
  
  (method (coalesce-events recording)
    (define (normalize-action action)
      (bind (where . event) action
        (if (and (not where)
                 (eq? (get-kind~ event) :char))
            (let ((content (get-property~ event content:)))
              (if (and (char? content)
                       (let ((modifiers (get-modifiers~ event)))
                         (or (= modifiers NoModifiers)
                             (= modifiers Shift-Bit))))
                  (make-string-action (format "{c}" content))
                action))
          action)))
    
    (define (coalesce-action current held)
      (bind (where . event) current
        (bind (top-where . top-event) (car held)
          (when (and (eq? (get-kind~ event) :string)
                     (eq? (get-kind~ top-event) :string))
            (let ((top-content (get-property~ top-event content:))
                  (content (get-property~ event content:)))
              (cons (make-string-action (concatenate content top-content)) (cdr held)))))))
    
    (define (simplify-action current held)
      (bind (where . event) current
        (bind (top-where . top-event) (car held)
          (let ((modifiers (get-modifiers~ event))
                (top-modifiers (get-modifiers~ top-event)))
            (cond ((and (eq? (get-kind~ event) :mouse-up)
                        (eq? (get-kind~ top-event) :mouse-down)
                        (equal? where top-where)
                        (= modifiers top-modifiers)
                        (near? (get-position~ event) (get-position~ top-event) 5))
                   (let ((action (cons where (new Event :click #f modifiers position: (get-position~ event)))))
                     (cons action (cdr held))))
                  (else
                   #f))))))
    
    (define (make-string-action content)
      (cons #f (new Event :string #f NoModifiers content: content)))
    
    (let (iter (scan (get-output~ recording))
               (held '()))
      (if (null? scan)
          (let ((fact (new List-Factory)))
            (put-sequence~ fact (reverse held))
            fact)
        (let ((current (normalize-action (car scan))))
          (if (null? held)
              (iter (cdr scan) (cons current held))
            (iter (cdr scan) (or (coalesce-action current held)
                                 (simplify-action current held)
                                 (cons current held))))))))
  
  
  (method (coalesce-actions recording)
    recording
    @buggy-with-translate-key
    (let* ((fact (new List-Factory))
           (result #f)
           (coalesce
            (lambda ()
              (when result
                (let ((handler {Event-Handler :focus on-insert})
                      (event (make-event Event :string self content: result)))
                  (put~ fact (cons handler event))
                  (set! result #f))))))
      (for-each (lambda (action)
                  (bind (action/handler . event) action
                    (if (and (eq? (get-target-name action/handler) :focus)
                             (eq? (get-action/method-name action/handler) 'on-insert))
                        (let ((added (string (get-property~ event content:))))
                          (if (not result)
                              (set! result added)
                            (set! result (string-append result added))))
                      (coalesce)
                      (put~ fact action))))
                (get-output~ recording))
      (coalesce)
      fact))
  
  
  ;;;
  ;;;; Condense
  ;;;
  
  
  (method (condense-events recording)
    (define (condense-kind kind)
      (case kind
        ((:mouse-enter) :enter)
        ((:mouse-down) :down)
        ((:mouse-up) :up)
        ((:mouse-leave) :leave)
        (else kind)))
    
    (let ((fact (new List-Factory)))
      (for-each (lambda (action)
                  (bind (where . event) action
                    (let ((kind (condense-kind (get-kind~ event)))
                          (modifiers (get-modifiers~ event)))
                      (put~ fact
                        (if (not where)
                            `(,kind ,(get-property~ event content:) ,@(modifiers->keys modifiers))
                          (let ((host (car where))
                                (view (cadr where))
                                (position (get-property~ event position:)))
                            `(,kind ,host ,view ,@(if position (list position) '()) ,@(modifiers->keys modifiers))))))))
                (get-output~ recording))
      fact))
  
  
  ;;;
  ;;;; Present
  ;;;
  
  
  (method (present-recording actions)
    (let* ((focus (get-focus))
           (output (open-output-string)))
      (loop (for action in actions)
            (for first? first #t then #f)
            (do (bind (action/handler . event) action
                  (if (pair? action/handler)
                      (format output "{?:{%}~}{l} {a}"
                        (not first?)
                        action/handler
                        event)
                    (format output "{?:{%}~}{a} {a} {a}"
                      (not first?)
                      (get-target-name action/handler)
                      (get-action/method-name action/handler)
                      event)))))
      (message-box (get-output-string output)
        title: "Recording")))
  
  
  (method (output-recording actions)
    (let ((text (get-focus)))
      (if (is-not? text Text-View)
          (bell)
        (let ((model (get-model~ text)))
          (with-atomic-undo~ (get-undoer~ model)
            (lambda ()
              (loop (for first? first #t then #f)
                    (for action in actions)
                    (do (unless first?
                          (insert-newline~ text))
                        (insert-string~ text (->string action :reader))
                      (unless first?
                        (tabulate~ text))))))))))
  
  
  ;;;
  ;;;; Patch
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...
  
  
  (definition (get-target-name action/handler)
    (typecase action/handler
      ((Action) (get-target-name~ action/handler))
      (else (get-target-name~ action/handler))))
  
  
  (definition (get-action/method-name action/handler)
    (typecase action/handler
      ((Action) (get-action-name~ action/handler))
      (else (get-method-name~ action/handler))))
  
  
  ;;;
  ;;;; Recording
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...

  
  (method public (record action/handler event)
    (unless (or (eq? (get-target-name action/handler) :recorder)
                ;; quick fix that needs to be thought out as it will make any extended command non-recordable amongst other things
                (memq? (get-action/method-name action/handler) '(on-start-recording on-command-extended)))
      (put~ Recording-Factory (cons action/handler event))))
  
  
  (method public (register-recording name recording)
    (table-set! Registered-Recordings name recording))
  
  
  (method public (get-recording name)
    (or (table-ref Registered-Recordings name #f)
        (begin
          (message-box (format "No recording {a} registered" name))
          (signal-cancel))))
    
  
  ;;;
  ;;;; Playback
  ;;;
  
  
  (method public (get-current-recording)
    (get-output~ Recording-Factory))
  
  
  (method public (play-current-recording)
    (if (not Active-Recording)
        (let ((profile (get-profile~ (get-application))))
          (unless (play-recording~ profile)
            (play-recording (get-output~ Recording-Factory))))
      (play-recording (get-recording Active-Recording))))


  (method public (play-recording recording)
    (if (not recording?)
        (case (effective-recording-level)
          ((event)
           (play-events recording))
          (else
           (let ((old playing?))
             (unwind-protect
                 (begin
                   (set! playing? #t)
                   (let ((focus (get-focus)))
                     (if (is? focus Text-View)
                         (let ((model (get-model~ focus)))
                           (with-atomic-undo~ (get-undoer~ model)
                             (lambda ()
                               (for-each play-action recording)
                               (end-completion~ focus))))
                       (for-each play-action recording))))
               (set! playing? old)))))
      (error "You cannot play a recording while another is being recorded")))
  
  
  (method public (find-target target)
    (process-alias~ (get-process) target))))
