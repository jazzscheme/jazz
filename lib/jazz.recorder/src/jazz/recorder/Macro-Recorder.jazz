;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Macro Recording
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.recorder.Macro-Recorder jazz


(import (jazz.library)
        (jazz.recorder)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view))


(definition public Recording-Factory
  (new List-Factory))

(definition public Registered-Recordings
  (make-table test: eqv?))

(definition public Active-Recording
  #f)


(class Macro-Recorder extends Object
  
  
  (slot recording? initialize #f getter generate)
  (slot playing?   initialize #f getter generate)
  (slot hooked?    initialize #f getter generate)
  
  
  (slot mouse-enter initialize #f)
  
  
  ;;;
  ;;;; Hooks
  ;;;
  
  
  ;; Todo
  ;; - identify consoles in console manager
  ;; - identify menus in menubar
  ;; - fix delay-event sleep 0.5 hack
  ;;
  ;; Host
  ;; - :menubar
  ;; - :toolbar
  ;; - :status-bar
  ;; - :docked name
  ;; - :frame
  
  
  (method (event-hook object event)
    (define (identify)
      (cond ((enumerator? object)
             (list object))
            ((is? object View)
             (identify-view object))
            (else
             #f)))
    
    (define (identify-view view)
      (let ((host (get-host~ object)))
        (when host
          (let ((host-identifier (identify-host host)))
            (if host-identifier
                (let ((view-identifier (identify-in host view)))
                  (if view-identifier
                      (cons host-identifier view-identifier)
                    (let ((guest (get-guest~ host)))
                      (when guest
                        (let ((view-identifier (identify-in guest view)))
                          (if view-identifier
                              (append host-identifier (cons :guest view-identifier))
                            (unidentifiable guest view)
                            #f))))))
              (unidentifiable 'host host)
              #f)))))
    
    (define (identify-host host)
      (let ((appl (get-application))
            (guest (get-guest~ host)))
        (cond ((eq? guest (find-menubar~ appl)) (list :menubar))
              ((eq? guest (find-toolbar~ appl)) (list :toolbar))
              ((eq? guest (find-status-bar~ appl)) (list :status-bar))
              ((eq? host (current-frame)) (list :frame))
              ((singleton-docked-name host) => (lambda (name) (list :docked name)))
              (else #f))))
    
    (define (identify-in in view)
      (if (eq? view in)
          (list)
        (identify-component~ in view)))
    
    (define (unidentifiable . rest)
      @debug
      (apply debug 'unidentifiable rest))
    
    (when (and recording? (eq? (effective-recording-level) 'event))
      (let ((identifier (identify)))
        (when identifier
          (user-message "{s} {s}" identifier event)
          (let ((action (cons identifier event)))
            (case (get-kind~ event)
              ((:mouse-enter)
               (set! mouse-enter (cons object action)))
              ((:mouse-leave)
               (if (and mouse-enter (eq? object (car mouse-enter)))
                   (set! mouse-enter #f)
                 (put~ Recording-Factory action)))
              (else
               (when mouse-enter
                 (put~ Recording-Factory (cdr mouse-enter))
                 (set! mouse-enter #f))
               (put~ Recording-Factory action))))))))
  
  
  (method (action-hook action/handler event)
    (when (and recording? (eq? (effective-recording-level) 'action))
      (record action/handler event)))
    
  
  ;;;
  ;;;; Events
  ;;;

  
  (method (on-start-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)
      (set! mouse-enter #f)
      (set! Recording-Factory (new List-Factory))
      (when (not hooked?)
        (register-event-hook event-hook)
        (register-action-hook action-hook)
        (set! hooked? #t))))
  
  
  (method (on-stop-recording evt)
    (when recording?
      (user-message "Stopped")
      (set! recording? #f)
      (set! mouse-enter #f)
      @buggy-with-translate-key
      (set! Recording-Factory (coalesce-actions (get-output~ Recording-Factory)))
      (set! Active-Recording #f)
      ;; this doesn't work yet because getting method value twice doesn't return eq? objects
      @wait (
      (unregister-event-hook event-hook)
      (unregister-action-hook action-hook))))

  
  (method (on-resume-recording evt)
    (when (not recording?)
      (user-message "Recording...")
      (set! recording? #t)))
  
  
  (method (on-play-recording evt)
    (if (not recording?)
        (begin
          (user-message "Playing...")
          (let ((no (get-property~ evt no:)))
            (if (not no)
                (play-current-recording)
              (play-recording (get-recording no))))
          (user-message "Done"))
      (error "You cannot play while a recording is in progress")))
  
  
  (method (on-output-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (output-recording actions))))
  
  
  (method (on-present-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (present-recording actions))))
  
  
  (method (on-register-recording evt)
    (let ((no (parse-integer (request-string title: "Register Recording (1 to 5)" prefix: "No:" initial-value: "1"))))
      (assert (between? no 1 5))
      (let ((recording (get-output~ Recording-Factory)))
        (register-recording no recording)
        (user-message "Recording {a} registered" no))))
  
  
  (method (on-set-active-recording evt)
    (let ((name (request-string title: "Enter Recording Name" prefix: "Name:")))
      (if (not name)
          (begin
            (set! Active-Recording #f)
            (user-message "Active recording reset to default"))
        (let ((no (read-string-element name)))
          (get-recording no)
          (set! Active-Recording no)
          (user-message "Active recording set to {a}" no)))))
  
  
  @buggy-with-translate-key
  (method (coalesce-actions actions)
    (let* ((fact (new List-Factory))
           (result #f)
           (coalesce
            (lambda ()
              (when result
                (let ((handler {Event-Handler :focus on-insert})
                      (event (make-event Event :string self content: result)))
                  (put~ fact (cons handler event))
                  (set! result #f))))))
      (for-each (lambda (action)
                  (bind (action/handler . event) action
                    (if (and (eq? (get-target-name action/handler) :focus)
                             (eq? (get-action/method-name action/handler) 'on-insert))
                        (let ((added (string (get-property~ event content:))))
                          (if (not result)
                              (set! result added)
                            (set! result (string-append result added))))
                      (coalesce)
                      (put~ fact action))))
                actions)
      (coalesce)
      fact))
  
  
  (method (present-recording actions)
    (let* ((focus (get-focus))
           (output (open-output-string))
           (targets (remove-duplicates (map get-target-name (map car actions)))))
      (loop (for action in actions)
            (for first? first #t then #f)
            (do (bind (action/handler . event) action
                  (format output "{?:{%}~}{a} {a} {a}"
                          (not first?)
                          (get-target-name action/handler)
                          (get-action/method-name action/handler)
                          event))))
      (message-box (get-output-string output)
        title: "Recording")))
  
  
  (method (output-recording actions)
    (let ((text (get-focus)))
      (if (is-not? text Text-View)
          (bell)
        (let ((model (get-model~ text)))
          (with-atomic-undo~ (get-undoer~ model)
            (lambda ()
              (insert-char~ text #\open-parenthesis)
              (loop (for first? first #t then #f)
                    (for action in actions)
                    (do (unless first?
                          (insert-newline~ text))
                        (insert-string~ text (->string action :reader))
                      (unless first?
                        (tabulate~ text))))
              (insert-char~ text #\close-parenthesis)))))))
  
  
  (method (target-name target)
    (if (eq? target :application)
        'appl
      (keyword->symbol target)))
  
  
  ;;;
  ;;;; Patch
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...
  
  
  (definition (get-target-name action/handler)
    (typecase action/handler
      ((Action) (get-target-name~ action/handler))
      (else (get-target-name~ action/handler))))
  
  
  (definition (get-action/method-name action/handler)
    (typecase action/handler
      ((Action) (get-action-name~ action/handler))
      (else (get-method-name~ action/handler))))
  
  
  ;;;
  ;;;; Recording
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...

  
  (method public (record action/handler event)
    (unless (or (eq? (get-target-name action/handler) :recorder)
                ;; quick fix that needs to be thought out as it will make any extended command non-recordable amongst other things
                (memq? (get-action/method-name action/handler) '(on-start-recording on-command-extended)))
      (put~ Recording-Factory (cons action/handler event))))
  
  
  (method public (register-recording name recording)
    (table-set! Registered-Recordings name recording))
  
  
  (method public (get-recording name)
    (or (table-ref Registered-Recordings name #f)
        (begin
          (message-box (format "No recording {a} registered" name))
          (signal-cancel))))
    
  
  ;;;
  ;;;; Playback
  ;;;
  
  
  (method public (get-current-recording)
    (get-output~ Recording-Factory))
  
  
  (method public (play-current-recording)
    (if (not Active-Recording)
        (let ((profile (get-profile~ (get-application))))
          (unless (play-recording~ profile)
            (play-recording (get-output~ Recording-Factory))))
      (play-recording (get-recording Active-Recording))))


  (method public (play-recording recording)
    (if (not recording?)
        (let ((old playing?))
          (unwind-protect
              (begin
                (set! playing? #t)
                (let ((focus (get-focus)))
                  (if (is? focus Text-View)
                      (let ((model (get-model~ focus)))
                        (with-atomic-undo~ (get-undoer~ model)
                          (lambda ()
                            (for-each play-action recording)
                            (end-completion~ focus))))
                    (for-each play-action recording))))
            (set! playing? old)))
      (error "You cannot play while a recording is in progress")))
  
  
  (method public (find-target target)
    (process-alias~ (get-process) target))))
