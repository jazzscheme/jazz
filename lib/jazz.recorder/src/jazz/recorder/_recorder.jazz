;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Recorder
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2012
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.recorder jazz


(export (jazz.recorder.autoload))
(import (jazz.recorder.autoload)
        (jazz.library)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window))


;;;
;;;; Level
;;;


(definition Recording-Level
  #f)


(definition public (get-recording-level)
  Recording-Level)

(definition public (set-recording-level level)
  (set! Recording-Level level))


(definition protected (effective-recording-level)
  (or Recording-Level 'action))


(definition Recording-Feedback?
  #f)


(definition public (get-recording-feedback?)
  Recording-Feedback?)

(definition public (set-recording-feedback? feedback?)
  (set! Recording-Feedback? feedback?))


(definition Recording-Slowdown
  #f)


(definition public (get-recording-slowdown)
  Recording-Slowdown)

(definition public (set-recording-slowdown slowdown)
  (set! Recording-Slowdown slowdown))


(definition protected Accessed-Mouse-Events
  (make-table test: eq? weak-keys: #t))


(definition protected (accessed-event? event)
  (table-ref Accessed-Mouse-Events event #f))

(definition protected (unaccessed-event? event)
  (not (table-ref Accessed-Mouse-Events event #f)))


;;;
;;;; Event
;;;


(definition public (play-script proc (catcher: catcher #f) (feedback?: feedback? (get-recording-feedback?)) (slowdown: slowdown (get-recording-slowdown)))
  (let ((debug? #f)
        (catch? #t)
        (first-feedback? #t)
        (error-occurred? #f))
    (define (play action)
      (define (feedback)
        (when feedback?
          (if first-feedback?
              (set! first-feedback? #f)
            (bind (kind . rest) action
              (let ((host (and (pair? rest) (car rest))))
                (unless (eq? host :unidentifiable)
                  (update-window~
                    (case host
                      ((:modal) (get-player~ (current-modal)))
                      ((:popup) (get-player~ (current-popup)))
                      (else (get-toplevel))))
                  (when slowdown
                    (sleep slowdown))))))))
      
      (define (simulate-mouse root pos)
        (when feedback?
          (set-mouse-position~ (get-player~ root) pos)))
      
      (unless error-occurred?
        (block-event
          (lambda ()
            (unless error-occurred?
              (with-exception-filter
                (lambda (exc)
                  (if (or (not catch?)
                          (and (object? exc)
                               (is? exc Signal)))
                      #f
                    (set! error-occurred? #t)
                    #t))
                (lambda (exc)
                  (if catcher
                      (catcher exc)
                    #f))
                (lambda ()
                  (if (procedure? action)
                      (action)
                    (when debug?
                      (debug action))
                    (feedback)
                    (play-event action feedback simulate-mouse)))))))))
    
    (proc play)))


(definition public (play-events actions . rest)
  (apply play-script
         (lambda (play)
           (for-each play actions))
         rest))


(definition (play-event action feedback simulate-mouse)
  (bind (kind . rest) action
    (define (play-action-event)
      (bind (target-name method-name . rest) rest
        (parse-event-modifiers rest
          (lambda (modifiers properties)
            (let ((handler (new Event-Handler target-name: target-name method-name: method-name))
                  (event (apply new Action-Event :action #f (modifiers->mask modifiers) properties)))
              (play-action (cons handler event)))))))
    
    (define (play-char)
      (bind (content . modifiers) rest
        (let ((shortcut (new Shortcut modifiers content)))
          (or (dispatch-shortcut~ (get-application) shortcut)
              (assert (char? content)
                (play-key content))))))
    
    (define (play-string)
      (let ((content (car rest)))
        (iterate content play-key)))
    
    (define (play-key key)
      (dispatch-key-press~ (get-focus) key))
    
    (define (play-mouse event-kind proc)
      (define (parse)
        (bind (host-locator view-locator . rest) rest
          (if (and (pair? rest)
                   (is? (car rest) Point))
              (values host-locator view-locator (car rest) (cdr rest))
            (values host-locator view-locator #f rest))))
      
      (receive (host-locator view-locator position modifiers) (parse)
        (define (locate-host)
          (if (pair? host-locator)
              (case (car host-locator)
                ((:docked) (singleton-docked-named (cdr host-locator)))
                (else #f))
            (case host-locator
              ((:modal) (current-modal))
              ((:popup) (current-popup))
              ((:menubar) (find-menubar~ (get-application)))
              ((:toolbar) (find-toolbar~ (get-application)))
              ((:statusbar) (find-status-bar~ (get-application)))
              ((:frame) (current-frame))
              (else #f))))
        
        (define (play host path)
          (assert host)
          (if (and (pair? path) (eq? (car path) :host))
              (play-in host (cdr path))
            (let ((guest (get-guest~ host)))
              (assert guest)
              (play-in guest path))))
        
        (define (play-in in path)
          (assert in)
          (let ((view (if (null? path)
                          in
                        (or (locate-component~ in path)
                            (find-component~ in path)))))
            (if (not view)
                (error "Unable to find '{s} in: {s}" path in)
              (play-root view))))
        
        (define (play-root view)
          (let ((root (get-root~ view)))
            (assert root)
            (if (not position)
                (begin
                  (simulate-mouse root (acquire~ root view {Point 10 10}))
                  (proc root view (new Mouse-Event event-kind #f (modifiers->mask modifiers))))
              (let ((acquired (acquire~ root view position)))
                (simulate-mouse root acquired)
                (proc root view (new Mouse-Event event-kind #f (modifiers->mask modifiers) position: position))))))
        
        (unless (eq? host-locator :unidentifiable)
          (let ((host (locate-host)))
            (if host
                (play host view-locator)
              (error "Unknown host: {s}" host-locator))))))
    
    (define (play-enter view)
      (dispatch-mouse-enter~ view)
      (set-mouse-in view))
    
    (define (play-click event-kind proc)
      (play-mouse event-kind
        (lambda (root view event)
          (let ((mouse-in (get-mouse-in)))
            (if (eq? mouse-in view)
                (proc root view event)
              (when mouse-in
                (play-leave mouse-in))
              (play-enter view)
              (feedback)
              (set-mouse-in view)
              (proc root view event))))))
    
    (define (play-leave view)
      (dispatch-mouse-leave~ view))
    
    (define (dispatch-click root view event)
      (dispatch-mouse-down~ root view event)
      (dispatch-mouse-up~ root view event))
    
    (define (play-menubar)
      (bind (path . modifiers) rest
        (debug path)))
    
    (case kind
      ((:action)       (play-action-event))
      ((:char)         (play-char))
      ((:string)       (play-string))
      ((:enter)        (play-mouse :mouse-enter  (lambda (root view event) (play-enter view))))
      ((:leave)        (play-mouse :mouse-leave  (lambda (root view event) (play-leave view))))
      ((:down)         (play-click :mouse-down   (lambda (root view event) (dispatch-mouse-down~ root view event))))
      ((:up)           (play-click :mouse-up     (lambda (root view event) (dispatch-mouse-up~ root view event))))
      ((:click)        (play-click :mouse-click  (lambda (root view event) (dispatch-click root view event))))
      ((:double-click) (play-click :double-click (lambda (root view event) (dispatch-double-click~ root view event))))
      ((:context-menu) (play-click :context-menu (lambda (root view event) (dispatch-context-menu~ root view event))))
      ((:menubar)      (play-menubar))
      (else            (error "Unknown event kind: {s}" kind)))))


;;;
;;;; Action
;;;


(definition public (play-action action)
  (bind (action/handler . event) action
    (typecase action/handler
      ((Action)
       (call-action action/handler #f '() event: event))
      (else
       (let ((target (get-focus)))
         (invoke~ action/handler target event)))))))
