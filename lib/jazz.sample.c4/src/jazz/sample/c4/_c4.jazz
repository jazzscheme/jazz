;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; C4
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.sample.c4 jazz


(export (jazz.sample.c4.autoload))

(import (jazz.io)
        (jazz.sample.game))


(definition package EMPTY <fx>
  0)

(definition package RED <fx>
  -1)

(definition package GREEN <fx>
  1)


(definition package Search-Depth
  5)


;;;
;;;; Player
;;;


(class C4-Player extends Player
  
  
  (slot game     getter generate)
  (slot me       getter generate)
  (slot opponent getter generate)
  
  
  (method (initialize game me)
    (nextmethod)
    (set! game~self game)
    (set! me~self me)
    (set! opponent~self (* me -1)))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function (printer)
        (format printer "{a}" me))))
  
  
  (method (present)
    (if (eq? me GREEN)
        "Green"
      "Red")))


;;;
;;;; Human
;;;


(class C4-Human extends C4-Player
  
  
  (method (player-kind)
    'human))


;;;
;;;; Square
;;;


(class Square extends Object
  
  
  (slot game            getter generate)
  (slot row   <fx>      getter generate)
  (slot col   <fx>      getter generate)
  (slot token <fx>      accessors generate)
  (slot up    <Square+> accessors generate)
  (slot down  <Square+> accessors generate)
  (slot lines <list>    accessors generate)
  
  
  (method (initialize game row col)
    (nextmethod)
    (set! game~self game)
    (set! row~self row)
    (set! col~self col)
    (set! token~self EMPTY))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function (printer)
        (format printer "{a} {a}" (present-move game self) token)))))


(definition package (present-row game row)
  (->string (- (get-board-rows~ game) row)))


(definition package (present-col game col)
  (->string (element Uppercase-Chars col)))


(definition package (present-move game move)
  (let ((row (get-row~ move))
        (col (get-col~ move)))
    (format "{a}{a}"
            (present-col game col)
            (present-row game row))))


;;;
;;;; Line
;;;


(class Line extends Object
  
  
  (slot first  <Square> getter generate)
  (slot second <Square> getter generate)
  (slot third  <Square> getter generate)
  (slot fourth <Square> getter generate)
  
  
  (method (initialize first second third fourth)
    (nextmethod)
    (set! first~self first)
    (set! second~self second)
    (set! third~self third)
    (set! fourth~self fourth))
  
  
  (method (count-token token <fx>) <fx>
    (+ (if (= (get-token~ first) token) 1 0)
       (if (= (get-token~ second) token) 1 0)
       (if (= (get-token~ third) token) 1 0)
       (if (= (get-token~ fourth) token) 1 0))))


(definition package (line=? l1 l2)
  (and (eq? (get-first~ l1) (get-first~ l2))
       (eq? (get-second~ l1) (get-second~ l2))
       (eq? (get-third~ l1) (get-third~ l2))
       (eq? (get-fourth~ l1) (get-fourth~ l2))))


;;;
;;;; Game
;;;


(class C4-Game extends Game
  
  
  ;; board
  (slot board-rows       initialize #f accessors generate)
  (slot board-columns    initialize #f accessors generate)
  (slot board-size       initialize #f accessors generate)
  (slot board            initialize #f accessors generate)
  
  ;; play
  (slot available-moves  initialize #f accessors generate)

  
  (method (initialize . rest)
    (bind-keywords ((rows 6) (columns 7)) rest
      (nextmethod)
      (set! board-rows rows)
      (set! board-columns columns)
      (set! board-size (* board-rows board-columns))
      (set! board (make-board))
      (set! available-moves (make-availables))
      (setup-squares)
      (setup-lines)))
  
  
  (method (make-board)
    (let ((board (make-vector board-size #f)))
      (loop (for row from 0 below board-rows)
            (loop (for col from 0 below board-columns)
                  (let ((rank (square-rank row col)))
                    (vector-set! board rank (new Square self row col)))))
      board))
  
  
  (method (make-availables)
    (let ((moves (make-vector board-columns #f))
          (bottom-row (- board-rows 1)))
      (loop (for col from 0 below board-columns)
            (vector-set! moves col (get-square bottom-row col)))
      moves))
  
  
  (method (setup-squares)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (let ((square (get-square row col)))
                  (set-up~ square (find-square (- row 1) col))
                  (set-down~ square (find-square (+ row 1) col))))))
  
  
  ;;;
  ;;;; Lines
  ;;;
  
  
  (definition directions
    '((0 . 1)
      (1 . 1)
      (1 . 0)
      (1 . -1)))
  
  
  (method (setup-lines)
    (loop (for rank from 0 below board-size)
          (let ((square (board-ref rank)))
            (set-lines~ square (compute-lines square)))))
  
  
  (method (compute-lines square)
    (let ((row (get-row~ square))
          (col (get-col~ square))
          (lines '()))
      (loop (for dir in directions)
            (loop (for n from -3 to 0)
                  (let ((a (find-next dir row col (+ n 0)))
                        (b (find-next dir row col (+ n 1)))
                        (c (find-next dir row col (+ n 2)))
                        (d (find-next dir row col (+ n 3))))
                    (if (and a b c d)
                        (set! lines (cons (new Line a b c d) lines))))))
      lines))
  
  
  (method (find-next dir row col n)
    (find-square
      (+ row (* n (car dir)))
      (+ col (* n (cdr dir)))))
  
  
  ;;;
  ;;;; Board
  ;;;
  
  
  (method public (iterate-board proc)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (do (proc (get-square row col))))))
  
  
  (method inline (board-ref rank) <Square>
    (vector-ref board rank))
  
  
  (method inline (square-rank row col) <fx>
    (+ (* row board-columns) col))
  
  
  (method inline (get-square row col) <Square>
    (board-ref (square-rank row col)))
  
  
  (method (find-square row col) <Square+>
    (if (and (>= row 0) (< row board-rows)
             (>= col 0) (< col board-columns))
        (get-square row col)
      #f))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method inline (available-move col) <Square>
    (vector-ref available-moves col))
  
  
  (method inline (set-available-move col square) <void>
    (vector-set! available-moves col square))
  
  
  (method (play move token)
    (set-token~ move token)
    (set-available-move (get-col~ move) (get-up~ move)))
  
  
  (method (unplay move)
    (set-available-move (get-col~ move) move)
    (set-token~ move EMPTY))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method (play-move move)
    (let ((player (next-player!)))
      (let ((token (get-me~ player)))
        (play move token)
        (add-move move)
        (inform-players move token)
        (check-status player move token))))
  
  
  (method (win? move token)
    (define (line? line)
      (= (count-token~ line token) 4))
    
    (some? line? (get-lines~ move)))
  
  
  (method (draw? move token)
    (not (loop (for col from 0 below board-columns)
               (some (available-move col)))))
  
  
  ;;;
  ;;;; I/O
  ;;;
  
  
  @wait
  (method (load-board game)
    (initialize-game game HUMAN)
    (loop (for tokens in saved-board)
          (for col from 0 below board-columns)
          (loop (for token in tokens)
                (for row from (- board-rows 1) downto 0)
                (let ((square (get-square row col)))
                  (set-token~ square
                    (case token
                      ((X) HUMAN)
                      ((O) COMPUTER)))))
          (let ((move (- board-rows (length tokens) 1)))
            (set-available-move col (if (>= move 0) (get-square move col) #f))))
    (invalidate-view~ game))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (inspect-board)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (let ((token (get-token~ (get-square row col))))
                  (display (cond ((eq? token EMPTY) ".")
                                 ((eq? token RED) "X")
                                 ((eq? token GREEN) "O")))
                  (display " ")))
          (newline)))))
