;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Library
;;;


;; Todo
;; - sourcification of
;;   - loop by clause
;;   - tie construct and time
;;   - c-definition
;;   - slot initialize field
;;   - generic and specific
;;   - type specifiers (?)
;; Gambit sourcification of
;;   - cond-expand
;;   - receive


(library jazz.sample.library jazz


(import (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.sample.lib)
        (jazz.utilities))


@commented-to-test-unresolved-symbols
(begin
  (define x {})
  (define y {})
  (define z {})
  (define v {})
  (define w {}))


;;;
;;;; Declare
;;;


(declare (standard-bindings)
         (extended-bindings))


(proclaim (warn optimizations))


;;;
;;;; Cond-Expand
;;;


(cond-expand
  (gambit
    (define (gamb)
      x))
  (chicken
    (define (chic)
      x))
  (else
    (define (sche)
      x)))


;;;
;;;; Syntax
;;;


(define-macro (defmac)
  x)


@todo
(define-special-form (defspe)
  x)


(macro (mac . rest)
  x)


(syntax (syn form)
  x)


;;;
;;;; Definition
;;;


(native nat)


(define (def)
  (define (i)
    x)
  y)


(definition (defin)
  x)


;;;
;;;; Reader
;;;


(define (literals)
  '(2
    2.3
    +2
    -3
    5L
    #b1101
    #x0A
    #f
    #t
    #\a
    #(a b c)
    (a b c)
    a
    :a
    a:
    "a"
    #"a"#
    {Point 2 3}))


(define (comments)
  x ;; a
  @comment a x)


(define (functional-syntax)
  x
  (x y)
  (((x) y) z))


(define (specifier-syntax a <fx>)
  (let ((b <fx> x))
    y))


;;;
;;;; Syntaxes
;;;


(define (binding)
  (let ((a x))
    (let* ((a x))
      (letrec ((a x))
        (receive (a) x
          y))))
  (parameterize ((x y))
    z)
  (with ((a x))
    (with-closed ((a x))
      y))
  (bind (a) x
    (bind-optionals ((a x)) y
      (bind-keywords ((a x)) y
        z))))


(define (functional)
  (lambda (a)
    x)
  (function (a)
    x))


(define (quotation)
  'a
  (quote a)
  `(a ,x)
  `(a ,@y)
  (quasiquote (a (unquote x)))
  (quasiquote (a (unquote-splicing y))))


(define (logical)
  (and x)
  (or x)
  (essay x)
  (either x))


(define (conditional)
  (if x
      y
    z)
  (when x
    y)
  (unless x
    y)
  (cond (x y)
        (else z))
  (case x
    ((a) y)
    (else z))
  (ecase x
    ((y) z)
    (else v))
  (typecase x
    ((y) z)
    (else v)))


(define (control)
  (begin
    x)
  (prog1 x
    y)
  (catch x
    y)
  (unwind-protect
      x
    y)
  (delay x)
  (do ((a x))
      (y z)
    v)
  (while x
    y))


(define (assertion)
  (assert x)
  @todo
  (assert-type x y)
  @todo
  (error-occurred? x))


(define (iteration)
  (loop (for a from x to y by z)
        (collect v)
        (do w)))


(define (assignment)
  (set! x 1)
  (increase! x 2)
  (decrease! x 3)
  (let ((a 0))
    (set! a x)
    (increase! a x)
    (decrease! a x)))


(define (other)
  (tie "{x}")
  (construct x y)
  (time x))


;;;
;;;; Types
;;;


@need-to-fix-conflicts
(specialize inline (= s1 <symbol> s2 <symbol>) <bool>
  (eq? s1 s2))


@todo
(define (t)
  (cast x y))


;;;
;;;; Foreign
;;;


(c-constant cconst
  x)


(c-enumeration cenum
  (AA #x01)
  (BB #x02))


;; @needs-to-be-compiled
(c-include "<stdlib.h>")


;; @needs-to-be-compiled
(c-initialize #<<end-of-c-code
N = 2;
end-of-c-code
)


;; @needs-to-be-compiled
(c-type cbool (native bool))
;; @needs-to-be-compiled
(c-type cuint (native unsigned-int))


;; @needs-to-be-compiled
(c-structure cstruct
  (cuint a))


;; @needs-to-be-compiled
(c-external cbool (cext) "JzE")


;; @needs-to-be-compiled
(definition cfunc
  (c-function (cuint) cbool
    "___result_voidstar = WindowFromPoint(*___arg1);"))


;; @needs-to-be-compiled
(c-definition (cdef a b) (cbool cuint) cuint "someproc" "static"
  (x a b))


;; @needs-to-be-compiled
(c-declare #<<end-of-c-code
...some c code...
end-of-c-code
)


;; @needs-to-be-compiled
(c-named-declare name
#<<end-of-c-code
...some c code...
end-of-c-code
)


;;;
;;;; Remoting
;;;


(remotable-stub S
  
  
  (method public call value (get-value))
  (method public call (call a))
  (method public exec (exec a))
  (method public post (post a)))


;;;
;;;; Runtime
;;;


(define (runtime-errors)
  (let ((obj (new Object)))
    (a~ obj)))


;;;
;;;; Interface
;;;


(interface I
  
  
  (method public virtual abstract (i)))


;;;
;;;; Class
;;;


(class A extends Object
  
  
  (method (initialize)
    (nextmethod)
    x)
  
  
  (method (j)
    x)
  
  
  (method virtual (virt a)
    x))


(class B extends A implements I
  
  
  (method meta (cls)
    x)
  
  
  (slot private slt initialize x)
  
  
  (define def
    x)
  
  
  (definition defin
    x)
  
  
  (method (initialize)
    (nextmethod x)
    y)
  
  
  @todo
  (method public inline (inl)
    x)
  
  
  (method chained (chain)
    x)
  
  
  (method synchronized (sync)
    x)
  
  
  (method (i)
    x)
  
  
  (method (virt a)
    (nextmethod x)
    y)
  
  
  (method (object-syntax)
    self
    (a~ x y)
    (~ a x)))


;;;
;;;; Component
;;;


(class C extends Component
  
  
  (property protected p initialize x accessors generate)
  
  
  (form
    (<install> p: a)))


(class D extends C
  
  
  (property protected q initialize x accessors generate)
  
  
  (form
    (<install> p: b q: c)))


(class E extends Component
  
  
  (property protected r initialize x accessors generate)
  
  
  (form
    (<install>       r: 1
      (<C>           p: 2)
      (<C>   name: c p: 3
        (<D> name: d q: 5)))))


;; component inheritance
(class F extends E
  
  
  (form
    (<install>         r: 2
      (<!>     name: c p: 4
        (<!>   name: d q: 6
          (<D>         p: 7))))))


;; component composition
(class G extends Component
  
  
  (form
    (<install>
      (<E>               r: 3
        (<!>     name: c p: 4
          (<!>   name: d q: 6
            (<D>         p: 7)))))))


;;;
;;;; Generic
;;;


(class K extends Object)
(class L extends K)


(generic (g (<K> k) a))

(specific (g (<K> k) a)
  x)

(specific (g (<L> l) a)
  x)


(generic (h (<K> k) a)
  x)

(specific (h (<L> l) a)
  x))
