;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; GStreamer Foreign
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.stream.foreign jazz


(require (jazz.stream.setup))

(import (jazz.foreign)
        (jazz.listener)
        (jazz.platform.types)
        (jazz.stream.header)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax)))


;;;
;;;; Trace
;;;


(define-setting trace-gst?
  #f)

(define-setting trace-gst
  (lambda (name rest)
    (unless (memq? name '(gst_app_sink_try_pull_buffer gst_app_sink_try_pull_frame gst_app_src_write gst_element_get_running_time move-u8vector->pointer!))
      (let ((port (console-port)))
        (define (present obj)
          (cond ((u8vector? obj)
                 (display (list 'u8vector (u8vector-length obj)) port))
                ((foreign? obj)
                 (let ((tags (foreign-tags obj)))
                   (cond ((equal? tags '(GstElement*))
                          (format port "#<{a}*"
                            (g_object_class_name obj))
                          (present-path obj)
                          (format port " #{a} 0x{x}>"
                            (object->serial obj)
                            (foreign-address obj)))
                         (else
                          (write obj port)))))
                (else
                 (write obj port))))
        
        (define (present-path elem)
          (let (loop (elem elem))
            (let ((parent (gst_element_get_parent_untraced elem)))
              (when parent
                (loop parent))
              (display " " port)
              (display (gst_object_get_name_untraced elem) port))))
        
        (display name port)
        (case name
          ((gst_element_set_state_threaded)
           (bind (elem state) rest
             (display " " port)
             (present elem)
             (display " " port)
             (display (ecase state
                        ((GST_STATE_NULL) "NULL")
                        ((GST_STATE_READY) "READY")
                        ((GST_STATE_PAUSED) "PAUSED")
                        ((GST_STATE_PLAYING) "PLAYING"))
                      port)))
          (else
           (for-each (lambda (obj)
                       (display " " port)
                       (present obj))
                     rest)))
        (newline port)
        (force-output port)))))


;;;
;;;; GLib
;;;


(c-include "<stdbool.h>")
(c-include "<string.h>")
(c-include "<stdlib.h>")
(c-include "<stdio.h>")
(c-include "<unistd.h>")
(c-include "<fcntl.h>")
(c-include "<glib.h>")
(c-include "<gst/gst.h>")
(c-include "<gst/app/gstappsrc.h>")
(c-include "<gst/app/gstappsink.h>")
(c-include "<gst/pbutils/pbutils.h>")


(c-type gint     int)
(c-type guint    uint)
(c-type gulong   ulong)
(c-type gsize    ulong)
(c-type gboolean gint)
(c-type gpointer void*)
(c-type GType    enum)


(c-type GValue   (native "GValue"))
(c-type GValue*  (pointer "GValue" GValue*))
(c-type GObject  (native "GObject"))
(c-type GObject* (pointer GObject #f))
(c-type GThread  (native "GThread"))
(c-type GThread* (pointer GThread GThread*))
(c-type GList    (native "GList"))
(c-type GList*   (pointer GList GList*))
(c-type GError   (native "GError"))
(c-type GError*  (pointer GError GError*))


(c-declare jazz.stream.foreign #/C/
___SCMOBJ CHARSTRINGFREE_to_SCMOBJ(char *src, ___SCMOBJ *dst, int arg_num)
{
  ___SCMOBJ result;

  result = ___EXT(___CHARSTRING_to_SCMOBJ)(___PSTATE, src, dst, arg_num);

  g_free(src);

  return result;
}

#define ___BEGIN_CFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c,i)___IF_STOC3(___SCMOBJ_to_CHARSTRING,s,&c,i){
#define ___END_CFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c,i)___EXT(___release_string)(c);}

#define ___BEGIN_CFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s)if ((___err = CHARSTRINGFREE_to_SCMOBJ(c, &s, ___RETURN_POS)) == ___FIX(___NO_ERR)){
#define ___END_CFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s)___EXT(___release_scmobj)(s);}

#define ___BEGIN_SFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s,i)if ((___err = CHARSTRINGFREE_to_SCMOBJ(c, &s, ___RETURN_POS)) == ___FIX(___NO_ERR)){
#define ___END_SFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s,i)___EXT(___release_scmobj)(s);}

#define ___BEGIN_SFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c)___STOC3(___SCMOBJ_to_CHARSTRING,s,&c,___RETURN_POS);
#define ___END_SFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c)
//#)

(c-define-type char-string-free
               "char*"
               "CHARSTRINGFREE_TO_SCMOBJ"
               "SCMOBJ_TO_CHARSTRINGFREE"
               #t)


(c-declare jazz.stream.foreign #/C/
static GType g_value_type(GValue* value)
{
    return G_VALUE_TYPE(value);
}

static char* g_value_type_name(GValue* value)
{
    return (char*) G_VALUE_TYPE_NAME(value);
}

static int g_object_get_int(GObject* obj, char* name)
{
    int d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static gint64 g_object_get_int64(GObject* obj, char* name)
{
    gint64 d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static unsigned int g_object_get_uint(GObject* obj, char* name)
{
    unsigned int d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static guint64 g_object_get_uint64(GObject* obj, char* name)
{
    guint64 d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static bool g_object_get_boolean(GObject* obj, char* name)
{
    bool d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static double g_object_get_double(GObject* obj, char* name)
{
    double d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static char* g_object_get_string(GObject* obj, char* name)
{
    char* s;
    g_object_get(obj, name, &s, NULL);
    return s;
}

static gpointer g_object_get_pointer(GObject* obj, char* name)
{
    gpointer p;
    g_object_get(obj, name, &p, NULL);
    return p;
}

static char* g_object_class_name(GObject* obj)
{
    return (char*) G_OBJECT_CLASS_NAME(G_OBJECT_GET_CLASS(obj));
}

static char* g_error_message(GError* error)
{
    return error->message;
}
//#)


(c-external (g_value_new GType) :alloc GValue*
  #/C/
    GValue* value = (GValue*) calloc(sizeof(GValue), 1);
    g_value_init(value, ___arg1);
    ___return(value);
//#)

(c-external (g_value_free GValue*) :free void
  #/C/
    g_value_unset(___arg1);
    free(___arg1);
//#)


(c-external (g_value_get_boolean GValue*) bool)
(c-external (g_value_set_boolean GValue* bool) void)
(c-external (g_value_get_int GValue*) int)
(c-external (g_value_set_int GValue* int) void)
(c-external (g_value_get_uint64 GValue*) uint64)
(c-external (g_value_set_uint64 GValue* uint64) void)
(c-external (g_value_get_double GValue*) double)
(c-external (g_value_set_double GValue* double) void)
(c-external (g_value_get_string GValue*) (cast char-string))
(c-external (g_value_set_string GValue* char-string) void)
(c-external (g_value_type GValue*) GType)
(c-external (g_value_type_name GValue*) char-string)
(c-external (g_list_free GList*) void)
(c-external (g_object_class_name (call G_OBJECT GObject*)) char-string)
(c-external (g_object_get_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_set_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_get_boolean (call G_OBJECT GObject*) char-string) bool "g_object_get_boolean")
(c-external (g_object_set_boolean (call G_OBJECT GObject*) char-string bool NULL) void "g_object_set")
(c-external (g_object_get_int (call G_OBJECT GObject*) char-string) int "g_object_get_int")
(c-external (g_object_set_int (call G_OBJECT GObject*) char-string int NULL) void "g_object_set")
(c-external (g_object_get_int64 (call G_OBJECT GObject*) char-string) int64 "g_object_get_int64")
(c-external (g_object_set_int64 (call G_OBJECT GObject*) char-string int64 NULL) void "g_object_set")
(c-external (g_object_get_uint (call G_OBJECT GObject*) char-string) uint "g_object_get_uint")
(c-external (g_object_set_uint (call G_OBJECT GObject*) char-string uint NULL) void "g_object_set")
(c-external (g_object_get_uint64 (call G_OBJECT GObject*) char-string) uint64 "g_object_get_uint64")
(c-external (g_object_set_uint64 (call G_OBJECT GObject*) char-string uint64 NULL) void "g_object_set")
(c-external (g_object_get_double (call G_OBJECT GObject*) char-string) double "g_object_get_double")
(c-external (g_object_set_double (call G_OBJECT GObject*) char-string double NULL) void "g_object_set")
(c-external (g_object_get_string (call G_OBJECT GObject*) char-string) char-string-free "g_object_get_string")
(c-external (g_object_set_string (call G_OBJECT GObject*) char-string char-string NULL) void "g_object_set")
(c-external (g_object_get_pointer (call G_OBJECT GObject*) char-string) gpointer "g_object_get_pointer")
(c-external (g_object_set_pointer (call G_OBJECT GObject*) char-string gpointer NULL) void "g_object_set")
(c-external (g_signal_emit_by_name gpointer char-string) void)
(c-external (g_signal_handler_disconnect gpointer gulong) void)
(c-external (g_error_message GError*) char-string)
(c-external (G_OBJECT_TYPE (call G_OBJECT GObject*)) uint64)
;; (c-external (G_OBJECT_TYPE_NAME (call G_OBJECT GObject*)) char-string)


;;;
;;;; GStreamer
;;;


(c-enumerant GST_TYPE_DISCOVERER_CONTAINER_INFO)
(c-enumerant GST_TYPE_DISCOVERER_STREAM_INFO)
(c-enumerant GST_TYPE_DISCOVERER_AUDIO_INFO)
(c-enumerant GST_TYPE_DISCOVERER_VIDEO_INFO)


(c-type GstClockTime         uint64)
(c-type GstClockTimeDiff     int64)
(c-type GstStateChangeReturn enum)
(c-type GstState             enum)
(c-type GstFormat            enum)
(c-type GstMessageType       enum)
(c-type GstFlowReturn        enum)
(c-type GstAppStreamType     enum)
(c-type GstSeekFlags         enum)
(c-type GstPadDirection      enum)
(c-type GstPadLinkReturn     enum)
(c-type GstPadMode           enum)


(c-type GstObject                (native "GstObject"))
(c-type GstObject*               (pointer GstObject GstObject*))
(c-type GstElement               (native "GstElement"))
(c-type GstElement*              (pointer GstElement GstElement*))
(c-type GstPad                   (native "GstPad"))
(c-type GstPad*                  (pointer GstPad GstPad*))
(c-type GstCaps                  (native "GstCaps"))
(c-type GstCaps*                 (pointer GstCaps GstCaps*))
(c-type GstCapsFeatures          (native "GstCapsFeatures"))
(c-type GstCapsFeatures*         (pointer GstCapsFeatures GstCapsFeatures*))
(c-type GstStructure             (native "GstStructure"))
(c-type GstStructure*            (pointer GstStructure GstStructure*))
(c-type GstBuffer                (native "GstBuffer"))
(c-type GstBuffer*               (pointer GstBuffer GstBuffer*))
(c-type GstMapInfo               (native "GstMapInfo"))
(c-type GstMapInfo*              (pointer GstMapInfo GstMapInfo*))
(c-type GstAdapter               (native "GstAdapter"))
(c-type GstAdapter*              (pointer GstAdapter GstAdapter*))
(c-type GstBin                   (native "GstBin"))
(c-type GstBin*                  (pointer GstBin GstBin*))
(c-type GstPipeline              (native "GstPipeline"))
(c-type GstPipeline*             (pointer GstPipeline GstPipeline*))
(c-type GstBus                   (native "GstBus"))
(c-type GstBus*                  (pointer GstBus GstBus*))
(c-type GstClock                 (native "GstClock"))
(c-type GstClock*                (pointer GstClock GstClock*))
(c-type GstTask                  (native "GstTask"))
(c-type GstTask*                 (pointer GstTask GstTask*))
(c-type GstQuery                 (native "GstQuery"))
(c-type GstQuery*                (pointer GstQuery GstQuery*))
(c-type GstEvent                 (native "GstEvent"))
(c-type GstEvent*                (pointer GstEvent GstEvent*))
(c-type GstMessage               (native "GstMessage"))
(c-type GstMessage*              (pointer GstMessage GstMessage*))
(c-type GstIterator              (native "GstIterator"))
(c-type GstIterator*             (pointer GstIterator GstIterator*))
(c-type GstDiscoverer            (native "GstDiscoverer"))
(c-type GstDiscoverer*           (pointer GstDiscoverer GstDiscoverer*))
(c-type GstDiscovererInfo        (native "GstDiscovererInfo"))
(c-type GstDiscovererInfo*       (pointer GstDiscovererInfo GstDiscovererInfo*))
(c-type GstDiscovererStreamInfo  (native "GstDiscovererStreamInfo"))
(c-type GstDiscovererStreamInfo* (pointer GstDiscovererStreamInfo GstDiscovererStreamInfo*))
(c-type GstDeviceMonitor         (native "GstDeviceMonitor"))
(c-type GstDeviceMonitor*        (pointer GstDeviceMonitor GstDeviceMonitor*))
(c-type GstDevice                (native "GstDevice"))
(c-type GstDevice*               (pointer GstDevice GstDevice*))
(c-type GstTracer                (native "GstTracer"))
(c-type GstTracer*               (pointer GstTracer GstTracer*))
(c-type GstRegistry              (native "GstRegistry"))
(c-type GstRegistry*             (pointer GstRegistry GstRegistry*))
(c-type GstPlugin                (native "GstPlugin"))
(c-type GstPlugin*               (pointer GstPlugin GstPlugin*))


;;;
;;;; Present
;;;


(c-declare jazz.stream.foreign #/C/
static double present_time(GstClockTime time)
{
    if (time == GST_CLOCK_TIME_NONE)
        return -1;
    else
        return GST_TIME_AS_SECONDS((double) time);
}

static double present_timediff(GstClockTimeDiff diff)
{
    return GST_TIME_AS_SECONDS((double) diff);
}
//#)


;;;
;;;; Listener
;;;


(c-declare jazz.stream.foreign #/C/
static void gst_listener_write(void* listener, char* c)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, c, 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, c, 1);
#endif
}

static void gst_listener_set(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "!", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "!", 1);
#endif
}

static void gst_listener_wakeup(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, ".", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, ".", 1);
#endif
}

static void gst_listener_eos(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "^", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "^", 1);
#endif
}

static void gst_listener_voice(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "+", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "+", 1);
#endif
}

static void gst_listener_freeze(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "<", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "<", 1);
#endif
}

static void gst_listener_thaw(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, ">", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, ">", 1);
#endif
}

static void gst_listener_silence(void* listener)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) listener;
    send(socket, "-", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) listener;
    #pragma GCC diagnostic pop
    
    write(fd, "-", 1);
#endif
}
//#)


;;;
;;;; Alloc
;;;


(c-declare jazz.stream.foreign #/C/
static ___SCMOBJ alloc_foreign(void* ptr, ___SCMOBJ tags)
{
    ___SCMOBJ foreign = ___EXT(___alloc_scmobj) (___PSTATE, ___sFOREIGN, ___FOREIGN_SIZE<<___LWS);
    ___FIELD(foreign,___FOREIGN_TAGS) = tags;
    ___FIELD(foreign,___FOREIGN_RELEASE_FN) = ___CAST(___SCMOBJ, ___EXT(___release_pointer));
    ___FIELD(foreign,___FOREIGN_PTR) = ___CAST(___SCMOBJ, ptr);
    return foreign;
}

static ___SCMOBJ alloc_values(___SCMOBJ obj0, ___SCMOBJ obj1)
{
    ___SCMOBJ values = ___EXT(___alloc_scmobj) (___PSTATE, ___sBOXVALUES, 2*sizeof(___SCMOBJ));
    ___SCMOBJ *ptr = ___CAST(___SCMOBJ*,___BODY(values));
    ptr[0] = obj0;
    ptr[1] = obj1;
    return values;
}
//#)

 
;;;
;;;; VAD
;;;


;; copy from gstremovesilence private

(c-declare jazz.stream.foreign #/C/
#define VAD_POWER_ALPHA 0x0800

// this code tries to match the mac
// preferences input level indicator
double power_level(guint64 power)
{
    double level = power / 4294967295.0;

    if (level > .4)
        level = .4;
    level = level / .4;
    level = pow(level, 1.0/5.0);

    return level;
}

guint64 sound_power(gint16 * data, gint len)
{
    guint64 power;
    gint i;

    power = 0;
    for (i = 0; i < len; i++) {
        power = VAD_POWER_ALPHA * ((data[i] * data[i] >> 14) & 0xFFFF) +
            (0xFFFF - VAD_POWER_ALPHA) * (power >> 16) +
            ((0xFFFF - VAD_POWER_ALPHA) * (power & 0xFFFF) >> 16);
    }

    return power;
}
//#)


;;;
;;;; Log
;;;


(c-declare jazz.stream.foreign #/C/
#ifdef _WIN32
#define G_LOG_DOMAIN "GStreamer"
#endif

#define LOG_LEVEL_NONE        0
#define LOG_LEVEL_G_ERROR     1
#define LOG_LEVEL_G_CRITICAL  2
#define LOG_LEVEL_G_WARNING   3
#define LOG_LEVEL_GST_ERROR   4
#define LOG_LEVEL_GST_WARNING 5

#define MAX_LOG_ENTRIES 100

static GMutex log_mutex;

static int log_id = 0;

static GQueue* log_queue = NULL;
static GQueue* log_user_queue = NULL;

typedef struct log_entry_struct
{
    GstClockTime time;
    int id;
    int level;
    char* category;
    char* function;
    char* message;
    char* stack;
    int refcount;
} log_entry;

static void* log_listener = NULL;

static void* log_pop_first_entry()
{
    gpointer data;

    g_mutex_lock(&log_mutex);
    if (log_queue)
        data = g_queue_pop_head(log_queue);
    else
        data = NULL;
    g_mutex_unlock(&log_mutex);
    
    return data;
}

static void* log_pop_user_first_entry()
{
    gpointer data;

    g_mutex_lock(&log_mutex);
    if (log_user_queue)
        data = g_queue_pop_head(log_user_queue);
    else
        data = NULL;
    g_mutex_unlock(&log_mutex);
    
    return data;
}

static GstClockTime log_entry_time(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->time;
}

static int log_entry_id(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->id;
}

static int log_entry_level(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->level;
}

static char* log_entry_category(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->category;
}

static char* log_entry_function(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->function;
}

static char* log_entry_message(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->message;
}

static char* log_entry_stack(void* data)
{
    log_entry* entry = (log_entry*) data;
  
    return entry->stack;
}

static void log_ref_entry(log_entry* entry)
{
    entry->refcount++;
}

static void log_unref_entry(log_entry* entry)
{
    entry->refcount--;
    if (entry->refcount <= 0)
    {
        if (entry->category)
            g_free(entry->category);
        if (entry->function)
            g_free(entry->function);
        g_free(entry->message);
        if (entry->stack)
            g_free(entry->stack);
        free(entry);
    }
}

static void log_push_entry(int level, gchar * category, gchar * function, gchar * message, gchar * stack)
{
    log_entry* entry = (log_entry*) malloc(sizeof(log_entry));
    log_entry* popped_entry;

    GstClock* clock = gst_system_clock_obtain();
    GstClockTime time = gst_clock_get_time(clock);
    gst_object_unref(clock);

    entry->time = time;
    entry->level = level;
    entry->category = category;
    entry->function = function;
    entry->message = message;
    entry->stack = stack;
    entry->refcount = 0;

    g_mutex_lock(&log_mutex);

    entry->id = log_id++;

    g_queue_push_tail(log_queue, entry);
    log_ref_entry(entry);
    if (g_queue_get_length(log_queue) > MAX_LOG_ENTRIES)
    {
        popped_entry = (log_entry*) g_queue_pop_head(log_queue);
        log_unref_entry(popped_entry);
    }

    g_queue_push_tail(log_user_queue, entry);
    log_ref_entry(entry);
    if (g_queue_get_length(log_user_queue) > MAX_LOG_ENTRIES)
    {
        popped_entry = g_queue_pop_head(log_user_queue);
        log_unref_entry(popped_entry);
    }

    if (log_listener)
        gst_listener_write(log_listener, ".");

    g_mutex_unlock(&log_mutex);
}

static void g_log_handler(const gchar * log_domain, GLogLevelFlags log_level, const gchar * message, gpointer user_data)
{
    int level;
    gchar *stack;

    if ((log_level & G_LOG_LEVEL_ERROR) != 0)
        level = LOG_LEVEL_G_ERROR;
    else if ((log_level & G_LOG_LEVEL_CRITICAL) != 0)
        level = LOG_LEVEL_G_CRITICAL;
    else if ((log_level & G_LOG_LEVEL_WARNING) != 0)
        level = LOG_LEVEL_G_WARNING;
    else
        level = LOG_LEVEL_NONE;
    stack = gst_debug_get_stack_trace(GST_STACK_TRACE_SHOW_FULL);
    log_push_entry(level, NULL, NULL, g_strdup(message), stack);

    if (!log_listener)
        g_log_default_handler(G_LOG_DOMAIN, log_level, message, user_data);
}

void gst_log_function (GstDebugCategory * category,
    GstDebugLevel level, const gchar * file, const gchar * function,
    gint line, GObject * object, GstDebugMessage * message, gpointer unused) G_GNUC_NO_INSTRUMENT;

void gst_log_function (GstDebugCategory * category,
    GstDebugLevel level, const gchar * file, const gchar * function,
    gint line, GObject * object, GstDebugMessage * message, gpointer unused)
{
    gchar *category_str, *function_str, *message_str, *stack;

    if (level == GST_LEVEL_ERROR || level == GST_LEVEL_WARNING)
    {
        if (level == GST_LEVEL_ERROR)
            level = LOG_LEVEL_GST_ERROR;
        else if (level == GST_LEVEL_WARNING)
            level = LOG_LEVEL_GST_WARNING;
        else
            level = LOG_LEVEL_NONE;
        category_str = g_strdup(gst_debug_category_get_name(category));
        function_str = g_strdup(function);
        message_str = g_strdup(gst_debug_message_get(message));
        // too much for relatively high occurence warnings
        if (level == LOG_LEVEL_GST_WARNING)
            stack = NULL;
        else
            stack = gst_debug_get_stack_trace(GST_STACK_TRACE_SHOW_FULL);
        log_push_entry(level, category_str, function_str, message_str, stack);
    }
}

static void log_set_listener(void* listener, int remove_default_log)
{
    g_mutex_lock(&log_mutex);
    log_listener = listener;
    g_mutex_unlock(&log_mutex);

    if (remove_default_log)
        gst_debug_remove_log_function(gst_debug_log_default);
}

static void log_setup()
{
    GLogLevelFlags llf;

    g_mutex_init(&log_mutex);
    log_queue = g_queue_new();
    log_user_queue = g_queue_new();
  
    llf = G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION;
    g_log_set_handler(G_LOG_DOMAIN, llf, g_log_handler, NULL);

    gst_debug_add_log_function(gst_log_function, NULL, NULL);
}
//#)


;;;
;;;; Various
;;;


(c-declare jazz.stream.foreign #/C/
static void gst_version_fill(___SCMOBJ info)
{
    ___U32 *ptr = ___CAST(___U32*, ___BODY(info));
  
    guint major, minor, micro, nano;
    
    gst_version(&major, &minor, &micro, &nano);
    
    ptr[0] = major;
    ptr[1] = minor;
    ptr[2] = micro;
    ptr[3] = nano;
}

static int gst_object_refcount(GstObject* obj)
{
    return GST_OBJECT_REFCOUNT_VALUE(obj);
}

static gboolean gst_object_flag_is_set(GstObject* obj, int flag)
{
    return GST_OBJECT_FLAG_IS_SET(obj, flag);
}

static GValue* gst_value_get_fraction_range_min_aux(GValue* value)
{
    return (GValue*) gst_value_get_fraction_range_min(value);
}

static GValue* gst_value_get_fraction_range_max_aux(GValue* value)
{
    return (GValue*) gst_value_get_fraction_range_max(value);
}

static GValue* gst_value_list_get_value_aux(GValue* value, guint index)
{
    return (GValue*) gst_value_list_get_value(value, index);
}

static char* gst_structure_get_name_aux(GstStructure* struc)
{
    return (char*) gst_structure_get_name(struc);
}

static int gst_structure_get_int_aux(GstStructure* struc, char* name)
{
    int result;
    
    gst_structure_get_int(struc, name, &result);
    
    return result;
}

static guint64 gst_structure_get_uint64_aux(GstStructure* struc, char* name)
{
    guint64 result;
    
    gst_structure_get_uint64(struc, name, &result);
    
    return result;
}

static double gst_structure_get_double_aux(GstStructure* struc, char* name)
{
    double result;
    
    gst_structure_get_double(struc, name, &result);
    
    return result;
}

static GValue* gst_structure_get_value_aux(GstStructure* struc, char* name)
{
    return (GValue*) gst_structure_get_value(struc, name);
}

static char* gst_structure_get_string_aux(GstStructure* struc, char* name)
{
    return (char*) gst_structure_get_string(struc, name);
}

static GValue* gst_structure_get_fraction_range_min_aux(GstStructure* struc, char* name)
{
    return (GValue*) gst_value_get_fraction_range_min(gst_structure_get_value(struc, name));
}

static GValue* gst_structure_get_fraction_range_max_aux(GstStructure* struc, char* name)
{
    return (GValue*) gst_value_get_fraction_range_max(gst_structure_get_value(struc, name));
}

static char* gst_structure_nth_field_name_aux(GstStructure* struc, guint index)
{
    return (char*) gst_structure_nth_field_name(struc, index);
}

static bool gst_caps_features_is_system_memory(GstCapsFeatures* features)
{
    return gst_caps_features_is_equal(features, GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY);
}

static GstBuffer* gst_buffer_new_allocate_aux(gsize size)
{
    return gst_buffer_new_allocate(NULL, size, NULL);
}

static GstClockTime gst_buffer_get_pts(GstBuffer* buffer)
{
    return GST_BUFFER_PTS(buffer);
}

static GstClockTime gst_buffer_get_dts(GstBuffer* buffer)
{
    return GST_BUFFER_DTS(buffer);
}

static GstClockTime gst_buffer_get_duration(GstBuffer* buffer)
{
    return GST_BUFFER_DURATION(buffer);
}

static bool gst_buffer_is_keyframe(GstBuffer* buffer)
{
    return (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT) ? 0 : 1);
}

static void gst_buffer_set_pts(GstBuffer* buffer, GstClockTime pts)
{
    GST_BUFFER_PTS(buffer) = pts;
}

static void gst_buffer_set_dts(GstBuffer* buffer, GstClockTime dts)
{
    GST_BUFFER_DTS(buffer) = dts;
}

static void gst_buffer_set_duration(GstBuffer* buffer, GstClockTime duration)
{
    GST_BUFFER_DURATION(buffer) = duration;
}

static int gst_buffer_copy_memory(GstBuffer* buffer, ___SCMOBJ vec)
{
    ___U8 *data = ___CAST(___U8*, ___BODY(vec));
    int data_size = ___HD_BYTES(___HEADER(vec));
    int size;

    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    if (map.size > data_size)
        size = -2;
    else
    {
        memmove(data, map.data, map.size);
        size = map.size;
    }
    gst_buffer_unmap(buffer, &map);

    return size;
}

static GstMapInfo* gst_buffer_map_aux(GstBuffer* buffer)
{
    GstMapInfo* map = (GstMapInfo*) calloc(sizeof(GstMapInfo), 1);
  
    gst_buffer_map(buffer, map, GST_MAP_READ);
    
    return map;
}

static void gst_buffer_unmap_aux(GstBuffer* buffer, GstMapInfo* map)
{
    gst_buffer_unmap(buffer, map);
    free((void*) map);
}

static int gst_mapinfo_size(GstMapInfo* map)
{
    return map->size;
}

static void* gst_mapinfo_data(GstMapInfo* map)
{
    return map->data;
}

static GstClockTime gst_adapter_prev_pts_aux(GstAdapter* adapter, ___SCMOBJ distance)
{
    ___U64 *distance_ptr = ___CAST(___U64*, ___BODY(distance));
    GstClockTime pts;
    guint64 dist;
    
    pts = gst_adapter_prev_pts(adapter, &dist);
    
    distance_ptr[0] = dist;
    
    return pts;
}

static ___SCMOBJ gst_parse_launch_aux(char* desc, ___SCMOBJ element_tags, ___SCMOBJ error_tags)
{
    GstElement* elem;
    GError* error = NULL;

    elem = gst_parse_launch(desc, &error);
    
    ___SCMOBJ foreign = alloc_foreign(elem, element_tags);

    ___SCMOBJ err;
    if (! error)
        err = ___FAL;
    else
        err = alloc_foreign(error, error_tags);

    ___SCMOBJ values = alloc_values(foreign, err);
    
    ___EXT(___release_scmobj)(foreign);
    if (err != ___FAL)
        ___EXT(___release_scmobj)(err);
    ___EXT(___release_scmobj)(values);
    
    return values;
}

static ___SCMOBJ gst_parse_bin_from_description_aux(char* desc, gboolean ghost_unlinked_pads, ___SCMOBJ element_tags, ___SCMOBJ error_tags)
{
    GstElement* elem;
    GError* error = NULL;

    elem = gst_parse_bin_from_description(desc, ghost_unlinked_pads, &error);
    
    ___SCMOBJ foreign = alloc_foreign(elem, element_tags);

    ___SCMOBJ err;
    if (! error)
        err = ___FAL;
    else
        err = alloc_foreign(error, error_tags);

    ___SCMOBJ values = alloc_values(foreign, err);
    
    ___EXT(___release_scmobj)(foreign);
    if (err != ___FAL)
        ___EXT(___release_scmobj)(err);
    ___EXT(___release_scmobj)(values);
    
    return values;
}

typedef struct element_state_struct
{
    GstElement* element;
    GstState state;
    void* listener;
    GThread* thread;
} element_state;

static void* set_state(void* data)
{
    element_state* es = (element_state*) data;
    GstElement* elem = es->element;
    GstState state = es->state;
    void* listener = es->listener;
  
    gst_element_set_state(elem, state);
    
    gst_listener_set(listener);
  
    return NULL;
}

static void* gst_element_set_state_threaded(GstElement* elem, GstState state, void* listener)
{
    element_state* es = malloc(sizeof(element_state));
    es->element = elem;
    es->state = state;
    es->listener = listener;
    es->thread = g_thread_new("set_state", set_state, (void*) es);
    
    return (void*) es;
}

static void gst_element_set_state_free(void* data)
{
    element_state* es = (element_state*) data;
    g_thread_join(es->thread);
    g_thread_unref(es->thread);
    free(data);
}

static GstStateChangeReturn gst_element_set_state_blocking(GstElement* elem, GstState state)
{
    GstStateChangeReturn state_change;
  
    ___mask_heartbeat_interrupts_state heartbeat_interrupts;
    ___EXT(___mask_heartbeat_interrupts_begin)(&heartbeat_interrupts);
    state_change = gst_element_set_state(elem, state);
    ___EXT(___mask_heartbeat_interrupts_end)(&heartbeat_interrupts);
  
    return state_change;
}

static GstState gst_element_get_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, 0);
    return state;
}

static void gst_element_wait_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, GST_CLOCK_TIME_NONE);
}

static gboolean gst_element_send_freeze(GstElement* elem)
{
    return
        gst_element_send_event(elem,
            gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM,
                gst_structure_new_empty("freeze")));
}

static gboolean gst_element_send_thaw(GstElement* elem)
{
    return
        gst_element_send_event(elem,
            gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM,
                gst_structure_new_empty("thaw")));
}

static GstClockTime gst_system_clock_get_time()
{
    GstClock* clock = gst_system_clock_obtain();
    GstClockTime time = gst_clock_get_time(clock);
    gst_object_unref(clock);
    return time;
}

static GstClockTime gst_pipeline_get_time(GstPipeline* pipeline)
{
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime time = gst_clock_get_time(clock);
    gst_object_unref(clock);
    return time;
}

static GstElement* gst_element_get_pipeline(GstElement* elem)
{
    GstElement *parent, *el;

    parent = el = GST_ELEMENT_PARENT(elem);
    while (parent) {
        el = parent;
        parent = GST_ELEMENT_PARENT(el);
    }
    
    return el;
}

static GstClockTime gst_element_get_running_time(GstElement* elem)
{
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GstClockTime base_time = gst_element_get_base_time(elem);
    gst_object_unref(clock);
    // error case that should not happen
    if (base_time > abs_time)
        return GST_CLOCK_TIME_NONE;
    else
        return abs_time - base_time;
}

static void gst_element_query_latency_aux(GstElement* elem, ___SCMOBJ info)
{
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstQuery *query;
    gboolean live;
    GstClockTime min_latency;
    GstClockTime max_latency;
    query = gst_query_new_latency();
    gst_element_query(elem, query);
    gst_query_parse_latency(query, &live, &min_latency, &max_latency);
    gst_query_unref(query);
    info_ptr[0] = live;
    info_ptr[1] = min_latency;
    info_ptr[2] = max_latency;
}

static void gst_element_query_segment_aux(GstElement* elem, GstFormat format, ___SCMOBJ info)
{
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstQuery *query;
    gdouble rate;
    GstFormat fmt;
    gint64 start;
    gint64 stop;
    query = gst_query_new_segment(format);
    gst_element_query(elem, query);
    gst_query_parse_segment(query, &rate, &fmt, &start, &stop);
    gst_query_unref(query);
    info_ptr[0] = rate;
    info_ptr[1] = fmt;
    info_ptr[2] = start;
    info_ptr[2] = stop;
}

static gint64 gst_element_query_position_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_position(elem, format, &pos);
    return pos;
}

static gint64 gst_element_query_duration_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_duration(elem, format, &pos);
    return pos;
}

static bool gst_is_pipeline(GstElement* elem)
{
    return GST_IS_PIPELINE(elem);
}

static bool gst_is_base_sink(GstElement* elem)
{
    return GST_IS_BASE_SINK(elem);
}

static GstState gst_message_state_changed_get_new_state(GstMessage *msg)
{
    GstState old_state, new_state;
    gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
    return new_state;
}

static GstElement* gst_iterator_next_element(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstElement*) g_value_get_object(&elem);
}

static GstPad* gst_iterator_next_pad(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstPad*) g_value_get_object(&elem);
}

static GstPadMode gst_pad_get_mode(GstPad* pad)
{
    return GST_PAD_MODE(pad);
}

static gboolean gst_pad_is_flushing(GstPad* pad)
{
    return GST_PAD_IS_FLUSHING(pad);
}

static void on_pad_added(GstElement *element, GstPad *pad, gpointer data)
{
    GstPad *sinkpad;
    GstElement *decoder = (GstElement *) data;

    sinkpad = gst_element_get_static_pad(decoder, "sink");

    gst_pad_link(pad, sinkpad);

    gst_object_unref(sinkpad);
}

static GstFlowReturn on_running(GstElement* object, gpointer user_data)
{
    printf("Running %p\n", object);
    return GST_FLOW_OK;
}

static GstFlowReturn on_overrun(GstElement* object, gpointer user_data)
{
    printf("Overrun %p\n", object);
    return GST_FLOW_OK;
}

static GstFlowReturn on_new_sample(GstElement* object, gpointer listener)
{
    gst_listener_wakeup(listener);
    return GST_FLOW_OK;
}

static GstFlowReturn on_eos(GstElement* object, gpointer listener)
{
    gst_listener_eos(listener);
    return GST_FLOW_OK;
}

static gulong gst_signal_connect_to(gpointer instance, char* signal, gpointer data)
{
    return g_signal_connect(instance, signal, G_CALLBACK(on_pad_added), data);
}

static gulong gst_queue_connect_running(GstElement* elem)
{
    return g_signal_connect(elem, "running", G_CALLBACK(on_running), NULL);
}

static gulong gst_queue_connect_overrun(GstElement* elem)
{
    return g_signal_connect(elem, "overrun", G_CALLBACK(on_overrun), NULL);
}

static void gst_app_sink_connect_listener_signals(GstElement* elem, void* listener)
{
    gst_app_sink_set_emit_signals(GST_APP_SINK(elem), 1);
    g_signal_connect(elem, "new-sample", G_CALLBACK(on_new_sample), listener);
    g_signal_connect(elem, "eos", G_CALLBACK(on_eos), listener);
}

static GstDiscoverer* gst_discoverer_new_aux()
{
    return gst_discoverer_new(5 * GST_SECOND, NULL);
}

static GstDiscovererInfo* gst_discoverer_discover_uri_aux(GstDiscoverer* disc, char* uri)
{
    GstDiscovererInfo* info;
    GError* err = NULL;
    
    info = gst_discoverer_discover_uri(disc, uri, &err);
    
    if (err)
        g_print(" %s\n", err->message);
    
    return info;
}

static GstDiscovererStreamInfo* gst_discoverer_stream_info_list_data(GList* list)
{
    return (GstDiscovererStreamInfo *) list->data;
}

static GList* gst_discoverer_stream_info_list_next(GList* list)
{
    return list->next;
}

static GstDevice* gst_device_monitor_device_list_data(GList* list)
{
    return (GstDevice *) list->data;
}

static GList* gst_device_monitor_device_list_next(GList* list)
{
    return list->next;
}

static char* gst_device_get_type_name(GstDevice* device)
{
    GstElement* elem;
    GstElementFactory *factory;
    char* type_name;
  
    elem = gst_device_create_element(device, NULL);
    factory = gst_element_get_factory(elem);
    
    type_name = gst_plugin_feature_get_name(factory);

    gst_object_unref(elem);
    
    return type_name;
}

static GstTracer* gst_tracer_list_data(GList* list)
{
    return (GstTracer *) list->data;
}

static GList* gst_tracer_list_next(GList* list)
{
    return list->next;
}

static GstPlugin* gst_plugin_list_data(GList* list)
{
    return (GstPlugin *) list->data;
}

static GList* gst_plugin_list_next(GList* list)
{
    return list->next;
}

static char* gst_plugin_get_name_aux(GstPlugin* plugin)
{
    return (char*) gst_plugin_get_name(plugin);
}

static char* gst_plugin_get_filename_aux(GstPlugin* plugin)
{
    return (char*) gst_plugin_get_filename(plugin);
}

static char* gst_plugin_get_package_aux(GstPlugin* plugin)
{
    return (char*) gst_plugin_get_package(plugin);
}

static char* gst_plugin_get_description_aux(GstPlugin* plugin)
{
    return (char*) gst_plugin_get_description(plugin);
}

static void gst_print_error(GstMessage *msg)
{
    gchar  *debug;
    GError *error;

    gst_message_parse_error(msg, &error, &debug);
    g_free(debug);

    g_printerr("Error: %s\n", error->message);
    g_error_free(error);
}

static GstBuffer* gst_app_sink_try_pull_buffer(GstElement* elem)
{
    GstSample *sample;
    sample = gst_app_sink_try_pull_sample(GST_APP_SINK(elem), 0);
    if (sample)
    {
        GstBuffer* buffer = gst_sample_get_buffer(sample);
        if (buffer)
        {
            gst_buffer_ref(buffer);
            gst_sample_unref(sample);
            return buffer;
        }
        else
        {
            gst_sample_unref(sample);
            return NULL;
        }
    }
    else
        return NULL;
}

static int gst_app_sink_try_pull_frame(GstElement* elem, ___SCMOBJ vec, ___SCMOBJ info)
{
    int size;
    ___U8 *data = ___CAST(___U8*, ___BODY(vec));
    int data_size = ___HD_BYTES(___HEADER(vec));
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstSample *sample;
    sample = gst_app_sink_try_pull_sample(GST_APP_SINK(elem), 0);
    if (sample)
    {
        GstBuffer* buffer = gst_sample_get_buffer(sample);
        GstClockTime dts, pts, duration;
        ___U64 keyframe;
        if (buffer)
        {
            GstMapInfo map;
            gst_buffer_map(buffer, &map, GST_MAP_READ);
            if (map.size > data_size)
                size = -2;
            else
            {
                memmove(data, map.data, map.size);
                size = map.size;
            }
            gst_buffer_unmap(buffer, &map);
            
            dts = GST_BUFFER_DTS(buffer);
            pts = GST_BUFFER_PTS(buffer);
            duration = GST_BUFFER_DURATION(buffer);
            keyframe = (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT) ? 0 : 1);
        }
        gst_sample_unref(sample);
        info_ptr[0] = dts;
        info_ptr[1] = pts;
        info_ptr[2] = duration;
        info_ptr[3] = keyframe;
        return size;
    }
    else
        return -1;
}

static GstFlowReturn gst_app_src_write(GstElement* elem, ___SCMOBJ vec, int size, ___U64 dts, ___U64 pts, ___U64 duration)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GST_BUFFER_DTS(buffer) = dts;
    GST_BUFFER_PTS(buffer) = pts;
    GST_BUFFER_DURATION(buffer) = duration;
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static GstFlowReturn gst_app_src_write_now(GstElement* elem, ___SCMOBJ vec, int size, ___U64 duration)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static GstFlowReturn gst_app_src_write_pointer_now(GstElement* elem, void* ptr, int size, ___U64 duration)
{
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static bool gst_audio_ring_buffer_acquired(GstElement* elem)
{
    GstAudioBaseSink *sink;
    sink = GST_AUDIO_BASE_SINK(elem);
    return gst_audio_ring_buffer_is_acquired(sink->ringbuffer);
}

static void gst_print_pipeline(GstPipeline* pipeline)
{
    GstClockTime delay, latency;
    delay = gst_pipeline_get_delay(pipeline);
    latency = gst_pipeline_get_latency(pipeline);
    printf("INFO pipeline delay %.3f latency %.3f\n", present_time(delay), present_time(latency));
}

static void gst_print_pad(GstElement* elem, char* name)
{
    GstPad* pad = gst_element_get_static_pad(elem, name);
    GstCaps* caps = gst_pad_get_current_caps(pad);
    printf("INFO pad caps %p\n", caps);
    gst_caps_unref(caps);
    gst_object_unref(pad);
}

static void gst_print_event(char* pipeline_name, char* element_name, char* pad_name, GstEvent* event)
{
    if (GST_EVENT_TYPE(event) == GST_EVENT_CAPS)
    {
        GstCaps *caps;
        gst_event_parse_caps(event, &caps);
        printf("EVENT %s %s %s caps %s\n", pipeline_name, element_name, pad_name, gst_caps_to_string(caps));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_QOS)
    {
        const char* const names[] = { "OVERFLOW", "UNDERFLOW", "THROTTLE" };
        GstQOSType type;
        gdouble proportion;
        GstClockTimeDiff diff;
        GstClockTime timestamp;
        gst_event_parse_qos(event, &type, &proportion, &diff, &timestamp);
        printf("EVENT %s %s %s qos %s %.3f %.3f %.3f\n", pipeline_name, element_name, pad_name, names[type], proportion, present_timediff(diff), present_time(timestamp));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_SEGMENT)
    {
        const GstSegment* segment;
        gst_event_parse_segment (event, &segment);
        printf("EVENT %s %s %s segment %.3f %.3f %.3f %.3f\n", pipeline_name, element_name, pad_name, segment->rate, present_time(segment->start), present_time(segment->stop), present_time(segment->duration));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_LATENCY)
    {
        GstClockTime latency;
        gst_event_parse_latency (event, &latency);
        printf("EVENT %s %s %s latency %.3f\n", pipeline_name, element_name, pad_name, present_time(latency));
    }
    else
        printf("EVENT %s %s %s %s\n", pipeline_name, element_name, pad_name, GST_EVENT_TYPE_NAME(event));
}

static void gst_print_message(char* pipeline_name, GstMessage *msg)
{
    switch (GST_MESSAGE_TYPE(msg)) {

        case GST_MESSAGE_EOS: {
            g_print("MESSAGE eos %s\n",
                pipeline_name);
            break;
        }
        case GST_MESSAGE_ERROR: {
            gchar  *debug;
            GError *error;
            gst_message_parse_error(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE error %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_WARNING: {
            gchar  *debug;
            GError *error;
            gst_message_parse_warning(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE warning %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_STATE_CHANGED: {
            GstState old_state, new_state;
            gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
            g_print("MESSAGE state-changed %s %s from %s to %s\n",
                pipeline_name,
                GST_OBJECT_NAME(msg->src),
                gst_element_state_get_name(old_state),
                gst_element_state_get_name(new_state));
            break;
        }
        case GST_MESSAGE_STREAM_STATUS: {
            const char* const names[] = { "CREATE", "ENTER", "LEAVE", "DESTROY", "START", "PAUSE", "STOP" };
            GstStreamStatusType type;
            GstElement *owner;
            gst_message_parse_stream_status(msg, &type, &owner);
            g_print("MESSAGE stream-status %s %s %s\n",
                pipeline_name,
                GST_OBJECT_NAME(owner),
                names[type]);
            break;
        }
        case GST_MESSAGE_NEW_CLOCK: {
            GstClock *clock;
    
            gst_message_parse_new_clock(msg, &clock);
    
            printf("MESSAGE new-clock: %s\n", (clock ? GST_OBJECT_NAME(clock) : "NULL"));
            break;
        }
        case GST_MESSAGE_QOS: {
            GstFormat format;
            guint64 rendered, dropped;
        
            gst_message_parse_qos_stats(msg, &format, &rendered, &dropped);
            if (format == GST_FORMAT_UNDEFINED)
                printf("MESSAGE qos %s UNDEFINED\n",
                    pipeline_name);
            else
                printf("MESSAGE qos %s %s %lu %lu\n",
                    pipeline_name,
                    GST_OBJECT_NAME(msg->src),
                    rendered,
                    dropped);
            break;
        }
        default: {
            printf("MESSAGE %s %s %s\n",
                GST_MESSAGE_TYPE_NAME(msg),
                pipeline_name,
                GST_OBJECT_NAME(msg->src));
            break;
        }
    }
}

static GstTask* gst_pad_task(GstPad* pad)
{
    return GST_PAD_TASK(pad);
}

static void* gst_task_thread(GstTask* task)
{
    return task->thread;
}

static GstPadProbeReturn
cb_block_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_drop_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    return GST_PAD_PROBE_DROP;
}

#define BLOCK_PROBE 0
#define DROP_PROBE  1
#define RATE_PROBE  2
#define POWER_PROBE 3
#define STAT_PROBE  4
#define VOICE_PROBE 5
#define VIDEO_PROBE 6

typedef struct probe_any
{
    int probe_kind;
    gulong probe_id;
} any_probe;

typedef struct probe_block
{
    int probe_kind;
    gulong probe_id;
} block_probe;

typedef struct probe_drop
{
    int probe_kind;
    gulong probe_id;
} drop_probe;

static void init_block_probe(block_probe* data)
{
    data->probe_kind = BLOCK_PROBE;
}

static void free_block_probe(block_probe* data)
{
    free(data);
}

static void init_drop_probe(drop_probe* data)
{
    data->probe_kind = DROP_PROBE;
}

static void free_drop_probe(drop_probe* data)
{
    free(data);
}

typedef struct probe_rate
{
    int probe_kind;
    gulong probe_id;
    double target_rate;
    int fix_decreasing_pts;
    GstClockTime smallest_latency;
    double last_time;
    double average_elapse;
    int allowed;
    int dropped;
} rate_probe;

static void init_rate_probe(rate_probe* data, double rate, int fix_decreasing_pts)
{
    data->probe_kind = RATE_PROBE;
    data->target_rate = rate;
    data->fix_decreasing_pts = fix_decreasing_pts;
    data->smallest_latency = GST_CLOCK_TIME_NONE;
    data->last_time = -1;
}

static void free_rate_probe(rate_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_rate_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    rate_probe* data = (rate_probe*) user_data;

    if (data->target_rate == 0)
        return GST_PAD_PROBE_DROP;

    GstBuffer* buffer;
    double time, elapse;
    double target_elapse = 1 / data->target_rate;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    
    // this is a bug fix around the camera sometimes
    // returning decreasing pts in avfvideosrc and maybe
    // also on windows. note that this code relies on the
    // element setting do-timestamp=true
    if (data->fix_decreasing_pts)
    {
        GstClockTime dts, pts;

        dts = GST_BUFFER_DTS(buffer);
        pts = GST_BUFFER_PTS(buffer);
        // smallest_latency is used to re-subtract from
        // the dts running time the latency between the
        // operating system timestamp and the actual
        // reception that gstreamer includes in the pts
        // see avfvideosrc getSampleBuffer for an example
        // note that this is necessary for audio video sync
        if (dts >= pts)
        {
            GstClockTime latency = dts - pts;
            if (data->smallest_latency == GST_CLOCK_TIME_NONE || latency < data->smallest_latency)
                data->smallest_latency = latency;
            GST_BUFFER_PTS(buffer) = dts - data->smallest_latency;
        }
        else
        {
            if (data->smallest_latency == GST_CLOCK_TIME_NONE)
                GST_BUFFER_PTS(buffer) = dts;
            else
                GST_BUFFER_PTS(buffer) = dts + data->smallest_latency;
        }
    }

    time = GST_TIME_AS_SECONDS((double) GST_BUFFER_PTS(buffer));
    
    if (data->last_time == -1)
    {
        data->last_time = time;
        data->average_elapse = target_elapse;
        data->smallest_latency = GST_CLOCK_TIME_NONE;
        data->allowed = 1;
        data->dropped = 0;
        return GST_PAD_PROBE_OK;
    }
    else
    {
        double elapse = time - data->last_time;
        double new_average_elapse = (elapse + 127 * data->average_elapse) / 128;
        
        if (new_average_elapse >= target_elapse)
        {
            data->allowed++;
            data->last_time = time;
            data->average_elapse = new_average_elapse;
            return GST_PAD_PROBE_OK;
        }
        else
        {
            data->dropped++;
            return GST_PAD_PROBE_DROP;
        }
    }
}

typedef struct probe_power
{
    int probe_kind;
    gulong probe_id;
    double level;
    double average_level;
} power_probe;

static void init_power_probe(power_probe* data)
{
    data->probe_kind = POWER_PROBE;
    data->level = 0;
    data->average_level = 0;
}

static void free_power_probe(power_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_power_data(GstPad          *pad,
              GstPadProbeInfo *info,
              gpointer         user_data)
{
    power_probe* data = (power_probe*) user_data;

    GstBuffer* buffer;
    GstMapInfo map;
    guint64 power;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);

    gst_buffer_map(buffer, &map, GST_MAP_READ);
    power = sound_power((gint16 *) map.data, map.size / sizeof(gint16));
    gst_buffer_unmap(buffer, &map);

    data->level = power_level(power);
    data->average_level = (data->average_level * 15. + data->level) / 16.;

    return GST_PAD_PROBE_OK;
}

typedef struct probe_stat
{
    int probe_kind;
    gulong probe_id;
    int size;
} stat_probe;

static void init_stat_probe(stat_probe* data)
{
    data->probe_kind = STAT_PROBE;
    data->size = 0;
}

static void free_stat_probe(stat_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_stat_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    stat_probe* data = (stat_probe*) user_data;

    GstBuffer* buffer;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);

    data->size += gst_buffer_get_size(buffer);

    return GST_PAD_PROBE_OK;
}

typedef struct probe_voice
{
    int probe_kind;
    gulong probe_id;
    gpointer listener;
} voice_probe;

static void init_voice_probe(voice_probe* data, gpointer listener)
{
    data->probe_kind = VOICE_PROBE;
    data->listener = listener;
}

static void free_voice_probe(voice_probe* data)
{
    free(data);
}

typedef struct probe_video
{
    int probe_kind;
    gulong probe_id;
    gpointer listener;
} video_probe;

static void init_video_probe(video_probe* data, gpointer listener)
{
    data->probe_kind = VIDEO_PROBE;
    data->listener = listener;
}

static void free_video_probe(video_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_connect_eos(GstPad * pad, GstPadProbeInfo * info, gpointer listener)
{
    if (GST_EVENT_TYPE(GST_PAD_PROBE_INFO_DATA(info)) == GST_EVENT_EOS)
    {
        gst_pad_remove_probe(pad, GST_PAD_PROBE_INFO_ID(info));

        gst_listener_eos(listener);

        return GST_PAD_PROBE_DROP;
    }
    else
        return GST_PAD_PROBE_PASS;
}

static void* gst_pad_add_block_probe(GstPad* pad)
{
    block_probe* data = malloc(sizeof(block_probe));
    init_block_probe(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM, (GstPadProbeCallback) cb_block_data, NULL, NULL);
    
    return (void*) data;
}

static void* gst_pad_add_drop_probe(GstPad* pad)
{
    drop_probe* data = malloc(sizeof(drop_probe));
    init_drop_probe(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_drop_data, NULL, NULL);
    
    return (void*) data;
}

static void* gst_pad_add_rate_probe(GstPad* pad, int rate, int fix_decreasing_pts)
{
    rate_probe* data = malloc(sizeof(rate_probe));
    init_rate_probe(data, rate, fix_decreasing_pts);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_rate_data, data, NULL);
    
    return (void*) data;
}

static void* gst_pad_add_power_probe(GstPad* pad)
{
    power_probe* data = malloc(sizeof(power_probe));
    init_power_probe(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_power_data, data, NULL);
    
    return (void*) data;
}

static void* gst_pad_add_stat_probe(GstPad* pad)
{
    stat_probe* data = malloc(sizeof(stat_probe));
    init_stat_probe(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_stat_data, data, NULL);
    
    return (void*) data;
}

static void gst_rate_probe_reset(void* info)
{
    rate_probe* data = (rate_probe*) info;
    data->last_time = -1;
}

static int gst_rate_probe_get_rate(void* info)
{
    rate_probe* data = (rate_probe*) info;
    return (int) data->target_rate;
}

static void gst_rate_probe_set_rate(void* info, int rate)
{
    rate_probe* data = (rate_probe*) info;
    data->target_rate = rate;
    data->last_time = -1;
}

static int gst_rate_probe_get_allowed(void* info)
{
    rate_probe* data = (rate_probe*) info;
    return data->allowed;
}

static int gst_rate_probe_get_dropped(void* info)
{
    rate_probe* data = (rate_probe*) info;
    return data->dropped;
}

static double gst_power_probe_get_level(void* info)
{
    power_probe* data = (power_probe*) info;
    return data->level;
}

static double gst_power_probe_get_average_level(void* info)
{
    power_probe* data = (power_probe*) info;
    return data->average_level;
}

static int gst_stat_probe_get_size(void* info)
{
    stat_probe* data = (stat_probe*) info;
    return data->size;
}

static void gst_pad_probe_free(void* info)
{
    any_probe* data = (any_probe*) info;
    switch (data->probe_kind) {
        case DROP_PROBE: {
            free_drop_probe((drop_probe*) data);
            break;
        }
        case RATE_PROBE: {
            free_rate_probe((rate_probe*) data);
            break;
        }
        case VOICE_PROBE: {
            free_voice_probe((voice_probe*) data);
            break;
        }
        case VIDEO_PROBE: {
            free_video_probe((video_probe*) data);
            break;
        }
    }
}

static GstPadProbeReturn
cb_voice_events(GstPad          *pad,
                GstPadProbeInfo *info,
                gpointer         user_data)
{
    voice_probe* data = (voice_probe*) user_data;

    GstEvent* event;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);

    switch (GST_EVENT_TYPE (event)) {
        case GST_EVENT_CUSTOM_DOWNSTREAM: {
            if (gst_structure_has_name(gst_event_get_structure(event), "voice"))
            {
                gst_listener_voice(data->listener);
            }
            else if (gst_structure_has_name(gst_event_get_structure(event), "silence"))
            {
                gst_listener_silence(data->listener);
            }
            break;
        }
    }

    return GST_PAD_PROBE_OK;
}

static void* gst_pad_add_voice_probe(GstPad* pad, gpointer listener)
{
    voice_probe* data = malloc(sizeof(voice_probe));
    init_voice_probe(data, listener);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM, (GstPadProbeCallback) cb_voice_events, data, NULL);
    
    return (void*) data;
}

static GstPadProbeReturn
cb_video_events(GstPad          *pad,
                GstPadProbeInfo *info,
                gpointer         user_data)
{
    video_probe* data = (video_probe*) user_data;

    GstEvent* event;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);

    switch (GST_EVENT_TYPE (event)) {
        case GST_EVENT_CUSTOM_DOWNSTREAM: {
            if (gst_structure_has_name(gst_event_get_structure(event), "freeze"))
            {
                gst_listener_freeze(data->listener);
            }
            else if (gst_structure_has_name(gst_event_get_structure(event), "thaw"))
            {
                gst_listener_thaw(data->listener);
            }
            break;
        }
    }

    return GST_PAD_PROBE_OK;
}

static void* gst_pad_add_video_probe(GstPad* pad, gpointer listener)
{
    video_probe* data = malloc(sizeof(video_probe));
    init_video_probe(data, listener);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM, (GstPadProbeCallback) cb_video_events, data, NULL);
    
    return (void*) data;
}

static void gst_pad_remove_probe_aux(GstPad* pad, void* info)
{
    any_probe* data = (any_probe*) info;
    gulong id = data->probe_id;
    
    gst_pad_remove_probe(pad, id);
    gst_pad_probe_free(info);
}

static void gst_pad_connect_eos(GstPad* pad, void* listener)
{
    gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM, cb_connect_eos, listener, NULL);
}

#define ANY_MONITOR     0
#define FILE_MONITOR    1
#define QUEUE_MONITOR   2
#define ANALYSE_MONITOR 3

typedef struct monitor_any
{
    int monitor_kind;
    gulong probe_id;
} any_monitor;

typedef struct monitor_file
{
    int monitor_kind;
    gulong probe_id;
    FILE* file;
} file_monitor;

typedef struct monitor_queue
{
    int monitor_kind;
    gulong probe_id;
    GMutex mutex;
    GQueue* queue;
    GstClockTime window;
    int size;
} queue_monitor;

typedef struct monitor_analyse
{
    int monitor_kind;
    gulong probe_id;
    char* name;
    int offset;
    GstClockTime expected;
    int silence_found;
    int zero_count;
    void* listener;
} analyse_monitor;

static void init_any_monitor(any_monitor* data)
{
    data->monitor_kind = ANY_MONITOR;
}

static void free_any_monitor(any_monitor* data)
{
    free(data);
}

static void init_file_monitor(file_monitor* data, FILE* file)
{
    data->monitor_kind = FILE_MONITOR;
    data->file = file;
}

static void free_file_monitor(file_monitor* data)
{
    FILE* file = data->file;

    fclose(file);

    free(data);
}

static void init_queue_monitor(queue_monitor* data, GstClockTime window)
{
    data->monitor_kind = QUEUE_MONITOR;
    g_mutex_init(&data->mutex);
    data->queue = g_queue_new();
    data->window = window;
    data->size = 0;
}

static void free_queue_monitor(queue_monitor* data)
{
    GQueue* queue = data->queue;

    g_mutex_lock(&data->mutex);
    while (1)
    {
        GstBuffer* buffer = (GstBuffer*) g_queue_pop_head(queue);
        if (! buffer)
            break;
        else
        {
            data->size -= gst_buffer_get_size(buffer);
            gst_buffer_unref(buffer);
        }
    }
    g_mutex_unlock(&data->mutex);

    g_queue_free(queue);
    
    free(data);
}

static void init_analyse_monitor(analyse_monitor* data, void* listener, char* name)
{
    data->monitor_kind = ANALYSE_MONITOR;
    data->name = name;
    data->offset = 0;
    data->expected = GST_CLOCK_TIME_NONE;
    data->silence_found = 0;
    data->zero_count = -1;
    data->listener = listener;
}

static void free_analyse_monitor(analyse_monitor* data)
{
    free(data);
}

static GstPadProbeReturn
cb_monitor_file(GstPad          *pad,
                GstPadProbeInfo *info,
                gpointer         user_data)
{
    file_monitor* data;
    FILE* file;
    GstBuffer* buffer;
    gsize size;

    data = (file_monitor*) user_data;
    file = data->file;
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    size = gst_buffer_get_size(buffer);
    GstClockTime dts = GST_BUFFER_DTS(buffer);
    GstClockTime pts = GST_BUFFER_PTS(buffer);
    GstClockTime duration = GST_BUFFER_DURATION(buffer);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    size = map.size;
    fwrite(map.data, size, 1, file);
    gst_buffer_unmap(buffer, &map);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_monitor_queue(GstPad          *pad,
                 GstPadProbeInfo *info,
                 gpointer         user_data)
{
    queue_monitor* data;
    GMutex* mutex;
    GQueue* queue;
    GstClockTime window;
    GstBuffer* buffer;

    data = (queue_monitor*) user_data;
    mutex = &data->mutex;
    queue = data->queue;
    window = data->window;
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    GstClockTime timestamp = GST_BUFFER_DTS_OR_PTS(buffer);

    if (timestamp != GST_CLOCK_TIME_NONE)
    {
        g_mutex_lock(mutex);

        GstClockTime prune;
     
        if (timestamp <= window)
            prune = 0;
        else
            prune = timestamp - window;

        gst_buffer_ref(buffer);
        g_queue_push_tail(queue, buffer);
        data->size += gst_buffer_get_size(buffer);

        while (1)
        {
            GstBuffer* buf = (GstBuffer*) g_queue_peek_head(queue);
            if (! buf)
                break;
            else
            {
                GstClockTime ts = GST_BUFFER_DTS_OR_PTS(buf);
                if (ts > prune)
                    break;
                else
                {
                    g_queue_pop_head(queue);
                    data->size -= gst_buffer_get_size(buf);
                    gst_buffer_unref(buf);
                }
            }
        }

        g_mutex_unlock(mutex);
    }

    return GST_PAD_PROBE_OK;
}

static ___SCMOBJ copy_monitor_queue(queue_monitor* data)
{
    GMutex* mutex = &data->mutex;
    GQueue* queue = data->queue;
  
    g_mutex_lock(mutex);

    ___SCMOBJ r = ___EXT(___alloc_scmobj) (___PSTATE, ___sU8VECTOR, data->size);
    ___U8 *ptr = ___CAST(___U8*,___BODY(r));
    int length = g_queue_get_length(queue);
    int offset = 0;
    for (int n = 0; n < length; n++)
    {
        GstBuffer* buffer = (GstBuffer*) g_queue_peek_nth(queue, n);
        GstMapInfo map;
        gst_buffer_map(buffer, &map, GST_MAP_READ);
        memcpy(ptr + offset, map.data, map.size);
        offset += map.size;
        gst_buffer_unmap(buffer, &map);
    }
    
    g_mutex_unlock(mutex);
    
    ___EXT(___release_scmobj)(r);
    return r;
}

static GstPadProbeReturn
cb_monitor_analyse(GstPad          *pad,
                   GstPadProbeInfo *info,
                   gpointer         user_data)
{
    analyse_monitor* data;
    void* listener;
    GstMiniObject* miniobj;
    GstBuffer* buffer;
    gsize size;

    data = (analyse_monitor*) user_data;
    listener = data->listener;
    miniobj = GST_PAD_PROBE_INFO_DATA(info);
    if (GST_IS_BUFFER(miniobj))
    {
        buffer = GST_BUFFER_CAST(miniobj);
        size = gst_buffer_get_size(buffer);
        GstClockTime dts = GST_BUFFER_DTS(buffer);
        GstClockTime pts = GST_BUFFER_PTS(buffer);
        GstClockTime duration = GST_BUFFER_DURATION(buffer);
        GstMapInfo map;
        gst_buffer_map(buffer, &map, GST_MAP_READ);
        size = map.size;
        // g_print("flags %d\n", GST_BUFFER_FLAGS(buffer));
        /*
        if (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_GAP))
        {
            GST_BUFFER_FLAG_UNSET(buffer, GST_BUFFER_FLAG_GAP);
            ___U16* ptr = (___U16*) map.data;
            int card = size / sizeof(___U16);
            int count = 0;
            for (int n = 0; n < card; n++)
            {
                ___U16 sample = *ptr++;
                if (sample == 0)
                    count++;
            }
            printf("unsetting gap of size %d silence %d flags %d\n", card, count, GST_BUFFER_FLAGS(buffer));
        }
        */
        if (GST_BUFFER_IS_DISCONT(buffer))
            gst_listener_write(listener, "d");
        if (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_GAP))
            gst_listener_write(listener, "g");
        if (data->expected != GST_CLOCK_TIME_NONE)
        {
            GstClockTimeDiff diff;
            diff = pts - data->expected;
            if (diff > 1 || diff < -1)
                gst_listener_write(listener, "e");
                // printf("%s expected %llu got %llu diff %lld size %d\n", data->name, data->expected, pts, diff);
        }
        data->expected = pts + duration;
        // only works for S16LE
        ___U16* ptr = (___U16*) map.data;
        int card = size / sizeof(___U16);
        for (int n = 0; n < card; n++)
        {
            ___U16 sample = *ptr++;
            if (sample == 0)
            {
                if (data->zero_count == -1)
                    data->zero_count = 1;
                else
                {
                    data->zero_count++;
                    if (data->zero_count == 48)
                    {
                        data->silence_found++;
                        gst_listener_write(listener, "s");
                    }
                }
            }
            else
                data->zero_count = -1;
            data->offset += sizeof(___U16);
        }
        gst_buffer_unmap(buffer, &map);
    }
    else if (GST_IS_BUFFER_LIST(miniobj))
    {
        printf("BUFFER LIST\n");
    }
    else if (GST_IS_EVENT(miniobj))
    {
        gst_print_event("", "", "", GST_EVENT(miniobj));
    }

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_monitor_data(GstPad          *pad,
                GstPadProbeInfo *info,
                gpointer         user_data)
{
    GstBuffer* buffer;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* pad_name;
    gsize size;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    pad_name = gst_pad_get_name(pad);
    size = gst_buffer_get_size(buffer);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime dts = GST_BUFFER_DTS(buffer);
    GstClockTime pts = GST_BUFFER_PTS(buffer);
    GstClockTime clockstamp = gst_clock_get_time(clock) - gst_element_get_base_time(GST_ELEMENT(pipeline));
    // printf("DATA %s %s %s   %ld   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, size, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s   %ld   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, size, present_time(pts), present_time(clockstamp), present_time(pts) - present_time(clockstamp));
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    size = map.size;
    printf("DATA %s %s %10s %6ld   %.3f   %.3f   %.3f  ", pipeline_name, element_name, pad_name, size, present_time(dts), present_time(pts), present_time(clockstamp));
    int i;
    for (i=0; i < ((size <= 20) ? size : 20); i++)
        printf(" %3d,", map.data[i]);
    printf("\n");
    gst_buffer_unmap(buffer, &map);
    g_free(pad_name);
    g_free(element_name);
    gst_object_unref(clock);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_monitor_events(GstPad          *pad,
                  GstPadProbeInfo *info,
                  gpointer         user_data)
{
    GstEvent* event;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* pad_name;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    pad_name = gst_pad_get_name(pad);
    gst_print_event(pipeline_name, element_name, pad_name, event);
    g_free(pad_name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_monitor_queries(GstPad          *pad,
                   GstPadProbeInfo *info,
                   gpointer         user_data)
{
    GstQuery* query;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    query = GST_PAD_PROBE_INFO_QUERY(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    if (GST_QUERY_TYPE(query) == GST_QUERY_CAPS)
    {
        GstCaps *caps, *result_caps;
        gst_query_parse_caps(query, &caps);
        gst_query_parse_caps_result(query, &result_caps);
        printf("QUERY %s %s %s caps %s ---> %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps), gst_caps_to_string(result_caps));
    }
    if (GST_QUERY_TYPE(query) == GST_QUERY_ACCEPT_CAPS)
    {
        GstCaps *caps;
        gboolean result;
        gst_query_parse_accept_caps(query, &caps);
        gst_query_parse_accept_caps_result(query, &result);
        printf("QUERY %s %s %s accept-caps %s ---> %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps), (result) ? "YES" : "NO");
    }
    else
        printf("QUERY %s %s %s %s\n", pipeline_name, element_name, name, GST_QUERY_TYPE_NAME(query));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static void* gst_monitor_file(GstPad* pad, char* filename)
{
    file_monitor* data = malloc(sizeof(file_monitor));
    FILE* file = fopen(filename, "wb");
    init_file_monitor(data, file);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_monitor_file, data, NULL);
    
    return (void*) data;
}

static void* gst_monitor_queue(GstPad* pad, GstClockTime window)
{
    queue_monitor* data = malloc(sizeof(queue_monitor));
    init_queue_monitor(data, window);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_monitor_queue, data, NULL);

    return (void*) data;
}

static ___SCMOBJ gst_monitor_queue_copy(void* info)
{
    queue_monitor* data = (queue_monitor*) info;
  
    return copy_monitor_queue(data);
}

static void* gst_monitor_analyse(GstPad* pad, void* listener, char* name)
{
    analyse_monitor* data = malloc(sizeof(analyse_monitor));
    init_analyse_monitor(data, listener, name);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM, (GstPadProbeCallback) cb_monitor_analyse, data, NULL);

    return (void*) data;
}

static void* gst_monitor_data(GstPad* pad, GstPipeline* pipeline)
{
    any_monitor* data = malloc(sizeof(any_monitor));
    init_any_monitor(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_monitor_data, pipeline, NULL);

    return (void*) data;
}

static void* gst_monitor_events(GstPad* pad, GstPipeline* pipeline)
{
    any_monitor* data = malloc(sizeof(any_monitor));
    init_any_monitor(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_BOTH, (GstPadProbeCallback) cb_monitor_events, pipeline, NULL);

    return (void*) data;
}

static void* gst_monitor_queries(GstPad* pad, GstPipeline* pipeline)
{
    any_monitor* data = malloc(sizeof(any_monitor));
    init_any_monitor(data);

    data->probe_id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_QUERY_BOTH, (GstPadProbeCallback) cb_monitor_queries, pipeline, NULL);

    return (void*) data;
}

static void gst_monitor_free(void* info)
{
    any_monitor* data = (any_monitor*) info;
    switch (data->monitor_kind) {
        case FILE_MONITOR: {
            free_file_monitor((file_monitor*) data);
            break;
        }
        case QUEUE_MONITOR: {
            free_queue_monitor((queue_monitor*) data);
            break;
        }
        case ANALYSE_MONITOR: {
            free_analyse_monitor((analyse_monitor*) data);
            break;
        }
        default: {
            free_any_monitor((any_monitor*) data);
            break;
        }
    }
}

static void gst_monitor_remove(GstPad* pad, void* info)
{
    any_monitor* data = (any_monitor*) info;
    gulong id = data->probe_id;
    
    gst_pad_remove_probe(pad, id);

    gst_monitor_free(info);
}

static gboolean gst_pad_push_force_key_unit(GstPad* pad)
{
    return
        gst_pad_push_event(pad,
            gst_video_event_new_upstream_force_key_unit(GST_CLOCK_TIME_NONE,
                FALSE, 0));
}

static GstBusSyncReply bus_sync_handler(GstBus* bus,
                                        GstMessage* message,
                                        gpointer user_data)
{
    GstPipeline* pipeline = (GstPipeline*) user_data;
    char* name = GST_OBJECT_NAME(pipeline);
    
    gst_print_message(name, message);
    
    return GST_BUS_PASS;
}

static void gst_print_messages(GstPipeline* pipeline)
{
    GstBus* bus = gst_pipeline_get_bus(pipeline);
    gst_bus_set_sync_handler(bus,
                             bus_sync_handler,
                             pipeline,
                             NULL);
    gst_object_unref(bus);
}
//#)


;;;
;;;; External
;;;


(gst-external (gst_init NULL NULL) void)
(gst-external (gst_deinit) void)
(c-external (log_setup) void)
(c-external (log_set_listener void* bool) void)
(c-external (log_pop_first_entry) void*)
(c-external (log_pop_user_first_entry) void*)
(c-external (log_unref_entry void*) void)
(c-external (log_entry_time void*) GstClockTime)
(c-external (log_entry_id void*) int)
(c-external (log_entry_level void*) int)
(c-external (log_entry_category void*) char-string)
(c-external (log_entry_function void*) char-string)
(c-external (log_entry_message void*) char-string)
(c-external (log_entry_stack void*) char-string)
(gst-external (gst_version_fill scheme-object) void)
(gst-external (gst_parse_launch_aux char-string scheme-object scheme-object) scheme-object)
(gst-external (gst_parse_bin_from_description_aux char-string gboolean scheme-object scheme-object) scheme-object)
(gst-external (gst_object_refcount (call GST_OBJECT gpointer)) int "gst_object_refcount")
(gst-external (gst_object_get_name (call GST_OBJECT gpointer)) char-string)
(c-external (gst_object_get_name_untraced (call GST_OBJECT gpointer)) char-string "gst_object_get_name")
(gst-external (gst_object_set_name (call GST_OBJECT gpointer) char-string) :gboolean)
(gst-external (gst_object_flag_is_set (call GST_OBJECT gpointer) int) gboolean)
(gst-external (gst_object_unref gpointer) void)
(gst-external (gst_value_get_fraction_numerator GValue*) int)
(gst-external (gst_value_get_fraction_denominator GValue*) int)
(gst-external (gst_value_set_fraction GValue* int int) void)
(gst-external (gst_value_get_fraction_range_min GValue*) GValue* "gst_value_get_fraction_range_min_aux")
(gst-external (gst_value_get_fraction_range_max GValue*) GValue* "gst_value_get_fraction_range_max_aux")
(gst-external (gst_value_get_buffer GValue*) GstBuffer*)
(gst-external (gst_value_list_get_size GValue*) guint)
(gst-external (gst_value_list_get_value GValue* guint) GValue* "gst_value_list_get_value_aux")
(gst-external (gst_pad_get_name GstPad*) char-string)
(gst-external (gst_pad_get_mode GstPad*) GstPadMode)
(gst-external (gst_pad_is_flushing GstPad*) gboolean)
(gst-external (gst_pad_get_allowed_caps GstPad*) GstCaps*)
(gst-external (gst_pad_has_current_caps GstPad*) bool)
(gst-external (gst_pad_get_current_caps GstPad*) GstCaps*)
(gst-external (gst_pad_query_caps GstPad* GstCaps*) GstCaps*)
(gst-external (gst_pad_get_direction GstPad*) GstPadDirection)
(gst-external (gst_pad_get_parent_element GstPad*) GstElement*)
(gst-external (gst_pad_get_peer GstPad*) GstPad*)
(gst-external (gst_pad_task GstPad*) GstTask*)
(gst-external (gst_pad_is_active GstPad*) gboolean)
(gst-external (gst_pad_is_linked GstPad*) gboolean)
(gst-external (gst_pad_link GstPad* GstPad*) GstPadLinkReturn)
(gst-external (gst_pad_add_block_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_drop_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_rate_probe GstPad* int bool) :alloc void*)
(gst-external (gst_pad_add_power_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_stat_probe GstPad*) :alloc void*)
(gst-external (gst_rate_probe_reset void*) void)
(gst-external (gst_rate_probe_get_rate void*) int)
(gst-external (gst_rate_probe_set_rate void* int) void)
(gst-external (gst_rate_probe_get_allowed void*) int)
(gst-external (gst_rate_probe_get_dropped void*) int)
(gst-external (gst_power_probe_get_level void*) double)
(gst-external (gst_power_probe_get_average_level void*) double)
(gst-external (gst_stat_probe_get_size void*) int)
(gst-external (gst_pad_add_voice_probe GstPad* gpointer) :alloc void*)
(gst-external (gst_pad_add_video_probe GstPad* gpointer) :alloc void*)
(gst-external (gst_pad_remove_probe GstPad* void*) (:free 2) void "gst_pad_remove_probe_aux")
(gst-external (gst_pad_probe_free void*) :free void "gst_pad_probe_free")
(gst-external (gst_pad_connect_eos GstPad* void*) void)
(gst-external (gst_pad_push_event GstPad* GstEvent*) :gboolean)
(gst-external (gst_pad_push_force_key_unit GstPad*) :gboolean)
(gst-external (gst_ghost_pad_new char-string GstPad*) GstPad*)
(gst-external (gst_task_thread GstTask*) void*)
(gst-external (gst_structure_get_name GstStructure*) char-string "gst_structure_get_name_aux")
(gst-external (gst_structure_get_int GstStructure* char-string) int "gst_structure_get_int_aux")
(gst-external (gst_structure_get_uint64 GstStructure* char-string) uint64 "gst_structure_get_uint64_aux")
(gst-external (gst_structure_get_double GstStructure* char-string) double "gst_structure_get_double_aux")
(gst-external (gst_structure_get_value GstStructure* char-string) GValue* "gst_structure_get_value_aux")
(gst-external (gst_structure_get_string GstStructure* char-string) char-string "gst_structure_get_string_aux")
(gst-external (gst_structure_get_fraction_range_min GstStructure* char-string) GValue* "gst_structure_get_fraction_range_min_aux")
(gst-external (gst_structure_get_fraction_range_max GstStructure* char-string) GValue* "gst_structure_get_fraction_range_max_aux")
(gst-external (gst_structure_to_string GstStructure*) char-string)
(gst-external (gst_structure_n_fields GstStructure*) gint)
(gst-external (gst_structure_nth_field_name GstStructure* guint) char-string "gst_structure_nth_field_name_aux")
(gst-external (gst_structure_free GstStructure*) void)
(gst-external (gst_caps_new_empty_simple char-string) GstCaps*)
(gst-external (gst_caps_from_string char-string) GstCaps*)
(gst-external (gst_caps_is_fixed GstCaps*) gboolean)
(gst-external (gst_caps_get_size GstCaps*) guint)
(gst-external (gst_caps_get_structure GstCaps* int) GstStructure*)
(gst-external (gst_caps_get_features GstCaps* int) GstCapsFeatures*)
(gst-external (gst_caps_set_value GstCaps* char-string GValue*) void)
(gst-external (gst_caps_to_string GstCaps*) char-string-free)
(gst-external (gst_caps_unref GstCaps*) void)
(gst-external (gst_caps_features_is_system_memory GstCapsFeatures*) bool)
(gst-external (gst_buffer_new_allocate gsize) GstBuffer* "gst_buffer_new_allocate_aux")
(gst-external (gst_buffer_new_wrapped gpointer gsize) GstBuffer*)
(gst-external (gst_buffer_get_size GstBuffer*) int)
(gst-external (gst_buffer_get_pts GstBuffer*) GstClockTime)
(gst-external (gst_buffer_get_dts GstBuffer*) GstClockTime)
(gst-external (gst_buffer_get_duration GstBuffer*) GstClockTime)
(gst-external (gst_buffer_is_keyframe GstBuffer*) bool)
(gst-external (gst_buffer_set_pts GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_set_dts GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_set_duration GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_unref GstBuffer*) void)
(gst-external (gst_buffer_copy_memory GstBuffer* scheme-object) int)
(gst-external (gst_buffer_map GstBuffer*) GstMapInfo* "gst_buffer_map_aux")
(gst-external (gst_buffer_unmap GstBuffer* GstMapInfo*) void "gst_buffer_unmap_aux")
(gst-external (gst_mapinfo_size GstMapInfo*) int)
(gst-external (gst_mapinfo_data GstMapInfo*) void*)
(gst-external (gst_adapter_new) GstAdapter*)
(gst-external (gst_adapter_clear GstAdapter*) void)
(gst-external (gst_adapter_flush GstAdapter* gsize) void)
(gst-external (gst_adapter_push GstAdapter* GstBuffer*) void)
(gst-external (gst_adapter_available GstAdapter*) gsize)
(gst-external (gst_adapter_prev_pts GstAdapter* scheme-object) GstClockTime "gst_adapter_prev_pts_aux")
(gst-external (gst_adapter_take_buffer GstAdapter* gsize) GstBuffer*)
(gst-external (gst_element_set_state_threaded GstElement* GstState void*) :alloc void*)
(gst-external (gst_element_set_state_free void*) :free void)
(gst-external (gst_element_set_state_blocking GstElement* GstState) GstStateChangeReturn)
(gst-external (gst_element_sync_state_with_parent GstElement*) :gboolean)
(gst-external (gst_element_get_state GstElement*) GstState "gst_element_get_state_aux")
(gst-external (gst_element_wait_state GstElement*) void "gst_element_wait_state_aux")
(gst-external (gst_element_seek_simple GstElement* GstFormat GstSeekFlags int64) :gboolean)
(gst-external (gst_element_send_event GstElement* GstEvent*) :gboolean)
(gst-external (gst_element_send_freeze GstElement*) :gboolean)
(gst-external (gst_element_send_thaw GstElement*) :gboolean)
(gst-external (gst_element_get_bus GstElement*) GstBus*)
(gst-external (gst_element_get_base_time GstElement*) GstClockTime)
(gst-external (gst_element_get_parent GstElement*) GstElement*)
(c-external (gst_element_get_parent_untraced GstElement*) GstElement* "gst_element_get_parent")
(gst-external (gst_element_get_pipeline GstElement*) GstElement*)
(gst-external (gst_element_get_running_time GstElement*) GstClockTime)
(gst-external (gst_element_get_clock GstElement*) GstClock*)
(gst-external (gst_element_factory_make char-string char-string) GstElement*)
(gst-external (gst_element_add_pad GstElement* GstPad*) :gboolean)
(gst-external (gst_element_link GstElement* GstElement*) :gboolean)
(gst-external (gst_element_link_pads GstElement* char-string GstElement* char-string) :gboolean)
(gst-external (gst_element_unlink GstElement* GstElement*) void)
(gst-external (gst_element_get_static_pad GstElement* char-string) GstPad*)
(gst-external (gst_element_get_request_pad GstElement* char-string) GstPad*)
(gst-external (gst_element_release_request_pad GstElement* GstPad*) void)
(gst-external (gst_element_iterate_pads GstElement*) GstIterator*)
(gst-external (gst_element_iterate_sink_pads GstElement*) GstIterator*)
(gst-external (gst_element_iterate_src_pads GstElement*) GstIterator*)
(gst-external (gst_element_query GstElement* GstQuery*) :gboolean)
(gst-external (gst_element_query_latency GstElement* scheme-object) void "gst_element_query_latency_aux")
(gst-external (gst_element_query_segment GstElement* GstFormat scheme-object) void "gst_element_query_segment_aux")
(gst-external (gst_element_query_position GstElement* GstFormat) int64 "gst_element_query_position_aux")
(gst-external (gst_element_query_duration GstElement* GstFormat) int64 "gst_element_query_duration_aux")
(gst-external (gst_iterator_next_element GstIterator*) GstElement*)
(gst-external (gst_iterator_next_pad GstIterator*) GstPad*)
(gst-external (gst_iterator_free GstIterator*) void)
(gst-external (gst_signal_connect_to gpointer char-string gpointer) gulong)
(gst-external (gst_bus_set_flushing GstBus* gboolean) void)
(gst-external (gst_bus_timed_pop_filtered GstBus* GstClockTime GstMessageType) GstMessage*)
(gst-external (gst_bus_pop GstBus*) GstMessage*)
(gst-external (gst_bin_new char-string) GstElement*)
(gst-external (gst_bin_add (call GST_BIN GstElement*) GstElement*) :gboolean)
(gst-external (gst_bin_remove (call GST_BIN GstElement*) GstElement*) :gboolean)
(gst-external (gst_bin_get_by_name_aux (call GST_BIN GstElement*) char-string) GstElement* "gst_bin_get_by_name")
(gst-external (gst_bin_iterate_elements (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_iterate_sorted (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_iterate_recurse (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_recalculate_latency (call GST_BIN GstElement*)) :gboolean)
(gst-external (gst_pipeline_new char-string) GstElement*)
(gst-external (gst_is_pipeline GstElement*) bool)
(gst-external (gst_pipeline_get_bus (call GST_PIPELINE GstElement*)) GstBus*)
(gst-external (gst_pipeline_get_clock (call GST_PIPELINE GstElement*)) GstClock*)
(gst-external (gst_pipeline_get_time (call GST_PIPELINE GstElement*)) GstClockTime)
(gst-external (gst_pipeline_get_latency (call GST_PIPELINE GstElement*)) GstClockTime)
(gst-external (gst_pipeline_set_latency (call GST_PIPELINE GstElement*) GstClockTime) void)
(gst-external (gst_is_base_sink GstElement*) bool)
(gst-external (gst_base_sink_get_latency (call GST_BASE_SINK GstElement*)) GstClockTime)
@gstreamer-1.18
(gst-external (gst_base_sink_get_stats (call GST_BASE_SINK GstElement*)) GstStructure*)
(gst-external (gst_event_new_eos) GstEvent*)
(gst-external (gst_event_new_stream_start char-string) GstEvent*)
(gst-external (gst_event_new_latency GstClockTime) GstEvent*)
(gst-external (gst_event_new_caps GstCaps*) GstEvent*)
(gst-external (gst_event_new_gap GstClockTime GstClockTime) GstEvent*)
(gst-external (gst_message_state_changed_get_new_state GstMessage*) GstState)
(gst-external (gst_message_unref GstMessage*) void)
(gst-external (gst_system_clock_get_time) GstClockTime)
(gst-external (gst_clock_get_time GstClock*) GstClockTime)
(gst-external (gst_discoverer_new) GstDiscoverer* "gst_discoverer_new_aux")
(gst-external (gst_discoverer_discover_uri GstDiscoverer* char-string) GstDiscovererInfo* "gst_discoverer_discover_uri_aux")
(gst-external (gst_discoverer_info_get_duration GstDiscovererInfo*) GstClockTime)
(gst-external (gst_discoverer_info_get_stream_info GstDiscovererInfo*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_stream_info_get_caps GstDiscovererStreamInfo*) GstCaps*)
(gst-external (gst_discoverer_stream_info_get_next GstDiscovererStreamInfo*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_container_info_get_streams (call GST_DISCOVERER_CONTAINER_INFO GstDiscovererStreamInfo*)) GList*)
(gst-external (gst_discoverer_stream_info_list_data GList*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_stream_info_list_next GList*) GList*)
(gst-external (gst_discoverer_stream_info_list_free GList*) void)
(gst-external (gst_discoverer_audio_info_get_bitrate (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_audio_info_get_sample_rate (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_audio_info_get_channels (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_width (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_height (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_bitrate (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_framerate_num (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_framerate_denom (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_device_monitor_new) GstDeviceMonitor*)
(gst-external (gst_device_monitor_add_filter GstDeviceMonitor* char-string GstCaps*) guint)
(gst-external (gst_device_monitor_start GstDeviceMonitor*) :gboolean)
(gst-external (gst_device_monitor_stop GstDeviceMonitor*) void)
(gst-external (gst_device_monitor_get_devices GstDeviceMonitor*) GList*)
(gst-external (gst_device_monitor_device_list_data GList*) GstDevice*)
(gst-external (gst_device_monitor_device_list_next GList*) GList*)
(gst-external (gst_device_create_element GstDevice* NULL) GstElement*)
(gst-external (gst_device_get_caps GstDevice*) GstCaps*)
(gst-external (gst_device_get_device_class GstDevice*) char-string)
(gst-external (gst_device_get_display_name GstDevice*) char-string)
(gst-external (gst_device_get_type_name GstDevice*) char-string)
(gst-external (gst_present_time GstClockTime) double "present_time")
(gst-external (gst_print_pipeline (call GST_PIPELINE GstElement*)) void)
(gst-external (gst_print_pad GstElement* char-string) void)
(gst-external (gst_print_message char-string GstMessage*) void)
(gst-external (gst_print_error GstMessage*) void)
(gst-external (gst_monitor_file GstPad* char-string) void*)
(gst-external (gst_monitor_queue GstPad* GstClockTime) void*)
(gst-external (gst_monitor_queue_copy void*) scheme-object)
(gst-external (gst_monitor_analyse GstPad* void* char-string) void*)
(gst-external (gst_monitor_data GstPad* (call GST_PIPELINE GstElement*)) void*)
(gst-external (gst_monitor_events GstPad* (call GST_PIPELINE GstElement*)) void*)
(gst-external (gst_monitor_queries GstPad* (call GST_PIPELINE GstElement*)) void*)
(gst-external (gst_monitor_remove GstPad* void*) void)
(gst-external (gst_print_messages (call GST_PIPELINE GstElement*)) void)
(gst-external (gst_queue_connect_running GstElement*) gulong)
(gst-external (gst_queue_connect_overrun GstElement*) gulong)
(gst-external (gst_app_src_get_caps (call GST_APP_SRC GstElement*)) GstCaps*)
(gst-external (gst_app_src_set_caps (call GST_APP_SRC GstElement*) GstCaps*) void)
(gst-external (gst_app_src_set_stream_type (call GST_APP_SRC GstElement*) GstAppStreamType) void)
(gst-external (gst_app_src_write GstElement* scheme-object int uint64 uint64 uint64) GstFlowReturn)
(gst-external (gst_app_src_write_now GstElement* scheme-object int uint64) GstFlowReturn)
(gst-external (gst_app_src_write_pointer_now GstElement* void* int uint64) GstFlowReturn)
(gst-external (gst_app_sink_connect_listener_signals GstElement* void*) void)
(gst-external (gst_app_sink_try_pull_buffer GstElement*) GstBuffer*)
(gst-external (gst_app_sink_try_pull_frame GstElement* scheme-object scheme-object) int)
(gst-external (gst_app_sink_is_eos (call GST_APP_SINK GstElement*)) bool)
(gst-external (gst_audio_ring_buffer_acquired GstElement*) bool)
@gstreamer-1.18
(gst-external (gst_tracing_get_active_tracers) GList*)
(gst-external (gst_tracer_list_data GList*) GstTracer*)
(gst-external (gst_tracer_list_next GList*) GList*)
(gst-external (gst_registry_fork_is_enabled) gboolean)
(gst-external (gst_registry_fork_set_enabled gboolean) void)
(gst-external (gst_registry_get) GstRegistry*)
(gst-external (gst_registry_get_plugin_list GstRegistry*) GList*)
(gst-external (gst_plugin_list_data GList*) GstPlugin*)
(gst-external (gst_plugin_list_next GList*) GList*)
(gst-external (gst_plugin_list_free GList*) void)
(gst-external (gst_plugin_get_name GstPlugin*) char-string "gst_plugin_get_name_aux")
(gst-external (gst_plugin_get_filename GstPlugin*) char-string "gst_plugin_get_filename_aux")
(gst-external (gst_plugin_get_package GstPlugin*) char-string "gst_plugin_get_package_aux")
(gst-external (gst_plugin_get_description GstPlugin*) char-string "gst_plugin_get_description_aux")
(gst-external (gst_debug_bin_to_dot_file (call GST_BIN GstElement*) int char-string) void)
(gst-external (GST_TYPE_FRACTION) GType "___return(GST_TYPE_FRACTION);")
(gst-external (GST_TYPE_FRACTION_RANGE) GType "___return(GST_TYPE_FRACTION_RANGE);")
(gst-external (GST_TYPE_LIST) GType "___return(GST_TYPE_LIST);")
(gst-external (GST_MESSAGE_TYPE GstMessage*) GstMessageType)
(gst-external (GST_MESSAGE_SRC GstMessage*) GstElement*)


(definition pipeline-flushing
  (make-table test: eq? weak-keys: #t))

(definition pipeline-flushing-mutex
  (make-mutex 'pipeline-flushing))

(definition public (set-pipeline-flushing? pipeline flushing?)
  (mutex-lock! pipeline-flushing-mutex)
  (table-set! pipeline-flushing pipeline flushing?)
  (mutex-unlock! pipeline-flushing-mutex)
  (set-bus-flushing pipeline flushing?))

(definition public (get-pipeline-flushing? pipeline)
  (mutex-lock! pipeline-flushing-mutex)
  (prog1 (table-ref pipeline-flushing pipeline #t)
    (mutex-unlock! pipeline-flushing-mutex)))


@blocking
(definition public (gst_element_set_state elem state)
  (gst_element_set_state_blocking elem state)
  (when (gst_is_pipeline elem)
    (set-bus-flushing elem (get-pipeline-flushing? elem))))


;; non-blocking listener-based set state
;; - for some reason this is needed for screen share
;; - without it it will not work on windows and on some
;;   macs turning screen share off will result in a crash
;; - the non-blocking set state might also result in a better
;;   behavior by not being in a C call during a blocking set state
(definition public (gst_element_set_state elem state (timeout #f))
  (let ((listener (open-stream-listener)))
    (let ((data (gst_element_set_state_threaded elem state (get-write-file listener))))
      (define (waiting proc)
        (if timeout
            (let ((c (wait-timeout listener timeout)))
              (if (eof-object? c)
                  #f
                (proc c)
                #t))
          (proc (wait listener))))
      
      (waiting
        (lambda (c)
          (assert (eqv? c #\!)
            (gst_element_set_state_free data)
            (close-stream-listener listener)
            (when (gst_is_pipeline elem)
              (set-bus-flushing elem (get-pipeline-flushing? elem)))))))))


;; we are not using messages at the moment and
;; not processing them causes nasty memory leaks
;; note that setting the bus to flushing from set_state
;; is a quick solution to gstreamer overriding flushing
;; when going to ready state
(definition (set-bus-flushing pipeline flushing?)
  (with-unref ((bus (gst_pipeline_get_bus pipeline)))
    (gst_bus_set_flushing bus (if flushing? 1 0))))


(gst-external (move-u8vector->pointer! scheme-object void*) void
  #/C/
    memmove(___arg2, ___BODY(___arg1), ___HD_BYTES(___HEADER(___arg1)));
//#)


(gst-external (move-pointer->u8vector! void* scheme-object) void
  #/C/
    memmove(___BODY(___arg2), ___arg1, ___HD_BYTES(___HEADER(___arg2)));
//#)


(gst-external (separate-alpha void* void* int) void
  #/C/
    char* data = (char*) ___arg1;
    char* alpha = (char*) ___arg2;
    int count = ___arg3;
    
    data += 3;
    while (count > 0)
    {
        *alpha++ = *data;
        data += 4;
        count--;
    }
//#)


(gst-external (combine-alpha scheme-object scheme-object void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char* alpha = (char*) ___BODY(___arg2);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *alpha++;
        color++;
        count--;
    }
//#)


(gst-external (add-alpha scheme-object float void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char alpha = (char) (___arg2 * 255);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = alpha;
        color++;
        count--;
    }
//#)


;;;
;;;; Startup
;;;


(definition gstreamer-start-time
  #f)

(definition protected (get-gstreamer-start-time)
  gstreamer-start-time)


(definition gstreamer-initialized?
  #f)


(definition public (startup-gstreamer)
  (unless gstreamer-initialized?
    (gst_registry_fork_set_enabled 0)
    (gst_init)
    (set! gstreamer-start-time (gst_system_clock_get_time))
    (log_setup)
    (for-each (lambda (hook)
                (hook))
              gstreamer-hooks)
    (set! gstreamer-initialized? #t)))


(definition public (shutdown-gstreamer)
  (when gstreamer-initialized?
    (set! gstreamer-initialized? #f)))


(startup-gstreamer))
