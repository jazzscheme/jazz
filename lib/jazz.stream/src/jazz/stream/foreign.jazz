;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; GStreamer Foreign
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.stream.foreign jazz


(import (jazz.foreign)
        (jazz.listener)
        (jazz.platform.types)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax)))


;;;
;;;; Trace
;;;


(define-setting trace-gst?
  #f)

(define-setting trace-gst
  (lambda (name rest)
    (unless (memq? name '(gst_app_sink_try_pull gst_app_src_write gst_element_get_running_time move-u8vector->pointer!))
      (let ((port (console-port)))
        (define (present obj)
          (cond ((u8vector? obj)
                 (display (list 'u8vector (u8vector-length obj)) port))
                ((foreign? obj)
                 (let ((tags (foreign-tags obj)))
                   (cond ((equal? tags '(GstElement*))
                          (format port "#<{a}*"
                            (g_object_class_name obj))
                          (present-path obj)
                          (format port " #{a} 0x{x}>"
                            (object->serial obj)
                            (foreign-address obj)))
                         (else
                          (write obj port)))))
                (else
                 (write obj port))))
        
        (define (present-path elem)
          (let (loop (elem elem))
            (let ((parent (gst_element_get_parent_untraced elem)))
              (when parent
                (loop parent))
              (display " " port)
              (display (gst_object_get_name_untraced elem) port))))
        
        (display name port)
        (case name
          ((gst_element_set_state_threaded)
           (bind (elem state) rest
             (display " " port)
             (present elem)
             (display " " port)
             (display (ecase state
                        ((GST_STATE_NULL) "NULL")
                        ((GST_STATE_READY) "READY")
                        ((GST_STATE_PAUSED) "PAUSED")
                        ((GST_STATE_PLAYING) "PLAYING"))
                      port)))
          (else
           (for-each (lambda (obj)
                       (display " " port)
                       (present obj))
                     rest)))
        (newline port)
        (force-output port)))))


;;;
;;;; GLib
;;;


(c-include "<stdbool.h>")
(c-include "<string.h>")
(c-include "<stdlib.h>")
(c-include "<stdio.h>")
(c-include "<unistd.h>")
(c-include "<fcntl.h>")
(c-include "<glib.h>")
(c-include "<gst/gst.h>")
(c-include "<gst/app/gstappsrc.h>")
(c-include "<gst/app/gstappsink.h>")
(c-include "<gst/pbutils/pbutils.h>")


(c-type gint     int)
(c-type guint    uint)
(c-type gulong   ulong)
(c-type gsize    ulong)
(c-type gboolean gint)
(c-type gpointer void*)
(c-type GType    enum)


(c-type GValue   (native "GValue"))
(c-type GValue*  (pointer "GValue" GValue*))
(c-type GObject  (native "GObject"))
(c-type GObject* (pointer GObject #f))
(c-type GThread  (native "GThread"))
(c-type GThread* (pointer GThread GThread*))
(c-type GList    (native "GList"))
(c-type GList*   (pointer GList GList*))
(c-type GError   (native "GError"))
(c-type GError*  (pointer GError GError*))


(c-enumerant G_TYPE_BOOLEAN)
(c-enumerant G_TYPE_INT)
(c-enumerant G_TYPE_UINT64)
(c-enumerant G_TYPE_DOUBLE)
(c-enumerant G_TYPE_STRING)


(c-declare jazz.stream.foreign #/C/
___SCMOBJ CHARSTRINGFREE_to_SCMOBJ(char *src, ___SCMOBJ *dst, int arg_num)
{
  ___SCMOBJ result;

  result = ___CHARSTRING_to_SCMOBJ(___PSTATE, src, dst, arg_num);

  g_free(src);

  return result;
}

#define ___BEGIN_CFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c,i)___IF_STOC3(___SCMOBJ_to_CHARSTRING,s,&c,i){
#define ___END_CFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c,i)___EXT(___release_string)(c);}

#define ___BEGIN_CFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s)if ((___err = CHARSTRINGFREE_to_SCMOBJ(c, &s, ___RETURN_POS)) == ___FIX(___NO_ERR)){
#define ___END_CFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s)___EXT(___release_scmobj)(s);}

#define ___BEGIN_SFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s,i)if ((___err = CHARSTRINGFREE_to_SCMOBJ(c, &s, ___RETURN_POS)) == ___FIX(___NO_ERR)){
#define ___END_SFUN_CHARSTRINGFREE_TO_SCMOBJ(c,s,i)___EXT(___release_scmobj)(s);}

#define ___BEGIN_SFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c)___STOC3(___SCMOBJ_to_CHARSTRING,s,&c,___RETURN_POS);
#define ___END_SFUN_SCMOBJ_TO_CHARSTRINGFREE(s,c)
//#)

(c-define-type char-string-free
               "char*"
               "CHARSTRINGFREE_TO_SCMOBJ"
               "SCMOBJ_TO_CHARSTRINGFREE"
               #t)


(c-declare jazz.stream.foreign #/C/
static int g_object_get_int(GObject* obj, char* name)
{
    int d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static unsigned int g_object_get_uint(GObject* obj, char* name)
{
    unsigned int d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static gint64 g_object_get_uint64(GObject* obj, char* name)
{
    gint64 d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static bool g_object_get_boolean(GObject* obj, char* name)
{
    bool d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static double g_object_get_double(GObject* obj, char* name)
{
    double d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static char* g_object_get_string(GObject* obj, char* name)
{
    char* s;
    g_object_get(obj, name, &s, NULL);
    return s;
}

static char* g_object_class_name(GObject* obj)
{
    return (char*) G_OBJECT_CLASS_NAME(G_OBJECT_GET_CLASS(obj));
}

static char* g_error_message(GError* error)
{
    return error->message;
}
//#)


(c-external (g_value_new GType) :alloc GValue*
  #/C/
    GValue* value = (GValue*) calloc(sizeof(GValue), 1);
    g_value_init(value, ___arg1);
    ___return(value);
//#)

(c-external (g_value_free GValue*) :free void
  #/C/
    g_value_unset(___arg1);
    free(___arg1);
//#)


(c-external (g_value_get_boolean GValue*) bool)
(c-external (g_value_set_boolean GValue* bool) void)
(c-external (g_value_get_int GValue*) int)
(c-external (g_value_set_int GValue* int) void)
(c-external (g_value_get_uint64 GValue*) uint64)
(c-external (g_value_set_uint64 GValue* uint64) void)
(c-external (g_value_get_double GValue*) double)
(c-external (g_value_set_double GValue* double) void)
(c-external (g_value_get_string GValue*) (cast char-string))
(c-external (g_value_set_string GValue* char-string) void)
(c-external (g_list_free GList*) void)
(c-external (g_object_class_name (call G_OBJECT GObject*)) char-string)
(c-external (g_object_get_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_set_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_get_boolean (call G_OBJECT GObject*) char-string) bool "g_object_get_boolean")
(c-external (g_object_set_boolean (call G_OBJECT GObject*) char-string bool NULL) void "g_object_set")
(c-external (g_object_get_int (call G_OBJECT GObject*) char-string) int "g_object_get_int")
(c-external (g_object_set_int (call G_OBJECT GObject*) char-string int NULL) void "g_object_set")
(c-external (g_object_get_uint (call G_OBJECT GObject*) char-string) uint "g_object_get_uint")
(c-external (g_object_set_uint (call G_OBJECT GObject*) char-string uint NULL) void "g_object_set")
(c-external (g_object_get_uint64 (call G_OBJECT GObject*) char-string) uint64 "g_object_get_uint64")
(c-external (g_object_set_uint64 (call G_OBJECT GObject*) char-string uint64 NULL) void "g_object_set")
(c-external (g_object_get_double (call G_OBJECT GObject*) char-string) double "g_object_get_double")
(c-external (g_object_set_double (call G_OBJECT GObject*) char-string double NULL) void "g_object_set")
(c-external (g_object_get_string (call G_OBJECT GObject*) char-string) char-string-free "g_object_get_string")
(c-external (g_object_set_string (call G_OBJECT GObject*) char-string char-string NULL) void "g_object_set")
(c-external (g_signal_emit_by_name gpointer char-string) void)
(c-external (g_signal_handler_disconnect gpointer gulong) void)
(c-external (g_error_message GError*) char-string)
(c-external (G_OBJECT_TYPE (call G_OBJECT GObject*)) uint64)
;; (c-external (G_OBJECT_TYPE_NAME (call G_OBJECT GObject*)) char-string)


;;;
;;;; GStreamer
;;;


(c-enumerant GST_STATE_NULL)
(c-enumerant GST_STATE_READY)
(c-enumerant GST_STATE_PAUSED)
(c-enumerant GST_STATE_PLAYING)
(c-enumerant GST_STATE_CHANGE_FAILURE)
(c-enumerant GST_STATE_CHANGE_SUCCESS)
(c-enumerant GST_STATE_CHANGE_ASYNC)
(c-enumerant GST_STATE_CHANGE_NO_PREROLL)
(c-enumerant GST_CLOCK_TIME_NONE "U64")
(c-enumerant GST_MESSAGE_EOS)
(c-enumerant GST_MESSAGE_ERROR)
(c-enumerant GST_MESSAGE_WARNING)
(c-enumerant GST_MESSAGE_STATE_CHANGED)
(c-enumerant GST_MESSAGE_STREAM_STATUS)
(c-enumerant GST_MESSAGE_QOS)
(c-enumerant GST_FORMAT_TIME)
(c-enumerant GST_EVENT_CAPS)
(c-enumerant GST_SEEK_FLAG_FLUSH)
(c-enumerant GST_APP_STREAM_TYPE_STREAM)
(c-enumerant GST_APP_STREAM_TYPE_SEEKABLE)
(c-enumerant GST_APP_STREAM_TYPE_RANDOM_ACCESS)
(c-enumerant GST_PAD_UNKNOWN)
(c-enumerant GST_PAD_SRC)
(c-enumerant GST_PAD_SINK)
(c-enumerant GST_PAD_LINK_OK)
(c-enumerant GST_PAD_LINK_WRONG_HIERARCHY)
(c-enumerant GST_PAD_LINK_WAS_LINKED)
(c-enumerant GST_PAD_LINK_WRONG_DIRECTION)
(c-enumerant GST_PAD_LINK_NOFORMAT)
(c-enumerant GST_PAD_LINK_NOSCHED)
(c-enumerant GST_PAD_LINK_REFUSED)
(c-enumerant GST_PAD_MODE_NONE)
(c-enumerant GST_PAD_MODE_PUSH)
(c-enumerant GST_PAD_MODE_PULL)
(c-enumerant GST_TYPE_DISCOVERER_CONTAINER_INFO)
(c-enumerant GST_TYPE_DISCOVERER_STREAM_INFO)
(c-enumerant GST_TYPE_DISCOVERER_AUDIO_INFO)
(c-enumerant GST_TYPE_DISCOVERER_VIDEO_INFO)
(c-enumerant GST_DEBUG_GRAPH_SHOW_ALL)


(c-type GstClockTime         uint64)
(c-type GstClockTimeDiff     int64)
(c-type GstStateChangeReturn enum)
(c-type GstState             enum)
(c-type GstFormat            enum)
(c-type GstMessageType       enum)
(c-type GstFlowReturn        enum)
(c-type GstAppStreamType     enum)
(c-type GstSeekFlags         enum)
(c-type GstPadDirection      enum)
(c-type GstPadLinkReturn     enum)
(c-type GstPadMode           enum)


(c-type GstObject                (native "GstObject"))
(c-type GstObject*               (pointer GstObject GstObject*))
(c-type GstElement               (native "GstElement"))
(c-type GstElement*              (pointer GstElement GstElement*))
(c-type GstPad                   (native "GstPad"))
(c-type GstPad*                  (pointer GstPad GstPad*))
(c-type GstCaps                  (native "GstCaps"))
(c-type GstCaps*                 (pointer GstCaps GstCaps*))
(c-type GstStructure             (native "GstStructure"))
(c-type GstStructure*            (pointer GstStructure GstStructure*))
(c-type GstBuffer                (native "GstBuffer"))
(c-type GstBuffer*               (pointer GstBuffer GstBuffer*))
(c-type GstAdapter               (native "GstAdapter"))
(c-type GstAdapter*              (pointer GstAdapter GstAdapter*))
(c-type GstBin                   (native "GstBin"))
(c-type GstBin*                  (pointer GstBin GstBin*))
(c-type GstPipeline              (native "GstPipeline"))
(c-type GstPipeline*             (pointer GstPipeline GstPipeline*))
(c-type GstBus                   (native "GstBus"))
(c-type GstBus*                  (pointer GstBus GstBus*))
(c-type GstClock                 (native "GstClock"))
(c-type GstClock*                (pointer GstClock GstClock*))
(c-type GstTask                  (native "GstTask"))
(c-type GstTask*                 (pointer GstTask GstTask*))
(c-type GstQuery                 (native "GstQuery"))
(c-type GstQuery*                (pointer GstQuery GstQuery*))
(c-type GstEvent                 (native "GstEvent"))
(c-type GstEvent*                (pointer GstEvent GstEvent*))
(c-type GstMessage               (native "GstMessage"))
(c-type GstMessage*              (pointer GstMessage GstMessage*))
(c-type GstIterator              (native "GstIterator"))
(c-type GstIterator*             (pointer GstIterator GstIterator*))
(c-type GstDiscoverer            (native "GstDiscoverer"))
(c-type GstDiscoverer*           (pointer GstDiscoverer GstDiscoverer*))
(c-type GstDiscovererInfo        (native "GstDiscovererInfo"))
(c-type GstDiscovererInfo*       (pointer GstDiscovererInfo GstDiscovererInfo*))
(c-type GstDiscovererStreamInfo  (native "GstDiscovererStreamInfo"))
(c-type GstDiscovererStreamInfo* (pointer GstDiscovererStreamInfo GstDiscovererStreamInfo*))
(c-type GstDeviceMonitor         (native "GstDeviceMonitor"))
(c-type GstDeviceMonitor*        (pointer GstDeviceMonitor GstDeviceMonitor*))
(c-type GstDevice                (native "GstDevice"))
(c-type GstDevice*               (pointer GstDevice GstDevice*))
(c-type GstTracer                (native "GstTracer"))
(c-type GstTracer*               (pointer GstTracer GstTracer*))


(c-declare jazz.stream.foreign #/C/
static double present_time(GstClockTime time)
{
    if (time == GST_CLOCK_TIME_NONE)
        return -1;
    else
        return GST_TIME_AS_SECONDS((double) time);
}

static double present_timediff(GstClockTimeDiff diff)
{
    return GST_TIME_AS_SECONDS((double) diff);
}

static void gst_version_fill(___SCMOBJ info)
{
    ___U32 *ptr = ___CAST(___U32*, ___BODY(info));
  
    guint major, minor, micro, nano;
    
    gst_version(&major, &minor, &micro, &nano);
    
    ptr[0] = major;
    ptr[1] = minor;
    ptr[2] = micro;
    ptr[3] = nano;
}

static int gst_object_refcount(GstObject* obj)
{
    return GST_OBJECT_REFCOUNT_VALUE(obj);
}

static char* gst_structure_get_name_aux(GstStructure* struc)
{
    return (char*) gst_structure_get_name(struc);
}

static int gst_structure_get_int_aux(GstStructure* struc, char* name)
{
    int result;
    
    gst_structure_get_int(struc, name, &result);
    
    return result;
}

static gint64 gst_structure_get_uint64_aux(GstStructure* struc, char* name)
{
    gint64 result;
    
    gst_structure_get_uint64(struc, name, &result);
    
    return result;
}

static double gst_structure_get_double_aux(GstStructure* struc, char* name)
{
    double result;
    
    gst_structure_get_double(struc, name, &result);
    
    return result;
}

static GValue* gst_structure_get_value_aux(GstStructure* struc, char* name)
{
    return (GValue*) gst_structure_get_value(struc, name);
}

static GstBuffer* gst_buffer_new_allocate_aux(gsize size)
{
    return gst_buffer_new_allocate(NULL, size, NULL);
}

static GstClockTime gst_buffer_get_pts(GstBuffer* buffer)
{
    return GST_BUFFER_PTS(buffer);
}

static GstClockTime gst_buffer_get_dts(GstBuffer* buffer)
{
    return GST_BUFFER_DTS(buffer);
}

static GstClockTime gst_buffer_get_duration(GstBuffer* buffer)
{
    return GST_BUFFER_DURATION(buffer);
}

static void gst_buffer_set_pts(GstBuffer* buffer, GstClockTime pts)
{
    GST_BUFFER_PTS(buffer) = pts;
}

static void gst_buffer_set_dts(GstBuffer* buffer, GstClockTime dts)
{
    GST_BUFFER_DTS(buffer) = dts;
}

static void gst_buffer_set_duration(GstBuffer* buffer, GstClockTime duration)
{
    GST_BUFFER_DURATION(buffer) = duration;
}

static GstClockTime gst_adapter_prev_pts_aux(GstAdapter* adapter, ___SCMOBJ distance)
{
    ___U64 *distance_ptr = ___CAST(___U64*, ___BODY(distance));
    GstClockTime pts;
    guint64 dist;
    
    pts = gst_adapter_prev_pts(adapter, &dist);
    
    distance_ptr[0] = dist;
    
    return pts;
}

static ___SCMOBJ alloc_foreign(void* ptr, ___SCMOBJ tags)
{
    ___SCMOBJ foreign = ___EXT(___alloc_scmobj) (___PSTATE, ___sFOREIGN, ___FOREIGN_SIZE<<___LWS);
    ___FIELD(foreign,___FOREIGN_TAGS) = tags;
    ___FIELD(foreign,___FOREIGN_RELEASE_FN) = ___CAST(___SCMOBJ, ___EXT(___release_pointer));
    ___FIELD(foreign,___FOREIGN_PTR) = ___CAST(___SCMOBJ, ptr);
    return foreign;
}

static ___SCMOBJ alloc_values(___SCMOBJ obj0, ___SCMOBJ obj1)
{
    ___SCMOBJ values = ___EXT(___alloc_scmobj) (___PSTATE, ___sBOXVALUES, 2*sizeof(___SCMOBJ));
    ___SCMOBJ *ptr = ___CAST(___SCMOBJ*,___BODY(values));
    ptr[0] = obj0;
    ptr[1] = obj1;
    return values;
}

static ___SCMOBJ gst_parse_launch_aux(char* desc, ___SCMOBJ element_tags, ___SCMOBJ error_tags)
{
    GstElement* elem;
    GError* error = NULL;

    elem = gst_parse_launch(desc, &error);
    
    ___SCMOBJ foreign = alloc_foreign(elem, element_tags);

    ___SCMOBJ err;
    if (! error)
        err = ___FAL;
    else
        err = alloc_foreign(error, error_tags);

    ___SCMOBJ values = alloc_values(foreign, err);
    
    ___EXT(___release_scmobj)(foreign);
    if (err != ___FAL)
        ___EXT(___release_scmobj)(err);
    ___EXT(___release_scmobj)(values);
    
    return values;
}

static ___SCMOBJ gst_parse_bin_from_description_aux(char* desc, gboolean ghost_unlinked_pads, ___SCMOBJ element_tags, ___SCMOBJ error_tags)
{
    GstElement* elem;
    GError* error = NULL;

    elem = gst_parse_bin_from_description(desc, ghost_unlinked_pads, &error);
    
    ___SCMOBJ foreign = alloc_foreign(elem, element_tags);

    ___SCMOBJ err;
    if (! error)
        err = ___FAL;
    else
        err = alloc_foreign(error, error_tags);

    ___SCMOBJ values = alloc_values(foreign, err);
    
    ___EXT(___release_scmobj)(foreign);
    if (err != ___FAL)
        ___EXT(___release_scmobj)(err);
    ___EXT(___release_scmobj)(values);
    
    return values;
}

static void gst_listener_set(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, "!", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, "!", 1);
#endif
}

typedef struct element_state_struct
{
    GstElement* element;
    GstState state;
    void* desc;
    GThread* thread;
} element_state;

static void* set_state(void* data)
{
    element_state* es = (element_state*) data;
    GstElement* elem = es->element;
    GstState state = es->state;
    void* desc = es->desc;
  
    gst_element_set_state(elem, state);
    
    gst_listener_set(desc);
  
    return NULL;
}

static void* gst_element_set_state_threaded(GstElement* elem, GstState state, void* desc)
{
    element_state* es = malloc(sizeof(element_state));
    es->element = elem;
    es->state = state;
    es->desc = desc;
    es->thread = g_thread_new("set_state", set_state, (void*) es);
    
    return (void*) es;
}

static void gst_element_set_state_free(void* data)
{
    element_state* es = (element_state*) data;
    g_thread_join(es->thread);
    g_thread_unref(es->thread);
    free(data);
}

static GstStateChangeReturn gst_element_set_state_blocking(GstElement* elem, GstState state)
{
    GstStateChangeReturn state_change;
  
    ___mask_heartbeat_interrupts_state heartbeat_interrupts;
    ___EXT(___mask_heartbeat_interrupts_begin)(&heartbeat_interrupts);
    state_change = gst_element_set_state(elem, state);
    ___EXT(___mask_heartbeat_interrupts_end)(&heartbeat_interrupts);
  
    return state_change;
}

static GstState gst_element_get_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, 0);
    return state;
}

static void gst_element_wait_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, GST_CLOCK_TIME_NONE);
}

static GstClockTime gst_system_clock_get_time()
{
    GstClock* clock = gst_system_clock_obtain();
    GstClockTime time = gst_clock_get_time(clock);
    gst_object_unref(clock);
    return time;
}

static GstClockTime gst_pipeline_get_time(GstPipeline* pipeline)
{
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime time = gst_clock_get_time(clock);
    gst_object_unref(clock);
    return time;
}

static GstElement* gst_element_get_pipeline(GstElement* elem)
{
    GstElement *parent, *el;

    parent = el = GST_ELEMENT_PARENT(elem);
    while (parent) {
        el = parent;
        parent = GST_ELEMENT_PARENT(el);
    }
    
    return el;
}

static GstClockTime gst_element_get_running_time(GstElement* elem)
{
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GstClockTime base_time = gst_element_get_base_time(elem);
    gst_object_unref(clock);
    // error case that should not happen
    if (base_time > abs_time)
        return GST_CLOCK_TIME_NONE;
    else
        return abs_time - base_time;
}

static void gst_element_query_latency_aux(GstElement* elem, ___SCMOBJ info)
{
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstQuery *query;
    gboolean live;
    GstClockTime min_latency;
    GstClockTime max_latency;
    query = gst_query_new_latency();
    gst_element_query(elem, query);
    gst_query_parse_latency(query, &live, &min_latency, &max_latency);
    gst_query_unref(query);
    info_ptr[0] = live;
    info_ptr[1] = min_latency;
    info_ptr[2] = max_latency;
}

static void gst_element_query_segment_aux(GstElement* elem, GstFormat format, ___SCMOBJ info)
{
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstQuery *query;
    gdouble rate;
    GstFormat fmt;
    gint64 start;
    gint64 stop;
    query = gst_query_new_segment(format);
    gst_element_query(elem, query);
    gst_query_parse_segment(query, &rate, &fmt, &start, &stop);
    gst_query_unref(query);
    info_ptr[0] = rate;
    info_ptr[1] = fmt;
    info_ptr[2] = start;
    info_ptr[2] = stop;
}

static gint64 gst_element_query_position_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_position(elem, format, &pos);
    return pos;
}

static gint64 gst_element_query_duration_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_duration(elem, format, &pos);
    return pos;
}

static bool gst_is_pipeline(GstElement* elem)
{
    return GST_IS_PIPELINE(elem);
}

static bool gst_is_base_sink(GstElement* elem)
{
    return GST_IS_BASE_SINK(elem);
}

static GstState gst_message_state_changed_get_new_state(GstMessage *msg)
{
    GstState old_state, new_state;
    gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
    return new_state;
}

static GstElement* gst_iterator_next_element(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstElement*) g_value_get_object(&elem);
}

static GstPad* gst_iterator_next_pad(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstPad*) g_value_get_object(&elem);
}

static GstPadMode gst_pad_get_mode(GstPad* pad)
{
    return GST_PAD_MODE(pad);
}

static void gst_listener_wakeup(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, ".", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, ".", 1);
#endif
}

static void gst_listener_eos(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, "^", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, "^", 1);
#endif
}

static void on_pad_added(GstElement *element, GstPad *pad, gpointer data)
{
    GstPad *sinkpad;
    GstElement *decoder = (GstElement *) data;

    sinkpad = gst_element_get_static_pad(decoder, "sink");

    gst_pad_link(pad, sinkpad);

    gst_object_unref(sinkpad);
}

static GstFlowReturn on_running(GstElement* object, gpointer user_data)
{
    printf("Running %p\n", object);
    return GST_FLOW_OK;
}

static GstFlowReturn on_overrun(GstElement* object, gpointer user_data)
{
    printf("Overrun %p\n", object);
    return GST_FLOW_OK;
}

static GstFlowReturn on_new_sample(GstElement* object, gpointer user_data)
{
    gst_listener_wakeup(user_data);
    return GST_FLOW_OK;
}

static GstFlowReturn on_eos(GstElement* object, gpointer user_data)
{
    gst_listener_eos(user_data);
    return GST_FLOW_OK;
}

static gulong gst_signal_connect_to(gpointer instance, char* signal, gpointer data)
{
    return g_signal_connect(instance, signal, G_CALLBACK(on_pad_added), data);
}

static gulong gst_queue_connect_running(GstElement* elem)
{
    return g_signal_connect(elem, "running", G_CALLBACK(on_running), NULL);
}

static gulong gst_queue_connect_overrun(GstElement* elem)
{
    return g_signal_connect(elem, "overrun", G_CALLBACK(on_overrun), NULL);
}

static void gst_app_sink_connect_listener_signals(GstElement* elem, void* data)
{
    gst_app_sink_set_emit_signals(GST_APP_SINK(elem), 1);
    g_signal_connect(elem, "new-sample", G_CALLBACK(on_new_sample), data);
    g_signal_connect(elem, "eos", G_CALLBACK(on_eos), data);
}

static GstDiscoverer* gst_discoverer_new_aux()
{
    return gst_discoverer_new(5 * GST_SECOND, NULL);
}

static GstDiscovererInfo* gst_discoverer_discover_uri_aux(GstDiscoverer* disc, char* uri)
{
    GstDiscovererInfo* info;
    GError* err = NULL;
    
    info = gst_discoverer_discover_uri(disc, uri, &err);
    
    if (err)
        g_print(" %s\n", err->message);
    
    return info;
}

static GstDiscovererStreamInfo* gst_discoverer_stream_info_list_data(GList* list)
{
    return (GstDiscovererStreamInfo *) list->data;
}

static GList* gst_discoverer_stream_info_list_next(GList* list)
{
    return list->next;
}

static GstDevice* gst_device_monitor_device_list_data(GList* list)
{
    return (GstDevice *) list->data;
}

static GList* gst_device_monitor_device_list_next(GList* list)
{
    return list->next;
}

static GstTracer* gst_tracer_list_data(GList* list)
{
    return (GstTracer *) list->data;
}

static GList* gst_tracer_list_next(GList* list)
{
    return list->next;
}

static void gst_print_error(GstMessage *msg)
{
    gchar  *debug;
    GError *error;

    gst_message_parse_error(msg, &error, &debug);
    g_free(debug);

    g_printerr("Error: %s\n", error->message);
    g_error_free(error);
}

static int gst_app_sink_try_pull(GstElement* elem, ___SCMOBJ vec, ___SCMOBJ info)
{
    int size;
    ___U8 *data = ___CAST(___U8*, ___BODY(vec));
    int data_size = ___HD_BYTES(___HEADER(vec));
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstSample *sample;
    sample = gst_app_sink_try_pull_sample(GST_APP_SINK(elem), 0);
    if (sample)
    {
        GstBuffer* buffer = gst_sample_get_buffer(sample);
        GstClockTime dts, pts, duration;
        ___U64 keyframe;
        if (buffer)
        {
            GstMapInfo map;
            gst_buffer_map(buffer, &map, GST_MAP_READ);
            if (map.size > data_size)
                size = -2;
            else
            {
                memmove(data, map.data, map.size);
                size = map.size;
            }
            gst_buffer_unmap(buffer, &map);
            
            dts = GST_BUFFER_DTS(buffer);
            pts = GST_BUFFER_PTS(buffer);
            duration = GST_BUFFER_DURATION(buffer);
            keyframe = (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT) ? 0 : 1);
        }
        gst_sample_unref(sample);
        info_ptr[0] = dts;
        info_ptr[1] = pts;
        info_ptr[2] = duration;
        info_ptr[3] = keyframe;
        return size;
    }
    else
        return -1;
}

static GstClockTimeDiff gst_app_src_write(GstElement* elem, ___SCMOBJ vec, int size, ___U64 dts, ___U64 pts, ___U64 duration, GstClockTimeDiff offset)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GST_BUFFER_DTS(buffer) = dts + offset;
    GST_BUFFER_PTS(buffer) = pts + offset;
    GST_BUFFER_DURATION(buffer) = duration;
    gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
    return offset;
}

static GstFlowReturn gst_app_src_write_now(GstElement* elem, ___SCMOBJ vec, int size, ___U64 duration)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static GstFlowReturn gst_app_src_write_pointer_now(GstElement* elem, void* ptr, int size, ___U64 duration)
{
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) gst_element_get_pipeline(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static bool gst_audio_ring_buffer_acquired(GstElement* elem)
{
    GstAudioBaseSink *sink;
    sink = GST_AUDIO_BASE_SINK(elem);
    return gst_audio_ring_buffer_is_acquired(sink->ringbuffer);
}

static void gst_print_pipeline(GstPipeline* pipeline)
{
    GstClockTime delay, latency;
    delay = gst_pipeline_get_delay(pipeline);
    latency = gst_pipeline_get_latency(pipeline);
    printf("INFO pipeline delay %.3f latency %.3f\n", present_time(delay), present_time(latency));
}

static void gst_print_pad(GstElement* elem, char* name)
{
    GstPad* pad = gst_element_get_static_pad(elem, name);
    GstCaps* caps = gst_pad_get_current_caps(pad);
    printf("INFO pad caps %p\n", caps);
    gst_caps_unref(caps);
    gst_object_unref(pad);
}

static void gst_print_message(char* pipeline_name, GstMessage *msg)
{
    switch (GST_MESSAGE_TYPE(msg)) {

        case GST_MESSAGE_EOS: {
            g_print("MESSAGE eos %s\n",
                pipeline_name);
            break;
        }
        case GST_MESSAGE_ERROR: {
            gchar  *debug;
            GError *error;
            gst_message_parse_error(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE error %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_WARNING: {
            gchar  *debug;
            GError *error;
            gst_message_parse_warning(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE warning %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_STATE_CHANGED: {
            GstState old_state, new_state;
            gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
            g_print("MESSAGE state-changed %s %s from %s to %s\n",
                pipeline_name,
                GST_OBJECT_NAME(msg->src),
                gst_element_state_get_name(old_state),
                gst_element_state_get_name(new_state));
            break;
        }
        case GST_MESSAGE_STREAM_STATUS: {
            const char* const names[] = { "CREATE", "ENTER", "LEAVE", "DESTROY", "START", "PAUSE", "STOP" };
            GstStreamStatusType type;
            GstElement *owner;
            gst_message_parse_stream_status(msg, &type, &owner);
            g_print("MESSAGE stream-status %s %s %s\n",
                pipeline_name,
                GST_OBJECT_NAME(owner),
                names[type]);
            break;
        }
        case GST_MESSAGE_NEW_CLOCK: {
            GstClock *clock;
    
            gst_message_parse_new_clock(msg, &clock);
    
            printf("MESSAGE new-clock: %s\n", (clock ? GST_OBJECT_NAME(clock) : "NULL"));
            break;
        }
        case GST_MESSAGE_QOS: {
            GstFormat format;
            guint64 rendered, dropped;
        
            gst_message_parse_qos_stats(msg, &format, &rendered, &dropped);
            if (format == GST_FORMAT_UNDEFINED)
                printf("MESSAGE qos %s UNDEFINED\n",
                    pipeline_name);
            else
                printf("MESSAGE qos %s %s %lu %lu\n",
                    pipeline_name,
                    GST_OBJECT_NAME(msg->src),
                    rendered,
                    dropped);
            break;
        }
        default: {
            printf("MESSAGE %s %s %s\n",
                GST_MESSAGE_TYPE_NAME(msg),
                pipeline_name,
                GST_OBJECT_NAME(msg->src));
            break;
        }
    }
}

static FILE* monitor_file = NULL;

static void gst_monitor_open(char* filename)
{
    monitor_file = fopen(filename, "wb");
}

static void gst_monitor_close()
{
    fclose(monitor_file);
    monitor_file = NULL;
}

static GstTask* gst_pad_task(GstPad* pad)
{
    return GST_PAD_TASK(pad);
}

static void* gst_task_thread(GstTask* task)
{
    return task->thread;
}

static GstPadProbeReturn
cb_block_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_drop_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    return GST_PAD_PROBE_DROP;
}

#define BLOCK_PROBE 0
#define DROP_PROBE  1
#define RATE_PROBE  2

typedef struct probe_any
{
    int probe_kind;
    gulong probe_id;
} any_probe;

typedef struct probe_block
{
    int probe_kind;
    gulong probe_id;
} block_probe;

typedef struct probe_drop
{
    int probe_kind;
    gulong probe_id;
} drop_probe;

static void init_block_probe(block_probe* data, gulong id)
{
    data->probe_kind = BLOCK_PROBE;
    data->probe_id = id;
}

static void free_block_probe(block_probe* data)
{
    free(data);
}

static void init_drop_probe(drop_probe* data, gulong id)
{
    data->probe_kind = DROP_PROBE;
    data->probe_id = id;
}

static void free_drop_probe(drop_probe* data)
{
    free(data);
}

typedef struct probe_rate
{
    int probe_kind;
    gulong probe_id;
    double target_rate;
    double current_rate;
    double first_time;
    int allowed;
    int dropped;
} rate_probe;

static void init_rate_probe(rate_probe* data, gulong id, double rate)
{
    data->probe_kind = RATE_PROBE;
    data->probe_id = id;
    data->target_rate = rate;
    data->current_rate = -1;
    data->first_time = -1;
    data->allowed = 0;
    data->dropped = 0;
}

static void free_rate_probe(rate_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_rate_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    GstBuffer* buffer;
    double time;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    time = GST_TIME_AS_SECONDS((double) GST_BUFFER_PTS(buffer));
    
    rate_probe* data = (rate_probe*) user_data;
    if (data->first_time == -1)
    {
        data->first_time = time;
        data->allowed++;
        return GST_PAD_PROBE_OK;
    }
    else
    {
        double elapsed = time - data->first_time;
        double rate_so_far = data->allowed / elapsed;
        
        if (rate_so_far <= data->target_rate)
        {
            data->allowed++;
            return GST_PAD_PROBE_OK;
        }
        else
        {
            data->dropped++;
            return GST_PAD_PROBE_DROP;
        }
    }
}

static GstPadProbeReturn
cb_have_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    GstBuffer* buffer;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* pad_name;
    gsize size;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    pad_name = gst_pad_get_name(pad);
    size = gst_buffer_get_size(buffer);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime dts = GST_BUFFER_DTS(buffer);
    GstClockTime pts = GST_BUFFER_PTS(buffer);
    GstClockTime clockstamp = gst_clock_get_time(clock) - gst_element_get_base_time(GST_ELEMENT(pipeline));
    // printf("DATA %s %s %s   %ld   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, size, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s   %ld   %.3f   %.3f   %.3f\n", pipeline_name, element_name, pad_name, size, present_time(pts), present_time(clockstamp), present_time(pts) - present_time(clockstamp));
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    size = map.size;
    if (monitor_file)
        fwrite(map.data, size, 1, monitor_file); 
    else
    {
        printf("DATA %s %s %10s %6ld   %.3f   %.3f   %.3f  ", pipeline_name, element_name, pad_name, size, present_time(dts), present_time(pts), present_time(clockstamp));
        int i;
        for (i=0; i < ((size <= 20) ? size : 20); i++)
            printf(" %3d,", map.data[i]);
        printf("\n");
    }
    gst_buffer_unmap(buffer, &map);
    g_free(pad_name);
    g_free(element_name);
    gst_object_unref(clock);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_have_event(GstPad          *pad,
              GstPadProbeInfo *info,
              gpointer         user_data)
{
    GstEvent* event;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    if (GST_EVENT_TYPE(event) == GST_EVENT_CAPS)
    {
        GstCaps *caps;
        gst_event_parse_caps(event, &caps);
        printf("EVENT %s %s %s caps %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_QOS)
    {
        const char* const names[] = { "OVERFLOW", "UNDERFLOW", "THROTTLE" };
        GstQOSType type;
        gdouble proportion;
        GstClockTimeDiff diff;
        GstClockTime timestamp;
        gst_event_parse_qos(event, &type, &proportion, &diff, &timestamp);
        printf("EVENT %s %s %s qos %s %.3f %.3f %.3f\n", pipeline_name, element_name, name, names[type], proportion, present_timediff(diff), present_time(timestamp));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_SEGMENT)
    {
        const GstSegment* segment;
        gst_event_parse_segment (event, &segment);
        printf("EVENT %s %s %s segment %.3f %.3f %.3f %.3f\n", pipeline_name, element_name, name, segment->rate, present_time(segment->start), present_time(segment->stop), present_time(segment->duration));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_LATENCY)
    {
        GstClockTime latency;
        gst_event_parse_latency (event, &latency);
        printf("EVENT %s %s %s latency %.3f\n", pipeline_name, element_name, name, present_time(latency));
    }
    else
        printf("EVENT %s %s %s %s\n", pipeline_name, element_name, name, GST_EVENT_TYPE_NAME(event));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_have_query(GstPad          *pad,
              GstPadProbeInfo *info,
              gpointer         user_data)
{
    GstQuery* query;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    query = GST_PAD_PROBE_INFO_QUERY(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    if (GST_QUERY_TYPE(query) == GST_QUERY_CAPS)
    {
        GstCaps *caps, *result_caps;
        gst_query_parse_caps(query, &caps);
        gst_query_parse_caps_result(query, &result_caps);
        printf("QUERY %s %s %s caps %s ---> %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps), gst_caps_to_string(result_caps));
    }
    if (GST_QUERY_TYPE(query) == GST_QUERY_ACCEPT_CAPS)
    {
        GstCaps *caps;
        gboolean result;
        gst_query_parse_accept_caps(query, &caps);
        gst_query_parse_accept_caps_result(query, &result);
        printf("QUERY %s %s %s accept-caps %s ---> %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps), (result) ? "YES" : "NO");
    }
    else
        printf("QUERY %s %s %s %s\n", pipeline_name, element_name, name, GST_QUERY_TYPE_NAME(query));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static void* gst_pad_add_block_probe(GstPad* pad)
{
    block_probe* data = malloc(sizeof(block_probe));
    gulong id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM, (GstPadProbeCallback) cb_block_data, NULL, NULL);
    
    init_block_probe(data, id);
    
    return (void*) data;
}

static void* gst_pad_add_drop_probe(GstPad* pad)
{
    drop_probe* data = malloc(sizeof(drop_probe));
    gulong id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_drop_data, NULL, NULL);
    
    init_drop_probe(data, id);
    
    return (void*) data;
}

static void* gst_pad_add_rate_probe(GstPad* pad, int rate)
{
    rate_probe* data = malloc(sizeof(rate_probe));
    gulong id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_rate_data, data, NULL);
    
    init_rate_probe(data, id, rate);
    
    return (void*) data;
}

static void gst_pad_probe_free(void* info)
{
    any_probe* data = (any_probe*) info;
    switch (data->probe_kind) {
        case DROP_PROBE: {
            free_drop_probe((drop_probe*) data);
            break;
        }
        case RATE_PROBE: {
            free_rate_probe((rate_probe*) data);
            break;
        }
    }
}

static void gst_pad_remove_probe_aux(GstPad* pad, void* info)
{
    any_probe* data = (any_probe*) info;
    gulong id = data->probe_id;
    
    gst_pad_remove_probe(pad, id);
    gst_pad_probe_free(info);
}

static gulong gst_monitor_data(GstPipeline* pipeline, GstPad* pad)
{
    return gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_have_data, pipeline, NULL);
}

static gulong gst_monitor_events(GstPipeline* pipeline, GstPad* pad)
{
    return gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_BOTH, (GstPadProbeCallback) cb_have_event, pipeline, NULL);
}

static gulong gst_monitor_queries(GstPipeline* pipeline, GstPad* pad)
{
    return gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_QUERY_BOTH, (GstPadProbeCallback) cb_have_query, pipeline, NULL);
}

static void gst_monitor_remove(GstPad* pad, gulong id)
{
    gst_pad_remove_probe(pad, id);
}

static GstBusSyncReply bus_sync_handler(GstBus* bus,
                                        GstMessage* message,
                                        gpointer user_data)
{
    GstPipeline* pipeline = (GstPipeline*) user_data;
    char* name = GST_OBJECT_NAME(pipeline);
    
    gst_print_message(name, message);
    
    return GST_BUS_PASS;
}

static void gst_monitor_messages(GstPipeline* pipeline)
{
    GstBus* bus = gst_pipeline_get_bus(pipeline);
    gst_bus_set_sync_handler(bus,
                             bus_sync_handler,
                             pipeline,
                             NULL);
    gst_object_unref(bus);
}

static void gst_debug_bin_to_dot_file_aux(GstBin* bin, char* filename)
{
    gst_debug_bin_to_dot_file(bin, GST_DEBUG_GRAPH_SHOW_ALL, filename);
}
//#)


(gst-external (gst_init NULL NULL) void)
(gst-external (gst_deinit) void)
(gst-external (gst_version_fill scheme-object) void)
(gst-external (gst_parse_launch_aux char-string scheme-object scheme-object) scheme-object)
(gst-external (gst_parse_bin_from_description_aux char-string gboolean scheme-object scheme-object) scheme-object)
(gst-external (gst_object_refcount (call GST_OBJECT gpointer)) int "gst_object_refcount")
(gst-external (gst_object_get_name (call GST_OBJECT gpointer)) char-string)
(c-external (gst_object_get_name_untraced (call GST_OBJECT gpointer)) char-string "gst_object_get_name")
(gst-external (gst_object_set_name (call GST_OBJECT gpointer) char-string) gboolean)
(gst-external (gst_object_unref gpointer) void)
(gst-external (gst_value_get_fraction_numerator GValue*) int)
(gst-external (gst_value_get_fraction_denominator GValue*) int)
(gst-external (gst_value_set_fraction GValue* int int) void)
(gst-external (gst_value_get_buffer GValue*) GstBuffer*)
(gst-external (gst_pad_get_name GstPad*) char-string)
(gst-external (gst_pad_get_mode GstPad*) GstPadMode)
(gst-external (gst_pad_get_allowed_caps GstPad*) GstCaps*)
(gst-external (gst_pad_has_current_caps GstPad*) bool)
(gst-external (gst_pad_get_current_caps GstPad*) GstCaps*)
(gst-external (gst_pad_query_caps GstPad* GstCaps*) GstCaps*)
(gst-external (gst_pad_get_direction GstPad*) GstPadDirection)
(gst-external (gst_pad_get_parent_element GstPad*) GstElement*)
(gst-external (gst_pad_get_peer GstPad*) GstPad*)
(gst-external (gst_pad_task GstPad*) GstTask*)
(gst-external (gst_pad_is_active GstPad*) gboolean)
(gst-external (gst_pad_is_linked GstPad*) gboolean)
(gst-external (gst_pad_link GstPad* GstPad*) GstPadLinkReturn)
(gst-external (gst_pad_add_block_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_drop_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_rate_probe GstPad* int) :alloc void*)
(gst-external (gst_pad_remove_probe GstPad* void*) (:free 2) void "gst_pad_remove_probe_aux")
(gst-external (gst_pad_probe_free void*) :free void "gst_pad_probe_free")
(gst-external (gst_pad_push_event GstPad* GstEvent*) gboolean)
(gst-external (gst_ghost_pad_new char-string GstPad*) GstPad*)
(gst-external (gst_task_thread GstTask*) void*)
(gst-external (gst_caps_new_empty_simple char-string) GstCaps*)
(gst-external (gst_caps_from_string char-string) GstCaps*)
(gst-external (gst_caps_is_fixed GstCaps*) gboolean)
(gst-external (gst_caps_get_size GstCaps*) guint)
(gst-external (gst_caps_get_structure GstCaps* int) GstStructure*)
(gst-external (gst_caps_set_value GstCaps* char-string GValue*) void)
(gst-external (gst_caps_to_string GstCaps*) char-string-free)
(gst-external (gst_caps_unref GstCaps*) void)
(gst-external (gst_structure_get_name GstStructure*) char-string "gst_structure_get_name_aux")
(gst-external (gst_structure_get_int GstStructure* char-string) int "gst_structure_get_int_aux")
(gst-external (gst_structure_get_uint64 GstStructure* char-string) uint64 "gst_structure_get_uint64_aux")
(gst-external (gst_structure_get_double GstStructure* char-string) double "gst_structure_get_double_aux")
(gst-external (gst_structure_get_value GstStructure* char-string) GValue* "gst_structure_get_value_aux")
(gst-external (gst_structure_to_string GstStructure*) char-string)
(gst-external (gst_buffer_new_allocate gsize) GstBuffer* "gst_buffer_new_allocate_aux")
(gst-external (gst_buffer_new_wrapped gpointer gsize) GstBuffer*)
(gst-external (gst_buffer_get_size GstBuffer*) int)
(gst-external (gst_buffer_get_pts GstBuffer*) GstClockTime)
(gst-external (gst_buffer_get_dts GstBuffer*) GstClockTime)
(gst-external (gst_buffer_get_duration GstBuffer*) GstClockTime)
(gst-external (gst_buffer_set_pts GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_set_dts GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_set_duration GstBuffer* GstClockTime) void)
(gst-external (gst_buffer_unref GstBuffer*) void)
(gst-external (gst_adapter_new) GstAdapter*)
(gst-external (gst_adapter_clear GstAdapter*) void)
(gst-external (gst_adapter_flush GstAdapter* gsize) void)
(gst-external (gst_adapter_push GstAdapter* GstBuffer*) void)
(gst-external (gst_adapter_available GstAdapter*) gsize)
(gst-external (gst_adapter_prev_pts GstAdapter* scheme-object) GstClockTime "gst_adapter_prev_pts_aux")
(gst-external (gst_adapter_take_buffer GstAdapter* gsize) GstBuffer*)
(gst-external (gst_element_set_state_threaded GstElement* GstState void*) :alloc void*)
(gst-external (gst_element_set_state_free void*) :free void)
(gst-external (gst_element_set_state_blocking GstElement* GstState) GstStateChangeReturn)
(gst-external (gst_element_sync_state_with_parent GstElement*) gboolean)
(gst-external (gst_element_get_state GstElement*) GstState "gst_element_get_state_aux")
(gst-external (gst_element_wait_state GstElement*) void "gst_element_wait_state_aux")
(gst-external (gst_element_seek_simple GstElement* GstFormat GstSeekFlags int64) gboolean)
(gst-external (gst_element_send_event GstElement* GstEvent*) gboolean)
(gst-external (gst_element_get_bus GstElement*) GstBus*)
(gst-external (gst_element_get_base_time GstElement*) GstClockTime)
(gst-external (gst_element_get_parent GstElement*) GstElement*)
(c-external (gst_element_get_parent_untraced GstElement*) GstElement* "gst_element_get_parent")
(gst-external (gst_element_get_pipeline GstElement*) GstElement*)
(gst-external (gst_element_get_running_time GstElement*) GstClockTime)
(gst-external (gst_element_get_clock GstElement*) GstClock*)
(gst-external (gst_element_factory_make char-string char-string) GstElement*)
(gst-external (gst_element_add_pad GstElement* GstPad*) gboolean)
(gst-external (gst_element_link GstElement* GstElement*) gboolean)
(gst-external (gst_element_link_pads GstElement* char-string GstElement* char-string) gboolean)
(gst-external (gst_element_unlink GstElement* GstElement*) void)
(gst-external (gst_element_get_static_pad GstElement* char-string) GstPad*)
(gst-external (gst_element_get_request_pad GstElement* char-string) GstPad*)
(gst-external (gst_element_release_request_pad GstElement* GstPad*) void)
(gst-external (gst_element_iterate_pads GstElement*) GstIterator*)
(gst-external (gst_element_iterate_sink_pads GstElement*) GstIterator*)
(gst-external (gst_element_iterate_src_pads GstElement*) GstIterator*)
(gst-external (gst_element_query GstElement* GstQuery*) gboolean)
(gst-external (gst_element_query_latency GstElement* scheme-object) void "gst_element_query_latency_aux")
(gst-external (gst_element_query_segment GstElement* GstFormat scheme-object) void "gst_element_query_segment_aux")
(gst-external (gst_element_query_position GstElement* GstFormat) int64 "gst_element_query_position_aux")
(gst-external (gst_element_query_duration GstElement* GstFormat) int64 "gst_element_query_duration_aux")
(gst-external (gst_iterator_next_element GstIterator*) GstElement*)
(gst-external (gst_iterator_next_pad GstIterator*) GstPad*)
(gst-external (gst_iterator_free GstIterator*) void)
(gst-external (gst_signal_connect_to gpointer char-string gpointer) gulong)
(gst-external (gst_bus_timed_pop_filtered GstBus* GstClockTime GstMessageType) GstMessage*)
(gst-external (gst_bus_pop GstBus*) GstMessage*)
(gst-external (gst_bin_add (call GST_BIN GstElement*) GstElement*) gboolean)
(gst-external (gst_bin_remove (call GST_BIN GstElement*) GstElement*) gboolean)
(gst-external (gst_bin_get_by_name_aux (call GST_BIN GstElement*) char-string) GstElement* "gst_bin_get_by_name")
(gst-external (gst_bin_iterate_elements (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_iterate_sorted (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_iterate_recurse (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_bin_recalculate_latency (call GST_BIN GstElement*)) gboolean)
(gst-external (gst_debug_bin_to_dot_file (call GST_BIN GstElement*) char-string) void "gst_debug_bin_to_dot_file_aux")
(gst-external (gst_pipeline_new char-string) GstElement*)
(gst-external (gst_is_pipeline GstElement*) bool)
(gst-external (gst_pipeline_get_bus (call GST_PIPELINE GstElement*)) GstBus*)
(gst-external (gst_pipeline_get_clock (call GST_PIPELINE GstElement*)) GstClock*)
(gst-external (gst_pipeline_get_time (call GST_PIPELINE GstElement*)) GstClockTime)
(gst-external (gst_pipeline_get_latency (call GST_PIPELINE GstElement*)) GstClockTime)
(gst-external (gst_pipeline_set_latency (call GST_PIPELINE GstElement*) GstClockTime) void)
(gst-external (gst_is_base_sink GstElement*) bool)
(gst-external (gst_base_sink_get_latency (call GST_BASE_SINK GstElement*)) GstClockTime)
(gst-external (gst_event_new_eos) GstEvent*)
(gst-external (gst_event_new_stream_start char-string) GstEvent*)
(gst-external (gst_event_new_latency GstClockTime) GstEvent*)
(gst-external (gst_event_new_caps GstCaps*) GstEvent*)
(gst-external (gst_message_state_changed_get_new_state GstMessage*) GstState)
(gst-external (gst_message_unref GstMessage*) void)
(gst-external (gst_system_clock_get_time) GstClockTime)
(gst-external (gst_clock_get_time GstClock*) GstClockTime)
(gst-external (gst_discoverer_new) GstDiscoverer* "gst_discoverer_new_aux")
(gst-external (gst_discoverer_discover_uri GstDiscoverer* char-string) GstDiscovererInfo* "gst_discoverer_discover_uri_aux")
(gst-external (gst_discoverer_info_get_duration GstDiscovererInfo*) GstClockTime)
(gst-external (gst_discoverer_info_get_stream_info GstDiscovererInfo*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_stream_info_get_caps GstDiscovererStreamInfo*) GstCaps*)
(gst-external (gst_discoverer_stream_info_get_next GstDiscovererStreamInfo*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_container_info_get_streams (call GST_DISCOVERER_CONTAINER_INFO GstDiscovererStreamInfo*)) GList*)
(gst-external (gst_discoverer_stream_info_list_data GList*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_stream_info_list_next GList*) GList*)
(gst-external (gst_discoverer_stream_info_list_free GList*) void)
(gst-external (gst_discoverer_audio_info_get_bitrate (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_audio_info_get_sample_rate (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_audio_info_get_channels (call GST_DISCOVERER_AUDIO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_width (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_height (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_bitrate (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_framerate_num (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_framerate_denom (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_device_monitor_new) GstDeviceMonitor*)
(gst-external (gst_device_monitor_add_filter GstDeviceMonitor* char-string GstCaps*) guint)
(gst-external (gst_device_monitor_start GstDeviceMonitor*) gboolean)
(gst-external (gst_device_monitor_stop GstDeviceMonitor*) void)
(gst-external (gst_device_monitor_get_devices GstDeviceMonitor*) GList*)
(gst-external (gst_device_monitor_device_list_data GList*) GstDevice*)
(gst-external (gst_device_monitor_device_list_next GList*) GList*)
(gst-external (gst_device_create_element GstDevice* NULL) GstElement*)
(gst-external (gst_device_get_caps GstDevice*) GstCaps*)
(gst-external (gst_device_get_device_class GstDevice*) char-string)
(gst-external (gst_device_get_display_name GstDevice*) char-string)
(gst-external (gst_present_time GstClockTime) double "present_time")
(gst-external (gst_print_pipeline (call GST_PIPELINE GstElement*)) void)
(gst-external (gst_print_pad GstElement* char-string) void)
(gst-external (gst_print_message char-string GstMessage*) void)
(gst-external (gst_print_error GstMessage*) void)
(gst-external (gst_monitor_open char-string) void)
(gst-external (gst_monitor_close) void)
(gst-external (gst_monitor_data (call GST_PIPELINE GstElement*) GstPad*) gulong)
(gst-external (gst_monitor_events (call GST_PIPELINE GstElement*) GstPad*) gulong)
(gst-external (gst_monitor_queries (call GST_PIPELINE GstElement*) GstPad*) gulong)
(gst-external (gst_monitor_remove GstPad* gulong) void)
(gst-external (gst_monitor_messages (call GST_PIPELINE GstElement*)) void)
(gst-external (gst_queue_connect_running GstElement*) gulong)
(gst-external (gst_queue_connect_overrun GstElement*) gulong)
(gst-external (gst_app_src_get_caps (call GST_APP_SRC GstElement*)) GstCaps*)
(gst-external (gst_app_src_set_caps (call GST_APP_SRC GstElement*) GstCaps*) void)
(gst-external (gst_app_src_set_stream_type (call GST_APP_SRC GstElement*) GstAppStreamType) void)
(gst-external (gst_app_src_write GstElement* scheme-object int uint64 uint64 uint64 GstClockTimeDiff) GstClockTimeDiff)
(gst-external (gst_app_src_write_now GstElement* scheme-object int uint64) GstFlowReturn)
(gst-external (gst_app_src_write_pointer_now GstElement* void* int uint64) GstFlowReturn)
(gst-external (gst_app_sink_connect_listener_signals GstElement* void*) void)
(gst-external (gst_app_sink_try_pull GstElement* scheme-object scheme-object) int)
(gst-external (gst_app_sink_is_eos (call GST_APP_SINK GstElement*)) bool)
(gst-external (gst_audio_ring_buffer_acquired GstElement*) bool)
(gst-external (gst_tracing_get_active_tracers) GList*)
(gst-external (gst_tracer_list_data GList*) GstTracer*)
(gst-external (gst_tracer_list_next GList*) GList*)
(gst-external (gst_debug_bin_to_dot_file (call GST_BIN GstElement*) int char-string) void)
(gst-external (GST_TYPE_FRACTION) GType "___return(GST_TYPE_FRACTION);")
(gst-external (GST_MESSAGE_TYPE GstMessage*) GstMessageType)
(gst-external (GST_MESSAGE_SRC GstMessage*) GstElement*)


;; to enable testing wasapi use the blocking api as a work
;; around wasapi not initializing com multithreaded on windows
@wasapi
(definition public gst_element_set_state
  gst_element_set_state_blocking)


;; non-blocking listener-based set state
;; - for some reason this is needed for screen share
;; - without it it will not work on windows and on some
;;   macs turning screen share off will result in a crash
;; - the non-blocking set state might also result in a better
;;   behavior by not being in a C call during a blocking set state
(definition public (gst_element_set_state elem state)
  (let ((listener (open-stream-listener)))
    (let ((data (gst_element_set_state_threaded elem state (get-write-file listener))))
      (let ((c (wait listener)))
        (assert (eqv? c #\!)
          (gst_element_set_state_free data)
          (close-stream-listener listener))))))


(gst-external (move-u8vector->pointer! scheme-object void*) void
  #/C/
    memmove(___arg2, ___BODY(___arg1), ___HD_BYTES(___HEADER(___arg1)));
//#)


(gst-external (move-pointer->u8vector! void* scheme-object) void
  #/C/
    memmove(___BODY(___arg2), ___arg1, ___HD_BYTES(___HEADER(___arg2)));
//#)


(gst-external (separate-alpha void* void* int) void
  #/C/
    char* data = (char*) ___arg1;
    char* alpha = (char*) ___arg2;
    int count = ___arg3;
    
    data += 3;
    while (count > 0)
    {
        *alpha++ = *data;
        data += 4;
        count--;
    }
//#)


(gst-external (combine-alpha scheme-object scheme-object void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char* alpha = (char*) ___BODY(___arg2);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *alpha++;
        color++;
        count--;
    }
//#)


(gst-external (add-alpha scheme-object float void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char alpha = (char) (___arg2 * 255);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = alpha;
        color++;
        count--;
    }
//#)


;;;
;;;; Startup
;;;


(definition gstreamer-initialized?
  #f)


(definition public (startup-gstreamer)
  (unless gstreamer-initialized?
    (gst_init)
    (set! gstreamer-initialized? #t)))


(definition public (shutdown-gstreamer)
  (when gstreamer-initialized?
    (set! gstreamer-initialized? #f)))


(startup-gstreamer))
