;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; GStreamer Foreign
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.stream.foreign jazz


(import (jazz.foreign)
        (jazz.listener)
        (jazz.platform.types)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax)))


;;;
;;;; Trace
;;;


(define-setting trace-gst?
  #f)

(define-setting trace-gst
  (lambda (name rest)
    (define (present obj)
      (cond ((u8vector? obj)
             (list 'u8vector (u8vector-length obj)))
            (else
             obj)))
    
    (apply terminal name (map present rest))))


;;;
;;;; GLib
;;;


(c-include "<stdbool.h>")
(c-include "<string.h>")
(c-include "<stdlib.h>")
(c-include "<stdio.h>")
(c-include "<unistd.h>")
(c-include "<fcntl.h>")
(c-include "<glib.h>")
(c-include "<gst/gst.h>")
(c-include "<gst/app/gstappsrc.h>")
(c-include "<gst/app/gstappsink.h>")
(c-include "<gst/pbutils/pbutils.h>")


(c-type gint     int)
(c-type guint    uint)
(c-type gulong   ulong)
(c-type gboolean gint)
(c-type gpointer void*)
(c-type GType    enum)


(c-type GValue   (native "GValue"))
(c-type GValue*  (pointer "GValue" GValue*))
(c-type GObject  (native "GObject"))
(c-type GObject* (pointer GObject #f))
(c-type GThread  (native "GThread"))
(c-type GThread* (pointer GThread GThread*))


(c-enumerant G_TYPE_BOOLEAN)
(c-enumerant G_TYPE_INT)
(c-enumerant G_TYPE_UINT64)
(c-enumerant G_TYPE_DOUBLE)
(c-enumerant G_TYPE_STRING)


(c-declare jazz.stream.foreign #/C/
static int g_object_get_int(GObject* obj, char* name)
{
    int d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static bool g_object_get_boolean(GObject* obj, char* name)
{
    bool d;
    g_object_get(obj, name, &d, NULL);
    return d;
}

static double g_object_get_double(GObject* obj, char* name)
{
    double d;
    g_object_get(obj, name, &d, NULL);
    return d;
}
//#)


(c-external (g_value_new GType) :alloc GValue*
  #/C/
    GValue* value = (GValue*) calloc(sizeof(GValue), 1);
    g_value_init(value, ___arg1);
    ___return(value);
//#)

(c-external (g_value_free GValue*) :free void
  #/C/
    g_value_unset(___arg1);
    free(___arg1);
//#)


(c-external (g_value_get_boolean GValue*) bool)
(c-external (g_value_set_boolean GValue* bool) void)
(c-external (g_value_get_int GValue*) int)
(c-external (g_value_set_int GValue* int) void)
(c-external (g_value_get_uint64 GValue*) uint64)
(c-external (g_value_set_uint64 GValue* uint64) void)
(c-external (g_value_get_double GValue*) double)
(c-external (g_value_set_double GValue* double) void)
(c-external (g_value_get_string GValue*) (cast char-string))
(c-external (g_value_set_string GValue* char-string) void)
(c-external (g_object_get_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_set_property (call G_OBJECT GObject*) char-string GValue*) void)
(c-external (g_object_get_boolean (call G_OBJECT GObject*) char-string) bool "g_object_get_boolean")
(c-external (g_object_set_boolean (call G_OBJECT GObject*) char-string bool NULL) void "g_object_set")
(c-external (g_object_get_int (call G_OBJECT GObject*) char-string) int "g_object_get_int")
(c-external (g_object_set_int (call G_OBJECT GObject*) char-string int NULL) void "g_object_set")
(c-external (g_object_get_double (call G_OBJECT GObject*) char-string) double "g_object_get_double")
(c-external (g_object_set_double (call G_OBJECT GObject*) char-string double NULL) void "g_object_set")
(c-external (g_object_set_string (call G_OBJECT GObject*) char-string char-string NULL) void "g_object_set")


;;;
;;;; GStreamer
;;;


(c-enumerant GST_STATE_NULL)
(c-enumerant GST_STATE_READY)
(c-enumerant GST_STATE_PAUSED)
(c-enumerant GST_STATE_PLAYING)
(c-enumerant GST_CLOCK_TIME_NONE "U64")
(c-enumerant GST_MESSAGE_EOS)
(c-enumerant GST_MESSAGE_ERROR)
(c-enumerant GST_MESSAGE_WARNING)
(c-enumerant GST_MESSAGE_STATE_CHANGED)
(c-enumerant GST_MESSAGE_STREAM_STATUS)
(c-enumerant GST_MESSAGE_QOS)
(c-enumerant GST_FORMAT_TIME)
(c-enumerant GST_EVENT_CAPS)
(c-enumerant GST_SEEK_FLAG_FLUSH)
(c-enumerant GST_APP_STREAM_TYPE_STREAM)
(c-enumerant GST_APP_STREAM_TYPE_SEEKABLE)
(c-enumerant GST_APP_STREAM_TYPE_RANDOM_ACCESS)
(c-enumerant GST_PAD_UNKNOWN)
(c-enumerant GST_PAD_SRC)
(c-enumerant GST_PAD_SINK)


(c-type GstClockTime         uint64)
(c-type GstStateChangeReturn enum)
(c-type GstState             enum)
(c-type GstFormat            enum)
(c-type GstMessageType       enum)
(c-type GstFlowReturn        enum)
(c-type GstAppStreamType     enum)
(c-type GstSeekFlags         enum)
(c-type GstPadDirection      enum)


(c-type GstElement               (native "GstElement"))
(c-type GstElement*              (pointer GstElement GstElement*))
(c-type GstPad                   (native "GstPad"))
(c-type GstPad*                  (pointer GstPad GstPad*))
(c-type GstCaps                  (native "GstCaps"))
(c-type GstCaps*                 (pointer GstCaps GstCaps*))
(c-type GstStructure             (native "GstStructure"))
(c-type GstStructure*            (pointer GstStructure GstStructure*))
(c-type GstBuffer                (native "GstBuffer"))
(c-type GstBuffer*               (pointer GstBuffer GstBuffer*))
(c-type GstBin                   (native "GstBin"))
(c-type GstBin*                  (pointer GstBin GstBin*))
(c-type GstPipeline              (native "GstPipeline"))
(c-type GstPipeline*             (pointer GstPipeline GstPipeline*))
(c-type GstBus                   (native "GstBus"))
(c-type GstBus*                  (pointer GstBus GstBus*))
(c-type GstClock                 (native "GstClock"))
(c-type GstClock*                (pointer GstClock GstClock*))
(c-type GstEvent                 (native "GstEvent"))
(c-type GstEvent*                (pointer GstEvent GstEvent*))
(c-type GstMessage               (native "GstMessage"))
(c-type GstMessage*              (pointer GstMessage GstMessage*))
(c-type GstIterator              (native "GstIterator"))
(c-type GstIterator*             (pointer GstIterator GstIterator*))
(c-type GstDiscoverer            (native "GstDiscoverer"))
(c-type GstDiscoverer*           (pointer GstDiscoverer GstDiscoverer*))
(c-type GstDiscovererInfo        (native "GstDiscovererInfo"))
(c-type GstDiscovererInfo*       (pointer GstDiscovererInfo GstDiscovererInfo*))
(c-type GstDiscovererStreamInfo  (native "GstDiscovererStreamInfo"))
(c-type GstDiscovererStreamInfo* (pointer GstDiscovererStreamInfo GstDiscovererStreamInfo*))


(c-declare jazz.stream.foreign #/C/
static int gst_version_fill(___SCMOBJ info)
{
    ___U32 *ptr = ___CAST(___U32*, ___BODY(info));
  
    guint major, minor, micro, nano;
    
    gst_version(&major, &minor, &micro, &nano);
    
    ptr[0] = major;
    ptr[1] = minor;
    ptr[2] = micro;
    ptr[3] = nano;
}

static int gst_structure_get_int_aux(GstStructure* struc, char* name)
{
    int result;
    
    gst_structure_get_int(struc, name, &result);
    
    return result;
}

static GValue* gst_structure_get_value_aux(GstStructure* struc, char* name)
{
    return (GValue*) gst_structure_get_value(struc, name);
}

static void gst_listener_set(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, "!", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, "!", 1);
#endif
}

typedef struct state_element
{
    GstElement* element;
    GstState state;
    void* desc;
    GThread* thread;
} element_state;

static void* set_state(void* data)
{
    element_state* es = (element_state*) data;
    GstElement* elem = es->element;
    GstState state = es->state;
    void* desc = es->desc;
  
    ___mask_heartbeat_interrupts_state heartbeat_interrupts;
    ___EXT(___mask_heartbeat_interrupts_begin)(&heartbeat_interrupts);
    gst_element_set_state(elem, state);
    ___EXT(___mask_heartbeat_interrupts_end)(&heartbeat_interrupts);
    
    gst_listener_set(desc);
  
    return NULL;
}

static void* gst_element_set_state_threaded(GstElement* elem, GstState state, void* desc)
{
    element_state* es = malloc(sizeof(element_state));
    es->element = elem;
    es->state = state;
    es->desc = desc;
    es->thread = g_thread_new("set_state", set_state, (void*) es);
    
    return (void*) es;
}

static void gst_element_set_state_free(void* data)
{
    element_state* es = (element_state*) data;
    g_thread_join(es->thread);
    g_thread_unref(es->thread);
    free(data);
}

static GstStateChangeReturn gst_element_set_state_blocking(GstElement* elem, GstState state)
{
    GstStateChangeReturn state_change;
  
    ___mask_heartbeat_interrupts_state heartbeat_interrupts;
    ___EXT(___mask_heartbeat_interrupts_begin)(&heartbeat_interrupts);
    state_change = gst_element_set_state(elem, state);
    ___EXT(___mask_heartbeat_interrupts_end)(&heartbeat_interrupts);
  
    return state_change;
}

static GstState gst_element_get_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, 0);
    return state;
}

static void gst_element_wait_state_aux(GstElement* elem)
{
    GstState state, pending;
    gst_element_get_state(elem, &state, &pending, GST_CLOCK_TIME_NONE);
}

static gint64 gst_element_query_position_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_position(elem, format, &pos);
    return pos;
}

static gint64 gst_element_query_duration_aux(GstElement* elem, GstFormat format)
{
    gint64 pos;
    gst_element_query_duration(elem, format, &pos);
    return pos;
}

static GstState gst_message_state_changed_get_new_state(GstMessage *msg)
{
    GstState old_state, new_state;
    gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
    return new_state;
}

static GstElement* gst_iterator_next_element(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstElement*) g_value_get_object(&elem);
}

static GstPad* gst_iterator_next_pad(GstIterator *it)
{
    GValue elem = G_VALUE_INIT;
    GstIteratorResult result = gst_iterator_next(it, &elem);
    if (result == GST_ITERATOR_DONE)
        return NULL;
    else
        return (GstPad*) g_value_get_object(&elem);
}

static void gst_listener_wakeup(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, ".", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, ".", 1);
#endif
}

static void gst_listener_eos(void* user_data)
{
#ifdef _WIN32
    SOCKET socket = (SOCKET) user_data;
    send(socket, "^", 1, 0);
#else
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    int fd = (int) user_data;
    #pragma GCC diagnostic pop
    
    write(fd, "^", 1);
#endif
}

static void on_pad_added(GstElement *element, GstPad *pad, gpointer data)
{
    GstPad *sinkpad;
    GstElement *decoder = (GstElement *) data;

    sinkpad = gst_element_get_static_pad(decoder, "sink");

    gst_pad_link(pad, sinkpad);

    gst_object_unref(sinkpad);
}

static GstFlowReturn on_new_sample(GstElement* object, gpointer user_data)
{
    gst_listener_wakeup(user_data);
    return GST_FLOW_OK;
}

static GstFlowReturn on_eos(GstElement* object, gpointer user_data)
{
    gst_listener_eos(user_data);
    return GST_FLOW_OK;
}

static gulong gst_signal_connect_to(gpointer instance, char* signal, gpointer data)
{
    return g_signal_connect(instance, signal, G_CALLBACK(on_pad_added), data);
}

static void gst_app_sink_connect_listener_signals(GstElement* elem, void* data)
{
    gst_app_sink_set_emit_signals(GST_APP_SINK(elem), 1);
    g_signal_connect(elem, "new-sample", G_CALLBACK(on_new_sample), data);
    g_signal_connect(elem, "eos", G_CALLBACK(on_eos), data);
}

static GstDiscoverer* gst_discoverer_new_aux()
{
    return gst_discoverer_new(5 * GST_SECOND, NULL);
}

static GstDiscovererInfo* gst_discoverer_discover_uri_aux(GstDiscoverer* disc, char* uri)
{
    GstDiscovererInfo* info;
    GError* err;
    
    info = gst_discoverer_discover_uri(disc, uri, &err);
    
    if (err)
        g_print(" %s\n", err->message);
    
    return info;
}

static int gst_discoverer_video_info_get_width_aux(GstDiscovererInfo* info)
{
    GstDiscovererVideoInfo* video_info = (GstDiscovererVideoInfo*) info;
  
    return gst_discoverer_video_info_get_width(video_info);
}

static void gst_print_error(GstMessage *msg)
{
    gchar  *debug;
    GError *error;

    gst_message_parse_error(msg, &error, &debug);
    g_free(debug);

    g_printerr("Error: %s\n", error->message);
    g_error_free(error);
}

static double present_time(GstClockTime time)
{
    if (time == GST_CLOCK_TIME_NONE)
        return -1;
    else
        return GST_TIME_AS_SECONDS((double) time);
}

static double present_timediff(GstClockTimeDiff diff)
{
    if (diff == GST_CLOCK_TIME_NONE)
        return -1;
    else
        return GST_TIME_AS_SECONDS((double) diff);
}

static int gst_app_sink_try_pull(GstElement* elem, ___SCMOBJ vec, ___SCMOBJ info)
{
    int size;
    ___U8 *data = ___CAST(___U8*, ___BODY(vec));
    ___U64 *info_ptr = ___CAST(___U64*, ___BODY(info));
    GstSample *sample;
    sample = gst_app_sink_try_pull_sample(GST_APP_SINK(elem), 0);
    if (sample)
    {
        GstBuffer* buffer = gst_sample_get_buffer(sample);
        GstClockTime pts, duration;
        if (buffer)
        {
            GstMapInfo map;
            gst_buffer_map(buffer, &map, GST_MAP_READ);
            memmove(data, map.data, map.size);
            size = map.size;
            gst_buffer_unmap(buffer, &map);
            
            pts = GST_BUFFER_PTS(buffer);
            duration = GST_BUFFER_DURATION(buffer);
               
            // return the clock time of buffer instead of pts
            // as a way of ensuring a monotonic sequence of pts
            // shielding us from h264 adjusting pts
            GstSegment* segment = gst_sample_get_segment(sample);
            GstClockTime base_time = gst_element_get_base_time(elem);
            GstClockTime running_time = gst_segment_to_running_time(segment, GST_FORMAT_TIME, pts);
            pts = base_time + running_time;
        }
        gst_sample_unref(sample);
        // not completely sure about this hack around audio receiving
        // GST_CLOCK_TIME_NONE PTS in the first two frames. note that
        // just dropping them by returning -1 makes audio not work at
        // the receiver side for some reason
        info_ptr[0] = (pts == GST_CLOCK_TIME_NONE) ? 0 : pts;
        info_ptr[1] = duration;
        return size;
    }
    else
        return -1;
}

static GstFlowReturn gst_app_src_write(GstElement* elem, ___SCMOBJ vec, int size, ___S64 timestamp, ___U64 duration)
{
    ___U8 *ptr = ___CAST(___U8*, ___BODY(vec));
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) GST_ELEMENT_PARENT(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time + timestamp;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static GstFlowReturn gst_app_src_write_pointer(GstElement* elem, void* ptr, int size, ___S64 timestamp, ___U64 duration)
{
    GstBuffer *buffer = gst_buffer_new_allocate(NULL, size, NULL);
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_WRITE);
    memmove(map.data, ptr, size);
    gst_buffer_unmap(buffer, &map);
    GstPipeline* pipeline = (GstPipeline*) GST_ELEMENT_PARENT(elem);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime base_time = gst_element_get_base_time(elem);
    GstClockTime abs_time = gst_clock_get_time(clock);
    GST_BUFFER_PTS(buffer) = abs_time - base_time + timestamp;
    GST_BUFFER_DTS(buffer) = GST_BUFFER_PTS(buffer);
    GST_BUFFER_DURATION(buffer) = duration;
    gst_object_unref(clock);
    return gst_app_src_push_buffer(GST_APP_SRC(elem), buffer);
}

static void gst_print_pipeline(GstPipeline* pipeline)
{
    GstClockTime delay, latency;
    delay = gst_pipeline_get_delay(pipeline);
    latency = gst_pipeline_get_latency(pipeline);
    printf("INFO pipeline delay %.3f latency %.3f\n", present_time(delay), present_time(latency));
}

static void gst_print_pad(GstElement* elem, char* name)
{
    GstPad* pad = gst_element_get_static_pad(elem, name);
    GstCaps* caps = gst_pad_get_current_caps(pad);
    printf("INFO pad caps %p\n", caps);
    gst_caps_unref(caps);
    gst_object_unref(pad);
}

static void gst_print_message(char* pipeline_name, GstMessage *msg)
{
    switch (GST_MESSAGE_TYPE(msg)) {

        case GST_MESSAGE_EOS: {
            g_print("MESSAGE eos %s\n",
                pipeline_name);
            break;
        }
        case GST_MESSAGE_ERROR: {
            gchar  *debug;
            GError *error;
            gst_message_parse_error(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE error %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_WARNING: {
            gchar  *debug;
            GError *error;
            gst_message_parse_warning(msg, &error, &debug);
            g_free(debug);
            g_printerr("MESSAGE warning %s %s %s\n",
                pipeline_name,
                GST_MESSAGE_SRC_NAME(msg),
                error->message);
            g_error_free(error);
            break;
        }
        case GST_MESSAGE_STATE_CHANGED: {
            GstState old_state, new_state;
            gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
            g_print("MESSAGE state-changed %s %s from %s to %s\n",
                pipeline_name,
                GST_OBJECT_NAME(msg->src),
                gst_element_state_get_name(old_state),
                gst_element_state_get_name(new_state));
            break;
        }
        case GST_MESSAGE_STREAM_STATUS: {
            const char* const names[] = { "CREATE", "ENTER", "LEAVE", "DESTROY", "START", "PAUSE", "STOP" };
            GstStreamStatusType type;
            GstElement *owner;
            gst_message_parse_stream_status(msg, &type, &owner);
            g_print("MESSAGE stream-status %s %s %s\n",
                pipeline_name,
                GST_OBJECT_NAME(owner),
                names[type]);
            break;
        }
        case GST_MESSAGE_QOS: {
            GstFormat format;
            guint64 rendered, dropped;
        
            gst_message_parse_qos_stats(msg, &format, &rendered, &dropped);
            if (format == GST_FORMAT_UNDEFINED)
                printf("MESSAGE qos %s UNDEFINED\n",
                    pipeline_name);
            else
                printf("MESSAGE qos %s %s %lu %lu\n",
                    pipeline_name,
                    GST_OBJECT_NAME(msg->src),
                    rendered,
                    dropped);
            break;
        }
        default: {
            printf("MESSAGE %s %s %s\n",
                GST_MESSAGE_TYPE_NAME(msg),
                pipeline_name,
                GST_OBJECT_NAME(msg->src));
            break;
        }
    }
}

static GstPadProbeReturn
cb_drop_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    return GST_PAD_PROBE_DROP;
}

#define DROP_PROBE 0
#define RATE_PROBE 1

typedef struct probe_any
{
    int probe_kind;
    gulong probe_id;
} any_probe;

typedef struct probe_drop 
{
    int probe_kind;
    gulong probe_id;
} drop_probe;

static void init_drop_probe(drop_probe* data, gulong id)
{
    data->probe_kind = DROP_PROBE;
    data->probe_id = id;
}

static void free_drop_probe(drop_probe* data)
{
    free(data);
}

typedef struct probe_rate
{
    int probe_kind;
    gulong probe_id;
    double target_rate;
    double current_rate;
    double first_time;
    int allowed;
    int dropped;
} rate_probe;

static void init_rate_probe(rate_probe* data, gulong id, double rate)
{
    data->probe_kind = RATE_PROBE;
    data->probe_id = id;
    data->target_rate = rate;
    data->current_rate = -1;
    data->first_time = -1;
    data->allowed = 0;
    data->dropped = 0;
}

static void free_rate_probe(rate_probe* data)
{
    free(data);
}

static GstPadProbeReturn
cb_rate_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    GstBuffer* buffer;
    double time;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    time = GST_TIME_AS_SECONDS((double) GST_BUFFER_PTS(buffer));
    
    rate_probe* data = (rate_probe*) user_data;
    if (data->first_time == -1)
    {
        data->first_time = time;
        data->allowed++;
        return GST_PAD_PROBE_OK;
    }
    else
    {
        double elapsed = time - data->first_time;
        double rate_so_far = data->allowed / elapsed;
        
        if (rate_so_far <= data->target_rate)
        {
            data->allowed++;
            return GST_PAD_PROBE_OK;
        }
        else
        {
            data->dropped++;
            return GST_PAD_PROBE_DROP;
        }
    }
}

static GstPadProbeReturn
cb_have_data(GstPad          *pad,
             GstPadProbeInfo *info,
             gpointer         user_data)
{
    GstBuffer* buffer;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    gsize size;
    
    buffer = GST_PAD_PROBE_INFO_BUFFER(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    size = gst_buffer_get_size(buffer);
    GstClock* clock = gst_pipeline_get_clock(pipeline);
    GstClockTime timestamp = GST_BUFFER_PTS(buffer);
    GstClockTime clockstamp = gst_clock_get_time(clock) - gst_element_get_base_time(GST_ELEMENT(pipeline));
    // printf("DATA %s %s %s %ld %.3f %.3f %.3f\n", pipeline_name, element_name, name, size, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s %.3f %.3f %.3f\n", pipeline_name, element_name, name, present_time(gst_element_get_start_time(element)), present_time(GST_BUFFER_PTS(buffer)), present_time(GST_BUFFER_DURATION(buffer)));
    // printf("DATA %s %s %s %ld %.3f %.3f %.3f\n", pipeline_name, element_name, name, size, present_time(timestamp), present_time(clockstamp), present_time(timestamp) - present_time(clockstamp));
    GstMapInfo map;
    gst_buffer_map(buffer, &map, GST_MAP_READ);
    size = map.size;
    printf("DATA %s %s %s %6ld", pipeline_name, element_name, name, size);
    int i;
    for (i=0; i < ((size <= 20) ? size : 20); i++)
        printf(" %3d,", map.data[i]);
    printf("\n");
    gst_buffer_unmap(buffer, &map);
    g_free(name);
    g_free(element_name);
    gst_object_unref(clock);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static GstPadProbeReturn
cb_have_event(GstPad          *pad,
              GstPadProbeInfo *info,
              gpointer         user_data)
{
    GstEvent* event;
    GstPipeline* pipeline;
    GstElement* element;
    gchar* pipeline_name;
    gchar* element_name;
    gchar* name;
    
    event = GST_PAD_PROBE_INFO_EVENT(info);
    pipeline = (GstPipeline*) user_data;
    pipeline_name = gst_element_get_name(pipeline);
    element = gst_pad_get_parent_element(pad);
    element_name = gst_element_get_name(element);
    name = gst_pad_get_name(pad);
    if (GST_EVENT_TYPE(event) == GST_EVENT_CAPS)
    {
        GstCaps *caps;
        gst_event_parse_caps(event, &caps);
        printf("EVENT %s %s %s caps %s\n", pipeline_name, element_name, name, gst_caps_to_string(caps));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_QOS)
    {
        const char* const names[] = { "OVERFLOW", "UNDERFLOW", "THROTTLE" };
        GstQOSType type;
        gdouble proportion;
        GstClockTimeDiff diff;
        GstClockTime timestamp;
        gst_event_parse_qos(event, &type, &proportion, &diff, &timestamp);
        printf("EVENT %s %s %s qos %s %.3f %.3f %.3f\n", pipeline_name, element_name, name, names[type], proportion, present_timediff(diff), present_time(timestamp));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_SEGMENT)
    {
        const GstSegment* segment;
        gst_event_parse_segment (event, &segment);
        printf("EVENT %s %s %s segment %.3f %.3f %.3f %.3f\n", pipeline_name, element_name, name, segment->rate, present_time(segment->start), present_time(segment->stop), present_time(segment->duration));
    }
    else if (GST_EVENT_TYPE(event) == GST_EVENT_LATENCY)
    {
        GstClockTime latency;
        gst_event_parse_latency (event, &latency);
        printf("EVENT %s %s %s latency %.3f\n", pipeline_name, element_name, name, present_time(latency));
    }
    else
        printf("EVENT %s %s %s %s\n", pipeline_name, element_name, name, GST_EVENT_TYPE_NAME(event));
    g_free(name);
    g_free(element_name);
    gst_object_unref(element);

    return GST_PAD_PROBE_OK;
}

static void* gst_pad_add_drop_probe(GstPad* pad)
{
    drop_probe* data = malloc(sizeof(drop_probe));
    gulong id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_drop_data, NULL, NULL);
    
    init_drop_probe(data, id);
    
    return (void*) data;
}

static void* gst_pad_add_rate_probe(GstPad* pad, int rate)
{
    rate_probe* data = malloc(sizeof(rate_probe));
    gulong id = gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_rate_data, data, NULL);
    
    init_rate_probe(data, id, rate);
    
    return (void*) data;
}

static void gst_pad_probe_free(void* info)
{
    any_probe* data = (any_probe*) info;
    switch (data->probe_kind) {
        case DROP_PROBE: {
            free_drop_probe((drop_probe*) data);
            break;
        }
        case RATE_PROBE: {
            free_rate_probe((rate_probe*) data);
            break;
        }
    }
}

static void gst_pad_remove_probe_aux(GstPad* pad, void* info)
{
    any_probe* data = (any_probe*) info;
    gulong id = data->probe_id;
    gst_pad_remove_probe(pad, id);
    gst_pad_probe_free(info);
}

static gulong gst_monitor_data(GstPipeline* pipeline, GstPad* pad)
{
    return gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_have_data, pipeline, NULL);
}

static gulong gst_monitor_events(GstPipeline* pipeline, GstPad* pad)
{
    return gst_pad_add_probe(pad, GST_PAD_PROBE_TYPE_EVENT_BOTH, (GstPadProbeCallback) cb_have_event, pipeline, NULL);
}

static void gst_debug_bin_to_dot_file_aux(GstBin* bin, char* filename)
{
    gst_debug_bin_to_dot_file(bin, GST_DEBUG_GRAPH_SHOW_ALL, filename);
}
//#)


(cond-expand
  (unix)
  (else
(c-declare jazz.stream.foreign #/C/
#include <glib.h>
#include <rnnoise.h>

#define FRAME_SIZE 480

bool denoising = true;

GstElement *mic_sink, *codec_src;

static bool get_denoising()
{
    return denoising;
}

static void set_denoising(bool flag)
{
    denoising = flag;
}

static void* denoise(void* data)
{
    float x[FRAME_SIZE];
    
    int done = 0;
    
    GstAppSink* sink = GST_APP_SINK(mic_sink);
    GstAppSrc* src = GST_APP_SRC(codec_src);
    
    DenoiseState* st = rnnoise_create();
    
    while (! done)
    {
        GstSample *sample;
        sample = gst_app_sink_pull_sample(sink);
        if (sample)
        {
            GstBuffer* buffer = gst_sample_get_buffer(sample);
            if (buffer)
            {
                GstMapInfo map;
                gst_buffer_map(buffer, &map, GST_MAP_READ);
                
                GstBuffer *denoised_buffer = gst_buffer_new_allocate(NULL, map.size, NULL);
                GstMapInfo denoised_map;
                gst_buffer_map(denoised_buffer, &denoised_map, GST_MAP_WRITE);
                memmove(denoised_map.data, map.data, map.size);
                
                if (denoising)
                {
                    int count = denoised_map.size / sizeof(short);
                    // it is possible to receive incorrect sizes
                    // in the first few frames so guard against it
                    if (count == FRAME_SIZE)
                    {
                        int i;
                        short *ptr = (short*) denoised_map.data;
                        for (i=0;i<count;i++) x[i] = ptr[i];
                        rnnoise_process_frame(st, x, x);
                        for (i=0;i<count;i++) ptr[i] = x[i];
                    }
                }
                
                gst_buffer_unmap(denoised_buffer, &denoised_map);
                gst_buffer_unmap(buffer, &map);
                
                gst_app_src_push_buffer(src, denoised_buffer);
            }
            gst_sample_unref(sample);
        }
        else
            done = 1;
    }
    
    rnnoise_destroy(st);
    
    return NULL;
}

static GThread* create_denoiser_thread(GstElement* sink, GstElement* src)
{
    mic_sink = sink;
    codec_src = src;
    
    return g_thread_new("denoise", denoise, NULL);
    
    // where do we call this
    // g_thread_unref(thread);
}
//#)))


(gst-external (gst_init NULL NULL) void)
(gst-external (gst_deinit) void)
(gst-external (gst_version_fill scheme-object) void)
(gst-external (gst_parse_launch char-string NULL) GstElement*)
(gst-external (gst_parse_bin_from_description char-string gboolean NULL) GstElement*)
(gst-external (gst_object_get_name (call GST_OBJECT GstElement*)) char-string)
(gst-external (gst_object_set_name (call GST_OBJECT GstElement*) char-string) gboolean)
(gst-external (gst_object_unref gpointer) void)
(gst-external (gst_value_get_fraction_numerator GValue*) int)
(gst-external (gst_value_get_fraction_denominator GValue*) int)
(gst-external (gst_value_set_fraction GValue* int int) void)
(gst-external (gst_value_get_buffer GValue*) GstBuffer*)
(gst-external (gst_pad_get_current_caps GstPad*) GstCaps*)
(gst-external (gst_pad_get_direction GstPad*) GstPadDirection)
(gst-external (gst_pad_add_drop_probe GstPad*) :alloc void*)
(gst-external (gst_pad_add_rate_probe GstPad* int) :alloc void*)
(gst-external (gst_pad_probe_free void*) :free void "gst_pad_probe_free")
(gst-external (gst_pad_remove_probe GstPad* void*) (:free 2) void "gst_pad_remove_probe_aux")
(gst-external (gst_caps_new_empty_simple char-string) GstCaps*)
(gst-external (gst_caps_from_string char-string) GstCaps*)
(gst-external (gst_caps_is_fixed GstCaps*) gboolean)
(gst-external (gst_caps_get_structure GstCaps* int) GstStructure*)
(gst-external (gst_caps_set_value GstCaps* char-string GValue*) void)
(gst-external (gst_caps_to_string GstCaps*) char-string)
(gst-external (gst_caps_unref GstCaps*) void)
(gst-external (gst_structure_get_int GstStructure* char-string) int "gst_structure_get_int_aux")
(gst-external (gst_structure_get_value GstStructure* char-string) GValue* "gst_structure_get_value_aux")
(gst-external (gst_buffer_get_size GstBuffer*) int)
(gst-external (gst_element_set_state_threaded GstElement* GstState void*) :alloc void*)
(gst-external (gst_element_set_state_free void*) :free void)
(gst-external (gst_element_set_state_blocking GstElement* GstState) GstStateChangeReturn)
(gst-external (gst_element_get_state GstElement*) GstState "gst_element_get_state_aux")
(gst-external (gst_element_wait_state GstElement*) void "gst_element_wait_state_aux")
(gst-external (gst_element_seek_simple GstElement* GstFormat GstSeekFlags int64) gboolean)
(gst-external (gst_element_send_event GstElement* GstEvent*) gboolean)
(gst-external (gst_element_get_bus GstElement*) GstBus*)
(gst-external (gst_element_get_base_time GstElement*) GstClockTime)
(gst-external (gst_element_factory_make char-string char-string) GstElement*)
(gst-external (gst_element_link GstElement* GstElement*) gboolean)
(gst-external (gst_element_get_static_pad GstElement* char-string) GstPad*)
(gst-external (gst_element_iterate_pads GstElement*) GstIterator*)
(gst-external (gst_element_query_position GstElement* GstFormat) int64 "gst_element_query_position_aux")
(gst-external (gst_element_query_duration GstElement* GstFormat) int64 "gst_element_query_duration_aux")
(gst-external (gst_iterator_next_element GstIterator*) GstElement*)
(gst-external (gst_iterator_next_pad GstIterator*) GstPad*)
(gst-external (gst_signal_connect_to gpointer char-string gpointer) gulong)
(gst-external (gst_bus_timed_pop_filtered GstBus* GstClockTime GstMessageType) GstMessage*)
(gst-external (gst_bus_pop GstBus*) GstMessage*)
(gst-external (gst_bin_add (call GST_BIN GstElement*) GstElement*) gboolean)
(gst-external (gst_bin_get_by_name (call GST_BIN GstElement*) char-string) GstElement*)
(gst-external (gst_bin_iterate_elements (call GST_BIN GstElement*)) GstIterator*)
(gst-external (gst_debug_bin_to_dot_file (call GST_BIN GstElement*) char-string) void "gst_debug_bin_to_dot_file_aux")
(gst-external (gst_pipeline_new char-string) GstElement*)
(gst-external (gst_pipeline_get_bus (call GST_PIPELINE GstElement*)) GstBus*)
(gst-external (gst_pipeline_get_clock (call GST_PIPELINE GstElement*)) GstClock*)
(gst-external (gst_pipeline_get_latency (call GST_PIPELINE GstElement*)) GstClockTime)
(gst-external (gst_pipeline_set_latency (call GST_PIPELINE GstElement*) GstClockTime) void)
(gst-external (gst_event_new_eos) GstEvent*)
(gst-external (gst_message_state_changed_get_new_state GstMessage*) GstState)
(gst-external (gst_message_unref GstMessage*) void)
(gst-external (gst_clock_get_time GstClock*) GstClockTime)
(gst-external (gst_discoverer_new) GstDiscoverer* "gst_discoverer_new_aux")
(gst-external (gst_discoverer_discover_uri GstDiscoverer* char-string) GstDiscovererInfo* "gst_discoverer_discover_uri_aux")
(gst-external (gst_discoverer_info_get_duration GstDiscovererInfo*) GstClockTime)
(gst-external (gst_discoverer_info_get_stream_info GstDiscovererInfo*) GstDiscovererStreamInfo*)
(gst-external (gst_discoverer_video_info_get_width (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_height (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_discoverer_video_info_get_depth (call GST_DISCOVERER_VIDEO_INFO GstDiscovererStreamInfo*)) int)
(gst-external (gst_present_time GstClockTime) double "present_time")
(gst-external (gst_print_pipeline (call GST_PIPELINE GstElement*)) void)
(gst-external (gst_print_pad GstElement* char-string) void)
(gst-external (gst_print_message char-string GstMessage*) void)
(gst-external (gst_print_error GstMessage*) void)
(gst-external (gst_monitor_data (call GST_PIPELINE GstElement*) GstPad*) gulong)
(gst-external (gst_monitor_events (call GST_PIPELINE GstElement*) GstPad*) gulong)
(gst-external (gst_app_src_set_caps (call GST_APP_SRC GstElement*) GstCaps*) void)
(gst-external (gst_app_src_set_stream_type (call GST_APP_SRC GstElement*) GstAppStreamType) void)
(gst-external (gst_app_src_write GstElement* scheme-object int int64 uint64) GstFlowReturn)
(gst-external (gst_app_src_write_pointer GstElement* void* int int64 uint64) GstFlowReturn)
(gst-external (gst_app_sink_connect_listener_signals GstElement* void*) void)
(gst-external (gst_app_sink_try_pull GstElement* scheme-object scheme-object) int)
(gst-external (gst_app_sink_is_eos (call GST_APP_SINK GstElement*)) bool)
(gst-external (GST_TYPE_FRACTION) GType "___return(GST_TYPE_FRACTION);")
(gst-external (GST_MESSAGE_TYPE GstMessage*) GstMessageType)
(gst-external (GST_MESSAGE_SRC GstMessage*) GstElement*)

(cond-expand
 (unix
(definition public (get-denoising?) #f)
(definition public (set-denoising? flag))
(definition public (create-denoiser-thread . rest)))
 (else
(gst-external (get-denoising?) bool "get_denoising")
(gst-external (set-denoising? bool) void "set_denoising")
(gst-external (create-denoiser-thread GstElement* GstElement*) GThread* "create_denoiser_thread")))


(definition public gst_element_set_state
  gst_element_set_state_blocking)

@w
(definition public (gst_element_set_state elem state)
  (let ((listener (open-stream-listener)))
    (let ((data (gst_element_set_state_threaded elem state (get-write-file listener))))
      (let ((c (wait listener)))
        (assert (eqv? c #\!)
          (gst_element_set_state_free data)
          (close-stream-listener listener))))))


(gst-external (move-u8vector->pointer! scheme-object void*) void
  #/C/
    memmove(___arg2, ___BODY(___arg1), ___HD_BYTES(___HEADER(___arg1)));
//#)


(gst-external (move-pointer->u8vector! void* scheme-object) void
  #/C/
    memmove(___BODY(___arg2), ___arg1, ___HD_BYTES(___HEADER(___arg2)));
//#)


(gst-external (separate-alpha void* void* int) void
  #/C/
    char* data = (char*) ___arg1;
    char* alpha = (char*) ___arg2;
    int count = ___arg3;
    
    data += 3;
    while (count > 0)
    {
        *alpha++ = *data;
        data += 4;
        count--;
    }
//#)


(gst-external (combine-alpha scheme-object scheme-object void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char* alpha = (char*) ___BODY(___arg2);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *alpha++;
        color++;
        count--;
    }
//#)


(gst-external (add-alpha scheme-object float void* int) void
  #/C/
    char* color = (char*) ___BODY(___arg1);
    char alpha = (char) (___arg2 * 255);
    char* data = (char*) ___arg3;
    int count = ___arg4;
    
    while (count > 0)
    {
        *data++ = *color++;
        *data++ = *color++;
        *data++ = *color++;
        *data++ = alpha;
        color++;
        count--;
    }
//#))
