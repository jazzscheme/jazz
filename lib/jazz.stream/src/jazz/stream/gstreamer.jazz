;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; GStreamer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.stream.gstreamer jazz


(import (jazz.flow)
        (jazz.foreign)
        (jazz.io)
        (jazz.listener)
        (jazz.moment)
        (jazz.settings)
        (jazz.snapshot)
        (jazz.stream.delayed)
        (jazz.stream.directories)
        (jazz.stream.header)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.version))

(export (jazz.stream.delayed)
        (jazz.stream.header))


;;;
;;;; Timestamp
;;;


(definition protected -inf.ts <fx>
  (- (expt 2 61)))

(definition protected +inf.ts <fx>
  (- (expt 2 61) 1))


(definition public current-timestamp
  current-monotonic-nanoseconds)


(definition protected nanosecond <fl>
  (exact->inexact (expt 10 9)))


(definition public (timestamp->flonum x) <fl>
  (/ (exact->inexact x) nanosecond))

(definition public (flonum->timestamp x)
  (inexact->exact (round (* x nanosecond))))


(definition protected +inf.flo <fl>
  (timestamp->flonum +inf.ts))

;; needed because of rounding errors
(definition protected (flonum->timestamp+ x)
  (if (= x +inf.flo)
      +inf.ts
    (flonum->timestamp x)))


(definition public (present-timestamp timestamp)
  (cond ((= timestamp -inf.ts)
         "-inf.ts")
        ((= timestamp +inf.ts)
         "+inf.ts")
        (else
         (format "{r}" (timestamp->flonum timestamp)))))


;;;
;;;; Log
;;;


(definition protected (parse-log-entry entry)
  (let ((level (log_entry_level entry))
        (category (log_entry_category entry))
        (function (log_entry_function entry))
        (message (log_entry_message entry))
        (stack (log_entry_stack entry)))
    (new Moment
      'gstreamer
      (current-seconds)
      level
      category
      function
      message
      (and stack (remove-empty (split stack "\n"))))))


;;;
;;;; GLib
;;;


(definition public (g_value_boolean n)
  (let ((value (g_value_new G_TYPE_BOOLEAN)))
    (g_value_set_boolean value n)
    value))


(definition public (g_value_int n)
  (let ((value (g_value_new G_TYPE_INT)))
    (g_value_set_int value n)
    value))


(definition public (g_value_uint64 n)
  (let ((value (g_value_new G_TYPE_UINT64)))
    (g_value_set_uint64 value n)
    value))


(definition public (g_value_double n)
  (let ((value (g_value_new G_TYPE_DOUBLE)))
    (g_value_set_double value n)
    value))


(definition public (g_value_string str)
  (let ((value (g_value_new G_TYPE_STRING)))
    (g_value_set_string value str)
    value))


(definition public (g_value_fraction fraction)
  (bind (n . d) fraction
    (let ((value (g_value_new (GST_TYPE_FRACTION))))
      (gst_value_set_fraction value n d)
      value)))


(definition public (for-each-typed-property proc lst)
  (let (iterate (lst lst))
    (when (not-null? lst)
      (proc (car lst) (cadr lst) (caddr lst))
      (iterate (cdddr lst)))))


(definition protected value-new
  (make-table test: eq?))

(definition protected (register-value-new name new)
  (table-set! value-new name new))

(register-value-new 'boolean  g_value_boolean)
(register-value-new 'int      g_value_int)
(register-value-new 'uint64   g_value_uint64)
(register-value-new 'double   g_value_double)
(register-value-new 'string   g_value_string)
(register-value-new 'fraction g_value_fraction)


;;;
;;;; GStreamer
;;;


(definition public (gst-version)
  (let ((info (make-u32vector 4)))
    (gst_version_fill info)
    (new Version
      (u32vector-ref info 0)
      (u32vector-ref info 1)
      (u32vector-ref info 2)
      (u32vector-ref info 3))))


;;;
;;;; Value
;;;


(definition public (gst-boolean value)
  (if value
      "true"
    "false"))


(definition public (gst-iterate-value-list value proc)
  (loop (for i from 0 below (gst_value_list_get_size value))
        (proc (gst_value_list_get_value value i))))


;;;
;;;; Audio
;;;


(definition public audiosrc
  (cond-expand
    (windows "wasapisrc")
    (mac "osxaudiosrc")
    (else "pulsesrc")))


(definition public audiosink
  (cond-expand
    (windows "wasapisink")
    (mac "osxaudiosink")
    (else "pulsesink")))


(definition public (rawaudio-pad-info pad)
  (let ((caps (gst_pad_get_current_caps pad)))
    (prog1 (let ((s (gst_caps_get_structure caps 0)))
             (list (gst_structure_get_string s "format")
                   (gst_structure_get_int s "rate")
                   (gst_structure_get_int s "channels")))
      (gst_caps_unref caps))))
    

(definition public (rawaudio-extension info)
  (bind (f r c) info
    (format "{a}_{a}_{a}" f c r)))


;;;
;;;; Video
;;;


(definition public videosrc
  (cond-expand
    (mac "avfvideosrc")
    (windows "mfvideosrc")
    (else "v4l2src")))


;;;
;;;; Object
;;;


(definition public (g-object-set obj . rest)
  (for-each-typed-property (lambda (name type value)
                             (let ((new (table-ref value-new type)))
                               (let ((value (new value)))
                                 (g_object_set_property obj name value)
                                 (g_value_free value))))
                           rest))


;;;
;;;; Renaming
;;;


;; gstreamer threads are named as element name:pad direction
;; the following renaming scheme gives a unique name to every
;; element so we can find the element bin solely from its name


(definition bin-renaming?
  #t)


(definition bin-mutex
  (make-mutex 'bin))

(definition protected (with-bin-mutex thunk)
  (mutex-lock! bin-mutex)
  (prog1 (thunk)
    (mutex-unlock! bin-mutex)))


(definition bin-unique-id
  0)

(definition (bin-unique-id!)
  (with-bin-mutex
    (lambda ()
      (prog1 bin-unique-id
        (increase! bin-unique-id)))))

(definition (bin-suffix id)
  (if (not bin-renaming?)
      ""
    (string-append "%" (->string id))))


(definition bins
  (make-table test: eq?))

(definition (register-bin bin id)
  (with-bin-mutex
    (lambda ()
      (table-set! bins bin id))))

(definition (registered-bin bin)
  (with-bin-mutex
    (lambda ()
      (table-ref bins bin))))

(definition protected (unregister-bin bin)
  (table-clear bins bin))


(definition protected (bin->id bin)
  (registered-bin bin))

(definition protected (id->bin id)
  (table-find bins id))


(definition protected (iterate-bins proc)
  (iterate-table bins
    proc))

(definition protected (collect-bins)
  (table-keys bins))


(definition protected (gst-element-bin-name bin name)
  (let ((id (registered-bin bin)))
    (string-append name (bin-suffix id))))


(definition public (gst_bin_get_by_name bin name)
  (let ((elem (gst_bin_get_by_name_aux bin (gst-element-bin-name bin name))))
    (if (not elem)
        (error "Unable to find element {a}" name)
      elem)))


(definition (substitute-names description id)
  (let ((output (open-output-string))
        (len (string-length description)))
    (let (iter (start 0))
      (let ((pos (search description "name=" start: start)))
        (if (not pos)
            (begin
              (write-string (substring description start len) output)
              (get-output-string output))
          (write-string (substring description start pos) output)
          (let ((start (+ pos 5)))
            (let ((end (or (search description " " start: start) len)))
              (write-string "name=" output)
              (write-string (substring description start end) output)
              (write-string (bin-suffix id) output)
              (iter end))))))))


(definition (substitute-^s description id)
  (substitute-string description "^" (bin-suffix id)))


;;;
;;;; Parse
;;;


(definition protected show-elements?
  (find-setting 'jazz.show-elements? #f))

(definition protected show-bin?
  (find-setting 'jazz.show-bin? #f))


(definition public (gst_parse_launch desc)
  (receive (pipeline err) (gst_parse_launch_aux desc element-tags error-tags)
    (if err
        (error "Create pipeline error: {a}" (g_error_message err))
      pipeline)))


(definition public (gst_parse_bin_from_description desc ghost_unlinked_pads)
  (receive (bin err) (gst_parse_bin_from_description_aux desc ghost_unlinked_pads element-tags error-tags)
    (if err
        (error "Create bin error: {a}" (g_error_message err))
      bin)))


(definition public (gst-pipeline . elements)
  (when show-elements?
    (pp elements))
  (let ((id (bin-unique-id!)))
    (let ((description (substitute-^s (substitute-names (gst-parse elements) id) id)))
      (when show-bin?
        (terminal description))
      (let ((pipeline (gst_parse_launch description)))
        (register-bin pipeline id)
        pipeline))))


(definition public (gst-bin . elements)
  (when show-elements?
    (pp elements))
  (let ((id (bin-unique-id!)))
    (let ((description (substitute-^s (substitute-names (gst-parse elements) id) id)))
      (when show-bin?
        (terminal description))
      (let ((bin (gst_parse_bin_from_description description 0)))
        (register-bin bin id)
        bin))))


(definition public (gst-parse elements)
  (define (parse-list elem)
    (let ((elem (remove-false elem)))
      (bind (first . rest) elem
        (string-append (if (pair? first)
                           (parse-list first)
                         first)
          (parse-rest rest)))))
  
  (define (parse-rest rest)
    (let (loop (rest rest) (line ""))
      (if (null? rest)
          line
        (bind (elem . rest) rest
          (cond ((not elem)
                 (loop rest line))
                ((string? elem)
                 (loop rest (string-append line " ! " elem)))
                ((pair? elem)
                 (loop rest (string-append line " " (parse-list elem))))
                (else
                 (error "Unable to parse {s}" elem)))))))
  
  (parse-list elements))


(definition public (gst_bin_release bin)
  (with-bin-mutex
    (lambda ()
      (gst_element_release bin)
      (unregister-bin bin))))


(definition public (pipeline-messages-processor pipeline (playing-proc: playing-proc #f) (print?: print? #f))
  (let ((name (gst_object_get_name pipeline))
        (bus (gst_pipeline_get_bus pipeline)))
    (lambda ()
      (let (loop)
        (let ((msg (gst_bus_pop bus)))
          (when msg
            (when (and playing-proc
                       (= (GST_MESSAGE_TYPE msg) GST_MESSAGE_STATE_CHANGED)
                       (= (gst_message_state_changed_get_new_state msg) GST_STATE_PLAYING)
                       (equal? (gst_object_get_name (GST_MESSAGE_SRC msg)) name))
              (playing-proc))
            (when print?
              (gst_print_message name msg))
            (let ((type (GST_MESSAGE_TYPE msg)))
              (ecase type
                ((GST_MESSAGE_ERROR)
                 (unless print?
                   (gst_print_message name msg)))
                ((GST_MESSAGE_WARNING)
                 (unless print?
                   (gst_print_message name msg)))))
            (gst_message_unref msg)
            (loop)))))))


(definition public (gst-element name . rest)
  (let ((port (open-output-string)))
    (display name port)
    (for-each-property (lambda (key value)
                         (when value
                           (format port " {a}={a}" (keyword->string key) value)))
                       rest)
    (get-output-string port)))


;;;
;;;; Bus
;;;


;; obsoleted by always setting the bus to flushing
(definition public (gst-flush-bus pipeline)
  (with-unref ((bus (gst_pipeline_get_bus pipeline)))
    (let (loop (count 0))
      (let ((msg (gst_bus_pop bus)))
        (if (not msg)
            count
          (gst_message_unref msg)
          (loop (+ count 1)))))))


;;;
;;;; Bin
;;;


(definition public (gst_bin_elements bin)
  (let ((it (gst_bin_iterate_elements bin))
        (queue (new-queue)))
    (let (loop)
      (let ((elem (gst_iterator_next_element it)))
        (if (not elem)
            (begin
              (gst_iterator_free it)
              (queue-list queue))
          (enqueue queue elem)
          (loop))))))


(definition public (gst_bin_elements_sorted bin)
  (let ((it (gst_bin_iterate_sorted bin))
        (queue (new-queue)))
    (let (loop)
      (let ((elem (gst_iterator_next_element it)))
        (if (not elem)
            (begin
              (gst_iterator_free it)
              (queue-list queue))
          (enqueue queue elem)
          (loop))))))


(definition public (gst_bin_elements_recurse bin)
  (let ((it (gst_bin_iterate_recurse bin))
        (queue (new-queue)))
    (let (loop)
      (let ((elem (gst_iterator_next_element it)))
        (if (not elem)
            (begin
              (gst_iterator_free it)
              (queue-list queue))
          (enqueue queue elem)
          (loop))))))


;;;
;;;; Structure
;;;


(definition public (collect-structure-fields struc)
  (loop (for i from 0 below (gst_structure_n_fields struc))
        (collect (gst_structure_nth_field_name struc i))))


;;;
;;;; Caps
;;;


(definition public (gst-new-caps type . rest)
  (let ((caps (gst_caps_new_empty_simple type)))
    (for-each-typed-property (lambda (name type value)
                               (let ((new (table-ref value-new type)))
                                 (let ((value (new value)))
                                   (gst_caps_set_value caps name value)
                                   (g_value_free value))))
                             rest)
    caps))


(definition public (gst_caps_get_name caps)
  (let ((struc (gst_caps_get_structure caps 0)))
    (gst_structure_get_name struc)))


(definition public (caps->codec-data caps)
  (let ((struc (gst_caps_get_structure caps 0)))
    (let ((value (gst_structure_get_value struc "codec_data")))
      (and value
           (gst_value_get_buffer_data value)))))


(definition public (caps-codec-data? caps)
  (let ((struc (gst_caps_get_structure caps 0)))
    (let ((value (gst_structure_get_value struc "codec_data")))
      (boolean value))))


(definition public (caps-string->codec-data caps-string)
  (let ((caps (gst_caps_from_string caps-string)))
    (prog1 (caps->codec-data caps)
      (gst_caps_unref caps))))


(definition public (caps-string-codec-data? caps-string)
  (let ((caps (gst_caps_from_string caps-string)))
    (prog1 (caps-codec-data? caps)
      (gst_caps_unref caps))))


;;;
;;;; Element
;;;


(definition public (gst_element_path elem)
  (let ((output (open-output-string)))
    (let (loop (elem elem))
      (let ((parent (gst_element_get_parent_untraced elem)))
        (when parent
          (loop parent)
          (display "." output))
        (display (gst_object_get_name_untraced elem) output)))
    (get-output-string output)))


(definition public (gst_element_sink_pads elem)
  (gst_collect_pad_iterator (gst_element_iterate_sink_pads elem)))


(definition public (gst_element_src_pads elem)
  (gst_collect_pad_iterator (gst_element_iterate_src_pads elem)))


(definition public (gst_element_pads elem)
  (gst_collect_pad_iterator (gst_element_iterate_pads elem)))


(definition public (gst_collect_pad_iterator iterator)
  (let ((queue (new-queue)))
    (let (loop)
      (let ((pad (gst_iterator_next_pad iterator)))
        (if (not pad)
            (begin
              (gst_iterator_free iterator)
              (queue-list queue))
          (enqueue queue pad)
          (loop))))))


(definition public (wait-playing pipeline)
  (declare (proper-tail-calls))
  (let (loop (n 0))
    (if (< n 100)
        (if (= (gst_element_get_state pipeline) 4)
            #t
          (sleep .01)
          (loop (+ n 1)))
      #f)))


(definition public (wait-caps-for pad wait)
  (declare (proper-tail-calls))
  (let ((max-iter (fxround (/ wait .01))))
    (let (loop (n 0))
      (if (> n max-iter)
          #f
        (if (not (gst_pad_has_current_caps pad))
            (begin
              (sleep .01)
              (loop (+ n 1)))
          (gst_pad_get_current_caps pad))))))


(definition public (wait-caps appsink)
  (with-unref ((pad (gst_element_get_static_pad appsink "sink")))
    (wait-caps-for pad 10.)))


(definition public (wait-caps-string appsink)
  (let ((caps (wait-caps appsink)))
    (and caps
         (let ((caps-string (gst_caps_to_string caps)))
           (gst_caps_unref caps)
           caps-string))))


(definition public (wait-caps-string/resolution appsink)
  (let ((caps (wait-caps appsink)))
    (and caps
         (let ((caps-string (gst_caps_to_string caps))
               (struc (gst_caps_get_structure caps 0)))
           (let ((width (gst_structure_get_int struc "width"))
                 (height (gst_structure_get_int struc "height")))
             (gst_caps_unref caps)
             (values caps-string (new Dimension width height)))))))


(definition public (gst_element_release elem)
  (gst_element_set_state elem GST_STATE_NULL)
  (gst_object_unref elem))


;;;
;;;; Monitor
;;;


(definition public (gst_monitor bin name what . rest)
  (define (parse-name name)
    (let ((parts (split name ".")))
      (if (= 1 (length parts))
          (let ((parts (split name "!")))
            (if (= 1 (length parts))
                (values name #f #f #f)
              (bind (name dir) parts
                (receive (dir peer?) (parse-pad dir)
                  (let ((direction (cond ((equal? dir "src") GST_PAD_SRC)
                                         ((equal? dir "sink") GST_PAD_SINK)
                                         (else (error "Unknown pad direction: {a}" dir)))))
                    (values name #f direction peer?))))))
        (bind (name pad_name) parts
          (receive (pad_name peer?) (parse-pad pad_name)
            (values name pad_name #f peer?))))))
  
  (define (parse-pad str)
    (if (ends-with? str "^")
        (values (substring str 0 (- (string-length str) 1)) #t)
      (values str #f)))
  
  (receive (name pad_name pad_direction peer?) (parse-name name)
    (define (with-elem proc)
      (if (empty-string? name)
          (proc bin)
        (with-unref ((elem (gst_bin_get_by_name bin name)))
          (if (not elem)
              (error "Unable to find element {a}" name)
            (proc elem)))))
    
    (with-elem
      (lambda (elem)
        (with-unref ((pads (gst_element_pads elem)))
          (define (find-pad)
            (find-if (lambda (pad)
                       (or (and (not pad_name)
                                (not pad_direction))
                           (and pad_name
                                (equal? (gst_pad_get_name pad) pad_name))
                           (and pad_direction
                                (= (gst_pad_get_direction pad) pad_direction))))
                     pads))
          
          (define (with-pad pad proc)
            (if (not peer?)
                (proc pad)
              (with-unref ((peer-pad (gst_pad_get_peer pad)))
                (proc peer-pad))))
          
          (let ((pad (find-pad)))
            (if (not pad)
                (error "Unable to find pad")
              (with-pad pad
                (lambda (pad)
                  (case what
                    ((file)
                     (let ((filename (car rest)))
                       (let ((effective-filename (if (procedure? filename) (filename pad) filename)))
                         (cons pad (gst_monitor_file pad effective-filename)))))
                    ((queue)
                     (cons pad (gst_monitor_queue pad (flonum->timestamp (car rest)))))
                    ((print)
                     (cons pad (gst_monitor_print pad bin (if (not-null? rest) (car rest) #f))))
                    ((analyse)
                     (cons pad (gst_monitor_analyse pad (car rest) name)))
                    ((data)
                     (cons pad (gst_monitor_data pad (if (not-null? rest) (car rest) bin))))
                    ((events)
                     (cons pad (gst_monitor_events pad (if (not-null? rest) (car rest) bin))))
                    ((queries)
                     (cons pad (gst_monitor_queries pad (if (not-null? rest) (car rest) bin))))
                    (else
                     (error "Unknown monitor: {a}" what))))))))))))


(definition public (gst_unmonitor monitored)
  (bind (pad . id) monitored
    (gst_monitor_remove pad id)))


;;;
;;;; AppSrc
;;;


(definition public (gst-app-src-set-caps appsrc type . rest)
  (let ((caps (gst_caps_new_empty_simple type))
        (values '()))
    (for-each-typed-property (lambda (name type value)
                               (let ((new (table-ref value-new type)))
                                 (let ((value (new value)))
                                   (set! values (cons value values))
                                   (gst_caps_set_value caps name value))))
                             rest)
    (gst_app_src_set_caps appsrc caps)
    (gst_caps_unref caps)
    (for-each g_value_free values)))


(definition public (gst-setup-video-source src type format width height framerate (stream-format: stream-format #f) (alignment: alignment #f))
  (apply gst-app-src-set-caps src type
    `("format"        string   ,format
      "width"         int      ,width
      "height"        int      ,height
      "framerate"     fraction ,(cons framerate 1)
      ,@(if stream-format `("stream-format" string "avc") '())
      ,@(if alignment `("alignment" string "au") '())))
  (g-object-set src
    "is-live"     'boolean #t
    "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
    "format"      'int     GST_FORMAT_TIME))


;;;
;;;; Adapter
;;;


(interface Source-Adapter
  
  
  (method public virtual abstract (reset self))
  (method public virtual abstract (adapt-time self appsrc timestamp)))


(class Source-Coupler extends Object implements Source-Adapter
  
  
  (slot timestamp-offset initialize #f getter generate)
  
  
  (method override (reset self)
    (set! timestamp-offset #f))


  (method override (adapt-time self appsrc timestamp)
    (or timestamp-offset
        (let ((running-time (gst_element_get_running_time appsrc)))
          (if (= running-time GST_CLOCK_TIME_NONE)
              (error "Invalid pipeline running time")
            (let ((offset (- running-time timestamp)))
              (set! timestamp-offset offset)
              offset))))))


(definition protected rebase-tolerance
  .03)


(class Source-Rebaser extends Object implements Source-Adapter
  
  
  (slot moving-deviation <fl> initialize 0. getter generate)
  (slot timestamp-offset      initialize #f getter generate)
  
  
  (method override (reset self)
    )


  (method override (adapt-time self appsrc timestamp)
    (let ((running-time (gst_element_get_running_time appsrc)))
      (if (= running-time GST_CLOCK_TIME_NONE)
          @really-quick-dirty-patch-until-i-understand-why-this-can-happen
          (error "Invalid pipeline running time")
          0
        (let ((perfect-offset (- running-time timestamp)))
          (if (not timestamp-offset)
              (set! timestamp-offset perfect-offset)
            (let ((deviation (timestamp->flonum (abs (- perfect-offset timestamp-offset)))))
              (set! moving-deviation (/ (+ (* moving-deviation 31.) deviation) 32.))
              (when (> moving-deviation rebase-tolerance)
                (set! timestamp-offset perfect-offset)
                (set! moving-deviation 0.)))))
        timestamp-offset))))


;;;
;;;; AppSink
;;;


(definition public app-sink-info-size
  4)


(definition Keyframe-Flag #x00000001)
(definition Voice-Flag    #x00000002)

(definition protected (frame-keyframe? flags)
  (mask-bit-set? flags Keyframe-Flag))

(definition protected (frame-voice? flags)
  (mask-bit-set? flags Voice-Flag))

(definition protected (frame-flags keyframe? voice?)
  (bitwise-ior (if keyframe? Keyframe-Flag 0)
               (if voice? Voice-Flag 0)))


(definition public (gst_app_sink_connect_signals elem listener)
  (gst_app_sink_connect_listener_signals elem (get-write-file listener)))


(definition public (gst_app_sink_read_frame listener elem vec info)
  (if (get-closed? listener)
      #f
    (let ((c (wait listener)))
      (case c
        ((#\^ #\@)
         #f)
        ((#\.)
         (validate-try-pull-frame (gst_app_sink_try_pull_frame elem vec info)))
        (else
         (error "Invalid app sink char: {s}" c))))))


(definition protected (validate-try-pull-frame size)
  (case size
    ((-1) (error "No sample returned by appsink try-pull"))
    ((-2) (error "Frame too small for sample returned by appsink try-pull"))
    (else size)))


(definition protected (validate-try-pull-buffer buffer)
  (if (not buffer)
      (error "No sample returned by appsink try-pull")
    buffer))


;;;
;;;; Device
;;;


;; hack around what seems to be a memory leak
;; of the device not freeing its caps on mac
(definition public (gst_device_unref_hack device)
  (let ((caps (gst_device_get_caps device)))
    (gst_object_unref device)
    (gst_caps_unref caps)
    (cond-expand
      (mac (gst_caps_unref caps))
      (else))))


(definition public (gst_devices_unref devices)
  (for-each gst_device_unref_hack devices))


;;;
;;;; URI
;;;


(definition public (gst-parse-uri file)
  (gst_filename_to_uri (parse file)))


;;;
;;;; Discoverer
;;;


(definition public (discover-audio file)
  (with-discoverer-info file
    discoverer-info-audio))


(definition public (discover-video file)
  (with-discoverer-info file
    discoverer-info-video))


(definition public (discover-image file)
  (with-discoverer-info file
    discoverer-info-image))


(definition protected (with-discoverer-info file proc)
  (with-unref ((discoverer (gst_discoverer_new)))
    (with-unref ((discoverer-info (gst_discoverer_discover_uri discoverer (gst-parse-uri file))))
      (proc discoverer-info))))


(definition protected (discoverer-info-audio discoverer-info)
  (let ((container-info (gst_discoverer_info_get_stream_info discoverer-info)))
    (let ((container-type (gst_caps_get_name (gst_discoverer_stream_info_get_caps container-info))))
      (define (audio-info stream-info)
        (let ((caps (gst_discoverer_stream_info_get_caps stream-info)))
          (let ((name (gst_caps_get_name caps)))
            (let ((version (and (equal? name "audio/mpeg")
                                (let ((struc (gst_caps_get_structure caps 0)))
                                  (gst_structure_get_int struc "mpegversion")))))
              (prog1 (list container-type
                           name
                           version
                           (gst_discoverer_audio_info_get_bitrate stream-info)
                           (gst_discoverer_audio_info_get_sample_rate stream-info)
                           (gst_discoverer_audio_info_get_channels stream-info)
                           (gst_caps_to_string caps))
                (gst_caps_unref caps))))))
      
      (ecase (G_OBJECT_TYPE container-info)
        ((GST_TYPE_DISCOVERER_AUDIO_INFO)
         (audio-info container-info))
        ((GST_TYPE_DISCOVERER_STREAM_INFO)
         (let ((caps (gst_discoverer_stream_info_get_caps container-info)))
           (let ((caps-string (gst_caps_to_string caps)))
             ;; hack for the mp3 format that is not structured
             ;; as a container containing stream children...
             (prog1 (if (equal? caps-string "application/x-id3")
                        (audio-info (gst_discoverer_stream_info_get_next container-info))
                      #f)
               (gst_caps_unref caps)))))
        ((GST_TYPE_DISCOVERER_CONTAINER_INFO)
         (let ((streams (gst_discoverer_container_info_get_streams container-info)))
           (prog1 (let (loop (streams streams))
                    (if (not streams)
                        #f
                      (let ((stream-info (gst_discoverer_stream_info_list_data streams)))
                        (if (= (G_OBJECT_TYPE stream-info) GST_TYPE_DISCOVERER_AUDIO_INFO)
                            (audio-info stream-info)
                          (loop (gst_discoverer_stream_info_list_next streams))))))
             (gst_discoverer_stream_info_list_free streams))))
        (else
         #f)))))


(definition protected (discoverer-info-video discoverer-info)
  (let ((container-info (gst_discoverer_info_get_stream_info discoverer-info)))
    (let ((container-type (gst_caps_get_name (gst_discoverer_stream_info_get_caps container-info))))
      (if (= (G_OBJECT_TYPE container-info) GST_TYPE_DISCOVERER_CONTAINER_INFO)
          (let ((streams (gst_discoverer_container_info_get_streams container-info)))
            (prog1 (let (loop (streams streams))
                     (if (not streams)
                         #f
                       (let ((stream-info (gst_discoverer_stream_info_list_data streams)))
                         (if (= (G_OBJECT_TYPE stream-info) GST_TYPE_DISCOVERER_VIDEO_INFO)
                             (let ((caps (gst_discoverer_stream_info_get_caps stream-info)))
                               (prog1 (list container-type
                                            (gst_caps_get_name caps)
                                            (new Dimension
                                              (gst_discoverer_video_info_get_width stream-info)
                                              (gst_discoverer_video_info_get_height stream-info))
                                            (/ (cast <fl> (gst_discoverer_video_info_get_framerate_num stream-info))
                                               (cast <fl> (gst_discoverer_video_info_get_framerate_denom stream-info)))
                                            (/ (cast <fl> (gst_discoverer_video_info_get_bitrate stream-info))
                                               1000.)
                                            (gst_caps_to_string caps))
                                 (gst_caps_unref caps)))
                           (loop (gst_discoverer_stream_info_list_next streams))))))
              (gst_discoverer_stream_info_list_free streams)))
        #f))))


(definition public (discoverer-info-image discoverer-info)
  (let ((stream-info (gst_discoverer_info_get_stream_info discoverer-info)))
    (if (= (G_OBJECT_TYPE stream-info) GST_TYPE_DISCOVERER_VIDEO_INFO)
        (let ((caps (gst_discoverer_stream_info_get_caps stream-info)))
          (prog1 (list (gst_caps_get_name caps)
                       (new Dimension
                         (gst_discoverer_video_info_get_width stream-info)
                         (gst_discoverer_video_info_get_height stream-info))
                       (gst_caps_to_string caps))
            (gst_caps_to_string caps)))
      #f)))


(definition public (gst_discoverer_discover_uri discover uri)
  (receive (discoverer-info err) (gst_discoverer_discover_uri_aux discover uri discoverer-info-tags error-tags)
    (if err
        (error "Discoverer discover error: {a}" (g_error_message err))
      discoverer-info)))


;;;
;;;; Registry
;;;


(definition public (collect-registry-plugins registry)
  (let ((queue (new-queue))
        (list (gst_registry_get_plugin_list registry)))
    (let (loop (plugins list))
      (if (not plugins)
          (begin
            (gst_plugin_list_free list)
            (queue-list queue))
        (enqueue queue (gst_plugin_list_data plugins))
        (loop (gst_plugin_list_next plugins))))))


(definition protected (gst-validate)
  (let ((registry (gst_registry_get)))
    (let ((plugins (collect-registry-plugins registry))
          (dir (gstreamer-dir)))
      (collect (lambda (plugin)
                 (if (/= (gst_object_flag_is_set plugin GST_PLUGIN_FLAG_BLACKLISTED) 0)
                     (cons (gst_plugin_get_name plugin) 'blacklisted)
                   (let ((filename (gst_plugin_get_filename plugin)))
                     (if (not filename)
                         #f
                       (if (not (starts-with? filename dir))
                           (cons (gst_plugin_get_name plugin) filename)
                         #f)))))
               plugins))))


;;;
;;;; Flow
;;;


(class GStreamer-Flow extends Flow
  
  
  (slot pipeline initialize #f getter generate)
  (slot appsrc   initialize #f getter generate)
  (slot appsink  initialize #f getter generate)
  (slot window   initialize #f getter generate)
  
  
  (method override (initialize self pipeline appsrc appsink window)
    (nextmethod self)
    (set! self.pipeline pipeline)
    (set! self.appsrc appsrc)
    (set! self.appsink appsink)
    (set! self.window window))
  
  
  (method override (running-time self)
    (gst_element_get_running_time appsrc))
  
  
  (method override (process-window self)
    window)
  
  
  (method override (freeze self)
    (gst_element_send_freeze appsrc))
  
  
  (method override (thaw self)
    (gst_element_send_thaw appsrc)))


;;;
;;;; Report
;;;


(definition public (report-mode pipeline (wait? #t))
  ;; wait for preroll to go to playing
  (when wait?
    (sleep .5))
  (with-unref ((elements (gst_bin_elements_recurse pipeline)))
    (for-each (lambda (elem)
                (with-unref ((pads (gst_element_pads elem)))
                  (for-each (lambda (pad)
                              (let ((dir (gst_pad_get_direction pad))
                                    (mode (gst_pad_get_mode pad))
                                    (task (gst_pad_task pad)))
                                (format :terminal "{a} {s} {s} {s}{%}"
                                  (gst_element_path elem)
                                  (ecase dir
                                    ((GST_PAD_SRC) 'src)
                                    ((GST_PAD_SINK) 'sink))
                                  (ecase mode
                                    ((GST_PAD_MODE_PUSH) 'push)
                                    ((GST_PAD_MODE_PULL) 'pull))
                                  (and task (gst_task_thread task)))))
                            pads)))
              (reverse elements))))


(definition public (report-latency pipeline (wait? #t))
  (define (report elem)
    (let ((info (make-u64vector 3)))
      (gst_element_query_latency elem info)
      (let ((live (u64vector-ref info 0))
            (min (u64vector-ref info 1))
            (max (u64vector-ref info 2)))
        (format :terminal "{a} {a} {a} {a}{%}"
          (gst_element_path elem)
          (= live 1)
          (format "{r precision: 5}" (/ min nanosecond))
          (if (= max GST_CLOCK_TIME_NONE)
              'none
            (format "{r precision: 5}" (/ max nanosecond)))))))
  
  ;; wait for preroll to go to playing
  (when wait?
    (sleep .5))
  (report pipeline)
  (with-unref ((elements (gst_bin_elements_recurse pipeline)))
    (for-each report (reverse elements))))


(definition public (report-caps pipeline (wait? #t))
  ;; wait for preroll to go to playing
  (when wait?
    (sleep .5))
  (with-unref ((elements (gst_bin_elements_recurse pipeline)))
    (for-each (lambda (elem)
                (with-unref ((pads (gst_element_pads elem)))
                  (for-each (lambda (pad)
                              (let ((caps (gst_pad_get_current_caps pad)))
                                (format :terminal "{a} {a} {a}{%}"
                                  (gst_element_path elem)
                                  (ecase (gst_pad_get_direction pad)
                                    ((GST_PAD_SRC) 'src)
                                    ((GST_PAD_SINK) 'sink))
                                  (and caps (gst_caps_to_string caps)))
                                (when caps
                                  (gst_caps_unref caps))))
                            pads)))
              (reverse elements))))


;;;
;;;; Leaks
;;;


(definition default-leaks-file
  {File Home "Devel" "together" "app" "devel" "leaks"})


;; quick ugly hack around many leaks in gstosxaudiosink
(definition default-ignore-audio/x-raw-caps?
  #t)


(definition public (parse-leaks file/port (include-stack?: include-stack? #t) (ignore-audio/x-raw-caps?: ignore-audio/x-raw-caps? default-ignore-audio/x-raw-caps?))
  (define (read-entries input)
    (let ((queue (new-queue)))
      (let (iter (line (read-line input)))
        (if (eof-object? line)
            (queue-list queue)
          (let ((pos (search line "GST_TRACER :0::")))
            (if pos
                (let ((info (substring line (+ pos 16) (string-length line))))
                  (let ((next-line (read-line input)))
                    (if (or (not include-stack?) (search next-line "GST_TRACER :0::") (empty-string? next-line))
                        (begin
                          (terminal 111)
                          (enqueue queue (cons info '()))
                          (iter next-line))
                      (terminal 222)
                      (enqueue queue (cons info (read-stack input next-line)))
                      (iter (read-line input)))))
              (iter (read-line input))))))))
  
  (define (read-stack input line)
    (let ((queue (new-queue)))
      (let (iter (line line))
        (if (equal? line ";")
            (queue-list queue)
          (enqueue queue line)
          (iter (read-line input))))))
  
  (define (parse-entry info)
    (bind (what . rest) (split info ", ")
      (let ((fields (collect (lambda (str)
                               (let ((lst (split str "=")))
                                 (and (> (length lst) 1)
                                      (bind (name value) lst
                                        (cons name value)))))
                             rest)))
        (values what fields))))
  
  (define (parse-what what description)
    (cond ((equal? what "object-alive")
           'alive)
          ((equal? what "object-refings")
           'ref)
          (else
           (error "Unknown what: {s}" what))))
  
  (define (parse-type-name value)
    (if (starts-with? value "(string)")
        (substring value 8 (string-length value))
      value))
  
  (define (parse-address value)
    (if (starts-with? value "(gpointer)")
        (substring value 10 (string-length value))
      value))
  
  (define (parse-description value)
    (if (starts-with? value "(string)")
        (substring value 8 (string-length value))
      value))
  
  (define (parse-refcount value)
    (if (starts-with? value "(uint)")
        (substring value 6 (string-length value))
      value))
  
  (define (parse-stack stack)
    (map parse-frame stack))
  
  (define (parse-frame frame)
    (bind (rank library address function plus offset) (remove-empty (split frame " "))
      (list library function offset)))
  
  (let ((entries (if (port? file/port)
                     (read-entries file/port)
                   (call-with-input-file (path-settings file/port)
                     read-entries))))
    (let ((kept (new-queue))
          (ignored (new-queue)))
      (for-each (lambda (entry)
                  (bind (info . stack) entry
                    (receive (what fields) (parse-entry info)
                      (when (or (equal? what "object-alive")
                                (equal? what "object-refings"))
                        (let ((type (parse-type-name (cdr (assoc "type-name" fields))))
                              (address (parse-address (cdr (assoc "address" fields))))
                              (description (parse-description (cdr (assoc "description" fields))))
                              (refcount (parse-refcount (cdr (assoc "ref-count" fields))))
                              (stack (parse-stack stack)))
                          (let ((what (parse-what what description)))
                            (let ((entry (list what type address description refcount stack)))
                              (if (and ignore-audio/x-raw-caps?
                                       (equal? type "GstCaps")
                                       (equal? description "audio/x-raw"))
                                  (enqueue ignored entry)
                                (enqueue kept entry)))))))))
                entries)
      (values (queue-list kept)
              (queue-list ignored)))))


(definition public (read-leaks port)
  (let ((header (read-line port)))
    (assert (equal? header "jazz")
      (read-all port))))


(definition public (report-leaks (file: file #f) (ignore-audio/x-raw-caps?: ignore-audio/x-raw-caps? default-ignore-audio/x-raw-caps?))
  (receive (entries ignored) (parse-leaks (or file default-leaks-file) include-stack?: #f ignore-audio/x-raw-caps?: ignore-audio/x-raw-caps?)
    (let ((count (length entries))
          (ignored (if (null? ignored) "" (format " ({a} audio/x-raw caps ignored)" (length ignored)))))
      (if (= count 0)
          (format :terminal "{%}No leaks found{a}{%}" ignored)
        (format :terminal "{%}")
        (let ((alive-count 0))
          (for-each (lambda (entry)
                      (bind (what type address description refcount stack) entry
                        (when (equal? what "object-alive")
                          (format :terminal "{a} (0x{a}) {a} refcount={a}{%}" type address description refcount)
                          (increase! alive-count))))
                    entries)
          (format :terminal "{%}Found {a} leak{a}{a}{%}" alive-count (format-plural alive-count) ignored))))))


;;;
;;;; Tools
;;;


(definition public (gst-device-monitor . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-device-monitor-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f)))))


(definition public (gst-discoverer . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-discoverer-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f)))))


(definition public (gst-inspect . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-inspect-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f)))))


(definition public (gst-launch . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-launch-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f)))))


(definition public (gst-play . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-play-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f)))))


(definition public (gst-typefind . arguments)
  (let ((dir (gstreamer-bin-dir)))
    (let ((path (add-extension (string-append dir "gst-typefind-1.0") (executable-extension kernel-platform))))
      (open-process (list path: path arguments: arguments directory: dir stderr-redirection: #t show-console: #f))))))
