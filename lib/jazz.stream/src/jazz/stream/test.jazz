;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Stream Test
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; GST_DEBUG=2 cache/release/jazz -run stream
;; G_DEBUG=fatal-criticals ...
;; G_DEBUG=fatal-warnings ...


(module jazz.stream.test jazz


(import (jazz.application)
        (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.platform)
        (jazz.process)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(startup-gstreamer)


;; none
;; audio
;; video
;; app
;; ogg
;; wav
(definition script
  'app)

(definition audio?
  #f)

;; none     no codec used
;; opus     seems a bug that avenc_opus reports src as unknown/unknown
;; vorbis   working
;; flac     is it an old codec?
(definition audio-codec
  'vorbis)

;; 1200 1920x1200
;; 720  1280x720
;; 540  960x540
;; 360  640x360
;; 180  320x180
(definition video-size
  {Dimension 1280 720})

;; none     no codec used
;; h265     *** cannot find the encoder but should definitely be considered ***
;; h264     *** the best one atm ***
;; h263     doesn't link
;; flv      really blocky.
;; mpeg4    also blocky
;; mpeg2    blocky and slow
;; mpeg1    blocky and slow
;; vp9      much too slow
;; vp8      too slow but faster than vp9
;; theora   cannot find the elements
(definition video-codec
  'h264)

(definition video-framerate
  30)

(definition video-bitrate
  2048)

(definition window-size
  #f)

(definition lag
  #f)

(definition fps?
  #f)

(definition debug?
  #f)

(definition monitor
  'all)

(definition remaining
  #f)


(jazz:split-command-line (command-arguments) '("fps" "debug") '("debugger" "r" "run" "script" "audio" "audio-codec" "size" "codec" "framerate" "bitrate" "window" "lag" "monitor") #f
  (lambda (commands options remain)
    (define (number-argument arg)
      (if (string? arg)
          (string->number arg)
        arg))
    
    (define (symbol-argument arg)
      (if (string? arg)
          (string->symbol arg)
        arg))
    
    (define (size-argument arg)
      (case (number-argument arg)
        ((1200) {Dimension 1920 1200})
        ((720) {Dimension 1280 720})
        ((540) {Dimension 960 540})
        ((360) {Dimension 640 360})
        ((180) {Dimension 320 180})
        (else #f)))
    
    (set! script (or (symbol-argument (find-option "script" options)) script))
    (set! audio? (find-option "audio" options #f))
    (set! audio-codec (or (symbol-argument (find-option "audio-codec" options)) audio-codec))
    (set! video-size (or (size-argument (find-option "size" options)) video-size))
    (set! video-codec (or (symbol-argument (find-option "codec" options)) video-codec))
    (set! video-framerate (or (number-argument (find-option "framerate" options)) video-framerate))
    (set! video-bitrate (or (number-argument (find-option "bitrate" options)) video-bitrate))
    (set! window-size (or (size-argument (find-option "window" options)) video-size))
    (set! lag (number-argument (find-option "lag" options)))
    (set! fps? (find-option "fps" options #f))
    (set! debug? (find-option "debug" options #f))
    (set! monitor (or (symbol-argument (find-option "monitor" options)) monitor))
    (set! remaining remain)))


@comment
(debug script audio-codec video-size video-codec video-framerate video-bitrate window-size lag fps? debug? remaining)


(definition public (test-gstreamer)
  (case script
    ((none))
    ((audio) (test-audio))
    ((video) (test-video))
    ((draw) (test-draw))
    ((app) (test-app))
    ((ogg) (test-ogg))
    ((wav) (test-wav))
    (else (error "Unknown script: {a}" script))))


;;;
;;;; Audio
;;;


(definition public (test-audio)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (let ((codec audio-codec))
          (let ((pipeline (gst-launch "autoaudiosrc name=src"
                                      (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                      (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                      (and (eq? codec 'flac) (tie "flacenc name=enc"))
                                      (and (neq? codec 'none) "identity name=identity")
                                      (and (eq? codec 'opus) "avdec_opus name=dec")
                                      (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                      (and (eq? codec 'flac) "flacdec name=dec")
                                      "autoaudiosink name=sink")))
            (gst_object_set_name pipeline "pipeline")
            (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
              (when debug?
                (when (neq? codec 'none)
                  (gst_monitor pipeline monitor "enc" "identity" "dec"))
                (gst_monitor pipeline monitor "sink"))
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              (let (loop)
                (process-messages)
                (sleep .001)
                (loop))))))
      'audio))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; Video
;;;


(definition public (test-video)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (window-width (get-width window-size))
        (window-height (get-height window-size))
        (codec video-codec)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((video-buffer (make-u8vector (* window-width window-height 4)))
          (video-info (make-u64vector 2))
          (video-mutex (make-mutex 'video))
          (pipe (open-vector))
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (increase! draw-count)
        (with-video-mutex
          (lambda ()
            (move-u8vector->pointer! video-buffer (cairo_image_surface_get_data (get-handle surface)))))
        (set-font surface {Font Label point-size: 36})
        (draw-text surface 10 16 (format "{a} skipped" (- frame-count draw-count)) {Color Red}))
      
      ;; video
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read pipe)))
              (let ((pipeline (gst-launch "avfvideosrc name=src"
                                          "videoscale name=scale"
                                          "videoconvert name=convert"
                                          (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                          (and (eq? codec 'h265) "??? name=enc")
                                          (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc"))
                                          (and (eq? codec 'h263) "avenc_h263 name=enc")
                                          (and (eq? codec 'flv) "avenc_flv name=enc")
                                          (and (eq? codec 'mpeg4) "avenc_mpeg4 name=enc")
                                          (and (eq? codec 'mpeg2) "avenc_mpeg2video name=enc")
                                          (and (eq? codec 'mpeg1) "avenc_mpeg1video name=enc")
                                          (and (eq? codec 'vp9) "vp9enc deadline=1 name=enc")
                                          (and (eq? codec 'vp8) "vp8enc deadline=1 name=enc")
                                          (and (eq? codec 'theora) "theoraenc name=enc")
                                          (and (neq? codec 'none) "identity name=identity")
                                          (and (eq? codec 'h265) "avdec_h265 name=dec")
                                          (and (eq? codec 'h264) "avdec_h264 name=dec")
                                          (and (eq? codec 'h263) "avdec_h263 name=dec")
                                          (and (eq? codec 'flv) "avdec_flv name=dec")
                                          (and (eq? codec 'mpeg4) "avdec_mpeg4 name=dec")
                                          (and (eq? codec 'mpeg2) "avdec_mpeg2video name=dec")
                                          (and (eq? codec 'mpeg1) "avdec_mpegvideo name=dec")
                                          (and (eq? codec 'vp9) "vp9dec name=dec")
                                          (and (eq? codec 'vp8) "vp8dec name=dec")
                                          (and (eq? codec 'theora) "theoradec name=dec")
                                          "videoconvert name=convert2"
                                          "videoflip video-direction=horiz"
                                          "videoscale name=scale2"
                                          (tie "video/x-raw, format=BGRA, width={window-width}, height={window-height}, framerate={framerate}/1")
                                          (if fps?
                                              "fpsdisplaysink video-sink=appsink name=sink"
                                            "appsink name=sink"))))
                (gst_object_set_name pipeline "pipeline")
                (let ((sink (gst_bin_get_by_name pipeline "sink"))
                      (process-messages (pipeline-messages-processor pipeline print?: debug?)))
                  (when debug?
                    (when (neq? codec 'none)
                      (gst_monitor pipeline monitor "enc" "identity" "dec"))
                    (gst_monitor pipeline monitor "convert2" "sink"))
                  (gst_element_set_state pipeline GST_STATE_PLAYING)
                  (process-messages)
                  (let (loop)
                    (let ((size (with-video-mutex
                                  (lambda ()
                                    (gst_app_sink_read sink video-buffer video-info)))))
                      (when (/= size -1)
                        (increase! frame-count)
                        (invalidate-view view)))
                    (process-messages)
                    (sleep .001)
                    (loop))))))
          'video))
      ;; application
      (boot-environment (new Test-Application size: window-size pipe: pipe drawer: drawer)))))


;;;
;;;; Draw
;;;


(definition public (test-draw)
  (initialize-aliases)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (framerate video-framerate)
        (bitrate 4096))
    (let ((video-pipe (open-vector))
          (memory-surface (new Memory-Surface #f (new Dimension width height)))
          (surface-mutex (make-mutex 'surface))
          (view-pipe (open-vector))
          (frame-count 0)
          (draw-count 0))
      (define (with-surface-mutex thunk)
        (mutex-lock! surface-mutex)
        (prog1 (thunk)
          (mutex-unlock! surface-mutex)))
      
      (define (draw surface)
        (clear surface)
        (fill-rect surface (new Rect 0 0 width height) {Color Blue alpha: .6})
        (set-font surface {Font Code point-size: 60})
        (draw-text surface 110 100 "(draw-text surface)" {Color Black})
        (set-font surface {Font Label point-size: 30})
        (draw-text surface 110 200 "Hello world!" {Color Black}))
      
      (define (drawer view surface)
        (increase! draw-count)
        (clear surface)
        (fill-rect surface (new Rect 100 70 800 400) {Color Red alpha: .8})
        (with-surface-mutex
          (lambda ()
            (draw-surface surface (get-handle memory-surface) 0 0)))
        (set-font surface {Font Label point-size: 36})
        (draw-text surface 10 16 (format "{a} skipped" (- frame-count draw-count)) {Color Red}))
      
      ;; input
      (thread-start!
        (new-thread
          (lambda ()
            (let ((color-pipeline (gst-launch "appsrc name=src"
                                              "videoconvert name=convert"
                                              (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                              (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc")
                                              "appsink name=sink")))
              (let ((color-src (gst_bin_get_by_name color-pipeline "src"))
                    (color-sink (gst_bin_get_by_name color-pipeline "sink")))
                (gst-setup-source color-src "video/x-raw" "BGRA" width height framerate)
                (gst_element_set_state color-pipeline GST_STATE_PLAYING)
                (let ((alpha-pipeline (gst-launch "appsrc name=src"
                                                  (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc")
                                                  "appsink name=sink")))
                  (let ((alpha-src (gst_bin_get_by_name alpha-pipeline "src"))
                        (alpha-sink (gst_bin_get_by_name alpha-pipeline "sink")))
                    (gst-setup-source alpha-src "video/x-raw" "I420" width height framerate)
                    (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)
                    (let ((color-buffer (make-u8vector (* width height 4)))
                          (color-info (make-u64vector 2))
                          (color-bytes #f)
                          (alpha-buffer (make-u8vector (/ (* width height 12) 8)))
                          (alpha-info (make-u64vector 2))
                          (alpha-bytes #f)
                          (alpha-data (heap-calloc (/ (* width height 12) 8) 1))
                          (surface (new Memory-Surface #f video-size))
                          (start #f))
                      (let (loop)
                        (when (and (not color-bytes) (not alpha-bytes))
                          (draw surface)
                          (set! start (real-time))
                          (let ((data (cairo_image_surface_get_data (get-handle surface)))
                                (size (* width height 4))
                                (alpha-size (/ (* width height 12) 8))
                                (timestamp 0)
                                (duration 100))
                            (separate-alpha data alpha-data (* width height))
                            (gst_app_src_write4 color-src data size timestamp duration)
                            (gst_app_src_write4 alpha-src alpha-data alpha-size timestamp duration)))
                        (when (not color-bytes)
                          (let ((size (gst_app_sink_read color-sink color-buffer color-info)))
                            (when (/= size -1)
                              (set! color-bytes size))))
                        (when (not alpha-bytes)
                          (let ((size (gst_app_sink_read alpha-sink alpha-buffer alpha-info)))
                            (when (/= size -1)
                              (set! alpha-bytes size))))
                        (when (and color-bytes alpha-bytes)
                          ;(terminal (- (real-time) start) color-bytes alpha-bytes)
                          (let ((timestamp (u64vector-ref color-info 0))
                                (duration (u64vector-ref color-info 1)))
                            (write (list (u8vector-copy color-buffer) color-bytes (u8vector-copy alpha-buffer) alpha-bytes timestamp duration) video-pipe)
                            (force-output video-pipe))
                          (set! color-bytes #f)
                          (set! alpha-bytes #f))
                        (sleep .001)
                        (loop))))))))
          'input))
      ;; output
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read view-pipe)))
              (let ((color-pipeline (gst-launch "appsrc name=src"
                                                "avdec_h264 name=dec"
                                                "videoconvert name=convert"
                                                (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                                "appsink name=sink")))
                (let ((color-src (gst_bin_get_by_name color-pipeline "src"))
                      (color-sink (gst_bin_get_by_name color-pipeline "sink")))
                  (gst-setup-source color-src "video/x-h264" "I420" width height framerate stream-format: "avc" alignment: "au")
                  (gst_element_set_state color-pipeline GST_STATE_PLAYING)
                  (let ((alpha-pipeline (gst-launch "appsrc name=src"
                                                    "avdec_h264 name=dec"
                                                    "appsink name=sink")))
                    (let ((alpha-src (gst_bin_get_by_name alpha-pipeline "src"))
                          (alpha-sink (gst_bin_get_by_name alpha-pipeline "sink")))
                      (gst-setup-source alpha-src "video/x-h264" "I420" width height framerate stream-format: "avc" alignment: "au")
                      (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)
                      (let ((color-buffer (make-u8vector (* width height 4)))
                            (color-info (make-u64vector 2))
                            (color-bytes #f)
                            (alpha-buffer (make-u8vector (/ (* width height 12) 8)))
                            (alpha-info (make-u64vector 2))
                            (alpha-bytes #f))
                        (let (loop)
                          (when (and (not color-bytes) (not alpha-bytes))
                            (let ((info (read video-pipe)))
                              (bind (buffer bytes alpha-buffer alpha-bytes timestamp duration) info
                                (gst_app_src_write3 color-src buffer bytes timestamp duration)
                                (gst_app_src_write3 alpha-src alpha-buffer alpha-bytes timestamp duration))))
                          (when (not color-bytes)
                            (let ((size (gst_app_sink_read color-sink color-buffer color-info)))
                              (when (/= size -1)
                                (set! color-bytes size))))
                          (when (not alpha-bytes)
                            (let ((size (gst_app_sink_read alpha-sink alpha-buffer alpha-info)))
                              (when (/= size -1)
                                (set! alpha-bytes size))))
                          (when (and color-bytes alpha-bytes)
                            (increase! frame-count)
                            (with-surface-mutex
                              (lambda ()
                                (cairo_surface_flush (get-handle memory-surface))
                                (combine-alpha color-buffer alpha-buffer (cairo_image_surface_get_data (get-handle memory-surface)) (* width height))
                                (cairo_surface_mark_dirty (get-handle memory-surface))))
                            (invalidate-view view)
                            (set! color-bytes #f)
                            (set! alpha-bytes #f))
                          (loop)))))))))
          'output))
      ;; application
      (boot-environment (new Test-Application size: video-size pipe: view-pipe drawer: drawer)))))


;;;
;;;; App
;;;


;; PLUGINS
;; - adder: Add N audio channels together
;; - audioamplify: Amplifies an audio stream by a given factor
;; - mpg123audiodec: Decodes mp3 streams using the mpg123 library
;; - openalsrc: Input audio through OpenAL
;; - openalsink: Output audio through OpenAL
;; - opusenc: Encodes audio in Opus format
;; - opusdec: decode opus streams to audio
;; - speexenc: Encodes audio in Speex format
;; - speexdec: decode speex streams to audio
;; - wavenc: Encode raw audio into WAV
;; - wavpackdec: Decodes Wavpack audio data	wavpack	gst-plugins-good
;; - wavpackenc: Encodes audio with the Wavpack lossless/lossy audio codec
;; - netsim: Network Simulator

;; QUESTIONS
;; - make opus codec work
;; - how to determine audio max size
;; - what format / layout / rate / channels to use for audio
;; - why the big delay with audio
;; - why is no codec audio not working


(definition public (test-app)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (codec video-codec)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((audio-pipe (open-vector))
          (video-pipe (open-vector))
          (video-buffer (make-u8vector (* width height 4)))
          (video-info (make-u64vector 2))
          (video-mutex (make-mutex 'video))
          (pipe (open-vector))
          (frame-size 0)
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (increase! draw-count)
        (with-video-mutex
          (lambda ()
            (move-u8vector->pointer! video-buffer (cairo_image_surface_get_data (get-handle surface)))))
        (set-font surface {Font Label point-size: 36})
        (draw-text surface 10 16 (format "{r precision: 1} kb, {a} skipped" (/ (cast <fl> frame-size) 1024.) (- frame-count draw-count)) {Color Red}))
      
      ;; audio input
      (when audio?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((codec audio-codec))
                (let ((pipeline (gst-launch "autoaudiosrc format=F32LE layout=interleaved rate=80000 channels=2 name=src"
                                            (and (eq? codec 'opus) (tie "avenc_opus name=enc"))
                                            (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                            "appsink name=sink")))
                  (gst_object_set_name pipeline "input")
                  (let ((sink (gst_bin_get_by_name pipeline "sink"))
                        (process-messages (pipeline-messages-processor pipeline print?: debug?)))
                    (when debug?
                      (when (neq? codec 'none)
                        (gst_monitor pipeline monitor "enc" "identity" "dec"))
                      (gst_monitor pipeline monitor "sink"))
                    (gst_element_set_state pipeline GST_STATE_PLAYING)
                    (let ((buffer (make-u8vector 4096))
                          (info (make-u64vector 2)))
                      (let (loop)
                        (let ((size (gst_app_sink_read sink buffer info)))
                          (when (/= size -1)
                            (let ((timestamp (u64vector-ref info 0))
                                  (duration (u64vector-ref info 1)))
                              (write (list (u8vector-copy buffer) size timestamp duration) audio-pipe)
                              (force-output audio-pipe))))
                        (process-messages)
                        (sleep .001)
                        (loop)))))))
            'audio-input)))
      ;; video input
      (thread-start!
        (new-thread
          (lambda ()
            (let ((pipeline (gst-launch "avfvideosrc name=src"
                                        "videoscale name=scale"
                                        "videoconvert name=convert"
                                        (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                        (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc"))
                                        (and (eq? codec 'vp8) "vp8enc deadline=1 name=enc")
                                        "appsink name=sink")))
              (gst_object_set_name pipeline "input")
              (let ((sink (gst_bin_get_by_name pipeline "sink"))
                    (process-messages (pipeline-messages-processor pipeline print?: debug?)))
                (when debug?
                  (gst_monitor pipeline monitor "src" "sink"))
                (gst_element_set_state pipeline GST_STATE_PLAYING)
                (process-messages)
                (let ((buffer (make-u8vector (* width height 4)))
                      (info (make-u64vector 2)))
                  (let (loop)
                    (let ((size (gst_app_sink_read sink buffer info)))
                      (when (/= size -1)
                        (let ((timestamp (u64vector-ref info 0))
                              (duration (u64vector-ref info 1)))
                          (write (list (u8vector-copy buffer) size timestamp duration) video-pipe)
                          (force-output video-pipe))))
                    (process-messages)
                    (sleep .001)
                    (loop))))))
          'video-input))
      ;; lag
      (when lag
        (sleep lag))
      ;; audio output
      (when audio?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((codec audio-codec))
                (let ((pipeline (gst-launch "appsrc name=src"
                                            (and (eq? codec 'opus) "avdec_opus name=dec")
                                            (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                            "autoaudiosink name=sink")))
                  (gst_object_set_name pipeline "output")
                  (let ((src (gst_bin_get_by_name pipeline "src"))
                        (process-messages (pipeline-messages-processor pipeline print?: debug?)))
                    (when debug?
                      (when (neq? codec 'none)
                        (gst_monitor pipeline monitor "enc" "identity" "dec"))
                      (gst_monitor pipeline monitor "sink"))
                    (case codec
                      ((vorbis)
                       (gst_app_src_set_caps src
                                             (gst_caps "audio/x-vorbis")))
                      (else
                       (gst_app_src_set_caps src
                                             (gst_caps "audio/x-raw"
                                                       "format"   (g_value_string "F32LE")
                                                       "layout"   (g_value_string "interleaved")
                                                       "rate"     (g_value_int 80000)
                                                       "channels" (g_value_int 2)))))
                    (g_object_set src
                                  "is-live"     (g_value_boolean #t)
                                  "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                                  "format"      (g_value_int GST_FORMAT_TIME))
                    (gst_element_set_state pipeline GST_STATE_PLAYING)
                    (process-messages)
                    (let (loop)
                      (let ((info (read audio-pipe)))
                        (bind (buffer size timestamp duration) info
                          (terminal '*** size)
                          (gst_app_src_write3 src buffer size timestamp duration)))
                      (process-messages)
                      (loop))))))
            'audio-output)))
      ;; video output
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read pipe)))
              (let ((pipeline (gst-launch "appsrc name=src"
                                          (and (eq? codec 'h264) "avdec_h264 name=dec")
                                          (and (eq? codec 'vp8) "vp8dec name=dec")
                                          "videoconvert name=convert"
                                          "videoflip video-direction=horiz"
                                          (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                          (if fps?
                                              "fpsdisplaysink video-sink=appsink name=sink"
                                            "appsink name=sink"))))
                (gst_object_set_name pipeline "output")
                (let ((src (gst_bin_get_by_name pipeline "src"))
                      (sink (gst_bin_get_by_name pipeline "sink"))
                      (process-messages (pipeline-messages-processor pipeline print?: debug?)))
                  (when debug?
                    (gst_monitor pipeline monitor "src" "convert" "sink")
                    (when (neq? codec 'none)
                      (gst_monitor pipeline monitor "dec")))
                  (case codec
                    ((h264)
                     (gst_app_src_set_caps src
                                           (gst_caps "video/x-h264"
                                                     "width"         (g_value_int width)
                                                     "height"        (g_value_int height)
                                                     "framerate"     (g_value_fraction framerate 1)
                                                     "stream-format" (g_value_string "avc")
                                                     "alignment"     (g_value_string "au"))))
                    ((vp8)
                     (gst_app_src_set_caps src
                                           (gst_caps "video/x-vp8"
                                                     "width"         (g_value_int width)
                                                     "height"        (g_value_int height)
                                                     "framerate"     (g_value_fraction framerate 1)
                                                     "stream-format" (g_value_string "avc")
                                                     "alignment"     (g_value_string "au"))))
                    (else
                     (gst_app_src_set_caps src
                                           (gst_caps "video/x-raw"
                                                     "format"    (g_value_string "I420")
                                                     "width"     (g_value_int width)
                                                     "height"    (g_value_int height)
                                                     "framerate" (g_value_fraction framerate 1)))))
                  (g_object_set src
                                "is-live"     (g_value_boolean #t)
                                "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                                "format"      (g_value_int GST_FORMAT_TIME))
                  (gst_element_set_state pipeline GST_STATE_PLAYING)
                  (process-messages)
                  (let (loop)
                    (let ((info (read video-pipe)))
                      (bind (buffer size timestamp duration) info
                        (set! frame-size size)
                        (gst_app_src_write3 src buffer size timestamp duration)))
                    (let ((size (with-video-mutex
                                  (lambda ()
                                    (gst_app_sink_read sink video-buffer video-info)))))
                      (when (/= size -1)
                        (increase! frame-count)
                        (invalidate-view view)))
                    (process-messages)
                    (loop))))))
          'video-output))
      ;; application
      (boot-environment (new Test-Application size: video-size pipe: pipe drawer: drawer)))))


;;;
;;;; OGG
;;;


(definition public (test-ogg)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (let ((pipeline (gst_pipeline_new "audio-player")))
          (let ((source   (gst_element_factory_make "filesrc"       "file-source"))
                (demuxer  (gst_element_factory_make "oggdemux"      "ogg-demuxer"))
                (decoder  (gst_element_factory_make "vorbisdec"     "vorbis-decoder"))
                (conv     (gst_element_factory_make "audioconvert"  "converter"))
                (volume   (gst_element_factory_make "volume"        "volume"))
                (panorama (gst_element_factory_make "audiopanorama" "audiopanorama"))
                (sink     (gst_element_factory_make "autoaudiosink" "audio-output")))
            (g_object_set_string source "location" "/Users/cartier/Media/test.ogg")
            (let ((bus (gst_pipeline_get_bus pipeline)))
              (gst_bin_add pipeline source)
              (gst_bin_add pipeline demuxer)
              (gst_bin_add pipeline decoder)
              (gst_bin_add pipeline conv)
              (gst_bin_add pipeline volume)
              (gst_bin_add pipeline panorama)
              (gst_bin_add pipeline sink)
              (gst_element_link source demuxer)
              (gst_element_link demuxer decoder)
              (gst_element_link decoder conv)
              (gst_element_link conv volume)
              (gst_element_link volume panorama)
              (gst_element_link panorama sink)
              (g_object_set_double volume "volume" .1)
              (g_object_set_double panorama "panorama" -1.)
              (gst_signal_connect_to demuxer "pad-added" decoder)
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              ;; augment volume
              (let ((vol .1))
                (thread-start!
                  (new-thread
                    (lambda ()
                      (let (loop)
                        (set! vol (min (* vol 1.025) 1.))
                        (g_object_set_double volume "volume" vol)
                        (sleep .1)
                        (loop))))))
              ;; pan left to right
              (let ((pan -1.))
                (thread-start!
                  (new-thread
                    (lambda ()
                      (let (loop)
                        (set! pan (min (+ pan .01) 1.))
                        (g_object_set_double panorama "panorama" pan)
                        (sleep .1)
                        (loop))))))))))
      'ogg))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; WAV
;;;


(define (play-explosion)
  (let ((pipeline (gst_pipeline_new "audio-player")))
    (let ((source  (gst_element_factory_make "filesrc"       "file-source"))
          (decoder (gst_element_factory_make "wavparse"      "wavparse"))
          (conv    (gst_element_factory_make "audioconvert"  "converter"))
          (sink    (gst_element_factory_make "autoaudiosink" "audio-output")))
      (g_object_set_string source "location" "/Users/cartier/Media/test.wav")
      (let ((bus (gst_pipeline_get_bus pipeline)))
        (gst_bin_add pipeline source)
        (gst_bin_add pipeline decoder)
        (gst_bin_add pipeline conv)
        (gst_bin_add pipeline sink)
        (gst_element_link source decoder)
        (gst_element_link decoder conv)
        (gst_element_link conv sink)
        (gst_element_set_state pipeline GST_STATE_PLAYING)))))


(definition public (test-wav)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (loop (repeat 20)
              (play-explosion)
              (sleep .1)))
      'wav))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; Application
;;;


(class Test-Application extends Application
  
  
  (slot size   getter generate)
  (slot pipe   getter generate)
  (slot drawer getter generate)
  
  
  (method override (initialize self (size: size #f) (pipe: pipe #f) (drawer: drawer #f))
    (set! self.size (or size {Dimension 640 360}))
    (set! self.pipe pipe)
    (set! self.drawer drawer))
  
  
  (method override (new-toplevel self)
    (new Toplevel caption-base: "Test" size: size))
  
  
  (method override (finish-process self)
    (nextmethod self)
    (let ((view (get-guest (new-frame Test-View host-title: (->string script) drawer: drawer))))
      (when pipe
        (write view pipe)))))


;;;
;;;; View
;;;


(class Test-View extends View
  
  
  (property drawer initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (when drawer
      (drawer self surface)))))
