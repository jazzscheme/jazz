;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Stream Test
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; gst-pipeline --gst-debug-help
;; - these can be applied to individual elements in the pipeline
;; GST_DEBUG=2 cache/release/jazz -run stream
;; G_DEBUG=fatal-criticals ...
;; G_DEBUG=fatal-warnings ...
;; G_DEBUG=fatal-criticals gdb -ex run --args ./test arg1 arg2 ...
;; GST_TRACERS="leaks" GST_DEBUG="GST_TRACER:7"
;; GST_DEBUG_DUMP_DOT_DIR=. ...


(module jazz.stream.test jazz


(import (jazz.application)
        (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.jpeg)
        (jazz.listener)
        (jazz.markup)
        (jazz.platform)
        (jazz.process)
        (jazz.screen)
        (jazz.stream)
        (jazz.stream.syntax (phase syntax))
        (jazz.syntax (phase syntax))
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(startup-gstreamer)

(set-use-retina? #f)

(initialize-aliases)


;; none
;; info
;; mic
;; camera
;; screen
;; app
;; ogg
;; wav
;; jpeg
;; media
;; leak
;; gambit
(definition script
  'app)

(definition audio?
  #f)

;; none     no codec used
;; opus     working
;; vorbis   working
;; flac     is it an old codec?
(definition audio-codec
  'vorbis)

(definition video?
  #f)

;; 1080 1920x1080
;; 720  1280x720
;; 540  960x540
;; 360  640x360
;; 180  320x180
(definition video-size
  {Dimension 1280 720})

;; none     no codec used
;; h265     *** cannot find the encoder but should definitely be considered ***
;; h264     *** the best one at the moment and is probably faster than h265 ***
;; h263     doesn't link
;; flv      really blocky.
;; mpeg4    also blocky
;; mpeg2    blocky and slow
;; mpeg1    blocky and slow
;; vp9      much too slow
;; vp8      too slow but faster than vp9
;; theora   cannot find the elements
(definition video-codec
  'h264)

(definition video-framerate
  (cond-expand
    (linux 25)
    (else 30)))

(definition video-bitrate
  2048)

(definition window-size
  #f)

(definition media
  #f)

(definition spawn
  #f)

(definition period
  #f)

(definition lag
  #f)

(definition fps?
  #f)

(definition info?
  #f)

(definition debug?
  #f)

(definition monitor
  #f)

(definition remaining
  #f)


(jazz:split-command-line (command-arguments) '("fps" "info" "debug") '("debugger" "r" "run" "script" "audio" "audio-codec" "video" "size" "codec" "framerate" "bitrate" "window" "media" "spawn" "period" "lag" "monitor") #f
  (lambda (commands options remain)
    (define (string-argument arg)
      arg)
    
    (define (boolean-argument arg)
      (if (string? arg)
          (parse-boolean arg)
        arg))
    
    (define (number-argument arg)
      (if (string? arg)
          (string->number arg)
        arg))
    
    (define (symbol-argument arg)
      (if (string? arg)
          (string->symbol arg)
        arg))
    
    (define (size-argument arg)
      (case (number-argument arg)
        ((1080) {Dimension 1920 1080})
        ((720) {Dimension 1280 720})
        ((540) {Dimension 960 540})
        ((360) {Dimension 640 360})
        ((180) {Dimension 320 180})
        ;; custom
        ((480) {Dimension 640 480})
        (else #f)))
    
    (when (not-null? remain)
      (format :terminal "Unknown options: {l}{%}" remain))
    
    (set! script (or (symbol-argument (find-option "script" options)) script))
    (set! audio? (boolean-argument (find-option "audio" options #f)))
    (set! audio-codec (or (symbol-argument (find-option "audio-codec" options)) audio-codec))
    (set! video? (boolean-argument (find-option "video" options #t)))
    (set! video-size (or (size-argument (find-option "size" options)) video-size))
    (set! video-codec (or (symbol-argument (find-option "codec" options)) video-codec))
    (set! video-framerate (or (number-argument (find-option "framerate" options)) video-framerate))
    (set! video-bitrate (or (number-argument (find-option "bitrate" options)) video-bitrate))
    (set! window-size (or (size-argument (find-option "window" options)) video-size))
    (set! media (string-argument (find-option "media" options)))
    (set! spawn (number-argument (find-option "spawn" options)))
    (set! period (number-argument (find-option "period" options)))
    (set! lag (number-argument (find-option "lag" options)))
    (set! fps? (find-option "fps" options #f))
    (set! info? (find-option "info" options #f))
    (set! debug? (find-option "debug" options #f))
    (set! monitor (or (symbol-argument (find-option "monitor" options)) monitor))
    (set! remaining remain)))


@comment
(debug script audio audio-codec video video-size video-codec video-framerate video-bitrate window-size lag fps? info? debug? remaining)


(definition public (test-gstreamer)
  (case script
    ((none))
    ((info) (test-info))
    ((mic) (test-mic))
    ((camera) (test-camera))
    ((screen) (test-screen))
    ((draw) (test-draw))
    ((app) (test-app))
    ((ogg) (test-ogg))
    ((wav) (test-wav))
    ((jpeg) (test-jpeg))
    ((media) (test-media))
    ((leak) (test-leak))
    ((gambit) (test-gambit))
    (else (error "Unknown script: {a}" script))))


;;;
;;;; Info
;;;


(definition public (test-info)
  (terminal (gst-version)))


;;;
;;;; Mic
;;;


(definition public (test-mic)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (let ((codec audio-codec))
          (let ((pipeline (gst-pipeline "autoaudiosrc name=src"
                                        (and (eq? codec 'opus) (tie "opusenc name=enc"))
                                        (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                        (and (eq? codec 'flac) (tie "flacenc name=enc"))
                                        (and (neq? codec 'none) "identity name=identity")
                                        (and (eq? codec 'opus) "opusdec name=dec")
                                        (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                        (and (eq? codec 'flac) "flacdec name=dec")
                                        (cond-expand
                                          (windows "directsoundsink buffer-time=200000 name=sink")
                                          (mac "osxaudiosink buffer-time=200000 name=sink")
                                          (else "pulsesink buffer-time=200000 name=sink")))))
            (gst_object_set_name pipeline "pipeline")
            (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
              (when monitor
                (when (neq? codec 'none)
                  (gst_monitor pipeline monitor "enc" "identity" "dec"))
                (gst_monitor pipeline monitor "sink"))
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              (let (loop)
                (process-messages)
                (sleep .001)
                (loop))))))
      'audio))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; Camera
;;;


(definition public (test-camera)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (window-width (get-width window-size))
        (window-height (get-height window-size))
        (codec video-codec)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((video-buffer (make-u8vector (* window-width window-height 4)))
          (video-info (make-u64vector app-sink-info-size))
          (video-mutex (make-mutex 'video))
          (transferer (make-transferer video-size))
          (pipe (open-vector))
          (listener (open-stream-listener))
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (with-video-mutex
          (lambda ()
            (increase! draw-count)
            (transferer video-buffer surface)
            (when info?
              (set-font surface {Font Label point-size: 36})
              (draw-text surface 10 16 (format "{a} skipped" (- frame-count draw-count)) {Color Red})))))
      
      ;; video
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read pipe)))
              (let ((pipeline (gst-pipeline (cond-expand
                                              (mac "avfvideosrc name=src")
                                              (windows "ksvideosrc name=src")
                                              (else "v4l2src name=src"))
                                            "videoscale name=scale"
                                            "videoconvert name=convert"
                                            (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                            "queue"
                                            (and (eq? codec 'h265) "??? name=enc")
                                            (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc"))
                                            (and (eq? codec 'h263) "avenc_h263 name=enc")
                                            (and (eq? codec 'flv) "avenc_flv name=enc")
                                            (and (eq? codec 'mpeg4) "avenc_mpeg4 name=enc")
                                            (and (eq? codec 'mpeg2) "avenc_mpeg2video name=enc")
                                            (and (eq? codec 'mpeg1) "avenc_mpeg1video name=enc")
                                            (and (eq? codec 'vp9) "vp9enc deadline=1 name=enc")
                                            (and (eq? codec 'vp8) "vp8enc deadline=1 name=enc")
                                            (and (eq? codec 'theora) "theoraenc name=enc")
                                            (and (neq? codec 'none) "identity name=identity")
                                            (and (eq? codec 'h265) "avdec_h265 name=dec")
                                            (and (eq? codec 'h264) "avdec_h264 name=dec")
                                            (and (eq? codec 'h263) "avdec_h263 name=dec")
                                            (and (eq? codec 'flv) "avdec_flv name=dec")
                                            (and (eq? codec 'mpeg4) "avdec_mpeg4 name=dec")
                                            (and (eq? codec 'mpeg2) "avdec_mpeg2video name=dec")
                                            (and (eq? codec 'mpeg1) "avdec_mpegvideo name=dec")
                                            (and (eq? codec 'vp9) "vp9dec name=dec")
                                            (and (eq? codec 'vp8) "vp8dec name=dec")
                                            (and (eq? codec 'theora) "theoradec name=dec")
                                            "videoconvert name=convert2"
                                            "videoflip video-direction=horiz"
                                            "videoscale name=scale2"
                                            (tie "video/x-raw, format=BGRA, width={window-width}, height={window-height}, framerate={framerate}/1")
                                            (if fps?
                                                "fpsdisplaysink video-sink=appsink name=sink"
                                              "appsink name=sink"))))
                (gst_object_set_name pipeline "pipeline")
                (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
                  (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                    (gst_app_sink_connect_signals sink listener)
                    (when monitor
                      (when (neq? codec 'none)
                        (gst_monitor pipeline monitor "enc" "identity" "dec"))
                      (gst_monitor pipeline monitor "convert2" "sink"))
                    (gst_element_set_state pipeline GST_STATE_PLAYING)
                    (process-messages)
                    (let (loop)
                      (let ((size (with-video-mutex
                                    (lambda ()
                                      (gst_app_sink_read listener sink video-buffer video-info)))))
                        (increase! frame-count)
                        (invalidate-view view))
                      (process-messages)
                      (loop)))))))
          'video))
      ;; application
      (boot-environment (new Test-Application size: window-size pipe: pipe drawer: drawer)))))


;;;
;;;; Screen
;;;


(definition public (test-screen)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (window-width (get-width window-size))
        (window-height (get-height window-size))
        (codec video-codec)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((video-buffer (make-u8vector (* window-width window-height 4)))
          (video-info (make-u64vector app-sink-info-size))
          (video-mutex (make-mutex 'video))
          (transferer (make-transferer video-size))
          (pipe (open-vector))
          (listener (open-stream-listener))
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (with-video-mutex
          (lambda ()
            (increase! draw-count)
            (transferer video-buffer surface)
            (when info?
              (set-font surface {Font Label point-size: 36})
              (draw-text surface 10 16 (format "{a} skipped" (- frame-count draw-count)) {Color Red})))))
      
      ;; video
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read pipe)))
              (let ((pipeline (gst-pipeline (cond-expand
                                              (mac "avfvideosrc capture-screen=true name=src")
                                              (windows "dx9screencapsrc name=src")
                                              (else "ximagesrc name=src"))
                                            "videoscale name=scale"
                                            "videoconvert name=convert"
                                            (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                            "queue"
                                            (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc"))
                                            (and (neq? codec 'none) "identity name=identity")
                                            (and (eq? codec 'h264) "avdec_h264 name=dec")
                                            "videoconvert name=convert2"
                                            "videoscale name=scale2"
                                            (tie "video/x-raw, format=BGRA, width={window-width}, height={window-height}, framerate={framerate}/1")
                                            (if fps?
                                                "fpsdisplaysink video-sink=appsink name=sink"
                                              "appsink name=sink"))))
                (gst_object_set_name pipeline "pipeline")
                (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
                  (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                    (gst_app_sink_connect_signals sink listener)
                    (when monitor
                      (when (neq? codec 'none)
                        (gst_monitor pipeline monitor "enc" "identity" "dec"))
                      (gst_monitor pipeline monitor "convert2" "sink"))
                    (gst_element_set_state pipeline GST_STATE_PLAYING)
                    (process-messages)
                    (let (loop)
                      (let ((size (with-video-mutex
                                    (lambda ()
                                      (gst_app_sink_read listener sink video-buffer video-info)))))
                        (increase! frame-count)
                        (invalidate-view view))
                      (process-messages)
                      (loop)))))))
          'video))
      ;; application
      (boot-environment (new Test-Application size: window-size pipe: pipe drawer: drawer)))))


;;;
;;;; Draw
;;;


(definition public (test-draw)
  (initialize-aliases)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (framerate video-framerate)
        (bitrate 4096))
    (let ((video-pipe (open-vector))
          (image-surface (new Image-Surface (new Dimension width height)))
          (surface-mutex (make-mutex 'surface))
          (view-pipe (open-vector))
          (frame-count 0)
          (draw-count 0))
      (define (with-surface-mutex thunk)
        (mutex-lock! surface-mutex)
        (prog1 (thunk)
          (mutex-unlock! surface-mutex)))
      
      (define (draw surface)
        (clear surface)
        (fill-rect surface (new Rect 0 0 width height) {Color Blue alpha: .6})
        (set-font surface {Font Code point-size: 60})
        (draw-text surface 110 100 "(draw-text surface)" {Color Black})
        (set-font surface {Font Label point-size: 30})
        (draw-text surface 110 200 "Hello world!" {Color Black}))
      
      (define (drawer view surface)
        (increase! draw-count)
        (clear surface)
        (fill-rect surface (new Rect 100 70 800 400) {Color Red alpha: .8})
        (with-surface-mutex
          (lambda ()
            (draw-surface surface (get-handle image-surface) 0 0)))
        (when info?
          (set-font surface {Font Label point-size: 36})
          (draw-text surface 10 16 (format "{a} skipped" (- frame-count draw-count)) {Color Red})))
      
      ;; input
      (thread-start!
        (new-thread
          (lambda ()
            (let ((color-listener (open-stream-listener))
                  (color-pipeline (gst-pipeline "appsrc name=src"
                                                "videoconvert name=convert"
                                                (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                                (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc")
                                                "appsink name=sink")))
              (with-unref ((color-src (gst_bin_get_by_name color-pipeline "src"))
                           (color-sink (gst_bin_get_by_name color-pipeline "sink")))
                (gst_app_sink_connect_signals color-sink color-listener)
                (gst-setup-video-source color-src "video/x-raw" "BGRA" width height framerate)
                (gst_element_set_state color-pipeline GST_STATE_PLAYING)
                (let ((alpha-listener (open-stream-listener))
                      (alpha-pipeline (gst-pipeline "appsrc name=src"
                                                    (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc")
                                                    "appsink name=sink")))
                  (with-unref ((alpha-src (gst_bin_get_by_name alpha-pipeline "src"))
                               (alpha-sink (gst_bin_get_by_name alpha-pipeline "sink")))
                    (gst_app_sink_connect_signals alpha-sink alpha-listener)
                    (gst-setup-video-source alpha-src "video/x-raw" "I420" width height framerate)
                    (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)
                    (let ((color-buffer (make-u8vector (* width height 4)))
                          (color-info (make-u64vector app-sink-info-size))
                          (color-bytes #f)
                          (alpha-buffer (make-u8vector (/ (* width height 12) 8)))
                          (alpha-info (make-u64vector app-sink-info-size))
                          (alpha-bytes #f)
                          (alpha-data (heap-calloc (/ (* width height 12) 8) 1))
                          (surface (new Image-Surface video-size))
                          (start #f))
                      (let (loop)
                        (when (and (not color-bytes) (not alpha-bytes))
                          (draw surface)
                          (set! start (real-time))
                          (let ((data (cairo_image_surface_get_data (get-handle surface)))
                                (size (* width height 4))
                                (alpha-size (/ (* width height 12) 8))
                                (duration 100))
                            (separate-alpha data alpha-data (* width height))
                            (gst_app_src_write_pointer_now color-src data size 0 duration)
                            (gst_app_src_write_pointer_now alpha-src alpha-data alpha-size 0 duration)))
                        (heap-free alpha-data)
                        (when (not color-bytes)
                          (let ((size (gst_app_sink_read color-listener color-sink color-buffer color-info)))
                            (set! color-bytes size)))
                        (when (not alpha-bytes)
                          (let ((size (gst_app_sink_read alpha-listener alpha-sink alpha-buffer alpha-info)))
                            (set! alpha-bytes size)))
                        (when (and color-bytes alpha-bytes)
                          ;(terminal (- (real-time) start) color-bytes alpha-bytes)
                          (let ((dts (u64vector-ref color-info 0))
                                (pts (u64vector-ref color-info 1))
                                (duration (u64vector-ref color-info 2)))
                            (write (list (u8vector-copy color-buffer) color-bytes (u8vector-copy alpha-buffer) alpha-bytes dts pts duration) video-pipe)
                            (force-output video-pipe))
                          (set! color-bytes #f)
                          (set! alpha-bytes #f))
                        (loop))))))))
          'input))
      ;; output
      (thread-start!
        (new-thread
          (lambda ()
            (let ((view (read view-pipe)))
              (let ((color-listener (open-stream-listener))
                    (color-pipeline (gst-pipeline "appsrc name=src"
                                                  "avdec_h264 name=dec"
                                                  "videoconvert name=convert"
                                                  (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                                  "appsink name=sink")))
                (with-unref ((color-src (gst_bin_get_by_name color-pipeline "src"))
                             (color-sink (gst_bin_get_by_name color-pipeline "sink")))
                  (gst_app_sink_connect_signals color-sink color-listener)
                  (gst-setup-video-source color-src "video/x-h264" "I420" width height framerate stream-format: "avc" alignment: "au")
                  (gst_element_set_state color-pipeline GST_STATE_PLAYING)
                  (let ((alpha-listener (open-stream-listener))
                        (alpha-pipeline (gst-pipeline "appsrc name=src"
                                                      "avdec_h264 name=dec"
                                                      "appsink name=sink")))
                    (with-unref ((alpha-src (gst_bin_get_by_name alpha-pipeline "src"))
                                 (alpha-sink (gst_bin_get_by_name alpha-pipeline "sink")))
                      (gst_app_sink_connect_signals alpha-sink alpha-listener)
                      (gst-setup-video-source alpha-src "video/x-h264" "I420" width height framerate stream-format: "avc" alignment: "au")
                      (gst_element_set_state alpha-pipeline GST_STATE_PLAYING)
                      (let ((color-buffer (make-u8vector (* width height 4)))
                            (color-info (make-u64vector app-sink-info-size))
                            (color-bytes #f)
                            (alpha-buffer (make-u8vector (/ (* width height 12) 8)))
                            (alpha-info (make-u64vector app-sink-info-size))
                            (alpha-bytes #f))
                        (let (loop)
                          (when (and (not color-bytes) (not alpha-bytes))
                            (let ((info (read video-pipe)))
                              (bind (buffer bytes alpha-buffer alpha-bytes dts pts duration) info
                                (gst_app_src_write_now color-src buffer bytes 0 duration)
                                (gst_app_src_write_now alpha-src alpha-buffer alpha-bytes 0 duration))))
                          (when (not color-bytes)
                            (let ((size (gst_app_sink_read color-listener color-sink color-buffer color-info)))
                              (set! color-bytes size)))
                          (when (not alpha-bytes)
                            (let ((size (gst_app_sink_read alpha-listener alpha-sink alpha-buffer alpha-info)))
                              (set! alpha-bytes size)))
                          (when (and color-bytes alpha-bytes)
                            (increase! frame-count)
                            (with-surface-mutex
                              (lambda ()
                                (cairo_surface_flush (get-handle image-surface))
                                (combine-alpha color-buffer alpha-buffer (cairo_image_surface_get_data (get-handle image-surface)) (* width height))
                                (cairo_surface_mark_dirty (get-handle image-surface))))
                            (invalidate-view view)
                            (set! color-bytes #f)
                            (set! alpha-bytes #f))
                          (loop)))))))))
          'output))
      ;; application
      (boot-environment (new Test-Application size: video-size pipe: view-pipe drawer: drawer)))))


;;;
;;;; App
;;;


;; PLUGINS
;; - adder: Add N audio channels together
;; - audioamplify: Amplifies an audio stream by a given factor
;; - mpg123audiodec: Decodes mp3 streams using the mpg123 library
;; - openalsrc: Input audio through OpenAL
;; - openalsink: Output audio through OpenAL
;; - opusenc: Encodes audio in Opus format
;; - opusdec: decode opus streams to audio
;; - speexenc: Encodes audio in Speex format
;; - speexdec: decode speex streams to audio
;; - wavenc: Encode raw audio into WAV
;; - wavpackdec: Decodes Wavpack audio data	wavpack	gst-plugins-good
;; - wavpackenc: Encodes audio with the Wavpack lossless/lossy audio codec
;; - netsim: Network Simulator

;; QUESTIONS
;; - make opus codec work
;; - how to determine audio max size
;; - what format / layout / rate / channels to use for audio
;; - why the big delay with audio
;; - why is no codec audio not working


(definition public (test-app)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (codec video-codec)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((audio-pipe (open-vector))
          (video-pipe (open-vector))
          (video-buffer (make-u8vector (* width height 4)))
          (video-info (make-u64vector app-sink-info-size))
          (video-mutex (make-mutex 'video))
          (transferer (make-transferer video-size))
          (pipe (open-vector))
          (frame-size 0)
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (with-video-mutex
          (lambda ()
            (increase! draw-count)
            (transferer video-buffer surface)
            (when info?
              (set-font surface {Font Label point-size: 36})
              (draw-text surface 10 16 (format "{r precision: 1} kb, {a} skipped" (/ (cast <fl> frame-size) 1024.) (- frame-count draw-count)) {Color Red})))))
      
      ;; audio input
      (when audio?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((codec audio-codec))
                (let ((listener (open-stream-listener))
                      (pipeline (gst-pipeline (cond ((eq? codec 'opus)
                                                     "autoaudiosrc format=S16LE layout=interleaved rate=48000 channels=2 name=src")
                                                    ((eq? codec 'vorbis)
                                                     "autoaudiosrc format=F32LE layout=interleaved rate=48000 channels=2 name=src")
                                                    (else
                                                     "autoaudiosrc format=F32LE layout=interleaved rate=48000 channels=2 name=src"))
                                              (and (eq? codec 'opus)
                                                   "audioresample")
                                              (and (eq? codec 'opus) (tie "opusenc name=enc"))
                                              (and (eq? codec 'vorbis) (tie "vorbisenc name=enc"))
                                              "appsink name=sink")))
                  (gst_object_set_name pipeline "input")
                  (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
                    (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                      (when monitor
                        (when (neq? codec 'none)
                          (gst_monitor pipeline monitor "enc" "identity" "dec"))
                        (gst_monitor pipeline monitor "sink"))
                      (gst_app_sink_connect_signals sink listener)
                      (gst_element_set_state pipeline GST_STATE_PLAYING)
                      (let ((buffer (make-u8vector 4096))
                            (info (make-u64vector app-sink-info-size)))
                        (let (loop)
                          (let ((size (gst_app_sink_read listener sink buffer info)))
                            (let ((dts (u64vector-ref info 0))
                                  (pts (u64vector-ref info 1))
                                  (duration (u64vector-ref info 2)))
                              (write (list (u8vector-copy buffer) size dts pts duration) audio-pipe)
                              (force-output audio-pipe)))
                          (process-messages)
                          (loop))))))))
            'audio-input)))
      ;; video input
      (when video?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((listener (open-stream-listener))
                    (pipeline (gst-pipeline (cond-expand
                                              (mac "avfvideosrc name=src")
                                              (windows "ksvideosrc name=src")
                                              (else "v4l2src name=src"))
                                            "videoscale name=scale"
                                            "videoconvert name=convert"
                                            (tie "video/x-raw, format=I420, width={width}, height={height}, framerate={framerate}/1")
                                            "queue"
                                            (and (eq? codec 'h264) (tie "x264enc pass=qual quantizer=20 bitrate={bitrate} tune=zerolatency speed-preset=superfast name=enc"))
                                            (and (eq? codec 'vp8) "vp8enc deadline=1 name=enc")
                                            "appsink name=sink")))
                (gst_object_set_name pipeline "input")
                (with-unref ((sink (gst_bin_get_by_name pipeline "sink")))
                  (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                    (when monitor
                      (gst_monitor pipeline monitor "src" "sink"))
                    (gst_app_sink_connect_signals sink listener)
                    (gst_element_set_state pipeline GST_STATE_PLAYING)
                    (process-messages)
                    (let ((buffer (make-u8vector (* width height 4)))
                          (info (make-u64vector app-sink-info-size)))
                      (let (loop)
                        (let ((size (gst_app_sink_read listener sink buffer info)))
                          (let ((dts (u64vector-ref info 0))
                                (pts (u64vector-ref info 1))
                                (duration (u64vector-ref info 2)))
                            (write (list (u8vector-copy buffer) size dts pts duration) video-pipe)
                            (force-output video-pipe)))
                        (process-messages)
                        (loop)))))))
            'video-input)))
      ;; lag
      (when lag
        (sleep lag))
      ;; audio output
      (when audio?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((codec audio-codec))
                (let ((pipeline (gst-pipeline "appsrc name=src"
                                              (and (eq? codec 'opus) "opusdec name=dec")
                                              (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                              (cond-expand
                                                (windows "directsoundsink buffer-time=200000 name=sink")
                                                (mac "osxaudiosink buffer-time=200000 name=sink")
                                                (else "pulsesink buffer-time=200000 name=sink")))))
                  (gst_object_set_name pipeline "output")
                  (with-unref ((src (gst_bin_get_by_name pipeline "src")))
                    (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                      (when monitor
                        (when (neq? codec 'none)
                          (gst_monitor pipeline monitor "enc" "identity" "dec"))
                        (gst_monitor pipeline monitor "sink"))
                      (case codec
                        ((vorbis)
                         (gst-app-src-set-caps src "audio/x-vorbis"))
                        ((opus)
                         (gst-app-src-set-caps src "audio/x-opus"
                           "channel-mapping-family" 'int 0))
                        (else
                         (gst-app-src-set-caps src "audio/x-raw"
                           "format"   'string "F32LE"
                           "layout"   'string "interleaved"
                           "rate"     'int    48000
                           "channels" 'int    2)))
                      (g-object-set src
                        "is-live"     'boolean #t
                        "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                        "format"      'int     GST_FORMAT_TIME)
                      (gst_element_set_state pipeline GST_STATE_PLAYING)
                      (process-messages)
                      (let (loop)
                        (let ((info (read audio-pipe)))
                          (bind (buffer size dts pts duration) info
                            (gst_app_src_write_now src buffer size 0 duration)))
                        (process-messages)
                        (loop)))))))
            'audio-output)))
      ;; video output
      (when video?
        (thread-start!
          (new-thread
            (lambda ()
              (let ((view (read pipe)))
                (let ((listener (open-stream-listener))
                      (pipeline (gst-pipeline "appsrc name=src"
                                              (and (eq? codec 'h264) "avdec_h264 name=dec")
                                              (and (eq? codec 'vp8) "vp8dec name=dec")
                                              "videoconvert name=convert"
                                              "videoflip video-direction=horiz"
                                              (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                              "queue"
                                              (if fps?
                                                  "fpsdisplaysink video-sink=appsink name=sink"
                                                "appsink name=sink"))))
                  (gst_object_set_name pipeline "output")
                  (with-unref ((src (gst_bin_get_by_name pipeline "src"))
                               (sink (gst_bin_get_by_name pipeline "sink")))
                    (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                      (when monitor
                        (gst_monitor pipeline monitor "src" "convert" "sink")
                        (when (neq? codec 'none)
                          (gst_monitor pipeline monitor "dec")))
                      (gst_app_sink_connect_signals sink listener)
                      (case codec
                        ((h264)
                         (gst-app-src-set-caps src "video/x-h264"
                           "width"         'int      width
                           "height"        'int      height
                           "framerate"     'fraction (cons framerate 1)
                           "stream-format" 'string   "avc"
                           "alignment"     'string   "au"))
                        ((vp8)
                         (gst-app-src-set-caps src "video/x-vp8"
                           "width"         'int      width
                           "height"        'int      height
                           "framerate"     'fraction (cons framerate 1)
                           "stream-format" 'string   "avc"
                           "alignment"     'string   "au"))
                        (else
                         (gst-app-src-set-caps src "video/x-raw"
                           "format"    'string   "I420"
                           "width"     'int      width
                           "height"    'int      height
                           "framerate" 'fraction (cons framerate 1))))
                      (g-object-set src
                        "is-live"     'boolean #t
                        "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
                        "format"      'int GST_FORMAT_TIME)
                      (gst_element_set_state pipeline GST_STATE_PLAYING)
                      (process-messages)
                      (let (loop)
                        (let ((info (read video-pipe)))
                          (bind (buffer size dts pts duration) info
                            (set! frame-size size)
                            (gst_app_src_write_now src buffer size 0 duration)))
                        (let ((size (with-video-mutex
                                      (lambda ()
                                        (gst_app_sink_read listener sink video-buffer video-info)))))
                          (increase! frame-count)
                          (invalidate-view view))
                        (process-messages)
                        (loop)))))))
            'video-output)))
      ;; application
      (boot-environment (new Test-Application size: video-size pipe: pipe drawer: (and video? drawer))))))


;;;
;;;; OGG
;;;


(definition public (test-ogg)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (let ((pipeline (gst_pipeline_new "audio-player"))
              (filename (or media "~/Media/test.ogg")))
          (let ((source   (gst_element_factory_make "filesrc"       "file-source"))
                (demuxer  (gst_element_factory_make "oggdemux"      "ogg-demuxer"))
                (decoder  (gst_element_factory_make "vorbisdec"     "vorbis-decoder"))
                (conv     (gst_element_factory_make "audioconvert"  "converter"))
                (resamp   (gst_element_factory_make "audioresample" "resampler"))
                (volume   (gst_element_factory_make "volume"        "volume"))
                (panorama (gst_element_factory_make "audiopanorama" "audiopanorama"))
                (winconv  (cond-expand
                            (windows (gst_element_factory_make "audioconvert" "winconv"))
                            (else)))
                (sink     (gst_element_factory_make "autoaudiosink" "audio-output")))
            (g_object_set_string source "location" (path-normalize filename))
            (let ((bus (gst_pipeline_get_bus pipeline)))
              (gst_bin_add pipeline source)
              (gst_bin_add pipeline demuxer)
              (gst_bin_add pipeline decoder)
              (gst_bin_add pipeline conv)
              (gst_bin_add pipeline resamp)
              (gst_bin_add pipeline volume)
              (gst_bin_add pipeline panorama)
              (cond-expand
                (windows (gst_bin_add pipeline winconv))
                (else))
              (gst_bin_add pipeline sink)
              (gst_element_link source demuxer)
              (gst_element_link demuxer decoder)
              (gst_element_link decoder conv)
              (gst_element_link conv resamp)
              (gst_element_link resamp volume)
              (gst_element_link volume panorama)
              (cond-expand
                (windows
                 (gst_element_link panorama winconv)
                 (gst_element_link winconv sink))
                (else
                 (gst_element_link panorama sink)))
              (g_object_set_double volume "volume" .1)
              (g_object_set_double panorama "panorama" -1.)
              (gst_signal_connect_to demuxer "pad-added" decoder)
              (gst_element_set_state pipeline GST_STATE_PLAYING)
              ;; augment volume
              (let ((vol .1))
                (thread-start!
                  (new-thread
                    (lambda ()
                      (let (loop)
                        (set! vol (min (* vol 1.025) 1.))
                        (g_object_set_double volume "volume" vol)
                        (sleep .1)
                        (loop))))))
              ;; pan left to right
              (let ((pan -1.))
                (thread-start!
                  (new-thread
                    (lambda ()
                      (let (loop)
                        (set! pan (min (+ pan .01) 1.))
                        (g_object_set_double panorama "panorama" pan)
                        (sleep .1)
                        (loop))))))))))
      'ogg))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; WAV
;;;


(define (play-explosion)
  (let ((pipeline (gst_pipeline_new "audio-player"))
        (filename (or media "~/Media/test.wav")))
    (let ((source  (gst_element_factory_make "filesrc"       "file-source"))
          (decoder (gst_element_factory_make "wavparse"      "wavparse"))
          (conv    (gst_element_factory_make "audioconvert"  "converter"))
          (resamp  (gst_element_factory_make "audioresample" "resampler"))
          (sink    (gst_element_factory_make "autoaudiosink" "audio-output")))
      (g_object_set_string source "location" (path-normalize filename))
      (let ((bus (gst_pipeline_get_bus pipeline)))
        (gst_bin_add pipeline source)
        (gst_bin_add pipeline decoder)
        (gst_bin_add pipeline conv)
        (gst_bin_add pipeline resamp)
        (gst_bin_add pipeline sink)
        (gst_element_link source decoder)
        (gst_element_link decoder conv)
        (gst_element_link conv resamp)
        (gst_element_link resamp sink)
        (gst_element_set_state pipeline GST_STATE_PLAYING)))))


(definition public (test-wav)
  ;; audio
  (thread-start!
    (new-thread
      (lambda ()
        (loop (repeat 20)
              (play-explosion)
              (sleep .1)))
      'wav))
  ;; application
  (boot-environment (new Test-Application)))


;;;
;;;; JPEG
;;;


(definition public (test-jpeg)
  (initialize-aliases)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (window-width (get-width window-size))
        (window-height (get-height window-size))
        (file (new File (tokenise-filename (or media "~/Media/test.jpg")))))
    (let ((image-surface (create-cairo-surface-from-jpeg file)))
      (define (drawer view surface)
        (blit-surface surface image-surface))
      
      ;; application
      (boot-environment (new Test-Application size: window-size drawer: drawer)))))


;;;
;;;; Media
;;;


(definition public (test-media)
  (let ((width (get-width video-size))
        (height (get-height video-size))
        (codec 'none)
        (framerate video-framerate)
        (bitrate video-bitrate))
    (let ((audio-pipe (open-vector))
          (video-pipe (open-vector))
          (video-buffer (make-u8vector (* width height 4)))
          (video-info (make-u64vector app-sink-info-size))
          (video-mutex (make-mutex 'video))
          (transferer (make-transferer video-size))
          (pipe (open-vector))
          (frame-size 0)
          (frame-count 0)
          (draw-count 0))
      (define (with-video-mutex thunk)
        (mutex-lock! video-mutex)
        (prog1 (thunk)
          (mutex-unlock! video-mutex)))
      
      (define (drawer view surface)
        (with-video-mutex
          (lambda ()
            (increase! draw-count)
            (transferer video-buffer surface)
            (when info?
              (set-font surface {Font Label point-size: 36})
              (draw-text surface 10 16 (format "{r precision: 1} kb, {a} skipped" (/ (cast <fl> frame-size) 1024.) (- frame-count draw-count)) {Color Red})))))
      
      ;; input
      (let ((listener (open-stream-listener))
            (audio-listener (open-stream-listener))
            (pipeline (gst-pipeline (tie "filesrc name=filesrc")
                                    "decodebin name=decoder"
                                    (list "decoder."
                                          "queue"
                                          "audioconvert"
                                          "audioresample"
                                          "audio/x-raw, format=S16LE, layout=interleaved, rate=48000, channels=2"
                                          "appsink name=audioappsink")
                                    (list "decoder."
                                          "videoscale"
                                          "videoconvert"
                                          (tie "video/x-raw, format=I420, width={width}, height={height}, pixel-aspect-ratio=(fraction)1/1")
                                          "appsink name=videoappsink")))
            (filename (or media "~/Media/sintel.webm")))
        (with-unref ((source (gst_bin_get_by_name pipeline "filesrc"))
                     (video-appsink (gst_bin_get_by_name pipeline "videoappsink"))
                     (audio-appsink (gst_bin_get_by_name pipeline "audioappsink")))
          (let ((video-data (make-u8vector (* width height 4)))
                (video-info (make-u64vector app-sink-info-size))
                (audio-buffer (make-u8vector 65536))
                (audio-info (make-u64vector app-sink-info-size))
                (process-messages (pipeline-messages-processor pipeline print?: debug?)))
            (gst_app_sink_connect_signals video-appsink listener)
            (gst_app_sink_connect_signals audio-appsink audio-listener)
            (g_object_set_string source "location" (path-normalize filename))
            (gst_element_set_state pipeline GST_STATE_PLAYING)
            (let (;; audio input
                  (audio-input-thread
                    (new-thread
                      (lambda ()
                        (let (loop)
                          (let ((size (gst_app_sink_read audio-listener audio-appsink audio-buffer audio-info)))
                            (let ((dts (u64vector-ref audio-info 0))
                                  (pts (u64vector-ref audio-info 1))
                                  (duration (u64vector-ref audio-info 2)))
                              (write (list (u8vector-copy audio-buffer) size dts pts duration) audio-pipe)
                              (force-output audio-pipe)))
                          (process-messages)
                          (loop)))
                      'audio-input))
                  ;; video input
                  (video-input-thread
                    (new-thread
                      (lambda ()
                        (let (loop)
                          (let ((size (gst_app_sink_read listener video-appsink video-buffer video-info)))
                            (let ((dts (u64vector-ref video-info 0))
                                  (pts (u64vector-ref video-info 1))
                                  (duration (u64vector-ref video-info 2)))
                              (write (list (u8vector-copy video-buffer) size dts pts duration) video-pipe)
                              (force-output video-pipe)))
                          (loop)))
                      'video-input))
                  ;; audio output
                  (audio-output-thread
                    (new-thread
                      (lambda ()
                        (let ((codec 'none))
                          (let ((pipeline (gst-pipeline "appsrc name=src"
                                                        "queue"
                                                        (and (eq? codec 'opus) "opusdec name=dec")
                                                        (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                                        (cond-expand
                                                          (windows "directsoundsink buffer-time=200000 name=sink")
                                                          (mac "osxaudiosink buffer-time=200000 name=sink")
                                                          (else "pulsesink buffer-time=200000 name=sink")))))
                            (gst_object_set_name pipeline "output")
                            (with-unref ((src (gst_bin_get_by_name pipeline "src")))
                              (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                                (when monitor
                                  (when (neq? codec 'none)
                                    (gst_monitor pipeline monitor "enc" "identity" "dec"))
                                  (gst_monitor pipeline monitor "sink"))
                                (case codec
                                  ((vorbis)
                                   (gst-app-src-set-caps src "audio/x-vorbis"))
                                  (else
                                   (gst-app-src-set-caps src "audio/x-raw"
                                     "format"   'string "S16LE"
                                     "layout"   'string "interleaved"
                                     "rate"     'int    48000
                                     "channels" 'int    2)))
                                (g-object-set src
                                              "is-live"     'boolean #t
                                              "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                                              "format"      'int     GST_FORMAT_TIME)
                                (gst_element_set_state pipeline GST_STATE_PLAYING)
                                (process-messages)
                                (let (loop)
                                  (let ((info (read audio-pipe)))
                                    (bind (buffer size dts pts duration) info
                                      (gst_app_src_write_now src buffer size 0 duration)))
                                  (process-messages)
                                  (loop)))))))
                      'audio-output))
                  ;; video output
                  (video-output-thread
                    (new-thread
                      (lambda ()
                        (let ((view (read pipe)))
                          (let ((listener (open-stream-listener))
                                (pipeline (gst-pipeline "appsrc name=src"
                                                        (and (eq? codec 'h264) "avdec_h264 name=dec")
                                                        (and (eq? codec 'vp8) "vp8dec name=dec")
                                                        "videoconvert name=convert"
                                                        (tie "video/x-raw, format=BGRA, width={width}, height={height}, framerate={framerate}/1")
                                                        "queue"
                                                        (if fps?
                                                            "fpsdisplaysink video-sink=appsink name=sink"
                                                          "appsink name=sink"))))
                            (gst_object_set_name pipeline "output")
                            (with-unref ((src (gst_bin_get_by_name pipeline "src"))
                                         (sink (gst_bin_get_by_name pipeline "sink")))
                              (let ((process-messages (pipeline-messages-processor pipeline print?: debug?)))
                                (when monitor
                                  (gst_monitor pipeline monitor "src" "convert" "sink")
                                  (when (neq? codec 'none)
                                    (gst_monitor pipeline monitor "dec")))
                                (gst_app_sink_connect_signals sink listener)
                                (case codec
                                  ((h264)
                                   (gst-app-src-set-caps src "video/x-h264"
                                     "width"         'int      width
                                     "height"        'int      height
                                     "framerate"     'fraction (cons framerate 1)
                                     "stream-format" 'string   "avc"
                                     "alignment"     'string   "au"))
                                  ((vp8)
                                   (gst-app-src-set-caps src "video/x-vp8"
                                     "width"         'int      width
                                     "height"        'int      height
                                     "framerate"     'fraction (cons framerate 1)
                                     "stream-format" 'string   "avc"
                                     "alignment"     'string   "au"))
                                  (else
                                   (gst-app-src-set-caps src "video/x-raw"
                                     "format"    'string   "I420"
                                     "width"     'int      width
                                     "height"    'int      height
                                     "framerate" 'fraction (cons framerate 1))))
                                (g-object-set src
                                              "is-live"     'boolean #t
                                              "stream-type" 'int     GST_APP_STREAM_TYPE_STREAM
                                              "format"      'int     GST_FORMAT_TIME)
                                (gst_element_set_state pipeline GST_STATE_PLAYING)
                                (process-messages)
                                (let (loop)
                                  (let ((info (read video-pipe)))
                                    (bind (buffer size dts pts duration) info
                                      (set! frame-size size)
                                      (gst_app_src_write_now src buffer size 0 duration)))
                                  (let ((size (with-video-mutex
                                                (lambda ()
                                                  (gst_app_sink_read listener sink video-buffer video-info)))))
                                    (increase! frame-count)
                                    (invalidate-view view))
                                  (process-messages)
                                  (loop)))))))
                      'video-output)))
              (thread-base-priority-set! audio-input-thread 100)
              (thread-base-priority-set! video-input-thread 100)
              (thread-base-priority-set! audio-output-thread 100)
              (thread-base-priority-set! video-output-thread 100)
              (thread-start! audio-input-thread)
              (thread-start! video-input-thread)
              (thread-start! audio-output-thread)
              (thread-start! video-output-thread)))))
      ;; application
      (boot-environment (new Test-Application size: video-size pipe: pipe drawer: drawer)))))


;;;
;;;; Leak
;;;


(definition public (test-leak)
  (let ((pipeline (gst-pipeline "appsrc name=src ! avdec_h264 name=dec ! appsink name=sink"))
        (width 640)
        (height 360)
        (framerate 10))
    (with-unref ((appsrc (gst_bin_get_by_name pipeline "src"))
                 (appsink (gst_bin_get_by_name pipeline "sink"))
                 (dec (gst_bin_get_by_name pipeline "dec")))
      (let ((data (make-u8vector (* width height 4)))
            (info (make-u64vector app-sink-info-size)))
        (gst-app-src-set-caps appsrc "video/x-h264"
          "width"         'int      width
          "height"        'int      height
          "framerate"     'fraction (cons framerate 1)
          "stream-format" 'string   "avc"
          "alignment"     'string   "au")
        (g-object-set appsrc
          "is-live"     'boolean #t
          "stream-type" 'int GST_APP_STREAM_TYPE_STREAM
          "format"      'int GST_FORMAT_TIME)
        (gst_element_set_state pipeline GST_STATE_PLAYING)
        (gst_element_set_state pipeline GST_STATE_NULL)
        (gst_object_unref pipeline))))
  (gst_deinit))


;;;
;;;; Gambit
;;;


(definition public (test-gambit)
  (let ((start (current-monotonic))
        (received 0)
        (received-mutex (make-mutex 'received))
        (last-report (current-monotonic))
        (spawn (or spawn 1))
        (period (or period .001)))
    (define (received-buffer)
      (mutex-lock! received-mutex)
      (increase! received)
      (let ((now (current-monotonic)))
        (when (> now (+ last-report 1))
          (terminal (/ (- now start) (/ received spawn)))
          (set! last-report now)))
      (mutex-unlock! received-mutex))
    
    (define (start-pipeline)
      (let ((pipe (open-vector)))
        ;; input
        (thread-start!
          (new-thread
            (lambda ()
              (declare (proper-tail-calls))
              (let ((buffer (object->u8vector (naturals 1 100))))
                (let (loop)
                  (write buffer pipe)
                  (sleep period)
                  (loop))))
            'input))
        ;; output
        (thread-start!
          (new-thread
            (lambda ()
              (declare (proper-tail-calls))
              (let (loop)
                (let ((buffer (read pipe)))
                  (received-buffer))
                (loop)))
            'output))))
    
    ;; pipelines
    (loop (repeat spawn)
          (start-pipeline))
    ;; application
    (boot-environment (new Test-Application))))


;;;
;;;; Application
;;;


(class Test-Application extends Application
  
  
  (slot size   getter generate)
  (slot pipe   getter generate)
  (slot drawer getter generate)
  (slot mouser getter generate)
  (slot keyer  getter generate)
  
  
  (method override (initialize self (size: size #f) (pipe: pipe #f) (drawer: drawer #f) (mouser: mouser #f) (keyer: keyer #f))
    (set! self.size (or size {Dimension 640 360}))
    (set! self.pipe pipe)
    (set! self.drawer drawer)
    (set! self.mouser mouser)
    (set! self.keyer keyer))
  
  
  (method override (new-toplevel self)
    (new Toplevel caption-base: "Test" position: {Point 50 50} size: size))
  
  
  (method override (finish-process self)
    (nextmethod self)
    (let ((view (get-guest (new-frame Test-View host-title: (->string script) drawer: drawer mouser: mouser keyer: keyer))))
      (when pipe
        (write view pipe)))))


;;;
;;;; View
;;;


(class Test-View extends View
  
  
  (property drawer initialize #f accessors generate)
  (property mouser initialize #f accessors generate)
  (property keyer  initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (when drawer
      (drawer self surface)))
  
  
  (method override (mouse-down self evt)
    (when mouser
      (mouser self (get-position evt))))
  
  
  (method override (key-press self evt)
    (when keyer
      (keyer self (get-key evt)))))


;;;
;;;; Transfer
;;;


(definition (make-transferer size)
  (cond-expand
    (windows
     (let ((transfer-surface (new Image-Surface size)))
       (lambda (video-buffer surface)
         (move-u8vector->pointer! video-buffer (cairo_image_surface_get_data (get-handle transfer-surface)))
         (cairo_surface_mark_dirty (get-handle transfer-surface))
         (blit-surface surface transfer-surface))))
    (else
     (lambda (video-buffer surface)
       (move-u8vector->pointer! video-buffer (cairo_image_surface_get_data (get-handle surface))))))))
