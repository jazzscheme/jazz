;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Applications
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.system.application.Application jazz


(import (jazz.console)
        (jazz.debuggee)
        (jazz.designer)
        (jazz.editor.lisp)
        (jazz.editor.sql)
        (jazz.editor.sql.view)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.listener)
        (jazz.library.template)
        (jazz.locale)
        (jazz.platform)
        (jazz.profile)
        (jazz.runtime)
        (jazz.system)
        (jazz.system.application)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.look)
        (jazz.ui.picker)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.ui.workspace)
        (time))


(class Application extends Process implements (Context-Provider History-Provider Event-Consumer Save-Environment-Listener)


  (slot toplevel                 initialize {})
  (slot profile-name             initialize {})
  (slot profile-unit             initialize {})
  (slot profile-class            initialize {})
  (slot profile-bindings         initialize {})
  (slot profile                  initialize {}                        getter generate)
  (slot focus-listeners          initialize '())
  (slot application-listeners    initialize (make-table test: eq?))
  (slot selected-owner           initialize {}                        getter generate)
  (slot selected                 initialize {})
  (slot selected-listeners       initialize '())
  (slot event-consumer           initialize self)
  (slot history-manager          initialize (new History-Manager self))
  (slot active?                  initialize #f                        getter generate)
  (slot application-actions      initialize '()                       getter generate)
  (slot profile-actions          initialize '()                       getter generate)
  (slot guest-actions            initialize '()                       getter generate)
  (slot focus-actions            initialize '()                       getter generate)
  (slot bindings-designer        initialize {}                        getter generate)
  (slot shortcut-table           initialize {})
  (slot shortcut-hook            initialize {}                        accessors generate)
  
  
  (method meta override (external-name . rest)
    'application)

  
  ;;;
  ;;;; Access
  ;;;


  (method override (get-toplevel)
    toplevel)


  ;;;
  ;;;; Startup
  ;;;
  
  
  (method override (prepare-bindings)
    (nextmethod)
    ;; this is critical as any problem in the boot process
    ;; might display a message-box that needs basic bindings
    (set-bindings (new Application-Bindings)))


  (method override (prepare-environment)
    (nextmethod)
    (set-application self)
    (setup-shortcuts)
    (let ((flat-look (new Flat-Look))
          (windows-look (new Windows-Look)))
      (set-looks (list flat-look windows-look))
      (set-look flat-look))
    (initialize-platform get-setting)
    (when (use-profile?)
      (log-profile)))

  
  (method override (start-environment)
    (nextmethod)
    (setup-bindings)
    (setup-fonts)
    (initialize-toplevel)
    (initialize-clipboard)
    (register-clipboard-formats))


  (method override (finalize-environment)
    (nextmethod)
    (set-cursor :arrow)
    (splash-screen))

  
  (method override (setup-profile)
    (define (create-profile)
      (with-safe-execution "creating the profile"
        (lambda ()
          (set! profile (new (load-profile-class profile-class))))
        continue-text: (list (format "to bypass this problem by using a generic profile class"))
        continue-handler:
        (lambda (err)
          (set! profile (new Me)))))
    
    (when (use-profile?)
      (create-profile)
      (set-profile-actions (get-class-actions profile))))
  
  
  (method override (finish-environment)
    (nextmethod)
    (register-locale-change locale-change)
    (add-save-environment-listener self)
    (when profile
      (with-safe-execution "initing the profile"
        (lambda ()
          (init~ profile))
        continue-handler:
        (lambda (err)
          )))
    (reload-session)
    (remove-splash-screen))
  
  
  (method override (finish-process)
    (nextmethod)
    (select-default-workspace)
    (update-focus-actions)
    (update-windowing-actions))
  
  
  (method override (conclude-environment)
    (nextmethod)
    (initialize-actions)
    (show-toplevel)
    (when (run-loop?)
      (select-foreground-window (get-handle~ toplevel)))
    (when profile
      (with-safe-execution "finalizing the profile"
        (lambda ()
          (finalize~ profile))
        continue-handler:
        (lambda (err)
          ))))
  
  
  ;;;
  ;;;; Termination
  ;;;
  
  
  (method override (terminate-process)
    (nextmethod)
    (reset-palettes)
    (reset-dockeds)
    (reset-toolbars)
    (when toplevel
      (close~ toplevel)
      (set! toplevel {})
      (set! profile-name {})
      (set! profile-unit {})
      (set! profile-class {})
      (set! profile-bindings {})
      (set! profile {})))


  ;;;
  ;;;; Java
  ;;;
  
  
  @test-java
  (definition Java-Classpath
    '({File "C:" "Java" "j2sdk1.4.2_04" "jre" "lib" "rt.jar"}
      {File "C:" "Java" "BCEL" "lib" "bcel-5.1.jar"}
      {File "C:" "Java" "JDBC" "msbase.jar"}
      {File "C:" "Java" "JDBC" "msutil.jar"}
      {File "C:" "Java" "JDBC" "mssqlserver.jar"}))
  
  
  @test-java
  (method (test-java)
    (setup-jvm classpath: Java-Classpath)
    (c-test)
    (let* ((loader (getSystemClassLoader~ java.lang.ClassLoader))
           (class (forName~ java.lang.Class "yo" #t loader)))
      (message-box (format "{a}" class))))


  ;;;
  ;;;; Loop
  ;;;


  (method override (start-loop)
    (setup-events)
    (process-events))
  
  
  (method override (resume-loop-action)
    (when toplevel
      (select-foreground-window (get-handle~ toplevel))))


  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (clipboard-prefix)
    (format "{a}_{a}_"
            (process-name)
            (present~ (process-version))))
  
  
  (method protected virtual (register-clipboard-formats)
    (register-jazz-clipboard-formats (clipboard-prefix)))


  ;;;
  ;;;; Clipboard Stack
  ;;;

  
  (definition Clipboard-Stack
    '())
  
  (definition Max-Stack
    256)
  
  
  (method public (get-clipboard-stack)
    Clipboard-Stack)
  
  
  (method public (empty-clipboard-stack?)
    (null? Clipboard-Stack))
  
  
  (method public (add-clipboard)
    (let ((text (get-clipboard-text)))
      (when text
        (set! Clipboard-Stack (cons text Clipboard-Stack))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (method public (push-clipboard-list list)
    (let ((pushed (length list)))
      (if (> pushed Max-Stack)
          (error "Unable to push list of {a} onto the clipboard stack" pushed)
        (set! Clipboard-Stack (append list Clipboard-Stack))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (definition (trim-clipboard)
    (when (> (length Clipboard-Stack) Max-Stack)
      (set-cdr! (tail Clipboard-Stack (- Max-Stack 1)) '())))
  
  
  (method (pop-clipboard)
    (let ((string (car Clipboard-Stack)))
      (set! Clipboard-Stack (cdr Clipboard-Stack))
      (set-clipboard-text string)
      (update-focus-actions)
      string))
  
  
  (method public (cycle-clipboard)
    (let ((string (get-clipboard-text)))
      (let ((res (pop-clipboard)))
        (if (null? Clipboard-Stack)
            (set! Clipboard-Stack (list string))
          (set-cdr! (last-pair Clipboard-Stack) (list string)))
        res)))
  
  
  (method public (cycle-clipboard-reversed)
    (let ((string (get-clipboard-text)))
      (let ((res (last Clipboard-Stack)))
        (set! Clipboard-Stack (cons string (butlast Clipboard-Stack)))
        (set-clipboard-text res)
        res)))

  
  (method package (paste-cycle-stack reversed?)
    (let ((focus (get-focus)))
      (if (or (is-not? focus Text-View) (null? Clipboard-Stack))
          (bell)
        (let ((text (get-clipboard-text))
              (expl (new (explorer-class~ focus) focus)))
          (set-pos~ expl (get-start~ focus))
          (when (looking-back?~ expl text)
            (backward-n~ expl (string-length text))
            (delete-range~ focus (get-range~ expl)))
          (insert-string~ focus (if reversed? (cycle-clipboard-reversed) (cycle-clipboard)))))))
  
  
  (method package (on-paste-cycle-stack evt)
    (paste-cycle-stack #f))


  (method package (on-paste-cycle-stack-reversed evt)
    (paste-cycle-stack #t))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method package (on-add-history evt)
    (add-current~ history-manager))
  
  
  (method package (on-backward-history evt)
    (go-backward-history~ history-manager))
  
  
  (method package (on-forward-history evt)
    (go-forward-history~ history-manager))
  
  
  (method public (add-history item)
    (add-history~ history-manager item))
  
  
  (method override (current-history-item)
    (let ((frame (current-frame)))
      (when frame
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (current-history-item~ guest))))))
  
  
  (method override (update-history-actions)
    (let ((backward (get-backward-history~ history-manager))
          (forward (get-forward-history~ history-manager)))
      (set-action-enabled? {Action application backward-history} (not-null? backward))
      (set-action-enabled? {Action application forward-history} (not-null? forward))))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method public virtual (get-recorder)
    {})
  
  
  (method package (macro-recording?)
    (let ((recorder (get-recorder)))
      (and recorder (get-recording?~ recorder))))
  
  
  (method package (macro-playing?)
    (let ((recorder (get-recorder)))
      (and recorder (get-playing?~ recorder))))


  ;;;
  ;;;; Profile
  ;;;
  
  
  (method protected virtual (use-profile?)
    #f)
  
  
  (method protected virtual (use-profile-logging?)
    #f)
  
  
  (method (log-profile)
    (define (install-profile)
      (let ((source (find-unit-source profile-class)))
        (when (not source)
          (install-new-profile)
          (set! source (find-unit-source profile-class)))
        (register-alias 'Profile (get-list~ (get-parent~ source)))))
    
    (define (install-new-profile)
      (let ((associations (list (cons 'profile profile-name)
                                (cons 'profile-lowercase (downcase (symbol->string profile-name)))
                                (cons 'profile-unit profile-unit)
                                (cons 'profile-bindings (either profile-bindings 'jazz)))))
        (copy-template {Directory Jazz "lib" "jedi" "templates" "profile"}
                       {Directory Home}
                       associations
                       non-expanded-nodes: '("catalogs")))
      (let ((repository (find-repository 'User)))
        (let ((package-name profile-unit)
              (package-path (concatenate (repository-library-directory repository) (format "{a}/.package" profile-unit))))
          (repository-add-package repository (load-package repository #f package-name package-path)))))
    
    (define (login-profile)
      (receive (name unit bindings always-use?) ((require-service 'choose-login))
        (set! profile-bindings bindings)
        (when settings
          (set-setting~ settings 'profile (if always-use? name #f))
          (save-content~ settings)
          (when always-use?
            (message-box (format "Jedi will now always start using profile {a}. To select another profile, keep the shift key pressed when starting Jedi or delete the 'profile' entry from your HOME/.jedi/.settings file."
                                 name))))
        (values name unit)))
    
    (define (standard-profile title)
      (let ((name (string->symbol title))
            (unit-name (string->symbol (format "profile.{a}" (downcase title)))))
        (values name unit-name)))
    
    (define (system-profile)
      (values 'Me 'jazz.profile)
      @convert
      (standard-profile (get-system-user-name)))
    
    (define (load-profile-jazzini)
      (let ((file {File Profile ".jazzini"}))
        (when (exists?~ file)
          (load (parse~ file)))))
    
    (define (profile-argument/setting)
      (let ((profile (argument/setting "profile" 'profile)))
        (when profile
          (capitalize (->string profile)))))
    
    (let ((use-logging? (use-profile-logging?)))
      (let ((profile-arg (and (or (not use-logging?) (not (shift-down?))) (or (jazz-profile) (profile-argument/setting)))))
        (receive (name unit) (cond (profile-arg (standard-profile (->string profile-arg)))
                                   (use-logging? (login-profile))
                                   (else (system-profile)))
          (set! profile-name name)
          (set! profile-unit unit)
          (set! profile-class (compose-name unit name))
          (install-profile)
          (load-profile-jazzini)))))


  ;;;
  ;;;; Closing
  ;;;
  
  
  (method override (preserve-environment)
    (nextmethod)
    (call-save-environment-listeners))
  
  
  (method override (close-environment)
    ;; called before closing frames because saving a class form
    ;; can potentialy modify an opened text
    (call-exit-listeners)
    (confirm-all-close)
    (close-all)
    (save-bindings)
    @wait
    (save-page-setup)
    (nextmethod))
      
  
  (method public (confirm-all-close)
    (define (frame-dependent-document? frame)
      (and (is? frame Host-View)
           (let ((guest (get-guest~ frame)))
             (and (is? guest Document)
                  (let ((controller (get-controller~ guest)))
                    (dependent-document?~ controller))))))
    
    (for-each (lambda (frame)
                (unless (frame-dependent-document? frame)
                  (confirm-close~ frame)))
              (all-frames include-invisibles?: #t)))
  
  
  (method (close-all)
    (for-each close~ (all-frames include-invisibles?: #t)))


  ;;;
  ;;;; Splash
  ;;;
  
  
  (definition Splash-Screen
    {})
  
  (definition Splash-End
    {})
  
  
  (method protected virtual (splash-screen)
    )
  
  
  (method (show-splash-screen (duration: duration {}))
    (set! Splash-Screen (show-splash))
    (set! Splash-End (essay duration (+ (time->seconds (current-time)) duration))))
  
  
  (method (remove-splash-screen)
    (when Splash-Screen
      (let ((time (time->seconds (current-time))))
        (when (and Splash-End (> Splash-End time))
          (sleep (- Splash-End time)))
        (remove-splash Splash-Screen))))
  
  
  (method protected virtual (show-splash)
    )
  
  
  (method protected virtual (remove-splash splash-screen)
    )


  ;;;
  ;;;; Help
  ;;;
  
  
  (method package (on-about evt)
    (show-about))
  
  
  (method public virtual (show-about)
    (let ((name (process-name))
          (owner (process-owner))
          (copyright (process-copyright))
          (licensee (process-licensee))
          (version (present~ (process-version)))
          (email (process-email)))
      (message-box
        (append!
         (list
          (list (list font: {Font name: Text} color: {Color name: Dark-Blue} (format "{a} v{a}" name version)))
          (list))
         (when owner
           (list
            (list (list font: {Font name: Text} (format "Copyright {a}{a}" (if copyright (format "{a} " copyright) "") owner)))
            (list)))
         (when licensee
           (list
            (list "This product is licensed to " (list licensee))
            (list)))
         (when email
           (list
            (list "Send comments, suggestions, bugs,... to:")
            (list email))))
        title: (format "About {a}" name))))


  ;;;
  ;;;; Exit
  ;;;
  

  (slot exit-listeners initialize '())
  
  
  (method public (add-exit-listener listener)
    (set! exit-listeners (cons listener exit-listeners)))
  
  
  (method public (remove-exit-listener listener)
    (set! exit-listeners (remove! listener exit-listeners)))
  
  
  (method public (call-exit-listeners)
    (for-each prepare-exit~ exit-listeners))


  ;;;
  ;;;; Activation
  ;;;
  
  
  (method public virtual (deactivate)
    (when active?
      (close-popups~ toplevel)
      (set-mouse-in {})
      (set! active? #f)))
  
  
  (method public virtual (activate)
    (unless active?
      (set! active? #t)
      ;; Necessary because verify-reloads can pop a dialog
      (if (mouse-clicked?)
          (set-delayed-mouse-action
            (lambda ()
              (verify-reloads)))
        (verify-reloads))))
  
  
  (method public (verify-reloads)
    (for-each (lambda (view)
                (when (is? view Frame-Host)
                  (let ((guest (get-guest~ view)))
                    (when (is? guest Document)
                      (verify-reload~ (get-controller~ guest))))))
              (all-frames include-invisibles?: #t)))
  
  
  (method public (verify-reload moniker)
    (let ((frame (find-document moniker)))
      (when frame
        (let ((document (get-guest~ frame)))
          (verify-reload~ (get-controller~ document))))))


  ;;;
  ;;;; Environment
  ;;;
  

  (slot save-environment-listeners initialize '())
  
  
  (method public (add-save-environment-listener listener)
    (set! save-environment-listeners (cons listener save-environment-listeners)))
  
  
  (method public (remove-save-environment-listener listener)
    (set! save-environment-listeners (remove! listener save-environment-listeners)))
  
  
  (method public (call-save-environment-listeners)
    (for-each (lambda (listener)
                (save-environment~ listener))
              save-environment-listeners))
  
  
  ;;;
  ;;;; Session
  ;;;
  
  
  (method public (reload-session)
    (reload-opened-windows))
  
  
  (method public virtual (reload-opened-windows)
    )
  
  
  (method public virtual (reload-component class properties)
    )

  
  (method override (save-environment)
    (define (save-application)
      (when preferences-root
        @convert/wait
        (set-property~ preferences-designer preferences-root active-context: context branch: {})
        (set-property~ preferences-designer preferences-root current-directory: (get-current-directory) branch: {})))
    
    (define (save-all-guest)
      @wait
      (for-each (lambda (frame)
                  (when (is? frame Host-Frame)
                    (let ((guest (get-guest~ frame)))
                      (when guest
                        (save-guest~ guest session-designer session)))))
                (all-frames include-invisibles?: #t)))
    
    (save-application)
    (save-all-guest))

  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method public virtual (display-aliases?)
    #t)
  
  
  (method public virtual (display-protocol?)
    #t)
  
  
  (method public virtual (application-anchors)
    (table-keys (get-aliases)))


  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method (setup-fonts)
    (define (preferences->font pref)
      (let ((name (get-name~ pref))
            (font-name (get-font-name~ pref))
            (point-size (get-point-size~ pref))
            (color (get-color~ pref))
            (bold? (get-bold?~ pref))
            (italic? (get-italic?~ pref))
            (underline? (get-underline?~ pref))
            (antialias (get-antialias~ pref))
            (hint-style (get-hint-style~ pref)))
        (let ((arguments
                `(,@(if (specified? font-name) (list font-name: font-name) '())
                  ,@(if (specified? point-size) (list point-size: point-size) '())
                  ,@(if (specified? color) (list color: color) '())
                  ,@(if (specified? bold?) (list bold?: bold?) '())
                  ,@(if (specified? italic?) (list italic?: italic?) '())
                  ,@(if (specified? underline?) (list underline?: underline?) '())
                  ,@(if (specified? antialias) (list antialias: antialias) '())
                  ,@(if (specified? hint-style) (list hint-style: hint-style) '()))))
          (unless (null? arguments)
            (apply new Font name: name arguments)))))
    
    (let ((pref (get-preferences 'fonts error?: #f)))
      (when pref
        (let ((fonts (get-children~ pref)))
          (for-each (lambda (pref)
                      (let ((font (preferences->font pref)))
                        (when font
                          (let ((name (get-name~ font)))
                            (register-font name font)))))
                    fonts)))))

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (add-focus-listener listener)
    (set! focus-listeners (add-listener listener focus-listeners)))
  
  
  (method public (remove-focus-listener listener)
    (set! focus-listeners (remove-listener listener focus-listeners)))

  
  (method package (process-focus-change new-focus)
    (when focus-listeners
      (let ((evt (new Focus-Event :focus-change self new-focus)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  focus-listeners)))
    (update-focus-actions))
  
  
  (method public virtual (update-focus-actions)
    (let* ((focus (get-focus))
           (view? (and focus (is? focus View))))
      (when preferences-root
        (set-action-enabled? {Action view undo} (and view? (can-undo?~ focus)))
        (set-action-enabled? {Action view redo} (and view? (can-redo?~ focus)))
        (set-action-enabled? {Action view cut} (and view? (can-cut?~ focus)))
        (set-action-enabled? {Action view copy} (and view? (can-copy?~ focus)))
        (set-action-enabled? {Action view paste} (and view? (can-paste?~ focus)))
        (set-action-enabled? {Action application paste-cycle-stack} (and view? (can-paste?~ focus) (not-null? Clipboard-Stack)))
        (set-action-enabled? {Action application paste-cycle-stack-reversed} (and view? (can-paste?~ focus) (not-null? Clipboard-Stack)))
        (set-action-enabled? {Action view paste-properties} (and view? (can-paste-properties?~ focus)))
        (set-action-enabled? {Action view delete} (and view? (can-delete?~ focus)))
        (set-action-enabled? {Action view select-all} (and view? (can-select-all?~ focus)))
        (when view?
          (focus-update-actions~ focus)))))
  
  
  ;;;
  ;;;; Selected
  ;;;
  
  
  (method public (add-selected-listener listener)
    (set! selected-listeners (add-listener listener selected-listeners)))
  
  
  (method public (remove-selected-listener listener)
    (set! selected-listeners (remove-listener listener selected-listeners)))
  
  
  (method public (get-selected)
    selected)
  
  
  (method public (set-selected owner sel (force?: force? #f))
    (let ((new-owner? (neq? owner selected-owner)))
      (when (or force? new-owner? (neq? sel selected))
        (process-selected-change owner selected sel force?))))
  
  
  (method public (close-selected owner)
    (when (eq? owner selected-owner)
      (set! selected-owner {})
      (process-selected-change {} selected {} #f)))

  
  (method (process-selected-change owner old-selected new-selected force?)
    (set! selected-owner owner)
    (set! selected new-selected)
    (when (and selected-listeners (not (exiting-process?)))
      (let ((evt (new Selected-Event :selected-change self owner old-selected new-selected force?: force?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  selected-listeners))))

  
  ;;;
  ;;;; Application
  ;;;
  
  
  (method public (add-application-listener category listener)
    (set-application-listeners category (add-listener listener (get-application-listeners category))))
  
  
  (method public (remove-application-listener category listener)
    (set-application-listeners category (remove-listener listener (get-application-listeners category))))

  
  (method package (process-application-event category kind sender . properties)
    (let ((listeners (get-application-listeners category)))
      (let ((evt (apply new Application-Event kind sender properties)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (get-application-listeners category)
    (table-ref application-listeners category '()))
  
  
  (method (set-application-listeners category listeners)
    (table-set! application-listeners category listeners))

  
  ;;;
  ;;;; Frames
  ;;;
  
  
  (method public virtual (default-frame-class)
    {})


  (method public virtual (file-frame-class file)
    (let ((extension (get-extension~ file)))
      (either (extension-frame-class extension)
              (error "Unknown file extension: {a}" extension))))


  (method public virtual (extension-frame-class ext)
    (either (profile-extension-frame-class ext)
            (known-extension-frame-class ext)
            (unknown-extension-frame-class)))
  
  
  (method (profile-extension-frame-class ext)
    (when profile
      (extension-frame-class~ profile ext)))


  (method public virtual (known-extension-frame-class ext)
    {})
  
  
  (method public virtual (unknown-extension-frame-class)
    {})


  (method public virtual (frame-class (file: file {}))
    (if (not file)
        (default-frame-class)
      (file-frame-class file)))
  
  
  (method (get-default-frame-class)
    (let* ((pref (get-workspace-preferences))
           (model (get-frame-model~ pref)))
      (if model
          (autoload model)
        (default-frame-class))))

  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (initialize-toplevel)
    (set! toplevel (new-toplevel))
    (ensure-displayed~ toplevel))
  
  
  (method public virtual (new-toplevel)
    (new Toplevel))
  
  
  (method public virtual (show-toplevel)
    (set-visible?~ toplevel #t))
  
  
  (method (initialize-actions)
    (set-application-actions (get-class-actions self)))

  
  ;;;
  ;;;; Stage
  ;;;
  
  
  (method public virtual (new-stage)
    (new (stage-class) parent: (new Stage-Border) name: 'stage))
  
  
  (method protected virtual (stage-class)
    Stage)
  
  
  ;;;
  ;;;; Shortcuts
  ;;;
  
  
  (method (setup-shortcuts)
    (set! shortcut-table (make-table test: shortcut=? hash: shortcut-hash)))
      
  
  (method (register-actions-shortcuts old-actions new-actions)
    (define (unregister-shortcut action-item shortcut)
      ;; the second test is necessary because bindings can be changed on-the-fly in the ide
      (when (and shortcut (table-ref shortcut-table shortcut #f))
        (table-remove! shortcut-table shortcut action-item)))
    
    (define (register-shortcut action-item shortcut)
      (when shortcut
        (table-add shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each (lambda (actions)
                  (for-each (lambda (action-item)
                              (when (get-visible?~ action-item)
                                (unregister-shortcut action-item (get-shortcut~ action-item))
                                (unregister-shortcut action-item (get-alternate-shortcut~ action-item))))
                            (get-children~ actions)))
                old-actions)
      (for-each-reversed (lambda (actions)
                           (for-each (lambda (action-item)
                                       (when (get-visible?~ action-item)
                                         (register-shortcut action-item (get-shortcut~ action-item))
                                         (register-shortcut action-item (get-alternate-shortcut~ action-item))))
                                     (get-children~ actions)))
                         new-actions)))
  
  
  (method public (update-shortcut action-item old-shortcut new-shortcut)
    (when old-shortcut
      (table-remove! shortcut-table old-shortcut action-item))
    (when new-shortcut
      (table-add shortcut-table new-shortcut action-item)))
  
  
  (method public (dispatch-shortcut shortcut)
    (if (or (not shortcut-hook)
            (not (shortcut-hook shortcut)))
        (let ((action-items (get-bound-actions shortcut)))
          (when (not-null? action-items)
            (invoke~ (car action-items) self {})
            #t))
      #t))
  
  
  (method public (get-bound-actions shortcut)
    (define (filter-enabled actions)
      (collect-if (lambda (action)
                    (get-enabled?~ action))
                  actions))
    
    (let ((actions (table-ref shortcut-table shortcut '())))
      ;; This temporary test is because I am not sure it is what we want in general
      ;; It could be very surprising to do a shortcut that's supposed to do nothing
      ;; as it's disabled and find out that something completly different happened!
      (if (shortcut=? shortcut {Shortcut :control #\X})
          (filter-enabled actions)
        actions)))
  
  
  ;;;
  ;;;; Bindings
  ;;;
  
  
  (definition Bindings-File
    {File Profile "settings" "Bindings.jml"})
  
  
  (method (setup-bindings)
    (define (set-bindings/designer bindings)
      (set-bindings bindings)
      (set! bindings-designer (new Designer form: (get-form~ bindings) reference: bindings)))
    
    (with-safe-execution "loading the bindings"
      (lambda ()
        (let ((bindings (load-bindings)))
          (set-bindings/designer bindings)
          (let ((active (either (get-active-bindings~ (get-preferences #f)) 'jazz)))
            (let ((branch (locate-component~ bindings active)))
              (when (is? branch Branch)
                (set-active-branch~ bindings branch))))))
      continue-handler:
      (lambda (err)
        (set-bindings/designer (default-bindings)))))
  
  
  (method protected virtual (load-bindings)
    (let ((file Bindings-File))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-from-file file))
        (default-bindings))))
  
  
  (method protected virtual (default-bindings)
    (new Application-Bindings))
  
  
  (method (save-bindings)
    (when (and bindings-designer (get-modified?~ bindings-designer) (file? (get-origin~ (get-form~ bindings-designer))))
      (save~ bindings-designer)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method public (set-application-actions actions-list)
    (register-actions-shortcuts application-actions actions-list)
    (set! application-actions actions-list))
  
  
  (method public (set-profile-actions actions-list)
    (register-actions-shortcuts profile-actions actions-list)
    (set! profile-actions actions-list))


  (method public (set-guest-actions actions-list)
    (register-actions-shortcuts guest-actions actions-list)
    (set! guest-actions actions-list))
  
  
  (method public (set-focus-actions actions-list)
    (register-actions-shortcuts focus-actions actions-list)
    (set! focus-actions actions-list))

  
  ;;;
  ;;;; Menubar
  ;;;


  (method public (find-menubar)
    (let ((host (get-toolbar :menubar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (update-menubar-buttons)
    (let ((menubar (find-menubar)))
      (when menubar
        (update-buttons~ menubar))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (definition Undisplayed-Message
    {})


  (method public (set-status-message msg action-handler)
    (let ((message (get-message-view)))
      (if (not message)
          (set! Undisplayed-Message msg)
        (set! Undisplayed-Message {})
        (post-event
          (lambda ()
            (set-title~ message (cond ((not msg) "")
                                      ((is? msg Locales) msg)
                                      (else (->string msg))))
            (set-action-handler~ message action-handler)))
        (when (primordial-thread?)
          (update-view~ message)))))


  (method public (find-status-bar)
    (let ((host (get-toolbar :status)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (get-message-view)
    (let ((status-bar (find-status-bar)))
      (when status-bar
        (find-component~ status-bar 'message))))
  
  
  (method public (show-undisplayed-message)
    (when Undisplayed-Message
      (set-status-message Undisplayed-Message {})
      (set! Undisplayed-Message {})))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (class-actions)
    (cons (find-actions 'application)
          (nextmethod)))


  ;;;
  ;;;; Alias
  ;;;
  
  
  (method override (process-alias name)
    (case name
      ((:application) self)
      ((:toplevel)    (get-toplevel))
      ((:stage)       (current-stage))
      ((:frame)       (current-frame))
      ((:document)    (current-document))
      ((:focus)       (get-focus))
      ((:focus-host)  (focused-host))
      ((:focus-guest) (focused-guest))
      ((:profile)     (get-profile))
      ((:images)      (get-images-cache))
      (else           (nextmethod name))))
  
  
  ;;;
  ;;;; Menus
  ;;;
  
  
  (method public virtual (text-menu text)
    (new-text-context-menu~ text))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public virtual (get-output-log)
    {})
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (definition All-Results
    {})
  
  (definition Active-Results
    {})
  
  
  (method public virtual (navigable-results)
    (must-implement 'navigable-results "results navigation"))
  
  
  (method (get-navigable-results)
    (unless All-Results
      (set! All-Results (navigable-results)))
    All-Results)
  
  
  (method public (get-active-results)
    (unless Active-Results
      (set! Active-Results (car (get-navigable-results))))
    Active-Results)
  
  
  (method public (set-active-results results)
    (set! Active-Results results))
  
  
  ;;;
  ;;;; Locales
  ;;;
  
  
  (method (locale-change loc update?)
    (select-locale loc)
    (when update?
      (locale-update)))


  (method public (select-locale locale)
    (let ((status (find-status-bar)))
      (when status
        (let ((label (locate-component~ status 'locales)))
          (when label
            (set-title~ label (localize (present-locale locale))))))))
  
  
  (method public (locale-update)
    ;; All this should of course be event based but it will do for now...
    (layout-menu~ (find-menubar))
    (redraw-window~ (get-toplevel)))
  
  
  ;;;
  ;;;; Workspace
  ;;;
  
  
  (method (setup-workspaces)
    (let ((preferences (get-workspaces-preferences)))
      (if (null? (get-children~ preferences))
          (error "No workspaces found in Preferences.jml")
        (let ((menubar (find-menubar)))
          (let ((actions (find-actions 'application))
                (menu (get-content~ (child~ menubar 'workspace)))
                (toolbar (find-toolbar))
                (active (get-active~ preferences)))
            (for-each (lambda (workspace)
                        (let ((name (get-name~ workspace))
                              (title (get-title~ workspace))
                              (icon (get-icon~ workspace)))
                          (let ((action-name (string->symbol (format "select-{a}-workspace" name)))
                                (event-handler (new Event-Handler target-name: :application method-name: 'on-select-workspace properties: (list workspace: name)))
                                (selected? (eq? name active)))
                            (new Action-Item parent: actions name: action-name action-handler: event-handler shortcut: (get-shortcut~ workspace))
                            (new Radio-Item parent: menu name: (get-name~ workspace) title: title icon: icon before: 'layout-separator group: 'workspace selected?: selected? action: (new Action 'application action-name '()))
                            (new Workspace-Button parent: toolbar name: name size: {Dimension 22 22} location: 'tail before: 'tail-separator group: 'workspace resource: icon portfolio: :images selected?: selected? tooltip?: #t tooltip-text: title action-handler: event-handler)
                            (new Separator parent: toolbar size: {Dimension 1 0} location: 'tail before: 'tail-separator))))
                      (get-children~ preferences))
            (layout-menu~ menu)
            (layout~ toolbar))))))
  
  
  (method (select-default-workspace)
    (define (find-workspace)
      (let ((pref (get-workspaces-preferences error?: #f)))
        (if (not pref)
            (default-workspace)
          (let ((active (get-active~ pref)))
            (if (not active)
                (default-workspace)
              (child~ pref active))))))
    
    (define (default-workspace)
      (new Default-Workspace))
    
    (apply-preferences~ (find-workspace)))
  
  
  (method package (on-select-workspace evt)
    (select-workspace (get-property~ evt workspace:)))
  
  
  (method package (on-next-workspace evt)
    (select-next-workspace))
  
  
  (method package (on-previous-workspace evt)
    (select-previous-workspace))
  
  
  (method package virtual (on-workspace evt)
    (case (get-kind~ evt)
      ((activate)
       (let ((workspace (get-property~ evt workspace:)))
         (activate-workspace-item workspace)
         (activate-workspace-button workspace)))))
  
  
  (method public undocumented (activate-workspace-item workspace)
    (let ((menubar (find-menubar)))
      (when menubar
        (let ((item (find-component~ menubar 'workspace)))
          (when item
            (let ((menu (get-content~ item)))
              (let ((radio (find-component~ menu (get-name~ workspace))))
                (if (not radio)
                    (unselect-elements~ menu class: Radio-Item group: 'workspace)
                  (set-selected?~ radio #t)))))))))
  
  
  (method public undocumented (activate-workspace-button workspace)
    (let ((toolbar (find-toolbar))
          (name (workspace-button-name workspace)))
      (when (and toolbar name)
        (let ((radio (find-component~ toolbar name)))
          (if (not radio)
              (unselect-elements~ toolbar class: Radio-Tool group: 'workspace)
            (set-selected?~ radio #t))))))
  
  
  (method public virtual undocumented (workspace-button-name workspace)
    (get-name~ workspace))
  
  
  (method public virtual (workspace-installed)
    )
  
  
  (method package (on-zoom-horizontally evt)
    (with-locked-update
      (lambda ()
        (let ((started? #f))
          (continuation-capture
            (lambda (return)
              (for-each-splitter (current-stage-border)
                (lambda (splitter host)
                  (if (eq? (get-orientation~ splitter) 'vert)
                      (when started?
                        (continuation-return return))
                    (if (eq? (get-state~ splitter) 'split)
                        (if (workspace-zoomable?~ splitter host)
                            (zoom~ splitter host)
                          (continuation-return return))
                      (unzoom~ splitter))
                    (set! started? #t))))))))))
  
  
  (method package (on-zoom-vertically evt)
    (with-locked-update
      (lambda ()
        (let ((started? #f)
              (border (current-stage-border)))
          (continuation-capture
            (lambda (return)
              (for-each-splitter border
                (lambda (splitter host)
                  (if (eq? (get-orientation~ splitter) 'horz)
                      (when started?
                        (continuation-return return))
                    (if (eq? (get-state~ splitter) 'split)
                        (zoom~ splitter host)
                      (unzoom~ splitter))
                    (set! started? #t))
                  (when (eq? host border)
                    (continuation-return return))))))))))
  
  
  (method package (on-maximize/restore evt)
    (let ((stage (current-stage)))
      (if (get-maximized?~ stage)
          (restore~ stage)
        (maximize~ stage))))
  
  
  (method package (on-full-screen evt)
    (let ((pref (get-preferences {})))
      (when (not (get-fullscreen-warned?~ pref))
        (message-box "Warning: There is currently only one way of exiting the fullscreen mode which is by using the Alt-Shift Backspace shortcut for Full Screen toggle")
        (set-property~ preferences-designer pref 'fullscreen-warned? #t)))
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (set-fullscreen?~ (selected-workspace) fullscreen?)
      (full-screen-stage fullscreen?)))
  
  
  (method public (full-screen-stage fullscreen?)
    (full-screen (current-stage-border) fullscreen?))
  
  
  (method public (toggle-full-screen host)
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (full-screen host fullscreen?)))
  
  
  (method public (full-screen host fullscreen?)
    (define (fix-top-splitter-insets splitter)
      (if (not fullscreen?)
          (let ((preserved (get-preserved-insets~ splitter)))
            (when preserved
              (set-preserved-insets~ splitter {})
              (set-insets~ splitter preserved)))
        (set-preserved-insets~ splitter (get-insets~ splitter))
        (set-insets~ splitter {Rect 0 0 0 0})))
    
    (let ((toplevel (get-toplevel))
          (stage (current-stage)))
      (when (neq? fullscreen? (get-fullscreen?~ toplevel))
        (with-locked-update
          (lambda ()
            (set-fullscreen?~ toplevel fullscreen?)
            (when stage
              (set-fullscreen?~ stage fullscreen?))
            (for-each-splitter host
              (lambda (splitter host)
                (let ((preferences (get-preferences~ splitter)))
                  (when (and preferences (eq? (get-name~ preferences) 'top))
                    (fix-top-splitter-insets splitter)))
                (set-full?~ splitter fullscreen?)
                (if fullscreen?
                    (zoom~ splitter host)
                  (unzoom~ splitter)))))))))
  
  
  (method public (on-delete-stage evt)
    (delete-stage))
  
  
  (method public (on-delete-other-stages evt)
    (delete-other-stages))
  
  
  (method public (on-split-vertically evt)
    (split-stage-vertically))
  
  
  (method public (on-split-horizontally evt)
    (split-stage-horizontally))
  
  
  (method public (on-navigate-frame evt)
    (navigate-frame))


  ;;;
  ;;;; Toolbar
  ;;;
  
  
  (method public (find-toolbar)
    (let ((host (get-toolbar :toolbar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (find-command-toolbar)
    (define (try name)
      (let ((host (get-toolbar name)))
        (when (and host (in-player?~ host))
          (get-guest~ host))))
    
    (either (try :command)
            (try :minibuffer)
            (try :toolbar)))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (get-context-text)
    {})
   
  
  ;;;
  ;;;; Classes
  ;;;
  
  
  (method public virtual (get-text-class)
    Plain-Text-View)


  ;;;
  ;;;; Resources
  ;;;
  
  
  (method public (get-resource type name)
    (define (resources-dir)
      (if (find-alias 'Jazz)
          {Directory Jazz "lib" "jazz" "resources"}
        {Directory Build "lib" "jazz" "resources"}))
    
    (case type
      ((image) (new-file~ (resources-dir) (list "images" (format "{a}.png" name))))
      ((cursor) (new-file~ (resources-dir) (list "cursors" (format "{a}.cur" name))))))


  ;;;
  ;;;; Images
  ;;;
  
  
  (definition Images-Cache
    {})
  
  
  (method public (get-images-cache)
    (unless Images-Cache
      (set! Images-Cache (new Portfolio)))
    Images-Cache)


  ;;;
  ;;;; Catalog
  ;;;


  (method public virtual (get-cataloguer)
    {})


  (method public virtual (get-catalog-context)
    {})


  ;;;
  ;;;; Feedback
  ;;;

  
  (method override (user-feedback message)
    )


  ;;;
  ;;;; Events
  ;;;
  

  (method override (get-event-consumer)
    event-consumer)
  
  
  (method override (set-event-consumer consumer)
    (set! event-consumer consumer))


  (method override (deliver-event handler target proc event)
    (proc target event))


  ;;;
  ;;;; Console
  ;;;


  (method public (fresh-prompt (text: text {}))
    (let ((text (either text (get-console-text))))
      (when text
        (fresh-prompt~ text))))
  
  
  (method package (on-console evt)
    (let ((focus (get-focus))
          (text (show-console)))
      (when (and text (eq? text focus))
        (cond ((or (not (at-end?~ text))
                   (extended?~ (last-block~ text)))
               (fresh-prompt~ text))
              ((not (cell-displayed?~ text (get-end~ text)))
               (ensure-displayed~ text))
              (else
               (select-next-console~ (get-console-manager)))))))
  
  
  (method public (show-console (class: class Lisp-Console-Manager)
                               (workspace: workspace 'home)
                               (focus?: focus? #t))
    (let ((manager (select-palette class workspace: workspace)))
      (when (and manager focus?)
        (let ((text (get-text~ manager)))
          (if (not text)
              (bell)
            (acquire-focus~ text))
          text))))
  
  
  (method package (on-clear-console evt)
    (clear-console~ (get-console-text)))
  
  
  (method package (on-sql-console evt)
    (let ((had-focus? (is? (get-focus) SQL-Console-Text-View)))
      (show-console class: SQL-Console-Manager workspace: 'sql)
      (when had-focus?
        (fresh-prompt text: (get-sql-console-text)))))
  
  
  (method (on-sql-connections evt)
    (select-palette SQL-Connections-Manager workspace: 'sql focus?: #t))
  
  
  @convert
  (method (on-sql-inventory evt)
    (select-palette Inventory-Browser workspace: 'sql focus?: #t))
  
  
  (method (on-sql-tree-output evt)
    (select-palette SQL-Tree-Output 'sql focus?: #t))


  ;;;
  ;;;; Debug
  ;;;
  
  
  (method override (process-debuggee-loop)
    (if (and (local-proxy? (get-controller-debugger))
             (event-thread?))
        (with-jazz-exception-debugger
          process-events)
      (nextmethod)))


  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method (exception-reported)
    ;; so as not to get recursive exceptions
    (catch Exception
      (cleanup-mouse-processing)))
  
  
  @convert
  (method (present-execution-context exception type prefix?)
    (present~ (new Exception-Presenter) exception type: type prefix?: prefix?))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual undocumented (get-search-manager)
    {})
  
  
  (method public virtual undocumented (get-search-results)
    (get-guest~ (singleton-docked Search-Results {})))
  
  
  (method public (active-search)
    (let ((manager (get-search-manager)))
      (when manager
        (get-search~ (get-guest~ manager)))))
  
  
  ;; This needs cleanup as it cannot be done for every application
  (method public (update-search-actions)
    (let* ((frames (all-frames))
           (count (length frames))
           (results (get-search-results))
           (results-count (get-visible-count~ (get-tree~ results)))
           (results-stack-count (length (get-results-stack~ results)))
           (in-modal? (in-modal?)))
      (set-action-enabled? {Action application edit-next} (>= results-count 1))
      (set-action-enabled? {Action application edit-previous} (>= results-count 1))
      (set-action-enabled? {Action application edit-current} (>= results-count 1))
      @wait
      (set-action-enabled? {Action application pop-results} (> results-stack-count 1))
      (set-action-enabled? {Action application find-forward} (>= count 1))
      (set-action-enabled? {Action application find-backward} (>= count 1))
      (set-action-enabled? {Action application replace} (>= count 1))
      (set-action-enabled? {Action application replace&find-forward} (>= count 1))
      (set-action-enabled? {Action application replace-all} (>= count 1))
      (set-action-enabled? {Action application replace-all-selected} (>= results-count 1))))


  ;;;
  ;;;; Search Menu
  ;;;
  
  
  (method package (on-find evt)
    (update-search 'text 'active-window))
  
  
  (method package (on-find-in-text evt)
    (update-search 'text {}))
  
  
  (method package (on-find-in-directories evt)
    (update-search 'directories {}))
  
  
  (method package (on-find-in-projects evt)
    (update-search 'projects {}))
  
  
  (method (update-search tab domain)
    (let* ((focus (get-focus))
           (internal? (is? focus Tree-Embedded-Search-Text-View))
           (string (if (and (not internal?) (is? focus Text-View)) (get-selected-string~ focus) {}))
           (palette (get-search-manager))
           (player (get-player~ palette))
           (manager (get-guest~ palette))
           (tab-view (locate~ manager 'tab))
           (same-tab? (eq? tab (get-selection-name~ tab-view))))
      (if (and (not domain)
               (eq? (get-focused-window) player)
               same-tab?)
          (next-radio~ (get-search~ manager))
        (when tab
          (set-selection-name~ tab-view tab)
          (when domain
            (set-search-domain~ (get-search~ manager) domain))))
      (bring-to-front~ player)
      (set-visible?~ player #t)
      (for-each (lambda (search)
                  (let ((targets (get-search-targets~ search)))
                    (unless (or (not string)
                                (and (not-null? targets)
                                     (equal? string (first (first targets)))))
                      (set-search-targets~ search (list (list string ""))))))
                (get-searches~ manager))
      (when (or (not internal?) (not same-tab?))
        (select-search~ (get-search~ manager)))))
  
  
  (method public (end-search-edition)
    (let* ((palette (get-search-manager))
           (manager (get-guest~ palette))
           (search (get-search~ manager))
           (tree (get-targets-tree~ search)))
      (end-edition~ tree)))


  (method package (on-edit-next evt)
    (edit-next~ (get-active-results)))


  (method package (on-edit-previous evt)
    (edit-previous~ (get-active-results)))


  (method package (on-edit-current evt)
    (edit-current~ (get-active-results)))


  (method package (on-pop-results evt)
    (clear-results~ (get-search-results)))


  (method package (on-find-forward evt)
    (let ((search (active-search)))
      (if (not search)
          (let ((text (get-text-view~ (get-guest~ (first-frame)))))
            (let ((multi-search-context (get-find-targets)))
              (unless (select-next~ text multi-search-context)
                (bell))))
        (on-find-forward~ search evt))))


  (method package (on-find-backward evt)
    (let ((search (active-search)))
      (if (not search)
          (let ((text (get-text-view~ (get-guest~ (first-frame)))))
            (let ((multi-search-context (get-find-targets)))
              (unless (select-previous~ text multi-search-context)
                (bell))))
        (on-find-backward~ search evt))))


  (method package (on-replace evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace~ search evt))))


  (method package (on-replace&find-forward evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace&find-forward~ search evt))))


  (method package (on-replace-all evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace-all~ search evt))))


  (method package (on-replace-all-selected evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace-all-selected~ search evt))))

  
  ;;;
  ;;;; Command Shell
  ;;;
  
  
  (method package (on-command-extended evt)
    (select-command-extended))
  
  
  (method package (on-command-execute evt)
    (select-command-execute))
  
  
  (method public virtual (get-command-shell)
    (let ((toolbar (find-command-toolbar)))
      (when toolbar
        (locate-component~ toolbar 'command-shell))))
  
  
  (method public virtual (get-command-text)
    (let ((shell (get-command-shell)))
      (when shell
        (get-text~ shell))))
  
  
  (method public (require-command-text)
    (either (get-command-text)
            (begin
              (message-box "This workspace doesn't contain a command text")
              (throw-cancel))))
  
  
  (method (require-unzoomed-command-text)
    (define (unzoom text)
      (let ((host (get-host~ text)))
        (let ((splitter (get-parent~ host)))
          (when (is? splitter Splitter-View)
            (when (eq? (get-state~ splitter) 'zoom)
              (let ((target (get-target~ splitter)))
                (when (neq? target host)
                  (unzoom~ splitter)
                  (set-client-restore~ text
                    (lambda ()
                      (when (in-player?~ splitter)
                        (zoom~ splitter target)))))))))))
    
    (let ((text (require-command-text)))
      (unzoom text)
      text))
  
  
  (method public (select-command-search direction text)
    (select-search~ (require-unzoomed-command-text) direction {} text #t #t))
  
  
  (method public (select-command-search-current direction range text)
    (select-search~ (require-unzoomed-command-text) direction range text #f #f))
  
  
  (method public (select-command-extended)
    (select-extended~ (require-unzoomed-command-text)))
  
  
  (method public (select-command-execute)
    (select-execute~ (require-unzoomed-command-text)))


  ;;;
  ;;;; Search Context
  ;;;


  (method public undocumented (get-search-targets)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Targets)
        (get-search-targets~ search))))
  
  
  (method public undocumented (set-search-targets targets)
    (let ((search (active-search)))
      (if (not search)
          #f @convert (set-setting 'Search-Targets targets)
        (set-search-targets~ search targets))))


  (method public undocumented (get-find-targets)
    (let ((search (active-search)))
      (if (not search)
          (make-multi-search-context
            (map (lambda (target)
                   (make-search-context (first target)
                     whole-words?: (get-whole-words?)
                     ignore-case?: (get-ignore-case?)))
                 (get-search-targets)))
        (get-find-targets~ search))))


  (method public undocumented (get-replace-targets)
    (let ((search (active-search)))
      (if (not search)
          (map second (get-search-targets))
        (get-replace-targets~ search))))

  
  (method public undocumented (get-whole-words?)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Whole-Words?)
        (get-whole-words?~ search))))
    
  
  (method public undocumented (get-ignore-case?)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Ignore-Case?)
        (get-ignore-case?~ search))))
    
  
  (method public undocumented (get-preserve-case?)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Preserve-Case?)
        (get-preserve-case?~ search))))
    
  
  (method public undocumented (get-play-recording?)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Play-Recording?)
        (get-play-recording?~ search))))

  
  (method public undocumented (get-expression?)
    (let ((search (active-search)))
      (if (not search)
          (get-setting 'Search-Expression?)
        (get-expression?~ search))))


  ;;;
  ;;;; Files
  ;;;


  (method package virtual (on-new evt)
    (new-event~ (get-default-frame-class)))
    

  (method package virtual (on-open evt)
    (open-files))
  
  
  (method public (open-files (directory: directory {}))
    (let ((files (choose-file directory: directory extensions: (open-extensions) multiple-selection?: #t)))
      (for-each edit-file
                (sort string>? files key: get-name~))))
  
  
  (method public virtual (receive-files pos pathnames)
    (if (and (= (length pathnames) 1) (directory? (car pathnames)))
        (let ((dir (car pathnames)))
          (set-current-directory dir)
          (user-message "Current directory set to {a}" (parse~ dir)))
      (let ((class (cond ((alt-down?) (autoload-class 'Jazz-Plain-Text-View))
                         ((shift-down?) (autoload-class 'Jazz-Text-View))
                         (else {}))))
        (for-each (lambda (pathname)
                    (when (file? pathname)
                      (if class
                          (edit-document pathname class: class)
                        (edit-file pathname))))
                  pathnames))))
  
  
  (method public virtual (edit-file file)
    (edit-document file))
  
  
  ;; a quicky... this should really be up to the current workspace
  (method public virtual (open-extensions)
    {})


  (method public (find-document moniker (class: class {}))
    (find-if (lambda (frame)
               (and (is? frame Frame-Host)
                    (let ((guest (get-guest~ frame)))
                      (and (is? guest Document)
                           (or (not class) (is? guest class))
                           (let ((guest-moniker (get-moniker~ (get-controller~ guest))))
                             (and guest-moniker
                                  (pathname=? guest-moniker moniker)))))))
             (all-frames include-invisibles?: #t)))
  
  
  (method public (edit-document moniker
                                (class: class {})
                                (workspace: workspace {})
                                (selection: selection {})
                                (char-encoding: char-encoding {})
                                (wrap?: wrap? #f)
                                (force-new?: force-new? #f)
                                (activate-focus?: activate-focus? #t)
                                (visible?: visible? #t)
                                (return-new?: return-new? #f))
    (when moniker
      (if (not (exists?~ moniker))
          (error "Unable to locate document: {t}" moniker)
        (let ((file moniker))
          (let* ((frame (if force-new? {} (find-document file class: class)))
                 (result (lambda (frame new?) (if return-new? (values frame new?) frame))))
            (if (not frame)
                (let ((class (either class (file-frame-class file))))
                  (with-cursor :wait
                    (lambda ()
                      (result (new-frame class
                                         host-workspace: workspace
                                         host-visible?: visible?
                                         host-focus?: activate-focus?
                                         initialize: (lambda (host document)
                                                       (let ((text? (is? document Text-View)))
                                                         (when text?
                                                           (set-char-encoding~ document char-encoding))
                                                         (set-moniker~ (get-controller~ document) moniker)
                                                         (when text?
                                                           (when wrap?
                                                             (set-wrap?~ document #t))
                                                           (when selection
                                                             (set-selection-safe~ document selection ensure-displayed?: 'center-caret))))))
                              #t))))
              (when selection
                (let ((document (get-guest~ frame)))
                  (set-selection-safe~ document selection ensure-displayed?: 'center-caret)))
              (when visible?
                (bring-to-front~ frame)
                (set-visible?~ frame #t)
                (when activate-focus?
                  (focus-host~ frame)))
              (verify-reload~ (get-controller~ (get-guest~ frame)))
              (result frame #f)))))))
  
  
  (method public (edit-help-document moniker)
    (let* ((frame (edit-document moniker))
           (text (get-guest~ frame)))
      (set-editable?~ text #f)))
  
  
  (method public (edit-filename filename)
    (let* ((workbench (get-service 'workbench))
           (project-file (essay workbench (find-filename~ workbench filename))))
      (if (not project-file)
          (error "Unable to locate filename: {t}" filename)
        (let* ((frame (edit-document (get-source~ project-file)))
               (text (get-guest~ frame)))
          (verify-reload~ (get-controller~ text))))))
  
  
  (method public virtual (edit-category name)
    )
  
  
  (method package virtual (on-close evt)
    (let ((frame (first-frame)))
      (when frame
        (close-with-confirm~ frame))))

  
  (method package virtual (on-close-all evt)
    (for-each (lambda (view)
                (when (is? view Frame-Host)
                  (let ((guest (get-guest~ view)))
                    (when (or (is-not? guest Document) (close-on-close-all?~ (get-controller~ guest)))
                      (confirm-close~ view)
                      (close~ view)))))
              (all-frames)))
        
    
  (method package virtual (on-save-all evt)
    (save-all))
  
  
  (method package virtual (on-print evt)
    (let ((guest (current-guest)))
      (print-document~ guest)))

   
  (method package virtual (on-print-layout evt)
    (let ((guest (current-guest)))
      (print-layout~ guest)))

  
  (method package virtual (on-print-preview evt)
    (let ((guest (current-guest)))
      (print-preview~ guest)))
  
  
  (method package virtual (on-quit-application evt)
    (exit-process))
  
  
  (method public (save-all (class: class Document) (save-unanchored?: save-unanchored? #t))
    (let ((save-documents
            (lambda (main-documents?)
              (for-each (lambda (host)
                          (when (is? host Frame-Host)
                            (let ((guest (get-guest~ host)))
                              (when (is? guest Document)
                                (let ((controller (get-controller~ guest)))
                                  (when (and (is? guest class)
                                             (or save-unanchored? (get-moniker~ guest))
                                             (xor main-documents? (dependent-document?~ controller))
                                             (get-modified?~ (get-controller~ guest)))
                                    (save~ guest)))))))
                        (all-frames include-invisibles?: #t)))))
      ;; saving dependent documents will make their main document modified
      (save-documents #f)
      (save-documents #t)))


  ;;;
  ;;;; Definitions
  ;;;

  
  (method public virtual (edit-definitions object . rest)
    )

  
  (method public virtual (edit-references object . rest)
    )


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (context-update)
    (define (modify-catalogs)
      (let ((pref (find-preferences 'catalogs)))
        (when pref
          (let ((cataloguer (get-cataloguer)))
            (for-each (lambda (config)
                        (let* ((name (get-name~ config))
                               (catalog (get-catalog~ cataloguer name error?: #f)))
                          (when (and catalog (get-active?~ config))
                            (activate~ catalog))))
                      (get-children~ pref))))))
    
    (define (modify-profile)
      (when profile
        (close~ profile))
      (let ((pref (find-preferences {})))
        (when pref
          (let ((class (either (get-profile-class~ pref) Profile)))
            (when class
              (set! profile (new (autoload class)))))))
      (when profile
        (init~ profile))
      (when profile
        (finalize~ profile)))
    
    (nextmethod)
    (modify-catalogs)
    (modify-profile)
    (user-message "Context set to {a}" context))

  
  ;;;
  ;;;; Preferences
  ;;;
  
  
  (method override (setup-preferences)
    (with-safe-execution "loading the preferences"
      (lambda ()
        (setup-preferences/designer))
      continue-handler:
      (lambda (err)
        (set-preferences/designer (default-preferences)))))
  
  
  (method override (default-preferences)
    (new Application-Preferences))
  
  
  (method protected virtual (toolbox-file)
    {File Profile "settings" "Toolbox.jml"})

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (definition Default-Page-Setup
    {})
  
  (definition Default-Page-Setup-Designer
    {})
  
  (definition Default-Page-Setup-Form
    (form>>
      (<Page-Setup>)))
  
  (definition Default-Page-Setup-File
    {File Profile "settings" "PageSetup.jml"})
  
  
  (method public undocumented (set-default-page-setup page-setup)
    (set! Default-Page-Setup page-setup))
  
  
  (method public undocumented (default-page-setup)
    (when (not Default-Page-Setup)
      (setup-page-setup))
    Default-Page-Setup)
  
  
  (method public undocumented (default-page-setup-designer)
    (when (not Default-Page-Setup-Designer)
      (setup-page-setup))
    Default-Page-Setup-Designer)
  
  
  (method virtual (setup-page-setup)
    (let* ((file Default-Page-Setup-File)
           (form (if (and (is-alias? 'Profile) (exists?~ file)) (read-from-file file) Default-Page-Setup-Form)))
      (set! Default-Page-Setup (instantiate~ form))
      (set! Default-Page-Setup-Designer (new Designer form: (get-form~ Default-Page-Setup) reference: Default-Page-Setup))))
  
  
  (method virtual (save-page-setup)
    (when (and Default-Page-Setup-Designer (file? (get-origin~ (get-form~ Default-Page-Setup-Designer))))
      (let ((form (get-form~ Default-Page-Setup-Designer)))
        (when (not (get-origin~ form))
          (set-origin~ form Default-Page-Setup-File)))
      (save~ Default-Page-Setup-Designer)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public virtual (get-documentation-cataloguer)
    {})
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  (method (on-zoom-out evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (- scaling 0.25) #t)))))
  
  
  (method (on-zoom-in evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (+ scaling 0.25) #t)))))
  
  
  (method (on-unzoom evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (scale-view view 1.0 #f))))
  
  
  (method (scaled-view what)
    (case what
      ((document) (current-document))
      ((mouse-view) (mouse-view))))
  
  
  (method (scale-view view scaling scaled?)
    (user-message "Scaling set to {a}" scaling)
    (set-scaling~ view scaling)
    (set-scaled?~ view scaled?))


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (on-capture-document evt)
    (pick-figure
      click: (lambda (view pos) (capture-document view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-document evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-document view))))
  
  
  (definition (capture-document view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (let ((guest (get-guest~ view)))
          (if (not guest)
              (bell)
            (export-picture~ guest))))))
  
  
  (method (on-capture-host evt)
    (pick-figure
      click: (lambda (view pos) (capture-host view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-host evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-host view))))
  
  
  (definition (capture-host view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (export-picture~ host))))


  ;;;
  ;;;; Windows
  ;;;
  
  
  (method public virtual (update-windowing-actions)
    (unless (exiting-process?)
      (update-history-actions)
      (update-window-actions)
      (update-menubar-buttons)))
  
  
  (method public (update-window-actions)
    (let* ((frames (all-frames))
           (count (length frames))
           (in-modal? (in-modal?)))
      (set-action-enabled? {Action application close}             (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application close-all}         (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action guest save}                    (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action guest save-as}                 (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application save-all}          (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action guest revert-saved}            (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action guest compare-saved}           (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application page-setup}        (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application print-layout}      (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application print-preview}     (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application print}             (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application next-frame}        (and (>= count 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-frame}    (and (>= count 2) (not in-modal?)))
      (set-action-enabled? {Action application current-frame}     (and (>= count 1) (not in-modal?)))
      (set-action-enabled? {Action application tile-horizontally} (and (>= count 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-vertically}   (and (>= count 2) (not in-modal?)))))
  
  
  (method package virtual (on-next-frame evt)
    (let ((first (first-frame)))
      (send-to-back~ first)
      (focus-host~ (current-frame))))
  
  
  (method package virtual (on-previous-frame evt)
    (let ((last (last-frame)))
      (bring-to-front~ last)
      (focus-host~ (current-frame))))
  
  
  (method package virtual (on-current-frame evt)
    (let ((first (first-frame)))
      (focus-host~ first)))
  
  
  (method package virtual (on-tile-horizontally evt)
    (let* ((stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (h (quotient height count))
           (t 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point 0 t))
                      (set-size~ frame (new Dimension width h))
                      (increase! t h))
                    frames)))))
  
  
  (method package virtual (on-tile-vertically evt)
    (let* ((stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (w (quotient width count))
           (l 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point l 0))
                      (set-size~ frame (new Dimension w height))
                      (increase! l w))
                    frames)))))
  
  
  (method package (on-select-frame evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ host)
      (focus-host~ host)))
  
  
  (method package (on-select-palette evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ (get-player~ host)))))


;;;
;;;; Default-Workspace
;;;


(class Default-Workspace extends Workspace-Preferences
  
  
  (form
    (<install>             fullscreen?: #t
      (<Stage-Preferences> location: root)))))
