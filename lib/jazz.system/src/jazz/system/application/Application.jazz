;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Applications
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.system.application.Application jazz


(import (jazz.debuggee)
        (jazz.designer)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.listener)
        (jazz.library.template)
        (jazz.locale)
        (jazz.platform)
        (jazz.profile)
        (jazz.runtime)
        (jazz.system)
        (jazz.system.application)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.picker)
        (jazz.ui.search)
        (jazz.ui.skin)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.ui.workspace)
        (time))


(class Application extends Process implements (Context-Provider History-Provider Event-Consumer Save-Environment-Listener)


  (slot toplevel                 initialize #f)
  (slot profile-class            initialize #f)
  (slot profile                  initialize #f                        getter generate)
  (slot focus-listeners          initialize '())
  (slot application-listeners    initialize (make-table test: eq?))
  (slot selected-owner           initialize #f                        getter generate)
  (slot selected                 initialize #f)
  (slot selected-listeners       initialize '())
  (slot event-consumer           initialize self)
  (slot history-manager          initialize (new History-Manager self))
  (slot active?                  initialize #f                        getter generate)
  (slot application-actions      initialize '()                       getter generate)
  (slot profile-actions          initialize '()                       getter generate)
  (slot guest-actions            initialize '()                       getter generate)
  (slot focus-actions            initialize '()                       getter generate)
  (slot bindings-designer        initialize #f                        getter generate)
  (slot skins-designer           initialize #f                        getter generate)
  (slot workspaces-designer      initialize #f                        getter generate)
  (slot shortcut-table           initialize #f)
  (slot shortcut-hook            initialize #f                        accessors generate)
  
  
  (method meta override (external-name . rest)
    'application)

  
  ;;;
  ;;;; Access
  ;;;


  (method override (get-toplevel)
    toplevel)


  ;;;
  ;;;; Startup
  ;;;
  
  
  (method override (prepare-bindings)
    (nextmethod)
    ;; this is critical as any problem in the boot process
    ;; might display a message-box that needs basic bindings
    (set-bindings (new Application-Bindings)))


  (method override (prepare-environment)
    (nextmethod)
    (set-application self)
    (setup-shortcuts)
    (initialize-windowing get-setting)
    (initialize-system)
    (prepare-skins)
    (prepare-profile)
    (prepare-colors)
    (prepare-fonts)
    (prepare-formats)
    (prepare-styles))

  
  (method override (install-environment)
    (nextmethod)
    (install-skins)
    (install-bindings)
    (install-workspaces)
    (initialize-toplevel)
    (initialize-clipboard)
    (register-clipboard-formats))


  (method override (finalize-environment)
    (nextmethod)
    (set-cursor :arrow)
    (splash-screen))

  
  (method override (setup-profile)
    (define (create-profile)
      (with-safe-execution "loading the profile"
        (lambda ()
          (set! profile (if (find-unit-source profile-class)
                            (new (load-profile-class profile-class))
                          (new Me))))
        continue-text: (list (format "to bypass this problem by using a generic profile class"))
        continue-handler:
        (lambda (err)
          (set! profile (new Me)))))
    
    (when (use-profile?)
      (create-profile)
      (set-profile-actions (get-class-actions profile))))
  
  
  (method override (finish-environment)
    (nextmethod)
    (register-locale (new Locale english: '(english: "English")))
    (register-locale-change locale-change)
    (add-save-environment-listener self)
    (when profile
      (with-safe-execution "initing the profile"
        (lambda ()
          (init~ profile))
        continue-handler:
        (lambda (err)
          )))
    (reload-session)
    (remove-splash-screen))
  
  
  (method override (finish-process)
    (nextmethod)
    (select-default-workspace)
    (update-focus-actions)
    (update-windowing-actions))
  
  
  (method override (conclude-environment)
    (nextmethod)
    (initialize-actions)
    (skin-update)
    (show-toplevel)
    (when (run-loop?)
      (select-foreground~ toplevel))
    (when profile
      (with-safe-execution "finalizing the profile"
        (lambda ()
          (finalize~ profile))
        continue-handler:
        (lambda (err)
          ))))
  
  
  ;;;
  ;;;; Termination
  ;;;
  
  
  (method override (terminate-process)
    (nextmethod)
    (reset-palettes)
    (reset-dockeds)
    (reset-toolbars)
    (when toplevel
      (close~ toplevel)
      (set! toplevel #f)
      (set! profile-class #f)
      (set! profile #f)))


  ;;;
  ;;;; Java
  ;;;
  
  
  @test-java
  (definition Java-Classpath
    '({File "C:" "Java" "j2sdk1.4.2_04" "jre" "lib" "rt.jar"}
      {File "C:" "Java" "BCEL" "lib" "bcel-5.1.jar"}
      {File "C:" "Java" "JDBC" "msbase.jar"}
      {File "C:" "Java" "JDBC" "msutil.jar"}
      {File "C:" "Java" "JDBC" "mssqlserver.jar"}))
  
  
  @test-java
  (method (test-java)
    (setup-jvm classpath: Java-Classpath)
    (c-test)
    (let* ((loader (getSystemClassLoader~ java.lang.ClassLoader))
           (class (forName~ java.lang.Class "yo" #t loader)))
      (message-box (format "{a}" class))))


  ;;;
  ;;;; Loop
  ;;;


  (method override (start-loop)
    (setup-events)
    (process-events))
  
  
  (method override (resume-loop-action)
    (when toplevel
      (select-foreground~ toplevel)))


  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (clipboard-prefix)
    (format "{a}_{a}_"
            (process-name)
            (present~ (process-version))))
  
  
  (method protected virtual (register-clipboard-formats)
    (register-jazz-clipboard-formats (clipboard-prefix)))


  ;;;
  ;;;; Clipboard Stack
  ;;;

  
  (definition Clipboard-Stack
    '())
  
  (definition Max-Stack
    256)
  
  
  (method public (get-clipboard-stack)
    Clipboard-Stack)
  
  
  (method public (empty-clipboard-stack?)
    (null? Clipboard-Stack))
  
  
  (method public (add-clipboard)
    (let ((text (get-clipboard-text)))
      (when text
        (set! Clipboard-Stack (cons text Clipboard-Stack))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (method public (push-clipboard-list list)
    (let ((pushed (length list)))
      (if (> pushed Max-Stack)
          (error "Unable to push list of {a} onto the clipboard stack" pushed)
        (set! Clipboard-Stack (append list Clipboard-Stack))
        (trim-clipboard)
        (update-focus-actions))))
  
  
  (definition (trim-clipboard)
    (when (> (length Clipboard-Stack) Max-Stack)
      (set-cdr! (tail Clipboard-Stack (- Max-Stack 1)) '())))
  
  
  (method (pop-clipboard)
    (let ((string (car Clipboard-Stack)))
      (set! Clipboard-Stack (cdr Clipboard-Stack))
      (set-clipboard-text string)
      (update-focus-actions)
      string))
  
  
  (method public (cycle-clipboard)
    (let ((string (get-clipboard-text)))
      (let ((res (pop-clipboard)))
        (if (null? Clipboard-Stack)
            (set! Clipboard-Stack (list string))
          (set-cdr! (last-pair Clipboard-Stack) (list string)))
        res)))
  
  
  (method public (cycle-clipboard-reversed)
    (let ((string (get-clipboard-text)))
      (let ((res (last Clipboard-Stack)))
        (set! Clipboard-Stack (cons string (butlast Clipboard-Stack)))
        (set-clipboard-text res)
        res)))

  
  (method package (paste-cycle-stack reversed?)
    (let ((focus (get-focus)))
      (if (or (is-not? focus Text-View) (null? Clipboard-Stack))
          (bell)
        (let ((text (get-clipboard-text)))
          (if (not text)
              (bell)
            (let ((model (get-model~ focus)))
              (let ((expl (new (explorer-class~ focus) model)))
                (set-pos~ expl (get-start~ focus))
                (when (looking-back?~ expl text)
                  (backward-n~ expl (string-length text))
                  (delete-range~ model (get-range~ expl)))
                (insert-string~ focus (if reversed? (cycle-clipboard-reversed) (cycle-clipboard))))))))))
  
  
  (method package (on-copy-formatted evt)
    (let ((focus (get-focus)))
      (if (is-not? focus Text-View)
          (bell)
        (copy-formatted-selection~ focus))))
  
  
  (method package (on-paste-cycle-stack evt)
    (paste-cycle-stack #f))


  (method package (on-paste-cycle-stack-reversed evt)
    (paste-cycle-stack #t))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method package (on-add-history evt)
    (add-current~ history-manager))
  
  
  (method package (on-backward-history evt)
    (go-backward-history~ history-manager))
  
  
  (method package (on-forward-history evt)
    (go-forward-history~ history-manager))
  
  
  (method public (add-history item)
    (add-history~ history-manager item))
  
  
  (method override (current-history-item)
    (let ((frame (current-frame)))
      (when frame
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (current-history-item~ guest))))))
  
  
  (method override (update-history-actions)
    (let ((backward (get-backward-history~ history-manager))
          (forward (get-forward-history~ history-manager)))
      (set-action-enabled? {Action application backward-history} (not-null? backward))
      (set-action-enabled? {Action application forward-history} (not-null? forward))))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method public virtual (get-recorder)
    #f)
  
  
  (method package (macro-recording?)
    (let ((recorder (get-recorder)))
      (and recorder (get-recording?~ recorder))))
  
  
  (method package (macro-playing?)
    (let ((recorder (get-recorder)))
      (and recorder (get-playing?~ recorder))))

  
  ;;;
  ;;;; Templates
  ;;;
  
  
  (method protected virtual (templates-directory)
    )


  ;;;
  ;;;; Profile
  ;;;
  
  
  (method protected virtual (prepare-profile)
    (when (use-profile?)
      (install-profiles)
      (log-profile)))
  
  
  (method protected virtual (use-profile?)
    #f)
  
  
  (method protected virtual (use-profile-logging?)
    #f)
  
  
  (method protected virtual (install-profiles)
    )
  
  
  (method (log-profile)
    (define (install-profile name unit bindings)
      (let ((source (find-unit-source profile-class)))
        (when (not source)
          (install-new-profile name unit bindings)
          (set! source (find-unit-source profile-class)))
        (register-alias 'Profile (get-list~ (get-parent~ source)))))
    
    (define (install-new-profile name unit bindings)
      (let ((associations (list (cons 'jazz-settings-version (present-version jazz-settings-version))
                                (cons 'settings-version (present-version (settings-version)))
                                (cons 'profile name)
                                (cons 'profile-lowercase (downcase (symbol->string name)))
                                (cons 'profile-unit unit)
                                (cons 'profile-bindings (or bindings 'jazz))
                                (cons 'active-skin (case kernel-windowing ((carbon) 'mac) ((x11) 'x11) (else 'jazz))))))
        (copy-template (new-directory~ (templates-directory) "profile")
                       {Directory Home}
                       associations
                       non-expanded-nodes: '("catalogs")))
      (let ((repository (find-repository 'Profiles)))
        (let ((package-name unit)
              (package-path (concatenate (repository-library-directory repository) (format "{a}/.package" unit))))
          (repository-add-package repository (load-package repository #f package-name package-path)))))
    
    (define (login-profile)
      (receive (name unit bindings always-use?) (choose-profile-login)
        (let ((one-shoot? (shift-down?)))
          (when settings
            (unless one-shoot?
              (set-setting~ settings 'profile (if always-use? (->string name) #f)))
            (when (and always-use? (not one-shoot?) (not (get-setting~ settings 'profile-warned? #f)))
              (message-box (format "{a} will now always start using profile {a}. Note that you can always get this dialog back by keeping the shift key pressed when launching."
                                   (process-name)
                                   name))
              (set-setting~ settings 'profile-warned? #t))
            (save-content~ settings))
          (values name unit bindings))))
    
    (define (standard-profile title)
      (let ((name (string->symbol title))
            (unit-name (string->symbol (format "profile.{a}" (downcase title))))
            (bindings 'jazz))
        (values name unit-name bindings)))
    
    (define (system-profile)
      (values 'Me 'jazz.profile 'jazz)
      @convert
      (standard-profile (get-system-user-name)))
    
    (define (load-profile-jazzini)
      (let ((file {File Profile ".jazzini"}))
        (when (exists?~ file)
          (load (parse~ file)))))
    
    (define (profile-parameter)
      (let ((profile (string-parameter "profile" 'profile #f)))
        (when profile
          (capitalize (->string profile)))))
    
    (let ((use-logging? (use-profile-logging?)))
      (let ((profile-arg (and (or (not use-logging?) (not (shift-down?))) (or (jazz-profile) (profile-parameter)))))
        (receive (name unit bindings) (cond (profile-arg (standard-profile (->string profile-arg)))
                                            (use-logging? (login-profile))
                                            (else (system-profile)))
          (set! profile-class (compose-identifier unit name))
          (install-profile name unit bindings)
          (load-profile-jazzini)))))
  
  
  (method protected virtual (choose-profile-login)
    )


  ;;;
  ;;;; Closing
  ;;;
  
  
  (method override (preserve-environment)
    (nextmethod)
    (call-save-environment-listeners))
  
  
  (method override (close-environment)
    ;; called before closing frames because saving a class form
    ;; can potentialy modify an opened text
    (call-exit-listeners)
    (confirm-all-close)
    (close-all-no-confirm)
    (save-bindings)
    (save-workspaces)
    @wait
    (save-page-setup)
    (nextmethod))
  
  
  (method virtual (confirm-all-close)
    (define (frame-dependent-document? frame)
      (and (is? frame Host-View)
           (let ((guest (get-guest~ frame)))
             (and (is? guest Document)
                  (let ((controller (get-controller~ guest)))
                    (dependent-document?~ controller))))))
    
    (for-each (lambda (frame)
                (unless (frame-dependent-document? frame)
                  (confirm-close~ frame)))
              (all-frames include-invisibles?: #t)))
  
  
  (method (close-all)
    (for-each close-host~ (all-frames include-invisibles?: #t)))
  
  
  (method (close-all-no-confirm)
    (for-each (lambda (host)
                (close-host~ host confirm?: #f))
              (all-frames include-invisibles?: #t)))


  ;;;
  ;;;; Splash
  ;;;
  
  
  (definition Splash-Screen
    #f)
  
  (definition Splash-End
    #f)
  
  
  (method protected virtual (splash-screen)
    )
  
  
  (method (show-splash-screen (duration: duration #f))
    (set! Splash-Screen (show-splash))
    (set! Splash-End (and duration (+ (time->seconds (current-time)) duration))))
  
  
  (method (remove-splash-screen)
    (when Splash-Screen
      (let ((time (time->seconds (current-time))))
        (when (and Splash-End (> Splash-End time))
          (sleep (- Splash-End time)))
        (remove-splash Splash-Screen))))
  
  
  (method protected virtual (show-splash)
    )
  
  
  (method protected virtual (remove-splash splash-screen)
    )


  ;;;
  ;;;; Help
  ;;;
  
  
  (method package (on-about evt)
    (show-about))
  
  
  (method public virtual (show-about)
    (let ((name (process-name))
          (owner (process-owner))
          (copyright (process-copyright))
          (licensee (process-licensee))
          (version (present~ (process-version)))
          (email (process-email)))
      (message-box
        (append!
         (list
          (list (list font: {Font Text} color: {Color Dark-Blue} (format "{a} v{a}" name version)))
          (list))
         (if owner
             (list
               (list (list font: {Font Text} (format "Copyright {a}{a}" (if copyright (format "{a} " copyright) "") owner)))
               (list))
           '())
         (if licensee
             (list
               (list "This product is licensed to " (list licensee))
               (list))
           '())
         (if email
             (list
               (list "Send comments, suggestions, bugs,... to:")
               (list email))
           '()))
        title: (format "{a} {a}" (localize {Locales english: "About" french: "À propos de"}) name))))


  ;;;
  ;;;; Exit
  ;;;
  

  (slot exit-listeners initialize '())
  
  
  (method public (add-exit-listener listener)
    (set! exit-listeners (cons listener exit-listeners)))
  
  
  (method public (remove-exit-listener listener)
    (set! exit-listeners (remove! listener exit-listeners)))
  
  
  (method public (call-exit-listeners)
    (for-each prepare-exit~ exit-listeners))


  ;;;
  ;;;; Activation
  ;;;
  
  
  (method public virtual (deactivate)
    (when active?
      (close-popups~ toplevel)
      (reset-mouse-in)
      (set! active? #f)))
  
  
  (method public virtual (activate)
    (unless active?
      (set! active? #t)
      ;; Necessary because verify-reloads can pop a dialog
      (if (mouse-clicked?)
          (set-delayed-mouse-action
            (lambda ()
              (verify-reloads)))
        (verify-reloads))))
  
  
  (method public (verify-reloads)
    (define (collect-reloads)
      (collect (lambda (view)
                 (when (is? view Frame-Host)
                   (let ((guest (get-guest~ view)))
                     (when (is? guest Document)
                       (let ((controller (get-controller~ guest)))
                         (when (needs-reload?~ controller)
                           controller))))))
               (all-frames include-invisibles?: #t)))
    
    (let ((reloads (collect-reloads)))
      (when (not-null? reloads)
        (let ((code (message-box (format "Files have been modified. Do you want to reload them?")
                                 title: "File Status"
                                 type: 'question)))
          (for-each (lambda (controller)
                      (propose-reload-action~ controller code))
                    reloads)))))
  
  
  (method public (verify-reload moniker)
    (let ((frame (find-document moniker)))
      (when frame
        (let ((document (get-guest~ frame)))
          (verify-reload~ (get-controller~ document))))))


  ;;;
  ;;;; Environment
  ;;;
  

  (slot save-environment-listeners initialize '())
  
  
  (method public (add-save-environment-listener listener)
    (set! save-environment-listeners (cons listener save-environment-listeners)))
  
  
  (method public (remove-save-environment-listener listener)
    (set! save-environment-listeners (remove! listener save-environment-listeners)))
  
  
  (method public (call-save-environment-listeners)
    (for-each (lambda (listener)
                (save-environment~ listener))
              save-environment-listeners))
  
  
  ;;;
  ;;;; Session
  ;;;
  
  
  (method public (reload-session)
    (reload-opened-windows))
  
  
  (method public virtual (reload-opened-windows)
    )
  
  
  (method public virtual (reload-component class properties)
    )

  
  (method override (save-environment)
    (define (save-application)
      (let ((process-preferences (get-preferences-root)))
        (when process-preferences
          @convert/wait
          (set-preference process-preferences active-context: context)
          (set-preference process-preferences current-directory: (get-current-directory)))))
    
    (define (save-all-guest)
      @wait
      (for-each (lambda (frame)
                  (when (is? frame Host-Frame)
                    (let ((guest (get-guest~ frame)))
                      (when guest
                        (save-guest~ guest session-designer session)))))
                (all-frames include-invisibles?: #t)))
    
    (save-application)
    (save-all-guest))

  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method public virtual (display-aliases?)
    #t)
  
  
  (method public virtual (display-protocol?)
    #t)

  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (method (prepare-colors)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Colors.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (colors-domain))))))


  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method (prepare-fonts)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Fonts.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (fonts-domain))))))


  ;;;
  ;;;; Formats
  ;;;
  
  
  (method (prepare-formats)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Formats.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (formats-domain))))))


  ;;;
  ;;;; Styles
  ;;;
  
  
  (method (prepare-styles)
    (when (is-alias? 'Profile)
      (let ((file {File Profile "settings" "Styles.jml"}))
        (when (exists?~ file)
          (register-children~ (instantiate~ (read-form file)) (styles-domain))))))

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (add-focus-listener listener)
    (set! focus-listeners (add-listener listener focus-listeners)))
  
  
  (method public (remove-focus-listener listener)
    (set! focus-listeners (remove-listener listener focus-listeners)))

  
  (method package (process-focus-change new-focus)
    (when focus-listeners
      (let ((evt (new Focus-Event :focus-change self new-focus)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  focus-listeners)))
    (update-focus-actions))
  
  
  (method public virtual (update-focus-actions)
    (let* ((focus (get-focus))
           (view? (and focus (is? focus View))))
      (when preferences-designer
        (set-action-enabled? {Action view undo} (and view? (can-view-undo?~ focus)))
        (set-action-enabled? {Action view redo} (and view? (can-view-redo?~ focus)))
        (set-action-enabled? {Action view cut} (and view? (can-view-cut?~ focus)))
        (set-action-enabled? {Action view copy} (and view? (can-view-copy?~ focus)))
        (set-action-enabled? {Action application copy-formatted} (and view? (can-view-copy?~ focus)))
        (set-action-enabled? {Action view paste} (and view? (can-view-paste?~ focus)))
        (set-action-enabled? {Action application paste-cycle-stack} (and view? (can-view-paste?~ focus) (not-null? Clipboard-Stack)))
        (set-action-enabled? {Action application paste-cycle-stack-reversed} (and view? (can-view-paste?~ focus) (not-null? Clipboard-Stack)))
        (set-action-enabled? {Action view paste-properties} (and view? (can-view-paste-properties?~ focus)))
        (set-action-enabled? {Action view delete} (and view? (can-view-delete?~ focus)))
        (set-action-enabled? {Action view select-all} (and view? (can-view-select-all?~ focus)))
        (when view?
          (focus-update-actions~ focus)))))
  
  
  ;;;
  ;;;; Selected
  ;;;
  
  
  (method public (add-selected-listener listener)
    (set! selected-listeners (add-listener listener selected-listeners)))
  
  
  (method public (remove-selected-listener listener)
    (set! selected-listeners (remove-listener listener selected-listeners)))
  
  
  (method public (get-selected)
    selected)
  
  
  (method public (set-selected owner sel (force?: force? #f))
    (let ((new-owner? (neq? owner selected-owner)))
      (when (or force? new-owner? (neq? sel selected))
        (process-selected-change owner selected sel force?))))
  
  
  (method public (close-selected owner)
    (when (eq? owner selected-owner)
      (set! selected-owner #f)
      (process-selected-change #f selected #f #f)))

  
  (method (process-selected-change owner old-selected new-selected force?)
    (set! selected-owner owner)
    (set! selected new-selected)
    (when (and selected-listeners (not (exiting-process?)))
      (let ((evt (new Selected-Event :selected-change self owner old-selected new-selected force?: force?)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  selected-listeners))))

  
  ;;;
  ;;;; Application
  ;;;
  
  
  (method public (add-application-listener category listener)
    (set-application-listeners category (add-listener listener (get-application-listeners category))))
  
  
  (method public (remove-application-listener category listener)
    (set-application-listeners category (remove-listener listener (get-application-listeners category))))

  
  (method package (process-application-event category kind sender . properties)
    (let ((listeners (get-application-listeners category)))
      (let ((evt (apply new Application-Event kind sender properties)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (get-application-listeners category)
    (table-ref application-listeners category '()))
  
  
  (method (set-application-listeners category listeners)
    (table-set! application-listeners category listeners))

  
  ;;;
  ;;;; Frames
  ;;;
  
  
  (method public virtual (default-frame-class)
    #f)


  (method public virtual (file-frame-class file)
    (let ((extension (get-extension~ file)))
      (or (extension-frame-class extension)
          (error "Unknown file extension: {a}" extension))))


  (method public virtual (extension-frame-class ext)
    (or (profile-extension-frame-class ext)
        (known-extension-frame-class ext)
        (unknown-extension-frame-class)))
  
  
  (method (profile-extension-frame-class ext)
    (when profile
      (extension-frame-class~ profile ext)))


  (method public virtual (known-extension-frame-class ext)
    #f)
  
  
  (method public virtual (unknown-extension-frame-class)
    #f)


  (method public virtual (frame-class (file: file #f))
    (if (not file)
        (default-frame-class)
      (file-frame-class file)))
  
  
  (method (get-default-frame-class)
    (let* ((pref (get-workspace-preferences))
           (model (get-frame-model~ pref)))
      (if model
          (resolve-reference~ model)
        (default-frame-class))))

  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (initialize-toplevel)
    (set! toplevel (new-toplevel))
    (ensure-displayed~ toplevel))
  
  
  (method public virtual (new-toplevel)
    (new Toplevel))
  
  
  (method public virtual (show-toplevel)
    (define (setup-stage)
      (let ((stage (current-stage)))
        (when stage
          (case (get-setting 'jazz.ui.stage-state #f)
            ((restored) (restore~ stage))
            ((maximized) (maximize~ stage))))))
    
    (setup-stage)
    (set-visible?~ toplevel #t))
  
  
  (method (initialize-actions)
    (set-application-actions (get-class-actions self)))

  
  ;;;
  ;;;; Stage
  ;;;
  
  
  (method public virtual (new-stage)
    (new (stage-class) parent: (new Stage-Border) name: 'stage))
  
  
  (method protected virtual (stage-class)
    Stage)
  
  
  ;;;
  ;;;; Shortcuts
  ;;;
  
  
  (method (setup-shortcuts)
    (set! shortcut-table (make-table test: shortcut=? hash: shortcut-hash)))
      
  
  (method (register-actions-shortcuts old-actions new-actions)
    (define (unregister-shortcut action-item shortcut)
      ;; the second test is necessary because bindings can be changed on-the-fly in the ide
      (when (and shortcut (table-ref shortcut-table shortcut #f))
        (table-remove! shortcut-table shortcut action-item)))
    
    (define (register-shortcut action-item shortcut)
      (when shortcut
        (table-add shortcut-table shortcut action-item)))
    
    (when shortcut-table
      (for-each (lambda (actions)
                  (for-each (lambda (action-item)
                              (when (get-visible?~ action-item)
                                (unregister-shortcut action-item (get-shortcut~ action-item))
                                (unregister-shortcut action-item (get-alternate-shortcut~ action-item))))
                            (get-children~ actions)))
                old-actions)
      (for-each-reversed (lambda (actions)
                           (for-each (lambda (action-item)
                                       (when (get-visible?~ action-item)
                                         (register-shortcut action-item (get-shortcut~ action-item))
                                         (register-shortcut action-item (get-alternate-shortcut~ action-item))))
                                     (get-children~ actions)))
                         new-actions)))
  
  
  (method public (update-shortcut action-item old-shortcut new-shortcut)
    (when old-shortcut
      (table-remove! shortcut-table old-shortcut action-item))
    (when new-shortcut
      (table-add shortcut-table new-shortcut action-item)))
  
  
  (method public (dispatch-shortcut shortcut)
    (if (or (not shortcut-hook)
            (not (shortcut-hook shortcut)))
        (let ((action-items (get-allowed-actions shortcut)))
          (when (not-null? action-items)
            (let ((action (car action-items)))
              (when (action-allowed? action)
                (invoke~ action self #f)
                #t))))
      #t))
  
  
  (method public (get-bound-actions shortcut)
    (table-ref shortcut-table shortcut '()))
  
  
  (method public (get-allowed-actions shortcut)
    (define (filter-allowed actions)
      (collect-if action-allowed? actions))
    
    (let ((actions (get-bound-actions shortcut)))
      ;; This temporary test is because I am not sure it is what we want in general
      ;; It could be very surprising to do a shortcut that's supposed to do nothing
      ;; as it's disabled and find out that something completly different happened!
      (if (shortcut=? shortcut {Shortcut :control #\X})
          (filter-allowed actions)
        actions)))
  
  
  (method public (action-allowed? action-item)
    (define (some-actionable-active?)
      (some? (lambda (actionable)
               (and (get-enabled?~ actionable)
                    (actionable-reachable?~ actionable)))
             (get-actionables~ action-item)))
    
    ;; maybe we shouldn't even use the action-item's enabled? property
    (and (get-enabled?~ action-item)
         (or (not (actions-orphaned?~ (get-parent~ action-item)))
             (allow-orphaned-actions?)
             (some-actionable-active?))))
  
  
  ;; quick solution. probably better would be some way for applications like an IDE
  ;; to register those orphaned actions somewhere user accessible
  (method protected virtual (allow-orphaned-actions?)
    #f)
  
  
  ;;;
  ;;;; Bindings
  ;;;
  
  
  (definition Bindings-File
    {File Profile "settings" "Bindings.jml"})
  
  
  (method (install-bindings)
    (define (set-bindings/designer bindings)
      (set-bindings bindings)
      (set! bindings-designer (new Designer form: (get-form~ bindings) reference: bindings)))
    
    (with-safe-execution "loading the bindings"
      (lambda ()
        (let ((bindings (load-bindings)))
          (set-bindings/designer bindings)
          (let ((active (or (get-active-bindings~ (get-preferences #f)) 'jazz)))
            (let ((trait (locate-component~ bindings active)))
              (when (is? trait Trait)
                (set-active-trait~ bindings trait))))))
      continue-handler:
      (lambda (err)
        (set-bindings/designer (default-bindings)))))
  
  
  (method protected virtual (load-bindings)
    (let ((file Bindings-File))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-bindings))))
  
  
  (method protected virtual (default-bindings)
    (new Application-Bindings))
  
  
  (method (save-bindings)
    (when (and bindings-designer (get-modified?~ bindings-designer) (file? (get-origin~ (get-form~ bindings-designer))))
      (save~ bindings-designer)))
    
  
  ;;;
  ;;;; Skins
  ;;;
  
  
  (method (prepare-skins)
    (let ((skins (default-skins)))
      (set-skin (child~ skins (default-skin)))))
  
  
  (method (install-skins)
    (with-safe-execution "loading the skins"
      (lambda ()
        (let ((skins (load-skins)))
          (set-skins-designer skins)
          (set-skin (child~ skins (or (get-active~ skins) (default-skin))))))
      continue-handler:
      (lambda (err)
        (let ((skins (default-skins)))
          (set-skins-designer skins)
          (set-skin (child~ skins (default-skin)))))))
  
  
  (method protected virtual (default-skin)
    (get-setting 'jazz.ui.skin 'jazz))
  
  
  (method protected virtual (skins-file)
    {File Profile "settings" "Skins.jml"})
  
  
  (method protected virtual (load-skins)
    (let ((file (skins-file)))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-skins))))
  
  
  (method protected virtual (default-skins)
    (instantiate~
      (<form>
        (<Skins>
          (<Default-Skin> name: default)
          (<Jazz-Skin>    name: jazz)
          (<Windows-Skin> name: windows)))))
  
  
  (method protected (set-skins-designer skins)
    (set! skins-designer (new Designer form: (get-form~ skins) reference: skins)))
  
  
  (method (save-skins)
    (when (and skins-designer (get-modified?~ skins-designer) (file? (get-origin~ (get-form~ skins-designer))))
      (save~ skins-designer)))

  
  ;;;
  ;;;; Workspaces
  ;;;
  
  
  (definition Workspaces-File
    {File Profile "settings" "Workspaces.jml"})
  
  
  (method (install-workspaces)
    (define (set-workspaces-designer workspaces)
      (set! workspaces-designer (new Designer form: (get-form~ workspaces) reference: workspaces)))
    
    (with-safe-execution "loading the workspaces"
      (lambda ()
        (set-workspaces-designer (load-workspaces)))
      continue-handler:
      (lambda (err)
        (set-workspaces-designer (default-workspaces)))))
  
  
  (method protected virtual (load-workspaces)
    (let ((file Workspaces-File))
      (if (and (is-alias? 'Profile) (exists?~ file))
          (instantiate~ (read-form file))
        (default-workspaces))))
  
  
  (method protected virtual (default-workspaces)
    (instantiate~
      (<form>
        (<Workspaces-Preferences>))))
  
  
  (method (save-workspaces)
    (when (and workspaces-designer (get-modified?~ workspaces-designer) (file? (get-origin~ (get-form~ workspaces-designer))))
      (save~ workspaces-designer)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method public (set-application-actions actions-list)
    (register-actions-shortcuts application-actions actions-list)
    (set! application-actions actions-list))
  
  
  (method public (set-profile-actions actions-list)
    (register-actions-shortcuts profile-actions actions-list)
    (set! profile-actions actions-list))


  (method public (set-guest-actions actions-list)
    (register-actions-shortcuts guest-actions actions-list)
    (set! guest-actions actions-list))
  
  
  (method public (set-focus-actions actions-list)
    (register-actions-shortcuts focus-actions actions-list)
    (set! focus-actions actions-list))

  
  ;;;
  ;;;; Menubar
  ;;;


  (method public (find-menubar)
    (let ((host (get-toolbar :menubar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (find-menu name)
    (let ((menubar (find-menubar)))
      (when menubar
        (let ((menuitem (find-component~ menubar name)))
          (when menuitem
            (get-content~ menuitem))))))
  
  
  (method public (update-menubar-buttons)
    (let ((menubar (find-menubar)))
      (when menubar
        (update-buttons~ menubar))))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (definition Undisplayed-Message
    #f)


  (method public (set-status-message msg action-handler update?)
    (let ((message (get-message-view)))
      (if (not message)
          (set! Undisplayed-Message msg)
        (set! Undisplayed-Message #f)
        (post-event
          (lambda ()
            (set-title~ message (cond ((not msg) "")
                                      ((is? msg Locales) msg)
                                      (else (->string msg))))
            (set-action-handler~ message action-handler)))
        (when (and update? (primordial-thread?))
          (update-view~ message)))))


  (method public (find-status-bar)
    (let ((host (get-toolbar :status)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (get-message-view)
    (let ((status-bar (find-status-bar)))
      (when status-bar
        (find-component~ status-bar 'message))))
  
  
  (method public (show-undisplayed-message)
    (when Undisplayed-Message
      (set-status-message Undisplayed-Message #f #f)
      (set! Undisplayed-Message #f)))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (class-actions)
    (cons (find-actions 'application)
          (nextmethod)))


  ;;;
  ;;;; Alias
  ;;;
  
  
  (method override (process-alias name)
    (case name
      ((:application) self)
      ((:toplevel)    (get-toplevel))
      ((:menubar)     (find-menubar))
      ((:toolbar)     (find-toolbar))
      ((:status-bar)  (find-status-bar))
      ((:stage)       (current-stage))
      ((:frame)       (current-frame))
      ((:document)    (current-document))
      ((:focus)       (get-focus))
      ((:focus-host)  (focused-host))
      ((:focus-guest) (focused-guest))
      ((:profile)     (get-profile))
      ((:images)      (get-images-portfolio))
      ((:bindings)    (get-bindings))
      (else (cond ((and (pair? name) (eq? (car name) :menu)) (find-menu (cadr name)))
                  (else (nextmethod name))))))
  
  
  ;;;
  ;;;; Menus
  ;;;
  
  
  (method public virtual (text-menu text)
    (new-text-context-menu~ text))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public virtual (get-output-log)
    #f)
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (definition All-Results
    #f)
  
  (definition Active-Results
    #f)
  
  
  (method public virtual (navigable-results)
    (must-implement 'navigable-results "results navigation"))
  
  
  (method (get-navigable-results)
    (unless All-Results
      (set! All-Results (navigable-results)))
    All-Results)
  
  
  (method public (get-active-results)
    (unless Active-Results
      (set! Active-Results (car (get-navigable-results))))
    Active-Results)
  
  
  (method public (set-active-results results)
    (set! Active-Results results))
  
  
  ;;;
  ;;;; Locales
  ;;;
  
  
  (method (locale-change loc update?)
    (select-locale loc)
    (when update?
      (locale-update)))


  (method public (select-locale locale)
    (let ((status (find-status-bar)))
      (when status
        (let ((label (locate-component~ status 'locales)))
          (when label
            (set-title~ label (localize (present-locale locale))))))))
  
  
  (method public (locale-update)
    (define (update-menubar)
      (let ((menubar (find-menubar)))
        (layout-menu~ menubar)
        (for-each (lambda (child)
                    (when (is? child Label-Item)
                      (let ((content (get-content~ child)))
                        (when (is? content Menu)
                          (layout-menu~ content)))))
                  (get-children~ menubar))))
    
    (define (update-toplevel)
      (let ((toplevel (get-toplevel)))
        (invalidate-title~ toplevel)
        (redraw-window~ toplevel)))
    
    ;; All this should of course be event based but it will do for now...
    (update-menubar)
    (update-toplevel))
  
  
  ;;;
  ;;;; Workspace
  ;;;
  
  
  (method (setup-workspaces)
    (let ((preferences (get-workspaces-preferences)))
      (case (length (get-children~ preferences))
        ((0) (error "No workspaces found in Preferences.jml"))
        ((1))
        (else
         (let ((menu (find-menu 'workspace)))
           (when menu
             (let ((actions (find-actions 'application))
                   (toolbar (find-toolbar))
                   (active (get-active~ preferences)))
               (for-each (lambda (workspace)
                           (let ((name (get-name~ workspace))
                                 (title (get-title~ workspace))
                                 (icon (get-icon~ workspace)))
                             (let ((action-name (string->symbol (format "select-{a}-workspace" name)))
                                   (event-handler (new Event-Handler target-name: :application method-name: 'on-select-workspace properties: (list workspace: name)))
                                   (selected? (eq? name active)))
                               (new Action-Item parent: actions name: action-name action-handler: event-handler shortcut: (get-shortcut~ workspace))
                               (new Radio-Item parent: menu name: (get-name~ workspace) title: title icon: icon before: 'layout-separator group: 'workspace selected?: selected? action-handler: (new Action 'application action-name '()))
                               (new Workspace-Button parent: toolbar name: name size: {Dimension 22 22} location: 'tail before: 'tail-separator group: 'workspace resource: icon portfolio: :images selected?: selected? tooltip?: #t tooltip-text: title action-handler: event-handler)
                               (new Separator parent: toolbar size: {Dimension 1 0} location: 'tail before: 'tail-separator))))
                         (get-children~ preferences))
               (layout-menu~ menu)
               (layout~ toolbar))))))))
  
  
  (method (select-default-workspace)
    (define (find-workspace)
      (let ((pref (get-workspaces-preferences error?: #f)))
        (if (not pref)
            (default-workspace)
          (let ((active (get-active~ pref)))
            (if (not active)
                (default-workspace)
              (child~ pref active))))))
    
    (define (default-workspace)
      (new Default-Workspace))
    
    (apply-preferences~ (find-workspace)))
  
  
  (method package (on-select-workspace evt)
    (select-workspace (get-property~ evt workspace:)))
  
  
  (method package (on-next-workspace evt)
    (select-next-workspace))
  
  
  (method package (on-previous-workspace evt)
    (select-previous-workspace))
  
  
  (method package virtual (on-workspace evt)
    (case (get-kind~ evt)
      ((activate)
       (let ((workspace (get-property~ evt workspace:)))
         (activate-workspace-item workspace)
         (activate-workspace-button workspace)))))
  
  
  (method public undocumented (activate-workspace-item workspace)
    (let ((menu (find-menu 'workspace)))
      (when menu
        (let ((radio (find-component~ menu (get-name~ workspace))))
          (if (not radio)
              (unselect-elements~ menu class: Radio-Item group: 'workspace)
            (set-selected?~ radio #t))))))
  
  
  (method public undocumented (activate-workspace-button workspace)
    (let ((toolbar (find-toolbar))
          (name (workspace-button-name workspace)))
      (when (and toolbar name)
        (let ((radio (find-component~ toolbar name)))
          (if (not radio)
              (unselect-elements~ toolbar class: Radio-Tool group: 'workspace)
            (set-selected?~ radio #t))))))
  
  
  (method public virtual undocumented (workspace-button-name workspace)
    (get-name~ workspace))
  
  
  (method public virtual (workspace-installed)
    )
  
  
  (method package (on-zoom-horizontally evt)
    (with-locked-update
      (lambda ()
        (let ((started? #f))
          (continuation-capture
            (lambda (return)
              (for-each-splitter (current-stage-border)
                (lambda (splitter host)
                  (if (eq? (get-orientation~ splitter) 'vert)
                      (when started?
                        (continuation-return return))
                    (if (eq? (get-state~ splitter) 'split)
                        (if (workspace-zoomable?~ splitter host)
                            (zoom~ splitter host)
                          (continuation-return return))
                      (unzoom~ splitter))
                    (set! started? #t))))))))))
  
  
  (method package (on-zoom-vertically evt)
    (with-locked-update
      (lambda ()
        (let ((started? #f)
              (border (current-stage-border)))
          (continuation-capture
            (lambda (return)
              (for-each-splitter border
                (lambda (splitter host)
                  (if (eq? (get-orientation~ splitter) 'horz)
                      (when started?
                        (continuation-return return))
                    (if (eq? (get-state~ splitter) 'split)
                        (zoom~ splitter host)
                      (unzoom~ splitter))
                    (set! started? #t))
                  (when (eq? host border)
                    (continuation-return return))))))))))
  
  
  (method package (on-maximize/restore evt)
    (let ((stage (current-stage)))
      (if (get-maximized?~ stage)
          (restore~ stage)
        (maximize~ stage))))
  
  
  (method package (on-full-screen evt)
    (let ((pref (get-preferences #f)))
      (when (not (get-fullscreen-warned?~ pref))
        (message-box "Warning: There is currently only one way of exiting the fullscreen mode which is by using the Alt-Shift Backspace shortcut for Full Screen toggle")
        (set-property~ preferences-designer pref 'fullscreen-warned? #t)))
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (set-fullscreen?~ (selected-workspace) fullscreen?)
      (full-screen-stage fullscreen?)))
  
  
  (method public (full-screen-stage fullscreen?)
    (full-screen (current-stage-border) fullscreen?))
  
  
  (method public (toggle-full-screen host)
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (full-screen host fullscreen?)))
  
  
  (method public (full-screen host fullscreen?)
    (define (fix-top-splitter-insets splitter)
      (if (not fullscreen?)
          (let ((preserved (get-preserved-insets~ splitter)))
            (when preserved
              (set-preserved-insets~ splitter #f)
              (set-insets~ splitter preserved)))
        (set-preserved-insets~ splitter (get-insets~ splitter))
        (set-insets~ splitter {Rect 0 0 0 0})))
    
    (let ((toplevel (get-toplevel))
          (stage (current-stage)))
      (when (neq? fullscreen? (get-fullscreen?~ toplevel))
        (with-locked-update
          (lambda ()
            (set-fullscreen?~ toplevel fullscreen?)
            (when stage
              (set-fullscreen?~ stage fullscreen?))
            (for-each-splitter host
              (lambda (splitter host)
                (let ((preferences (get-preferences~ splitter)))
                  (when (and preferences (eq? (get-name~ preferences) 'top))
                    (fix-top-splitter-insets splitter)))
                (set-full?~ splitter fullscreen?)
                (if fullscreen?
                    (zoom~ splitter host)
                  (unzoom~ splitter)))))))))
  
  
  (method public (on-delete-stage evt)
    (delete-stage))
  
  
  (method public (on-delete-other-stages evt)
    (delete-other-stages))
  
  
  (method public (on-split-vertically evt)
    (split-stage-vertically))
  
  
  (method public (on-split-horizontally evt)
    (split-stage-horizontally))
  
  
  (method public (on-move-frame evt)
    (move-frame))
  
  
  (method public (on-clone-frame evt)
    (clone-frame))


  ;;;
  ;;;; Toolbar
  ;;;
  
  
  (method public (find-toolbar)
    (let ((host (get-toolbar :toolbar)))
      (when (and host (in-player?~ host))
        (get-guest~ host))))
  
  
  (method public (find-command-toolbar)
    (define (try name)
      (let ((host (get-toolbar name)))
        (when (and host (in-player?~ host))
          (get-guest~ host))))
    
    (or (try :command)
        (try :minibuffer)
        (try :toolbar)))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (get-context-text)
    #f)
   
  
  ;;;
  ;;;; Classes
  ;;;
  
  
  (method public virtual (get-text-class)
    Plain-Text-View)


  ;;;
  ;;;; Resources
  ;;;
  
  
  (method public (get-resource type name)
    (define (resources-dir)
      (if (is-alias? 'Jazz)
          {Directory Jazz "lib" "jazz.resources" "resources"}
        {Directory Build "lib" "jazz.resources" "resources"}))
    
    (case type
      ((image) (new-file~ (resources-dir) (list "images" (format "{a}.png" name))))
      ((cursor) (new-file~ (resources-dir) (list "cursors" (format "{a}.cur" name))))))


  ;;;
  ;;;; Images
  ;;;
  
  
  (definition Images-Portfolio
    #f)
  
  
  (method public (get-images-portfolio)
    (unless Images-Portfolio
      (set! Images-Portfolio (new Portfolio name: :images)))
    Images-Portfolio)


  ;;;
  ;;;; Catalog
  ;;;


  (method public virtual (get-cataloguer)
    #f)


  ;;;
  ;;;; Events
  ;;;
  

  (method override (get-event-consumer)
    event-consumer)
  
  
  (method override (set-event-consumer consumer)
    (set! event-consumer consumer))


  (method override (deliver-event handler target proc event)
    (proc target event))


  ;;;
  ;;;; Debug
  ;;;
  
  
  (method override (process-debuggee-loop)
    (if (and (local-proxy? (get-controller-debugger))
             (event-thread?))
        (with-jazz-exception-debugger
          process-events)
      (nextmethod)))


  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method (exception-reported)
    ;; so as not to get recursive exceptions
    (catch Exception
      (cleanup-mouse-processing)))
  
  
  @convert
  (method (present-execution-context exception type prefix?)
    (present~ (new Exception-Presenter) exception type: type prefix?: prefix?))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual undocumented (get-search-manager)
    #f)
  
  
  (method public virtual undocumented (get-search-results)
    (get-guest~ (singleton-docked Search-Results #f)))
  
  
  (method public (active-search-view)
    (let ((manager (get-search-manager)))
      (when manager
        (get-search~ manager))))
  
  
  ;; This needs cleanup as it cannot be done for every application
  (method public (update-search-actions)
    (let* ((document (current-document))
           (result (active-search-result))
           (results (get-search-results))
           (resultset (get-current-resultset~ results))
           (results-count (get-visible-count~ (get-tree~ results))))
      (set-action-enabled? {Action application find-forward} (and result document))
      (set-action-enabled? {Action application find-backward} (and result document))
      (set-action-enabled? {Action application replace} (and result document))
      (set-action-enabled? {Action application replace&find-forward} (and result document))
      (set-action-enabled? {Action application replace-all} (and result document))
      (set-action-enabled? {Action application edit-next} (>= results-count 1))
      (set-action-enabled? {Action application edit-previous} (>= results-count 1))
      (set-action-enabled? {Action application edit-current} (>= results-count 1))
      (set-action-enabled? {Action application replace-selected} (>= results-count 1))
      (set-action-enabled? {Action application previous-search} (and result resultset))))


  ;;;
  ;;;; Search Menu
  ;;;
  
  
  (method package (on-find evt)
    (update-search 'text domain: 'window))
  
  
  (method package (on-find-in-text evt)
    (update-search 'text))
  
  
  (method package (on-find-in-projects evt)
    (update-search 'projects))
  
  
  (method package (on-find-in-directories evt)
    (update-search 'directories))
  
  
  (method package (on-find-in-user evt)
    (update-search 'user))
  
  
  (method (update-search tab (domain: domain #f) (selector: selector #f))
    (let* ((focus (get-focus))
           (internal? (is? focus Tree-Embedded-Search-Text-View))
           (strings (and (not internal?) (is? focus Text-View) (get-selected-strings~ focus)))
           (string (and strings (= (length strings) 1) (car strings)))
           (manager (get-search-manager))
           (palette (get-host~ manager))
           (player (get-player~ palette))
           (tab-view (locate~ manager 'tab))
           (same-tab? (eq? tab (get-selection-name~ tab-view))))
      (if (and (not domain)
               (eq? (get-focused-window) player)
               same-tab?)
          (next-radio~ (get-search~ manager))
        (when tab
          (set-selection-name~ tab-view tab)
          (when domain
            (set-search-domain~ (get-search~ manager) domain))))
      (for-each (lambda (search)
                  (let ((targets (get-search-targets~ search)))
                    (unless (or (not string)
                                (and (not-null? targets)
                                     (equal? string (first (first targets)))))
                      (set-search-targets~ search (list (list string ""))))))
                (get-searches~ manager))
      (when (or (not internal?) (not same-tab?))
        (select-search~ (get-search~ manager)))
      (when selector
        (selector (get-search~ manager)))
      (bring-to-front~ player)
      (set-visible?~ player #t)))
  
  
  (method public (end-search-edition)
    (let ((tree (get-targets~ (get-search~ (get-search-manager)))))
      (end-edition~ tree)))


  (method package (on-edit-next evt)
    (edit-next~ (get-active-results)))


  (method package (on-edit-previous evt)
    (edit-previous~ (get-active-results)))


  (method package (on-edit-current evt)
    (edit-current~ (get-active-results)))


  (method package (on-find-forward evt)
    (let ((result (active-search-result)))
      (if result
          (if (find-forward~ result follow?: #f)
              (acquire-focus~ (effective-client~ result))
            (unless (follow-forward~ result)
              (bell)))
        (bell))))


  (method package (on-find-backward evt)
    (let ((result (active-search-result)))
      (if result
          (if (find-backward~ result follow?: #f)
              (acquire-focus~ (effective-client~ result))
            (unless (follow-backward~ result)
              (bell)))
        (bell))))


  (method package (on-replace evt)
    (let ((result (active-search-result)))
      (unless (and result (replace-selection~ result))
        (bell))))


  (method package (on-replace&find-forward evt)
    (let ((result (active-search-result)))
      (unless (and result (replace-selection&find-forward~ result))
        (bell))))


  (method package (on-replace-all evt)
    (let ((result (active-search-result)))
      (if (not result)
          (bell)
        (replace-all~ result))))
  
  
  (method package (on-replace-selected evt)
    (replace-selected~ (get-search-results)))


  (method package (on-previous-search evt)
    (let ((result (active-search-result))
          (results (get-search-results)))
      (let ((resultset (get-current-resultset~ results)))
        (if (eq? (get-current-resultset~ results) (get-resultset~ result))
            (pop-resultset~ results)
          (set-active-search-result (new Search-Result resultset))))))

  
  ;;;
  ;;;; Command Shell
  ;;;
  
  
  (method package (on-command-extended evt)
    (select-command-extended))
  
  
  (method package (on-command-execute evt)
    (select-command-execute))
  
  
  (method public virtual (get-command-shell)
    (let ((toolbar (find-command-toolbar)))
      (when toolbar
        (locate-component~ toolbar 'command-shell))))
  
  
  (method public virtual (get-command-text)
    (let ((shell (get-command-shell)))
      (when shell
        (get-text~ shell))))
  
  
  (method public (require-command-text)
    (or (get-command-text)
        (begin
          (message-box "This workspace doesn't contain a command text")
          (throw-cancel))))
  
  
  (method public (require-unzoomed-command-text)
    (define (unzoom text)
      (let ((host (get-host~ text)))
        (let ((splitter (get-parent~ host)))
          (when (is? splitter Splitter-View)
            (when (eq? (get-state~ splitter) 'zoom)
              (let ((target (get-target~ splitter)))
                (when (neq? target host)
                  (unzoom~ splitter)
                  (set-client-restore~ text
                    (lambda ()
                      (when (in-player?~ splitter)
                        (zoom~ splitter target)))))))))))
    
    (let ((text (require-command-text)))
      (unzoom text)
      text))
  
  
  (method public (select-command-search direction initial)
    (select-search~ (require-unzoomed-command-text) direction #f initial again?: #t))
  
  
  (method public (select-command-search-current direction range initial)
    (select-search~ (require-unzoomed-command-text) direction range initial again?: #f))
  
  
  (method public (select-command-highlight direction range search-result client (highlight?: highlight? #f))
    (select-search~ (require-unzoomed-command-text) direction range #f search-result: search-result client: client highlight?: highlight? again?: #f))
  
  
  (method public (select-command-extended)
    (select-extended~ (require-unzoomed-command-text)))
  
  
  (method public (select-command-execute)
    (select-execute~ (require-unzoomed-command-text)))


  ;;;
  ;;;; Files
  ;;;


  (method package virtual (on-new evt)
    (new-event~ (get-default-frame-class)))
    

  (method package virtual (on-open evt)
    (open-files))
  
  
  (method public (open-files (directory: directory #f))
    (let ((files (choose-file directory: directory extensions: (open-extensions) multiple-selection?: #t)))
      (for-each edit-file
                (sort string>? files key: get-name~))))
  
  
  (method public virtual (receive-files pos pathnames)
    (if (and (= (length pathnames) 1) (directory? (car pathnames)))
        (let ((dir (car pathnames)))
          (set-current-directory dir)
          (user-message "Current directory set to {a}" (parse~ dir)))
      (let ((class (cond ((alt-down?) jazz.editor.jazz:Jazz-Plain-Text-View)
                         ((shift-down?) jazz.editor.jazz:Jazz-Text-View)
                         (else #f))))
        (for-each (lambda (pathname)
                    (when (file? pathname)
                      (if class
                          (edit-document pathname class: class)
                        (edit-file pathname))))
                  pathnames))))
  
  
  (method public virtual (edit-file file)
    (edit-document file))
  
  
  ;; a quicky... this should really be up to the current workspace
  (method public virtual (open-extensions)
    #f)


  (method public (find-document moniker (class: class #f))
    (find-frame-if-guest
      (lambda (guest)
        (and (is? guest Document)
             (or (not class) (is? guest class))
             (let ((guest-moniker (get-moniker~ (get-controller~ guest))))
               (and guest-moniker
                    (pathname=? guest-moniker moniker)))))))
  
  
  (method public (edit-document moniker
                                (class: class #f)
                                (kind: kind #f)
                                (workspace: workspace #f)
                                (selection: selection #f)
                                (char-encoding: char-encoding #f)
                                (wrap?: wrap? #f)
                                (force-new?: force-new? #f)
                                (visible?: visible? #t)
                                (activate-focus?: activate-focus? #t)
                                (return-new?: return-new? #f))
    (when moniker
      (if (not (exists?~ moniker))
          (error "Unable to locate document: {t}" moniker)
        (let ((file moniker))
          (let* ((frame (if force-new? #f (find-document file class: class)))
                 (result (lambda (frame new?) (if return-new? (values frame new?) frame))))
            (if (not frame)
                (let ((class (or class (file-frame-class file))))
                  (with-cursor :wait
                    (lambda ()
                      (result (new-frame class
                                         kind: kind
                                         host-workspace: workspace
                                         host-visible?: visible?
                                         host-focus?: activate-focus?
                                         initialize: (lambda (host document)
                                                       (let ((text? (is? document Text-View)))
                                                         (when text?
                                                           (set-char-encoding~ (get-model~ document) char-encoding))
                                                         (set-moniker~ (get-controller~ document) moniker)
                                                         (when text?
                                                           (when wrap?
                                                             (set-wrap?~ (get-model~ document) #t))
                                                           (when selection
                                                             (end-completion~ document)
                                                             (set-selection-safe~ document selection ensure-displayed?: 'center-caret))))))
                              #t))))
              (when selection
                (let ((document (get-guest~ frame)))
                  (end-completion~ document)
                  (set-selection-safe~ document selection ensure-displayed?: #f)
                  (ensure-displayed~ document force-vertical: 'head)))
              (when (and visible? activate-focus?)
                (focus-host~ frame))
              (verify-reload~ (get-controller~ (get-guest~ frame)))
              (result frame #f)))))))
  
  
  (method public (edit-help-document moniker)
    (let* ((frame (edit-document moniker))
           (text (get-guest~ frame)))
      (set-editable?~ text #f)))
  
  
  (method public (edit-filename filename)
    (let* ((workbench (get-service 'workbench))
           (project-file (and workbench (find-filename~ workbench filename))))
      (if (not project-file)
          (error "Unable to locate filename: {t}" filename)
        (let* ((frame (edit-document (get-source~ project-file)))
               (text (get-guest~ frame)))
          (verify-reload~ (get-controller~ text))))))
  
  
  (method public virtual (edit-category name)
    )
  
  
  (method package virtual (on-close evt)
    (let ((frame (front-frame)))
      (when frame
        (close-host~ frame))))

  
  (method package virtual (on-close-all evt)
    (for-each (lambda (view)
                (when (is? view Frame-Host)
                  (let ((guest (get-guest~ view)))
                    (when (or (is-not? guest Document) (close-on-close-all?~ (get-controller~ guest)))
                      (confirm-close~ view)
                      (close-host~ view)))))
              (all-frames)))
        
    
  (method package virtual (on-save-all evt)
    (save-all))
  
  
  (method package virtual (on-print evt)
    (let ((guest (current-guest)))
      (print-document~ guest)))

   
  (method package virtual (on-print-layout evt)
    (let ((guest (current-guest)))
      (print-layout~ guest)))

  
  (method package virtual (on-print-preview evt)
    (let ((guest (current-guest)))
      (print-preview~ guest)))
  
  
  (method package virtual (on-quit-application evt)
    (exit-process))
  
  
  (method public (save-all (class: class Document) (save-unanchored?: save-unanchored? #t))
    (let ((save-documents
            (lambda (main-documents?)
              (for-each (lambda (host)
                          (when (is? host Frame-Host)
                            (let ((guest (get-guest~ host)))
                              (when (is? guest Document)
                                (let ((controller (get-controller~ guest)))
                                  (when (and (is? guest class)
                                             (or save-unanchored? (get-moniker~ guest))
                                             (xor main-documents? (dependent-document?~ controller))
                                             (get-modified?~ (get-controller~ guest)))
                                    (save~ guest)))))))
                        (all-frames include-invisibles?: #t)))))
      ;; saving dependent documents will make their main document modified
      (save-documents #f)
      (save-documents #t)))


  ;;;
  ;;;; Definitions
  ;;;

  
  (method public virtual (edit-definitions object . rest)
    )

  
  (method public virtual (edit-references object . rest)
    )


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (context-update)
    (define (modify-profile)
      (when profile
        (close~ profile))
      (let ((pref (get-preferences #f error?: #f)))
        (when pref
          (let ((class-unit (or (get-profile-class~ pref) Profile)))
            (when class-unit
              (set! profile (new (load-profile-class class-unit)))))))
      (when profile
        (init~ profile))
      (when profile
        (finalize~ profile)))
    
    (nextmethod)
    (modify-profile)
    (user-message "Context set to {a}" context))

  
  ;;;
  ;;;; Preferences
  ;;;
  
  
  (method override (setup-preferences)
    (with-safe-execution "loading the preferences"
      (lambda ()
        (setup-preferences/designer))
      continue-handler:
      (lambda (err)
        (set-preferences/designer (default-preferences)))))
  
  
  (method override (default-preferences)
    (new Application-Preferences))
  
  
  (method protected virtual (toolbox-file toolbox)
    (new-file~ {Directory Profile "settings"}
      (or toolbox "Toolbox.jml")))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (definition Default-Page-Setup
    #f)
  
  (definition Default-Page-Setup-Designer
    #f)
  
  (definition Default-Page-Setup-Form
    (<form>
      (<Page-Setup>)))
  
  (definition Default-Page-Setup-File
    {File Profile "settings" "PageSetup.jml"})
  
  
  (method public undocumented (set-default-page-setup page-setup)
    (set! Default-Page-Setup page-setup))
  
  
  (method public undocumented (default-page-setup)
    (when (not Default-Page-Setup)
      (setup-page-setup))
    Default-Page-Setup)
  
  
  (method public undocumented (default-page-setup-designer)
    (when (not Default-Page-Setup-Designer)
      (setup-page-setup))
    Default-Page-Setup-Designer)
  
  
  (method virtual (setup-page-setup)
    (let* ((file Default-Page-Setup-File)
           (form (if (and (is-alias? 'Profile) (exists?~ file)) (read-form file) Default-Page-Setup-Form)))
      (set! Default-Page-Setup (instantiate~ form))
      (set! Default-Page-Setup-Designer (new Designer form: (get-form~ Default-Page-Setup) reference: Default-Page-Setup))))
  
  
  (method virtual (save-page-setup)
    (when (and Default-Page-Setup-Designer (file? (get-origin~ (get-form~ Default-Page-Setup-Designer))))
      (let ((form (get-form~ Default-Page-Setup-Designer)))
        (when (not (get-origin~ form))
          (set-origin~ form Default-Page-Setup-File)))
      (save~ Default-Page-Setup-Designer)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public virtual (get-documentation-cataloguer)
    #f)
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  (method (on-zoom-out evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (- scaling 0.25) #t)))))
  
  
  (method (on-zoom-in evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (+ scaling 0.25) #t)))))
  
  
  (method (on-unzoom evt)
    (let ((view (scaled-view (get-property~ evt what:))))
      (if (not view)
          (bell)
        (scale-view view 1.0 #f))))
  
  
  (method (scaled-view what)
    (case what
      ((document) (current-document))
      ((mouse-view) (mouse-view))))
  
  
  (method (scale-view view scaling scaled?)
    (user-message "Scaling set to {a}" scaling)
    (set-scaling~ view scaling)
    (set-scaled?~ view scaled?))


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (on-capture-document evt)
    (pick-figure
      click: (lambda (view pos) (capture-document view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-document evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-document view))))
  
  
  (definition (capture-document view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (let ((guest (get-guest~ view)))
          (if (not guest)
              (bell)
            (export-picture~ guest))))))
  
  
  (method (on-capture-host evt)
    (pick-figure
      click: (lambda (view pos) (capture-host view))
      highlight: #t
      highlight-root-only?: #t
      obscure-unhighlighted?: #f
      report-figure?: #f
      tooltips?: #f))
  
  
  (method (on-capture-mouse-host evt)
    (let ((view (mouse-view)))
      (if (not view)
          (bell)
        (capture-host view))))
  
  
  (definition (capture-host view)
    (let ((host (get-host~ view)))
      (if (not host)
          (bell)
        (export-picture~ host))))


  ;;;
  ;;;; Windows
  ;;;
  
  
  (method public virtual (update-windowing-actions)
    (unless (exiting-process?)
      (update-history-actions)
      (update-window-actions)
      (update-menubar-buttons)))
  
  
  (method public (update-window-actions)
    (let ((all-frames (length (all-frames)))
          (frames (length (current-stage-frames)))
          (stages (length (get-active-stages)))
          (in-modal? (in-modal?)))
      (set-action-enabled? {Action application close}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application close-all}         (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save}                    (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest save-as}                 (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application save-all}          (and (>= all-frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest revert-saved}            (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action guest compare-saved}           (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application page-setup}        (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-layout}      (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print-preview}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application print}             (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-frame}        (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-frame}    (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application current-frame}     (and (>= frames 1) (not in-modal?)))
      (set-action-enabled? {Action application next-stage}        (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application previous-stage}    (and (>= stages 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-horizontally} (and (>= frames 2) (not in-modal?)))
      (set-action-enabled? {Action application tile-vertically}   (and (>= frames 2) (not in-modal?)))))
  
  
  (method package virtual (on-next-frame evt)
    (let ((first (first-frame)))
      (send-to-back~ first)
      (focus-host~ (front-frame))))
  
  
  (method package virtual (on-previous-frame evt)
    (let ((last (last-frame)))
      (bring-to-front~ last)
      (focus-host~ (front-frame))))
  
  
  (method package virtual (on-current-frame evt)
    (let ((first (first-frame)))
      (focus-host~ first)))
  
  
  (method package (on-next-stage evt)
    (navigate-next-stage))
  
  
  (method package (on-previous-stage evt)
    (navigate-previous-stage))
  
  
  (method package virtual (on-tile-horizontally evt)
    (let* ((stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (w (quotient width count))
           (l 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point l 0))
                      (set-size~ frame (new Dimension w height))
                      (increase! l w))
                    frames)))))
  
  
  (method package virtual (on-tile-vertically evt)
    (let* ((stage (current-stage))
           (frames (get-views~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (h (quotient height count))
           (t 0))
      (with-locked-update
        (lambda ()
          (restore~ stage)
          (for-each (lambda (frame)
                      (set-position~ frame (new Point 0 t))
                      (set-size~ frame (new Dimension width h))
                      (increase! t h))
                    frames)))))
  
  
  (method package (on-select-frame evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ host)
      (focus-host~ host)))
  
  
  (method package (on-select-palette evt)
    (let ((host (get-property~ evt host:)))
      (bring-to-front~ (get-player~ host))))


  ;;;
  ;;;; Modal
  ;;;
  
  
  (method package virtual (update-modal-actions)
    (update-windowing-actions)))


;;;
;;;; Default-Workspace
;;;


(class Default-Workspace extends Workspace-Preferences
  
  
  (form
    (<install>             fullscreen?: #t
      (<Stage-Preferences> location: root)))))
