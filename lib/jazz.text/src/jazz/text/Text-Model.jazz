;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Text Model
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Marcel Cote
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.text.Text-Model jazz


(import (jazz.application)
        (jazz.component)
        (jazz.document)
        (jazz.event)
        (jazz.exemplar)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.skin)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.ui.skin)
        (jazz.undoer)
        (jazz.view)
        (jazz.workspace))


(definition compare-monikers
  (request-service 'compare-monikers))


(class Text-Model extends Outline-Model
  
  
  ;;;
  ;;;; Lexicon
  ;;;
  
  
  ;; line -> numerical value of paragraph rank
  ;; col  -> character offset into a paragraph string
  
  
  ;; a user friendly textual input format that is saved as is
  (property protected text                           initialize #f                       accessors explicit)
  (property protected wrap?                          initialize #f                       accessors generate)
  (property protected base-format                    initialize #f                       accessors generate)
  (property protected default-format                 initialize #f                       accessors explicit)
  (property protected base-style                     initialize #f                       accessors generate)
  (property protected default-style                  initialize #f                       accessors explicit)
  (property protected paragraph-spacing         <fx> initialize 0                        accessors generate)
  (property protected char-encoding                  initialize #f                       accessors generate)
  (property protected eol-encoding                   initialize #f                       accessors generate)
  (property protected propagate-styles?              initialize #t                       accessors generate)
  
  
  (slot protected syntax                 initialize #f              accessors generate)
  (slot protected undoer     <Undoer>    initialize #f              getter generate)
  (slot protected user-tabs              initialize '())
  (slot protected tabs                   initialize '()             accessors generate)
  (slot protected formats                initialize (make-formats)  getter generate)
  (slot protected styles                 initialize (make-styles)   getter generate)
  (slot protected wrap-width             initialize #f              accessors generate)
  (slot protected wrap-patch             initialize 0               accessors generate)
  
  
  (form
    ;; the default-row-height: 16 is a try for a quick fix. all the default-row-height related stuff needs cleanup
    (<install> background: {Color Text-Background} left-padding: 12 default-row-height: 16))
  
  
  (definition (make-formats)
    (new Exemplar-Domain name: 'formats intern?: #t chained: (list (formats-domain))))
  
  (definition (make-styles)
    (new Exemplar-Domain name: 'styles intern?: #t chained: (list (styles-domain))))
  
  
  (method override (prepare self rest)
    (define (new-default-format)
      (new Format domain: formats base: 'Text-Base))
    
    (define (new-default-style)
      (new Text-Style domain: styles base: 'Text-Base))
    
    (nextmethod self rest)
    (set! default-format (new-default-format))
    (set! default-style (new-default-style))
    (set! undoer (new Undoer reset-modified: (~ reset-modified? self))))
  
  
  (method override (install-child self form creator creator-branch restore-form)
    (case (get-model form)
      ;; until Form <-> Node unification
      ((text) (set-text self (form->node form)))
      (else (nextmethod self form creator creator-branch restore-form))))

  
  (method override (finish self rest)
    (nextmethod self rest)
    (when (not text)
      (set-content self (empty-content self)))
    (set! tabs (make-tabs self)))
  
  
  (method protected virtual (new-syntax self) <Text-Syntax>
    (new Text-Syntax self))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method package (get-paragraphs self) <Axis>
    (get-sons root-row))
  
  
  (method package (set-paragraphs self lst)
    (set-sons root-row lst))
  
  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method override (get-modified? self)
    modified?)
  
  
  (method override (set-modified? self state)
    (set! modified? state)
    (for-each-client self
      (lambda (view)
        (set-modified? view state))))
  
  
  (method package (reset-modified? self)
    (set-modified? self #f))
  
  
  (method package (update-status self)
    (for-each-client self
      (lambda (view)
        (update-status view))))
  
  
  (method package (update-moniker-time self moniker)
    (for-each-client self
      (lambda (view)
        (update-moniker-time view moniker))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;
  
  
  (method package (load-content self moniker)
    (if (not moniker)
        (set-content self #f)
      (read-content self moniker))
    (update-status self))
  
  
  (method package (save-content self moniker)
    (save-to self moniker)
    (update-moniker-time self moniker)
    (if (not (get-modified? self))
        (update-status self)
      (set-modified? self #f)
      (reset-save-depth undoer)))
  
  
  (method override (save-to self moniker)
    (let ((content (get-content self)))
      (save-lines moniker content char-encoding: char-encoding eol-encoding: eol-encoding)))
  
  
  (method package (reload-moniker self moniker)
    (when moniker
      (reload-content self (read-moniker self moniker))
      (update-moniker-time self moniker)))
  
  
  (method package (compare-moniker self moniker)
    (when moniker
      (compare-monikers (new Document-Moniker moniker) moniker)))
  
  
  (method protected virtual (empty-content self)
    (new Text paragraphs: (list "")))
  
  
  (method override (get-content self)
    (accumulate (get-paragraphs self) (~ paragraph->string self) List))
  
  
  (method override (set-content self lst)
    (set-unformatted-content self lst))
  
  
  (method public (empty-text self)
    (set-content self (empty-content self)))
  
  
  (method (set-unformatted-content self lst)
    (let* ((lst (or lst (empty-content self)))
           (lst (if (null/pair? lst) lst (get-paragraphs lst)))
           (count <fx> 0)
           (height <fx> 0)
           (previous root-row)
           (rows (map (lambda (string)
                        (let ((paragraph (make-string-paragraph self #f string)))
                          (set-previous paragraph previous)
                          (set-next previous paragraph)
                          (set! previous paragraph)
                          (wrap-paragraph self '() paragraph)
                          (increase! count)
                          (increase! height (get-row-height paragraph))
                          paragraph))
                      lst)))
      (complete-setup self rows count height)))
  
  
  (method public (get-string-content self) <string>
    (join-lines (get-content self)))
  
  
  (method public (set-string-content self content <string>) <void>
    (set-content self (parse-string-content self content))
    ;; ugly sejour hack
    (when (is? (current-application) Application)
      (colorize syntax))
    (call-content-change self #f))
  
  
  (method (make-string-paragraph self format string <string>) <Paragraph>
    (make-paragraph self
     format
     string
     (if (empty-string? string)
         '()
       (list (new Run (subseq! string 0 (cast <fx> (cardinality string))) (get-default-style self))))))
  
  
  (method (make-paragraph self format string <string> runs)
    (let ((paragraph (new Paragraph)))
      (set-parent paragraph self)
      (set-format paragraph (or format (get-default-format self)))
      (set-string paragraph string)
      (set-runs paragraph runs)
      (set-father paragraph root-row)
      (set-level paragraph 0)
      (set-row-height paragraph (get-height (get-metrics (get-font (get-default-style self)))))
      (fix-view-style-parent paragraph)
      paragraph))
  
  
  (method public virtual (read-content self moniker)
    (set-content self (read-moniker self moniker))
    (update-moniker-time self moniker)
    (colorize syntax))
  
  
  (method protected virtual (read-moniker self moniker)
    ;; we cannot directly use UTF-fallback-ISO-8859-1 as
    ;; it fails in the case of an UTF-8 file with no BOM
    (catch-exception-filter
      (lambda (exc)
        (os-exception? exc))
      (lambda (exc)
        (load-lines moniker char-encoding: 'UTF-fallback-ISO-8859-1 char-encoding-errors: #t))
      (lambda ()
        (load-lines moniker char-encoding: char-encoding char-encoding-errors: #t))))
  
  
  (method public (reload-content self lst)
    (set-content self lst)
    (colorize syntax)
    (update-status self))
  
  
  ;;;
  ;;;; Container
  ;;;
  
  
  (method override (content-size-change self size <Dimension>)
    (set! visible-width (get-width size))
    (when wrap?
      (wrap-content self '())))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method public (for-each-logical-range self range <Range$Cell$> proc)
    (let ((start (get-start range))
          (end (get-end range)))
      (when (/= start end)
        (if (= (get-line start) (get-line end))
            (let ((line (get-line start)))
              (proc line (get-paragraph self line) (get-col start) (get-col end)))
          (let ((beginning (get-line start))
                (limit (get-line end)))
            (loop (for line from beginning to limit)
                  (let ((paragraph (get-paragraph self line)))
                    (cond ((= line beginning) (proc line paragraph (get-col start) #f))
                          ((= line limit) (proc line paragraph #f (get-col end)))
                          (else (proc line paragraph #f #f))))))))))
  
  
  (method public (for-each-range self range <Range$Cell$> proc)
    (for-each-logical-range self range
      (lambda (line paragraph start end)
        (proc line
              paragraph
              (or start 0)
              (or end (get-length paragraph))))))
  
  
  ;;;
  ;;;; Tabs
  ;;;
  
  
  ;; Tabs should really grow as needed...
  ;; For now a big number of tabs will do!
  (method (make-tabs self)
    (make-tabs-from self 0 32 1024))
  
  
  (method public (make-tabs-from self from tab-size number)
    (let ((stop from))
      (map (lambda (n)
             (prog1 stop
               (increase! stop tab-size)))
           (naturals 0 number))))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method override (can-undo? self)
    (can-undo? undoer))
  
  
  (method override (can-redo? self)
    (can-redo? undoer))
  
  
  (method override (undo self)
    (undo undoer))
  
  
  (method override (redo self)
    (redo undoer))
  
  
  ;;;
  ;;;; Boundaries
  ;;;
  
  
  (method public (text-beginning self) <Cell>
    (new Cell 0 0))
  
  
  (method public (text-ending self) <Cell>
    (let ((limit (get-limit self)))
      (new Cell limit (paragraph-length self limit))))
  
  
  (method public (text-range self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-ending self)))
  
  
  (method public (text-empty? self) <bool>
    (= (text-beginning self) (text-ending self)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (get-char self pos <Cell>) <char>
    (let ((line (get-line pos))
          (col (get-col pos)))
      (let ((string (get-string (get-paragraph self line))))
        (if (< col (cardinality string))
            (element string col)
          #\newline))))
  
  
  (method public (get-string self range <Range$Cell$>) <string>
    (join-lines (range-strings self range)))
  
  
  (method public (next! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) (paragraph-length self (get-line pos)))
           (increase-col pos)
           #t)
          ((< (get-line pos) (get-limit self))
           (increase-line pos)
           (set-col pos 0)
           #t)
          (else
           #f)))
  
  
  (method public (previous! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) 0)
           (increase-col pos -1)
           #t)
          ((> (get-line pos) 0)
           (increase-line pos -1)
           (set-col pos (paragraph-length self (get-line pos)))
           #t)
          (else
           #f)))
  
  
  (method public (next-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (next! self cell)
           cell)))
  
  
  (method public (previous-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (previous! self cell)
           cell)))
  
  
  (method public (get-range-strings self range)
    (if (empty? range)
        '()
      (range-strings self range)))
  
  
  (method public (next-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((next! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (previous-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((previous! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (get-column self line <fx>) <fx>
    (let ((pos (new Cell line 0)))
      (while (memq? (get-char self pos) '(#\space #\tab))
        (increase! pos))
      (get-col pos)))
  
  
  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method override (dynamic-scrollee? self)
    #t)
  
  
  (method override (dynamic-set-scrollee-size self)
    (nextmethod self)
    (let ((size (get-size self)))
      (for-each-client self
        (lambda (view)
          (scrollee-size-update view size)))))
  
  
  (method override (scrollee-width self)
    (let ((single-client (single-client self)))
      (if (and single-client wrap?)
          (or wrap-width (get-display-width single-client))
        (if (and single-client (dynamic-scrollee-width? single-client))
            (+ left-padding (calculate-scrollee-width self) left-padding)
          4000))))
  
  
  (method override (scrollee-content-width self)
    (+ left-padding (calculate-scrollee-width self) left-padding))
  
  
  (method (calculate-scrollee-width self)
    (let ((width 0))
      (for-each-paragraph self
        (lambda (line <fx> paragraph <Paragraph>)
          (let ((paragraph-width (compute-width paragraph)))
            (when (> paragraph-width width)
              (set! width paragraph-width)))))
      width))
  
  
  (method package (calculate-contour-scrollee-width self)
    (let ((width 0))
      (for-each-paragraph self
        (lambda (line <fx> paragraph <Paragraph>)
          (for-each (lambda (line <Line>)
                      (let ((line-width (contour-width line)))
                        (when (> line-width width)
                          (set! width line-width))))
                    (get-lines paragraph))))
      width))
  
  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method override (invalidate-update self)
    (nextmethod self)
    (wrap-content self '()))
  
  
  ;;;
  ;;;; Paragraph
  ;;;


  (method public (get-length self) <fx>
    (cardinality (get-paragraphs self)))
  
  
  (method public (get-limit self) <fx>
    (- (get-length self) 1))
  
  
  (method public (get-paragraph self line <fx>) <Paragraph>
    (element (get-paragraphs self) line))
  
  
  (method public (paragraph-string self line <fx>) <string>
    (get-string (get-paragraph self line)))
  
  
  (method public (paragraph-length self line <fx>) <fx>
    (cardinality (paragraph-string self line)))
  
  
  (method (paragraph->string self paragraph <Paragraph>) <string>
    (get-string paragraph))
  
  
  (method public (first-paragraph self)
    (get-paragraph self 0))
  
  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (get-print-area self context)
    (new Rect 0 0 800 (scrollee-height self)))
  
  
  (method package (paginate-range self start end page-width page-height)
    (let ((pages (new List-Factory))
          (page 0)
          (top 0)
          (bottom 0)
          (together #f))
      (for-each-paragraph self
        (lambda (line <fx> paragraph <Paragraph>)
          (when (and (>= line start) (< line end))
            (let* ((paragraph-top bottom)
                   (string (get-string paragraph))
                   (format (get-format paragraph))
                   (height (get-height paragraph))
                   (bot (+ bottom height)))
              (if (<= bot (+ top page-height))
                  (set! bottom bot)
                (let ((effective-bottom (or together bottom)))
                  (put pages (new Rect 0 top page-width effective-bottom))
                  (set! top effective-bottom))
                (set! bottom bot))
              (when (and together (not (empty-string? string)))
                (set! together #f))
              (when (and (not together) (get-keep-with-next? format))
                (set! together paragraph-top))))))
      (put pages (new Rect 0 top page-width bottom))
      (get-output pages)))
  
  
  (method override (setup-printing self)
    (let ((width wrap-width))
      (set! wrap-width 800)
      ;; this is a necessary (hopefully temporary) patch buffer because currently we get and memorize
      ;; character sizes at no scaling and of course round of errors accumulate when in higher scaling
      ;; wrap is wrongly done character by character
      (set! wrap-patch 50)
      (layout-scrollee self)
      (wrap-content self '())
      (cons :wrap-width (cons width (nextmethod self)))))
  
  
  (method override (restore-printing self preserved)
    (nextmethod self preserved)
    (set! wrap-width (getf preserved :wrap-width))
    (set! wrap-patch 0)
    (layout-scrollee self)
    (wrap-content self '()))
  
  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method package virtual (draw-enabled? self)
    (view-enabled? self))
  
  
  (method override (get-drawing-background self context)
    (let ((skin (get-skin self)))
      (if (not (draw-enabled? self))
          (or (get-disabled-background skin)
              {Color Medium})
        (or (get-background skin)
            (nextmethod self context)))))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method override (get-skin self)
    (find-skin 'ui:text))
  
  
  ;;;
  ;;;; Word
  ;;;
  
  
  (method public (next-word self pos (constituent-test: constituent-test #f))
    (let ((expl (new Text-Explorer self start: pos end: pos))
          (test (or constituent-test alphanumeric?)))
      (forward-until expl (lambda (c) (test c)))
      (forward-until expl (lambda (c) (not (test c))))
      (get-end expl)))
  
  
  (method public (previous-word self pos (constituent-test: constituent-test #f))
    (let ((expl (new Text-Explorer self start: pos end: pos))
          (test (or constituent-test alphanumeric?)))
      (backward-until expl (lambda (c) (test c)))
      (backward-until expl (lambda (c) (not (test c))))
      (get-start expl)))
  
  
  ;;;
  ;;;; Constituent
  ;;;
  
  
  (method public virtual (get-constituent-test self)
    (get-constituent-test syntax))
  
  
  (method public virtual (text-constituent? self char)
    (text-constituent? syntax char))
  
  
  (method public virtual (get-match-test self)
    (get-match-test syntax))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method public (move-forward self pos word?)
    (and pos
         (if word? (next-word self pos) (next-cell self pos))))
  
  
  (method public (move-backward self pos word?)
    (and pos
         (if word? (previous-word self pos) (previous-cell self pos))))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-char self range c)
    (insert-string self range (string c)))
  
  
  (method public (insert-string self range str)
    (replace self range (split-lines str)))
  
  
  (method public (insert-newline self range)
    (insert-string self range "\n"))
  
  
  (method public (insert-styled self range string style)
    (let ((start (get-start range))
          (style (cond ((is? style Style) style) ((not style) default-style) (else (locate-style self style)))))
      (let ((end (insert-string self range string)))
        (stylize-range self (new Range$Cell$ start end) style))))
  
  
  (method public (insert-link self range string (font: font #f) (anchor: anchor #f) (action: action #f))
    (let* ((font (or font {Font Link}))
           (style (new Link-Style font: font color: {Color Link} anchor: anchor action: action)))
      (insert-styled self range string style)))
  
  
  (method public (insert-image self range moniker)
    (let ((style (new Image-Style moniker: moniker)))
      (insert-styled self range " " style)))
  
  
  (method public (insert-view self range view/form)
    (let* ((view (if (is? view/form View) view/form (instantiate view/form)))
           (end (get-end range))
           (paragraph (get-paragraph self (get-line end))))
      (set-parent view paragraph)
      (let ((style (new View-Style view: view)))
        (insert-styled self range " " style))))
  
  
  ;;;
  ;;;; Table
  ;;;
  
  
  (method public (create-table self (size: size #f) (header?: header? #t) (node-column?: node-column? #f) (columns: columns '()) (row-count: row-count #f))
    (define (setup-columns tree node-column? columns)
      (let ((first? #t))
        (for-each (lambda (column)
                    (let* ((node?  (and first? node-column?))
                           (class  (if node? Tree-Node-Column Tree-Label-Column))
                           (title  (getf column title:))
                           (width  (getf column width:))
                           (others (if node? (list :display-images? #f) '())))
                      (set! first? #f)
                      (apply add-column tree class: class title: title width: width others)))
                  columns)))
    
    (define (setup-rows tree header? columns row-count)
      (when row-count
        (let ((height (get-height tree)))
          ;; time to patch!
          (when (not header?)
            (increase! height 16))
          (let ((row-height (quotient height (cast <fx> row-count))))
            (for-each (lambda (line)
                        (let ((children (map (lambda (column)
                                               (new Formatted-Text-View))
                                             columns)))
                          (add-row tree row-height: row-height children: children)))
                      (naturals 0 row-count))))))
    
    (let* ((border (new Table-Border))
           (tree (locate border 'tree)))
      (when size
        (set-size border size))
      (when (not header?)
        (set-shown? (locate border 'header) #f))
      (setup-columns tree node-column? columns)
      (setup-rows tree header? columns row-count)
      border))
  
  
  (method public (insert-table self range . rest)
    (let ((table (apply create-table self rest)))
      (insert-view self range table)
      table))
  
  
  ;;;
  ;;;; Table Of Content
  ;;;
  
  
  (method public virtual (insert-table-of-content self)
    )
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method (with-adjusted-marks self range thunk)
    (let ((caret (thunk))
          (procs (new-queue))) ;; delay calling change-procs until all marks are adjusted
      (for-each-client self
        (lambda (view)
          (adjust-marks view range caret procs)))
      (for-each (lambda (change-proc)
                  (change-proc))
                (queue-list procs))
      caret))
  
  
  ;;;
  ;;;; Replace
  ;;;
  
  
  (method public (delete-range self range)
    (replace self range (list "")))
  
  
  (method public (replace self range <Range$Cell$> strings)
    (with-adjusted-marks self range
      (lambda ()
        (replace-text self range strings))))
  
  
  (method package (replace-text self range <Range$Cell$> strings)
    (for-each-client self
      (lambda (client)
        (content-changing client range strings)))
    (let ((start (get-start range))
          (end (get-end range))
          (count (length strings))
          (undo-strings (range-strings self range))
          (caret (replace-range self range strings)))
      (update-displayed-from self (get-line start))
      (replace-recolorize self start count)
      (set-modified? self #t)
      (let ((undo-range (new Range$Cell$ start caret)))
        (register-undo undoer
                       (let ((old-range (copy range)))
                         (lambda ()
                           (for-each-client self hide-caret)
                           (replace self undo-range undo-strings)
                           (for-each-client self
                             (lambda (client)
                               (set-selection client old-range)
                               (update-caret client))))))
        (for-each-client self
          (lambda (client)
            (content-changed client range strings undo-range undo-strings))))
      (let ((appl (current-application)))
        ;; quick hack for sejour
        (when (and appl (is? appl Application))
          (update-focus-actions appl)))
      caret))
  
  
  (method package (replace-range self range <Range$Cell$> strings)
    (define (replace-paragraph line <fx> start <fx> end <fx> string <string>)
      (let* ((paragraph (get-paragraph self line))
             (inserted <fx> (cardinality string))
             (top (get-bottom paragraph)))
        (replace-range paragraph start end string)
        (invalidate-replacement paragraph top)
        (new Cell line (+ start inserted))))
    
    (define (replace-paragraphs range <Range$Cell$> strings)
      (let* ((start       (get-start range))
             (end         (get-end range))
             (sl          (get-line start))
             (el          (get-line end))
             (replaced    (+ (- el sl) 1))
             (inserted    (length strings))
             (before      (range-height sl el))
             (first-par   (get-paragraph self sl))
             (last-par    (get-paragraph self el))
             (bottom      (get-bottom last-par))
             (paragraphs  (strings->paragraphs first-par strings))
             (first-runs  (range-runs first-par 0 (get-col start)))
             (last-runs   (range-runs last-par (get-col end) (get-length last-par)))
             (last-length (cardinality (cast <string> (last strings))))
             (caret-line  (+ sl inserted -1))
             (caret-col   (+ (if (= inserted 1) (get-col start) 0) last-length)))
        (replace-sons root-row paragraphs first-par sl (get-next last-par) (+ el 1))
        (replace-beginning (get-paragraph self sl) first-runs)
        (replace-ending (get-paragraph self caret-line) last-runs)
        (invalidate-replacements paragraphs replaced inserted bottom before)
        (new Cell caret-line caret-col)))
    
    (define (invalidate-replacement paragraph top)
      (let ((delta (wrap-paragraph self '() paragraph)))
        (layout-scrollee self)
        ;; this has to be done, but possibly the right approach is
        ;; to have an invalid scrollee flag... set by the various row methods...
        ;; or maybe the fucking row-height can all be cleaned up!!!
        (let ((single-client (single-client self)))
          (when (and single-client (or wrap? (dynamic-scrollee-width? single-client)))
            (layout-scrollee single-client)))
        (when (/= delta 0)
          (for-each-client self
            (lambda (client)
              (let ((size (get-size client)))
                (let ((rect (new Rect 0 top (get-width size) (get-height size))))
                  (scroll-view client (new Distance 0 delta) rect))))))
        (invalidate-paragraph self paragraph)))
    
    (define (invalidate-replacements paragraphs replaced inserted bottom before)
      (define (paragraphs-height paragraphs)
        (let (iterate (paragraphs paragraphs)
                      (sum 0))
          (if (null? paragraphs)
              sum
            (iterate (cdr paragraphs) (+ sum (paragraph-height (car paragraphs)))))))
      
      (for-each (lambda (paragraph)
                  (wrap-paragraph-lowlevel self '() paragraph))
                paragraphs)
      (let* ((after (paragraphs-height paragraphs))
             (delta (- after before)))
        (increase! visible-count (- inserted replaced))
        (increase! visible-height delta)
        (layout-scrollee self)
        (for-each-client self
          (lambda (client)
            (layout-scrollee client)
            (when (/= delta 0)
              (let ((size (get-size client)))
                (let ((rect (new Rect 0 bottom (get-width size) (get-height size))))
                  (scroll-view client (new Distance 0 delta) rect))))))
        (for-each (~ invalidate-paragraph self) paragraphs)))
    
    (define (range-height start end)
      (loop (with row = (get-row self start))
            (for n from start to end)
            (sum (paragraph-height row))
            (do (set! row (get-next row)))))
    
    (define (paragraph-height paragraph)
      (get-row-height paragraph))
    
    (define (strings->paragraphs first-par strings)
      (let ((last-format (get-format first-par)))
        (map (lambda (string)
               (make-string-paragraph self last-format string))
             strings)))
    
    (let ((start (get-start range))
          (end   (get-end range))
          (count (length strings)))
      (for-each-client self model-update)
      (if (and (= (get-line start) (get-line end)) (= 1 count))
          (replace-paragraph (get-line start) (get-col start) (get-col end) (cast <string> (car strings)))
        (if (<= count (- (get-line end) (get-line start)))
            (with-update-locked self
              (lambda ()
                (replace-paragraphs range strings)))
          (replace-paragraphs range strings)))))
  
  
  (method package (invalidate-paragraph self paragraph)
    (for-each-client self
      (lambda (client)
        (let ((rect (position/size->rect (get-position paragraph) (new Dimension (get-width client) (get-height paragraph)))))
          (invalidate-rect client rect)))))
  
  
  (method package virtual (replace-recolorize self start count)
    (receive (syntax syntax-style) (replace-syntax syntax start)
      (recolorize syntax syntax-style start (- (+ (get-line start) count) 1))))
  
  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method public (get-text self)
    text)
  
  
  (method public (set-text self value)
    (set-content self (parse-text-content self value))
    (set! text value))
  
  
  (method (parse-text-content self content)
    (cond ((not content)
           (empty-content self))
          ((string? content)
           (parse-string-content self content))
          ((and (null/pair? content) (is? self Formatted-Text-Model))
           (parse-markup-content self (parse-markup content)))
          ((is? content Markup-Node)
           (parse-markup-content self content))
          (else
           (error "Unable to parse text content type: {t}" (category-identifier (class-of content))))))
  
  
  (method (parse-string-content self content)
    (new Text paragraphs: (split-lines content)))
  
  
  ;;;
  ;;;; Markup
  ;;;
  
  
  @text-tags
  ((<text>)
   (<paragraph> <p>)
   (<header> <h>)
   (<list> type: ordered unordered
     (<item>))
   (<format>)
   (<style>)
   (<anchor> <a>)
   (<hyperlink> <link>)
   (<image> <img>)
   (<table>
     (<tr>)
     (<td>)))
  
  
  @have-to-think-those-through-as-they-are-very-basic-in-the-xhtml-model
  ((<div>)
   (<span>))
  
  
  @comment
  (let ((yo (lambda rest (debug 'yo))))
    `(<span>
       "Hello World"
       (<bulleted> "Yoo")
       (<bulleted> "This message-box")
       (<bulleted> indent: 2 
         "really"
         " "
         (<text> frame: Blue
           (<text> highlight: Red
             (<text> color: Green
               "really")))
         (<text> frame: Blue highlight: Red color: Green
           "really"))
       (<paragraph> bulleted: #t indent: 1
         (<text> action: ,yo
           "rocks!"))))
  
  
  (method (parse-markup-content self node)
    (let ((paragraphs (new-queue))
          (formats (new List-Factory))
          (styles (new List-Factory)))
      (define (intern-format format)
        (and format
             (put formats format)))
      
      (define (intern-style style)
        (and style
             (put styles style)))
      
      (define (process-node node runs style)
        (if (is? node Markup-Text)
            (let ((text (get-text node)))
              (if (not runs)
                  (enqueue paragraphs (cons #f (list (list text #f))))
                (enqueue runs (list text (intern-style style)))))
          (case (get-tag node)
            ((span) (process-span node runs style))
            ((paragraph) (process-paragraph node runs style))
            ((text) (process-text node runs style))
            (else (error "Invalid text node: {s}" (get-tag node))))))
      
      (define (process-children node runs style)
        (for-each (lambda (child)
                    (process-node child runs style))
                  (get-children node)))
      
      (define (process-span node runs style)
        (process-children node runs style))
      
      (define (process-paragraph node runs style)
        (let ((format (new Format))
              (runs (new-queue))
              (style (new Text-Style base: 'Base)))
          (for-each-property (lambda (property value)
                               (case property
                                 ((format) (set! format (new Format base: value)))
                                 ((bulleted) (set! format (extend format bulleted?: value left-margin: 16)))
                                 ((indent) (set! format (extend format left-margin: (+ (get-left-margin format) (* value 32)))))
                                 ((justification) (set! format (extend format justification: value)))
                                 (else (error "Unknown paragraph property: {s}" property))))
                           (get-properties node))
          (process-children node runs style)
          (enqueue paragraphs (cons (intern-format format) (queue-list runs)))))
      
      (define (process-text node runs style)
        (for-each-property (lambda (property value)
                             (case property
                               ((style) (set! style (new Text-Style base: value)))
                               ((font) (set! style (extend style font: (process-font value))))
                               ((frame) (set! style (extend style frame: (process-color value))))
                               ((highlight) (set! style (extend style highlight: (process-color value))))
                               ((color) (set! style (extend style color: (process-color value))))
                               ((action) (set! style (new Link-Style font: {Font Link} color: {Color Link} action: value)))
                               (else (error "Unknown text property: {s}" property))))
                           (get-properties node))
        (process-children node runs style))
      
      (define (process-color color)
        (if (is? color Color)
            color
          (registered-color color)))
      
      (define (process-font font)
        (if (is? font Font)
            font
          (registered-font font)))
      
      (process-node (transform-markup node (new Text-Transformation)) #f #f)
      (new Formatted-Text
        formats: (get-output formats)
        styles: (get-output styles)
        paragraphs: (queue-list paragraphs))))
  
  
  ;;;
  ;;;; Formatted
  ;;;
  
  
  (method public (patch-formatted-bug self)
    (empty-interned formats)
    (empty-interned styles)
    (for-each-paragraph self
      (lambda (line <fx> paragraph <Paragraph>)
        (set-format paragraph (intern-format self (get-format paragraph)))
        (for-each (lambda (run)
                    (set-style run (intern-style self (get-style run))))
                  (get-runs paragraph)))))
  
  
  (method protected (read-formatted self moniker)
    (parameterize ((walk-for #f))
      (call-with-input-file (path-settings moniker eol-encoding: 'cr-lf readtable: jazz-readtable)
        read)))
  
  
  (method protected (read-formatted-string self str)
    (parameterize ((walk-for #f))
      (call-with-input-string (list init: str readtable: jazz-readtable)
        read)))
  
  
  (method protected (save-formatted self moniker)
    (call-with-output-file (path-settings moniker)
      (lambda (output)
        (print-formatted self output #f))))
  
  
  (method package (print-formatted self output range <Range$Cell$+>)
    (define (print-formats formats output)
      (format output " (")
      (let ((first? #t))
        (iterate formats
                 (lambda (fmt)
                   (if first?
                       (set! first? #f)
                     (format output "{%}  "))
                   (format output "{s}" fmt))))
      (format output "){%}{%}"))
    
    (define (print-styles styles output)
      (format output " (")
      (let ((first? #t))
        (iterate styles
                 (lambda (style)
                   (if first?
                       (set! first? #f)
                     (format output "{%}  "))
                   (format output "{s}" style))))
      (format output "){%}{%}"))
    
    (define (range-paragraph-runs paragraph <Paragraph> range <Range$Cell$+>)
      (if (not range)
          (get-runs paragraph)
        (let ((first? (eq? paragraph (get-paragraph self (get-line (get-start range)))))
              (last?  (eq? paragraph (get-paragraph self (get-line (get-end range))))))
          (let ((start (if first? (get-col (get-start range)) 0))
                (end (if last? (get-col (get-end range)) (get-length paragraph))))
            (range-runs paragraph start end)))))
    
    (let ((formats (get-interned formats))
          (styles (get-interned styles)))
      (format output "~{Formatted-Text{%}")
      (format output " formats:{%}")
      (print-formats formats output)
      (format output " styles:{%}")
      (print-styles styles output)
      (format output " paragraphs:{%}")
      (format output " (")
      (let ((first? #t)
            (paragraphs (if (not range)
                            (get-paragraphs self)
                          (range-paragraphs self range))))
        (iterate paragraphs
                 (lambda (paragraph <Paragraph>)
                   (if first?
                       (set! first? #f)
                     (format output "{%}  "))
                   (format output "({s}" (find-rank (get-format paragraph) formats))
                   (for-each (lambda (run)
                               (format output " ({s} {s})" (export-string run) (find-rank (get-style run) styles)))
                             (range-paragraph-runs paragraph range))
                   (format output ")")))
        (format output ")}{%}"))))
  
  
  (method public (get-formatted-content self)
    (let ((formats (get-interned formats))
          (styles (get-interned styles)))
      (define (get-formatted-paragraphs)
        (let ((fact (new List-Factory)))
          (for-each-paragraph self
            (lambda (line <fx> paragraph <Paragraph>)
              (put fact (cons (find-rank (get-format paragraph) formats)
                               (map (lambda (run)
                                      (list (export-string run) (find-rank (get-style run) styles)))
                                    (get-runs paragraph))))))
          (get-output fact)))
      
      (new Formatted-Text
        formats: (coerce formats List)
        styles: (coerce styles List)
        paragraphs: (get-formatted-paragraphs))))
  
  
  (method public (set-formatted-content self text)
    (typecase text
      ((Formatted-Text)
       (let ((formats (get-formats text))
             (styles (get-styles text))
             (paragraphs (get-paragraphs text)))
         (let* ((formats (map (~ intern-format self) formats))
                (styles (map (~ intern-style self) styles))
                (count 0)
                (height 0)
                (previous root-row)
                (rows (accumulate paragraphs
                                  (lambda (info)
                                    (bind (format . runs) info
                                      (let* ((format (and format (reference-format self formats format)))
                                             (string (run-infos->string runs))
                                             (runs (make-runs self string styles runs))
                                             (paragraph (make-paragraph self format string runs)))
                                        (set-previous paragraph previous)
                                        (set-next previous paragraph)
                                        (set! previous paragraph)
                                        (wrap-paragraph self '() paragraph)
                                        (increase! count)
                                        (increase! height (get-row-height paragraph))
                                        paragraph))))))
           (complete-setup self rows count height))))
      ((Text)
       (set-unformatted-content self (get-paragraphs text)))
      (else
       (error "Unsupported text: {t}" text))))
  
  
  (method (complete-setup self rows count height)
    (set-paragraphs self (coerce rows Axis))
    (set! visible-count count)
    (set! visible-height height)
    (set! visible-width (get-width self))
    (for-each-client self reset-selection)
    (for-each-client self invalidate-update))
  
  
  (method public (wrap-content self context)
    (let ((single-client (single-client self)))
      (unless (or update-locked? (not single-client))
        (let ((height 0))
          (iterate (get-paragraphs self)
                   (lambda (paragraph)
                     (wrap-paragraph self context paragraph)
                     (increase! height (get-row-height paragraph))))
          (set! visible-height height)
          (layout-scrollee single-client)
          (invalidate-view single-client)))))
  
  
  ;; Note that wrap-paragraph will only set the row-height of the paragraph.
  ;; It is the responsibility of the caller to force a layout of the ouline or
  ;; maintain incrementally the visible-height.
  (method package (wrap-paragraph self context paragraph)
    (let ((before (get-row-height paragraph)))
      (wrap-paragraph-lowlevel self context paragraph)
      (let ((delta (- (get-row-height paragraph) before)))
        (increase! visible-height delta)
        delta)))
  
  
  (method protected (wrap-paragraph-lowlevel self context paragraph)
    (define (get-paragraph-width)
      (max 40 (- (if wrap-width (- wrap-width wrap-patch) (display-width-patch)) left-padding (get-left-margin (get-format paragraph)))))
    
    (define (display-width-patch)
      (let ((single-client (single-client self)))
        (if single-client
            (get-display-width single-client)
          100)))
    
    (if (not wrap?)
        (flatten paragraph)
      (let ((width (get-paragraph-width)))
        (wrap paragraph context width))))
  
  
  (method (range-paragraphs self range <Range$Cell$>)
    (let ((last #f)
          (fact (new List-Factory)))
      (loop (for line from (get-line (get-start range)) to (get-line (get-end range)))
            (let ((paragraph (get-paragraph self line)))
              (if (not paragraph)
                  (put fact line)
                (unless (eq? paragraph last)
                  (put fact (get-paragraph self line))
                  (set! last paragraph)))))
      (get-output fact)))
  
  
  (method package (replace-formatted self range <Range$Cell$> info)
    (with-adjusted-marks self range
      (lambda ()
        (typecase info
          ((Formatted-Text)
           (let* ((formats (get-formats info))
                  (styles (get-styles info))
                  (paragraphs (get-paragraphs info))
                  (interned-formats (map (~ intern-format self) formats))
                  (interned-styles (map (~ intern-style self) styles))
                  (strings (map (lambda (run-info)
                                  (bind (format . runs) run-info
                                    (run-infos->string runs)))
                                paragraphs)))
             (replace-formatted-text self range strings interned-formats interned-styles paragraphs)))
          ((Text)
           (replace-text self range (split-lines (get-paragraphs info))))
          (else
           (error "Unsupported text: {t}" info))))))
  
  
  (method package (replace-formatted-text self range <Range$Cell$> strings formats styles paragraphs)
    (define (range-formatted-text range <Range$Cell$>)
      (let ((output (open-output-string)))
        (print-formatted self output range)
        (parameterize ((walk-for #f))
          (with-jazz-readtable
            (lambda ()
              (read-string-element (get-output-string output)))))))
    
    (define (apply-formats/styles range <Range$Cell$>)
      (let ((start (new Cell (get-line (get-start range)) (get-col (get-start range))))
            (end   (new Cell (get-line (get-start range)) (get-col (get-start range)))))
        (for-each (lambda (paragraph)
                    (bind (format . runs) paragraph
                      (for-each (lambda (run)
                                  (bind (string . ref) run
                                    (let ((style (reference-style self styles (car ref))))
                                      (set-col end (+ (get-col start) (cast <fx> (cardinality string))))
                                      (stylize-range self (new Range$Cell$ start end) style)
                                      (set-col start (get-col end)))))
                                runs)
                      (let* ((full-paragraph (get-paragraph self (get-line start)))
                             (line-length (- (get-length full-paragraph) 1)))
                        (when (and (inside? range (new Cell (get-line start) 0))
                                   (inside? range (new Cell (get-line start) line-length)))
                          (set-format (get-paragraph self (get-line start)) (reference-format self formats format)))
                        (fix-view-style-parent full-paragraph)))
                    (set-line start (+ (get-line start) 1))
                    (set-line end (+ (get-line end) 1))
                    (set-col start 0))
                  paragraphs)))
    
    (for-each-client self
      (lambda (client)
        (content-changing client range strings)))
    (let* ((start (get-start range))
           (end (get-end range))
           (count (length strings))
           (undo-strings (range-formatted-text range))
           (caret (replace-range self range strings)))
      (apply-formats/styles (new Range$Cell$ start caret))
      (update-displayed-from self (get-line start))
      (replace-recolorize self start count)
      (set-modified? self #t)
      (let ((undo-range (new Range$Cell$ start caret)))
        (register-undo undoer
                       (let ((old-range (copy range)))
                         (lambda ()
                           (for-each-client self hide-caret)
                           (replace-formatted self undo-range undo-strings)
                           (for-each-client self
                             (lambda (client)
                               (set-selection client old-range)
                               (update-caret client))))))
        (for-each-client self
          (lambda (client)
            (content-changed client range strings undo-range undo-strings))))
      (let ((appl (current-application)))
        ;; quick hack for sejour
        (when (and appl (is? appl Application))
          (update-focus-actions appl)))
      caret))
  
  
  ;;;
  ;;;; Paragraph Format
  ;;;
  
  
  (method public (toggle-bulleted self line)
    (modify-format self (get-paragraph self line)
                   (lambda (format)
                     (let ((left-margin (get-left-margin format))
                           (bulleted? (get-bulleted? format)))
                       (extend format bulleted?: (not bulleted?) left-margin: (+ left-margin (if bulleted? -16 16)))))))
  
  
  (method public (indent-paragraph self line paragraph delta)
    (modify-format self paragraph
                   (lambda (format)
                     (let ((left-margin (get-left-margin format)))
                       (extend format left-margin: (+ left-margin delta))))))
  
  
  (method package (set-justification self line paragraph justification)
    (modify-format self paragraph
                   (lambda (format)
                     (extend format justification: justification))))
  
  
  (method (modify-format self paragraph proc)
    (let ((format (get-format paragraph)))
      (set-paragraph-format self paragraph (proc format))))
  
  
  (method package (set-paragraph-format self paragraph format)
    (set-format paragraph (intern-format self format))
    (wrap-paragraph self '() paragraph)
    (set-modified? self #t)
    (let ((single-client (single-client self)))
      (when single-client
        (layout-scrollee single-client)
        (invalidate-view single-client))))
  
  
  (method public (apply-style self name start (end #f))
    (stylize self (locate-style self name) start end))
  
  
  (method public (stylize self name/style start (end #f))
    (when (not end)
      (set! end (new Cell (get-line start) (paragraph-length self (get-line start)))))
    (set-text-style self (new Range$Cell$ start end) (locate-style self name/style)))
  
  
  ;; the layout-scrollee? is a quick hack
  (method public (stylize-range self range <Range$Cell$> style <Style> (layout-scrollee? #t))
    (let ((style (intern-style self style)))
      (for-each-range self range
        (lambda (line paragraph start end)
          (set-style paragraph start end style)
          (wrap-paragraph self '() paragraph)
          (when (not layout-scrollee?)
            (invalidate-paragraph self paragraph))))
      (set-modified? self #t)
      (when layout-scrollee?
        (let ((single-client (single-client self)))
          (when single-client
            (layout-scrollee single-client)
            (invalidate-view single-client))))))
  
  
  (method public (modify-style self range <Range$Cell$> proc)
    (for-each-range self range
      (lambda (line paragraph start end)
        (modify-style paragraph start end proc)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph))))
  
  
  (method public (remove-style self range)
    (apply-style self default-style (get-start range) (get-end range)))
  
  
  (method public (push-style self range style-name)
    (modify-style self range
      (lambda (s)
        (and (not (inherits? s style-name))
             (let ((style (extend s)))
               (set-base style (cons style-name (get-base style)))
               style)))))
  
  
  (method public (pop-style self range style-name)
    (modify-style self range
      (lambda (s)
        (let ((base (get-base s)))
          (and (memq? style-name base)
               (let ((style (extend s)))
                 (set-base style (remove style-name (get-base style)))
                 style))))))
  
  
  (method public (set-text-alignment self range <Range$Cell$> alignment)
    (for-each-range self range
      (lambda (line paragraph start end)
        (set-text-alignment paragraph start end alignment)
        (wrap-paragraph self '() paragraph)))
    (set-modified? self #t)
    (let ((single-client (single-client self)))
      (when single-client
        (layout-scrollee single-client)
        (invalidate-view single-client))))
  
  
  (method public (set-text-font self range <Range$Cell$> font <Font>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (set-text-font paragraph start end font)
        (wrap-paragraph self '() paragraph)))
    (set-modified? self #t)
    (let ((single-client (single-client self)))
      (when single-client
        (layout-scrollee single-client)
        (invalidate-view single-client))))
  
  
  (method public (set-text-style self range <Range$Cell$> style <Style>)
    (let ((style (intern-style self style)))
      (for-each-range self range
        (lambda (line paragraph start end)
          (set-style paragraph start end style)
          (wrap-paragraph self '() paragraph)
          (invalidate-paragraph self paragraph)))
      @should-not-be-done-for-code-text (set-modified? #t)))
  
  
  (method public (set-text-color self range <Range$Cell$> color <Color>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (set-text-color paragraph start end color)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph)))
    @should-not-be-done-for-code-text (set-modified? #t))
  
  
  (method public (set-highlight-color self range <Range$Cell$> color <Color+>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (set-highlight-color paragraph start end color)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph)))
    @should-not-be-done-for-code-text (set-modified? #t))
  
  
  (method public (set-frame-color self range <Range$Cell$> color <Color+>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (set-frame-color paragraph start end color)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph)))
    @should-not-be-done-for-code-text (set-modified? #t))
  
  
  (method public (toggle-bold self range <Range$Cell$>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (toggle-bold paragraph start end)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph))))
  
  
  (method public (toggle-italic self range <Range$Cell$>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (toggle-italic paragraph start end)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph))))
  
  
  (method public (toggle-underline self range <Range$Cell$>)
    (for-each-range self range
      (lambda (line paragraph start end)
        (toggle-underline paragraph start end)
        (wrap-paragraph self '() paragraph)
        (invalidate-paragraph self paragraph))))
  
  
  (method public (for-each-paragraph self proc (start: start 0) (end: end (get-limit self)))
    (let ((start (or start 0))
          (end (or end (get-limit self)))
          (paragraphs (get-paragraphs self)))
      (loop (for line from start to end)
            (proc line (element paragraphs line)))))
  
  
  ;;;
  ;;;; Formats
  ;;;
  
  
  (method public (get-default-format self)
    default-format)
  
  
  (method public (set-default-format self value)
    (for-each-paragraph self
      (lambda (line <fx> paragraph <Paragraph>)
        (when (eq? (get-format paragraph) default-format)
          (set-format paragraph value))))
    (set! default-format value)
    (set-domain default-format formats)
    (intern-format self (copy default-format)))
  
  
  (method public (get-formats-domain self)
    formats)
  
  
  (method public (get-named-formats self)
    (get-index formats))
  
  
  (method public (get-interned-formats self)
    (get-interned formats))
  
  
  (method public (symbolize-format self format)
    (symbolize formats format))
  
  
  (method public (add-format self name pref-format) <Format>
    (let ((format (extend pref-format)))
      (register-exemplar name format formats)))
  
  
  (method public (locate-format self name/format (error?: error? #t)) <Format>
    (if (is? name/format Format)
        name/format
      (locate formats name/format error?: error?)))
  
  
  (method public (intern-format self format) <Format>
    (intern formats format))
  
  
  (method (reference-format self formats reference)
    (if (symbol? reference)
        (locate-format self reference)
      (element formats reference)))
  
  
  ;;;
  ;;;; Styles
  ;;;
  
  
  (method public (get-default-style self)
    default-style)
  
  
  (method public (set-default-style self value)
    (set! default-style value)
    (set-domain default-style styles)
    (intern-style self (copy default-style)))
  
  
  ;; temp quicky necessary because in an empty text the first
  ;; paragraph takes its style information from the default style
  (method public (patch-default-style-height self)
    (when (text-empty? self)
      (let ((paragraph (get-paragraph self 0))
            (height (get-height (get-metrics (get-font default-style)))))
        (set-row-height paragraph height)
        (set-height paragraph height)
        (set-height (get-line paragraph 0) height))))
  
  
  (method public (get-styles-domain self)
    styles)
  
  
  (method public (get-named-styles self)
    (get-index styles))
  
  
  (method public (get-interned-styles self)
    (get-interned styles))
  
  
  (method public (symbolize-style self style)
    (symbolize styles style))
  
  
  (method public (add-style self name pref-style) <Style>
    (let ((style (extend pref-style)))
      (register-exemplar name style styles)))
  
  
  (method public (locate-style self name/style (error?: error? #t)) <Style>
    (if (is? name/style Style)
        name/style
      (locate styles name/style error?: error?)))
  
  
  (method public (intern-style self style) <Style>
    (intern styles style))
  
  
  (method (reference-style self styles reference)
    (if (symbol? reference)
        (locate-style self reference)
      (element styles reference)))
  
  
  (definition (fix-view-style-parent paragraph)
    (let ((runs (get-runs paragraph)))
      (for-each (lambda (run)
                  (let ((style (get-style run)))
                    (when (is? style View-Style)
                      (let ((view (get-view style)))
                        (set-parent view paragraph)))))
                runs)))
  
  
  (method public (comment-style? self style)
    (comment-style? syntax style))
  
  
  (method public (string-style? self style)
    (string-style? syntax style))
  
  
  (method public (textual-style? self style)
    (textual-style? syntax style))
  
  
  ;;;
  ;;;; Runs
  ;;;
  
  
  (definition (run-infos->string infos)
    (let ((output (open-output-string)))
      (for-each (lambda (info)
                  (let ((string (car info)))
                    (format output "{a}" string)))
                infos)
      (get-output-string output)))
  
  
  (method (make-runs self string <string> styles infos)
    (let ((offset 0))
      (map (lambda (info)
             (let ((str (car info)))
               (bind-optionals ((rank #f)) (cdr info)
                 (let* ((limit (+ offset (cast <fx> (cardinality str))))
                        (subseq (subseq! string offset limit))
                        (style (if (not rank) (get-default-style self) (reference-style self styles rank))))
                   (set! offset limit)
                   (new Run subseq style)))))
           infos)))
  
  
  ;;;
  ;;;; Height
  ;;;
  
  
  (method public (get-default-height self) <fx>
    (get-height default-style))
  
  
  (method public (get-height-at self pos <Cell>) <fx>
    (get-height (get-line-at (get-paragraph self (get-line pos)) (get-col pos))))
  
  
  ;;;
  ;;;; Width
  ;;;
  
  
  (method public (compute-width self) <fx>
    (let ((width 0))
      (for-each-paragraph self
        (lambda (line <fx> paragraph <Paragraph>)
          (let ((w (compute-width paragraph)))
            (when (> w width)
              (set! width w)))))
      width))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method public inline (new-range self start end)
    (new Range$Cell$ start end))
  
  
  (method public (range-strings self range <Range$Cell$>) <list>
    (let ((start (get-start range))
          (end (get-end range)))
      (if (= (get-line start) (get-line end))
          (list (subseq (paragraph-string self (get-line start)) (get-col start) (get-col end)))
        (let ((dest (new List-Factory)))
          (put dest (subseq (paragraph-string self (get-line start)) (get-col start)))
          (put-sequence dest (map (~ paragraph-string self) (naturals (+ (get-line start) 1) (get-line end))))
          (put dest (subseq (paragraph-string self (get-line end)) 0 (get-col end)))
          (get-output dest)))))
  
  
  (method public (range-first-string self range <Range$Cell$>) <string>
    (first (range-strings self range)))
  
  
  ;;;
  ;;;; Offset
  ;;;
  
  
  (method (position-offset self pos <Cell>) <fx>
    (let ((line (get-line pos))
          (col (get-col pos))
          (offset 0))
      (loop (for n from 0 below line)
            (increase! offset (+ (paragraph-length self n) 1)))
      (+ offset col)))
  
  
  (method (offset-position self offset <fx>) <Cell>
    (let ((scan 0))
      (continuation-capture
        (lambda (return)
          (for-each-paragraph self
            (lambda (line <fx> paragraph <Paragraph>)
              (let ((next (+ scan (cardinality (get-string paragraph)) 1)))
                (if (> next offset)
                    (continuation-return return (new Cell line (- offset scan)))
                  (set! scan next)))))))))
  
  
  ;;;
  ;;;; Color
  ;;;
  
  
  (method public (get-format-at self pos <Cell>) <Format>
    (let ((paragraph (get-paragraph self (get-line pos))))
      (get-format paragraph)))
  
  
  (method public (get-run-at self pos <Cell>) <Run+>
    (let ((paragraph (get-paragraph self (get-line pos))))
      (get-run paragraph (get-col pos))))
  
  
  (method public (get-style-at self pos <Cell>) <Style>
    (let ((run (get-run-at self pos)))
      (if (not run)
          (get-default-style self)
        (get-style run))))
  
  
  ;; until style at col 0 is cleanly integrated
  (method public (get-style-at* self pos <Cell>) <Style>
    (let ((col (get-col pos))
          (line (get-line pos)))
      (if (and (= col 0)
               (> line 0))
          (let ((previous (- line 1)))
            (get-style-at self (new Cell previous (paragraph-length self previous))))
        (get-style-at self pos))))
  
  
  (method public (uncolorize-row self line <fx>) <void>
    (let ((paragraph (get-paragraph self line)))
      (when (remove-coloring paragraph default-style)
        (invalidate-paragraph self paragraph))))
  
  
  (method public (colorize self color <Color> start <Cell> (end #f))
    (when (not end)
      (set! end (new Cell (get-line start) (paragraph-length self (get-line start)))))
    (set-text-color self (new Range$Cell$ start end) color))
  
  
  (method public (fill self color <Color> pos <Cell>) <void>
    (let ((range (new Range$Cell$ pos (+ pos 1))))
      (set-highlight-color self range color)))
  
  
  (method public (unfill self pos <Cell>) <void>
    (let ((range (new Range$Cell$ pos (+ pos 1))))
      (set-highlight-color self range #f)))
  
  
  ;;;
  ;;;; Colorizer
  ;;;
  
  
  (method public (new-colorizer self)
    (new Text-Colorizer self))
  
  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method (line->view self line <fx>) <fx>
    (let ((par (get-paragraph self line)))
      (get-v (get-position par))))
  
  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public (text-regular-search self search-context (start: start #f) (end: end #f) (reversed?: reversed? #f))
    (let ((match-test (get-match-test self))
          (constituent-test (get-constituent-test self))
          (search-set (->search-set search-context)))
      ;; quick solution to multi-line string search
      (if (some? (lambda (context)
                   (search (get-target context) "\n"))
                 (get-contexts search-set))
          (let ((content (get-string-content self)))
            (let ((found (regular-search content search-set match-test: match-test constituent-test: constituent-test start: (position-offset self start) reversed?: reversed?)))
              (and found
                   (bind (from . to) found
                     (cons (offset-position self from) (offset-position self to))))))
        (let ((pos (or start (if reversed? (text-ending self) (text-beginning self))))
              (end (or end (if reversed? (text-beginning self) (text-ending self)))))
          (let ((line (get-line pos))
                (col (get-col pos))
                (end-line (get-line end))
                (end-col (get-col end)))
            (let (iter (n line) (start col))
              (if (if reversed? (>= n end-line) (<= n end-line))
                  (let ((string (paragraph-string self n))
                        (end (if (= n end-line) end-col #f)))
                    (let ((found (regular-search string search-set match-test: match-test constituent-test: constituent-test start: start end: end reversed?: reversed?)))
                      (if found
                          (bind (from . to) found
                            (cons (new Cell n from) (new Cell n to)))
                        (iter (if reversed? (- n 1) (+ n 1)) #f))))
                #f)))))))

  
  (method public (text-regular-search-all self search-context (start: start #f) (end: end #f))
    (let ((queue (new-queue))
          (match-test (get-match-test self))
          (constituent-test (get-constituent-test self))
          (search-set (->search-set search-context))
          (start (or start (text-beginning self)))
          (end (or end (text-ending self))))
      (for-each-range self (new-range self start end)
        (lambda (line paragraph <Paragraph> start end)
          (let ((str (substring (get-string paragraph) start end)))
            (for-each (lambda (found)
                        (bind (from . to) found
                          (enqueue queue (cons (new Cell line (+ start from)) (new Cell line (+ start to))))))
                      (regular-search-all str search-set match-test: match-test constituent-test: constituent-test)))))
      (queue-list queue)))
  
  
  (method public (text-search self context . rest)
    (let ((found (apply text-regular-search self context rest)))
      (if found
          (car found)
        #f)))
  
  
  (method public (text-search-all self context . rest)
    (map car (apply text-regular-search-all self context rest)))
  
  
  (method package (search-context self obj
                                    (whole-words?: whole-words? #f)
                                    (ignore-case?: ignore-case? #f))
    (cond ((is? obj Search-Context) obj)
          ((is? obj Search-Set) (car (get-contexts obj)))
          (else (make-search-context (or obj "")
                                     whole-words?: whole-words?
                                     ignore-case?: ignore-case?
                                     match-test: (get-match-test self)
                                     constituent-test: (get-constituent-test self)))))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor self (context: context #f))
    (new jazz.text.descriptors:Text-Model-Descriptor))))
