;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Marcel Cote
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.text.Text-View jazz


(import (jazz.action)
        (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.document)
        (jazz.event)
        (jazz.exemplar)
        (jazz.feedback)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.locale)
        (jazz.markup)
        (jazz.menu)
        (jazz.outline)
        (jazz.platform)
        (jazz.process)
        (jazz.profile)
        (jazz.skin)
        (jazz.text)
        (jazz.text.preferences)
        (jazz.ui)
        (jazz.ui.skin)
        (jazz.undoer)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(class Text-View extends Outline-View implements Document
  
  
  ;; the text content automaticaly saved in a canonical form when the text is visually edited
  (property protected text-content              initialize #f accessors explicit)
  (property protected selectable?               initialize #t accessors generate)
  (property protected editable?                 initialize #t accessors generate)
  (property protected accepts-returns?          initialize #t accessors generate)
  (property protected focus-selects-all?        initialize #f accessors generate)
  (property protected show-unfocused-selection? initialize #t accessors generate)
  (property protected force-tab-navigate?       initialize #f accessors generate)
  
  
  (slot protected syntax                 initialize #f accessors generate)
  (slot protected document-controller    initialize #f)
  (slot protected selection-anchor       initialize #f)
  (slot protected locked-anchor?         initialize #f)
  (slot protected mouse-selecting?       initialize #f)
  (slot protected selection-mode         initialize 'char)
  (slot protected selection-inhibit?     initialize #f)
  (slot protected special-mode           initialize #f)
  (slot protected virtual-h              initialize #f)
  (slot protected caret-pulse            initialize #f)
  (slot protected caret-pulse?           initialize #t)
  (slot protected caret-visible?         initialize #f)
  (slot protected completion-active?     initialize #f getter generate)
  (slot protected completion-unique?     initialize #f)
  (slot protected mark                   initialize #f accessors generate)
  (slot protected marks                  initialize '())
  (slot protected previous-position      initialize #f)
  (slot protected autoscroll-pulse       initialize #f)
  (slot protected mouse-copy-selection   initialize #f)
  (slot protected mouse-copy-destination initialize #f)
  (slot protected highlights             initialize '() getter generate)
  (slot protected text-actions           initialize #f)
  (slot protected text-listeners         initialize '())
  
  
  (form
    (<install> background: {Color Text-Background}))

  
  (method override (verify-reload self));;abstract
  (method override (current-history-item self));;abstract
  
  
  (method protected virtual (preferences self)
    (new jazz.text.preferences:Text-Preferences))
  
  
  (method override (new-model self)
    (new Text-Model))
  
  
  (method override (setup-model self mdl)
    (nextmethod self mdl)
    (when syntax
      (set-model syntax mdl))
    (let ((pref (preferences self)))
      (when pref
        (let ((base (or (get-base-format model) (get-base-format pref))))
          (add-format self 'Base base)
          (set-default-format model (intern-format model (or (get-default-format pref) (new Format base: 'Base)))))
        (let ((base (or (get-base-style model) (get-base-style pref))))
          (add-style self 'Base base)
          (set-default-style model (intern-style model (or (get-default-style pref) (new Text-Style base: 'Base)))))
        (register-children (child pref 'styles) (get-styles model))
        (register-children (child pref 'formats) (get-formats model)))))
  
  
  ;; kinda quicky
  (method package (setup-style self base)
    (add-style self 'Base base)
    (set-default-style model (intern-style model (new Text-Style base: 'Base))))
  
  
  (method override (prepare self rest)
    (set! selection (new Text-Mark self (empty-selection self) strict?: #f change-proc: (~ selection-change self)))
    (set! selection-anchor (new Text-Mark self (empty-selection self) strict?: #f))
    (nextmethod self rest))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set! syntax (new-syntax self))
    (set-syntax model syntax)
    (let ((pref (preferences self)))
      (when pref
        (let ((background (get-background pref)))
          (when background
            (set-background self (symbolic-color background))))
        (set! caret-pulse? (get-pulse-caret? pref)))))
  
  
  (method override (install-child self form creator creator-branch restore-form)
    (case (get-model form)
      ;; until Form <-> Node unification
      ((text) (set-text model (form->node form)))
      (else (nextmethod self form creator creator-branch restore-form))))
  
  
  (method override (destroy self)
    (show-text-cursor self)
    (nextmethod self))
  
  
  (method protected virtual (new-syntax self) <Text-Syntax>
    (new Text-Syntax model))
  
  
  (method override (get-text-view self) <Text-View>
    self)
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method package (get-paragraphs self) <Axis>
    (get-paragraphs model))
  
  
  (method package (set-paragraphs self lst)
    (set-paragraphs model lst))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method override (host-workspaces self)
    '(text))
  
  
  (method override (install-in-host self host)
    (nextmethod self host)
    (install-in-host (get-document-controller self) host))
  
  
  (method override (split-view self)
    (let ((host (new-frame (class-of self) host-workspace: (get-workspace (get-host self)) host-visible?: #f)))
      (let ((view (get-guest host)))
        (set-model view model)
        (change-moniker (get-document-controller view) (get-moniker self))
        (scroll-to view (get-scrolled-position self))
        (set-selection view (get-selection self) ensure-displayed?: #f)
        (update-status view)
        (focus-host host)
        host)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions self)
    (cons (find-actions 'text)
          (nextmethod self)))
  
  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method override (get-document-controller self)
    (unless document-controller
      (set! document-controller (new-document-controller self)))
    document-controller)
  
  
  (method override (new-document-controller self)
    (new Document-Controller self tool?: (default-tool? self) console?: (default-console? self)))
  
  
  (method protected virtual (default-tool? self)
    #f)
  
  
  (method protected virtual (default-console? self)
    #f)
  
  
  (method override (save self)
    (save (get-document-controller self)))
  
  
  (method override (save-as self)
    (save-as (get-document-controller self)))
  
  
  (method public virtual (save-all self)
    (save-all (get-document-controller self)))
  
  
  (method public (get-moniker self)
    (get-moniker (get-document-controller self)))
  
  
  (method public (set-moniker self moniker)
    (set-moniker (get-document-controller self) moniker))
  
  
  (method override (get-modified? self)
    (get-modified? (get-document-controller self)))
  
  
  (method override (set-modified? self state)
    (set-modified? (get-document-controller self) state))
  
  
  (method package (get-read-only? self)
    (get-read-only? (get-document-controller self)))
  
  
  (method package (write-allowed? self)
    (and editable? (write-allowed? (get-document-controller self))))
  
  
  (method package (update-status self)
    (update-status (get-document-controller self)))
  
  
  (method package (update-moniker-time self moniker)
    (update-moniker-time (get-document-controller self) moniker))
  
  
  (method override (confirm-close self . rest)
    (when (last-client? self)
      (confirm-close (get-document-controller self))))
  
  
  (method override (tool-update self tool?)
    )
  
  
  (method override (console-update self console?)
    )

  
  (method override (revert-saved self)
    (revert-saved (get-document-controller self)))

  
  (method override (compare-saved self)
    (compare-saved (get-document-controller self)))
  
  
  (method override (install-scroller? self)
    #t)
  
  
  ;;;
  ;;;; Input/Output
  ;;;
  
  
  (method public (get-string-content self) <string>
    (get-string-content model))
  
  
  (method public (set-string-content self content <string>) <void>
    (set-string-content model content))
  
  
  (method public (empty-text self)
    (empty-text model))
  
  
  (method override (default-extension self)
    (default-extension syntax))
  
  
  (method override (extensions self)
    (extensions syntax))
  
  
  (method override (load-content self moniker)
    (load-content model moniker))
  
  
  (method override (save-content self moniker)
    (save-content model moniker))
  
  
  (method override (save-to self moniker)
    (save-to model moniker))
  
  
  (method override (reload-moniker self moniker)
    (let ((line (get-line (get-start self))))
      (reload-moniker model moniker)
      (set-caret self (new Cell (min line (cardinality (get-paragraphs self))) 0))
      (set-modified? model #f)))
  
  
  (method override (compare-moniker self moniker)
    (compare-moniker model moniker))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (get-text-content self)
    text-content)
  
  
  (method public (set-text-content self value)
    (set! text-content value)
    (set-content model text-content))
  
  
  ;;;
  ;;;; Explorer
  ;;;
  
  
  (method public virtual (explorer-class self)
    (explorer-class syntax))
  
  
  (method (on-select-outer self evt)
    (select-outer self))
  
  
  (method protected virtual (select-outer self)
    (end-completion self)
    (let ((expl <Text-Explorer> (new (explorer-class self) model range: (get-selection self))))
      (with-safe-explore
        (lambda ()
          (when (outer-expr expl uniform-style?: #t)
            (reset-mode self)
            (set-selection self (get-range expl)))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (show-text-cursor self)
    (update-caret self)
    (when (and focus-selects-all? (not (activating-window?)))
      (focus-select-all self)
      (when (and (eq? (event-type) 'mouse) (eq? (get-mouse-down-view) self))
        (set! selection-inhibit? #t)))
    (when (has-selection? self)
      (invalidate-selection self (get-selection self)))
    (invalidate-non-showed-highlights self))
  
  
  (method override (focus-lose self)
    (nextmethod self)
    (set! selection-inhibit? #f)
    (show-text-cursor self)
    (end-completion self)
    (hide-caret self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (when (has-selection? self)
      (invalidate-selection self (get-selection self)))
    (invalidate-non-showed-highlights self))
  
  
  (method override (focus-activate self)
    (focus-document self))
  
  
  (method override (focus-document self)
    (acquire-focus self))
  
  
  (method protected virtual (focus-select-all self)
    (select-all self))
  
  
  (method override (mouse-leave self)
    (show-text-cursor self))
  
  
  (method override (on-backspace-press self evt)
    (parameterize ((event-type 'keyboard))
      (backspace-press self #f word?: (get-property evt word?:))))
  
  
  (method (on-delete-press self evt)
    (delete-press self #f word?: (get-property evt word?:)))
  
  
  (method (on-numbered self evt)
    (unimplemented 'on-numbered))
  
  
  (method (on-bulleted self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (toggle-bulleted model line))))
  
  
  (method (on-decrease-indent self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (indent-paragraph model line paragraph -32))))
  
  
  (method (on-increase-indent self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (indent-paragraph model line paragraph 32))))
  
  
  (method (on-justify self evt)
    (let ((justification (get-property evt justification:)))
      (for-each-selected-paragraph self
        (lambda (line paragraph)
          (set-justification model line paragraph justification)))))
  
  
  (method (on-alignment self evt)
    (let ((alignment (get-property evt alignment:)))
      (set-text-alignment model (get-selection self) alignment)))
  
  
  (method (on-text-style self evt)
    (let ((style (get-property evt style:)))
      (set-selection-format/style self style)))
  
  
  (method (on-text-font self evt)
    (let ((font (get-property evt font:)))
      (set-selection-font-name self font)))
  
  
  (method (on-text-size self evt)
    (let ((size (get-property evt size:)))
      (set-selection-point-size self size)))
  
  
  (method (on-text-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color Black})))
      (set-text-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-text-color self evt)
    (pick-text-color (get-sender evt)))
  
  
  (method (on-highlight-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color White})))
      (set-highlight-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-highlight-color self evt)
    (pick-highlight-color (get-sender evt)))
  
  
  (method (on-frame-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color White})))
      (set-frame-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-frame-color self evt)
    (pick-frame-color (get-sender evt)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-text-listener self listener)
    (set! text-listeners (add-listener listener text-listeners)))
  
  
  (method public (remove-text-listener self listener)
    (set! text-listeners (remove-listener listener text-listeners)))
  
  
  (method public (text-listener? self object)
    (listener? object text-listeners))
  
  
  (method public (process-selection-change self)
    (when text-listeners
      (let ((evt (make-event Text-Event :selection-change self)))
        (for-each (lambda (listener)
                    (invoke listener self evt))
                  text-listeners))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method package (model-update self)
    (remove-all-text-actions self))
  
  
  (method protected (last-client? self)
    (= (length (get-clients model)) 1))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press self evt)
    (hide-text-cursor self)
    (char-press self (translate-key (syntax-at syntax (get-start self)) (get-key evt))))

  
  (method override (backspace-press self evt (word?: word? #f))
    (insert-char/backspace self #\backspace word?: word?)
    (when completion-active?
      (complete-at self (get-start self))))
  
  
  (method (delete-press self key (word?: word? #f))
    (delete-action self word?))
  
  
  (method (on-delete-char self evt)
    (delete-char self))
  
  
  (method (on-delete-word self evt)
    (delete-word self))
  
  
  (method (on-kill-line self evt)
    (define (kill-range)
      (let* ((pos (selection-tail self 'forward))
             (line (get-line pos))
             (col (get-col pos))
             (len (paragraph-length self line)))
        (if (= col len)
            (if (= line (get-limit self))
                #f
              (new Range$Cell$ pos (new Cell (+ line 1) 0)))
          (new Range$Cell$ pos (new Cell line len)))))
    
    (let ((range (kill-range)))
      (when range
        (let ((string (get-string self range)))
          (define (replace-clipboard)
            (set-clipboard-text string)
            (add-clipboard (current-application))
            (set! special-mode 'kill-line))
          
          (define (append-clipboard actual)
            (set-clipboard-text (string-append actual string)))
      
          (if (neq? special-mode 'kill-line)
              (replace-clipboard)
            (let ((actual (get-clipboard-text)))
              (if (not actual)
                  (replace-clipboard)
                (append-clipboard actual))))
          (delete-range model range)))))
  
  
  (method (on-open-line self evt)
    (insert-newline self)
    (left-arrow-move self #f #f))
  
  
  (method override (return-press self evt)
    (when accepts-returns?
      (insert-newline self)))


  (method override (escape-press self evt)
    (remove-completion self))
  
  
  (method override (tab-press self evt)
    (cond ((has-ambiguous-completion? self)
           (end-completion self))
          ((or (not accepts-returns?) force-tab-navigate?)
           (navigate-view self (get-shift? evt)))
          (else
           (if (has-completion? self)
               (end-completion self)
             (insert-char self #\tab)))))
  
  
  (method public virtual (char-press self key)
    (if (auto-complete? self)
        (auto-complete self key)
      (insert-char self key)))
  
  
  (method (reset-mode self (keep: keep #f))
    (set! special-mode #f)
    (unless (eq? keep 'virtual)
      (set! virtual-h #f)))
  
  
  (method package (on-insert self evt)
    (case (get-kind evt)
      ((:char) (call-key-press self evt))
      ((:string) (insert-string self (get-property evt content:)))))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (cond-expand
    (cocoa
      (method public (hide-text-cursor self)
        ))
    (else
     (method public (hide-text-cursor self)
       @commented-until-working-well
       (when (and player (view-enabled? self) selectable? editable? (mouse-over? self))
         (hide-cursor player)))))
  
  
  (cond-expand
    (cocoa
      (method public (show-text-cursor self)
        ))
    (else
     (method public (show-text-cursor self)
       @commented-until-working-well
       (when (and player (view-enabled? self) selectable? editable?)
         (show-cursor player)))))
  
  
  (method override (cursor-update self evt)
    (let ((view (get-position evt)))
      (show-text-cursor self)
      (when (and (view-enabled? self) (mouse-copyable? self))
        (if (mouse-copy? self evt)
            (set-cursor :finger)
          (let ((pos (view->text self view)))
            (let ((par (get-paragraph self (get-line pos))))
              (if (< (get-h view) (paragraph-left par))
                  (set-cursor :left-arrow)
                (let ((style (get-style-at model pos)))
                  (if (is? style Link-Style)
                      (set-cursor :finger)
                    (set-cursor :ibeam))))))))))
  
  
  ;;;
  ;;;; Caret
  ;;;
  
  
  (method package (show-caret self)
    (define (pulse-caret)
      (when editable?
        (set! caret-visible? (not caret-visible?))
        (invalidate-caret self)))
    
    (when (and editable? (not caret-visible?) (has-focus? self))
      (set! caret-visible? #t)
      (when (and caret-pulse? (not caret-pulse))
        (set! caret-pulse (new Pulse 'caret 0.5 pulse-caret)))
      (invalidate-caret self)))
  
  
  (method package (hide-caret self)
    (when editable?
      (when caret-pulse
        (close caret-pulse))
      (set! caret-visible? #f)
      (set! caret-pulse #f)
      (invalidate-caret self)))
  
  
  (method (without-caret self proc)
    (if (not editable?)
        (proc)
      (let ((shown? caret-visible?))
        (unwind-protect
            (begin
              (hide-caret self)
              (proc))
          (when shown?
            (update-caret self))))))
  
  
  (method package virtual (update-caret self)
    (when (and player editable? (has-focus? self))
      (if (has-selection? self)
          (hide-caret self)
        (show-caret self))))
  
  
  (method (invalidate-caret self)
    (when editable?
      (let ((rect (caret-rect self (get-caret self))))
        (when rect
          (invalidate-rect self rect)))))
  
  
  (method (caret-rect self caret-pos <Cell+>)
    (and caret-pos
         (let* ((pos <Point> (text->view self caret-pos))
                (par <Paragraph> (get-paragraph self (get-line caret-pos)))
                (lne (get-line-at par (get-col caret-pos)))
                (run (get-run par (get-col caret-pos)))
                (width <fx> (or (get-caret-width (get-skin self)) 1))
                (height <fx> (if run (get-height run) (get-height par)))
                (line-height <fx> (get-height lne))
                (top <fx> (+ (get-v pos)
                             (if run
                                 (justify-element (get-style run) height line-height)
                               (- line-height height)))))
           (new Rect (get-h pos) (- top 1) (+ (get-h pos) width) (+ top height 1)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (when selectable?
      (let ((view (get-position evt)))
        (let ((focus? (has-focus? self))
              (mouse-copy? (mouse-copy? self evt))
              (pos (view->text self view)))
          (unless (is? (get-style-at model pos) Link-Style)
            (end-completion self)
            (unless mouse-copy?
              (acquire-focus self))
            (when pos
              (acquire-capture self)
              (unlock-anchor self)
              (set! mouse-selecting? #t)
              (set! selection-mode 'char)
              (unless (or (get-shift? evt) (not focus?))
                (reset-caret self pos generate-event?: #f))
              (let ((par (get-paragraph self (get-line pos))))
                (if (< (get-h view) (paragraph-left par))
                    (set-selection self (selection-line self (get-line pos)) generate-event?: #f set-anchor?: #t)
                  (when (or focus? (not focus-selects-all?))
                    (if (get-shift? evt)
                        (change-selection self pos generate-event?: #f)
                      (set-caret self pos generate-event?: #f))
                    (update-caret self)))
                (reset-mode self)
                (set! previous-position pos))))))))
  
  
  (method protected virtual (mouse-copyable? self)
    selectable?)

  
  (method override (mouse-copy self event destination)
    (if (not selectable?)
        (nextmethod self event destination)
      (set! mouse-copy-selection (get-selection self))
      (set! mouse-copy-destination destination)
      (call-mouse-down self event)
      #t))
  
  
  (method override (drag-move self evt)
    (when mouse-selecting?
      (drag-move-action self (get-position evt))))
  
  
  (method (drag-move-action self view)
    (drag-select self view #f)
    (when (get-scroller self)
      (setup-autoscroll self (calculate-autoscroll-amount self view))))
  
  
  (method override (drag-up self evt . rest)
    (if mouse-selecting?
        (let ((view     (get-position evt))
              (alt?     (get-alt? evt))
              (control? (get-control? evt))
              (shift?   (get-shift? evt))
              (appl     (current-application)))
          (release-capture self)
          (kill-autoscroll self)
          (drag-select self view #t)
          (set! mouse-selecting? #f)
          (set! previous-position #f)
          (update-caret self)
          (set! selection-mode 'char)
          (unless alt?
            (process-selection-change self))
          @cant-replace-a-selection-by-pasting!
          (mouse-select-copy
            (lambda ()
              (get-selected-string)))
          (if mouse-copy-selection
              (let ((range (if (has-selection? self) (get-selection self) (expr-range self (get-start self)))))
                (if (or (not range)
                        (empty? range))
                    (set-selection self mouse-copy-selection ensure-displayed?: #f)
                  (let ((copy (get-string self range)))
                    (set-selection self mouse-copy-selection ensure-displayed?: #f)
                    (mouse-insert mouse-copy-destination copy))))
            (ensure-displayed self))
          (set! selection-inhibit? #f)
          (set! mouse-copy-selection #f)
          (set! mouse-copy-destination #f)
          (when (and (not alt?) control? (not shift?))
            (let ((recorder (get-recorder appl)))
              (when recorder
                (jazz.recorder:play-current-recording recorder))))
          (update-focus-actions appl))
        ;; link
      (when (view-enabled? self)
        (let* ((pos (view->text self (get-position evt)))
               (style (get-style-at model pos)))
          (when (is? style Link-Style)
            (let (@convert (anchor (get-anchor style))
                  (action (get-action style)))
              (define (invoke-action action pos style)
                (cond ((is? action Event-Handler)
                       (invoke action self (apply make-event Event :link self (get-properties action))))
                      (else
                       (action self pos style))))
              
              @convert
              (define (goto-anchor anchor)
                (for-each-heading model
                  (lambda (name heading line string)
                    (when (equal? string anchor)
                      (set-selection self (new Range$Cell$
                                            (new Cell line 0)
                                            (new Cell line (cardinality string))))))))
              
              (cond (action
                     (invoke-action action pos style))
                    @convert
                    (anchor
                     (goto-anchor anchor))
                    (else
                     (bell)))))))))
  
  
  (method (drag-select self view final?)
    (let ((pos (view->text self view)))
      ;; patch to manage the line selection border
      (when (and pos
                 (< (get-h view) (paragraph-left (get-paragraph self (get-line pos))))
                 (cell>=? pos (get-end-anchor self)))
        (set! pos (get-end (selection-line self (get-line pos)))))
      (when (and pos #t @parameterized-fix-me (/= pos previous-position))
        (let* ((range (selection-range self pos))
               (parts (range-difference range (get-selection self)))
               (player (get-player self)))
          (with-transformation-surface self
            (lambda (surface)
              (change-selection self pos generate-event?: #f)
              (with ((region (multi-part-region self parts (lambda (rect) (logical->device surface rect)))))
                (when region
                  (if final?
                      (invalidate-region player region)
                    (redraw-window player region: region)
                    (set! previous-position pos))))))))))
  
  
  (method override (double-click self evt)
    (if selectable?
        (let ((view (get-position evt)))
          (let* ((pos (view->text self view))
                 (par (get-paragraph self (get-line pos))))
            (if (< (get-h view) (paragraph-left par))
                (select-paragraph self (get-line pos))
              (let ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos)))
                (with-safe-explore
                  (lambda ()
                    (when (outer-expr expl)
                      (set-selection self (get-range expl) set-anchor?: #t ensure-displayed?: #f))
                    (set! mouse-selecting? #t)
                    (set! selection-mode 'word)
                    (reset-mode self)
                    (set! previous-position pos)))))))
      (call-mouse-down self evt)))
  
  
  (method override (middle-mouse-down self evt)
    (unless (middle-mouse-paste
              (lambda (text)
                (paste-clipboard-string self text)))
      (mouse-down self evt)))
  
  
  (method public virtual (context-menu? self)
    #t)
  
  
  (method protected (context-menu-click self pos (move-caret: move-caret #f))
    (when (and (view-enabled? self) selectable? (context-menu? self))
      (acquire-focus self)
      (let ((text (view->text self pos)))
        (when (and (neq? move-caret 'never)
                   (or (eq? move-caret 'always) (< text (get-start self)) (>= text (get-end self))))
          (set-caret self (view->text self pos))
          (update-caret self)))))
  
  
  (method override (right-mouse-down self evt)
    (context-menu-click self (get-position evt)))
  
  
  (method override (context-menu self evt)
    (when (and (view-enabled? self) selectable? (context-menu? self))
      (let ((pos (get-position evt)))
        (let ((menu (get-context-menu self)))
          (when menu
            (track-popup-menu self menu pos))))))
  
  
  (method override (get-context-menu self)
    (text-menu (current-application) self))
  
  
  (method public (new-text-context-menu self)
    (let ((menu (new Text-Context-Menu)))
      (when (not editable?)
        (set-visible? (locate menu 'cut) #f)
        (set-visible? (locate menu 'paste) #f))
      (layout-menu menu)
      menu))
  
  
  (method public inline (new-range self start end)
    (new Range$Cell$ start end))
  
  
  (method (select-paragraph self line)
    (let ((limit (get-limit self)))
      (when (<= line limit)
        (let* ((par (get-paragraph self line))
               (len (get-length par)))
          (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell line len)))))))
  
  
  (method (selection-line self line <fx>)
    (let ((limit (get-limit self)))
      (and (<= line limit)
           (if (= line limit)
               (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length self line)))
             (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method (selection-range self pos)
    (let ((anchor (get-selection-anchor self)))
      (define (selection-range-from-anchor)
        (cond ((before? anchor pos)
               (new Range$Cell$ pos (get-end anchor)))
              ((after? anchor pos)
               (new Range$Cell$ (get-start anchor) pos))
              ;; else pos is inside anchor
              (else
               anchor)))
      
      (case selection-mode
        ((char)
         (selection-range-from-anchor))
        ((word)
         (if (inside? anchor pos)
             (selection-range-from-anchor)
           (let* ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos))
                  (kind (outer-expr expl explore-whitespace?: #f))
                  (range (and kind (get-range expl))))
             (cond ((not range)
                    (selection-range-from-anchor))
                   ((before? anchor pos)
                    (new Range$Cell$ (get-start range) (maximum (list (get-end range) (get-end anchor)))))
                   ;; else pos is after anchor
                   (else
                    (new Range$Cell$ (minimum (list (get-start range) (get-start anchor))) (get-end range)))))))
        (else (selection-range-from-anchor)))))
  
  
  (definition (range-difference x <Range$Cell$> y <Range$Cell$>)
    (let ((sx (get-start x))
          (ex (get-end x))
          (sy (get-start y))
          (ey (get-end y)))
      (if (and (= sx sy) (= ex ey))
          '()
        (cond ((= sx ex) (list y))
              ((= sy ey) (list x))
              ((or (< ex sy) (> sx ey))
               (list x y))
              (else
               (let ((parts (new List-Factory)))
                 (cond ((< sx sy) (put parts (new Range$Cell$ sx sy)))
                       ((> sx sy) (put parts (new Range$Cell$ sy sx))))
                 (cond ((< ex ey) (put parts (new Range$Cell$ ex ey)))
                       ((> ex ey) (put parts (new Range$Cell$ ey ex))))
                 (get-output parts)))))))
  
  
  (method (multi-part-region self parts transformer)
    (case (length parts)
      ((0) #f)
      ((1) (range-region self (car parts) transformer))
      ((2) (with ((region (range-region self (first parts) transformer)))
             (let ((union (range-region self (second parts) transformer)))
               (and region union
                 (begin
                   (combine-or! union region)
                   union)))))))
  
  
  (method (calculate-autoscroll-amount self view)
    (let* ((display (view->display self view))
           (size (get-size (get-display self)))
           (h (get-h display))
           (v (get-v display))
           (height (get-default-height self))
           (ah (cond ((< h 0) 8) ((> h (get-width size)) -8) (else 0)))
           (av (cond ((< v 0) height) ((> v (get-height size)) (- height)) (else 0))))
      (new Point ah av)))
  
  
  (method (setup-autoscroll self amount)
    (define (autoscroll-action)
      (drag-move-action self (mouse-position self))
      (scroll self amount)
      (update-view self))
    
    (if (nu=? amount {Point 0 0})
        (kill-autoscroll self)
      (when (not autoscroll-pulse)
        (set! autoscroll-pulse (new Pulse 'autoscroll 0.01 autoscroll-action delay: 0)))))
  
  
  (method (kill-autoscroll self)
    (close autoscroll-pulse)
    (set! autoscroll-pulse #f))
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method protected virtual (home-column self line col)
    (let ((column (get-column self line)))
      (if (= col 0)
          column
        0)))
  
  
  (method package (on-home self evt)
    (goto-home self (get-property evt document?:)
               (or locked-anchor? (get-property evt extend?:))))
  
  
  (method public (goto-home self document? extend?)
    (reset-mode self)
    (if document?
        (if extend?
            (change-selection self (text-beginning self))
          (set-caret self (text-beginning self)))
      (let* ((pos (selection-tail self 'backward))
             (line (get-line pos))
             (col (home-column self line (get-col pos)))
             (start (new Cell line col)))
        (if extend?
            (change-selection self start)
          (set-caret self start))
        (ensure-scrolled-left self))))
  
  
  (method package (on-end self evt)
    (goto-end self (get-property evt document?:)
              (or locked-anchor? (get-property evt extend?:))))
  
  
  (method public (goto-end self document? extend?)
    (reset-mode self)
    (if document?
        (if extend?
            (change-selection self (text-ending self))
          (set-caret self (text-ending self)))
      (goto-paragraph-end self extend-selection?: extend?)))
  
  
  (method public (goto-paragraph-end self (extend-selection?: extend-selection? #f))
    (let* ((pos (selection-tail self 'forward))
           (end (new Cell (get-line pos) (paragraph-length self (get-line pos)))))
      (if extend-selection?
          (change-selection self end)
        (set-caret self end))))
    
  
  (method (on-move self evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (arrow-move self evt)))


  (method public (arrow-move self evt)
    (let ((direction (get-property evt direction:))
          (extend? (or locked-anchor? (get-property evt extend?:)))
          (word? (get-property evt word?:))
          (scroll? (get-property evt scroll?:)))
      (case direction
        ((left) (left-arrow-move self extend? word?))
        ((right) (right-arrow-move self extend? word?))
        ((up) (up-arrow-move self extend? scroll?))
        ((down) (down-arrow-move self extend? scroll?)))))
  
  
  (method protected virtual (left-arrow-move self extend? word?)
    (textual-left-arrow-move self extend? word?))
  
  
  (method protected (textual-left-arrow-move self extend? word?)
    (reset-mode self)
    (if extend?
        (change-selection self (move-backward self (selection-tail self 'backward) word?))
      (if (empty-selection? self)
          (set-caret self (move-backward self (selection-tail self 'backward) word?))
        (set-caret self (get-start self)))))
  
  
  (method protected virtual (right-arrow-move self extend? word?)
    (textual-right-arrow-move self extend? word?))
  
  
  (method protected (textual-right-arrow-move self extend? word?)
    (reset-mode self)
    (if extend?
        (change-selection self (move-forward self (selection-tail self 'forward) word?))
      (if (empty-selection? self)
          (set-caret self (move-forward self (selection-tail self 'forward) word?))
        (set-caret self (get-end self)))))
  
  
  (method protected virtual (up-arrow-move self extend? scroll?)
    (textual-up-arrow-move self extend? scroll?))
  
  
  (method protected (textual-up-arrow-move self extend? scroll?)
    (reset-mode-on-anchor self)
    (let* ((pos (if extend? (selection-tail self 'backward) (get-start self)))
           (line (get-line pos))
           (col (get-col pos)))
      (cond (scroll?
              (let ((height (get-default-height self)))
                (scroll self (new Point 0 height))))
            (else
             (if (> line 0)
                 (move-verticaly self line col -1 'backward extend?)
               (unless extend? (reset-caret self (get-start self))))))))
  
  
  (method protected virtual (down-arrow-move self extend? scroll?)
    (textual-down-arrow-move self extend? scroll?))
  
  
  (method protected virtual (textual-down-arrow-move self extend? scroll?)
    (reset-mode-on-anchor self)
    (let* ((pos (if extend? (selection-tail self 'forward) (get-end self)))
           (line (get-line pos))
           (col (get-col pos)))
      (cond (scroll?
              (let ((height (get-default-height self)))
                (scroll self (new Point 0 (- height)))))
            (else
             (if (< line (get-limit self))
                 (move-verticaly self line col 1 'forward extend?)
               (unless extend? (reset-caret self (get-end self))))))))
  
  
  (method (on-widen-forward self evt)
    (let ((start (get-start self))
          (end (get-end self)))
      (let ((extend (next-word model end)))
        (set-selection self (new Range$Cell$ start extend)))))
  
  
  (method (reset-mode-on-anchor self)
    (if (and (has-selection? self) (nu=? (get-start self) (get-start-anchor self)) (nu=? (get-end self) (get-end-anchor self)))
        (reset-mode self)
      (reset-mode self keep: 'virtual)))
  
  
  (method (move-verticaly self line col inc direction shift?)
    (let* ((par     (get-paragraph self line))
           (h       (get-h (text->view self (new Cell line (if (has-selection? self) (get-col (selection-tail self 'forward)) col)))))
           (new-line (+ line inc))
           (new-par (get-paragraph self new-line))
           (new-len (paragraph-length self new-line))
           (new-end (get-h (text->view self (new Cell new-line new-len)))))
      (cond (virtual-h
             (move-caret self (new Cell new-line (min (get-col (view->text self (new Point virtual-h (get-top new-par)))) new-len)) direction shift?))
            ((> h new-end)
             (set! virtual-h h)
             (move-caret self (new Cell new-line new-len) direction shift?))
            (else
             (move-caret self (new Cell new-line (get-col (view->text self (new Point h (get-top new-par))))) direction shift?)))))
  
  
  (method protected virtual (move-caret self pos direction shift?)
    (unless (cell-displayed? self pos)
      (let ((height (get-default-height self)))
        (scroll self (new Point 0 (case direction ((forward) (- height)) ((backward) height))))))
    (if shift?
        (change-selection self pos)
      (set-caret self pos)))
  
  
  (method (on-backward-compound self evt)
    (with-safe-explore
      (lambda ()
        (let ((extend? (get-property evt extend?:)))
          (backward-compound self extend?: extend?)))))
  
  
  (method (on-forward-compound self evt)
    (with-safe-explore
      (lambda ()
        (let ((extend? (get-property evt extend?:)))
          (forward-compound self extend?: extend?)))))
  
  
  (method (on-upward-compound self evt)
    (upward-compound self))
  
  
  (method (on-downward-compound self evt)
    (downward-compound self))
  
  
  (method protected virtual (backward-compound self (extend?: extend? #f))
    (left-arrow-move self extend? #t))
  
  
  (method protected virtual (forward-compound self (extend?: extend? #f))
    (right-arrow-move self extend? #t))
  
  
  (method protected virtual (upward-compound self)
    (up-arrow-move self #f #t))
  
  
  (method protected virtual (downward-compound self)
    (down-arrow-move self #f #t))

  
  (method (on-transpose-word self evt)
    (transpose-word self))
  
  
  (method public (transpose-movements self forward backward)
    (if (has-selection? self)
        (bell)
      (with-atomic-undo (get-undoer model)
        (lambda ()
          (let ((left-expl <Text-Explorer> (new (explorer-class self) model))
                (right-expl <Text-Explorer> (new (explorer-class self) model)))
            (set-pos left-expl (get-start self))
            (backward left-expl)
            (set-pos right-expl (get-end self))
            (forward right-expl)
            (let ((left (get-range left-expl))
                  (right (get-range right-expl)))
              (if (or (not left) (not right))
                  (bell)
                (let ((ls (range-strings self left))
                      (rs (range-strings self right)))
                  (replace model right ls)
                  (replace model left rs)))))
          (set-modified? model #t)))))
  
  
  (method public (transpose-word self)
    (transpose-movements self
      (lambda (expl) (forward-non-word expl) (set-start expl (get-end expl)) (forward-word expl))
      (lambda (expl) (backward-non-word expl) (set-end expl (get-start expl)) (backward-word expl))))

  
  (method override (prior-page self shift?)
    (let* ((start (get-start self))
           (v (line->display-v self (get-line start))))
      (scroll self (new Point 0 (get-page-size self 'vert)))
      (let* ((line (display-v->line self v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection self dest)
          (set-caret self dest)))))
  
  
  (method override (next-page self shift?)
    (let* ((start (get-start self))
           (v (line->display-v self (get-line start))))
      (scroll self (new Point 0 (- (get-page-size self 'vert))))
      (let* ((line (display-v->line self v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection self dest)
          (set-caret self dest)))))
  
  
  (method (line->display-v self line) <fx>
    (let ((top (- (get-v position)))
          (v (line->view self line)))
      (- v top)))
  
  
  (method (display-v->line self v) <fx>
    (let* ((top (- (get-v position)))
           (pos (new Point left-padding (+ top v)))
           (text (view->text self pos)))
      (get-line text)))
  
  
  (method (selection-tail self direction) <Cell>
    (let ((anchor (get-selection-anchor self)))
      (cond ((after? anchor  (get-end self))
             (get-end self))
            ((before? anchor (get-start self))
             (get-start self))
            ;; else the selection is the same as the selection-anchor
            (else
             (case direction
               ((backward) (get-start self))
               ((forward)  (get-end self)))))))
  
  
  (method package (on-remove-spaces self evt)
    (if (not (empty-selection? self))
        (bell)
      (remove-spaces self (get-caret self) keep: (get-property evt keep:))))
  
  
  (method public (remove-spaces self pos (keep: keep 'one/none))
    (let ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos)))
      (backward-whitespaces expl)
      (forward-whitespaces expl)
      (let* ((range (get-range expl))
             (one-left? (and (= (get-line (get-start range)) (get-line (get-end range))) (= (+ (get-col (get-start range)) 1) (get-col (get-end range))))))
        (replace model (get-range expl)
          (case keep
            ((none) (list ""))
            ((one) (list " "))
            ((one/none) (if one-left? (list "") (list " "))))))))
  
  
  (method package (on-display-info self evt)
    (user-message (info-message self)))
  
  
  (method protected virtual (info-message self)
    (let ((start (get-start self))
          (end (get-end self)))
      (format "Start: line {a} col {a}, End: line {a} col {a}"
              (+ (get-line start) 1) (+ (get-col start) 1)
              (+ (get-line end) 1) (+ (get-col end) 1))))
  
  
  (method package (on-user-code self evt)
    (let* ((appl (current-application))
           (profile (get-profile appl)))
      (user-code profile self)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method package (range-region self range <Range$Cell$> transformer (top: top #f) (bottom: bottom #f))
    (let ((root (get-root self))
          (region (new Region))
          (width (get-width self)))
      (for-each-logical-range self range
        (lambda (line paragraph start end)
          (with ((sub (range-region paragraph left-padding start end width transformer)))
            (combine-or! region sub))))
      (with ((clipper (new Region rect: (transformer (get-view-clipper self)))))
        (combine-and! region clipper))
      region))
  
  
  (method (line-range-rect self line start end)
    (let ((paragraph (get-paragraph self line)))
      (new Rect
        (get-h (col->view paragraph start))
        (line->view self line)
        (if end (get-h (col->view paragraph (max 1 end))) (get-width self))
        (+ (line->view self line) (if end (get-height (get-line-at paragraph end)) (get-default-height self))))))
  
  
  (method (invalidate-range self range <Range$Cell$>)
    (when (view-visible? self)
      (with-transformation-surface self
        (lambda (surface)
          (with ((region (range-region self range (lambda (rect) (logical->device surface rect)))))
            (invalidate-region player region))))))
  
  
  ;; this should be unified with selection-region
  (method (text-selection-region self transformer top bottom)
    (range-region self (get-selection self) transformer top: top bottom: bottom))
  
  
  (method (selection-region-all self transformer)
    (text-selection-region self transformer 0 (get-display-height self)))
  
  
  (method protected virtual (get-selection-color self)
    (if completion-active?
        (or (get-completion-color (get-skin self)) {Color red: 128 green: 240 blue: 240})
      (or (get-active-selection-color (get-skin self)) {Color red: 190 green: 190 blue: 230})))
  
  
  (method package virtual (get-inactive-selection-color self)
    (or (get-inactive-selection-color (get-skin self)) {Color Unfocused-Selection}))
  
  
  (method public (for-each-logical-range self range <Range$Cell$> proc)
    (let ((start (get-start range))
          (end (get-end range)))
      (when (/= start end)
        (if (= (get-line start) (get-line end))
            (let ((line (get-line start)))
              (proc line (get-paragraph self line) (get-col start) (get-col end)))
          (let ((beginning (get-line start))
                (limit (get-line end)))
            (loop (for line from beginning to limit)
                  (let ((paragraph (get-paragraph self line)))
                    (cond ((= line beginning) (proc line paragraph (get-col start) #f))
                          ((= line limit) (proc line paragraph #f (get-col end)))
                          (else (proc line paragraph #f #f))))))))))
  
  
  (method public (for-each-range self range <Range$Cell$> proc)
    (for-each-logical-range self range
      (lambda (line paragraph start end)
        (proc line
              paragraph
              (or start 0)
              (or end (get-length paragraph))))))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method override (can-undo? self)
    (can-undo? model))
  
  
  (method override (can-redo? self)
    (can-redo? model))
  
  
  (method override (can-cut? self)
    (has-selection? self))
  
  
  (method override (can-copy? self)
    (has-selection? self))
  
  
  (method override (can-paste? self)
    #t)
  
  
  (method override (can-delete? self)
    (has-selection? self))
  
  
  (method override (can-select-all? self)
    #t)
  
  
  (method override (undo self)
    (undo model)
    (update-focus-actions (current-application)))
  
  
  (method override (redo self)
    (redo model)
    (update-focus-actions (current-application)))
  
  
  (method override (cut-selection self)
    (copy-selection self)
    (delete-selection self))
  
  
  (method override (copy-selection self)
    (if (empty-selection? self)
        (bell)
      (set-clipboard-text (join-lines (selection-lines self)))
      (add-clipboard (current-application))))
  
  
  (method override (paste-clipboard self)
    (let ((text (get-clipboard-text)))
      (if (not text)
          (bell)
        (paste-clipboard-string self text))))
  
  
  (method override (paste-clipboard-value self clipboard)
    (when (eq? (get-format clipboard) 'unicode-text)
      (paste-clipboard-string self (get-text clipboard))))
  
  
  (method override (cycle-paste-clipboard self previous-clipboard clipboard)
    (when (eq? (get-format clipboard) 'unicode-text)
      (if (or (not previous-clipboard) (neq? (get-format previous-clipboard) 'unicode-text))
          (paste-clipboard-value self clipboard)
        (let ((expl (new (explorer-class self) model)))
          (set-pos expl (get-start self))
          (with-atomic-undo (get-undoer model)
            (lambda ()
              (let ((actual-text (get-text previous-clipboard)))
                (when (looking-back? expl actual-text)
                  (backward-n expl (string-length actual-text))
                  (delete-range model (get-range expl)))
                (insert-string self (get-text clipboard)))))))))
  
  
  (method public virtual (paste-clipboard-string self string)
    (replace-selection self (split-lines string)))


  (method package (on-paste&stay self evt)
    (paste&stay self))


  (method package (on-paste&next self evt)
    (paste&stay self)
    (down-arrow-move self #f #f))
  
  
  (method (paste&stay self)
    (let ((pos (get-start self)))
      (paste-clipboard self)
      (set-caret self pos)))
  
  
  (method package (on-paste-cycle-ring self evt)
    (paste-cycle-ring (current-application) #f))


  (method package (on-paste-cycle-ring-reversed self evt)
    (paste-cycle-ring (current-application) #t))
  
  
  (method override (delete-selection self)
    (unless (empty-selection? self)
      (replace-selection self (list ""))))
  
  
  (method override (select-all self . rest)
    (set-selection self (buffer-selection self)))
  
  
  (method public (clear-all self)
    (select-all self)
    (delete-selection self))
  
  
  ;;;
  ;;;; Mark
  ;;;
  
  
  (method package (on-set-mark self evt)
    (set-mark self (get-selection self))
    (user-message "Marked"))
  
  
  (method package (on-jump-mark self evt)
    (when mark
      (let ((mark (valid-range self mark)))
        (if (or locked-anchor? (get-property evt extend?:))
            (set-selection self (new Range$Cell$
                             (minimum (list (get-start-anchor self) (get-start mark)))
                             (maximum (list (get-end-anchor self) (get-end mark)))))
          (let ((new-mark mark))
            (set-mark self (get-selection self))
            (set-selection self new-mark))))))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method public (get-marks self)
    marks)
  
  
  (method public (add-mark self mark)
    (set! marks (cons mark marks)))
  
  
  (method public (remove-mark self mark)
    (set! marks (remove! mark marks)))
  
  
  (method package (adjust-marks self range caret procs)
    (for-each (lambda (mark)
                (let ((change-proc (adjust mark (get-start range) (get-end range) caret)))
                  (when change-proc
                    (enqueue procs change-proc))))
              marks))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method override (empty-selection self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-beginning self)))
  
  
  (method override (reset-selection self)
    (set-range-noupdate selection (empty-selection self))
    (set-range-noupdate selection-anchor (empty-selection self)))
  
  
  (method package (buffer-selection self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-ending self)))
  
  
  (method override (line-selected? self line) <bool>
    #f)
  
  
  (method public (text-beginning self) <Cell>
    (new Cell 0 0))
  
  
  (method public (text-ending self) <Cell>
    (let ((limit (get-limit self)))
      (new Cell limit (paragraph-length self limit))))
  
  
  (method public (text-range self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-ending self)))
  
  
  (method public (text-empty? self) <bool>
    (= (text-beginning self) (text-ending self)))
  
  
  (method public inline (get-start self) <Cell>
    (get-start selection))
  
  
  (method public inline (get-end self) <Cell>
    (get-end selection))
  
  
  (method inline override (get-selection self) <Range$Cell$>
    (get-range selection))
  
  
  (method override (set-selection self range <Range$Cell$>
                                  (force?: force? #f)
                                  (reposition: reposition #f)
                                  (ensure-displayed?: ensure-displayed? #t)
                                  (generate-event?: generate-event? #t)
                                  (set-anchor?: set-anchor? #t))
    (validate-range self range)
    (when (and (or force? (/= (cast <Range$Cell$> (get-selection self)) range))
               (not selection-inhibit?))
      (hide-caret self)
      (when set-anchor?
        (set-selection-anchor self range))
      (update-selection self range)
      (update-caret self)
      (when (and ensure-displayed? (not mouse-selecting?))
        (ensure-displayed self reposition: reposition center?: (eq? ensure-displayed? 'center-caret)))
      (unless (and (get-mouse-down?) (eq? (get-mouse-in) self))
        (let ((appl (current-application)))
          ;; quick hack for sejour
          (when (is? appl Application)
            (update-focus-actions appl))))
      (when generate-event?
        (process-selection-change self))))
  
  
  (method public (update-selection self range <Range$Cell$>)
    (if (not (view-visible? self))
        (set-range selection range)
      (with-transformation-surface self
        (lambda (surface)
          (let ((transformer (lambda (rect) (logical->device surface rect))))
            (with ((old (selection-region-all self transformer)))
              (set-range selection range)
              (with ((new (selection-region-all self transformer)))
                (if (and old new)
                    (begin
                      (combine-xor! new old)
                      (invalidate-region player new))
                  (when old
                    (invalidate-region player old))
                  (when new
                    (invalidate-region player new))))))))))
  
  
  (method public (reset-caret self pos <Cell> . rest)
    (apply set-selection self (new Range$Cell$ pos pos) rest))
  
  
  (method (fit-range self range <Range$Cell$>)
    (let* ((ending (text-ending self))
           (start (get-start range))
           (end (get-end range))
           (s (when (> start ending) ending))
           (e (when (> end ending) ending)))
      (when (or s e)
        (new Range$Cell$ (or s start) (or e end)))))
  
  
  (method public (get-selection-anchor self)
    (get-range selection-anchor))
  
  
  (method public (get-start-anchor self)
    (get-start selection-anchor))
  
  
  (method public (get-end-anchor self)
    (get-end selection-anchor))
  
  
  (method public (set-selection-anchor self range)
    (set-range selection-anchor (copy range)))
  
  
  (method public (lock-anchor self)
    (set! locked-anchor? #t))
  
  
  (method public (unlock-anchor self)
    (set! locked-anchor? #f))
  
  
  ;; The selection change up to a specified position
  (method public (change-selection self pos . rest)
    (bind-keywords ((set-anchor? #f) . others) rest
      (when pos (apply set-selection self (selection-range self pos) set-anchor?: set-anchor? others))))
  
  
  (method public (get-caret self) <Cell>
    (get-start self))
  
  
  (method public (set-caret self pos . rest)
    (when pos
      ;; lisp tabulate can return negative col
      (let* ((line (min (max 0 (get-line pos)) (get-limit self)))
             (par (get-paragraph self line))
             (col (min (max 0 (get-col pos)) (get-length par)))
             (caret
               (if (and (= line (get-line pos))
                        (= col (get-col pos)))
                   pos
                 (new Cell line col))))
        (apply reset-caret self caret rest))))
  
  
  (method package virtual (selection-change self)
    )
  
  
  (method public (has-selection? self)
    (/= (get-start self) (get-end self)))
  
  
  (method public (empty-selection? self)
    (= (get-start self) (get-end self)))
  
  
  (method public (at-beginning? self)
    (and (= (get-start self) (get-end self))
         (= (get-start self) (text-beginning self))))
  
  
  (method public (at-end? self)
    (and (= (get-start self) (get-end self))
         (= (get-start self) (text-ending self))))
  
  
  (method public (at-line-start? self)
    (= (get-col (get-start self)) 0))
  
  
  (method public (selected-lines self)
    (let* ((start (get-start self))
           (end (get-end self))
           (end-line (if (= (get-col end) 0) (- (get-line end) 1) (get-line end))))
      (naturals (get-line start) (+ end-line 1))))
  
  
  (method public (for-each-selected-paragraph self proc)
    (let ((selection (get-selection self)))
      (for-each-paragraph model proc
        start: (get-line (get-start selection))
        end: (get-line (get-end selection)))))
  
  
  (method override (invalidate-selection self sel)
    (invalidate-range self sel))
  
  
  (method override (selection-region self sel transformer)
    (range-region self sel transformer))
  
  
  (method public (get-char self pos <Cell>) <char>
    (let ((line (get-line pos))
          (col (get-col pos)))
      (let ((string (get-string (get-paragraph self line))))
        (if (< col (cardinality string))
            (element string col)
          #\newline))))
  
  
  (method public (get-string self range <Range$Cell$>) <string>
    (join-lines (range-strings self range)))
  
  
  (method public (next! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) (paragraph-length self (get-line pos)))
           (increase-col pos)
           #t)
          ((< (get-line pos) (get-limit self))
           (increase-line pos)
           (set-col pos 0)
           #t)
          (else
           #f)))
  
  
  (method public (previous! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) 0)
           (increase-col pos -1)
           #t)
          ((> (get-line pos) 0)
           (increase-line pos -1)
           (set-col pos (paragraph-length self (get-line pos)))
           #t)
          (else
           #f)))
  
  
  (method public (next-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (next! self cell)
           cell)))
  
  
  (method public (previous-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (previous! self cell)
           cell)))
  
  
  (method (selection-lines self)
    (range-strings self (get-selection self)))
  
  
  (method public (get-selected-string self) <string+>
    (and (has-selection? self)
         (get-string self (get-selection self))))
  
  
  (method public (get-selected-strings self)
    (get-range-strings self (get-selection self)))
  
  
  (method public (get-range-strings self range)
    (if (empty? range)
        '()
      (range-strings self range)))
  
  
  (method public (next-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((next! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (previous-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((previous! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (get-column self line <fx>) <fx>
    (let ((pos (new Cell line 0)))
      (while (memq? (get-char self pos) '(#\space #\tab))
        (increase! pos))
      (get-col pos)))
  
  
  (method (on-goto-line self evt)
    (let* ((start (get-start self))
           (line (get-line start))
           (str (request-string title: "Goto Line" prefix: "Line no:" initial-value: (->string (+ line 1)))))
      (cond ((starts-with? str "+")
             (goto-line self (+ line (parse-integer (subseq str 1 (cardinality str))))))
            ((starts-with? str "-")
             (goto-line self (- line (parse-integer (subseq str 1 (cardinality str))))))
            (else
             (goto-line self (- (parse-integer str) 1))))))
  
  
  (method public (goto-line self line)
    (cond ((< line 0)
           (set-selection self (new Range$Cell$ (new Cell 0 0) (new Cell 1 0))))
          ((>= line (get-limit self))
           (let ((line (get-limit self)))
             (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length self line))))))
          (else
           (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method override (added-update-selection self line count)
    )
  
  
  (method override (removed-update-selection self line count)
    #f)
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (on-lock-anchor self evt)
    (lock-anchor self)
    (user-message "Anchor locked"))
  
  
  (method package (on-unlock-anchor self evt)
    (unlock-anchor self)
    (user-message "Anchor unlocked"))
    
  
  (method package (on-toggle-lock-anchor self evt)
    (if locked-anchor?
        (on-unlock-anchor self evt)
      (on-lock-anchor self evt)))
  
  
  ;;;
  ;;;; Text Actions
  ;;;
  
  
  (method public (add-text-action self text-action)
    (set! text-actions (cons text-action text-actions)))
  
  
  (method public (run-text-action self text-action)
    (when (memq text-action text-actions)
      (text-action)
      (remove! text-action text-actions)))
  
  
  (method public (remove-all-text-actions self)
    (set! text-actions '()))
  
  
  ;;;
  ;;;; Highlights
  ;;;
  
  
  (method public (add-highlight self highlight)
    (set! highlights (cons highlight highlights)))
  
  
  (method public (remove-highlight self highlight)
    (set! highlights (remove! highlight highlights)))
  
  
  (method public (remove-all-highlights self)
    (set! highlights '())
    (invalidate-view self))
  
  
  (method public (invalidate-highlight self highlight)
    (invalidate-range self (valid-range self (get-range highlight))))
  
  
  (method public (invalidate-non-showed-highlights self)
    (for-each (lambda (highlight)
                (when (not (get-show-unfocused? highlight))
                  (invalidate-highlight self highlight)))
              highlights))

  
  ;;;
  ;;;; Layout
  ;;;
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method override (layout-scrollee-patch self)
    (update-displayed self))
  
  
  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method override (size-change self size)
    (nextmethod self size)
    ;; because for the moment wrap is done in the
    ;; model it is dependent on our display size
    (when (get-wrap? model)
      (layout-scrollee model)))
  
  
  (method override (scrollee-width self)
    (let ((width (scrollee-width model)))
      (if (and scroller fit-to-scroller?)
          (max (get-display-width self) width)
        width)))
  
  
  (method override (dynamic-scrollee? self)
    (not fit-to-scroller?))
  
  
  (method override (dynamic-set-scrollee-size self)
    (let ((size (dimension-max {Dimension 10 10} (scrollee-size self))))
      (set-size self size)
      (let ((scroller (get-scroller self)))
        (when scroller
          (let ((scroller-size (dimension-min (get-size (get-parent (get-scroller self))) size)))
            (set-size-noevent (get-scroller self) scroller-size)
            (set-size-noevent (get-content (get-scroller self)) scroller-size)
            (layout-view (get-parent (get-scroller self))))))))
  
  
  ;; until we maintain it incrementally
  (method package virtual (dynamic-scrollee-width? self)
    (or (not fit-to-scroller?)
        (<= (get-visible-count model) 16)))
  
  
  (method override (scrollee-content-width self)
    (scrollee-content-width model))
  
  
  (method package virtual (scrollee-size-update self size)
    )
  
  
  ;;;
  ;;;; Paragraph
  ;;;


  (method public (get-length self) <fx>
    (get-length model))
  
  
  (method public (get-limit self) <fx>
    (get-limit model))
  
  
  (method public (get-paragraph self line <fx>) <Paragraph>
    (get-paragraph model line))
  
  
  (method public (paragraph-string self line <fx>) <string>
    (paragraph-string model line))
  
  
  (method public (paragraph-length self line <fx>) <fx>
    (paragraph-length model line))
  
  
  (method public (first-paragraph self)
    (first-paragraph model))
  
  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (get-print-area self context)
    (get-print-area model context))
  
  
  (method override (paginate self page-width page-height)
    (let ((selected? #f @tmp (has-selection?)))
      (let ((start (if selected? (get-line (get-start self)) 0))
            (end (+ (if selected? (get-line (get-end self)) (get-limit self)) 1)))
        (paginate-range model start end page-width page-height))))
  
  
  (method override (setup-printing self)
    (setup-printing model))
  
  
  (method override (restore-printing self preserved)
    (restore-printing model preserved))
  
  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method package virtual (draw-enabled? self)
    (view-enabled? self))
  
  
  (method override (get-drawing-background self context)
    (let ((skin (get-skin self)))
      (if (not (draw-enabled? self))
          (or (get-disabled-background skin)
              {Color Medium})
        (or (get-background skin)
            (nextmethod self context)))))
  
  
  ;; quick copy/paste of outline-view draw-background
  ;; to let get-drawing-background decide the disabled 
  (method override (draw-background self surface context)
    (let ((background (cond ((debug-paint?)
                             (cycle-debug-color!))
                            (else
                             (get-drawing-background self context)))))
      (when (and background (neq? background 'none))
        (let ((bounds (get-bounds self)))
          (fill-rect surface bounds background)))))
  
  
  (method override (draw-children self surface nodes context)
    (define (draw-highlights)
      (let ((focus? (has-focus? self))
            (tabs (get-tabs model)))
        (for-each (lambda (highlight)
                    (when (or focus? (get-show-unfocused? highlight))
                      (let ((range (get-range highlight))
                            (style (get-style highlight)))
                        (let* ((start (get-start range))
                               (end (get-end range))
                               (paragraph (get-paragraph self (get-line start)))
                               (target (subseq (get-string paragraph) (get-col start) (get-col end)))
                               (info (text->view-extended self start))
                               (line (car info))
                               (pos (cdr info))
                               (height (get-height line))
                               (format (get-format paragraph))
                               (left (get-left-margin format))
                               (enabled? (draw-enabled? self)))
                          (draw-style style surface '() target (get-h pos) (get-v pos) height tabs left enabled?)))))
                  highlights)))
    
    (define (draw-caret)
      (when (and caret-visible? (empty-selection? self) (or (not (get-mouse-down?)) (and (not (alt-down?)) (not (meta-down?)))))
        (let ((rect <Rect> (caret-rect self (get-caret self))))
          (fill-rect surface rect (or (get-caret-color (get-skin self)) {Color red: .706 green: .005 blue: .995})))))
    
    (let ((top #f)
          (bottom #f)
          (printing? (getf context printing?:)))
      (unless printing?
        (draw-selection self surface top bottom))
      (nextmethod self surface nodes context)
      (draw-highlights)
      (unless printing?
        (draw-caret))))
  
  
  (method protected virtual (draw-selection self surface top bottom)
    (when (and (or (is-focused? self) show-unfocused-selection?) selectable?)
      (with ((region (text-selection-region self identity top bottom)))
        (when region
          (fill-region surface region
            (if (is-focused? self)
                (get-selection-color self)
              (get-inactive-selection-color self)))))))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method override (get-skin self)
    (find-skin 'ui:text))
  
  
  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method override (ensure-displayed self . rest)
    (let ((selection (get-selection self)))
      (when selection
        (apply ensure-range-displayed self selection rest))))
  
  
  (method public (ensure-cell-displayed self pos <Cell>)
    (let* ((start (text->view self pos))
           (end (+ start (new Point 0 (get-height-at self pos)))))
      (scroll self (scroll-needed self start end (get-scroll-context self)))))
  
  
  (method public (ensure-range-displayed self range <Range$Cell$> . rest)
    (unless update-locked?
      (let* ((start (get-start range))
             (end (get-end range))
             (end-height (get-height-at self end)))
        (scroll self (apply scroll-needed self (text->view self start) (+ (text->view self end) (new Point 0 end-height)) (get-scroll-context self) rest)))))
  
  
  (method public (ensure-scrolled-left self)
    (unless update-locked?
      (when (/= 0 (get-h (get-position self)))
        (let* ((size (get-display-width self))
               (context (cdr (get-scroll-context self)))
               (context (if context (fxround (cast <fl> (* size context))) 0))
               (tail (+ (get-scrolled-distance-h self) size))
               (end (get-h (text->view self (get-end self)))))
          (when (< end (- tail context))
            (scroll self (new Point (- tail context end) 0)))))))
  
  
  (method public (cell-displayed? self pos)
    (let* ((start (text->view self pos))
           (end (+ start (new Point 0 (get-height-at self pos)))))
      (= (scroll-needed self start end #f) {Point 0 0})))
  
  
  (method (on-center-caret self evt)
    (center-caret self))
  
  
  (method (on-top-caret self evt)
    (top-caret self))
  
  
  (method public (center-caret self)
    (let* ((start (get-bottom (get-row self (get-line (get-start self)))))
           (end (get-top (get-row self (get-line (get-end self)))))
           (size (- end start))
           (height (get-display-height self))
           (top (if (>= size height)
                    start
                  (let ((half (fxround/ (- height size) 2)))
                    (- start half)))))
      (scroll-to self (new Point 0 (- top)))))
  
  
  (method public (center-undisplayed-caret self)
    (when (or (not (cell-displayed? self (get-start self)))
              (not (cell-displayed? self (get-end self))))
      (center-caret self)))
  
  
  (method public (top-caret self)
    (let ((start (get-top (get-row self (get-line (get-start self))))))
      (scroll-to self (new Point 0 (- start)))))
  
  
  ;;;
  ;;;; Constituent
  ;;;
  
  
  (method public virtual (get-constituent-test self)
    (get-constituent-test syntax))
  
  
  (method public virtual (text-constituent? self char)
    (text-constituent? syntax char))
  
  
  (method public virtual (get-match-test self)
    (get-match-test syntax))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method public (move-forward self pos word?)
    (move-forward model pos word?))
  
  
  (method public (move-backward self pos word?)
    (move-backward model pos word?))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-char self c)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (insert-char model (get-selection self) c)))))
  
  
  (method public (insert-string self str)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (insert-string model (get-selection self) str)))))
  
  
  (method public (insert-styled self string style)
    (when (write-allowed? self)
      (let ((start (get-start self))
            (style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (insert-string self string)
        (stylize-range model (new Range$Cell$ start (get-start self)) style))))
  
  
  (method public (replace-styled self range strings style)
    (when (write-allowed? self)
      (let ((start (get-start range))
            (style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (let ((end (replace model range strings)))
          (let ((range (new Range$Cell$ start end)))
            (stylize-range model range style)
            range)))))
  
  
  (method public (stylize-range self range style)
    (when (write-allowed? self)
      (let ((style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (stylize-range model range style))))
  
  
  (method public (insert-line self line (proper? #t))
    (when (write-allowed? self)
      (replace-selection self (if proper? (list line "") (list line)))))
  
  
  (method public (insert-bulleted-line self line)
    (when (write-allowed? self)
      (let ((line (get-line (get-start self))))
        (insert-line self line)
        (toggle-bulleted model line))))
  
  
  (method public (insert-newline self)
    (when (write-allowed? self)
      (end-completion self)
      (insert-string self "\n")))
  
  
  (method public (insert-link self string (font: font #f) (anchor: anchor #f) (action: action #f))
    (when (write-allowed? self)
      (let* ((font (or font {Font Link}))
             (style (new Link-Style font: font color: {Color Link} anchor: anchor action: action)))
        (insert-styled self string style))))
  
  
  (method public (insert-image self moniker)
    (when (write-allowed? self)
      (let ((style (new Image-Style moniker: moniker)))
        (insert-styled self " " style))))
  
  
  (method public (insert-view self view/form)
    (when (write-allowed? self)
      (let* ((view (if (is? view/form View) view/form (instantiate view/form)))
             (end (get-end self))
             (paragraph (get-paragraph self (get-line end))))
        (set-parent view paragraph)
        (let ((style (new View-Style view: view)))
          (insert-styled self " " style)))))
  
  
  ;;;
  ;;;; Replace
  ;;;
  
  
  (method public (backspace self word?)
    (when (and (write-allowed? self)
               (backspace-allowed? self))
      (unless (at-beginning? self)
        (if (has-selection? self)
            (delete-selection self)
          (updating-caret self
            (lambda ()
              (delete-range model (new Range$Cell$ (move-backward self (get-start self) word?) (get-end self)))))))))
  
  
  (method protected virtual (backspace-allowed? self)
    #t)
  
  
  (method public virtual (delete-char self)
    (delete-action self #f))
  
  
  (method public virtual (delete-word self)
    (delete-action self #t))
  
  
  (method public (delete-action self word?)
    (when (write-allowed? self)
      (unless (at-end? self)
        (if (has-selection? self)
            (delete-selection self)
          (updating-caret self
            (lambda ()
              (delete-range model (new Range$Cell$ (get-start self) (move-forward self (get-end self) word?)))))))))
  
  
  (method package virtual (content-changing self range strings)
    )
  
  
  (method package virtual (content-changed self range strings undo-range undo-strings)
    (let ((event (new Replace-Event :replace self (modifiers-mask) range strings undo-range undo-strings)))
      (call-content-change self #f event: event)))
  
  
  (method public (replace self range <Range$Cell$> strings)
    (when (write-allowed? self)
      (without-caret self
        (lambda ()
          (updating-caret self
            (lambda ()
              (replace model range strings)))))))
  
  
  (method package (replace-text self range <Range$Cell$> strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace model range strings)))))
  
  
  (method public (replace-selection self strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace model (get-selection self) strings)))))
  
  
  (method (updating-caret self proc)
    (hide-caret self)
    (let ((caret (proc)))
      (when caret
        (set-caret self caret force?: #t)
        (update-caret self))))
  
  
  ;;;
  ;;;; Formatted
  ;;;
  
  
  (method package (copy-formatted-selection self)
    (if (empty-selection? self)
        (bell)
      (let ((output (open-output-string)))
        (print-formatted model output (get-selection self))
        (let ((text (get-output-string output)))
          (set-clipboard-text text format: 'jazz-formatted-text)))))
  
  
  (method package (paste-formatted-clipboard self)
    (let ((clipboard (get-clipboard '(jazz-formatted-text unicode-text))))
      (if (not clipboard)
          (bell)
        (paste-formatted-clipboard-value self clipboard))))
  
  
  (method package (paste-formatted-clipboard-value self clipboard)
    (case (get-format clipboard)
      ((jazz-formatted-text)
       (let ((text (get-clipboard-text format: 'jazz-formatted-text)))
         (let ((info (parameterize ((walk-for #f))
                       (with-jazz-readtable
                         (lambda ()
                           (read-string-element text))))))
           (replace-formatted-selection self info))))
      ((unicode-text)
       (let ((strings (split-lines (get-clipboard-text))))
         (replace-selection self strings)))))
  
  
  (method (replace-formatted-selection self strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace-formatted model (get-selection self) strings)))))
  
  
  (method package (replace-formatted-text self range <Range$Cell$> strings formats styles paragraphs)
    (when (write-allowed? self)
      (without-caret self
        (lambda ()
          (replace-formatted-text model range strings formats styles paragraphs)))))
  
  
  ;;;
  ;;;; Text Formatted
  ;;;
  
  
  (definition protected formatted-start-delimiter
    #\x02)
  
  (definition protected formatted-end-delimiter
    #\x03)
  
  
  (method public virtual (insert-formatted-line self line)
    (call-with-input-string (standardize-string-representation self line)
      (~ process-formatted self)))
  
  
  ;; quick hack around string representation changed
  (method (standardize-string-representation self line)
    (declare (proper-tail-calls))
    (let ((output (open-output-string))
          (len (string-length line)))
      (let (loop (n 0))
        (if (>= n len)
            (get-output-string output)
          (let ((c (string-ref line n)))
            (if (or (eqv? c formatted-start-delimiter)
                    (eqv? c formatted-end-delimiter))
                (let ((next (and (< (+ n 1) len) (string-ref line (+ n 1)))))
                  (write-char c output)
                  (if (eqv? next #\;)
                      (loop (+ n 2))
                    (loop (+ n 1))))
              (write-char c output)
              (loop (+ n 1))))))))
  
  
  (method protected (process-formatted self input)
    (define (process-string)
      (let ((output (open-output-string)))
        (let (iterate)
          (let ((c (peek-char input)))
            (if (or (eof-object? c)
                    (eqv? c formatted-start-delimiter)
                    (eqv? c formatted-end-delimiter))
                (insert-styled self (get-output-string output) 'Output)
              (write-char (read-char input) output)
              (iterate))))))
    
    (define (process)
      (let ((c (peek-char input)))
        (when (and (not (eof-object? c))
                   (not (eqv? c formatted-end-delimiter)))
          (cond ((eqv? c formatted-start-delimiter)
                 (read-char input)
                 (let ((directive (read-formatted-parameter input)))
                   (process-formatted-directive self directive input)))
                (else
                 (process-string)))
          (process))))
    
    (process))
  
  
  (method (with-formatted-range self input proc)
    (let ((start (get-start self)))
      (process-formatted self input)
      (let ((end-char (read-char input)))
        (if (eof-object? end-char)
            (error "Incomplete formatted input, EOF reached")
          (let ((end (get-start self)))
            (proc (new Range$Cell$ start end)))))))
  
  
  (method protected virtual (process-formatted-directive self directive input)
    (case directive
      ((%)
       (insert-newline self))
      (($)
       (unless (at-line-start? self)
         (insert-newline self)))
      ((bold)
       (with-formatted-range self input
         (lambda (range)
           (toggle-bold model range))))
      ((italic)
       (with-formatted-range self input
         (lambda (range)
           (toggle-italic model range))))
      ((underline)
       (with-formatted-range self input
         (lambda (range)
           (toggle-underline model range))))
      ((color)
       (let ((color (read-formatted-parameter input)))
         (with-formatted-range self input
           (lambda (range)
             (set-text-color model range (registered-color color))))))
      ((font)
       (let ((font (read-formatted-parameter input)))
         (with-formatted-range self input
           (lambda (range)
             (set-text-font model range (registered-font font))))))
      (else
       (error "Unknown text directive: {s}" directive))))
  
  
  (definition (read-formatted-parameter input)
    (prog1 (read input)
      (read-char input)))
  
  
  ;;;
  ;;;; Format
  ;;;
  
  
  (method public (add-format self name pref-format) <Format>
    (add-format model name pref-format))
  
  
  ;;;
  ;;;; Style
  ;;;

  
  (method public (add-style self name pref-style) <Style>
    (add-style model name pref-style))
  
  
  (method public (locate-style self name/style (error?: error? #t)) <Style>
    (locate-style model name/style error?: error?))
  
  
  ;;;
  ;;;; Height
  ;;;
  
  
  (method public (get-default-height self) <fx>
    (get-default-height model))
  
  
  (method public (get-height-at self pos <Cell>) <fx>
    (get-height-at model pos))
  
  
  ;;;
  ;;;; Chapters
  ;;;
  
  
  (method public virtual (get-headers self) <list+>
    #f)
  
  
  (method public virtual (get-chapters self) <list>
    (let ((headers (get-headers self)))
      (if (not headers)
          '()
        (let ((occurences (text-regular-search-all model (map make-search-context headers)))
              (chapters (new List-Factory)))
          (for-each (lambda (info)
                      (bind (from . to) info
                        (let ((line (get-line from))
                              (col (get-col from)))
                          (when (= col (get-column self line))
                            (let ((string (paragraph-string self line)))
                              (let ((header (subseq string col (get-col to)))
                                    (level (if (= col 0) 1 2))
                                    (label (get-chapter-label self string col from to)))
                                (put chapters (list level from header label))))))))
                    occurences)
          (get-output chapters)))))
  
  
  (method public virtual (get-chapter-label self string col from to)
    (subseq string (+ col (- (get-col to) (get-col from))))
    @fixme-slow
    (subseq string (+ col (- (position-offset model to) (position-offset model from)))))
  
  
  (method public virtual (get-first-special? self) <bool>
    #t)
  
  
  (method public virtual (get-first-chapter self lst)
    (if (get-first-special? self)
        (if (null? lst) #f (car lst))
      (let ((file (get-moniker self)))
        (list 0
              (text-beginning self)
              ""
              (if (not file)
                  "<Top>"
                (get-name file))))))
  
  
  (method public virtual (get-remaining-chapters self lst)
    (if (get-first-special? self)
        (if (null? lst) '() (cdr lst))
      lst))
  
  
  (method package (select-chapter self pos)
    (let* ((pos (valid-cell self pos))
           (line (get-line pos))
           (col (get-col pos))
           (len (paragraph-length self line))
           (range (new Range$Cell$ (new Cell line col) (new Cell line len))))
      (set-selection-safe self range ensure-displayed?: #f)
      (ensure-displayed self force-vertical: 'head)))
  
  
  ;;;
  ;;;; Expression
  ;;;
  
  
  (method public (current-name self)
    (let ((range (current-expr-range self)))
      (and range
           (name-at self range))))
  
  
  (method public (current-symbol self)
    (let ((expr (current-expr self)))
      (and (symbol? expr)
           expr)))
  
  
  (method public (current-expr self)
    (current-name self))
  
  
  (method public (current-expr-range self)
    (or (effective-selection self)
        (expr-range self (get-end self))))
  
  
  (method public (current-expr-string self)
    (let ((range (current-expr-range self)))
      (and range
           (get-string self range))))
  
  
  (method public virtual (name-at self range)
    (name-at syntax range))


  (method public virtual (expr-at self pos)
    (expr-at syntax pos))
  
  
  (method public virtual (range-expr self range)
    (range-expr syntax range))
  
  
  (method public virtual (expr-range self pos)
    (expr-range syntax pos))
  
  
  (method public (outer-range self range)
    (outer-range syntax range))
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method override (mouse-insert self copy)
    (define (separate? before after)
      (and (not (or (memv? before '(#\- #\.))
                    (memv? after '(#\- #\.))))
           (or (text-constituent? self before) (memv? before '(#\) #\] #\} #\")))
           (or (text-constituent? self after) (memv? after '(#\( #\[ #\{ #\" #\' #\,)))))
    
    (let ((start (get-start self))
          (end (get-end self))
          (str (localize copy)))
      (when (nu=? start end)
        (let ((prev (and (/= start (text-beginning self)) (get-char self (previous-cell self start))))
              (next (and (/= end (text-ending self)) (get-char self end))))
          (when (and prev (separate? prev (element str 0)))
            (set! str (string-append " " str)))
          (when (and next (separate? (last str) next))
            (set! str (string-append str " ")))))
      (insert-string self str)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method public (range-strings self range <Range$Cell$>) <list>
    (let ((start (get-start range))
          (end (get-end range)))
      (if (= (get-line start) (get-line end))
          (list (subseq (paragraph-string self (get-line start)) (get-col start) (get-col end)))
        (let ((dest (new List-Factory)))
          (put dest (subseq (paragraph-string self (get-line start)) (get-col start)))
          (put-sequence dest (map (~ paragraph-string self) (naturals (+ (get-line start) 1) (get-line end))))
          (put dest (subseq (paragraph-string self (get-line end)) 0 (get-col end)))
          (get-output dest)))))
  
  
  (method public (range-first-string self range <Range$Cell$>) <string>
    (first (range-strings self range)))
  
  
  ;;;
  ;;;; Column
  ;;;
  
  
  (definition Marked-Column
    #f)
  
  
  (method (on-mark-column self evt)
    (mark-column self))
  
  
  (method (on-fill-to-column self evt)
    (fill-to-column self))
  
  
  (method (mark-column self)
    (let* ((start (get-start self))
           (col (get-col start)))
      (set! Marked-Column col)
      (user-message "Marked to column {a}" col)))
  
  
  (method (fill-to-column self)
    (if (or (has-selection? self) (not Marked-Column))
        (bell)
      (let* ((start (get-start self))
             (col (get-col start))
             (delta (- Marked-Column col)))
        (case (sign delta)
          ((1) (insert-string self (make-string delta #\space)))))))
  
  
  ;;;
  ;;;; Formats
  ;;;
  
  
  (method package (on-upcase-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (upcase (get-selected-string self)))))))
  
  
  (method package (on-downcase-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (downcase (get-selected-string self)))))))
  
  
  (method (on-capitalize-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (capitalize (get-selected-string self)))))))
  
  
  (method package (with-preserved-selection self proc)
    (let ((selection (get-selection self))
          (anchor (get-selection-anchor self)))
      (proc)
      (set-selection self (valid-range self selection))
      (set-selection-anchor self (valid-range self anchor))))
  
  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method public (view->text self pos <Point>) <Cell>
    (define (effective-line v)
      (cond ((< v 0)
             0)
            ((>= v (get-visible-height model))
             (get-limit self))
            (else
             (v->line self v))))
    
    (let ((v (get-v pos)))
      (let ((line (effective-line v)))
        (assert line
          (let ((par (get-paragraph self line)))
            (let ((col (view->col par (- pos (get-position par)))))
              (assert col
                (new Cell line col))))))))
  
  
  (method public (text->view self pos <Cell>) <Point>
    (let* ((par (get-paragraph self (get-line pos)))
           (view (col->view par (get-col pos))))
      (new Point
        (get-h view)
        (+ (line->view self (get-line pos)) (get-v view)))))
  
  
  (method public (text->view-extended self pos <Cell>)
    (let* ((par (get-paragraph self (get-line pos)))
           (info (col->view-extended par (get-col pos)))
           (line (car info))
           (view (cdr info)))
      (cons line (new Point
                   (get-h view)
                   (+ (line->view self (get-line pos)) (get-v view))))))
  
  
  (method (line->view self line <fx>) <fx>
    (let ((par (get-paragraph self line)))
      (get-v (get-position par))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-range self range <Range$Cell$>) <void>
    (let ((start (get-start range))
          (end (get-end range)))
      (unless (and (= (valid-cell self start) start)
                   (= (valid-cell self end) end))
        (error "Invalid text range: {t}" range))))
  
  
  (method public (valid-line self line)
    (let ((limit (get-limit self)))
      (if (> line limit)
          limit
        line)))
  
  
  (method public (valid-cell self cell) <Cell>
    (let ((limit (get-limit self)))
      (define (restrict-row cell)
        (if (> (get-line cell) limit)
            (new Cell limit 0)
          cell))
      
      (define (restrict-col cell)
        (let ((line (get-line cell))
              (col (get-col cell)))
          (let ((len (paragraph-length self line)))
            (if (> col len)
                (new Cell line len)
              cell))))
      
      (restrict-col (restrict-row cell))))
  
  
  (method public (valid-range self range) <Range$Cell$>
    (new Range$Cell$
      (valid-cell self (get-start range))
      (valid-cell self (get-end range))))
  
  
  (method public (set-selection-safe self range . rest)
    (apply set-selection self (valid-range self range) rest))
  
  
  ;;;
  ;;;; Styles
  ;;;
  
  
  (method public (set-selection-format/style self name)
    (let ((selection (get-selection self))
          (start (get-start self))
          (end (get-end self)))
      (let ((empty? (empty-selection? self))
            (span? (neq? (get-paragraph self (get-line start)) (get-paragraph self (get-line end)))))
        (let ((format (and (or empty? span?) (locate-format model name error?: #f) (new Format base: name)))
              (style (and (locate-style model name error?: #f) (new Text-Style base: name))))
          (when style
            (cond ((or empty? span?)
                   (for-each-paragraph model
                     (lambda (line <fx> paragraph <Paragraph>)
                       (set-text-style model (new Range$Cell$ (new Cell line 0) (new Cell line (get-length paragraph))) style))
                     start: (get-line start)
                     end: (get-line end)))
                  (else
                   (set-text-style model selection style))))
          (when format
            (for-each-paragraph model
              (lambda (line <fx> paragraph <Paragraph>)
                (set-paragraph-format model paragraph format))
              start: (get-line start)
              end: (get-line end)))
          (set-modified? model #t)
          (layout-scrollee self)
          (invalidate-view self)))))
  
  
  (method (on-bold self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-bold model (get-selection self))
      (set-modified? model #t)))
  
  
  (method (on-italic self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-italic model (get-selection self))
      (set-modified? model #t)))
  
  
  (method (on-underline self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-underline model (get-selection self))
      (set-modified? model #t)))
  
  
  ;;;
  ;;;; Ruler
  ;;;
  
  
  (method public virtual (get-ruler self)
    #f)
  
  
  (method (on-toggle-ruler self evt)
    (let ((ruler (get-ruler self)))
      (if (not ruler)
          (bell)
        (set-shown? ruler (not (get-shown? ruler))))))
  
  
  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method public (set-selection-font-name self name)
    (for-each-range self (get-selection self)
      (lambda (line paragraph start end)
        (set-font-name paragraph start end name)
        (wrap-paragraph model '() paragraph)))
    (set-modified? model #t)
    (layout-scrollee self)
    (invalidate-view self))
  
  
  (method public (set-selection-point-size self size)
    (for-each-range self (get-selection self)
      (lambda (line paragraph start end)
        (set-point-size paragraph start end size)
        (wrap-paragraph model '() paragraph)))
    (set-modified? model #t)
    (layout-scrollee self)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (definition (pick-text-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-highlight-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-frame-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (method protected (has-completion? self)
    (and completion-active? (has-selection? self)))
  
  
  (method package (has-ambiguous-completion? self)
    (and completion-active? (not completion-unique?) (has-selection? self)))
  
  
  (method protected (has-effective-selection? self)
    (and (not completion-active?) (has-selection? self)))
  
  
  (method protected (empty-effective-selection? self)
    (or completion-active? (empty-selection? self)))
  
  
  (method protected (effective-selection self)
    (and (has-effective-selection? self)
         (get-selection self)))


  (method protected (set-completion self range unique?)
    (set! completion-active? #t)
    (set! completion-unique? unique?)
    (set-selection self range))
  

  (method (remove-completion self)
    (when completion-active?
      (delete-selection self)
      (set! completion-active? #f)))


  (method package (end-completion self)
    (when completion-active?
      (set! completion-active? #f)
      (set-caret self (get-end self))))
  
  
  (method package virtual (auto-complete? self)
    #f)


  (method package virtual (favorite-completions? self)
    #t)


  (method package virtual (favorite-completions self)
    (favorite-completions syntax))


  (method protected virtual (favorite-completion self name)
    (assoc-value name (favorite-completions self) #f))


  (method package virtual (completion-name self pos)
    )


  (method (completion-string self pos)
    (define (skip-prefix name)
      (if name
          (let ((len (string-length name)))
            (if (and (> len 0) (eqv? (string-ref name 0) #\<))
                (substring name 1 len)
              name))
        #f))
    
    (define (alphabetize-completion completions offset)
      (let ((alphabet-char (remove-duplicates
                             (sort char<?
                                   (map (lambda (completion)
                                          (if (> (string-length completion) offset) (element completion offset) #\space))
                                        completions)))))
        (coerce alphabet-char String)))
    
    (let ((name (skip-prefix (completion-name self pos))))
      (if (not name)
          (values #f #f)
        (let ((size (string-length name))
              (favorite (and (favorite-completions? self) (or (get-user-completion name) (favorite-completion self name))))
              (feedback? (not (macro-playing? (current-application)))))
          (if favorite
              (begin
                (when feedback?
                  (clear-user-message))
                (values (subseq favorite size) #t))
            (if (not (complete-name? self size))
                (begin
                  (when feedback?
                    (clear-user-message))
                  (values #f #f))
              (let* ((completions (symbol-completions self name))
                     (count (length completions)))
                (cond ((= count 0)
                       (when feedback?
                         (clear-user-message))
                       (values #f #f))
                      ((= count 1)
                       (let ((found (car completions)))
                         (when feedback?
                           (user-message "{a}" found))
                         (if (string=? name found)
                             (values #f #f)
                           (values (subseq found size) #t))))
                      ((> count 5)
                       (let* ((common (completions-prefix self completions))
                              (offset (string-length common))
                              (alphabet (alphabetize-completion completions offset)))
                         (when feedback?
                           (user-message "{a} ... [{a}]" common alphabet))
                         (values (subseq common size) #f)))
                      (else
                       (let ((common (completions-prefix self completions)))
                         (when feedback?
                           (user-message "{l detail: :human}" completions))
                         (values (subseq common size) #f)))))))))))
  
  
  (method package virtual (complete-name? self size)
    (>= size (get-auto-complete-minimum (preferences self))))
  
  
  (method package virtual (symbol-completions self name)
    '())
  
  
  (method protected virtual (completions-prefix self completions)
    (prefix completions))
  
  
  (method protected virtual (auto-complete self key)
    (with-atomic-undo (get-undoer model)
      (lambda ()
        (get-style-at model (get-start self))
        (let* ((end (get-end self))
               (last (and (> (get-col end) 0) (get-char self (- end 1))))
               (class (class-of self)))
          (if (not (auto-complete-char? self key last))
              (begin
                (insert-char self key)
                (complete-at self (get-start self)))
            (let* ((completion (join-lines (selection-lines self)))
                   (offset (and completion (find completion key)))
                   (replacement (and offset (subseq completion 0 offset))))
              (when (and completion-active? replacement)
                (replace-selection self (list replacement)))
              (end-completion self)
              (insert-char/backspace self key)
              (complete-at self (get-start self))))))))
  
  
  (method package virtual (auto-complete-char? self key last)
    (auto-complete-char? syntax key last))
  

  (method package (complete-at self pos <Cell> (auto-complete?: auto-complete? (unspecified)))
    (define (reset-completion)
      (set! completion-active? #t)
      (set! completion-unique? #t))
    
    (unless (or (textual-style? model (get-style-at model pos))
                (macro-active? (current-application)))
      (let ((pref (preferences self)))
        (let ((auto-complete? (if (specified? auto-complete?) auto-complete? (get-auto-complete? pref))))
          (if (not auto-complete?)
              (reset-completion)
            (receive (completion unique?) (completion-string self pos)
              (if (not completion)
                  (reset-completion)
                (insert-string self completion)
                (set-completion self (new Range$Cell$ pos (+ pos (cast <fx> (cardinality completion)))) unique?))))))))
  
  
  (method protected (convert-completion self)
    (when completion-active?
      (let ((start (get-start self))
            (end (get-end self)))
        (end-completion self)
        (set-selection self (new Range$Cell$ start end) set-anchor?: #f))))


  (method protected (insert-char/backspace self c (word?: word? #f))
    (case c
      ((#\backspace)
       (remove-completion self)
       (backspace self word?))
      (else
       (insert-char self c))))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method (on-search-forward-mode self evt)
    (select-command-search (current-application) 'forward
      (search-context model (get-selected-string self) ignore-case?: #t)))
  
  
  (method (on-search-backward-mode self evt)
    (select-command-search (current-application) 'backward
      (search-context model (get-selected-string self) ignore-case?: #t)))
  
  
  (method (on-search-current self evt)
    (define (single-line strings)
      (if (null? strings)
          ""
        (car strings)))
    
    (let ((range (current-expr-range self)))
      (if (not range)
          (select-command-search (current-application) 'forward (search-context model #f ignore-case?: #t))
        (let ((current (single-line (get-range-strings self range))))
          (select-command-search-current (current-application) 'forward range (search-context model current ignore-case?: #t))))))

  
  (method public (text-expression-search self string (start: start #f) (end: end (get-limit self)) (reversed?: reversed? #f))
    (let* ((expl (new (explorer-class self) model start: (text-beginning self) end: (text-beginning self)))
           (moniker (get-moniker self))
           (mode (if (or (not moniker) (ci=? (get-extension moniker) "jazz")) 'code 'quotation))
           (found (jazz.editor.lisp:search-expressions expl mode string position #f #f)))
      (and found
           (car found))))

  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method public virtual (select-next self search-context (end: end #f))
    (let ((found (text-regular-search model search-context start: (get-end self) end: end reversed?: #f)))
      (and found
           (bind (from . to) found
             (set-selection self (new Range$Cell$ from to))
             @fixme-slow
             (set-selection (new Range$Cell$ from (offset-position model (+ (position-offset model from) (- (position-offset model to) (position-offset model from))))))
             (ensure-displayed self)
             (ensure-scrolled-left self)
             #t))))
  
  
  (method public virtual (select-previous self search-context (end: end #f))
    (let ((found (text-regular-search model search-context start: (get-start self) end: end reversed?: #t)))
      (and found
           (bind (from . to) found
             (set-selection self (new Range$Cell$ from to))
             @fixme-slow
             (set-selection (new Range$Cell$ from (offset-position model (+ (position-offset model from) (- (position-offset model to) (position-offset model from))))))
             (ensure-displayed self)
             (ensure-scrolled-left self)
             #t))))
  
  
  (method public virtual (select-expr self search-context direction)
    (case direction
      ((forward) (select-expr-forward self search-context))
      ((backward) (select-expr-backward self search-context))))
  
  
  (method public virtual (select-expr-forward self search-context)
    (set-caret self (text-beginning self))
    (select-next self search-context))
  
  
  (method public virtual (select-expr-backward self search-context)
    (set-caret self (text-ending self))
    (select-previous self search-context))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor self (context: context #f))
    (new jazz.text.descriptors:Text-View-Descriptor)))


;;;
;;;; Text-Event
;;;


(class Text-Event extends Event)


;;;
;;;; Replace-Event
;;;


(class Replace-Event extends Event
  
  
  (slot range        getter generate)
  (slot strings      getter generate)
  (slot undo-range   getter generate)
  (slot undo-strings getter generate)


  (method override (initialize self kind sender modifiers range strings undo-range undo-strings)
    (nextmethod self kind sender modifiers)
    (set! self.range range)
    (set! self.strings strings)
    (set! self.undo-range undo-range)
    (set! self.undo-strings undo-strings))))
