;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Marcel Cote
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.text.Text-View jazz


(import (jazz.action)
        (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.document)
        (jazz.event)
        (jazz.exemplar)
        (jazz.feedback)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.locale)
        (jazz.markup)
        (jazz.menu)
        (jazz.outline)
        (jazz.platform)
        (jazz.profile)
        (jazz.skin)
        (jazz.text)
        (jazz.ui)
        (jazz.ui.skin)
        (jazz.undoer)
        (jazz.view)
        (jazz.window)
        (jazz.workspace))


(class Text-View extends Outline-View implements Document
  
  
  ;; the text content automaticaly saved in a canonical form when the text is visually edited
  (property protected text-content              initialize #f accessors explicit)
  (property protected selectable?               initialize #t accessors generate)
  (property protected editable?                 initialize #t accessors generate)
  (property protected accepts-returns?          initialize #t accessors generate)
  (property protected focus-selects-all?        initialize #f accessors generate)
  (property protected show-unfocused-selection? initialize #t accessors generate)
  (property protected force-tab-navigate?       initialize #f accessors generate)
  
  
  (slot protected syntax                 initialize #f accessors generate)
  (slot protected document-controller    initialize #f)
  (slot protected selection-anchor       initialize #f)
  (slot protected locked-anchor?         initialize #f)
  (slot protected mouse-selecting?       initialize #f)
  (slot protected selection-mode         initialize 'char)
  (slot protected selection-inhibit?     initialize #f)
  (slot protected special-mode           initialize #f)
  (slot protected virtual-h              initialize #f)
  (slot protected caret-pulse            initialize #f)
  (slot protected caret-pulse?           initialize #t)
  (slot protected caret-visible?         initialize #f)
  (slot protected completion-active?     initialize #f getter generate)
  (slot protected completion-unique?     initialize #f)
  (slot protected mark                   initialize #f accessors generate)
  (slot protected marks                  initialize '())
  (slot protected previous-position      initialize #f)
  (slot protected autoscroll-pulse       initialize #f)
  (slot protected mouse-copy-selection   initialize #f)
  (slot protected mouse-copy-destination initialize #f)
  (slot protected highlights             initialize '() getter generate)
  (slot protected text-actions           initialize #f)
  (slot protected text-listeners         initialize '())
  
  
  (form
    (<install> background: {Color Text-Background}))

  
  (method override (verify-reload self));;abstract
  (method override (current-history-item self));;abstract
  
  
  (method protected virtual (preferences self)
    (new jazz.text.preferences:Text-Preferences))
  
  
  (method override (new-model self)
    (new Text-Model))
  
  
  (method override (setup-model self mdl)
    (nextmethod self mdl)
    (when syntax
      (set-model syntax mdl))
    (let ((pref (preferences self)))
      (when pref
        (let ((base (or (get-base-format model) (get-base-format pref))))
          (add-format self 'Base base)
          (set-default-format model (intern-format model (or (get-default-format pref) (new Format base: 'Base)))))
        (let ((base (or (get-base-style model) (get-base-style pref))))
          (add-style self 'Base base)
          (set-default-style model (intern-style model (or (get-default-style pref) (new Text-Style base: 'Base)))))
        (register-children (child pref 'styles) (get-styles model))
        (register-children (child pref 'formats) (get-formats model)))))
  
  
  ;; kinda quicky
  (method package (setup-style self base)
    (add-style self 'Base base)
    (set-default-style model (intern-style model (new Text-Style base: 'Base))))
  
  
  (method override (prepare self rest)
    (set! selection (new Text-Mark self (empty-selection self) strict?: #f change-proc: (~ selection-change self)))
    (set! selection-anchor (new Text-Mark self (empty-selection self) strict?: #f))
    (nextmethod self rest))
  
  
  (method override (install self rest)
    (nextmethod self rest)
    (set! syntax (new-syntax self))
    (set-syntax model syntax)
    (let ((pref (preferences self)))
      (when pref
        (let ((background (get-background pref)))
          (when background
            (set-background self (symbolic-color background))))
        (set! caret-pulse? (get-pulse-caret? pref)))))
  
  
  (method override (install-child self form creator creator-branch restore-form)
    (case (get-model form)
      ;; until Form <-> Node unification
      ((text) (set-text model (form->node form)))
      (else (nextmethod self form creator creator-branch restore-form))))
  
  
  (method override (destroy self)
    (show-text-cursor self)
    (nextmethod self))
  
  
  (method protected virtual (new-syntax self) <Text-Syntax>
    (new Text-Syntax model))
  
  
  (method override (get-text-view self) <Text-View>
    self)
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method package (get-paragraphs self) <Axis>
    (get-paragraphs model))
  
  
  (method package (set-paragraphs self lst)
    (set-paragraphs model lst))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method override (host-workspaces self)
    '(text))
  
  
  (method override (install-in-host self host)
    (nextmethod self host)
    (install-in-host (get-document-controller self) host))
  
  
  (method override (split-view self)
    (let ((host (new-frame (class-of self) host-workspace: (get-workspace (get-host self)) host-visible?: #f)))
      (let ((view (get-guest host)))
        (set-model view model)
        (change-moniker (get-document-controller view) (get-moniker self))
        (scroll-to view (get-scrolled-position self))
        (set-selection view (get-selection self) ensure-displayed?: #f)
        (update-status view)
        (focus-host host)
        host)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions self)
    (cons (find-actions 'text)
          (nextmethod self)))
  
  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method override (get-document-controller self)
    (unless document-controller
      (set! document-controller (new-document-controller self)))
    document-controller)
  
  
  (method override (new-document-controller self)
    (new Document-Controller self tool?: (default-tool? self) console?: (default-console? self)))
  
  
  (method protected virtual (default-tool? self)
    #f)
  
  
  (method protected virtual (default-console? self)
    #f)
  
  
  (method override (save self)
    (save (get-document-controller self)))
  
  
  (method override (save-as self)
    (save-as (get-document-controller self)))
  
  
  (method public virtual (save-all self)
    (save-all (get-document-controller self)))
  
  
  (method public (get-moniker self)
    (get-moniker (get-document-controller self)))
  
  
  (method public (set-moniker self moniker)
    (set-moniker (get-document-controller self) moniker))
  
  
  (method override (get-modified? self)
    (get-modified? (get-document-controller self)))
  
  
  (method override (set-modified? self state)
    (set-modified? (get-document-controller self) state))
  
  
  (method package (get-read-only? self)
    (get-read-only? (get-document-controller self)))
  
  
  (method package (write-allowed? self)
    (and editable? (write-allowed? (get-document-controller self))))
  
  
  (method package (update-status self)
    (update-status (get-document-controller self)))
  
  
  (method package (update-moniker-time self moniker)
    (update-moniker-time (get-document-controller self) moniker))
  
  
  (method override (confirm-close self . rest)
    (when (last-client? self)
      (confirm-close (get-document-controller self))))
  
  
  (method override (tool-update self tool?)
    )
  
  
  (method override (console-update self console?)
    )

  
  (method override (revert-saved self)
    (revert-saved (get-document-controller self)))

  
  (method override (compare-saved self)
    (compare-saved (get-document-controller self)))
  
  
  (method override (install-scroller? self)
    #t)
  
  
  ;;;
  ;;;; Input/Output
  ;;;
  
  
  (method public (get-string-content self) <string>
    (get-string-content model))
  
  
  (method public (set-string-content self content <string>) <void>
    (set-string-content model content))
  
  
  (method public (empty-text self)
    (empty-text model))
  
  
  (method override (default-extension self)
    (default-extension syntax))
  
  
  (method override (extensions self)
    (extensions syntax))
  
  
  (method override (load-content self moniker)
    (load-content model moniker))
  
  
  (method override (save-content self moniker)
    (save-content model moniker))
  
  
  (method override (save-to self moniker)
    (save-to model moniker))
  
  
  (method override (reload-moniker self moniker)
    (let ((line (get-line (get-start self))))
      (reload-moniker model moniker)
      (set-caret self (new Cell (min line (cardinality (get-paragraphs self))) 0))
      (set-modified? model #f)))
  
  
  (method override (compare-moniker self moniker)
    (compare-moniker model moniker))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (get-text-content self)
    text-content)
  
  
  (method public (set-text-content self value)
    (set! text-content value)
    (set-content model text-content))
  
  
  ;;;
  ;;;; Explorer
  ;;;
  
  
  (method public virtual (explorer-class self)
    (explorer-class syntax))
  
  
  (method (on-select-outer self evt)
    (select-outer self))
  
  
  (method protected virtual (select-outer self)
    (end-completion self)
    (let ((expl <Text-Explorer> (new (explorer-class self) model range: (get-selection self))))
      (with-safe-explore
        (lambda ()
          (when (outer-expr expl uniform-style?: #t)
            (reset-mode self)
            (set-selection self (get-range expl)))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (show-text-cursor self)
    (update-caret self)
    (when (and focus-selects-all? (not (activating-window?)))
      (focus-select-all self)
      (when (and (eq? (event-type) 'mouse) (eq? (get-mouse-down-view) self))
        (set! selection-inhibit? #t)))
    (when (has-selection? self)
      (invalidate-selection self (get-selection self)))
    (invalidate-non-showed-highlights self))
  
  
  (method override (focus-lose self)
    (nextmethod self)
    (set! selection-inhibit? #f)
    (show-text-cursor self)
    (end-completion self)
    (hide-caret self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (when (has-selection? self)
      (invalidate-selection self (get-selection self)))
    (invalidate-non-showed-highlights self))
  
  
  (method override (focus-activate self)
    (focus-document self))
  
  
  (method override (focus-document self)
    (acquire-focus self))
  
  
  (method protected virtual (focus-select-all self)
    (select-all self))
  
  
  (method override (mouse-leave self)
    (show-text-cursor self))
  
  
  (method override (on-backspace-press self evt)
    (parameterize ((event-type 'keyboard))
      (backspace-press self #f word?: (get-property evt word?:))))
  
  
  (method (on-delete-press self evt)
    (delete-press self #f word?: (get-property evt word?:)))
  
  
  (method (on-numbered self evt)
    (unimplemented 'on-numbered))
  
  
  (method (on-bulleted self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (toggle-bulleted model line))))
  
  
  (method (on-decrease-indent self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (indent-paragraph model line paragraph -32))))
  
  
  (method (on-increase-indent self evt)
    (for-each-selected-paragraph self
      (lambda (line paragraph)
        (indent-paragraph model line paragraph 32))))
  
  
  (method (on-justify self evt)
    (let ((justification (get-property evt justification:)))
      (for-each-selected-paragraph self
        (lambda (line paragraph)
          (set-justification model line paragraph justification)))))
  
  
  (method (on-alignment self evt)
    (let ((alignment (get-property evt alignment:)))
      (set-text-alignment model (get-selection self) alignment)))
  
  
  (method (on-text-style self evt)
    (let ((style (get-property evt style:)))
      (set-selection-format/style self style)))
  
  
  (method (on-text-font self evt)
    (let ((font (get-property evt font:)))
      (set-selection-font-name self font)))
  
  
  (method (on-text-size self evt)
    (let ((size (get-property evt size:)))
      (set-selection-point-size self size)))
  
  
  (method (on-text-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color Black})))
      (set-text-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-text-color self evt)
    (pick-text-color (get-sender evt)))
  
  
  (method (on-highlight-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color White})))
      (set-highlight-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-highlight-color self evt)
    (pick-highlight-color (get-sender evt)))
  
  
  (method (on-frame-color self evt)
    (let ((color (get-property evt color:))
          (combo (popup-initiator (get-sender evt))))
      (close-popups self)
      (when combo
        (set-color (get-body combo) (or color {Color White})))
      (set-frame-color model (get-selection self) color)
      (set-modified? model #t)))
  
  
  (method (on-pick-frame-color self evt)
    (pick-frame-color (get-sender evt)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-text-listener self listener)
    (set! text-listeners (add-listener listener text-listeners)))
  
  
  (method public (remove-text-listener self listener)
    (set! text-listeners (remove-listener listener text-listeners)))
  
  
  (method public (text-listener? self object)
    (listener? object text-listeners))
  
  
  (method public (process-selection-change self)
    (when text-listeners
      (let ((evt (make-event Text-Event :selection-change self)))
        (for-each (lambda (listener)
                    (invoke listener self evt))
                  text-listeners))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method package (model-update self)
    (remove-all-text-actions self))
  
  
  (method protected (last-client? self)
    (= (length (get-clients model)) 1))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press self evt)
    (hide-text-cursor self)
    (char-press self (translate-key (syntax-at syntax (get-start self)) (get-key evt))))

  
  (method override (backspace-press self evt (word?: word? #f))
    (insert-char/backspace self #\backspace word?: word?)
    (when completion-active?
      (complete-at self (get-start self))))
  
  
  (method (delete-press self key (word?: word? #f))
    (delete-action self word?))
  
  
  (method (on-delete-char self evt)
    (delete-char self))
  
  
  (method (on-delete-word self evt)
    (delete-word self))
  
  
  (method (on-kill-line self evt)
    (define (kill-range)
      (let* ((pos (selection-tail self 'forward))
             (line (get-line pos))
             (col (get-col pos))
             (len (paragraph-length self line)))
        (if (= col len)
            (if (= line (get-limit self))
                #f
              (new Range$Cell$ pos (new Cell (+ line 1) 0)))
          (new Range$Cell$ pos (new Cell line len)))))
    
    (let ((range (kill-range)))
      (when range
        (let ((string (get-string self range)))
          (define (replace-clipboard)
            (set-clipboard-text string)
            (add-clipboard (current-application))
            (set! special-mode 'kill-line))
          
          (define (append-clipboard actual)
            (set-clipboard-text (string-append actual string)))
      
          (if (neq? special-mode 'kill-line)
              (replace-clipboard)
            (let ((actual (get-clipboard-text)))
              (if (not actual)
                  (replace-clipboard)
                (append-clipboard actual))))
          (delete-range model range)))))
  
  
  (method (on-open-line self evt)
    (insert-newline self)
    (left-arrow-move self #f #f))
  
  
  (method override (return-press self evt)
    (when accepts-returns?
      (insert-newline self)))


  (method override (escape-press self evt)
    (remove-completion self))
  
  
  (method override (tab-press self evt)
    (cond ((has-ambiguous-completion? self)
           (end-completion self))
          ((or (not accepts-returns?) force-tab-navigate?)
           (navigate-view self (get-shift? evt)))
          (else
           (if (has-completion? self)
               (end-completion self)
             (insert-char self #\tab)))))
  
  
  (method public virtual (char-press self key)
    (if (auto-complete? self)
        (auto-complete self key)
      (insert-char self key)))
  
  
  (method (reset-mode self (keep: keep #f))
    (set! special-mode #f)
    (unless (eq? keep 'virtual)
      (set! virtual-h #f)))
  
  
  (method package (on-insert self evt)
    (case (get-kind evt)
      ((:char) (call-key-press self evt))
      ((:string) (insert-string self (get-property evt content:)))))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (cond-expand
    (cocoa
      (method public (hide-text-cursor self)
        ))
    (else
     (method public (hide-text-cursor self)
       (when (and player (view-enabled? self) selectable? editable? (mouse-over? self))
         (hide-cursor player)))))
  
  
  (cond-expand
    (cocoa
      (method public (show-text-cursor self)
        ))
    (else
     (method public (show-text-cursor self)
       (when (and player (view-enabled? self) selectable? editable?)
         (show-cursor player)))))
  
  
  (method override (cursor-update self evt)
    (let ((view (get-position evt)))
      (show-text-cursor self)
      (when (and (view-enabled? self) (mouse-copyable? self))
        (if (mouse-copy? self evt)
            (set-cursor :finger)
          (let ((pos (view->text self view)))
            (let ((par (get-paragraph self (get-line pos))))
              (if (< (get-h view) (paragraph-left par))
                  (set-cursor :left-arrow)
                (let ((style (get-style-at model pos)))
                  (if (is? style Link-Style)
                      (set-cursor :finger)
                    (set-cursor :ibeam))))))))))
  
  
  ;;;
  ;;;; Caret
  ;;;
  
  
  (method (show-caret self)
    (define (pulse-caret)
      (when editable?
        (set! caret-visible? (not caret-visible?))
        (invalidate-caret self)))
    
    (when (and editable? (not caret-visible?) (has-focus? self))
      (set! caret-visible? #t)
      (when (and caret-pulse? (not caret-pulse))
        (set! caret-pulse (new Pulse 'caret 0.5 pulse-caret)))
      (invalidate-caret self)))
  
  
  (method (hide-caret self)
    (when editable?
      (when caret-pulse
        (close caret-pulse))
      (set! caret-visible? #f)
      (set! caret-pulse #f)
      (invalidate-caret self)))
  
  
  (method (without-caret self proc)
    (if (not editable?)
        (proc)
      (let ((shown? caret-visible?))
        (unwind-protect
            (begin
              (hide-caret self)
              (proc))
          (when shown?
            (update-caret self))))))
  
  
  (method virtual (update-caret self)
    (when (and player editable? (has-focus? self))
      (if (has-selection? self)
          (hide-caret self)
        (show-caret self))))
  
  
  (method (invalidate-caret self)
    (when editable?
      (let ((rect (caret-rect self (get-caret self))))
        (when rect
          (invalidate-rect self rect)))))
  
  
  (method (caret-rect self caret-pos <Cell+>)
    (and caret-pos
         (let* ((pos <Point> (text->view self caret-pos))
                (par <Paragraph> (get-paragraph self (get-line caret-pos)))
                (lne (get-line-at par (get-col caret-pos)))
                (run (get-run par (get-col caret-pos)))
                (width <fx> (or (get-caret-width (get-skin self)) 1))
                (height <fx> (if run (get-height run) (get-height par)))
                (line-height <fx> (get-height lne))
                (top <fx> (+ (get-v pos)
                             (if run
                                 (justify-element (get-style run) height line-height)
                               (- line-height height)))))
           (new Rect (get-h pos) (- top 1) (+ (get-h pos) width) (+ top height 1)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down self evt)
    (when selectable?
      (let ((view (get-position evt)))
        (let ((focus? (has-focus? self))
              (mouse-copy? (mouse-copy? self evt))
              (pos (view->text self view)))
          (unless (is? (get-style-at model pos) Link-Style)
            (end-completion self)
            (unless mouse-copy?
              (acquire-focus self))
            (when pos
              (acquire-capture self)
              (unlock-anchor self)
              (set! mouse-selecting? #t)
              (set! selection-mode 'char)
              (unless (or (get-shift? evt) (not focus?))
                (reset-caret self pos generate-event?: #f))
              (let ((par (get-paragraph self (get-line pos))))
                (if (< (get-h view) (paragraph-left par))
                    (set-selection self (selection-line self (get-line pos)) generate-event?: #f set-anchor?: #t)
                  (when (or focus? (not focus-selects-all?))
                    (if (get-shift? evt)
                        (change-selection self pos generate-event?: #f)
                      (set-caret self pos generate-event?: #f))
                    (update-caret self)))
                (reset-mode self)
                (set! previous-position pos))))))))
  
  
  (method protected virtual (mouse-copyable? self)
    selectable?)

  
  (method override (mouse-copy self event destination)
    (if (not selectable?)
        (nextmethod self event destination)
      (set! mouse-copy-selection (get-selection self))
      (set! mouse-copy-destination destination)
      (call-mouse-down self event)
      #t))
  
  
  (method override (drag-move self evt)
    (when mouse-selecting?
      (drag-move-action self (get-position evt))))
  
  
  (method (drag-move-action self view)
    (drag-select self view #f)
    (when (get-scroller self)
      (setup-autoscroll self (calculate-autoscroll-amount self view))))
  
  
  (method override (drag-up self evt . rest)
    (if mouse-selecting?
        (let ((view     (get-position evt))
              (alt?     (get-alt? evt))
              (control? (get-control? evt))
              (shift?   (get-shift? evt))
              (appl     (current-application)))
          (release-capture self)
          (kill-autoscroll self)
          (drag-select self view #t)
          (set! mouse-selecting? #f)
          (set! previous-position #f)
          (update-caret self)
          (set! selection-mode 'char)
          (unless alt?
            (process-selection-change self))
          @cant-replace-a-selection-by-pasting!
          (mouse-select-copy
            (lambda ()
              (get-selected-string)))
          (if mouse-copy-selection
              (let ((range (if (has-selection? self) (get-selection self) (expr-range self (get-start self)))))
                (if (or (not range)
                        (empty? range))
                    (set-selection self mouse-copy-selection ensure-displayed?: #f)
                  (let ((copy (get-string self range)))
                    (set-selection self mouse-copy-selection ensure-displayed?: #f)
                    (mouse-insert mouse-copy-destination copy))))
            (ensure-displayed self))
          (set! selection-inhibit? #f)
          (set! mouse-copy-selection #f)
          (set! mouse-copy-destination #f)
          (when (and (not alt?) control? (not shift?))
            (let ((recorder (get-recorder appl)))
              (when recorder
                (jazz.recorder:play-current-recording recorder))))
          (update-focus-actions appl))
        ;; link
      (when (view-enabled? self)
        (let* ((pos (view->text self (get-position evt)))
               (style (get-style-at model pos)))
          (when (is? style Link-Style)
            (let (@convert (anchor (get-anchor style))
                  (action (get-action style)))
              (define (invoke-action action pos style)
                (cond ((is? action Event-Handler)
                       (invoke action self (apply make-event Event :link self (get-properties action))))
                      (else
                       (action self pos style))))
              
              @convert
              (define (goto-anchor anchor)
                (for-each-heading model
                  (lambda (name heading line string)
                    (when (equal? string anchor)
                      (set-selection self (new Range$Cell$
                                            (new Cell line 0)
                                            (new Cell line (cardinality string))))))))
              
              (cond (action
                     (invoke-action action pos style))
                    @convert
                    (anchor
                     (goto-anchor anchor))
                    (else
                     (bell)))))))))
  
  
  (method (drag-select self view final?)
    (let ((pos (view->text self view)))
      ;; patch to manage the line selection border
      (when (and pos
                 (< (get-h view) (paragraph-left (get-paragraph self (get-line pos))))
                 (cell>=? pos (get-end-anchor self)))
        (set! pos (get-end (selection-line self (get-line pos)))))
      (when (and pos #t @parameterized-fix-me (/= pos previous-position))
        (let* ((range (selection-range self pos))
               (parts (range-difference range (get-selection self)))
               (player (get-player self)))
          (with-transformation-surface self
            (lambda (surface)
              (change-selection self pos generate-event?: #f)
              (with ((region (multi-part-region self parts (lambda (rect) (logical->device surface rect)))))
                (when region
                  (with ((platform-region (->platform-region region)))
                    (if final?
                        (invalidate-region player platform-region)
                      (redraw-window player region: platform-region)
                      (set! previous-position pos)))))))))))
  
  
  (method override (double-click self evt)
    (if selectable?
        (let ((view (get-position evt)))
          (let* ((pos (view->text self view))
                 (par (get-paragraph self (get-line pos))))
            (if (< (get-h view) (paragraph-left par))
                (select-paragraph self (get-line pos))
              (let ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos)))
                (with-safe-explore
                  (lambda ()
                    (when (outer-expr expl)
                      (set-selection self (get-range expl) set-anchor?: #t ensure-displayed?: #f))
                    (set! mouse-selecting? #t)
                    (set! selection-mode 'word)
                    (reset-mode self)
                    (set! previous-position pos)))))))
      (call-mouse-down self evt)))
  
  
  (method override (middle-mouse-down self evt)
    (unless (middle-mouse-paste
              (lambda (text)
                (paste-clipboard-string self text)))
      (mouse-down self evt)))
  
  
  (method public virtual (context-menu? self)
    #t)
  
  
  (method protected (context-menu-click self pos (move-caret: move-caret #f))
    (when (and (view-enabled? self) selectable? (context-menu? self))
      (acquire-focus self)
      (let ((text (view->text self pos)))
        (when (and (neq? move-caret 'never)
                   (or (eq? move-caret 'always) (< text (get-start self)) (>= text (get-end self))))
          (set-caret self (view->text self pos))
          (update-caret self)))))
  
  
  (method override (right-mouse-down self evt)
    (context-menu-click self (get-position evt)))
  
  
  (method override (context-menu self evt)
    (when (and (view-enabled? self) selectable? (context-menu? self))
      (let ((pos (get-position evt)))
        (let ((menu (get-context-menu self)))
          (when menu
            (track-popup-menu self menu pos))))))
  
  
  (method override (get-context-menu self)
    (text-menu (current-application) self))
  
  
  (method public (new-text-context-menu self)
    (let ((menu (new Text-Context-Menu)))
      (when (not editable?)
        (set-visible? (locate menu 'cut) #f)
        (set-visible? (locate menu 'paste) #f))
      (layout-menu menu)
      menu))
  
  
  (method public inline (new-range self start end)
    (new Range$Cell$ start end))
  
  
  (method (select-paragraph self line)
    (let ((limit (get-limit self)))
      (when (<= line limit)
        (let* ((par (get-paragraph self line))
               (len (get-length par)))
          (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell line len)))))))
  
  
  (method (selection-line self line <fx>)
    (let ((limit (get-limit self)))
      (and (<= line limit)
           (if (= line limit)
               (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length self line)))
             (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method (selection-range self pos)
    (let ((anchor (get-selection-anchor self)))
      (define (selection-range-from-anchor)
        (cond ((before? anchor pos)
               (new Range$Cell$ pos (get-end anchor)))
              ((after? anchor pos)
               (new Range$Cell$ (get-start anchor) pos))
              ;; else pos is inside anchor
              (else
               anchor)))
      
      (case selection-mode
        ((char)
         (selection-range-from-anchor))
        ((word)
         (if (inside? anchor pos)
             (selection-range-from-anchor)
           (let* ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos))
                  (kind (outer-expr expl explore-whitespace?: #f))
                  (range (and kind (get-range expl))))
             (cond ((not range)
                    (selection-range-from-anchor))
                   ((before? anchor pos)
                    (new Range$Cell$ (get-start range) (maximum (list (get-end range) (get-end anchor)))))
                   ;; else pos is after anchor
                   (else
                    (new Range$Cell$ (minimum (list (get-start range) (get-start anchor))) (get-end range)))))))
        (else (selection-range-from-anchor)))))
  
  
  (definition (range-difference x <Range$Cell$> y <Range$Cell$>)
    (let ((sx (get-start x))
          (ex (get-end x))
          (sy (get-start y))
          (ey (get-end y)))
      (if (and (= sx sy) (= ex ey))
          '()
        (cond ((= sx ex) (list y))
              ((= sy ey) (list x))
              ((or (< ex sy) (> sx ey))
               (list x y))
              (else
               (let ((parts (new List-Factory)))
                 (cond ((< sx sy) (put parts (new Range$Cell$ sx sy)))
                       ((> sx sy) (put parts (new Range$Cell$ sy sx))))
                 (cond ((< ex ey) (put parts (new Range$Cell$ ex ey)))
                       ((> ex ey) (put parts (new Range$Cell$ ey ex))))
                 (get-output parts)))))))
  
  
  (method (multi-part-region self parts transformer)
    (case (length parts)
      ((0) #f)
      ((1) (range-region self (car parts) transformer))
      ((2) (with ((region (range-region self (first parts) transformer)))
             (let ((union (range-region self (second parts) transformer)))
               (and region union
                 (begin
                   (combine-or! union region)
                   union)))))))
  
  
  (method (calculate-autoscroll-amount self view)
    (let* ((display (view->display self view))
           (size (get-size (get-display self)))
           (h (get-h display))
           (v (get-v display))
           (height (get-default-height self))
           (ah (cond ((< h 0) 8) ((> h (get-width size)) -8) (else 0)))
           (av (cond ((< v 0) height) ((> v (get-height size)) (- height)) (else 0))))
      (new Point ah av)))
  
  
  (method (setup-autoscroll self amount)
    (define (autoscroll-action)
      (drag-move-action self (mouse-position self))
      (scroll self amount)
      (update-view self))
    
    (if (nu=? amount {Point 0 0})
        (kill-autoscroll self)
      (when (not autoscroll-pulse)
        (set! autoscroll-pulse (new Pulse 'autoscroll 0.01 autoscroll-action delay: 0)))))
  
  
  (method (kill-autoscroll self)
    (close autoscroll-pulse)
    (set! autoscroll-pulse #f))
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method protected virtual (home-column self line col)
    (let ((column (get-column self line)))
      (if (= col 0)
          column
        0)))
  
  
  (method package (on-home self evt)
    (goto-home self (get-property evt document?:)
               (or locked-anchor? (get-property evt extend?:))))
  
  
  (method public (goto-home self document? extend?)
    (reset-mode self)
    (if document?
        (if extend?
            (change-selection self (text-beginning self))
          (set-caret self (text-beginning self)))
      (let* ((pos (selection-tail self 'backward))
             (line (get-line pos))
             (col (home-column self line (get-col pos)))
             (start (new Cell line col)))
        (if extend?
            (change-selection self start)
          (set-caret self start))
        (ensure-scrolled-left self))))
  
  
  (method package (on-end self evt)
    (goto-end self (get-property evt document?:)
              (or locked-anchor? (get-property evt extend?:))))
  
  
  (method public (goto-end self document? extend?)
    (reset-mode self)
    (if document?
        (if extend?
            (change-selection self (text-ending self))
          (set-caret self (text-ending self)))
      (goto-paragraph-end self extend-selection?: extend?)))
  
  
  (method public (goto-paragraph-end self (extend-selection?: extend-selection? #f))
    (let* ((pos (selection-tail self 'forward))
           (end (new Cell (get-line pos) (paragraph-length self (get-line pos)))))
      (if extend-selection?
          (change-selection self end)
        (set-caret self end))))
    
  
  (method (on-move self evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (arrow-move self evt)))


  (method public (arrow-move self evt)
    (let ((direction (get-property evt direction:))
          (extend? (or locked-anchor? (get-property evt extend?:)))
          (word? (get-property evt word?:))
          (scroll? (get-property evt scroll?:)))
      (case direction
        ((left) (left-arrow-move self extend? word?))
        ((right) (right-arrow-move self extend? word?))
        ((up) (up-arrow-move self extend? scroll?))
        ((down) (down-arrow-move self extend? scroll?)))))
  
  
  (method protected virtual (left-arrow-move self extend? word?)
    (textual-left-arrow-move self extend? word?))
  
  
  (method protected (textual-left-arrow-move self extend? word?)
    (reset-mode self)
    (if extend?
        (change-selection self (move-backward self (selection-tail self 'backward) word?))
      (if (empty-selection? self)
          (set-caret self (move-backward self (selection-tail self 'backward) word?))
        (set-caret self (get-start self)))))
  
  
  (method protected virtual (right-arrow-move self extend? word?)
    (textual-right-arrow-move self extend? word?))
  
  
  (method protected (textual-right-arrow-move self extend? word?)
    (reset-mode self)
    (if extend?
        (change-selection self (move-forward self (selection-tail self 'forward) word?))
      (if (empty-selection? self)
          (set-caret self (move-forward self (selection-tail self 'forward) word?))
        (set-caret self (get-end self)))))
  
  
  (method protected virtual (up-arrow-move self extend? scroll?)
    (textual-up-arrow-move self extend? scroll?))
  
  
  (method protected (textual-up-arrow-move self extend? scroll?)
    (reset-mode-on-anchor self)
    (let* ((pos (if extend? (selection-tail self 'backward) (get-start self)))
           (line (get-line pos))
           (col (get-col pos)))
      (cond (scroll?
              (let ((height (get-default-height self)))
                (scroll self (new Point 0 height))))
            (else
             (if (> line 0)
                 (move-verticaly self line col -1 'backward extend?)
               (unless extend? (reset-caret self (get-start self))))))))
  
  
  (method protected virtual (down-arrow-move self extend? scroll?)
    (textual-down-arrow-move self extend? scroll?))
  
  
  (method protected virtual (textual-down-arrow-move self extend? scroll?)
    (reset-mode-on-anchor self)
    (let* ((pos (if extend? (selection-tail self 'forward) (get-end self)))
           (line (get-line pos))
           (col (get-col pos)))
      (cond (scroll?
              (let ((height (get-default-height self)))
                (scroll self (new Point 0 (- height)))))
            (else
             (if (< line (get-limit self))
                 (move-verticaly self line col 1 'forward extend?)
               (unless extend? (reset-caret self (get-end self))))))))
  
  
  (method (on-widen-forward self evt)
    (let ((start (get-start self))
          (end (get-end self)))
      (let ((extend (next-word model end)))
        (set-selection self (new Range$Cell$ start extend)))))
  
  
  (method (reset-mode-on-anchor self)
    (if (and (has-selection? self) (nu=? (get-start self) (get-start-anchor self)) (nu=? (get-end self) (get-end-anchor self)))
        (reset-mode self)
      (reset-mode self keep: 'virtual)))
  
  
  (method (move-verticaly self line col inc direction shift?)
    (let* ((par     (get-paragraph self line))
           (h       (get-h (text->view self (new Cell line (if (has-selection? self) (get-col (selection-tail self 'forward)) col)))))
           (new-line (+ line inc))
           (new-par (get-paragraph self new-line))
           (new-len (paragraph-length self new-line))
           (new-end (get-h (text->view self (new Cell new-line new-len)))))
      (cond (virtual-h
             (move-caret self (new Cell new-line (min (get-col (view->text self (new Point virtual-h (get-top new-par)))) new-len)) direction shift?))
            ((> h new-end)
             (set! virtual-h h)
             (move-caret self (new Cell new-line new-len) direction shift?))
            (else
             (move-caret self (new Cell new-line (get-col (view->text self (new Point h (get-top new-par))))) direction shift?)))))
  
  
  (method protected virtual (move-caret self pos direction shift?)
    (unless (cell-displayed? self pos)
      (let ((height (get-default-height self)))
        (scroll self (new Point 0 (case direction ((forward) (- height)) ((backward) height))))))
    (if shift?
        (change-selection self pos)
      (set-caret self pos)))
  
  
  (method (on-backward-compound self evt)
    (let ((extend? (get-property evt extend?:)))
      (backward-compound self extend?: extend?)))
  
  
  (method (on-forward-compound self evt)
    (let ((extend? (get-property evt extend?:)))
      (forward-compound self extend?: extend?)))
  
  
  (method (on-upward-compound self evt)
    (upward-compound self))
  
  
  (method (on-downward-compound self evt)
    (downward-compound self))
  
  
  (method protected virtual (backward-compound self (extend?: extend? #f))
    (left-arrow-move self extend? #t))
  
  
  (method protected virtual (forward-compound self (extend?: extend? #f))
    (right-arrow-move self extend? #t))
  
  
  (method protected virtual (upward-compound self)
    (up-arrow-move self #f #t))
  
  
  (method protected virtual (downward-compound self)
    (down-arrow-move self #f #t))

  
  (method (on-transpose-word self evt)
    (transpose-word self))
  
  
  (method public (transpose-movements self forward backward)
    (if (has-selection? self)
        (bell)
      (with-atomic-undo (get-undoer model)
        (lambda ()
          (let ((left-expl <Text-Explorer> (new (explorer-class self) model))
                (right-expl <Text-Explorer> (new (explorer-class self) model)))
            (set-pos left-expl (get-start self))
            (backward left-expl)
            (set-pos right-expl (get-end self))
            (forward right-expl)
            (let ((left (get-range left-expl))
                  (right (get-range right-expl)))
              (if (or (not left) (not right))
                  (bell)
                (let ((ls (range-strings self left))
                      (rs (range-strings self right)))
                  (replace model right ls)
                  (replace model left rs)))))
          (set-modified? model #t)))))
  
  
  (method public (transpose-word self)
    (transpose-movements self
      (lambda (expl) (forward-non-word expl) (set-start expl (get-end expl)) (forward-word expl))
      (lambda (expl) (backward-non-word expl) (set-end expl (get-start expl)) (backward-word expl))))

  
  (method override (prior-page self shift?)
    (let* ((start (get-start self))
           (v (line->display-v self (get-line start))))
      (scroll self (new Point 0 (get-page-size self 'vert)))
      (let* ((line (display-v->line self v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection self dest)
          (set-caret self dest)))))
  
  
  (method override (next-page self shift?)
    (let* ((start (get-start self))
           (v (line->display-v self (get-line start))))
      (scroll self (new Point 0 (- (get-page-size self 'vert))))
      (let* ((line (display-v->line self v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection self dest)
          (set-caret self dest)))))
  
  
  (method (line->display-v self line) <fx>
    (let ((top (- (get-v position)))
          (v (line->view self line)))
      (- v top)))
  
  
  (method (display-v->line self v) <fx>
    (let* ((top (- (get-v position)))
           (pos (new Point left-padding (+ top v)))
           (text (view->text self pos)))
      (get-line text)))
  
  
  (method (selection-tail self direction) <Cell>
    (let ((anchor (get-selection-anchor self)))
      (cond ((after? anchor  (get-end self))
             (get-end self))
            ((before? anchor (get-start self))
             (get-start self))
            ;; else the selection is the same as the selection-anchor
            (else
             (case direction
               ((backward) (get-start self))
               ((forward)  (get-end self)))))))
  
  
  (method package (on-remove-spaces self evt)
    (if (not (empty-selection? self))
        (bell)
      (remove-spaces self (get-caret self) keep: (get-property evt keep:))))
  
  
  (method public (remove-spaces self pos (keep: keep 'one/none))
    (let ((expl <Text-Explorer> (new (explorer-class self) model start: pos end: pos)))
      (backward-whitespaces expl)
      (forward-whitespaces expl)
      (let* ((range (get-range expl))
             (one-left? (and (= (get-line (get-start range)) (get-line (get-end range))) (= (+ (get-col (get-start range)) 1) (get-col (get-end range))))))
        (replace model (get-range expl)
          (case keep
            ((none) (list ""))
            ((one) (list " "))
            ((one/none) (if one-left? (list "") (list " "))))))))
  
  
  (method package (on-display-info self evt)
    (user-message (info-message self)))
  
  
  (method protected virtual (info-message self)
    (let ((start (get-start self))
          (end (get-end self)))
      (format "Start: line {a} col {a}, End: line {a} col {a}"
              (+ (get-line start) 1) (+ (get-col start) 1)
              (+ (get-line end) 1) (+ (get-col end) 1))))
  
  
  (method package (on-user-code self evt)
    (let* ((appl (current-application))
           (profile (get-profile appl)))
      (user-code profile self)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method package (range-region self range <Range$Cell$> transformer (top: top #f) (bottom: bottom #f))
    (let ((root (get-root self))
          (region (new Cairo-Region))
          (width (get-width self)))
      (for-each-logical-range self range
        (lambda (line paragraph start end)
          (with ((sub (range-region paragraph left-padding start end width transformer)))
            (combine-or! region sub))))
      (with ((clipper (new Cairo-Region rect: (transformer (get-view-clipper self)))))
        (combine-and! region clipper))
      region))
  
  
  (method (line-range-rect self line start end)
    (let ((paragraph (get-paragraph self line)))
      (new Rect
        (get-h (col->view paragraph start))
        (line->view self line)
        (if end (get-h (col->view paragraph (max 1 end))) (get-width self))
        (+ (line->view self line) (if end (get-height (get-line-at paragraph end)) (get-default-height self))))))
  
  
  (method (invalidate-range self range <Range$Cell$>)
    (when (view-visible? self)
      (with-transformation-surface self
        (lambda (surface)
          (with ((region (range-region self range (lambda (rect) (logical->device surface rect)))))
            (with ((platform-region (->platform-region region)))
              (invalidate-region player platform-region)))))))
  
  
  ;; this should be unified with selection-region
  (method (text-selection-region self transformer top bottom)
    (range-region self (get-selection self) transformer top: top bottom: bottom))
  
  
  (method (selection-region-all self transformer)
    (text-selection-region self transformer 0 (get-display-height self)))
  
  
  (method protected virtual (get-selection-color self)
    (if completion-active?
        (or (get-completion-color (get-skin self)) {Color red: 128 green: 240 blue: 240})
      (or (get-active-selection-color (get-skin self)) {Color red: 190 green: 190 blue: 230})))
  
  
  (method package virtual (get-inactive-selection-color self)
    (or (get-inactive-selection-color (get-skin self)) {Color Unfocused-Selection}))
  
  
  (method public (for-each-logical-range self range <Range$Cell$> proc)
    (let ((start (get-start range))
          (end (get-end range)))
      (when (/= start end)
        (if (= (get-line start) (get-line end))
            (let ((line (get-line start)))
              (proc line (get-paragraph self line) (get-col start) (get-col end)))
          (let ((beginning (get-line start))
                (limit (get-line end)))
            (loop (for line from beginning to limit)
                  (let ((paragraph (get-paragraph self line)))
                    (cond ((= line beginning) (proc line paragraph (get-col start) #f))
                          ((= line limit) (proc line paragraph #f (get-col end)))
                          (else (proc line paragraph #f #f))))))))))
  
  
  (method public (for-each-range self range <Range$Cell$> proc)
    (for-each-logical-range self range
      (lambda (line paragraph start end)
        (proc line
              paragraph
              (or start 0)
              (or end (get-length paragraph))))))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method override (can-undo? self)
    (can-undo? model))
  
  
  (method override (can-redo? self)
    (can-redo? model))
  
  
  (method override (can-cut? self)
    (has-selection? self))
  
  
  (method override (can-copy? self)
    (has-selection? self))
  
  
  (method override (can-paste? self)
    #t)
  
  
  (method override (can-delete? self)
    (has-selection? self))
  
  
  (method override (can-select-all? self)
    #t)
  
  
  (method override (undo self)
    (undo model)
    (update-focus-actions (current-application)))
  
  
  (method override (redo self)
    (redo model)
    (update-focus-actions (current-application)))
  
  
  (method override (cut-selection self)
    (copy-selection self)
    (delete-selection self))
  
  
  (method override (copy-selection self)
    (if (empty-selection? self)
        (bell)
      (set-clipboard-text (join-lines (selection-lines self)))
      (add-clipboard (current-application))))
  
  
  (method override (paste-clipboard self)
    (let ((text (get-clipboard-text)))
      (if (not text)
          (bell)
        (paste-clipboard-string self text))))
  
  
  (method override (paste-clipboard-value self clipboard)
    (when (eq? (get-format clipboard) 'unicode-text)
      (paste-clipboard-string self (get-text clipboard))))
  
  
  (method override (cycle-paste-clipboard self previous-clipboard clipboard)
    (when (eq? (get-format clipboard) 'unicode-text)
      (if (or (not previous-clipboard) (neq? (get-format previous-clipboard) 'unicode-text))
          (paste-clipboard-value self clipboard)
        (let ((expl (new (explorer-class self) model)))
          (set-pos expl (get-start self))
          (with-atomic-undo (get-undoer model)
            (lambda ()
              (let ((actual-text (get-text previous-clipboard)))
                (when (looking-back? expl actual-text)
                  (backward-n expl (string-length actual-text))
                  (delete-range model (get-range expl)))
                (insert-string self (get-text clipboard)))))))))
  
  
  (method public virtual (paste-clipboard-string self string)
    (replace-selection self (split-lines string)))


  (method package (on-paste&stay self evt)
    (paste&stay self))


  (method package (on-paste&next self evt)
    (paste&stay self)
    (down-arrow-move self #f #f))
  
  
  (method (paste&stay self)
    (let ((pos (get-start self)))
      (paste-clipboard self)
      (set-caret self pos)))
  
  
  (method package (on-paste-cycle-ring self evt)
    (paste-cycle-ring (current-application) #f))


  (method package (on-paste-cycle-ring-reversed self evt)
    (paste-cycle-ring (current-application) #t))
  
  
  (method override (delete-selection self)
    (unless (empty-selection? self)
      (replace-selection self (list ""))))
  
  
  (method override (select-all self . rest)
    (set-selection self (buffer-selection self)))
  
  
  (method public (clear-all self)
    (select-all self)
    (delete-selection self))
  
  
  ;;;
  ;;;; Mark
  ;;;
  
  
  (method package (on-set-mark self evt)
    (set-mark self (get-selection self))
    (user-message "Marked"))
  
  
  (method package (on-jump-mark self evt)
    (when mark
      (let ((mark (valid-range self mark)))
        (if (or locked-anchor? (get-property evt extend?:))
            (set-selection self (new Range$Cell$
                             (minimum (list (get-start-anchor self) (get-start mark)))
                             (maximum (list (get-end-anchor self) (get-end mark)))))
          (let ((new-mark mark))
            (set-mark self (get-selection self))
            (set-selection self new-mark))))))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method public (get-marks self)
    marks)
  
  
  (method public (add-mark self mark)
    (set! marks (cons mark marks)))
  
  
  (method public (remove-mark self mark)
    (set! marks (remove! mark marks)))
  
  
  (method package (adjust-marks self range caret procs)
    (for-each (lambda (mark)
                (let ((change-proc (adjust mark (get-start range) (get-end range) caret)))
                  (when change-proc
                    (enqueue procs change-proc))))
              marks))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method override (empty-selection self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-beginning self)))
  
  
  (method override (reset-selection self)
    (set-range-noupdate selection (empty-selection self))
    (set-range-noupdate selection-anchor (empty-selection self)))
  
  
  (method (buffer-selection self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-ending self)))
  
  
  (method override (line-selected? self line) <bool>
    #f)
  
  
  (method public (text-beginning self) <Cell>
    (new Cell 0 0))
  
  
  (method public (text-ending self) <Cell>
    (let ((limit (get-limit self)))
      (new Cell limit (paragraph-length self limit))))
  
  
  (method public (text-range self) <Range$Cell$>
    (new Range$Cell$ (text-beginning self) (text-ending self)))
  
  
  (method public (text-empty? self) <bool>
    (= (text-beginning self) (text-ending self)))
  
  
  (method public inline (get-start self) <Cell>
    (get-start selection))
  
  
  (method public inline (get-end self) <Cell>
    (get-end selection))
  
  
  (method inline override (get-selection self) <Range$Cell$>
    (get-range selection))
  
  
  (method override (set-selection self range <Range$Cell$>
                                  (force?: force? #f)
                                  (reposition: reposition #f)
                                  (ensure-displayed?: ensure-displayed? #t)
                                  (generate-event?: generate-event? #t)
                                  (set-anchor?: set-anchor? #t))
    (validate-range self range)
    (when (and (or force? (/= (cast <Range$Cell$> (get-selection self)) range))
               (not selection-inhibit?))
      (hide-caret self)
      (when set-anchor?
        (set-selection-anchor self range))
      (update-selection self range)
      (update-caret self)
      (when (and ensure-displayed? (not mouse-selecting?))
        (ensure-displayed self reposition: reposition center?: (eq? ensure-displayed? 'center-caret)))
      (unless (and (get-mouse-down?) (eq? (get-mouse-in) self))
        (let ((appl (current-application)))
          ;; quick hack for sejour
          (when (is? appl Application)
            (update-focus-actions appl))))
      (when generate-event?
        (process-selection-change self))))
  
  
  (method public (update-selection self range <Range$Cell$>)
    (if (not (view-visible? self))
        (set-range selection range)
      (with-transformation-surface self
        (lambda (surface)
          (let ((transformer (lambda (rect) (logical->device surface rect))))
            (with ((old (selection-region-all self transformer)))
              (set-range selection range)
              (with ((new (selection-region-all self transformer)))
                (if (and old new)
                    (begin
                      (combine-xor! new old)
                      (with ((platform-region (->platform-region new)))
                        (invalidate-region player platform-region)))
                  (when old
                    (with ((platform-region (->platform-region old)))
                      (invalidate-region player platform-region)))
                  (when new
                    (with ((platform-region (->platform-region new)))
                      (invalidate-region player platform-region)))))))))))
  
  
  (method public (reset-caret self pos <Cell> . rest)
    (apply set-selection self (new Range$Cell$ pos pos) rest))
  
  
  (method (fit-range self range <Range$Cell$>)
    (let* ((ending (text-ending self))
           (start (get-start range))
           (end (get-end range))
           (s (when (> start ending) ending))
           (e (when (> end ending) ending)))
      (when (or s e)
        (new Range$Cell$ (or s start) (or e end)))))
  
  
  (method public (get-selection-anchor self)
    (get-range selection-anchor))
  
  
  (method public (get-start-anchor self)
    (get-start selection-anchor))
  
  
  (method public (get-end-anchor self)
    (get-end selection-anchor))
  
  
  (method public (set-selection-anchor self range)
    (set-range selection-anchor (copy range)))
  
  
  (method public (lock-anchor self)
    (set! locked-anchor? #t))
  
  
  (method public (unlock-anchor self)
    (set! locked-anchor? #f))
  
  
  ;; The selection change up to a specified position
  (method public (change-selection self pos . rest)
    (bind-keywords ((set-anchor? #f) . others) rest
      (when pos (apply set-selection self (selection-range self pos) set-anchor?: set-anchor? others))))
  
  
  (method public (get-caret self) <Cell>
    (get-start self))
  
  
  (method public (set-caret self pos . rest)
    (when pos
      ;; lisp tabulate can return negative col
      (let* ((line (min (max 0 (get-line pos)) (get-limit self)))
             (par (get-paragraph self line))
             (col (min (max 0 (get-col pos)) (get-length par)))
             (caret
               (if (and (= line (get-line pos))
                        (= col (get-col pos)))
                   pos
                 (new Cell line col))))
        (apply reset-caret self caret rest))))
  
  
  (method package virtual (selection-change self)
    )
  
  
  (method public (has-selection? self)
    (/= (get-start self) (get-end self)))
  
  
  (method public (empty-selection? self)
    (= (get-start self) (get-end self)))
  
  
  (method public (at-beginning? self)
    (and (= (get-start self) (get-end self))
         (= (get-start self) (text-beginning self))))
  
  
  (method public (at-end? self)
    (and (= (get-start self) (get-end self))
         (= (get-start self) (text-ending self))))
  
  
  (method public (at-line-start? self)
    (= (get-col (get-start self)) 0))
  
  
  (method public (selected-lines self)
    (let* ((start (get-start self))
           (end (get-end self))
           (end-line (if (= (get-col end) 0) (- (get-line end) 1) (get-line end))))
      (naturals (get-line start) (+ end-line 1))))
  
  
  (method public (for-each-selected-paragraph self proc)
    (let ((selection (get-selection self)))
      (for-each-paragraph model proc
        start: (get-line (get-start selection))
        end: (get-line (get-end selection)))))
  
  
  (method override (invalidate-selection self sel)
    (invalidate-range self sel))
  
  
  (method override (selection-region self sel transformer)
    (range-region self sel transformer))
  
  
  (method public (get-char self pos <Cell>) <char>
    (let ((line (get-line pos))
          (col (get-col pos)))
      (let ((string (get-string (get-paragraph self line))))
        (if (< col (cardinality string))
            (element string col)
          #\newline))))
  
  
  (method public (get-string self range <Range$Cell$>) <string>
    (join-lines (range-strings self range)))
  
  
  (method public (next! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) (paragraph-length self (get-line pos)))
           (increase-col pos)
           #t)
          ((< (get-line pos) (get-limit self))
           (increase-line pos)
           (set-col pos 0)
           #t)
          (else
           #f)))
  
  
  (method public (previous! self pos <Cell>) <bool>
    (cond ((/= (get-col pos) 0)
           (increase-col pos -1)
           #t)
          ((> (get-line pos) 0)
           (increase-line pos -1)
           (set-col pos (paragraph-length self (get-line pos)))
           #t)
          (else
           #f)))
  
  
  (method public (next-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (next! self cell)
           cell)))
  
  
  (method public (previous-cell self pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (and (previous! self cell)
           cell)))
  
  
  (method (selection-lines self)
    (range-strings self (get-selection self)))
  
  
  (method public (get-selected-string self) <string+>
    (and (has-selection? self)
         (get-string self (get-selection self))))
  
  
  (method public (get-selected-strings self)
    (get-range-strings self (get-selection self)))
  
  
  (method public (get-range-strings self range)
    (if (empty? range)
        '()
      (range-strings self range)))
  
  
  (method public (next-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((next! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (previous-pos self pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((previous! self pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (get-column self line <fx>) <fx>
    (let ((pos (new Cell line 0)))
      (while (memq? (get-char self pos) '(#\space #\tab))
        (increase! pos))
      (get-col pos)))
  
  
  (method (on-goto-line self evt)
    (let* ((start (get-start self))
           (line (get-line start))
           (str (request-string title: "Goto Line" prefix: "Line no:" initial-value: (->string (+ line 1)))))
      (cond ((starts-with? str "+")
             (goto-line self (+ line (parse-integer (subseq str 1 (cardinality str))))))
            ((starts-with? str "-")
             (goto-line self (- line (parse-integer (subseq str 1 (cardinality str))))))
            (else
             (goto-line self (- (parse-integer str) 1))))))
  
  
  (method public (goto-line self line)
    (cond ((< line 0)
           (set-selection self (new Range$Cell$ (new Cell 0 0) (new Cell 1 0))))
          ((>= line (get-limit self))
           (let ((line (get-limit self)))
             (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length self line))))))
          (else
           (set-selection self (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method override (added-update-selection self line count)
    )
  
  
  (method override (removed-update-selection self line count)
    #f)
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (on-lock-anchor self evt)
    (lock-anchor self)
    (user-message "Anchor locked"))
  
  
  (method package (on-unlock-anchor self evt)
    (unlock-anchor self)
    (user-message "Anchor unlocked"))
    
  
  (method package (on-toggle-lock-anchor self evt)
    (if locked-anchor?
        (on-unlock-anchor self evt)
      (on-lock-anchor self evt)))
  
  
  ;;;
  ;;;; Text Actions
  ;;;
  
  
  (method public (add-text-action self text-action)
    (set! text-actions (cons text-action text-actions)))
  
  
  (method public (run-text-action self text-action)
    (when (memq text-action text-actions)
      (text-action)
      (remove! text-action text-actions)))
  
  
  (method public (remove-all-text-actions self)
    (set! text-actions '()))
  
  
  ;;;
  ;;;; Highlights
  ;;;
  
  
  (method public (add-highlight self highlight)
    (set! highlights (cons highlight highlights)))
  
  
  (method public (remove-highlight self highlight)
    (set! highlights (remove! highlight highlights)))
  
  
  (method public (remove-all-highlights self)
    (set! highlights '())
    (invalidate-view self))
  
  
  (method public (invalidate-highlight self highlight)
    (invalidate-range self (valid-range self (get-range highlight))))
  
  
  (method public (invalidate-non-showed-highlights self)
    (for-each (lambda (highlight)
                (when (not (get-show-unfocused? highlight))
                  (invalidate-highlight self highlight)))
              highlights))

  
  ;;;
  ;;;; Layout
  ;;;
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method override (layout-scrollee-patch self)
    (update-displayed self))
  
  
  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method override (size-change self size)
    (nextmethod self size)
    ;; because for the moment wrap is done in the
    ;; model it is dependent on our display size
    (when (get-wrap? model)
      (layout-scrollee model)))
  
  
  (method override (scrollee-width self)
    (let ((width (scrollee-width model)))
      (if (and scroller fit-to-scroller?)
          (max (get-display-width self) width)
        width)))
  
  
  (method override (dynamic-scrollee? self)
    (not fit-to-scroller?))
  
  
  (method override (dynamic-set-scrollee-size self)
    (let ((size (dimension-max {Dimension 10 10} (scrollee-size self))))
      (set-size self size)
      (let ((scroller (get-scroller self)))
        (when scroller
          (let ((scroller-size (dimension-min (get-size (get-parent (get-scroller self))) size)))
            (set-size-noevent (get-scroller self) scroller-size)
            (set-size-noevent (get-content (get-scroller self)) scroller-size)
            (layout-view (get-parent (get-scroller self))))))))
  
  
  ;; until we maintain it incrementally
  (method package virtual (dynamic-scrollee-width? self)
    (or (not fit-to-scroller?)
        (<= (get-visible-count model) 16)))
  
  
  (method override (scrollee-content-width self)
    (scrollee-content-width model))
  
  
  (method package virtual (scrollee-size-update self size)
    )
  
  
  ;;;
  ;;;; Paragraph
  ;;;


  (method public (get-length self) <fx>
    (get-length model))
  
  
  (method public (get-limit self) <fx>
    (get-limit model))
  
  
  (method public (get-paragraph self line <fx>) <Paragraph>
    (get-paragraph model line))
  
  
  (method public (paragraph-string self line <fx>) <string>
    (paragraph-string model line))
  
  
  (method public (paragraph-length self line <fx>) <fx>
    (paragraph-length model line))
  
  
  (method public (first-paragraph self)
    (first-paragraph model))
  
  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (get-print-area self context)
    (get-print-area model context))
  
  
  (method override (paginate self page-width page-height)
    (let ((selected? #f @tmp (has-selection?)))
      (let ((start (if selected? (get-line (get-start self)) 0))
            (end (+ (if selected? (get-line (get-end self)) (get-limit self)) 1)))
        (paginate-range model start end page-width page-height))))
  
  
  (method override (setup-printing self)
    (setup-printing model))
  
  
  (method override (restore-printing self preserved)
    (restore-printing model preserved))
  
  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method package virtual (draw-enabled? self)
    (view-enabled? self))
  
  
  (method override (get-drawing-background self context)
    (let ((skin (get-skin self)))
      (if (not (draw-enabled? self))
          (or (get-disabled-background skin)
              {Color Medium})
        (or (get-background skin)
            (nextmethod self context)))))
  
  
  ;; quick copy/paste of outline-view draw-background
  ;; to let get-drawing-background decide the disabled 
  (method override (draw-background self surface context)
    (let ((background (cond ((debug-paint?)
                             (cycle-debug-color!))
                            (else
                             (get-drawing-background self context)))))
      (when (and background (neq? background 'none))
        (let ((bounds (get-bounds self)))
          (fill-rect surface bounds background)))))
  
  
  (method override (draw-children self surface nodes context)
    (define (draw-highlights)
      (let ((focus? (has-focus? self))
            (tabs (get-tabs model)))
        (for-each (lambda (highlight)
                    (when (or focus? (get-show-unfocused? highlight))
                      (let ((range (get-range highlight))
                            (style (get-style highlight)))
                        (let* ((start (get-start range))
                               (end (get-end range))
                               (paragraph (get-paragraph self (get-line start)))
                               (target (subseq (get-string paragraph) (get-col start) (get-col end)))
                               (info (text->view-extended self start))
                               (line (car info))
                               (pos (cdr info))
                               (height (get-height line))
                               (format (get-format paragraph))
                               (left (get-left-margin format))
                               (enabled? (draw-enabled? self)))
                          (draw-style style surface '() target (get-h pos) (get-v pos) height tabs left enabled?)))))
                  highlights)))
    
    (define (draw-caret)
      (when (and caret-visible? (empty-selection? self) (or (not (get-mouse-down?)) (and (not (alt-down?)) (not (meta-down?)))))
        (let ((rect <Rect> (caret-rect self (get-caret self))))
          (fill-rect surface rect (or (get-caret-color (get-skin self)) {Color red: .706 green: .005 blue: .995})))))
    
    (let ((top #f)
          (bottom #f)
          (printing? (getf context printing?:)))
      (unless printing?
        (draw-selection self surface top bottom))
      (nextmethod self surface nodes context)
      (draw-highlights)
      (unless printing?
        (draw-caret))))
  
  
  (method protected virtual (draw-selection self surface top bottom)
    (when (and (or (is-focused? self) show-unfocused-selection?) selectable?)
      (with ((region (text-selection-region self identity top bottom)))
        (when region
          (fill-region surface region
            (if (is-focused? self)
                (get-selection-color self)
              (get-inactive-selection-color self)))))))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method override (get-skin self)
    (find-skin 'ui:text))
  
  
  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method override (ensure-displayed self . rest)
    (let ((selection (get-selection self)))
      (when selection
        (apply ensure-range-displayed self selection rest))))
  
  
  (method public (ensure-cell-displayed self pos <Cell>)
    (let* ((start (text->view self pos))
           (end (+ start (new Point 0 (get-height-at self pos)))))
      (scroll self (scroll-needed self start end (get-scroll-context self)))))
  
  
  (method public (ensure-range-displayed self range <Range$Cell$> . rest)
    (unless update-locked?
      (let* ((start (get-start range))
             (end (get-end range))
             (end-height (get-height-at self end)))
        (scroll self (apply scroll-needed self (text->view self start) (+ (text->view self end) (new Point 0 end-height)) (get-scroll-context self) rest)))))
  
  
  (method public (ensure-scrolled-left self)
    (unless update-locked?
      (when (/= 0 (get-h (get-position self)))
        (let* ((size (get-display-width self))
               (context (cdr (get-scroll-context self)))
               (context (if context (fxround (cast <fl> (* size context))) 0))
               (tail (+ (get-scrolled-distance-h self) size))
               (end (get-h (text->view self (get-end self)))))
          (when (< end (- tail context))
            (scroll self (new Point (- tail context end) 0)))))))
  
  
  (method public (cell-displayed? self pos)
    (let* ((start (text->view self pos))
           (end (+ start (new Point 0 (get-height-at self pos)))))
      (= (scroll-needed self start end #f) {Point 0 0})))
  
  
  (method (on-center-caret self evt)
    (center-caret self))
  
  
  (method (on-top-caret self evt)
    (top-caret self))
  
  
  (method public (center-caret self)
    (let* ((start (get-bottom (get-row self (get-line (get-start self)))))
           (end (get-top (get-row self (get-line (get-end self)))))
           (size (- end start))
           (height (get-display-height self))
           (top (if (>= size height)
                    start
                  (let ((half (fxround/ (- height size) 2)))
                    (- start half)))))
      (scroll-to self (new Point 0 (- top)))))
  
  
  (method public (center-undisplayed-caret self)
    (when (or (not (cell-displayed? self (get-start self)))
              (not (cell-displayed? self (get-end self))))
      (center-caret self)))
  
  
  (method public (top-caret self)
    (let ((start (get-top (get-row self (get-line (get-start self))))))
      (scroll-to self (new Point 0 (- start)))))
  
  
  ;;;
  ;;;; Constituent
  ;;;
  
  
  (method public virtual (get-constituent-test self)
    (get-constituent-test syntax))
  
  
  (method public virtual (text-constituent? self char)
    (text-constituent? syntax char))
  
  
  (method public virtual (get-match-test self)
    (get-match-test syntax))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method public (move-forward self pos word?)
    (move-forward model pos word?))
  
  
  (method public (move-backward self pos word?)
    (move-backward model pos word?))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-char self c)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (insert-char model (get-selection self) c)))))
  
  
  (method public (insert-string self str)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (insert-string model (get-selection self) str)))))
  
  
  (method public (insert-styled self string style)
    (when (write-allowed? self)
      (let ((start (get-start self))
            (style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (insert-string self string)
        (stylize-range model (new Range$Cell$ start (get-start self)) style))))
  
  
  (method public (replace-styled self range strings style)
    (when (write-allowed? self)
      (let ((start (get-start range))
            (style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (let ((end (replace model range strings)))
          (let ((range (new Range$Cell$ start end)))
            (stylize-range model range style)
            range)))))
  
  
  (method public (stylize-range self range style)
    (when (write-allowed? self)
      (let ((style (cond ((is? style Style) style) ((not style) (get-default-style model)) (else (locate-style model style)))))
        (stylize-range model range style))))
  
  
  (method public (insert-line self line (proper? #t))
    (when (write-allowed? self)
      (replace-selection self (if proper? (list line "") (list line)))))
  
  
  (method public (insert-bulleted-line self line)
    (when (write-allowed? self)
      (let ((line (get-line (get-start self))))
        (insert-line self line)
        (toggle-bulleted model line))))
  
  
  (method public (insert-newline self)
    (when (write-allowed? self)
      (end-completion self)
      (insert-string self "\n")))
  
  
  (method public (insert-link self string (font: font #f) (anchor: anchor #f) (action: action #f))
    (when (write-allowed? self)
      (let* ((font (or font {Font Link}))
             (style (new Link-Style font: font color: {Color Link} anchor: anchor action: action)))
        (insert-styled self string style))))
  
  
  (method public (insert-image self moniker)
    (when (write-allowed? self)
      (let ((style (new Image-Style moniker: moniker)))
        (insert-styled self " " style))))
  
  
  (method public (insert-view self view/form)
    (when (write-allowed? self)
      (let* ((view (if (is? view/form View) view/form (instantiate view/form)))
             (end (get-end self))
             (paragraph (get-paragraph self (get-line end))))
        (set-parent view paragraph)
        (let ((style (new View-Style view: view)))
          (insert-styled self " " style)))))
  
  
  ;;;
  ;;;; Replace
  ;;;
  
  
  (method public (backspace self word?)
    (when (write-allowed? self)
      (unless (at-beginning? self)
        (if (has-selection? self)
            (delete-selection self)
          (updating-caret self
            (lambda ()
              (delete-range model (new Range$Cell$ (move-backward self (get-start self) word?) (get-end self)))))))))
  
  
  (method public virtual (delete-char self)
    (delete-action self #f))
  
  
  (method public virtual (delete-word self)
    (delete-action self #t))
  
  
  (method public (delete-action self word?)
    (when (write-allowed? self)
      (unless (at-end? self)
        (if (has-selection? self)
            (delete-selection self)
          (updating-caret self
            (lambda ()
              (delete-range model (new Range$Cell$ (get-start self) (move-forward self (get-end self) word?)))))))))
  
  
  (method package virtual (content-changing self range strings)
    )
  
  
  (method package virtual (content-changed self range strings undo-range undo-strings)
    (let ((event (new Replace-Event :replace self (modifiers-mask) range strings undo-range undo-strings)))
      (call-content-change self #f event: event)))
  
  
  (method public (replace self range <Range$Cell$> strings)
    (when (write-allowed? self)
      (without-caret self
        (lambda ()
          (updating-caret self
            (lambda ()
              (replace model range strings)))))))
  
  
  (method package (replace-text self range <Range$Cell$> strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace model range strings)))))
  
  
  (method public (replace-selection self strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace model (get-selection self) strings)))))
  
  
  (method (updating-caret self proc)
    (hide-caret self)
    (let ((caret (proc)))
      (when caret
        (set-caret self caret force?: #t)
        (update-caret self))))
  
  
  ;;;
  ;;;; Formatted
  ;;;
  
  
  (method package (copy-formatted-selection self)
    (if (empty-selection? self)
        (bell)
      (let ((output (open-output-string)))
        (print-formatted model output (get-selection self))
        (let ((text (get-output-string output)))
          (set-clipboard-text text format: 'jazz-formatted-text)))))
  
  
  (method (paste-formatted-clipboard self)
    (let ((clipboard (get-clipboard '(jazz-formatted-text unicode-text))))
      (if (not clipboard)
          (bell)
        (paste-formatted-clipboard-value self clipboard))))
  
  
  (method (paste-formatted-clipboard-value self clipboard)
    (case (get-format clipboard)
      ((jazz-formatted-text)
       (let ((text (get-clipboard-text format: 'jazz-formatted-text)))
         (let ((info (parameterize ((walk-for #f))
                       (with-jazz-readtable
                         (lambda ()
                           (read-string-element text))))))
           (replace-formatted-selection self info))))
      ((unicode-text)
       (let ((strings (split-lines (get-clipboard-text))))
         (replace-selection self strings)))))
  
  
  (method protected (replace-formatted-selection self strings)
    (when (write-allowed? self)
      (updating-caret self
        (lambda ()
          (replace-formatted model (get-selection self) strings)))))
  
  
  (method package (replace-formatted-text self range <Range$Cell$> strings formats styles paragraphs)
    (when (write-allowed? self)
      (without-caret self
        (lambda ()
          (replace-formatted-text model range strings formats styles paragraphs)))))
  
  
  ;;;
  ;;;; Text Formatted
  ;;;
  
  
  (definition protected formatted-start-delimiter
    #\x02)
  
  (definition protected formatted-end-delimiter
    #\x03)
  
  
  (method public virtual (insert-formatted-line self line)
    (call-with-input-string line
      (~ process-formatted self)))
  
  
  (method protected (process-formatted self input)
    (define (process-string)
      (let ((output (open-output-string)))
        (let (iterate)
          (let ((c (peek-char input)))
            (if (or (eof-object? c)
                    (eqv? c formatted-start-delimiter)
                    (eqv? c formatted-end-delimiter))
                (insert-styled self (get-output-string output) 'Output)
              (write-char (read-char input) output)
              (iterate))))))
    
    (define (process)
      (let ((c (peek-char input)))
        (when (and (not (eof-object? c))
                   (not (eqv? c formatted-end-delimiter)))
          (cond ((eqv? c formatted-start-delimiter)
                 (read-char input)
                 (let ((directive (read-formatted-parameter input)))
                   (process-formatted-directive self directive input)))
                (else
                 (process-string)))
          (process))))
    
    (process))
  
  
  (method (with-formatted-range self input proc)
    (let ((start (get-start self)))
      (process-formatted self input)
      (let ((end-char (read-char input)))
        (if (eof-object? end-char)
            (error "Incomplete formatted input, EOF reached")
          (let ((end (get-start self)))
            (proc (new Range$Cell$ start end)))))))
  
  
  (method protected virtual (process-formatted-directive self directive input)
    (case directive
      ((%)
       (insert-newline self))
      (($)
       (unless (at-line-start? self)
         (insert-newline self)))
      ((bold)
       (with-formatted-range self input
         (lambda (range)
           (toggle-bold model range))))
      ((italic)
       (with-formatted-range self input
         (lambda (range)
           (toggle-italic model range))))
      ((underline)
       (with-formatted-range self input
         (lambda (range)
           (toggle-underline model range))))
      ((color)
       (let ((color (read-formatted-parameter input)))
         (with-formatted-range self input
           (lambda (range)
             (set-text-color model range (registered-color color))))))
      ((font)
       (let ((font (read-formatted-parameter input)))
         (with-formatted-range self input
           (lambda (range)
             (set-text-font model range (registered-font font))))))
      (else
       (error "Unknown text directive: {s}" directive))))
  
  
  (definition (read-formatted-parameter input)
    (prog1 (read input)
      (read-char input)))
  
  
  ;;;
  ;;;; Format
  ;;;
  
  
  (method public (add-format self name pref-format) <Format>
    (add-format model name pref-format))
  
  
  ;;;
  ;;;; Style
  ;;;

  
  (method public (add-style self name pref-style) <Style>
    (add-style model name pref-style))
  
  
  (method public (locate-style self name/style (error?: error? #t)) <Style>
    (locate-style model name/style error?: error?))
  
  
  ;;;
  ;;;; Height
  ;;;
  
  
  (method public (get-default-height self) <fx>
    (get-default-height model))
  
  
  (method public (get-height-at self pos <Cell>) <fx>
    (get-height-at model pos))
  
  
  ;;;
  ;;;; Chapters
  ;;;
  
  
  (method public virtual (get-headers self) <list+>
    #f)
  
  
  (method public virtual (get-chapters self) <list>
    (let ((headers (get-headers self)))
      (if (not headers)
          '()
        (let ((occurences (text-regular-search-all model (map make-search-context headers)))
              (chapters (new List-Factory)))
          (for-each (lambda (info)
                      (bind (from . to) info
                        (let ((line (get-line from))
                              (col (get-col from)))
                          (when (= col (get-column self line))
                            (let ((string (paragraph-string self line)))
                              (let ((header (subseq string col (get-col to)))
                                    (level (if (= col 0) 1 2))
                                    (label (get-chapter-label self string col from to)))
                                (put chapters (list level from header label))))))))
                    occurences)
          (get-output chapters)))))
  
  
  (method public virtual (get-chapter-label self string col from to)
    (subseq string (+ col (- (get-col to) (get-col from))))
    @fixme-slow
    (subseq string (+ col (- (position-offset model to) (position-offset model from)))))
  
  
  (method public virtual (get-first-special? self) <bool>
    #t)
  
  
  (method public virtual (get-first-chapter self lst)
    (if (get-first-special? self)
        (if (null? lst) #f (car lst))
      (let ((file (get-moniker self)))
        (list 0
              (text-beginning self)
              ""
              (if (not file)
                  "<Top>"
                (get-name file))))))
  
  
  (method public virtual (get-remaining-chapters self lst)
    (if (get-first-special? self)
        (if (null? lst) '() (cdr lst))
      lst))
  
  
  (method package (select-chapter self pos)
    (let* ((pos (valid-cell self pos))
           (line (get-line pos))
           (col (get-col pos))
           (len (paragraph-length self line))
           (range (new Range$Cell$ (new Cell line col) (new Cell line len))))
      (set-selection-safe self range ensure-displayed?: #f)
      (ensure-displayed self force-vertical: 'head)))
  
  
  ;;;
  ;;;; Expression
  ;;;
  
  
  (method public (current-name self)
    (let ((range (current-expr-range self)))
      (and range
           (name-at self range))))
  
  
  (method public (current-symbol self)
    (let ((expr (current-expr self)))
      (and (symbol? expr)
           expr)))
  
  
  (method public (current-expr self)
    (current-name self))
  
  
  (method public (current-expr-range self)
    (or (effective-selection self)
        (expr-range self (get-end self))))
  
  
  (method public (current-expr-string self)
    (let ((range (current-expr-range self)))
      (and range
           (get-string self range))))
  
  
  (method public virtual (name-at self range)
    (name-at syntax range))


  (method public virtual (expr-at self pos)
    (expr-at syntax pos))
  
  
  (method public virtual (range-expr self range)
    (range-expr syntax range))
  
  
  (method public virtual (expr-range self pos)
    (expr-range syntax pos))
  
  
  (method public (outer-range self range)
    (outer-range syntax range))
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method override (mouse-insert self copy)
    (define (separate? before after)
      (and (not (or (memv? before '(#\- #\.))
                    (memv? after '(#\- #\.))))
           (or (text-constituent? self before) (memv? before '(#\) #\] #\} #\")))
           (or (text-constituent? self after) (memv? after '(#\( #\[ #\{ #\" #\' #\,)))))
    
    (let ((start (get-start self))
          (end (get-end self))
          (str (localize copy)))
      (when (nu=? start end)
        (let ((prev (and (/= start (text-beginning self)) (get-char self (previous-cell self start))))
              (next (and (/= end (text-ending self)) (get-char self end))))
          (when (and prev (separate? prev (element str 0)))
            (set! str (string-append " " str)))
          (when (and next (separate? (last str) next))
            (set! str (string-append str " ")))))
      (insert-string self str)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method public (range-strings self range <Range$Cell$>) <list>
    (let ((start (get-start range))
          (end (get-end range)))
      (if (= (get-line start) (get-line end))
          (list (subseq (paragraph-string self (get-line start)) (get-col start) (get-col end)))
        (let ((dest (new List-Factory)))
          (put dest (subseq (paragraph-string self (get-line start)) (get-col start)))
          (put-sequence dest (map (~ paragraph-string self) (naturals (+ (get-line start) 1) (get-line end))))
          (put dest (subseq (paragraph-string self (get-line end)) 0 (get-col end)))
          (get-output dest)))))
  
  
  (method public (range-first-string self range <Range$Cell$>) <string>
    (first (range-strings self range)))
  
  
  ;;;
  ;;;; Column
  ;;;
  
  
  (definition Marked-Column
    #f)
  
  
  (method (on-mark-column self evt)
    (mark-column self))
  
  
  (method (on-fill-to-column self evt)
    (fill-to-column self))
  
  
  (method (mark-column self)
    (let* ((start (get-start self))
           (col (get-col start)))
      (set! Marked-Column col)
      (user-message "Marked to column {a}" col)))
  
  
  (method (fill-to-column self)
    (if (or (has-selection? self) (not Marked-Column))
        (bell)
      (let* ((start (get-start self))
             (col (get-col start))
             (delta (- Marked-Column col)))
        (case (sign delta)
          ((1) (insert-string self (make-string delta #\space)))))))
  
  
  ;;;
  ;;;; Formats
  ;;;
  
  
  (method package (on-upcase-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (upcase (get-selected-string self)))))))
  
  
  (method package (on-downcase-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (downcase (get-selected-string self)))))))
  
  
  (method (on-capitalize-selection self evt)
    (if (empty-selection? self)
        (bell)
      (with-preserved-selection self
        (lambda ()
          (insert-string self (capitalize (get-selected-string self)))))))
  
  
  (method package (with-preserved-selection self proc)
    (let ((selection (get-selection self))
          (anchor (get-selection-anchor self)))
      (proc)
      (set-selection self (valid-range self selection))
      (set-selection-anchor self (valid-range self anchor))))
  
  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method public (view->text self pos <Point>) <Cell>
    (define (effective-line v)
      (cond ((< v 0)
             0)
            ((>= v (get-visible-height model))
             (get-limit self))
            (else
             (v->line self v))))
    
    (let ((v (get-v pos)))
      (let ((line (effective-line v)))
        (assert line
          (let ((par (get-paragraph self line)))
            (let ((col (view->col par (- pos (get-position par)))))
              (assert col
                (new Cell line col))))))))
  
  
  (method public (text->view self pos <Cell>) <Point>
    (let* ((par (get-paragraph self (get-line pos)))
           (view (col->view par (get-col pos))))
      (new Point
        (get-h view)
        (+ (line->view self (get-line pos)) (get-v view)))))
  
  
  (method public (text->view-extended self pos <Cell>)
    (let* ((par (get-paragraph self (get-line pos)))
           (info (col->view-extended par (get-col pos)))
           (line (car info))
           (view (cdr info)))
      (cons line (new Point
                   (get-h view)
                   (+ (line->view self (get-line pos)) (get-v view))))))
  
  
  (method (line->view self line <fx>) <fx>
    (let ((par (get-paragraph self line)))
      (get-v (get-position par))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-range self range <Range$Cell$>) <void>
    (let ((start (get-start range))
          (end (get-end range)))
      (unless (and (= (valid-cell self start) start)
                   (= (valid-cell self end) end))
        (error "Invalid text range: {t}" range))))
  
  
  (method public (valid-line self line)
    (let ((limit (get-limit self)))
      (if (> line limit)
          limit
        line)))
  
  
  (method public (valid-cell self cell) <Cell>
    (let ((limit (get-limit self)))
      (define (restrict-row cell)
        (if (> (get-line cell) limit)
            (new Cell limit 0)
          cell))
      
      (define (restrict-col cell)
        (let ((line (get-line cell))
              (col (get-col cell)))
          (let ((len (paragraph-length self line)))
            (if (> col len)
                (new Cell line len)
              cell))))
      
      (restrict-col (restrict-row cell))))
  
  
  (method public (valid-range self range) <Range$Cell$>
    (new Range$Cell$
      (valid-cell self (get-start range))
      (valid-cell self (get-end range))))
  
  
  (method public (set-selection-safe self range . rest)
    (apply set-selection self (valid-range self range) rest))
  
  
  ;;;
  ;;;; Styles
  ;;;
  
  
  (method public (set-selection-format/style self name)
    (let ((selection (get-selection self))
          (start (get-start self))
          (end (get-end self)))
      (let ((empty? (empty-selection? self))
            (span? (neq? (get-paragraph self (get-line start)) (get-paragraph self (get-line end)))))
        (let ((format (and (or empty? span?) (locate-format model name error?: #f) (new Format base: name)))
              (style (and (locate-style model name error?: #f) (new Text-Style base: name))))
          (when style
            (cond ((or empty? span?)
                   (for-each-paragraph model
                     (lambda (line <fx> paragraph <Paragraph>)
                       (set-text-style model (new Range$Cell$ (new Cell line 0) (new Cell line (get-length paragraph))) style))
                     start: (get-line start)
                     end: (get-line end)))
                  (else
                   (set-text-style model selection style))))
          (when format
            (for-each-paragraph model
              (lambda (line <fx> paragraph <Paragraph>)
                (set-paragraph-format model paragraph format))
              start: (get-line start)
              end: (get-line end)))
          (set-modified? model #t)
          (layout-scrollee self)
          (invalidate-view self)))))
  
  
  (method (on-bold self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-bold model (get-selection self))
      (set-modified? model #t)))
  
  
  (method (on-italic self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-italic model (get-selection self))
      (set-modified? model #t)))
  
  
  (method (on-underline self evt)
    (if (empty-selection? self)
        (bell)
      (toggle-underline model (get-selection self))
      (set-modified? model #t)))
  
  
  ;;;
  ;;;; Ruler
  ;;;
  
  
  (method public virtual (get-ruler self)
    #f)
  
  
  (method (on-toggle-ruler self evt)
    (let ((ruler (get-ruler self)))
      (if (not ruler)
          (bell)
        (set-shown? ruler (not (get-shown? ruler))))))
  
  
  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method public (set-selection-font-name self name)
    (for-each-range self (get-selection self)
      (lambda (line paragraph start end)
        (set-font-name paragraph start end name)
        (wrap-paragraph model '() paragraph)))
    (set-modified? model #t)
    (layout-scrollee self)
    (invalidate-view self))
  
  
  (method public (set-selection-point-size self size)
    (for-each-range self (get-selection self)
      (lambda (line paragraph start end)
        (set-point-size paragraph start end size)
        (wrap-paragraph model '() paragraph)))
    (set-modified? model #t)
    (layout-scrollee self)
    (invalidate-view self))
  
  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (definition (pick-text-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-highlight-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-frame-color sender)
    (popup-colors (get-parent sender) geometry: {Cell 3 8}))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (method protected (has-completion? self)
    (and completion-active? (has-selection? self)))
  
  
  (method package (has-ambiguous-completion? self)
    (and completion-active? (not completion-unique?) (has-selection? self)))
  
  
  (method protected (has-effective-selection? self)
    (and (not completion-active?) (has-selection? self)))
  
  
  (method protected (empty-effective-selection? self)
    (or completion-active? (empty-selection? self)))
  
  
  (method protected (effective-selection self)
    (and (has-effective-selection? self)
         (get-selection self)))


  (method protected (set-completion self range unique?)
    (set! completion-active? #t)
    (set! completion-unique? unique?)
    (set-selection self range))
  

  (method (remove-completion self)
    (when completion-active?
      (delete-selection self)
      (set! completion-active? #f)))


  (method package (end-completion self)
    (when completion-active?
      (set! completion-active? #f)
      (set-caret self (get-end self))))
  
  
  (method package virtual (auto-complete? self)
    #f)


  (method package virtual (favorite-completions? self)
    #t)


  (method package virtual (favorite-completions self)
    (favorite-completions syntax))


  (method protected virtual (favorite-completion self name)
    (assoc-value name (favorite-completions self) #f))


  (method package virtual (completion-name self pos)
    )


  (method (completion-string self pos)
    (define (skip-prefix name)
      (if name
          (let ((len (string-length name)))
            (if (and (> len 0) (eqv? (string-ref name 0) #\<))
                (substring name 1 len)
              name))
        #f))
    
    (define (alphabetize-completion completions offset)
      (let ((alphabet-char (remove-duplicates
                             (sort char<?
                                   (map (lambda (completion)
                                          (if (> (string-length completion) offset) (element completion offset) #\space))
                                        completions)))))
        (coerce alphabet-char String)))
    
    (let ((name (skip-prefix (completion-name self pos))))
      (if (not name)
          (values #f #f)
        (let ((size (string-length name))
              (favorite (and (favorite-completions? self) (or (get-user-completion name) (favorite-completion self name))))
              (feedback? (not (macro-playing? (current-application)))))
          (if favorite
              (begin
                (when feedback?
                  (clear-user-message))
                (values (subseq favorite size) #t))
            (if (not (complete-name? self size))
                (begin
                  (when feedback?
                    (clear-user-message))
                  (values #f #f))
              (let* ((completions (symbol-completions self name))
                     (count (length completions)))
                (cond ((= count 0)
                       (when feedback?
                         (clear-user-message))
                       (values #f #f))
                      ((= count 1)
                       (let ((found (car completions)))
                         (when feedback?
                           (user-message "{a}" found))
                         (if (string=? name found)
                             (values #f #f)
                           (values (subseq found size) #t))))
                      ((> count 5)
                       (let* ((common (completions-prefix self completions))
                              (offset (string-length common))
                              (alphabet (alphabetize-completion completions offset)))
                         (when feedback?
                           (user-message "{a} ... [{a}]" common alphabet))
                         (values (subseq common size) #f)))
                      (else
                       (let ((common (completions-prefix self completions)))
                         (when feedback?
                           (user-message "{l detail: :human}" completions))
                         (values (subseq common size) #f)))))))))))
  
  
  (method package virtual (complete-name? self size)
    (>= size (get-auto-complete-minimum (preferences self))))
  
  
  (method package virtual (symbol-completions self name)
    '())
  
  
  (method protected virtual (completions-prefix self completions)
    (prefix completions))
  
  
  (method protected virtual (auto-complete self key)
    (with-atomic-undo (get-undoer model)
      (lambda ()
        (get-style-at model (get-start self))
        (let* ((end (get-end self))
               (last (and (> (get-col end) 0) (get-char self (- end 1))))
               (class (class-of self)))
          (if (not (auto-complete-char? self key last))
              (begin
                (insert-char self key)
                (complete-at self (get-start self)))
            (let* ((completion (join-lines (selection-lines self)))
                   (offset (and completion (find completion key)))
                   (replacement (and offset (subseq completion 0 offset))))
              (when (and completion-active? replacement)
                (replace-selection self (list replacement)))
              (end-completion self)
              (insert-char/backspace self key)
              (complete-at self (get-start self))))))))
  
  
  (method package virtual (auto-complete-char? self key last)
    (auto-complete-char? syntax key last))
  

  (method (complete-at self pos <Cell> (auto-complete?: auto-complete? (unspecified)))
    (define (reset-completion)
      (set! completion-active? #t)
      (set! completion-unique? #t))
    
    (unless (or (textual-style? model (get-style-at model pos))
                (macro-active? (current-application)))
      (let ((pref (preferences self)))
        (let ((auto-complete? (if (specified? auto-complete?) auto-complete? (get-auto-complete? pref))))
          (if (not auto-complete?)
              (reset-completion)
            (receive (completion unique?) (completion-string self pos)
              (if (not completion)
                  (reset-completion)
                (insert-string self completion)
                (set-completion self (new Range$Cell$ pos (+ pos (cast <fx> (cardinality completion)))) unique?))))))))
  
  
  (method protected (convert-completion self)
    (when completion-active?
      (let ((start (get-start self))
            (end (get-end self)))
        (end-completion self)
        (set-selection self (new Range$Cell$ start end) set-anchor?: #f))))


  (method protected (insert-char/backspace self c (word?: word? #f))
    (case c
      ((#\backspace)
       (remove-completion self)
       (backspace self word?))
      (else
       (insert-char self c))))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method (on-search-forward-mode self evt)
    (select-command-search (current-application) 'forward
      (search-context model (get-selected-string self) ignore-case?: #t)))
  
  
  (method (on-search-backward-mode self evt)
    (select-command-search (current-application) 'backward
      (search-context model (get-selected-string self) ignore-case?: #t)))
  
  
  (method (on-search-current self evt)
    (define (single-line strings)
      (if (null? strings)
          ""
        (car strings)))
    
    (let ((range (current-expr-range self)))
      (if (not range)
          (select-command-search (current-application) 'forward (search-context model #f ignore-case?: #t))
        (let ((current (single-line (get-range-strings self range))))
          (select-command-search-current (current-application) 'forward range (search-context model current ignore-case?: #t))))))

  
  (method public (text-expression-search self string (start: start #f) (end: end (get-limit self)) (reversed?: reversed? #f))
    (let* ((expl (new (explorer-class self) model start: (text-beginning self) end: (text-beginning self)))
           (moniker (get-moniker self))
           (mode (if (or (not moniker) (ci=? (get-extension moniker) "jazz")) 'code 'quotation))
           (found (jazz.editor.lisp:search-expressions expl mode string position #f #f)))
      (and found
           (car found))))

  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method public virtual (select-next self search-context (end: end #f))
    (let ((found (text-regular-search model search-context start: (get-end self) end: end reversed?: #f)))
      (and found
           (bind (from . to) found
             (set-selection self (new Range$Cell$ from to))
             @fixme-slow
             (set-selection (new Range$Cell$ from (offset-position model (+ (position-offset model from) (- (position-offset model to) (position-offset model from))))))
             (ensure-displayed self)
             (ensure-scrolled-left self)
             #t))))
  
  
  (method public virtual (select-previous self search-context (end: end #f))
    (let ((found (text-regular-search model search-context start: (get-start self) end: end reversed?: #t)))
      (and found
           (bind (from . to) found
             (set-selection self (new Range$Cell$ from to))
             @fixme-slow
             (set-selection (new Range$Cell$ from (offset-position model (+ (position-offset model from) (- (position-offset model to) (position-offset model from))))))
             (ensure-displayed self)
             (ensure-scrolled-left self)
             #t))))
  
  
  (method public virtual (select-expr self search-context direction)
    (case direction
      ((forward) (select-expr-forward self search-context))
      ((backward) (select-expr-backward self search-context))))
  
  
  (method public virtual (select-expr-forward self search-context)
    (set-caret self (text-beginning self))
    (select-next self search-context))
  
  
  (method public virtual (select-expr-backward self search-context)
    (set-caret self (text-ending self))
    (select-previous self search-context))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor self (context: context #f))
    (new jazz.text.descriptors:Text-View-Descriptor)))


;;;
;;;; Text-Event
;;;


(class Text-Event extends Event)


;;;
;;;; Replace-Event
;;;


(class Replace-Event extends Event
  
  
  (slot range        getter generate)
  (slot strings      getter generate)
  (slot undo-range   getter generate)
  (slot undo-strings getter generate)


  (method override (initialize self kind sender modifiers range strings undo-range undo-strings)
    (nextmethod self kind sender modifiers)
    (set! self.range range)
    (set! self.strings strings)
    (set! self.undo-range undo-range)
    (set! self.undo-strings undo-strings))))
