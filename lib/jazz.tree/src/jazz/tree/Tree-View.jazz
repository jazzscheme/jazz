;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Tree View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Stephane Le Cornec
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.tree.Tree-View jazz


(import (jazz.action)
        (jazz.application)
        (jazz.component)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.locale)
        (jazz.locator)
        (jazz.markup)
        (jazz.menu)
        (jazz.outline)
        (jazz.preferences)
        (jazz.selection)
        (jazz.skin)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window))


(class Tree-View extends Outline-View-Old implements Selection-Provider
  

  ;;;
  ;;;; Lexicon
  ;;;
  
  
  ;; visible   : a row that has all its parents expanded
  ;; displayed : a row that is displayed on-screen even if only partially
  ;; row       : a Row object
  ;; column    : a Column object
  ;; site      : a Site object (row + column)
  ;; line      : the rank of a visible row
  ;; col       : the rank of a visible column
  ;; cell      : a Cell object (line + col)
  
  
  ;;;
  ;;;; Notes
  ;;;
  
  
  ;; For now, cell selection-mode only supports single select mode

  
  (definition delayed-autorow
    #f)

  
  (property protected portfolio                 initialize #f   accessors explicit)
  (property protected show-header?              initialize #t   accessors generate)
  ;; row cell node
  (property protected selection-mode            initialize 'row accessors explicit)
  (property protected multiple-selection?       initialize #f   accessors explicit)
  (property protected can-select-empty?         initialize #t   accessors explicit)
  (property protected always-select?            initialize #f   accessors generate)
  (property protected show-unfocused-selection? initialize #t   accessors explicit)
  (property protected focused-on-descendants?   initialize #f   accessors explicit)
  (property protected auto-expand/collapse?     initialize #f   accessors generate)
  (property protected cell-background           initialize #f   accessors explicit)
  (property protected empty-background          initialize #f   accessors explicit)
  (property protected filled-column             initialize #t   accessors generate)
  (property protected column-spacing            initialize 0    accessors explicit)
  (property protected column-frequency          initialize 1    accessors explicit)
  (property protected reorderable?              initialize #f   accessors generate)
  (property protected content                   initialize #f   accessors explicit)
  
  
  (slot protected columns                       initialize '()  getter generate)
  (slot protected node-column                   initialize #f   getter generate)
  (slot protected sorted-columns                initialize '()  getter generate)
  (slot protected selection-pivot               initialize #f)
  (slot protected highlighted                   initialize '())
  (slot protected indentation                   initialize 16   getter generate)
  (slot protected columns-right            <fx> initialize 0    getter generate)
  (slot protected edited-site                   initialize #f   getter generate)
  (slot protected cell-editor                   initialize #f   getter generate)
  (slot protected auto-expanded-row             initialize #f   setter generate)
  (slot protected locator                       initialize (new Tree-Locator self))
  (slot protected selection-manager             initialize (new Selection-Manager self))
  (slot protected merge-cell-table              initialize (make-table test: site=? hash: site-hash) getter generate)
  
  
  (form
    (<install> background: {Color Tree-Background}))


  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (prepare self rest)
    (nextmethod self rest)
    (set! selection '()))
  
  
  (method override (finish self rest)
    (nextmethod self rest)
    (invalidate-columns self)
    (fill-column self)
    (invalidate-header self))
  
  
  (method override (destroy-component self)
    (end-edition self)
    (nextmethod self))
  

  ;;;
  ;;;; Component
  ;;;


  (method override (add-child self child)
    (nextmethod self child)
    (when (is? child Tree-Column)
      (set! columns (append! columns (list child)))
      (invalidate-columns self)
      (fill-column self)
      (invalidate-header self)))
  
  
  (method override (remove-child self child)
    (nextmethod self child)
    (unless (destroying? self)
      (when (is? child Tree-Column)
        (set! columns (remove! child columns))
        (when (eq? child node-column)
          (set! node-column #f))
        ;; should idealy be done incrementaly
        (invalidate-columns self)
        (fill-column self)
        (invalidate-header self))))

  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-portfolio self)
    (and portfolio
         (if (is? portfolio Portfolio)
             portfolio
           (set! portfolio (child self portfolio))
           portfolio)))


  (method public (set-portfolio self object)
    (set! portfolio object)
    (invalidate-view self))


  (method public (get-multiple-selection? self)
    multiple-selection?)


  (method public (set-multiple-selection? self flag)
    (set! multiple-selection? flag)
    (invalidate-view self))


  (method public (get-can-select-empty? self)
    can-select-empty?)


  (method public (set-can-select-empty? self flag)
    (set! can-select-empty? flag)
    (invalidate-view self))


  (method public (get-show-unfocused-selection? self)
    show-unfocused-selection?)


  (method public (set-show-unfocused-selection? self flag)
    (set! show-unfocused-selection? flag)
    (invalidate-view self))


  (method public (get-focused-on-descendants? self)
    focused-on-descendants?)


  (method public (set-focused-on-descendants? self flag)
    (set! focused-on-descendants? flag)
    (invalidate-view self))


  (method public (get-selection-mode self)
    selection-mode)


  (method public (set-selection-mode self value)
    (set! selection-mode value)
    (invalidate-view self))


  (method public (get-cell-background self)
    cell-background)
  
  
  (method public (set-cell-background self color)
    (set! cell-background color)
    (invalidate-view self))
  
  
  (method public (get-empty-background self)
    empty-background)
  
  
  (method public (set-empty-background self color)
    (set! empty-background color)
    (invalidate-view self))


  (method public (get-column-spacing self)
    column-spacing)


  (method public (set-column-spacing self spacing)
    (set! column-spacing spacing)
    (invalidate-view self))


  (method public (get-column-frequency self)
    column-frequency)


  (method public (set-column-frequency self frequency)
    (set! column-frequency frequency)
    (invalidate-view self))


  ;;;
  ;;;; Focus
  ;;;


  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-selection self selection))


  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-selection self selection))
  
  
  (method public (selection-border self)
    (if (focused? self)
        (focused-border self)
      (unfocused-border self)))
  
  
  (method protected virtual (focused-border self)
    (get-focused-border (get-skin self)))
  
  
  (method protected virtual (unfocused-border self)
    (get-unfocused-border (get-skin self)))
  
  
  (method public (selection-color self)
    (if (focused? self)
        (focused-color self)
      (unfocused-color self)))
  
  
  (method protected virtual (focused-color self)
    (or (get-focused-color (get-skin self))
        {Color Focused-Selection}))
  
  
  (method protected virtual (unfocused-color self)
    (or (get-unfocused-color (get-skin self))
        {Color Unfocused-Selection}))
  
  
  (method public (selected-text-color self)
    (if (focused? self)
        {Color Focused-Selected-Text}
      {Color Unfocused-Selected-Text}))
  
  
  (method public virtual (focused? self)
    (or (is-focused? self)
        (and focused-on-descendants?
             (contains-focus? self))))
  
  
  (method public (focus-and-select self)
    (acquire-focus self)
    (when (> (get-visible-count self) 0)
      (set-single-selection self 0)))


  ;;;
  ;;;; Actions
  ;;;
  

  (method override (focus-actions self)
    (cons (find-actions 'tree)
          (nextmethod self)))


  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-expand self evt)
    (let ((row (get-selected-row self)))
      (if (not row)
          (bell)
        (expand self row))))
  
  
  (method (on-expand-all self evt)
    (let ((row (get-selected-row self)))
      (if (not row)
          (bell)
        (expand-all self row))))
  
  
  (method (on-collapse self evt)
    (let ((row (get-selected-row self)))
      (if (not row)
          (bell)
        (collapse self row))))
  
  
  (method (on-collapse-all self evt)
    (let ((row (get-selected-row self)))
      (if (not row)
          (bell)
        (collapse-all self row))))
  
  
  (method protected virtual (on-properties self evt)
    )
  
  
  ;;;
  ;;;; Header
  ;;;
  
  
  (method public (get-header self)
    (and parent (let ((header (get-parent parent)))
                  (and (is? header Tree-Header)
                       header))))
  
  
  (method public (invalidate-header self)
    (let ((header (get-header self)))
      (when header
        (invalidate-view header))))
  
  
  (method virtual (make-header-menu self column)
    #f)


  (method public (header-menu self column pos)
    (let ((menu (make-header-menu self column)))
      (and menu
           (layout-menu menu)
           (let ((header (get-header self)))
             (track-popup-menu self menu (acquire self header (point+ pos (header-position header column))))))))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method override (find-subdrawing self surface <Surface> device-pos <Point> pos <Point> ignore)
    (or (let ((cell (view->tree self pos)))
          (and cell
               (let ((merge-cell (get-merge-cell self (cell->site self cell))))
                 (and merge-cell
                      (let ((data (get-site-data self (get-first-site merge-cell))))
                        (and (is? data View)
                             (let ((row (get-parent data)))
                               (let ((position (get-position row))
                                     (size (get-size row)))
                                 ;; bypassing the row's find-in-drawing as the merge-cell can exceed the row's bounds
                                 (with-clipping-transformation surface (get-h position) (get-v position) (get-width size) (get-height size) (get-transformation row)
                                   (lambda ()
                                     (find-in-drawing data surface device-pos ignore)))))))))))
        (nextmethod self surface device-pos pos ignore)))


  ;;;
  ;;;; Layout
  ;;;
  
  
  (method package (layout-column self column)
    (let ((row (get-next root-row))
          (rt 0))
      (while row
        (let* ((height (get-effective-height row))
               (rb (+ rt height)))
          (set-size row (new Dimension columns-right height))
          (set! rt rb)
          (set! row (get-next row))
          (increase! rt row-spacing)))))
  

  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method override (layout-scrollee self)
    ;; column width change must be done before calling nextmethod
    (unless (or update-locked? (inhibit-scrollee-layouts?))
      (when filled-column
        (fill-column self)))
    (nextmethod self))
  
  
  (method override (scrollee-width self)
    (let ((width (if show-header? columns-right (+ visible-width column-spacing))))
      (if (and scroller fit-to-scroller?)
          (max (get-display-width self) width)
        width)))
  

  ;;;
  ;;;; Update
  ;;;
  
  
  ;; todo: do both of these in a single pass
  (method override (update-visible self)
    (define (update-visible-height)
      (let ((count 0)
            (height 0)
            (first? #t))
        (for-each-visible-row self
          (lambda (row line)
            (increase! count)
            (increase! height (get-effective-height row))
            (if first?
                (set! first? #f)
              (increase! height row-spacing))))
        (set! visible-count count)
        (set! visible-height height)))
    
    ;; todo: can very easily optimize the text-h call away by calculating at the start the
    ;; base (text-h for some row - level * indentation) and then only adding level * indentation
    (define (update-visible-width)
      (when (not show-header?)
        (let ((width 0))
          ;; a quick not too clean solution for now...
          (when (is? node-column Tree-Node-Column)
            (for-each-visible-row self
              (lambda (row line)
                (let* ((highlight-border 3)
                       (nw (+ (or (calculate-node-width row) 0) highlight-border))
                       (w (+ (text-h node-column (get-level row)) nw)))
                  (when (> w width)
                    (set! width w)))))
            (set! visible-width width)
            (set! columns-right width)
            (set-borders node-column (cons 0 width))
            (set-width node-column width)))))
    
    (update-visible-height)
    (update-visible-width))
  
  
  (method override (scroll-invalidate self delta)
    (nextmethod self delta)
    (when (/= (get-x delta) 0)
      (invalidate-header self)))


  ;;;
  ;;;; Drawing
  ;;;
  
  
  (definition Highlighted-Outer-Color
    (new Color red: 0 green: 0 blue: 128))
  
  (definition Highlighted-Inner-Color
    (new Color red: 218 green: 218 blue: 255))
    
  (definition Highlighted-Insert-Color
    {Color Dark-Red})
  
  
  (method override (get-drawing-background self context)
    (or (get-background (get-skin self))
        (nextmethod self context)))

  
  (method override (draw-outline self surface context clipper scrolled-v)
    (nextmethod self surface context clipper scrolled-v)
    (let ((right (+ (get-right clipper) (get-h (get-position self))))
          (height (get-height self)))
      (when (and (view-enabled? self) empty-background (<= columns-right right))
        (let ((rect (new Rect columns-right 0 right height)))
          (fill-rect surface rect (if (debug-paint?) (cycle-debug-color!) empty-background)))))
    (draw-highlighted self surface))
  
  
  (method override (draw-empty self surface top bottom rt width)
    (when (and (view-enabled? self) empty-background (<= rt bottom))
      (let ((rect (new Rect 0 rt width bottom)))
        (fill-rect surface rect (if (debug-paint?) (cycle-debug-color!) empty-background)))))
  
  
  (method (draw-highlighted self surface)
    (for-each-reversed (lambda (highlight)
                         (let ((row (get-row highlight))
                               (col (get-col highlight))
                               (insert (get-insert highlight)))
                           (if (not insert)
                               (draw-highlighted-cell self surface row col highlight)
                             (let ((rect (highlighted-insert-rect self row insert)))
                               (fill-rect surface rect Highlighted-Insert-Color)))))
                       highlighted))
  
  
  (method protected virtual (draw-highlighted-cell self surface row col highlight)
    (let* ((inner-rect (highlighted-target-rect self row col))
           (outer-rect (inflate-rect inner-rect 1 1)))
      (let ((outer-color (or (get-outer-color highlight) (highlighted-outer-color self)))
            (inner-color (or (get-inner-color highlight) (highlighted-inner-color self))))
        (frame-rect surface outer-rect outer-color)
        (when (highlight-inner? self)
          (frame-rect surface inner-rect inner-color)))))
  
  
  (method protected virtual (highlighted-outer-color self)
    Highlighted-Outer-Color)
  
  
  (method protected virtual (highlighted-inner-color self)
    Highlighted-Inner-Color)
  
  
  (method protected virtual (highlight-inner? self)
    #t)
  
  
  (method public virtual (header-color self)
    {Color Medium})
  
  
  (method override (draw-children self surface <Surface> nodes context)
    (define (paint-data context column row h v width height data)
      (let ((view? (is? data View)))
        (with-clipping-transformation surface h v width height (and view? (get-transformation data))
          (lambda ()
            (if (not view?)
                (draw-data column surface context row data width height)
              (render-drawing data surface context))))))
    
    (define (paint-merge-cell merge-cell)
      (let ((rect (merge-cell-rect self merge-cell)))
        (receive (top-left bottom-right) (merge-corner-site self merge-cell)
          (let ((left-column (get-column top-left))
                (top-row (get-row top-left))
                (left (get-left rect))
                (top (get-top rect))
                (right (get-right rect))
                (bottom (get-bottom rect))
                (data (get-site-data self (get-first-site merge-cell)))
                (selected? (merge-cell-selected? self merge-cell)))
            (let ((new-context `(selected?: ,selected? line: ,(row->line self top-row) ,@context)))
              (paint-data new-context left-column top-row left top (- right left) (- bottom top) data))))))
    
    (parameterize ((redrawn-merge-cells (make-table test: eq?)))
      (nextmethod self surface nodes context)
      (iterate-table (redrawn-merge-cells)
        (lambda (merge-cell value)
          (paint-merge-cell merge-cell)))))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method override (get-skin self)
    (find-skin 'ui:tree))
  
  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method public (get-highlighted self)
    highlighted)
  
  
  (method public (set-highlighted self value)
    (define (invalidate-highlighted highlighted)
      (for-each (lambda (highlight)
                  (let ((row (get-row highlight))
                        (col (get-col highlight))
                        (insert (get-insert highlight)))
                    (if (not insert)
                        (invalidate-highlighted-cell self row col)
                      (invalidate-rect self (highlighted-insert-rect self row insert)))))
                highlighted))
    
    (assert (every? (lambda (object) (is? object Tree-Highlight)) value))
    (when (not (equal? value highlighted))
      (let ((old highlighted))
        (set! highlighted value)
        (invalidate-highlighted old)
        (invalidate-highlighted highlighted))))
  
  
  (method protected virtual (invalidate-highlighted-cell self row col)
    (with ((inner (highlighted-target-rect self row col))
           (outer (inflate-rect inner 1 1))
           (region (frame-region outer insets: {Rect 2 2 2 2})))
      (invalidate-region self region)))

  
  (method (highlighted-target-rect self row col)
    (if (not col)
        (cell-text-rect self (new Cell (row->line self row) 0))
      (cell-rect self (new Cell (row->line self row) col))))
  
  
  (method (highlighted-insert-rect self row insert)
    (let* ((height (get-height self))
           (line (row->line self row))
           (rect (line-rect self line) @old-l&f-probably-better (cell-content-rect (new Cell line 0)))
           (before-first? (and (= line 0) (eq? insert 'before)))
           (after-last? (and (= line (- visible-count 1)) (eq? insert 'after)))
           (half-spacing (- (fxround/ row-spacing 2) 1))
           (offset (cond (before-first? 0)
                         (after-last? -2)
                         ((eq? insert 'after) half-spacing)
                         (else (- half-spacing row-spacing))))
           (proc
            (lambda (v)
              (let* ((top (+ v offset))
                     (bottom (+ top 2)))
                (new Rect (get-left rect) top (get-right rect) bottom)))))
      (case insert
        ((before) (proc (get-top rect)))
        ((after) (proc (get-bottom rect))))))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method override (update-visible-width-incremental self level width)
    @wait-optimized
    (let ((width (+ (text-h node-column level) width)))
      (when (> width visible-width)
        (set! visible-width width))))

  
  (method override (remove-row self row)
    (when (and (attached? row) (eq? row auto-expanded-row))
      (close-auto-expanded-row self))
    (nextmethod self row))
  
  
  (method override (remove-every-row self)
    (close-auto-expanded-row self)
    (set-sorted-column self #f #f)
    (set! highlighted '())
    (set! selection-pivot #f)
    (unmerge-all-cells self)
    (nextmethod self))
  
  
  (method public (unmerge-all-cells self)
    (empty-table merge-cell-table))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method override (cursor-update self evt)
    (if (mouse-copy? self evt)
        (set-cursor :finger)
      (nextmethod self evt)))
  

  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (allow-start-drag? self pos)
    (and (nextmethod self pos)
         (allow-start-drag? selection-manager)))
  
  
  (method override (mouse-down self evt)
    (let ((view (get-position evt)))
      (let* ((cell (view->tree self view))
             (pos (and cell (cell-coordinates self cell view)))
             (part (and cell (find-part (get-column self (get-col cell)) cell pos))))
        (mouse-down selection-manager view part (get-shift? evt) (get-control? evt) (get-alt? evt) (get-multiple-selection? self)))
      (acquire-focus self)
      (acquire-capture self)
      (let ((cell (view->tree self view))
            (shift? (get-shift? evt))
            (control? (get-control? evt)))
        (if (not cell)
            (when can-select-empty?
              (set-selection self '() user-origin: 'mouse))
          (let ((pos (cell-coordinates self cell view))
                (column (get-column self (get-col cell))))
            (mouse-down column cell pos shift? control?))))))
  
  
  (method override (drag-move self evt)
    (let ((view (get-position evt)))
      (let ((cell (view->tree self view)))
        (when cell
          (let ((pos (cell-coordinates self cell view))
                (column (get-column self (get-col cell))))
            (drag-move column cell pos))))))
  
  
  (method override (drag-up self evt (dragging? #f))
    (let ((shift? (get-shift? evt))
          (control? (get-control? evt))
          (alt? (get-alt? evt)))
      (mouse-up selection-manager shift? control? alt?)
      (let ((pos (get-mouse-view selection-manager)))
        (when (and pos (not (mouse-part-control? selection-manager)))
          (let ((cell (view->tree self pos)))
            (when cell
              (let ((row (get-row self (get-line cell)))
                    (column (get-column self (get-col cell))))
                (when auto-expand/collapse?
                  (auto-expand/collapse self row))
                (focus-delegate self)
                (drag-up column cell pos))))
          (process-action self self))))
    (release-capture self)
    (reset selection-manager))
  
  
  (method override (call-double-click self evt)
    (let ((view (get-position evt)))
      (let ((cell (view->tree self view)))
        (when cell
          (let* ((pos (cell-coordinates self cell view))
                 (column (get-column self (get-col cell)))
                 (part (find-part column cell pos)))
            (case part
              ((control) (mouse-down self evt))
              ((content) (nextmethod self evt))
              (else (double-click column cell pos))))))))
  
  
  (method override (double-click self evt)
    (double-click selection-manager (get-shift? evt) (get-control? evt) (get-alt? evt))
    (let ((view (get-position evt)))
      (let ((cell (view->tree self view)))
        (when cell
          (let* ((pos (cell-coordinates self cell view))
                 (column (get-column self (get-col cell)))
                 (part (find-part column cell pos)))
            (double-click column cell pos))))))
  
  
  (method override (context-menu self evt)
    (let ((view (get-position evt)))
      (let ((cell (view->tree self view)))
        (when cell
          (let ((row (get-row self (get-line cell))))
            (context-menu row (acquire row self view)))))))
  
  
  (method package (cell-coordinates self cell <Cell> pos <Point>) <Point>
    (- pos (cell-position self cell)))


  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method override (mouse-data self pos)
    (let ((cell (view->tree self pos)))
      (and cell
           (get-cell-title self cell))))


  ;;;
  ;;;; Keyboard
  ;;;


  (method override (key-press self evt)
    (let ((key (get-key evt)))
      (when (and (use-locator? self) (alphanumeric? key) (> visible-count 0))
        (enter locator key))))


  ;;;
  ;;;; Locator
  ;;;
  
  
  (method protected virtual (use-locator? self)
    #t)
  
  
  (method public (locate-prefix self prefix)
    (locate locator prefix))
  

  ;;;
  ;;;; Sort
  ;;;

  
  (method public virtual (header-click self column)
    (let* ((current-direction (column-sorting self column))
           (new-direction (case current-direction
                            ((ascending) 'descending)
                            ((descending) 'ascending)
                            (else 'ascending))))
      (unless (eq? current-direction new-direction)
        (set-sorted-column self column new-direction)
        (sort-rows self column new-direction)))
    (ensure-displayed self))
    
  
  (method protected (set-sorted-column self column direction)
    (if (not column)
        (set! sorted-columns '())
      (set! sorted-columns (list (cons column direction))))
    (invalidate-header self))

  
  (method public (column-sorting self column)
    (let ((pair (assq column sorted-columns)))
      (and pair
           (cdr pair))))
  
  
  (method protected (sort-rows self column direction)
    (define (call-sort rows equal predicate)
      (let ((col (column->col self column)))
        (let ((dual? (/= col 0)))
          (define (get-node row children n)
            (let ((data (element children n)))
              (or (sort-value (get-column self n) row data) "")))
          
          (sort (lambda (rx ry)
                  (let* ((cx (get-children rx))
                         (cy (get-children ry))
                         (nx (localize (get-node rx cx col)))
                         (ny (localize (get-node ry cy col))))
                    (or (predicate nx ny)
                        (and dual?
                             (equal nx ny)
                             (predicate (localize (get-node rx cx 0)) (localize (get-node ry cy 0)))))))
                rows))))
    
    (receive (equal smaller greater) (sort-predicates)
      (let ((predicate (case (column-sorting self column)
                         ((ascending) smaller)
                         ((descending) greater))))
        (define (iter row)
          (let ((sorted (call-sort (get-sons row) equal predicate)))
            (reorder-sons row sorted)
            (iterate (get-sons row) iter)))
        
        (with-preserved-selection self
          (lambda ()
            (with-update-locked self
              (lambda ()
                (iter root-row))))
          ensure-displayed?: #f))))
  
  
  ;;;
  ;;;; Selector
  ;;;
  

  (method public (selector-click self row)
    (acquire-focus self)
    (case selection-mode
      ((cell)
       (let ((col (if selection-pivot (get-col selection-pivot) 0)))
         (let ((select-list
                 (loop (for n from 0 below (get-columns-count self))
                       (collect (new Cell (row->line self row) n)))))
           (set-selection self select-list))))
      (else
       (set-selection self (list (row->line self row))))))
  
  
  (method public (selector-multi-select self row initial-line)
    (let ((new-line (row->line self row)))
      (let ((from-line (min initial-line new-line))
            (to-line (max initial-line new-line)))
        (case selection-mode
          ((cell)
           (let ((select-list (new-queue)))
             (loop (for line from from-line to to-line)
                   (loop (for col from 0 below (get-columns-count self))
                         (enqueue select-list (new Cell line col))))
             (set-selection self (queue-list select-list))))
          (else
           (let ((select-list
                   (loop (for line from from-line to to-line)
                         (collect line))))
             (set-selection self select-list)))))))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method override (get-content self)
    content)
  
  
  (method override (set-content self value)
    (loop (for row in value)
          (for i from 0)
          (loop (for info in row)
                (for j from 0)
                (do (let* ((cell (new Cell i j))
                           (data (get-cell-data self cell)))
                      (set-title data info)
                      (invalidate-cell self cell))))))


  ;;;
  ;;;; Context
  ;;;

  
  (method override (with-context-click self pos proc)
    (acquire-focus self)
    (let ((cell (view->tree self pos)))
      (if (not cell)
          (when can-select-empty?
            (set-selection self '()))
        (let ((row (get-row self (get-line cell))))
          (case selection-mode
            ((cell)
             (unless (member? cell (get-selection self) test: cell=?)
               (set-selection self (list cell))))
            (else
             (unless (memq? (get-line cell) (get-selection self))
               (set-selection self (list (get-line cell)))))))
        (update-view self))
      (proc)))

  
  ;;;
  ;;;; Flatten
  ;;;
  
  
  (method public (flattened? self)
    (let ((path-column (get-path-column self)))
      (and path-column (get-visible? path-column))))
  
  
  (method public (flatten/unflatten self)
    (let* ((path-column (get-path-column self))
           (flattened? (flattened? self)))
      (if (not path-column)
          (error "Unable to find path column")
        (set-visible? path-column (not flattened?))
        (fill-column self)
        (with-preserved-selection self
          (lambda ()
            (with-update-locked self
              (lambda ()
                (if flattened?
                    (unflatten self)
                  (flatten self)))))))))
  
  
  (method public (get-path-column self)
    (find-if (lambda (column)
               (is? column Tree-Path-Column))
             columns))
  
  
  (method public virtual (flatten-row? self row)
    #t)
  
  
  (method public (flatten self)
    (let ((sons (get-sons root-row)))
      (iterate sons
               (lambda (son)
                 (if (flatten-row? self son)
                     (disconnect son)
                   (flatten son root-row))))
      (iterate sons
               (lambda (son)
                 (unless (disconnected? son)
                   (set-visible? son #f))))))
  
  
  (method public (unflatten self)
    (iterate (get-sons root-row)
             (lambda (son)
               (when (disconnected? son)
                 (reconnect son))))
    (iterate (get-sons root-row)
             (lambda (son)
               (unless (get-visible? son)
                 (set-visible? son #t)))))
  
  
  ;;;
  ;;;; Filter
  ;;;
  
  
  (method public (filter-rows self cell-title-filter (row-filter: row-filter #f))
    (define (determine-visible? row)
      (and (or (not row-filter) (row-filter row))
           (or (not cell-title-filter)
               (some? (lambda (cell)
                        (let ((title (get-title cell)))
                          (and title
                               (cell-title-filter title))))
                      (get-children row)))))
  
    (define (make-row-visible row visible?)
      (set-visible? row visible?)
      (when visible?
        (let loop ((node (get-father row)))
             (when node
               (set-visible? node #t)
               (loop (get-father node))))))
    
    (scroll-to self {Point 0 0})                   ; quicky
    (set-selection self '() generate-event?: #f)   ; quicky
    (with-update-locked self
      (lambda ()
        (for-each-row self
          (lambda (row rank)
            (make-row-visible row (determine-visible? row)))))))
    
  
  (method public (unfilter-rows self)
    (filter-rows self #f))


  ;;;
  ;;;; Tooltip
  ;;;


  (method override (get-tooltip? self)
    #t)
  
  
  (method (calculate-tooltip-bounds self cell)
    (cell-rect self cell))
  
  
  (method override (get-tooltip-bounds self pos)
    (let ((cell (view->tree self pos)))
      (and cell
           (calculate-tooltip-bounds self cell))))
  
  
  (method override (get-tooltip-context self pos)
    (if (get-tooltip-text self)
        (nextmethod self pos)
      (let ((cell (view->tree self pos)))
        (and cell
             (let ((row (get-row self (get-line cell)))
                   (column (get-column self (get-col cell)))
                   (text (localize (get-cell-tooltip self cell))))
               (and text
                    (let* ((width (get-width column))
                           (height (get-height row))
                           (content-rect (content-rect column row cell width height))
                           (formatted? (get-formatted-tooltip? self))
                           (text-width (if formatted? 0 (+ (text-width (effective-font self) text) 2))))
                      (and (or (cell-tooltips? self cell) (and exceeds-tooltips? (> text-width (rect-width content-rect))))
                           (let ((rect (calculate-tooltip-bounds self cell))
                                 (h (+ (content-h column (get-level row)) (if (= (get-col cell) 0) 2 -2))))
                             (new Tooltip-Context
                               view: self
                               text: (if formatted? text (split-lines text))
                               bounds: rect
                               position: (get-tooltip-position self text rect h 0)
                               padding: (new Dimension 0 0)
                               font: (effective-font self)))))))))))
  
  
  (method protected virtual (cell-tooltips? self cell)
    #f)
  
  
  (method protected virtual (get-cell-tooltip self cell)
    (let ((column (get-column self (get-col cell)))
          (data (get-cell-data self cell)))
      (get-data-tooltip column data)))
  
  
  (method protected virtual (get-tooltip-position self text rect h v)
    (+ (rect-position rect) (new Point (- h 10) (+ v (rect-height rect) 5))))
  
  
  (method package virtual (get-column-tooltip self column)
    #f)


  ;;;
  ;;;; Dnd
  ;;;
  
  
  (method override (get-drag-drop self)
    (and (view->tree self (get-mouse-down-point))
         (nextmethod self)))


  ;;;
  ;;;; Drag
  ;;;
  
  
  (method override (get-drag-source self)
    (let* ((pos (get-drag-position self))
           (cell (view->tree self pos))
           (row (get-row self (get-line cell)))
           (col (get-col cell)))
      (get-drag-cell-source self pos row col)))
  
  
  (method protected virtual (get-drag-cell-source self pos row col)
    (new Tree-Drag-Source view: self position: pos @old image: @old (get-drag-image pos) row: row col: col))
  
  
  (method override (get-drag-image self pos)
    (let* ((cell (view->tree self pos))
           (line (get-line cell)))
      (get-node-image self line)))

  
  (method public (get-node-image self line)
    @old
    (let* ((cdc (new Client-Surface player))
           (font (effective-font))
           (row (get-row line))
           (data (get-cell-data (new Cell line 0)))
           (image (get-image data))
           (title (get-title data))
           (width (get-width node-column))
           (height (get-height row))
           (bitmap (unspecified))
           (mask (unspecified)))
      (with ((memdc (new Memory-Surface cdc (new Dimension width height) keep-bitmap?: #t))
             (maskdc (new Memory-Surface cdc (new Dimension width height) keep-bitmap?: #t)))
        (fill-rect memdc (new Rect 0 0 width height) {Color Tree-Background})
        (fill-rect maskdc (new Rect 0 0 width height) {Color Tree-Background})
        (draw-image portfolio memdc #f image 0 0)
        (draw-mask portfolio maskdc image 0 0)
        (set-font memdc font)
        (draw-text memdc 19 2 title {Color Black})
        (set-font maskdc font)
        (draw-text maskdc 19 2 title {Color Black})
        (set! bitmap (get-bitmap memdc))
        (set! mask (get-bitmap maskdc)))
      (let* ((portfolio (new Portfolio))
             (no (add-masked-bitmap portfolio bitmap mask)))
        (new Image portfolio: portfolio resource: no))))
    

  ;;;
  ;;;; Drop
  ;;;
  
  
  (method override (current-drop self drag-drop pos)
    (define (get-reorder-target drag-drop pos)
      (call-with-view->tree self pos
        (lambda (cell v height)
          (and cell
               (let* ((line (get-line cell))
                      (quarter (get-row-quarter v height))
                      (current (get-target drag-drop))
                      (row (get-row self line)))
                 (if (and current (eq? self (get-view current)) (eq? row (get-row current)) (eqv? quarter (get-quarter current)))
                     current
                   (get-row-reorder-target self drag-drop row quarter)))))))
    
    (define (get-row-quarter v height)
      (let ((quarter (/ (cast <fl> height) 4))
            (middle (/ (cast <fl> height) 2)))
        (cond ((< v quarter) 1)
              ((< v middle) 2)
              ((< v (- height quarter)) 3)
              (else 4))))
    
    (if (get-surrogate self)
        (nextmethod self drag-drop pos)
      (if (and reorderable? (eq? self (get-view (get-source drag-drop))))
          (get-reorder-target drag-drop pos)
        (get-tree-target self drag-drop pos))))
  
  
  (method protected virtual (get-row-reorder-target self drag-drop row quarter)
    (let* ((same-row? (memq? (row->line self row) selection))
           (src-selection (get-selection (get-view (get-source drag-drop))))
           (src-range (contiguous-range src-selection))
           (dst (get-user-data row))
           (dst-line (row->line self row))
           (current-rank (if (memq? quarter '(1 2)) dst-line (+ dst-line 1)))
           (accept? (or (not src-range) (and (not (memq? current-rank src-selection)) (/= current-rank (+ (cdr src-range) 1))))))
      (and accept?
           (let ((part (if (= current-rank dst-line) 'before 'after)))
             (new Tree-Drop-Target view: self row: row part: part)))))
  
  
  (method protected virtual (get-tree-target self drag-drop pos)
    (call-with-view->tree self pos
      (lambda (cell v height)
        (and cell
             (let ((row (get-row self (get-line cell)))
                   (current (get-target drag-drop)))
               (if (and current (eq? self (get-view current)) (eq? row (get-row current)))
                   current
                 (get-row-target self drag-drop row)))))))
  
    
  (method public (get-tree-data-target self drag-drop pos)
    (call-with-view->tree self pos
      (lambda (cell v height)
        (and cell
             (let ((row (get-row self (get-line cell)))
                   (col (get-col cell))
                   (source (get-source drag-drop))
                   (current (get-target drag-drop)))
               (and (or (neq? (get-view source) self) (neq? (get-row source) row) (/= (get-col source) col))
                    (if (and current (eq? self (get-view current)) (eq? row (get-row current)) (= col (get-col current)))
                        current
                      (get-cell-target self drag-drop row col))))))))
  
  
  (method protected virtual (get-row-target self drag-drop row)
    #f)
  
  
  (method protected virtual (get-cell-target self drag-drop row col)
    #f)
    
  
  (method override (highlight-drop self drag-drop pos)
    (let ((target (get-target drag-drop)))
      ;; temp patch... this should always be a t-d-t
      (when (is? target Tree-Drop-Target)
        (let* ((row (get-row target))
               (col (get-col target))
               (part (get-part target))
               (insert
                (case part
                  ((row) #f)
                  ((before) 'before)
                  ((after) 'after)))
               (highlight (new Tree-Highlight row col insert: insert outer-color: Highlighted-Outer-Color inner-color: Highlighted-Inner-Color)))
          (set-highlighted self (cons highlight (get-highlighted self)))))))
  
  
  (method override (unhighlight-drop self drag-drop)
    (set-highlighted self (if (null? highlighted)
                         '()
                       (cdr highlighted))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method override (tab-stop-enter self)
    )

  
  ;;;
  ;;;; Edition
  ;;;
    
  
  (method (on-move self evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (let ((direction (get-property evt direction:))
            (modifiers (get-modifiers evt)))
        (case direction
          ((up) (up-arrow-action self modifiers #t))
          ((down) (down-arrow-action self modifiers #t))
          ((left) (left-arrow-action self modifiers #t))
          ((right) (right-arrow-action self modifiers #t))))))


  (method virtual package (on-home self evt)
    (home-action self))
  
  
  (method public (home-action self)
    (let ((count (get-visible-count self)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot (get-col selection-pivot) 0)))
             (set-selection self (list (new Cell 0 col)))))
          (else
           (set-selection self (list 0)))))))


  (method virtual package (on-end self evt)
    (end-action self))
  
  
  (method public (end-action self)
    (let ((count (get-visible-count self)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot (get-col selection-pivot) 0)))
             (set-selection self (list (new Cell (- count 1) col)))))
          (else
           (set-selection self (list (- count 1))))))))


  (method override (left-arrow-press self modifiers)
    (left-arrow-action self modifiers #t))
  
  
  (method public (left-arrow-action self modifiers user-origin)
    (define (logical-col cell)
      (let ((site (cell->site self cell)))
        (and site
             (let ((merge-cell (get-merge-cell self site)))
               (if merge-cell
                   (get-first-col merge-cell)
                 (get-col cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((col (logical-col cell)))
             (when (> col 0)
               (move-cell self (new Cell (get-line cell) (- col 1)) 'left user-origin))))))
      ((row)
       (let ((row (get-selected-row self)))
         (if (not row)
             (bell)
           (if (expanded? row)
               (expand/collapse self row)
             (when (> (get-level row) 0)
               (set-selection self (list (row->line self (get-father row)))))))))))


  (method override (up-arrow-press self modifiers)
    (up-arrow-action self modifiers #t))
  
  
  (method public (up-arrow-action self modifiers user-origin)
    (define (logical-row cell)
      (let ((site (cell->site self cell)))
        (and site
             (let ((merge-cell (get-merge-cell self site)))
               (if merge-cell
                   (get-first-line merge-cell)
                 (get-line cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((line (logical-row cell)))
             (when (> line 0)
               (move-cell self (new Cell (- line 1) (get-col cell)) 'up user-origin))))))
      (else
       (let ((count (get-visible-count self)))
         (if (null? selection)
             (when (> count 0)
               (move-selection self (- count 1) 'backward user-origin))
           (let ((line (car selection)))
             (when (> line 0)
               (move-selection self (- line 1) 'backward user-origin))))))))


  (method override (right-arrow-press self modifiers)
    (right-arrow-action self modifiers #t))
  
  
  (method public (right-arrow-action self modifiers user-origin)
    (define (logical-col cell)
      (let ((site (cell->site self cell)))
        (and site
             (let ((merge-cell (get-merge-cell self site)))
               (if merge-cell
                   (get-last-col merge-cell)
                 (get-col cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((col (logical-col cell)))
             (when (< col (- (get-columns-count self) 1))
               (move-cell self (new Cell (get-line cell) (+ col 1)) 'right user-origin))))))
      (else
       (let ((row (get-selected-row self)))
         (if (not row)
             (bell)
           (unless (expanded? row)
             (expand/collapse self row)))))))


  (method override (down-arrow-press self modifiers)
    (down-arrow-action self modifiers #t))
  
  
  (method public (down-arrow-action self modifiers user-origin)
    (define (logical-row cell)
      (let ((site (cell->site self cell)))
        (and site
             (let ((merge-cell (get-merge-cell self site)))
               (if merge-cell
                   (get-last-line merge-cell)
                 (get-line cell))))))

    (let* ((count (get-visible-count self))
           (last (- count 1)))
      (case selection-mode
        ((cell)
         (when (not-null? selection)
           (let ((cell selection-pivot))
             (let ((line (logical-row cell)))
               (when (< line last)
                 (move-cell self (new Cell (+ line 1) (get-col cell)) 'down user-origin))))))
        (else
         (if (null? selection)
             (when (> count 0)
               (move-selection self 0 'forward user-origin))
           (let ((line (car selection)))
             (when (< line last)
               (move-selection self (+ line 1) 'forward user-origin))))))))
    
  
  (method package (move-selection self line direction user-origin)
    (let ((row (get-row self line)))
      (set-selection self (list line) user-origin: user-origin)
      (when user-origin
        (update-view self))))
  
  
  (method (move-cell self cell direction user-origin)
    (set-selection self (list cell) ensure-displayed?: #f user-origin: user-origin)
    (let ((rect (cell-rect self cell)))
      (case direction
        ((left)  (scroll self (new Point (horizontal-scroll-needed self (get-left rect) 'backward) 0)))
        ((up)    (scroll self (new Point 0 (vertical-scroll-needed self (get-top rect) 'backward))))
        ((right) (scroll self (new Point (horizontal-scroll-needed self (get-right rect) 'forward) 0)))
        ((down)  (scroll self (new Point 0 (vertical-scroll-needed self (get-bottom rect) 'forward))))))
    (when user-origin
      (update-view self)))
  
  
  (method (line-displayed? self line)
    (let* ((row (get-row self line))
           (top (get-top row))
           (bottom (get-bottom row))
           (needed (scroll-needed self (new Point 0 top) (new Point 0 bottom) #f)))
      (= (get-v needed) 0)))
  
  
  (method package (cell-displayed? self cell)
    (let* ((rect (cell-rect self cell))
           (needed (scroll-needed self (new Point (get-left rect) (get-top rect)) (new Point (get-right rect) (get-bottom rect)) #f)))
      (and (= (get-h needed) 0)
           (= (get-v needed) 0))))
  
  
  (method override (select-all self (user-origin: user-origin #f))
    (when multiple-selection?
      (set-selection self (naturals 0 visible-count) user-origin: user-origin)))

  
  ;;;
  ;;;; Columns
  ;;;
  
  
  (method public (for-each-column self proc)
    (for-each proc (get-columns self) (iota (get-columns-count self))))
  
  
  (method public (fill-column self)
    (define (find-filled-column name)
      (cond ((integer? name) (element columns name))
            ((eq? name #t) (and (not-null? columns) (last columns)))
            (else (find-if (lambda (column)
                             (eq? (get-name column) name))
                           columns))))
    
    (when (and filled-column (not-null? columns) (get-finished? self))
      (let ((column (find-filled-column filled-column)))
        (when column
          (let ((col (column->col self column)))
            (when (< col (length columns))
              (let* ((filled-borders (get-borders column))
                     (space-after (- columns-right (borders-right filled-borders)))
                     (size (get-display-size self))
                     (delta (max (- (borders-width filled-borders)) (- (get-width size) space-after (borders-right filled-borders))))
                     (old-right (cdr filled-borders))
                     (new-right (+ old-right delta)))
                (for-each (lambda (column)
                            (bind (left . right) (get-borders column)
                              (set-borders column (cons (+ left delta) (+ right delta)))))
                          (tail columns (+ col 1)))
                (set-cdr! filled-borders new-right)
                (increase! columns-right delta)
                (set-width column (max (+ (get-width column) delta) min-column-width))
                (let ((left (max (- (min old-right new-right) 2) 0))
                      (top 0)
                      (right (get-width size))
                      (bottom (get-height size)))
                  (when (and (< left right) (< top bottom))
                    (invalidate-rect self (new Rect left top right bottom))))
                (invalidate-header self))))))))

  
  (method public (add-column self . rest)
    (bind-keywords ((class Tree-Column) . others) rest
      (apply new class parent: self others)))
  
  
  (method public (remove-column self column)
    (remove-child self column))
  
  
  (method public (remove-columns self (preserve-node-column?: preserve-node-column? #f) (preserve: preserve '()))
    (define (remove-columns-preserving)
      (remove-every-row self)
      (for-each (lambda (column)
                  (unless (or (and preserve-node-column? (is? column Tree-Node-Column))
                              (memq? (get-name column) preserve))
                    (remove-column self column)))
                (get-columns self))
      (invalidate-header self))
    
    (define (remove-all-columns)
      (remove-every-row self)
      (set-children self '())
      (set! columns '())
      (set! columns-right 0)
      (set! node-column #f)
      (invalidate-header self))
    
    (if (or preserve-node-column? preserve)
        (remove-columns-preserving)
      (remove-all-columns)))

  
  (method override (invalidate-columns self)
    (define (update-node-column)
      (set! node-column (find-if (lambda (column)
                                   (is? column Tree-Node-Column))
                                 columns)))
    
    (define (update-columns)
      (let ((left 0)
            (last-right #f))
        (for-each (lambda (column rank)
                    (set-rank column rank)
                    (let* ((width (get-width column))
                           (right (+ left width)))
                      (set-borders column (cons left right))
                      (when (get-visible? column)
                        (set! left (+ right (if (space-column? self column rank) column-spacing 0))))
                      (set! last-right right)))
                  columns
                  (naturals 0 (length columns)))
        (set! columns-right last-right)))
    
    (when (not-null? columns)
      (update-node-column)
      (update-columns)))
  
  
  (method package virtual (space-column? self column rank)
    (= (modulo (+ rank 1) column-frequency) 0))
    
  
  (method public (get-columns-count self)
    (length columns))
    
  
  (method public (get-column self col)
    (element columns col))
  
  
  (method public (find-column self name)
    (find-component self name))
  
  
  (method public (get-node-column-index self)
    (column->col self node-column))
  
  
  (method public (column->col self column)
    (get-rank column))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method override (row-class self)
    Tree-Row)
  
  
  (method override (update-father-control self father)
    (when (and (not update-locked?) (neq? father root-row) (row-visible? father))
      (let* ((line (row->line self father))
             (top (row-top self line)))
        (when (< top (get-height self))
          (invalidate-rect self (control-rect node-column father top))
          (invalidate-rect self (image-rect node-column father top))))))
  
  
  (method override (add-empty-row self (father: father #f))
    (let ((father (or father root-row)))
      (add-row self father: father children: (map (lambda (column)
                                               (new-empty-cell column))
                                             columns))))
  
  
  (method override (line-selected? self line)
    (case selection-mode
      ((cell) (some? (lambda (cell) (= (get-line cell) line)) selection))
      (else (memq? line selection))))
  
  
  (method override (line-draw-selected? self line)
    (and (nextmethod self line)
         (or (has-focus? self) show-unfocused-selection?)))

  
  ;;;
  ;;;; Merge
  ;;;
  
  
  (method public (merge-cells self cell nbline nbcol)
    (if (and (> nbline 0) (> nbcol 0))
        (let ((cell-data (get-cell-data self cell)))
          (if cell-data
              (let ((title (get-cell-title self cell))
                    (site (cell->site self cell)))
                (when site
                  (when (get-merge-cell self site)
                    (unmerge-cells self cell)))
                (when (or (> nbline 1) (> nbcol 1))
                  (let ((cell-line (get-line cell))
                        (cell-col (get-col cell)))
                    (if (and (< (+ cell-line nbline -1) (get-row-count self))
                             (< (+ cell-col nbcol -1) (get-columns-count self)))
                        (let ((merged-rows (let ((queue (new-queue)))
                                             (loop (for r from cell-line below (+ cell-line nbline))
                                                   (enqueue queue (get-row self r)))
                                             (queue-list queue)))
                              (merged-columns (let ((queue (new-queue)))
                                                (loop (for c from cell-col below (+ cell-col nbcol))
                                                      (enqueue queue (get-column self c)))
                                                (queue-list queue))))
                          (merge-sites self merged-rows merged-columns))
                      (error "Merge cell out of tree bounds")))))
            (error "First cell is empty")))
      (error "Invalid merge-cells")))
  
  
  (method protected (merge-sites self rows columns (inhibit-invalidate?: inhibit-invalidate? #f))
    (let ((merge-cell (new Merge-Cell rows columns self)))
      (for-each (lambda (column)
                  (for-each (lambda (row)
                              (set-merge-cell! self (new Site row column) merge-cell))
                            rows))
                columns)
      (unless inhibit-invalidate?
        (let ((rect (merge-cell-rect self merge-cell)))
          (when rect
            (let ((site-data (get-site-data self (new Site (first rows) (first columns)))))
              (when (is? site-data View)
                (set-rect site-data (acquire (get-parent site-data) self rect))))
            (invalidate-rect self rect))))))
  
  
  (method public (unmerge-cells self cell)
    (let ((merge-cell-to-remove (get-merge-cell self (cell->site self cell))))
      (when merge-cell-to-remove
        (let ((rect (merge-cell-rect self merge-cell-to-remove)))
          (for-each-cell merge-cell-to-remove
            (lambda (row column)
              (let ((site (row/column->site self row column)))
                (clear-merge-cell self site))))
          (when rect
            (invalidate-rect self rect))))))
  
  
  (method public (add-merged-row self row merge-cell)
    (let ((merged-title (get-cell-title self (get-master-cell merge-cell)))
          (is-valid? #t)
          (site-list '()))
      (for-each (lambda (column)
                  (let ((new-title (get-data-title self (get-child row (column->col self column)))))
                    (if (equal? merged-title new-title)
                        (let ((site (new Site row column)))
                          (set-merge-cell! self site merge-cell)
                          (set! site-list (cons site site-list)))
                      (set! is-valid? #f))))
                (get-merged-columns merge-cell))
      (if is-valid?
          (add-merged-row merge-cell row)
        (for-each (~ clear-merge-cell self) site-list))
      @creates-problems-with-edited-cells
      (when (not is-valid?)
        (error "Merged cells title must be identical"))))

  
  (method public (get-merge-cell self site)
    (table-ref merge-cell-table site #f))
  
  
  (method public (safe-get-merge-cell self site)
    (case selection-mode
      ((cell) (get-merge-cell self site))
      (else #f)))
  
  
  (method public (set-merge-cell! self site merge-cell)
    (table-set! merge-cell-table site merge-cell))
  
  
  (method public (clear-merge-cell self site)
    (table-clear merge-cell-table site))
  
  
  (method package (merge-cell-selected? self merge-cell)
    (and (or (has-focus? self) show-unfocused-selection?)
         (case selection-mode
           ((cell)
            (some? (lambda (cell)
                     (let ((site (cell->site self cell)))
                       (and site
                            (eq? merge-cell (get-merge-cell self site)))))
                   (get-selection self)))
           (else
            #f))))
    

  (method (merge-corner-site self merge-cell)
    (values (get-first-site merge-cell) (get-last-site merge-cell)))
    

  (method (merge-corner-cell self merge-cell)
    (values (get-first-cell merge-cell) (get-last-cell merge-cell)))
  
  
  (method public (merge-cell-rect self merge-cell)
    (receive (top-left bottom-right) (merge-corner-site self merge-cell)
      (if (and top-left bottom-right)
          (let ((top-left-rect (unmerged-site-rect self top-left))
                (bottom-right-rect (unmerged-site-rect self bottom-right)))
            (new Rect (get-left top-left-rect) (get-top top-left-rect) (get-right bottom-right-rect) (get-bottom bottom-right-rect)))
        #f)))
  
  
  (method public (invalidate-merge-cell self merge-cell)
    (when (view-visible? self)
      (with-transformation-surface self
        (lambda (surface)
          (with ((region (new Region rect: (logical->device surface (merge-cell-rect self merge-cell)))))
            (invalidate-region player region))))))
  
  
  (method public (get-master-cell self cell)
    (let ((merge-cell (safe-get-merge-cell self (cell->site self cell))))
      (if merge-cell
          (get-master-cell merge-cell)
        cell)))
  
  
  (method public (get-master-site self site)
    (let ((merge-cell (safe-get-merge-cell self site)))
      (if merge-cell
          (cell->site self (get-master-cell merge-cell))
        site)))
  
  
  (method public (get-top-site self site)
    (let ((merge-cell (safe-get-merge-cell self site)))
      (if merge-cell
          (cell->site self (get-first-cell merge-cell))
        site)))
  

  ;;;
  ;;;; User
  ;;;
  
  
  (method public (row-index self target)
    (continuation-capture
      (lambda (return)
        (for-each-visible-row self
          (lambda (row line)
            (when (eq? row target)
              (continuation-return return line))))
        #f)))
  
  
  (method public (user-data-row self data (test: test eqv?) (include-invisibles?: include-invisibles? #f))
    (let ((rows (if include-invisibles? (collect-rows self) (collect-visible-rows self))))
      (find rows data key: get-user-data test: test return: 'item)))


  (method public (user-data-rows self data-list (test: test eqv?) (include-invisibles?: include-invisibles? #f))
    (let ((fact (new List-Factory)))
      ((if include-invisibles? (~ for-each-row self) (~ for-each-visible-row self))
       (lambda (row line)
         (let ((user-data (get-user-data row)))
           (when (member? user-data data-list test: test)
             (put fact row)))))
      (get-output fact)))


  ;; Because it returns the line, this method only makes sense on visible rows
  (method public (user-data-index self data (test: test eqv?))
    (continuation-capture
      (lambda (return)
        (for-each-visible-row self
          (lambda (row line)
            (when (test (get-user-data row) data)
              (continuation-return return line))))
        #f)))


  ;; Because it returns the line, this method only makes sense on visible rows
  (method public (user-data-indexes self data-list (test: test eqv?))
    (let ((fact (new List-Factory)))
      (for-each-visible-row self
        (lambda (row line)
          (let ((user-data (get-user-data row)))
            (when (member? user-data data-list test: test)
              (put fact line)))))
      (get-output fact)))
  
  
  (method public (select-user-data-row self data (test: test eqv?) (include-invisibles?: include-invisibles? #f) (error?: error? #t))
    (let ((row (user-data-row self data test: test include-invisibles?: include-invisibles?)))
      (if (not row)
          (and error? (error "Unable to select user-data: {t}" data))
        (set-single-selection self (row->line self row)))))

  
  ;;;
  ;;;; Cells
  ;;;
  
  
  (method public (cell-values self cell)
    (values (get-row self (get-line cell))
            (get-column self (get-col cell))))
  
  
  (method public (get-site-data self site)
    (let ((row (get-row site))
          (col (column->col self (get-column site))))
      (get-child row col)))
  
  
  (method public (get-cell-data self cell)
    (let ((row (get-row self (get-line cell))))
      (and row
           (begin
             (when (>= (get-col cell) (length (get-children row)))
               (set! selection '())
               (error "Sequence overrun"))
             (get-child row (get-col cell))))))
  
  
  (method public (set-cell-data self cell data)
    (let ((row (get-row self (get-line cell))))
      (set-element! (get-children row) (get-col cell) data)))
  
  
  (method public (get-data-title self data)
    (cond ((is? data Tree-Label)
           (get-title data))
          ((is? data Tree-Data-View)
           (get-title (get-preserved-data data)))))
  
  
  (method public (set-data-title self data title)
    (cond ((is? data Tree-Label)
           (set-title data title))
          ((is? data Tree-Data-View)
           (set-title (get-preserved-data data) title))))
  
  
  (method public (get-cell-title self cell)
    (let ((data (get-cell-data self cell)))
      (and data
           (get-data-title self data))))
  
  
  (method public (set-cell-title self cell title)
    (let ((data (get-cell-data self cell)))
      (when data
        (set-data-title self data title))))

  
  (method public (invalidate-site self site)
    (invalidate-rect self (site-rect self site)))
  
  
  (method public (invalidate-cell self cell)
    (invalidate-rect self (cell-rect self cell)))
  
  
  (method public (redraw-cell self cell)
    (invalidate-cell self cell)
    (update-view self))


  ;;;
  ;;;; State
  ;;;
  
  
  (method override (expand/collapse self row)
    (let ((top (get-v (get-position row))))
      (invalidate-rect self (control-rect node-column row top)))
    (case (get-state row)
      ((dynamic) (dynamic-expand self row))
      (else (nextmethod self row))))
  
  
  (method public (dynamic-expand self row)
    (update-row self row)
    (expand self row #t))
  
  
  (method override (invalidate-expand self row top dynamic?)
    (when node-column
      (invalidate-rect self (image-rect node-column row top))
      (if (and dynamic? (= (cardinality (get-sons row)) 0))
          (invalidate-rect self (control-rect node-column row top))
        (invalidate-rect self (plus/minus-rect node-column row top)))))
  
  
  (method override (invalidate-collapse self line row top selected?)
    (when node-column
      (invalidate-rect self (image-rect node-column row top))
      (if selected?
          (invalidate-rect self (line-rect self line))
        (invalidate-rect self (plus/minus-rect node-column row top)))))
  
  
  (method override (collapse-selection self line removed)
    (case selection-mode
      ((cell)
       (when removed
         (let ((cell (new Cell line (get-col removed))))
           (unless (member? cell selection)
             (set-selection self (cons cell selection))))))
      (else
       (when (and removed (not (line-selected? self line)))
         (set-selection self (cons line selection)))))
    (unless selection-pivot
      (set! selection-pivot (and (not-null? selection) (car selection)))))
  
  
  (method public (auto-expand/collapse self row (close-auto-expanded?: close-auto-expanded? #t) (auto-toggle?: auto-toggle? #f))
    (define (auto-toggle row auto-toggle?)
      (if (expanded? row)
          (when auto-toggle?
            (when (collapsable? row)
              (collapse self row))
            (set! auto-expanded-row #f))
        (when (expandable? row)
          (expand/collapse self row))
        (set! auto-expanded-row row)))
    
    (let ((selected-rows (selection->rows self selection)))
      (cond ((mouse-down? selection-manager)
             (when (and close-auto-expanded? auto-expanded-row (neq? auto-expanded-row row))
               (close-auto-expanded self new-spine: (and row (get-spine row)) force?: #f)
               (set! delayed-autorow auto-expanded-row)
               (set! auto-expanded-row #f)))
            ((mouse-up? selection-manager)
             (when delayed-autorow
               (if row
                   (close-delayed-row self new-spine: (get-spine row))
                 (let ((row (if (expanded? delayed-autorow)
                                delayed-autorow
                              (get-father delayed-autorow))))
                   (when (collapsable? row)
                     (collapse self row)))
                 (set! delayed-autorow #f)))
             (when row
               (auto-toggle row auto-toggle?)))
            (else
             (when close-auto-expanded?
               (close-auto-expanded self new-spine: (and row (get-spine row))))
             (when row
               (auto-toggle row auto-toggle?))))
      (set! selection (rows->selection self selected-rows))))
  
  
  (method public (close-delayed-row self (new-spine: new-spine #f))
    (when delayed-autorow
      (let ((old-spine (get-spine delayed-autorow))
            (done? #f))
        (set! delayed-autorow #f)
        (for-each-reversed (lambda (row)
                             (unless done?
                               (if (and new-spine (memq? row new-spine))
                                   (set! done? #t)
                                 (when (collapsable? row)
                                   (collapse self row)))))
                           old-spine))))
  
  
  (method public (close-auto-expanded self (new-spine: new-spine #f) (force?: force? #t))
    (when auto-expanded-row
      (let ((old-spine (get-spine auto-expanded-row))
            (done? #f))
        (set! auto-expanded-row #f)
        (for-each-reversed (lambda (row)
                             (unless done?
                               (if (and new-spine (memq? row new-spine))
                                   (set! done? #t)
                                 (if force?
                                     (when (collapsable? row)
                                       (collapse self row))
                                   (set! auto-expanded-row row)
                                   (set! done? #t)))))
                           old-spine))))
  
  
  (method (close-auto-expanded-row self)
    (when auto-expanded-row
      (when (collapsable? auto-expanded-row)
        (collapse self auto-expanded-row))
      (set! auto-expanded-row #f)))
  
  
  (method public (set-dynamic self row)
    (when (neq? (get-state row) 'dynamic)
      (set-state row 'dynamic)
      (let* ((line (row->line self row))
             (top (row-top self line)))
        (invalidate-rect self (control-rect node-column row top)))))

  
  ;;;
  ;;;; Scroll
  ;;;


  (method override (ensure-displayed self . rest)
    (when (not-null? selection)
      (if (eq? selection-mode 'cell)
          (ensure-cell-displayed self (car selection))
        (ensure-row-displayed self (selection-row self (car selection))))))
  
  
  (method package (ensure-cell-displayed self cell)
    (let ((rect (cell-rect self cell)))
      ;; the second pos should take in the cell width and height
      (scroll self (scroll-needed self (rect-position rect) (rect-end-position rect) (get-scroll-context self)))))

  
  ;;;
  ;;;; Selection
  ;;;


  (method package (cell->site self cell)
    (if (is? cell Cell)
        (let ((column (get-column self (get-col cell)))
              (row (get-row self (get-line cell))))
          (new Site row column))
      cell))


  (method package (row/column->site self row column)
    (new Site row column))


  (method package (site->cell self site)
    (if (is? site Site)
        (let ((col (column->col self (get-column site)))
              (line (row->line self (get-row site))))
          (new Cell line col))
      site))


  (method (site->line/col self site)
    (let ((col (column->col self (get-column site)))
          (line (row->line self (get-row site))))
      (values line col)))

  
  (method (process-multi-selection-row self element shift? control? user-origin)
    (cond ((and shift? control?)
           (set! selection-pivot element)
           (unless (member? element selection)
             (set-selection self (list element) set-pivot?: #f user-origin: user-origin)))
          (shift?
            (let ((pivot (or selection-pivot 0)))
              (cond ((= element pivot) (set-selection self (list element) set-pivot?: #f user-origin: user-origin))
                    ((> element pivot) (set-selection self (naturals pivot (+ element 1)) set-pivot?: #f user-origin: user-origin))
                    ((< element pivot) (set-selection self (naturals element (+ pivot 1)) set-pivot?: #f user-origin: user-origin)))))
          (control?
            (if (member? element selection test: nu=?)
                (set-selection self (remove element selection test: equal?) set-pivot?: #f user-origin: user-origin)
              (set-selection self (cons element selection) set-pivot?: #f user-origin: user-origin))
            (when (and selection-pivot (= element selection-pivot))
              (cond ((null? selection) (set! selection-pivot #f))
                    ((< selection-pivot (car selection)) (set! selection-pivot (car selection)))
                    ((> selection-pivot (last selection)) (set! selection-pivot (last selection))))))))
  

  (method (process-multi-selection-cell self element shift? control? user-origin)
    (cond ((and shift? control?)
           (set! selection-pivot element)
           (unless (member? element selection test: cell=?)
             (set-selection self (list element) set-pivot?: #f user-origin: user-origin)))
          (shift?
            (unless (or (and selection-pivot (/= (get-col element) (get-col selection-pivot)))
                        (not selection-pivot))
              (let ((col (get-col selection-pivot))
                    (element (get-line element))
                    (pivot (get-line selection-pivot)))
                (define (make-cell line)
                  (new Cell line col))
                (cond ((= element pivot) (set-selection self (map make-cell (list element)) set-pivot?: #f user-origin: user-origin))
                      ((> element pivot) (set-selection self (map make-cell (naturals pivot (+ element 1))) set-pivot?: #f user-origin: user-origin))
                      ((< element pivot) (set-selection self (map make-cell (naturals element (+ pivot 1))) set-pivot?: #f user-origin: user-origin))))))
          (control?
            (if (member? element selection test: cell=?)
                (set-selection self (remove element selection test: cell=?) set-pivot?: #f user-origin: user-origin)
              (set-selection self (cons element selection) set-pivot?: #f user-origin: user-origin))
            (when selection-pivot
              (let ((element-col (get-col element))
                    (pivot-col (get-col selection-pivot)))
                (if (= element-col pivot-col)
                    (when (cell=? element selection-pivot)
                      (let ((pivot-line (get-line selection-pivot)))
                        (cond ((null? selection) (set! selection-pivot #f))
                              ((< pivot-line (get-line (car selection))) (set! selection-pivot (car selection)))
                              ((> pivot-line (get-line (last selection))) (set! selection-pivot (last selection))))))
                  (set! selection-pivot #f)))))))
  
  
  (method public (process-selection self cell shift? control? user-origin)
    (let ((element (case selection-mode ((cell) cell) (else (get-line cell)))))
      (if (and multiple-selection? (or shift? control?))
          ((case selection-mode
             ((cell) (~ process-multi-selection-cell self))
             ((row)  (~ process-multi-selection-row self))) element shift? control? user-origin)
        (when (and (not always-select?) (member? element selection test: (if (eq? selection-mode 'cell) cell=? equal?)) (allow-start-drag? selection-manager))
          (delay-selection selection-manager))
        (set! selection-pivot element)
        (set-selection self (list element) set-pivot?: #f user-origin: user-origin))))
  
  
  (method override (get-selection self)
    selection)
  
  
  (method public (get-ordered-selection self)
    (sort < selection))
  
  
  (method override (set-selection self sel
                                  (force?: force? #f)
                                  (set-pivot?: set-pivot? #t)
                                  (ensure-displayed?: ensure-displayed? #t)
                                  (auto-expand?: auto-expand? #t)
                                  (generate-event?: generate-event? #t)
                                  (user-origin: user-origin #f))
    (define (inval-selection selection)
      (when (not-null? selection)
        (for-each (lambda (cell)
                    (let ((merge-cell (and (is? cell Cell) (get-merge-cell self (cell->site self cell)))))
                      (if merge-cell
                          (invalidate-merge-cell self merge-cell)
                        (invalidate-selection self (list cell)))))
                  selection)))
    
    (unless (locked? selection-manager)
      (reset locator)
      (when (change-selection? selection-manager)
        (let ((old-selection selection))
          (set! selection sel)
          (when set-pivot?
            (set! selection-pivot (if (null? selection) #f (car selection))))
          (inval-selection old-selection)
          (inval-selection selection)
          (when generate-event?
            (selection-change self old-selection force? user-origin))))
      (when (and auto-expand/collapse? auto-expand? (eq? user-origin 'mouse))
        (unless multiple-selection?
          (let ((auto-row (and (not-null? sel) (get-row self (selection-row self (car sel))))))
            (when (or (not auto-row) (collapsed? auto-row))
              (auto-expand/collapse self auto-row auto-toggle?: #t)))))
      (let ((selection-cell (selection-cell self)))
        (when selection-cell
          (let ((data (get-cell-data self selection-cell)))
            (when (is? data View)
              (let ((outline-view (get-outline-view data)))
                (when (and (eq? outline-view self)
                           (is-focused? self))
                  (acquire-focus data)))))))
      (when (and ensure-displayed? (end-delayed? selection-manager))
        (ensure-displayed self))))
  
  
  (method package virtual (selection-change self old-selection force? user-origin)
    (with-locked-operation selection-manager
      (lambda ()
        (call-selection-handler self old-selection selection force? user-origin))))
  
  
  (method public (get-selection-state self (use: use 'row))
    (define (save-selection selection)
      (case selection-mode
        ((cell) (map save-cell selection))
        (else (map save-row selection))))
    
    (define (save-cell cell)
      (cons (save-row (get-line cell)) (get-col cell)))
    
    (define (save-row line)
      (case use
        ((row) (get-row self line))
        ((rank) line)
        ((text) (line->text line))
        ((data) (get-user-data (get-row self line)))))
    
    (define (line->text line)
      (map (~ row-title self) (get-spine (get-row self line))))
    
    (let ((saved-selection (save-selection (get-selection self)))
          (saved-position (nu+ (get-scrolled-position self) (selection-position self (get-selection self))))
          (saved-pivot (and selection-pivot (save-selection (list selection-pivot))))
          (saved-edited (and edited-site (save-cell (site->cell self edited-site)))))
      (list use
            saved-selection
            saved-position
            saved-pivot
            saved-edited)))
  
  
  (method public (set-selection-state self state (test: test eqv?) (ensure-expanded?: ensure-expanded? #f) (ensure-displayed?: ensure-displayed? #t) (generate-event?: generate-event? #f))
    (bind (use saved-selection saved-position saved-pivot saved-edited) state
      (let ((row->line (if ensure-expanded?
                           (lambda (row)
                             (ensure-expanded self row)
                             (row->line self row))
                         (~ row->line self))))
        (define (restore-selection saved-selection)
          (remove-false
            (case selection-mode
              ((cell) (map restore-cell saved-selection))
              (else (map restore-row saved-selection)))))
        
        (define (restore-cell saved)
          (bind (row . col) saved
            (let ((line (restore-row row)))
              (and line
                   (new Cell line col)))))
        
        (define (restore-row saved)
          (case use
            ((row) (row->line saved))
            ((rank) saved)
            ((text) (text->line saved))
            ((data) (user-data-index self saved test: test))))
        
        (define (text->line text)
          (let (iter (row root-row) (text text))
            (if (null? text)
                (row->line row)
              (let ((subrow (find-by-title row (car text))))
                (and subrow
                     (iter subrow (cdr text)))))))
        
        (when saved-pivot
          (let ((pivot (restore-selection saved-pivot)))
            (set! selection-pivot (cond ((not-null? pivot) (car pivot))
                                        ((null? selection) #f)
                                        (else (car selection))))))
        (when saved-edited
          (let ((edited (restore-cell saved-edited)))
            (if (not edited)
                (kill-edition self)
              (set! edited-site (cell->site self (get-master-cell self edited)))
              (replace-site self edited-site cell-editor)
              (let* ((rect (site-rect self edited-site))
                     (size (new Dimension (- (get-right rect) (get-left rect)) (- (get-bottom rect) (get-top rect)))))
                (set-size cell-editor size)))))
        (let ((selection (restore-selection saved-selection)))
          (scroll-to self (nu- saved-position (selection-position self selection)))
          (set-selection self selection ensure-displayed?: ensure-displayed? generate-event?: generate-event? auto-expand?: #f)))))
  
  
  (method (selection-position self selection)
    (with ((region (selection-region self selection identity no-clipping?: #t)))
      (rect-position (get-box region))))
  
  
  (method public (with-preserved-selection self thunk (use: use 'row) (test: test eqv?) (ensure-expanded?: ensure-expanded? #f) (ensure-displayed?: ensure-displayed? #t) (generate-event?: generate-event? #f))
    (let ((saved-state (get-selection-state self use: use)))
      (thunk)
      (set-selection-state self saved-state test: test ensure-expanded?: ensure-expanded? ensure-displayed?: ensure-displayed? generate-event?: generate-event?)))
  
  
  (method public (get-single-selection self)
    (if (null? selection)
        #f
      (car selection)))
  
  
  (method public (set-single-selection self sel . rest)
    (assert (or (integer? sel) (is? sel Cell)))
    (apply set-selection self (list sel) rest))
  
  
  (method public (select-first-row self)
    (when (and (null? selection) (> (get-visible-count self) 0))
      (set-selection self (list 0))))
  
  
  (method public (select-first-data self)
    (define (find-data)
      (continuation-capture
        (lambda (return)
          (for-each-visible-row self
            (lambda (row line)
              (when (get-user-data row)
                (continuation-return return line))))
          #f)))
    
    (let ((line (find-data)))
      (when line
        (set-selection self (list line)))))
  
  
  (method (selected-row-proc self)
    (case selection-mode
      ((cell)
       (lambda (cell)
         (get-row self (get-line cell))))
      (else
       (~ get-row self))))
  
  
  (method public (get-selected-row self)
    (let ((selection (get-single-selection self)))
      (and selection
           ((selected-row-proc self) selection))))
  
  
  (method public (get-selected-rows self)
    (map (selected-row-proc self) (sort < selection)))
  
  
  (method public (get-selected-data self)
    (map get-user-data (get-selected-rows self)))
  
  
  (method public (get-single-selected-data self)
    (let ((row (get-selected-row self)))
      (and row
           (get-user-data row))))
  
  
  (method public (get-selection-data self selection)
    (map (lambda (line)
           (let ((row (get-row self line)))
             (get-user-data row)))
         selection))
  
  
  (method public (with-deleted-selection self selection proc (can-survive?: can-survive? #f))
    (let* ((selected-lines (if (eq? selection-mode 'cell) (map get-line selection) selection))
           (data (and can-survive? (get-selection-data self selected-lines)))
           (smallest (apply min selected-lines)))
      (proc)
      (let ((sel (and can-survive? (remove-false (map (~ user-data-index self) data)))))
        (if (and can-survive? (= (length selection) (length sel)))
            (set-selection self sel)
          (when (and smallest (> smallest 0))
            (let ((previous (- smallest 1)))
              (set-single-selection self (if (eq? selection-mode 'cell) (new Cell previous 0) previous))))))))
  
  
  (method (selection->rows self selection)
    (case selection-mode
      ((cell)
       (map (lambda (cell)
              (cons (get-visible-row self (get-line cell)) (get-col cell)))
            selection))
      (else
       (map (~ get-visible-row self) selection))))
  
  
  (method (rows->selection self rows)
    (case selection-mode
      ((cell)
       (remove-false (map (lambda (pair)
                            (bind (row . col) pair
                              (new Cell (row-index self row) col)))
                          rows)))
      (else
       (remove-false (map (~ row-index self) rows)))))
  
  
  ;; update slots that are line based
  (method override (added-update-selection self line count)
    (let ((proc (case selection-mode
                  ((cell) (lambda (cell)
                            (let ((l (get-line cell)))
                              (if (>= l line)
                                  (new Cell (+ l count) (get-col cell))
                                cell))))
                  (else (lambda (l)
                          (if (>= l line)
                              (+ l count)
                            l))))))
      (set! selection (map proc selection))
      (when selection-pivot
        (let ((new-pivot (proc selection-pivot)))
          (when new-pivot
            (set! selection-pivot new-pivot))))))
  
  
  ;; update slots that are line based
  (method override (removed-update-selection self line count)
    (let ((end-line (+ line count))
          (removed #f))
      (let ((proc (case selection-mode
                    ((cell) (lambda (cell)
                              (let ((l (get-line cell)))
                                (cond ((< l line)
                                       cell)
                                      ((>= l end-line)
                                       (new Cell (- l count) (get-col cell)))
                                      (else
                                       #f)))))
                    (else (lambda (l)
                            (cond ((< l line)
                                   l)
                                  ((>= l end-line)
                                   (- l count))
                                  (else
                                   #f)))))))
        (set! selection (collect (lambda (old)
                                   (let ((new (proc old)))
                                     (unless (or new removed)
                                       (set! removed old))
                                     new))
                                 selection))
        (when selection-pivot
          (let ((pivot (proc selection-pivot)))
            (set! selection-pivot (or pivot (and (not-null? selection) (car selection))))))
        removed)))

  
  (method override (selection-region self sel transformer (no-clipping?: no-clipping? #f))
    (define (element-region element)
      (case selection-mode
        ((cell) (new Region rect: (transformer (cell-rect self element))))
        (else (selection-row-region self element transformer))))
    
    (let ((region (new Region)))
      (loop (for element in sel)
            (let ((merge-cell (safe-get-merge-cell self (cell->site self element))))
              (if merge-cell
                  (with ((row-region (new Region rect: (transformer (merge-cell-rect self merge-cell)))))
                    (combine-or! region row-region))
                (with ((row-region (element-region element)))
                  (combine-or! region row-region)))))
      (unless no-clipping?
        (with ((clipper (new Region rect: (transformer (get-view-clipper self)))))
          (combine-and! region clipper)))
      region))
  
  
  (method override (selection-row-rect self line)
    (define (left-with-node row)
      (let* ((node-left (row-text-left node-column row))
             (columns-left (if (> (length columns) 1)
                               (borders-left (get-borders (second columns)))
                             node-left)))
        (min node-left columns-left)))
    
    (define (left-without-node)
      (borders-left (get-borders (first columns))))
    
    (let ((row (get-row self line)))
      (let ((left   (if node-column (left-with-node row) (left-without-node)))
            (top    (get-v (get-position row))))
        (new Rect (- left 3) top columns-right (+ top (get-height row))))))
  
  
  (method (selection-row self element)
    (case selection-mode
      ((cell) (get-line element))
      (else element)))
  
  
  (method (selection-cell self)
    (and (not multiple-selection?)
         (let ((selection (get-single-selection self)))
           (and selection
                (case selection-mode
                  ((cell) selection)
                  ((row) (and (= 1 (get-columns-count self))
                              (new Cell selection 0)))
                  ((node) (new Cell selection 0)))))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method override (get-view-state self (use: use 'row))
    (list (get-expand-state self) (get-selection-state self use: use)))
  
  
  (method override (set-view-state self state)
    (bind (expand-state selection-state) state
      (set-expand-state self expand-state)
      (set-selection-state self selection-state)))
  
  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (cell-visible? self cell)
    (and (< (get-line cell) visible-count)
         (< (get-col cell) (get-columns-count self))))


  ;;;
  ;;;; Borders
  ;;;
  
  
  (definition (borders-left borders)
    (car borders))
  
  
  (definition (borders-right borders)
    (cdr borders))
  
  
  (definition (borders-width borders)
    (- (borders-right borders) (borders-left borders)))
  

  ;;;
  ;;;; Coordinates
  ;;;
  
  
  ;; temp patch to be virtual...
  (method override (line-rect self line <fx>) <Rect>
    (let* ((row   (get-row self line))
           (left  (borders-left (get-borders (car columns))))
           (top   (get-v (get-position row)))
           (right columns-right))
      (new Rect left top right (+ top (get-height row)))))
  
  
  (method public (cell-position self cell <Cell>) <Point>
    (let ((rect (cell-rect self cell)))
      (new Point (get-left rect) (get-top rect))))
  
  
  (method public (site-rect self site <Site>) <Rect>
    (let ((merge-cell (safe-get-merge-cell self site)))
      (if merge-cell
          (merge-cell-rect self merge-cell)
        (unmerged-site-rect self site))))
  
  
  (method public (cell-rect self cell <Cell>) <Rect>
    (site-rect self (cell->site self cell)))

  
  (method public (unmerged-site-rect self site <Site>) <Rect>
    (let* ((borders (get-borders (get-column site)))
           (row (get-row site))
           (top (get-v (get-position row))))
      (new Rect (borders-left borders) top (borders-right borders) (+ top (get-height row)))))
  
  
  (method public (cell-region self cell <Cell>) <Region>
    (new Region rect: (cell-rect self cell)))
  
  
  (method (cell-content-rect self cell <Cell>) <Rect>
    (let* ((line    (get-line cell))
           (col     (get-col cell))
           (row     (get-row self line))
           (column  (get-column self col))
           (top     (get-v (get-position row)))
           (data    (get-cell-data self cell))
           (width   (get-width column))
           (borders (get-borders column))
           (left    (borders-left borders)))
      (offset-rect (content-rect column row data width (get-height row)) left top)))
    
  
  (method (cell-text-rect self cell <Cell>) <Rect>
    (let* ((line  (get-line cell))
           (col   (get-col cell))
           (row   (get-row self line))
           (top   (get-v (get-position row)))
           (data  (get-cell-data self cell))
           (width (get-width node-column)))
      (offset-rect (text-rect (get-column self col) row data width (get-height row) #f) 0 top)))
  
  
  (method public (view->tree self pos <Point> (any?: any? #f) (uniform-height?: uniform-height? #f))
    (define (visible-cell cell)
      (if any?
          cell
        (and (cell-visible? self cell)
             cell)))
    
    (let ((line (if uniform-height? (quotient (get-v pos) default-row-height) (v->line self (get-v pos))))
          (col (h->col self (get-h pos))))
      (and line col (>= line 0)
        (let ((cell (new Cell line col)))
          (let ((merge-cell (get-merge-cell self (cell->site self cell))))
            (visible-cell (if merge-cell (get-first-cell merge-cell) cell)))))))


  (method public (call-with-view->tree self pos <Point> proc)
    (call-with-v->line self (get-v pos)
      (lambda (line v height)
        (if line
            (let ((col (h->col self (get-h pos))))
              (if (and line col (>= line 0))
                  (let ((cell (new Cell line col)))
                    (if (cell-visible? self cell)
                        (proc cell v height)
                      (proc #f #f #f)))
                (proc #f #f #f)))
          (proc #f #f #f)))))
  

  (method public (h->col self h)
    (continuation-capture
      (lambda (return)
        (loop (for col from 0 below (get-columns-count self))
              (for column in columns)
              (bind (left . right) (get-borders column)
                (when (and (<= h right) (/= left right))
                  (continuation-return return col))))
        #f)))
  
  
  ;;;
  ;;;; Embedded Edition
  ;;;
  
  
  (method public (in-edition? self)
    edited-site)
  
  
  (method public (edit-cell self cell (editor: editor #f) (after-end: after-end #f))
    (assert (not update-locked?))
    (assert (< (get-col cell) (get-columns-count self)))
    (end-edition self)
    (let ((rect (cell-editor-rect self cell))
          (view (new Tree-Data-View
                  preserved-data: (get-cell-data self cell)
                  after-end: after-end
                  visible?: #f
                  children: (list editor)))
          (site (cell->site self cell)))
      (replace-site self (get-top-site self site) view)
      (set-rect view (acquire (get-parent view) self rect))
      (set! edited-site site)
      (set! cell-editor view)
      (set-visible? view #t)))
  
  
  (method public (end-edition self)
    (when edited-site
      (let ((site edited-site)
            (editor cell-editor))
        (set! edited-site #f)
        (set! cell-editor #f)
        (receive (line col) (site->line/col self site)
          (when (and line col)
            (let ((bounds (cell-editor-rect self (new Cell line col)))
                  (after-end (get-after-end editor)))
              (replace-site self (get-master-site self site) (get-preserved-data editor))
              (close editor)
              (when after-end
                (after-end site))
              (invalidate-rect self bounds)))))))
  
  
  (method public (kill-edition self)
    (when edited-site
      (let ((site edited-site)
            (editor cell-editor))
        (set! edited-site #f)
        (set! cell-editor #f)
        (replace-site self (get-master-site self site) (get-preserved-data editor))
        (close editor))))
  
  
  (method public (replace-site self site child)
    (replace-child (get-row site) (column->col self (get-column site)) child))
  
  
  (method public (replace-cell self cell child)
    (replace-child (get-row self (get-line cell)) (get-col cell) child))
  
  
  (method public (get-edited-cell self)
    (and edited-site (site->cell self edited-site)))
  
  
  (method (cell-editor-rect self cell)
    ;; quicky
    (let ((merge-cell (safe-get-merge-cell self (cell->site self cell))))
      (if merge-cell
          (merge-cell-rect self merge-cell)
        (let* ((line    (get-line cell))
               (col     (get-col cell))
               (row     (get-row self line))
               (column  (get-column self col))
               (top     (get-v (get-position row)))
               (cell    (get-cell-data self cell))
               (width   (if show-header? (get-width column) (get-width self)))
               (borders (get-borders column))
               (left    (borders-left borders))
               (h       (text-h column (get-level row)))
               (rect    (content-rect column row cell width (get-height row))))
          (offset-rect rect left top)))))
  
  
  (method public (cell-up self cell)
    (let ((merge-cell (safe-get-merge-cell self (cell->site self cell))))
      (let ((line (- (if merge-cell
                         (get-first-line merge-cell)
                       (get-line cell)) 1))
            (col (get-col cell)))
        (and (>= line 0)
             (new Cell line col)))))
  
  
  (method public (cell-down self cell (validate? #t))
    (let ((merge-cell (safe-get-merge-cell self (cell->site self cell))))
      (let ((line (+ (if merge-cell
                         (get-last-line merge-cell)
                       (get-line cell)) 1))
            (col (get-col cell)))
        (and (or (not validate?) (< line (get-visible-count self)))
             (new Cell line col)))))
  
  
  (method public (cell-left self cell)
    (let* ((merge-cell (safe-get-merge-cell self (cell->site self cell)))
           (col (- (or (and merge-cell (get-first-col merge-cell))
                       (get-col cell))
                   1))
           (cell (new Cell (get-line cell) col)))
      (cond ((< col 0) #f)
            ((get-visible? (get-column self col))
             cell)
            (else
             (cell-left self cell)))))
  
  
  (method public (cell-right self cell)
    (let* ((merge-cell (safe-get-merge-cell self (cell->site self cell)))
           (col (+ (or (and merge-cell (get-first-col merge-cell))
                       (get-col cell))
                   1))
           (cell (new Cell (get-line cell) col)))
      (cond ((>= col (get-columns-count self)) #f)
            ((get-visible? (get-column self col))
             cell)
            (else
             (cell-right self cell)))))
  
  
  (method public (select-up self cell)
    (let ((sel (cell-up self cell)))
      (when sel
        (end-edition self)
        (select-cell self sel))))
  
  
  (method public (select-down self cell (validate? #t))
    (let ((sel (cell-down self cell validate?)))
      (when sel
        (end-edition self)
        (select-cell self sel))))
    
  
  (method public (select-left self cell)
    (let ((sel (cell-left self cell)))
      (when sel
        (end-edition self)
        (select-cell self sel))))

  
  (method public (select-right self cell)
    (let ((sel (cell-right self cell)))
      (when sel
        (end-edition self)
        (select-cell self sel))))
  
  
  (method public virtual (select-cell self cell . rest)
    (set-single-selection self 
      (if (eq? selection-mode 'cell)
          cell
        (get-line cell))))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor self (context: context #f))
    (new jazz.tree.descriptors:Tree-View-Descriptor)))


;;;
;;;; Locator
;;;


(class Tree-Locator extends Locator
  
  
  (slot tree)
  (slot column initialize #f)
  
  
  (method override (initialize self tree . rest)
    (set! self.tree tree)
    (apply nextmethod self rest))
  
  
  (method override (iterate-entries self proc)
    (define (prepare-iterate)
      (let ((sel (get-single-selection tree)))
        (case (get-selection-mode tree)
          ((cell)
           (set! column (if sel (get-col sel) 0))
           (cons (and sel (get-row tree (get-line sel)))
                 (lambda (row) (element (get-children row) column))))
          (else
           (cons (and sel (get-row tree sel))
                 (lambda (row) (car (get-children row))))))))
    
    (bind (row . child-get) (prepare-iterate)
      (for-each-visible-row tree
        (lambda (row line)
          (let ((child (child-get row)))
            (let ((title (typecase child
                           ((Tree-Label) (get-title child))
                           (else (get-title child)))))
              (proc title line))))
        start: (and row (if prefix row (get-next row)))
        wrap?: #t)))
  
  
  (method override (select-entry self line)
    (case (get-selection-mode tree)
      ((cell) (set-single-selection tree (new Cell line column)))
      (else (set-single-selection tree line)))))


;;;
;;;; Merge-Cell
;;;


(class Merge-Cell extends Object
  
  
  (slot merged-rows    initialize '() accessors generate)
  (slot merged-columns initialize '() accessors generate)
  (slot tree           initialize #f  accessors generate)
  
  
  (method override (initialize self rows-list columns-list cells-tree)
    (nextmethod self)
    (set! merged-rows rows-list)
    (set! merged-columns columns-list)
    (set! tree cells-tree))
  
  
  (method public (get-master-cell self)
    (let ((master-row (first merged-rows))
          (master-column (first merged-columns)))
      (site->cell tree (new Site master-row master-column))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (let ((r (length merged-rows))
              (c (length merged-columns)))
          (format output "{a} row{a} {a} column{a}" r (format-plural r) c (format-plural c))))))
  
  
  (method public (add-merged-row self row)
    (set! merged-rows (cons row merged-rows)))
  
  
  (method public (for-each-cell self proc)
    (for-each (lambda (row)
                (for-each (lambda (column)
                            (proc row column))
                          merged-columns))
              merged-rows))
  
  
  (method public (get-first-row self)
    (first merged-rows))
  
  
  (method public (get-last-row self)
    (last merged-rows))
  
  
  (method public (get-first-column self)
    (first merged-columns))
  
  
  (method public (get-last-column self)
    (last merged-columns))
  
  
  (method public (get-first-site self)
    (new Site (get-first-row self) (get-first-column self)))
  
  
  (method public (get-last-site self)
    (new Site (get-last-row self) (get-last-column self)))
  
  
  (method public (get-first-line self)
    (let ((first-line #f))
      (for-each (lambda (row)
                  (when (get-visible? row)
                    (let ((line (row->line tree row)))
                      (when (or (not first-line)
                                (< line first-line))
                        (set! first-line line)))))
                merged-rows)
      first-line))
  
  
  (method public (get-last-line self)
    (let ((last-line 0))
      (for-each (lambda (row)
                  (when (get-visible? row)
                    (let ((line (row->line tree row)))
                      (when (> line last-line)
                        (set! last-line line)))))
                merged-rows)
      last-line))
  
  
  (method public (get-first-col self)
    (let ((first-col #f))
      (for-each (lambda (column)
                  (when (get-visible? column)
                    (let ((col (column->col tree column)))
                      (when (or (not first-col)
                                (< col first-col))
                        (set! first-col col)))))
                merged-columns)
      first-col))
  
  
  (method public (get-last-col self)
    (let ((last-col 0))
      (for-each (lambda (column)
                  (when (get-visible? column)
                    (let ((col (column->col tree column)))
                      (when (> col last-col)
                        (set! last-col col)))))
                merged-columns)
      last-col))


  (method public (get-first-cell self)
    (let ((first-line (get-first-line self))
          (first-col (get-first-col self)))
      (if (and first-line first-col)
          (new Cell first-line first-col)
        #f)))


  (method public (get-last-cell self)
    (let ((last-line (get-last-line self))
          (last-col (get-last-col self)))
      (new Cell last-line last-col)))))
