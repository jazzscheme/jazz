;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Command Text-View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.command.Command-Text-View jazz


(import (jazz.graphic)
        (jazz.ide)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.project)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window))


(class Command-Text-View extends IDE-Text-View
  
  
  (slot mode             initialize #f accessors generate)
  (slot client           initialize #f getter generate)
  (slot client-selection initialize #f getter generate)
  (slot client-position  initialize #f getter generate)
  (slot client-restore   initialize #f accessors generate)
  (slot previous-search  initialize #f accessors generate)
  
  
  (form
    (<install>
      focus-selects-all?: #t
      show-unfocused-selection?: #f
      accepts-returns?: #f
      left-padding: 2
      top-padding: 2
      tooltip?: #t
      tooltip-text: "Command Shell"))
  
  
  (method override (preferences)
    (get-preferences '(documents command-text)))
  
  
  (method override (propagate-styles?)
    #f)
  
  
  (method override (install rest)
    (nextmethod rest)
    (let ((pref (preferences)))
      (add-style 'Separator (get-separator-style~ pref))))
  
  
  (method override (finish rest)
    (nextmethod rest)
    (set! mode (new Execute-Mode self)))
  
  
  (method override (component-alias name)
    (case name
      ((:mode) mode)
      (else (nextmethod name))))
  
  
  ;;;
  ;;;; Client
  ;;;
  
  
  (method (setup-client)
    (set! client (get-focus))
    (set! client-selection #f))
  
  
  (method (setup-search-client)
    (define (determine-client)
      (let ((focus (get-focus)))
        (when (and (is? focus Text-View) (not (in-cell-edit? focus)))
          focus)))
    
    (set! client (determine-client))
    (set! client-selection (and client (get-selection~ client)))
    (set! client-position (and client (get-scrolled-position~ client))))
  
  
  (method (cleanup-client)
    (set! client #f)
    (set! client-selection #f))
  
  
  (method (restore-client)
    (when client-restore
      (client-restore)
      (set! client-restore #f)))
  
  
  (method (preserve-search)
    (let ((content (first-content)))
      (set! previous-search (if (empty-string? content) #f content))))
  
  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method override (focus-lose)
    (nextmethod)
    (cleanup~ mode #t)
    (cleanup-client)
    (set-mode-execute)
    (clear-user-message)
    (empty-text))
  
  
  (method override (focus-actions)
    (cons (mode-actions~ mode)
          (nextmethod)))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press key)
    (nextmethod key)
    (key-press~ mode key))
  
  
  (method override (backspace-press key (word?: word? #f))
    (nextmethod key word?: word?)
    (backspace-press~ mode key word?: word?))
  
  
  (method override (tab-press key modifiers)
    (navigate-field (shift-key? modifiers)))
  
  
  (method override (next-page evt)
    (next-page~ mode))
  
  
  (method override (prior-page evt)
    (prior-page~ mode))
  
  
  (method override (get-constituent-test)
    (or (get-constituent-test~ mode)
        (nextmethod)))
  
  
  (method override (auto-complete?)
    (auto-complete?~ mode))
  
  
  (method override (auto-complete-char? key last)
    (let ((value (auto-complete-char?~ mode key last)))
      (if (eq? value 'default)
          (nextmethod key last)
        value)))


  (method override (favorite-completions?)
    (let ((value (favorite-completions?~ mode)))
      (if (eq? value 'default)
          (nextmethod)
        value)))
  
  
  (method override (complete-name? size)
    (let ((value (complete-name?~ mode size)))
      (if (eq? value 'default)
          (nextmethod size)
        value)))


  (method override (completion-name pos)
    (or (completion-name~ mode pos)
        (nextmethod pos)))
    
  
  (method override (symbol-completions name)
    (or (symbol-completions~ mode name)
        (nextmethod name)))

  
  ;;;
  ;;;; Fields
  ;;;
  
  
  (method (navigate-field backward?)
    (let ((fields (collect-fields)))
      (let ((rank (caret-rank fields)))
        (let ((next (modulo ((if backward? - +) rank 1) (length fields))))
          (goto-field (element fields next))))))
  
  
  (method (first-field)
    (first (collect-fields)))
  
  
  (method (second-field)
    (let ((fields (collect-fields)))
      (when (>= (length fields) 2)
        (second fields))))
  
  
  (method (first-content)
    (field-content (first-field)))
  
  
  (method (second-content)
    (let ((field (second-field)))
      (when field
        (field-content field))))
  
  
  (method (field-content field)
    (substring (get-string~ (first-paragraph))
               (get-start~ field)
               (get-end~ field)))
  
  
  (method (goto-field field)
    (set-selection field))
  
  
  (method (goto-first-field)
    (goto-field (first-field)))
  
  
  (method (goto-second-field)
    (let ((field (second-field)))
      (if field
          (goto-field field)
        (set-caret (text-ending))
        (insert-separator))))
  
  
  (method (collect-fields)
    (let ((paragraph (first-paragraph))
          (fields (new-queue)))
      (define (forward-style pos predicate)
        (let ((card (get-length~ paragraph)))
          (let (iterate (pos pos))
            (if (>= pos card)
                pos
              (let ((next (+ pos 1)))
                (let ((run (get-run~ paragraph next)))
                  (if (or (not run) (predicate (get-style~ run)))
                      (iterate next)
                    pos)))))))
      
      (define (text-style? style)
        (not (separator-style? style)))
      
      (define (separator-style? style)
        (inherits?~ style 'Separator))
      
      (define (new-field start end)
        (new Range start end))
      
      (let (iter (pos 0))
        (let ((text-end (forward-style pos text-style?)))
          (enqueue fields (new-field pos text-end))
          (let ((separator-end (forward-style text-end separator-style?)))
            (when (/= separator-end text-end)
              (iter separator-end)))))
      (queue-list fields)))
  
  
  (method (field-rank fields pos)
    (let (iter (fields fields) (rank 0))
      (let ((field (car fields)))
        (if (between? pos (get-start~ field) (get-end~ field))
            rank
          (iter (cdr fields) (+ rank 1))))))
  
  
  (method (caret-rank fields)
    (let ((pos (get-col~ (get-caret))))
      (field-rank fields pos)))
  
  
  (method (insert-separator)
    (insert-styled "/" 'Separator))

  
  ;;;
  ;;;; Mode
  ;;;
  
  
  (method public (select-search direction range initial (highlight?: highlight? #f) (again?: again? #f) (beginning: beginning #f) (ending: ending #f))
    (set-mode-search (if highlight? Highlight-Mode Search-Mode) direction beginning ending)
    (setup-search-client)
    (push-focus self)
    (prepare-search~ mode range)
    (set-text (get-target~ initial))
    (select-all)
    (set-context~ mode initial)
    (search~ mode direction initial?: #t again?: again?))
  
  
  (method (set-mode-search class direction beginning ending)
    (set! mode (new class self direction beginning ending))
    (user-message "Search..."))
  
  
  (method public (select-extended)
    (set-mode-extended)
    (setup-client)
    (push-focus self))
  
  
  (method (set-mode-extended)
    (set! mode (new Extended-Mode self))
    (user-message "Extended..."))
  
  
  (method public (select-execute)
    (set-mode-execute)
    (setup-client)
    (push-focus self))
  
  
  (method (set-mode-execute)
    (set! mode (new Execute-Mode self))
    (user-message "Execute...")))


;;;
;;;; Command-Mode
;;;


(class Command-Mode extends Object
  
  
  (slot text)
  
  
  (method override (initialize text)
    (nextmethod)
    (set! text~self text))
  
  
  (method (get-client)
    (get-client~ text))
  
  
  (method (get-client-selection)
    (get-client-selection~ text))
  
  
  (method (get-client-position)
    (get-client-position~ text))
  
  
  (method virtual (mode-actions)
    )
    
  
  (method virtual (key-press key)
    )
  
  
  (method virtual (backspace-press key (word?: word? #f))
    )
  
  
  (method virtual (next-page)
    )
  
  
  (method virtual (prior-page)
    )
  
  
  (method virtual (get-constituent-test)
    #f)

  
  (method virtual (auto-complete?)
    #f)
  
  
  (method virtual (auto-complete-char? key last)
    'default)
  
  
  (method virtual (favorite-completions?)
    'default)
  
  
  (method virtual (complete-name? size)
    'default)


  (method virtual (completion-name pos)
    #f)
  
  
  (method virtual (symbol-completions name)
    #f)
  
  
  (method virtual (finish)
    (cleanup))
  
  
  (method virtual (cancel)
    (cleanup))
  
  
  (method virtual (cleanup (lose-focus? #f))
    (restore-client~ text)
    (let ((client (get-client)))
      (when client
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Search-Mode
;;;


(class Search-Mode extends Command-Mode
  
  
  (slot direction       initialize #f)
  (slot beginning       initialize #f)
  (slot ending          initialize #f)
  (slot context         initialize #f)
  (slot last-range      initialize #f)
  (slot prefixes        initialize (make-table test: equal?))
  (slot found-style     initialize #f)
  (slot highlight-style initialize #f)
  (slot replace-style   initialize #f)
  (slot boundary-style  initialize #f)
  
  
  (method override (initialize text direction beginning ending)
    (nextmethod text)
    (set! direction~self direction)
    (set! beginning~self beginning)
    (set! ending~self ending))
  
  
  (method (prepare-search range)
    (let ((client (get-client))
          (client-selection (get-client-selection)))
      (let ((text? (and client (is? client Text-View))))
        (set! last-range (if text? (or range client-selection) #f))
        (set! found-style (if text? (add-style~ client 'Found (new Text-Style base: 'Base domain: (get-styles-domain~ client) highlight: {Color Found})) #f))
        (set! highlight-style (if text? (add-style~ client 'Highlight (new Text-Style base: 'Base domain: (get-styles-domain~ client) highlight: {Color Highlight})) #f))
        (set! replace-style (if text? (add-style~ client 'Replace (new Text-Style base: 'Base domain: (get-styles-domain~ client) highlight: {Color Light-Red} frame: {Color Replace})) #f))
        (set! boundary-style (if text? (add-style~ client 'Boundary (new Text-Style base: 'Base domain: (get-styles-domain~ client) highlight: {Color Boundary})) #f)))))
  
  
  (method override (mode-actions)
    (find-actions 'search-mode))
  
  
  (method override (key-press key)
    (search direction))
  
  
  (method override (backspace-press key (word?: word? #f))
    (search direction prefix?: #t))
  
  
  (method override (next-page)
    (search 'forward again?: #t))
  
  
  (method override (prior-page)
    (search 'backward again?: #t))
  
  
  (method (set-context ctx)
    (set! context ctx))
  
  
  (method (select-whole-words? whole-words?)
    (set-whole-words?~ context whole-words?))
  
  
  (method (select-ignore-case? ignore-case?)
    (set-ignore-case?~ context ignore-case?))
  
  
  (method (select-regexp? regexp?)
    (set-regexp?~ context regexp?))
  
  
  (method (on-whole-words evt)
    (select-whole-words? (not (get-whole-words?~ context)))
    (user-message "Search whole-words {a}" (if (get-whole-words?~ context) "on" "off"))
    (rehighlight-target))
  
  
  (method (on-ignore-case evt)
    (select-ignore-case? (not (get-ignore-case?~ context)))
    (user-message "Search ignore-case {a}" (if (get-ignore-case?~ context) "on" "off"))
    (rehighlight-target))
  
  
  (method (on-regexp evt)
    (select-regexp? (not (get-regexp?~ context)))
    (user-message "Search regexp {a}" (if (get-regexp?~ context) "on" "off"))
    (rehighlight-target))
  
  
  (method (on-forward evt)
    (let ((again? (not (select-empty-search))))
      (search 'forward again?: again?)))
  
  
  (method (on-backward evt)
    (let ((again? (not (select-empty-search))))
      (search 'backward again?: again?)))
  
  
  (method (select-empty-search)
    (when (empty-string? (get-target~ context))
      (let ((previous (get-previous-search~ text)))
        (when previous
          (set-previous-search~ text #f)
          (set-string-content~ text previous)
          (set-caret~ text (text-ending~ text))
          #t))))
  
  
  (method (on-current evt)
    (cancel))
  
  
  (method (on-widen evt)
    (let ((client (get-client)))
      (let ((selection (get-selection~ client)))
        (let ((end (get-end~ selection)))
          (let ((extend (next-word~ client end)))
            (let ((add (range-first-string~ client (new Range$Cell$ end extend))))
              (if (empty-string? add)
                  (bell)
                (insert-string~ text add)
                (search direction))))))))
  
  
  (method (on-outer-boundaries evt)
    (let ((client (get-client)))
      (let ((range (if (and beginning ending)
                       (new Range$Cell$ beginning ending)
                     (get-selection~ client))))
        (let ((outer (outer-range~ client range)))
          (if (not outer)
              (bell)
            (set! beginning (get-start~ outer))
            (set! ending (get-end~ outer))
            (rehighlight-target)
            (user-message "Boundaries set to range"))))))
  
  
  (method (on-declaration-boundaries evt)
    (let ((client (get-client)))
      (let ((range (if (and beginning ending)
                       (new Range$Cell$ beginning ending)
                     (get-selection~ client))))
        (let ((outer (outer-declaration-range~ client range)))
          (if (not outer)
              (bell)
            (receive (range name declaration-name) outer
              (set! beginning (get-start~ range))
              (set! ending (get-end~ range))
              (rehighlight-target)
              (user-message "Boundaries set to ({a} {a})" name declaration-name)))))))
  
  
  (method (on-buffer-boundaries evt)
    (set! beginning #f)
    (set! ending #f)
    (rehighlight-target)
    (user-message "Boundaries set to buffer"))
  
  
  (method (on-center-caret evt)
    (center-caret~ (get-client)))
  
  
  (method (on-prior evt)
    (prior-page~ (get-client) #f))
  
  
  (method (on-next evt)
    (next-page~ (get-client) #f))
  
  
  (method (on-home evt)
    (on-home~ (get-client) evt)
    (finish))
  
  
  (method (on-end evt)
    (on-end~ (get-client) evt)
    (finish))
  
  
  (method (on-highlight evt)
    (highlight-current))
  
  
  (method (on-persist-highlights evt)
    (persist-highlights))
  
  
  (method protected virtual (highlight-current)
    (persist-highlights)
    (cancel))
  
  
  (method protected virtual (persist-highlights)
    (let ((client (get-client)))
      (let ((reference-style (get-style~ client 'Reference)))
        (for-each (lambda (highlight)
                    (when (or (inherits?~ (get-style~ highlight) found-style)
                              (inherits?~ (get-style~ highlight) highlight-style))
                      (modify-style~ client (get-range~ highlight)
                        (lambda (s)
                          (unless (inherits?~ s reference-style)
                            (let ((style (extend~ s)))
                              (set-base~ style (cons 'Reference (get-base~ style)))
                              style))))))
                  (get-highlights~ client)))))
  
  
  (method (on-replace evt)
    (goto-second-field~ text))
  
  
  (method (on-finish evt)
    (let ((fields (collect-fields~ text)))
      (when (= (caret-rank~ text fields) 1)
        (replace-all (second-content~ text))))
    (finish))
  
  
  (method (on-cancel evt)
    (cancel))

  
  (method (search direction (initial?: initial? #f) (prefix?: prefix? #t) (again?: again? #f))
    (define (search-target client target again?)
      (let ((range (or (and prefix? (table-ref prefixes target #f)) last-range)))
        (let ((pos (case direction
                     ((forward) (if again? (get-end~ range) (get-start~ range)))
                     ((backward) (if again? (get-start~ range) (nu+ (get-start~ range) (cardinality target))))))
              (reversed? (eq? direction 'backward)))
          (set-target~ context target)
          (set-regexp~ context #f)
          (let ((found (text-regular-search~ client context start: pos end: (if reversed? beginning ending) reversed?: reversed?)))
            (define (add-prefix range)
              (reset-prefixes)
              (table-set! prefixes target range))
            
            (define (reset-prefixes)
              (let ((card (cardinality target)))
                (iterate-table-safe prefixes
                  (lambda (prefix range)
                    (when (>= (cardinality prefix) card)
                      (table-clear prefixes prefix))))))
            
            (when found
              (bind (from . to) found
                (let ((range (new Range$Cell$ from to)))
                  (add-prefix range)
                  (set! last-range range)))
              found)))))
    
    (define (highlight-boundary client)
      (define (add-boundary-highlight range)
        (add-highlight~ client (new Text-Highlight range boundary-style)))
      
      (when beginning
        (add-boundary-highlight (new Range$Cell$ beginning (next-cell~ client beginning))))
      (when ending
        (add-boundary-highlight (new Range$Cell$ (previous-cell~ client ending) ending))))
    
    (define (highlight-target client)
      (unless (empty-string? (get-target~ context))
        (for-each (lambda (found)
                    (bind (start . end) found
                      (let ((range (new Range$Cell$ start end)))
                        (unless (nu=? range last-range)
                          (add-highlight~ client (new Text-Highlight range highlight-style))))))
                  (text-regular-search-all~ client context start: beginning end: ending)))
      (add-highlight~ client (new Text-Highlight last-range found-style))
      (set-selection~ client last-range))
    
    (define (highlight-replace client repl)
      (unless (empty-string? repl)
        ;; quicky to test
        (let ((target (make-search-context repl whole-words?: #t)))
          (for-each (lambda (found)
                      (bind (start . end) found
                        (let ((range (new Range$Cell$ start end)))
                          (add-highlight~ client (new Text-Highlight range replace-style)))))
                    (text-regular-search-all~ client target start: beginning end: ending)))))
    
    (let ((client (get-client)))
      (when (is? client Text-View)
        (let ((content (first-content~ text))
              (repl (second-content~ text))
              (target (get-target~ context)))
          (let ((found #f))
            (set! found (search-target client content #f))
            (when again?
              (set! found (search-target client content #t)))
            (when (not found)
              (bell)))
          (remove-highlights)
          (highlight-boundary client)
          (highlight-target client)
          (when repl
            (highlight-replace client repl))))))
  
  
  (method (replace-all repl)
    (let ((client (get-client)))
      (with-atomic-undo~ (get-undoer~ client)
        (lambda ()
          (for-each-reversed (lambda (found)
                               (bind (start . end) found
                                 (let ((range (new Range$Cell$ start end)))
                                   (replace~ client range (list repl)))))
                             (text-regular-search-all~ client context start: beginning end: ending))))))
  
  
  (method (rehighlight-target)
    (search direction))
  
  
  (method (remove-highlights)
    (let ((client (get-client)))
      (when (is? client Text-View)
        (remove-all-highlights~ client))))
  
  
  (method override (finish)
    (cleanup))
  
  
  (method override (cancel)
    (let ((client (get-client))
          (client-selection (get-client-selection)))
      (when client-selection
        (set-selection~ client client-selection ensure-displayed?: #f)
        (scroll-to~ client (get-client-position))))
    (cleanup))
  
  
  (method override (cleanup (lose-focus? #f))
    (restore-client~ text)
    (preserve-search~ text)
    (let ((client (get-client)))
      (when client
        (remove-highlights)
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Highlight-Mode
;;;


(class Highlight-Mode extends Search-Mode
  
  
  (method override (mode-actions)
    (find-actions 'highlight-mode))
  
  
  (method override (highlight-current)
    (cancel))
  
  
  (method override (finish)
    (persist-highlights)
    (cleanup)))


;;;
;;;; Extended-Mode
;;;


(class Extended-Mode extends Command-Mode
  
  
  (method override (mode-actions)
    (find-actions 'extended-mode))
  
  
  (method (on-find-file evt)
    (set-mode~ text (new Find-File-Mode text))
    (set-text~ text (standardize-filename (current-directory)))
    (set-caret~ text (text-ending~ text))
    (refresh-focus-actions text)
    (user-message "Find file..."))
  
  
  (method (on-find-filename evt)
    (set-mode~ text (new Find-Filename-Mode text))
    (set-text~ text "")
    (refresh-focus-actions text)
    (user-message "Find filename..."))
  
  
  (method (on-find-buffer evt)
    (set-mode~ text (new Find-Buffer-Mode text))
    (refresh-focus-actions text)
    (user-message "Find buffer..."))
  
  
  (method (on-save-buffer evt)
    (finish)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-save~ guest evt))))
  
  
  (method (on-save-buffer-as evt)
    (finish)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-save-as~ guest evt))))
  
  
  (method (on-save-all evt)
    (finish)
    (let ((appl (get-application)))
      (on-save-all~ appl evt)))
  
  
  (method (on-revert-buffer evt)
    (finish)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (on-revert-saved~ guest evt))))
  
  
  (method (on-kill-buffer evt)
    (let ((appl (get-application)))
      (on-close~ appl evt)))
  
  
  (method (on-delete-stage evt)
    (delete-stage)
    (finish))
  
  
  (method (on-delete-other-stages evt)
    (delete-other-stages)
    (finish))
  
  
  (method (on-split-stage-vertically evt)
    (split-stage-vertically)
    (finish))
  
  
  (method (on-split-stage-horizontally evt)
    (split-stage-horizontally)
    (finish))
  
  
  (method (on-quit evt)
    (let ((appl (get-application)))
      (on-quit-application~ appl evt)))
  
  
  (method (on-start-recording evt)
    (finish)
    (let ((recorder (get-recorder~ (get-application))))
      (on-start-recording~ recorder evt)))
  
  
  (method (on-stop-recording evt)
    (finish)
    (let ((recorder (get-recorder~ (get-application))))
      (on-stop-recording~ recorder evt)))
  
  
  (method (on-play-recording evt)
    (finish)
    (let ((recorder (get-recorder~ (get-application))))
      (on-play-recording~ recorder evt)))
  
  
  (method (on-downcase-selection evt)
    (finish)
    (let ((text (current-document)))
      (if (is-not? text Text-View)
          (bell)
        (on-downcase-selection~ text evt))))
  
  
  (method (on-upcase-selection evt)
    (finish)
    (let ((text (current-document)))
      (if (is-not? text Text-View)
          (bell)
        (on-upcase-selection~ text evt))))
  
  
  (method (on-select-all evt)
    (finish)
    (let ((view (current-document)))
      (if (not view)
          (bell)
        (on-select-all~ view evt))))
  
  
  (method (on-finish evt)
    (finish))
  
  
  (method (on-cancel evt)
    (cancel)))


;;;
;;;; Find
;;;


(class Find-Mode extends Command-Mode
  
  
  (method override (mode-actions)
    (find-actions 'find-mode))
  
  
  (method override (get-constituent-test)
    alphanumeric?)
  
  
  (method override (auto-complete?)
    #t)
  
  
  (method override (auto-complete-char? key last)
    (memv? key '(#\/ #\- #\_ #\.)))

  
  (method override (favorite-completions?)
    #f)
  
  
  (method override (complete-name? size)
    (>= size 1))


  (method override (completion-name pos)
    (get-string~ text (new Range$Cell$ {Cell 0 0} pos)))
  
  
  (method (on-finish evt)
    (finish))
  
  
  (method (on-cancel evt)
    (cancel))
  
  
  (method override (cancel)
    (cleanup))
  
  
  (method override (cleanup (lose-focus? #f))
    (set-string-content~ text "")
    (restore-client~ text)
    (let ((client (get-client)))
      (when client
        (unless lose-focus?
          (pop-focus))))
    (clear-user-message)))


;;;
;;;; Find-File
;;;


(class Find-File-Mode extends Find-Mode
  
  
  (method override (symbol-completions name)
    (define (split-filename filename)
      (let ((pos (find filename #\/ reversed?: #t)))
        (if (not pos)
            (values #f filename)
          (values (substring filename 0 (+ pos 1))
                  (substring filename (+ pos 1) (string-length filename))))))
    
    (receive (dir filename) (split-filename name)
      (when (or (not dir)
                (and (file-exists? dir)
                     (eq? (pathname-type dir) 'directory)))
        (collect (lambda (name)
                   (when (compare-n filename name (string-length filename) test: char-ci=?)
                     (let ((path (standardize-filename (string-append (or dir "") name))))
                       (if (and (file-exists? path)
                                (eq? (pathname-type path) 'directory))
                           (string-append path "/")
                         path))))
                 (directory-content (list path: (or dir (current-directory)) ignore-hidden: 'dot-and-dot-dot))))))
  
  
  (method override (finish)
    (let ((filename (first-content~ text)))
      (if (and (file-exists? filename)
               (eq? (pathname-type filename) 'regular))
          (let ((file (anchorize~ (new File (tokenise-filename (pathname-normalize filename))))))
            (set-current-directory (get-parent~ file))
            (edit-document~ (get-application) file)
            (cleanup))
        (bell)))))


;;;
;;;; Find-Filename
;;;


(class Find-Filename-Mode extends Find-Mode
  
  
  (slot filenames)
  
  
  (method override (initialize text)
    (define (collect-filenames)
      (let ((workbench (get-workbench))
            (table (make-table test: equal?)))
        (for-each-project-file~ workbench
          (lambda (file)
            (let ((source (get-source~ file)))
              (when source
                (let ((name (downcase (get-name~ source))))
                  (table-set! table name source))))))
        table))
    
    (nextmethod text)
    (set! filenames (collect-filenames)))
  
  
  (method override (symbol-completions name)
    (let ((queue (new-queue)))
      (iterate-table filenames
                     (lambda (filename file)
                       (when (compare-n name filename (string-length name) test: char-ci=?)
                         (enqueue queue filename))))
      (queue-list queue)))
  
  
  (method override (finish)
    (define (find-file name)
      (continuation-capture
        (lambda (return)
          (let ((len (string-length name)))
            (iterate-table filenames
                           (lambda (filename file)
                             (when (compare-n name filename len test: char-ci=?)
                               (let ((remaining (substring filename len (string-length filename))))
                                 (when (or (empty-string? remaining)
                                           (and (eqv? (string-ref remaining 0) #\.)
                                                (not (find remaining #\. start: 1))))
                                   (continuation-return return file)))))))
          #f)))
    
    (let ((filename (first-content~ text)))
      (let ((file (find-file filename)))
        (if file
            (edit-document~ (get-application) file)
          (bell))))))


;;;
;;;; Find-Buffer
;;;


(class Find-Buffer-Mode extends Find-Mode
  
  
  (method override (symbol-completions name)
    (collect (lambda (view)
               (let ((presentation (present-title view)))
                 (when (compare-n name presentation (string-length name) test: char-ci=?)
                   presentation)))
             (all-views)))
  
  
  (method override (finish)
    (define (find-view name)
      (find-if (lambda (view)
                 (string-ci=? (present-title view) name))
               (all-views)))
    
    (let ((name (first-content~ text)))
      (if (empty-string? name)
          (let ((views (all-frames)))
            (if (>= (length views) 2)
                (begin
                  (send-to-back~ (first views))
                  (focus-host~ (current-frame)))
              (bell)))
        (let ((view (find-view name)))
          (if view
              (begin
                (focus-host~ view)
                (cleanup))
            (bell))))))
  
  
  (definition (present-title window/view)
    (let ((title (typecase window/view
                   ((Window)
                    (get-title~ window/view))
                   ((View)
                    (if (is? window/view Host-View)
                        (let ((guest (get-guest~ window/view)))
                          (if (is? guest Document)
                              (name-status~ (get-controller~ guest))
                            (get-title~ window/view)))
                      (get-title~ window/view))))))
      (if (or (null? title) (empty-string? title))
          "<Untitled>"
        title)))
  
  
  (definition (all-views)
    (append (collect-frames)
            (collect-palettes))))


;;;
;;;; Execute-Mode
;;;


(class Execute-Mode extends Command-Mode
  
  
  (method override (mode-actions)
    (find-actions 'execute-mode))
  
  
  (method override (auto-complete?)
    #t)
  
  
  (method (on-finish evt)
    (finish))
  
  
  (method (on-cancel evt)
    (cancel)))


;;;
;;;; Utilities
;;;


(definition (standardize-filename filename)
  (let ((home (pathname-normalize "~")))
    (if (starts-with? filename home)
        (string-append "~/" (substring filename (cardinality home) (cardinality filename)))
      filename))))
