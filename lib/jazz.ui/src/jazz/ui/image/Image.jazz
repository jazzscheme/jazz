;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Images
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.ui.image.Image jazz


(import (jazz.graphic)
        (jazz.io)
        (jazz.library)
        (jazz.utilities)
        (jazz.platform.cairo)
        (jazz.literals)
        (jazz.ui.image))


(class Image extends Object


  (slot icon          initialize {})
  (slot bitmap        initialize {})
  (slot metafile      initialize {})
  (slot portfolio     initialize {})
  (slot image-name    initialize {})
  (slot moniker       initialize {})
  (slot source        initialize {})
  (slot scaled?       initialize #f)
  (slot scaling       initialize 1.0)
  (slot cache?        initialize #f)
  (slot handle        initialize {})
  (slot size          initialize {})
  (slot view-position initialize {Point 0 0})
  (slot view-size     initialize {})
  (slot mode          initialize {})
  
  
  (method (initialize (cache?: cache? #f)
                      (portfolio: portfolio {})
                      (image-name: image-name {})
                      (view-position: view-position {Point 0 0})
                      (view-size: view-size {}))
    (nextmethod)
    (set! cache?~self cache?)
    (set! portfolio~self portfolio)
    (set! image-name~self image-name)
    (set! view-position~self view-position)
    (set! view-size~self view-size))
  
  
  (method public (get-bounds)
    (unimplemented 'get-bounds)
    @windows-specific
    (cond (metafile
           (let ((size (size-of ENHMETAHEADER)))
             (with ((header (new ENHMETAHEADER)))
               (set header 'nSize size)
               (GetEnhMetaFileHeader metafile size header)
               (let ((proc
                      (function (bounds)
                        (if scaled?
                            (scale bounds scaling)
                          bounds))))
                 (proc (RECT->rect (get header 'rclBounds)))))))
          (else
           (error "Unable to get image bounds for {t}" self))))
  
  
;; tofix : should be removed or we should start using libpng
  (method public (get-size (error?: error? #t))
    (cond (source
            size)
          @unused
          (bitmap
            (let ((info (BITMAP-make)))
              (GetObject (either handle (load-image 'bitmap bitmap)) (BITMAP-sizeof) info)
              (new Dimension
                (BITMAP-bmWidth-ref info)
                (BITMAP-bmHeight-ref info))))
          @unused
          (metafile
            (let ((bounds (get-bounds)))
              (new Dimension
                (+ (rect-width bounds) 1)
                (+ (rect-height bounds) 1))))
          (else
           (when error?
             (error "Unable to get image size for {t}" self)))))
  
  
  (method public (get-width)
    (cond (portfolio (get-width~ portfolio))
          (else (get-width~ (get-size)))))
  
  
  (method public (get-height)
    (cond (portfolio (get-height~ portfolio))
          (else (get-height~ (get-size)))))


  ;;;
  ;;;; Drawing
  ;;;


;; tofix : style was ILD_TRANSPARENT
  (method public (draw surface context h v (size: size (get-size error?: #f)) (style: style {}) (enabled?: enabled? #t))
    (let ((h (+ (get-h~ view-position) h))
          (v (+ (get-v~ view-position) v)))
      (draw-image-aux surface context h v size style enabled?)))
  
  
  (method protected (draw-image-aux surface context h v size style enabled?)
    (cond (icon (draw-icon surface context h v size))
          (bitmap (draw-bitmap surface h v size))
          (metafile (draw-metafile surface h v size))
          (portfolio (draw-image surface context h v size style enabled?))
          (source (draw-source surface h v size))
          ((and handle cache?) (draw-bitmap surface h v size))))


  (method (draw-icon surface context h v size)
    (let ((icon (either handle (load-image 'icon icon))))
      (draw-image~ surface icon h v)))
  
  
  (method (draw-bitmap surface h v size)
    (let ((bitmap (either handle (load-image 'bitmap bitmap))))
      (draw-image~ surface icon h v)))
  
  
  (method (draw-metafile surface h v size)
    (unimplemented 'draw-metafile)
    @windows-specific
    (let ((bounds (get-bounds)))
      (with ((rect (rect->RECT bounds)))
        (PlayEnhMetaFile (get-hdc~ surface) metafile rect))))


  (method (draw-image surface context h v size style enabled?)
    (when image-name
      (draw-image~ portfolio surface context image-name h v style: style enabled?: enabled?)))


  (method (draw-source surface h v size)
    (case mode
      ((centered) (draw-centered surface h v))
      ((tiled) (draw-tiled surface h v))
      ((filled) (draw-positioned surface 0 0))
      ((stretched) (draw-centered surface h v))
      (else (draw-positioned surface h v))))


  (method (draw-source-bitmap surface h v)
    (unimplemented 'draw-source-bitmap)
    @windows-specific
    (when handle
      (draw-HBITMAP~ Imaging (get-hdc~ surface) handle h v (get-width~ size) (get-height~ size) NULL)))


  (method (draw-centered surface h v)
    (let ((centered (center size view-size)))
      (when (or (> (get-width~ view-size) (get-width~ size))
                (> (get-height~ view-size) (get-height~ size)))
        (let ((rect (new Rect 0 0 (get-width~ view-size) (get-height~ view-size))))
          (fill-rect~ surface rect {Color name: Black})))
      (draw-source-bitmap surface (get-h~ centered) (get-v~ centered))))


  (method (draw-tiled surface h v)
    (let ((v 0))
      (while (< v (get-height~ view-size))
        (let ((h 0))
          (while (< h (get-width~ view-size))
            (draw-source-bitmap surface h v)
            (increase! h (get-width~ size))))
        (increase! v (get-height~ size)))))


  (method (draw-positioned surface h v)
    (draw-source-bitmap surface (+ (get-h~ view-position) h) (+ (get-v~ view-position) v)))
  
  
  ;;;
  ;;;; Preload
  ;;;
  
  
  (method public (preload-image)
    (when (and portfolio image-name)
      (preload~ portfolio image-name)))


  ;;;
  ;;;; Scaling
  ;;;


  (method public (get-scaled?)
    scaled?)


  (method public (set-scaled? value)
    (set! scaled? value))


  (method public (get-scaling)
    scaling)


  (method public (set-scaling value)
    (set! scaling value))


  ;;;
  ;;;; Access
  ;;;


  (method public (get-mode)
    mode)


  (method public (set-mode md)
    (when (neq? mode md)
      (let ((old mode))
        (set! mode md)
        (when (or (eq? old 'filled) (eq? mode 'filled)
                  (eq? old 'stretched) (eq? mode 'stretched))
          (update-image force?: #t)))))


  (method public (get-view-position)
    view-position)


  (method public (set-view-position pos)
    (set! view-position pos))


  (method public (get-view-size)
    view-size)


  (method public (set-view-size s)
    (set! view-size s))


  (method public (get-icon)
    icon)


  (method public (set-icon icn)
    (set! icon icn))


  (method public (get-portfolio)
    portfolio)


  (method public (set-portfolio pf)
    (set! portfolio pf))


  (method public (get-image-name)
    image-name)


  (method public (set-image-name name)
    (set! image-name name))


  (method public (get-bitmap)
    bitmap)


  (method public (set-bitmap b)
    (unimplemented 'set-bitmap)
    @windows-specific (
    (set! bitmap b)
    (when cache?
      (when handle
        (DeleteObject handle)
        (set! handle {}))
      (when bitmap
        (set! handle (load-image 'bitmap bitmap))))))
  
  
  (method public (get-handle)
    handle)
  
  
  (method public (set-handle hnd)
    (set! handle hnd))


  (method public (get-source)
    source)


  (method public (set-source file)
    (unimplemented 'set-source)
    @windows-specific (
    (set! source {})
    (when handle
      (DeleteObject handle)
      (set! handle {}))
    (when file
      (load-image-source file))))
  
  
  (method public (get-moniker)
    (either moniker bitmap source))
  
  
  (method public (set-moniker mnk)
    (set! moniker mnk)
    (let ((ext (get-extension~ moniker)))
      (cond (#f @this-is-not-clear-and-there-is-a-bug-with-set-bitmap (ci=? ext "bmp")
             (set-bitmap moniker))
            ((member? ext '("wmf" "emf") test: ci=?)
             (load-metafile moniker))
            (else
             (set-source moniker)))))
  
  
  (method (load-metafile moniker)
    (unimplemented 'load-metafile)
    @windows-specific
    (set! metafile (GetEnhMetaFile (parse~ moniker))))


  (method public (update-image (force?: force? #f))
    (when (or force? (eq? mode 'filled) (eq? mode 'stretched))
      (set-source source)))


  (method (load-image-source file)
    (unimplemented 'load-image-source)
    @windows-specific
    (let ((src (open-source file)))
      (receive (rgb w h) (read-source file src)
        (close-source~ Imaging src)
        (if (not rgb)
            (error "Unable to read image source: {t}" file)
          (when view-size
            (case mode
              ((filled)
                (let* ((nw (get-width~ view-size))
                       (nh (get-height~ view-size))
                       (resized-rgb (heap-alloc (* nw nh 3))))
                  (resize-RGB~ Imaging rgb w h resized-rgb nw nh)
                  (heap-free rgb)
                  (set! rgb resized-rgb)
                  (set! w nw)
                  (set! h nh)))
              ((stretched)
                (let* ((rw (/ (get-width~ view-size) w))
                       (rh (/ (get-height~ view-size) h))
                       (ratio (if (> rw rh) rh rw))
                       (nw (fxround (* w ratio)))
                       (nh (fxround (* h ratio)))
                       (resized-rgb (heap-alloc (* nw nh 3))))
                  (resize-RGB~ Imaging rgb w h resized-rgb nw nh)
                  (heap-free rgb)
                  (set! rgb resized-rgb)
                  (set! w nw)
                  (set! h nh)))))
          (with-closed ((compatibility-dc (new Client-Surface (get-desktop))))
            (let ((bmp (RGB->HBITMAP~ Imaging rgb w h NULL (get-hdc~ compatibility-dc))))
              (heap-free rgb)
              (set! source file)
              (set! handle bmp)
              (set! size (new Dimension w h))))))))
  
  
  (method (open-source source)
    (unimplemented 'open-source)
    @windows-specific
    (if (file? source)
        (open-file-source~ Imaging (coerce (parse~ source) Ansi-String))
      (open-memory-source~ Imaging (get-handle~ source) (length source))))


  (method (read-source source src)
    (unimplemented 'read-source)
    @windows-specific
    (case (source-type source)
      ((bmp) (read-BMP->RGB~ Imaging src))
      ((png) (read-PNG->RGB~ Imaging src))
      ((jpg) (read-JPG->RGB~ Imaging src))
      ((tiff) (read-TIFF->RGB~ Imaging src))))


  (method (source-type source)
    (if (file? source)
        (let ((ext (get-extension~ source)))
          (cond ((ci=? ext "bmp") 'bmp)
                ((ci=? ext "png") 'png)
                ((member? ext '("jpg" "jpeg") test: ci=?) 'jpg)
                ((member? ext '("tif" "tiff") test: ci=?) 'tiff)
                (else (error "Unable to display image type: {t}" ext))))
      'jpg))))
