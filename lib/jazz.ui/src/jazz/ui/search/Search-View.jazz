;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Search View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.search.Search-View jazz


(import (jazz.editor.jazz)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.activity)
        (jazz.ui.view)
        (jazz.ui.window)
        (irregex))


(class undocumented Search-View extends Layout-View

  
  (form
    (<install>
      (<Push-Button>                   name: search          title: "Search" position: {Point 755 14} size: {Dimension 80 24} action-handler: {Event-Handler :form on-search} default?: #t)
      (<Group-Box>                     name: domain          position: {Point 10 8} size: {Dimension 350 97})
      (<Splitter>                      name: vertical        position: {Point 362 8} size: {Dimension 6 97} move-handler: {Event-Handler :form on-splitter-move})
      (<Border-View>                   name: targets-border  position: {Point 370 14} size: {Dimension 373 91} border-type: edge style: ()
        (<Scroller-View>                                     vscroll?: #t
          (<content~>                                        layout-type: fill
            (<Tree-Header>
              (<content~>
                (<Search-Targets>      name: targets         font: {Font name: Label-User} default-row-height: 15
                  (<Tree-Node-Column>                        title: "Find" width: 176 toplevel-controls?: #f display-images?: #f)
                  (<Tree-Label-Column>                       title: "Replace" width: 173)))))))
      (<Check-Box>                     name: whole-words?    title: "Whole Words" position: {Point 10 114} size: {Dimension 100 18})
      (<Check-Box>                     name: ignore-case?    title: "Ignore Case" position: {Point 118 114} size: {Dimension 100 18})
      (<Check-Box>                     name: regexp?         title: "Regexp" position: {Point 226 114} size: {Dimension 100 18})
      (<Check-Box>                     name: preserve-case?  title: "Preserve Case" position: {Point 375 114} size: {Dimension 100 18})
      (<Check-Box>                     name: play-recording? title: "Play Recording" position: {Point 483 114} size: {Dimension 100 18})
      ;; temp #f
      (<Check-Box>                     name: expression?     title: "Expression" visible?: #f position: {Point 388 114} size: {Dimension 200 18})))
  
  
  (method public (next-radio)
    (let* ((domain (get-search-domain))
           (domains (get-search-domains))
           (pos (find domains domain)))
      (when pos
        (set-search-domain (element domains (modulo (+ pos 1) (length domains)))))))
  
  
  (method public (next-tab)
    (let* ((manager (get-manager))
           (max-selection (length (get-children~ manager)))
           (old-selection (get-selection~ manager))
           (new-selection (modulo (+ old-selection 1) max-selection)))
      (set-selection~ manager new-selection)))


  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (finish rest)
    (nextmethod rest)
    (let ((tree (locate 'targets)))
      (for-each (lambda (column)
                  (set-justification~ column '(1 1)))
                (get-columns~ tree))))


  ;;;
  ;;;; Session
  ;;;
  
  
  (method public virtual (get-session-properties)
    (list
      'domain          (get-search-domain)
      'targets         (get-search-targets)
      'whole-words?    (get-whole-words?)
      'ignore-case?    (get-ignore-case?)
      'preserve-case?  (get-preserve-case?)
      'play-recording? (get-play-recording?)
      'expression?     (get-expression?)))
  
  
  (method public virtual (set-session-properties config)
    (set-search-targets  (get-targets~ config))
    (set-whole-words?    (get-whole-words?~ config))
    (set-ignore-case?    (get-ignore-case?~ config))
    (set-preserve-case?  (get-preserve-case?~ config))
    (set-play-recording? (get-play-recording?~ config))
    (set-expression?     (get-expression?~ config)))


  ;;;
  ;;;; Manager
  ;;;
  
  
  (method (get-manager)
    (child 3))
    

  ;;;
  ;;;; Access
  ;;;
  
  
  (method protected (get-results)
    (get-search-results~ (get-application)))
  
  
  (method public (get-targets-tree)
    (locate 'targets))
  
  
  (method public (get-search-targets)
    (let* ((tree (locate 'targets))
           (height (get-visible-count~ tree))
           (fact (new List-Factory)))
      ;; to-convert temp patch
      (if (in-edition?~ tree)
          '()
        (for-each (lambda (line)
                    (let ((find (get-title~ (get-cell-data~ tree (new Cell line 0))))
                          (repl (get-title~ (get-cell-data~ tree (new Cell line 1)))))
                      (unless (and (empty-string? find) (empty-string? repl))
                        (put~ fact (list find repl)))))
                  (naturals 0 height))
        (get-output~ fact))))


  (method public (set-search-targets targets)
    (let ((tree (locate 'targets))
          (count (length targets)))
      (ensure-visible-count~ tree count)
      (let ((width (get-columns-count~ tree))
            (height (get-visible-count~ tree)))
        (with-update-locked~ tree
          (lambda ()
            (for-each (lambda (target line)
                        (for-each (lambda (target col)
                                    (let ((cell (new Cell line col)))
                                      (set-cell-title~ tree cell target)
                                      (invalidate-cell~ tree cell)))
                                  target
                                  (naturals 0 (length target))))
                      targets
                      (naturals 0 (length targets)))
            (for-each (lambda (line)
                        (for-each (lambda (col)
                                    (let ((cell (new Cell line col)))
                                      (set-cell-title~ tree cell "")
                                      (invalidate-cell~ tree cell)))
                                  (naturals 0 width)))
                      (naturals (length targets) height)))))))
  
  
  (method public (get-find-targets)
    (let ((whole-words? (get-whole-words?))
          (ignore-case? (get-ignore-case?))
          (regexp? (get-regexp?)))
      (->search-set
        (map (lambda (target)
               (make-search-context (first target)
                 whole-words?: whole-words?
                 ignore-case?: ignore-case?
                 regexp?: regexp?))
             (get-search-targets)))))
  
  
  (method (get-replace-targets)
    (map second (get-search-targets)))
  
  
  (method public (get-search-domain)
    (let ((group (get-content~ (locate 'domain))))
      (find-if (lambda (name)
                 (let ((radio (find-component~ group name)))
                   (when (and radio (get-selected?~ radio))
                     name)))
               (get-search-domains))))
  
  
  (method public (set-search-domain domain)
    (let* ((group (get-content~ (locate 'domain)))
           (radio (find-component~ group domain)))
      (when radio
        (for-each (lambda (child)
                    (when (is? child Radio-Button)
                      (set-selected?~ child (eq? child radio))))
                  (get-children~ group)))))
  
  
  (method public (get-whole-words?)
    (get-checked?~ (locate 'whole-words?)))
  
  
  (method public (set-whole-words? flag)
    (set-checked?~ (locate 'whole-words?) flag))
  
  
  (method public (get-ignore-case?)
    (get-checked?~ (locate 'ignore-case?)))
  
  
  (method public (set-ignore-case? flag)
    (set-checked?~ (locate 'ignore-case?) flag))
  
  
  (method public (get-regexp?)
    (get-checked?~ (locate 'regexp?)))
  
  
  (method public (set-regexp? flag)
    (set-checked?~ (locate 'regexp?) flag))
  
  
  (method public (get-preserve-case?)
    (get-checked?~ (locate 'preserve-case?)))
  
  
  (method public (set-preserve-case? flag)
    (set-checked?~ (locate 'preserve-case?) flag))
  
  
  (method public (get-play-recording?)
    (get-checked?~ (locate 'play-recording?)))
  
  
  (method public (set-play-recording? flag)
    (set-checked?~ (locate 'play-recording?) flag))
  
  
  (method public (get-expression?)
    (get-checked?~ (locate 'expression?)))
  
  
  (method public (set-expression? flag)
    (set-checked?~ (locate 'expression?) flag))
    

  ;;;
  ;;;; Domains
  ;;;
  
  
  (method public virtual (get-search-domains)
    '())
  
  
  (method public virtual (get-active-window-domain)
    #f)


  ;;;
  ;;;; Events
  ;;;
  
  
  (method package (on-search evt)
    (hide~ (get-player))
    (let ((targets (locate 'targets)))
      (end-edition~ targets)
      (let ((search-set (get-find-targets)))
        (if (null? (get-contexts~ search-set))
            (bell)
          (search-targets search-set)))))
  
  
  (method protected virtual (search-targets targets)
    )


  (method override (resize dh dv)
    (nextmethod dh dv)
    (move-figure~ (locate 'search) dh 0)
    (size-figure~ (locate 'domain) 0 dv)
    (size-figure~ (locate 'targets-border) dh dv)
    (move-figure~ (locate 'whole-words?) 0 dv)
    (move-figure~ (locate 'ignore-case?) 0 dv)
    (move-figure~ (locate 'regexp?) 0 dv)
    (move-figure~ (locate 'preserve-case?) 0 dv)
    (move-figure~ (locate 'play-recording?) 0 dv)
    (move-figure~ (locate 'expression?) 0 dv))
  
  
  (method (on-splitter-move evt)
    (let ((delta (get-property~ evt delta:)))
      (size-figure~ (locate 'domain) delta 0)
      (move-figure~ (locate 'targets-border) delta 0)
      (size-figure~ (locate 'targets-border) (- delta) 0)
      (update-view)))
    
    
  (method override (on-return-press evt)
    (on-search evt))
  
  
  (method package (on-find-forward evt)
    (let ((search-set (get-find-targets)))
      (unless (null? (get-contexts~ search-set))
        (let ((target (get-target-text))
              (domain (get-search-domain)))
          (unless (and target (find-forward target search-set (follow-search-results? domain)))
            (bell))))))
  
  
  (method package (on-find-backward evt)
    (let ((search-set (get-find-targets)))
      (unless (null? (get-contexts~ search-set))
        (let ((target (get-target-text))
              (domain (get-search-domain)))
          (unless (and target (find-backward target search-set (follow-search-results? domain)))
            (bell))))))
  
  
  (method package (on-replace evt)
    (let* ((find (get-contexts~ (get-find-targets)))
           (repl (get-replace-targets))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (target (get-target-text)))
      (unless (and target (replace target find repl ignore-case? case? play? expression?))
        (bell))))
  
  
  (method package (on-replace&find-forward evt)
    (let* ((find (get-contexts~ (get-find-targets)))
           (repl (get-replace-targets))
           (domain (get-search-domain))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (next? (follow-search-results? domain))
           (target (get-target-text)))
      (unless (and target (replace&find-forward target find repl ignore-case? case? play? expression? next?))
        (bell))))
  
  
  (method package (on-replace-all evt)
    (let* ((find (get-contexts~ (get-find-targets)))
           (repl (get-replace-targets))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (target (get-target-text)))
      (if (not target)
          (bell)
        (replace-all target find repl ignore-case? case? play? expression?))))
  
  
  (method package (on-replace-selected evt)
    (let ((code (message-box "Automatically save & close files that are not currently edited?" type: 'confirmation)))
      (if (eq? code 'cancel)
          (throw-cancel)
        (let* ((auto-save/close? (eq? code 'yes))
               (find (get-contexts~ (get-find-targets)))
               (repl (get-replace-targets))
               (appl (get-application))
               (ignore-case? (get-ignore-case?~ appl))
               (case? (get-preserve-case?~ appl))
               (play? (get-play-recording?~ appl))
               (expression? (get-expression?~ appl))
               (results (get-results))
               (tree (locate~ results 'results))
               (selection (get-selection~ tree))
               (modified-count 0))
          (for-each (lambda (item)
                      (receive (frame new?) (edit-item~ results item #t #f #f)
                        (let* ((guest (get-guest~ frame))
                               (target (get-text-view~ guest))
                               (moniker (get-moniker~ (get-controller~ target))))
                          (user-feedback "Processing {a}..." (get-name~ moniker))
                          (replace-all target find repl ignore-case? case? play? expression?)
                          (when (and auto-save/close? new?)
                            (when (get-modified?~ target)
                              (save~ guest)
                              (increase! modified-count))
                            (close~ frame)))))
                    selection)
          (when auto-save/close?
            (message-box (format "{a} file{a} modified" modified-count (format-plural modified-count))))
          (user-feedback "Done")))))


  (method (get-target-text)
    (let ((frame (first-frame)))
      (when (is? frame Frame-Host)
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (get-text-view~ guest))))))
  
  
  (method (follow-search-results? domain)
    (or (not domain) (neq? domain (get-active-window-domain))))


  ;;;
  ;;;; Reporting
  ;;;
  
  
  (method protected (get-search-reporter count)
    (let* ((manager (get-activity-manager))
           (reporter (register-activity~ manager)))
      (setup-search-reporter reporter count)
      (show~ manager)
      reporter))
  
  
  (method protected virtual (setup-search-reporter reporter count)
    )

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method (replace target find-list repl-list ignore-case? case? play? expression?)
    (define (determine-case str)
      (if (or (empty-string? str) (lower-case? (element str 0)))
          'lower-case
        (if (or (= (cardinality str) 1) (upper-case? (element str 1)))
            'upper-case
          'capitalized)))
    
    (define (convert-case str cs)
      (case cs
        ((lower-case)  (downcase str))
        ((upper-case)  (upcase str))
        ((capitalized) (capitalize str))))
    
    (define (get-replacement str find-list repl-list)
      (and (pair? find-list)
           (pair? repl-list)
           (let ((m (irregex-match (search-context-regexp (car find-list)) str)))
             (if m
                 (if (get-regexp?~ (car find-list))
                     (expand-replacement str m (car repl-list))
                   (car repl-list))
               (get-replacement str (cdr find-list) (cdr repl-list))))))
    
    (define (expand-replacement str m repl)
      (let ((end (- (string-length repl) 1)))
        (let (lp (from 0) (i 0) (res '()))
          (define (collect) (if (= i from) res (cons (substring repl from i) res)))
          (cond
            ((>= i end) (apply string-append (reverse (collect))))
            ((eqv? #\\ (string-ref repl i))
             (lp (+ i 2)
                 (+ i 2)
                 (cons
                   (case (string-ref repl (+ i 1))
                     ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
                      (or (irregex-match-substring m (- (char->integer (string-ref repl (+ i 1))) (char->integer #\0))) ""))
                     ((#\n) "\n") ((#\t) "\t") ((#\r) "\r")
                     (else (substring repl (+ i 1) (+ i 2))))
                   (collect))))
            (else (lp from (+ i 1) res))))))

    (let* ((str (get-selected-string~ target))
           (repl (and str (if expression? (car repl-list) (get-replacement str find-list repl-list)))))
      (when repl
        (if (not play?)
            (insert-string~ target (if case? (convert-case repl (determine-case str)) repl))
          ;; temp... should not be necessary. play-recording should be
          ;; made to work even if the window doesn't have the focus.
          (acquire-focus~ target)
          (play-current-recording~ (get-recorder~ (get-application))))
        #t)))
  
  
  (method (replace&find-forward target find repl ignore-case? case? play? expression? (next? #t))
    (replace target find repl ignore-case? case? play? expression?)
    (unless (null? find)
      (find-forward target find next?)))
  
  
  (method (replace-all target find repl ignore-case? case? play? expression?)
    (replace target find repl ignore-case? case? play? expression?)
    (while (find-forward target find #f)
      (replace target find repl ignore-case? case? play? expression?)))
  
  
  (method protected (find-forward target search-set (next? #t))
    (or (select-next~ target search-set)
        (and next? (edit-next~ (get-results)))))
  
  
  (method protected (find-backward target search-set (previous? #t))
    (or (select-previous~ target search-set)
        (and previous? (edit-previous~ (get-results)))))


  ;;;
  ;;;; Search
  ;;;


  (method (search-in-file search-set file expression? factory reporter)
    (unless (and reporter (cancel-requested?~ reporter))
      (when reporter
        (user-feedback~ reporter "Searching {a}" (get-name~ file))
        (step-it~ reporter))
      (let ((info (search-file file search-set expression?)))
        (when info
          (put~ factory (list file info search-set))))))
  
  
  (method protected (search-in-directories search-set directories extensions expression? factory reporter)
    (for-each (lambda (directory)
                (search-in-directory search-set directory extensions expression? factory reporter))
              directories))
  

  (method protected (search-in-directory search-set directory extensions expression? factory reporter)
    (let ((all-extensions? (equal? extensions '("*"))))
      (iterate-directory~ directory
        (lambda (file)
          (let ((ext (get-extension~ file)))
            (cond ;; very quick and dirty solution
              ((and all-extensions? (not (member? ext '("obj" "o" "o1" "o2" "o3" "o4" "o5" "o6" "o7" "o8" "o9" "a" "dll" "exe") test: ci=?)) @convert (<= (get-size~ file) 512000))
               (search-in-file search-set file expression? factory reporter))
              ((member? ext extensions test: ci=?)
               (search-in-file search-set file expression? factory reporter)))))
        ignored-toplevel-directories: '(".git" ".hg" "bin" "build" "bootstrap" "gambit"))))


  (method (search-file file search-set expression?)
    (when (exists?~ file)
      (let ((ext (get-extension~ file)))
        (if (not expression?)
            (call-with-input-file (list path: (parse~ file) char-encoding-errors: #f eol-encoding: 'cr-lf)
              (lambda (reader)
                (let ((content (read-content-string reader))
                      (constituent-test (extension-constituent-test ext)))
                  (contextual-search content search-set constituent-test: constituent-test))))
          (let ((text (new Jazz-Text-View)))
            (set-moniker~ text file)
            (let* ((beginning (text-beginning~ text))
                   (expl (new Jazz-Explorer text start: beginning end: beginning))
                   (mode (if (ci=? ext "jazz") 'code 'quotation)))
              (search-expressions~ expl mode search-set beginning)))))))


  ;;;
  ;;;; Targets
  ;;;


  (method public virtual (select-search)
    (let ((targets (locate 'targets)))
      (select-cell~ targets {Cell 0 0})))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (current-history-item)
    (let ((tree (locate 'results)))
      (new History-Search-Item
        (get-mode~ (get-results))
        (get-search-domain)
        (get-search-targets)
        (get-whole-words?)
        (get-ignore-case?)
        (get-preserve-case?)
        (get-play-recording?)
        (get-expression?)
        (get-content~ tree)
        (get-selection~ tree))))
  
  
  (method protected (install-history-item item)
    (let ((tree (locate 'results)))
      (set-mode~ (get-results) (get-mode~ item))
      (set-search-domain (get-domain~ item))
      (set-search-targets (get-targets~ item))
      (set-whole-words? (get-whole-words?~ item))
      (set-ignore-case? (get-ignore-case?~ item))
      (set-preserve-case? (get-preserve-case?~ item))
      (set-play-recording? (get-play-recording?~ item))
      (set-expression? (get-expression?~ item))
      (set-content~ tree (get-content~ item))
      (set-selection~ tree (get-selection~ item)))))


;;;
;;;; Search-Targets
;;;


(class Search-Targets extends Tree-View
  
  
  (method override (mouse-down pos)
    (let ((cell (view->tree pos any?: #t uniform-height?: #t)))
      (if (not cell)
          (nextmethod pos)
        (select-cell cell))))
  
  
  (method override (tab-stop-enter)
    (select-cell {Cell 0 0}))
  
  
  (method override (add-empty-row (father: father #f))
    (let ((father (or father root-row))
          (children (map new-empty-cell~ columns)))
      (add-row father: father children: children)))
  
  
  (method override (select-cell cell)
    (end-edition)
    (let* ((data (get-cell-data cell))
           (left (if (= (get-col~ cell) 0) 3 0))
           (editor (new Border-View border-type: 'solid border-color: {Color Medium}))
           (scroller (new Scroller-View parent: editor vscroll?: #f hscroll?: #f))
           (text (new Tree-Embedded-Search-Text-View parent: (get-content~ scroller) left-padding: left top-padding: 0 font: font)))
      (when data
        (set-string-content~ text (get-title~ data)))
      (ensure-row-exists (get-line~ cell))
      (edit-cell cell
                 editor: editor
                 after-end: (lambda (cell)
                              (set-title~ (get-cell-data cell) (get-string-content~ text))))
      (set-client~ scroller text)
      (set-tree~ text self)
      (layout-scrollee~ text)
      (acquire-focus~ text)
      (select-all~ text)))))
