;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Code Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.ui.text.Code-Text-View jazz


(import (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.automata)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.ui.view)
        (jazz.utilities)
        (time))


(class undocumented Code-Text-View extends Text-View
  
  
  (form
    (<install> default-style: {Text-Style name: Default font: {Font name: Code}} left-padding: 12))
  
  
  (method (new-syntax)
    (new Code-Syntax))

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method (host-workspaces)
    '(text debugger))
  
  
  ;;;
  ;;;; Access
  ;;;
    

  (method (tab-press key modifiers)
    (if (or (has-completion?)
            (not accepts-returns?))
        (nextmethod key modifiers)
      (if (or (empty-selection?) (= (get-row~ (get-start)) (get-row~ (get-end))))
          (insert-char #\tab)
        (tabulate))))

  
  (method (backspace-press key (word?: word? #f))
    (let ((previous (previous-cell (get-start))))
      (if (not completion-active?)
          (insert-char/backspace #\backspace word?: word?)
        (when previous
          (complete-current #\backspace previous {} #t #f)))))


  (method (char-press key translated)
    (nextmethod key translated)
    (flash-matching-character)
    (when (eqv? key #\space)
      (show-arguments)))


  (method (select-outer)
    (end-completion)
    (nextmethod))


  (method (context-menu pos)
    (receive (shift? control? alt?) (modifiers-down)
      (let ((move-caret
             (cond ((and (not control?) (not shift?) (not alt?)) 'outside-selection)
                   ((and (not control?) shift? (not alt?)) 'never)
                   ((and control? shift? (not alt?)) 'never)
                   (else 'always))))
        (context-menu-click pos move-caret: move-caret))
      (cond ((and (not control?) shift? (not alt?)) (edit-definitions pos))
            ((and control? shift? (not alt?)) (edit-references pos))
            (else (track-popup-menu (get-context-menu) pos)))))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method (focus-actions)
    (cons (find-actions 'code-text)
          (nextmethod)))
  

  ;;;
  ;;;; Explorer
  ;;;


  (method (explorer-class)
    Code-Explorer)

  
  ;;;
  ;;;; Moving
  ;;;
  
  
  (method (backward-compound)
    (backward-expr))
  
  
  (method (forward-compound)
    (forward-expr))
  
  
  (method (upward-compound)
    (exit-composite))
  
  
  (method (downward-compound)
    (enter-composite))
  
  
  (method package (on-backward evt)
    (backward-expr))
  
  
  (method package (on-forward evt)
    (forward-expr))
  
  
  (method package (on-enter-composite evt)
    (enter-composite))
  
  
  (method package (on-exit-composite evt)
    (exit-composite))


  (method protected virtual (forward-expr)
    (let ((expl <Text-Explorer> (new (explorer-class) self end: (get-end))))
      (when (forward-expr~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method protected virtual (backward-expr)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start))))
      (when (backward-expr~ expl)
        (set-caret (get-start~ expl)))))
  
  
  (method protected virtual (enter-composite)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start) end: (get-end))))
      (when (enter-composite~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method protected virtual (exit-composite)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-end) end: (get-end))))
      (when (exit-list~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method (move-caret pos direction shift?)
    (nextmethod pos direction shift?)
    (end-completion))
  
  
  (method (on-transpose-expr evt)
    (transpose-expr))
  
  
  (method public (transpose-expr)
    (if (has-selection?)
        (bell)
      (with-atomic-undo~ undoer
        (function ()
          (let ((left-expl <Text-Explorer> (new (explorer-class) self))
                (right-expl <Text-Explorer> (new (explorer-class) self)))
            (set-pos~ left-expl (get-start))
            (backward-expr~ left-expl)
            (set-pos~ right-expl (get-end))
            (forward-expr~ right-expl)
            (let ((left (get-range~ left-expl))
                  (right (get-range~ right-expl)))
              (if (or (not left) (not right))
                  (bell)
                (let ((ls (range-strings left))
                      (rs (range-strings right)))
                  (replace right ls)
                  (replace left rs)))))
          (set-modified? #t)))))

  
  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method public virtual (get-context)
    #t)
  
  
  (method (header-string? form)
    (and (string? form)
         (>= (string-length form) 2)
         (eqv? (first form) #\double-quote)
         (eqv? (last form) #\double-quote)))
  
  
  (method protected virtual (edition-workspace)
    {})

  
  (method (on-edit-definitions evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (cond ((header-string? form)
               (edit-filename~ appl (subseq form 1 (- (string-length form) 1))))
              ((file? form)
               (edit-document~ appl form workspace: (edition-workspace)))
              (else
               (let ((form (standardize-form form)))
                 (edit-definitions~ appl form workspace: (edition-workspace) history-item: (current-history-item) context: (get-context))))))))

  
  (method (on-edit-references evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (let ((form (standardize-form form)))
          (edit-references~ appl form history-item: (current-history-item) context: (get-context))))))
    
  
  (method (standardize-form form)
    (cond ((tag? form) (tag->name form))
          ((dispatch? form) (dispatch->name form))
          (else form)))


  (method protected virtual (expr-at pos)
    )
    
  
  (method protected virtual (edit-symbol-class symbol)
    #f)


  (method protected (edit-definitions pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (cond ((header-string? form)
               (edit-filename~ (get-application) (subseq form 1 (- (string-length form) 1))))
              ((file? form)
               (edit-document~ (get-application) form))
              (else
               (let* ((appl (get-application))
                      (cataloguer (get-cataloguer~ appl)))
                 (when cataloguer
                   (let* ((item (current-history-item))
                          (form (standardize-form form))
                          (list (get-coalesced-definitions~ cataloguer form context: (get-context))))
                     (case (length list)
                       ((0) (bell))
                       ((1) (add-history~ appl item) (edit~ (car list)))
                       (else (track-popup-menu (new Definitions-Menu history-item: item definitions: list) pos)))))))))))


  (method protected (edit-references pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (let* ((appl (get-application))
               (cataloguer (get-cataloguer~ appl)))
          (when cataloguer
            (let* ((item (current-history-item))
                   (form (standardize-form form))
                   (list (get-references~ cataloguer form context: (get-context))))
              (case (length list)
                ((0) (bell))
                ((1) (add-history~ appl item) (edit-reference~ (car list) form))
                (else (track-popup-menu (new References-Menu history-item: item target: form definitions: list) pos)))))))))

  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (current-history-item)
    (let ((selection (get-selection))
          (moniker (get-moniker)))
      (if (not moniker)
          (let ((frame (get-frame)))
            (when frame
              (new History-Document-Item frame selection)))
        (new History-File-Item moniker selection))))

  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method (save-content moniker)
    (nextmethod moniker)
    @really-not-sure-its-fun-to-have-errors-poping-on-save
    (update-catalog))

  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method package (on-update-catalog evt)
    (update-catalog))
  
  
  (method (update-catalog)
    (let ((catalog (find-catalog)))
      (if (not catalog)
          (bell)
        (if (update-file~ catalog (get-moniker))
            (user-message "Updated")
          (user-message "Already up-to-date")))))
  
  
  (method (find-catalog)
    (let ((moniker (get-moniker)))
      (when moniker
        (let ((entries (get-file-entries~ (get-cataloguer~ (get-application)) moniker)))
          (when (not-null? entries)
            ;; quicky until we check for catalogs overlapping
            (let ((entry (car entries)))
              (get-catalog~ entry)))))))

  
  ;;;
  ;;;; Coloring
  ;;;


  (method package (on-recolorize-syntax evt)
    (with-cursor :wait
      (function ()
        (recolorize-syntax))))
  
  
  (method public (recolorize-syntax)
    (uncolorize-all)
    (colorize-syntax recoloring?: #t))


  (method (uncolorize-all)
    (for-each uncolorize-row (naturals 0 (get-length))))
  
  
  (method protected virtual (preferences)
    )
  
  
  (method protected virtual (syntax-targets)
    {})
  
  
  (method protected virtual (syntax-automata)
    {})
  
  
  (method protected virtual (compute-syntax-targets)
    )
  
  
  (method protected virtual (compute-syntax-automata)
    (let ((targets (syntax-targets)))
      (when targets
        (build-search-automata targets #t #f c-constituent?))))
  
  
  (method (colorize-syntax (recoloring?: recoloring? #f) (entries?: entries? #t))
    (colorize-syntax-from (text-beginning) recoloring?)
    (when entries?
      (colorize-entries)))
  
  
  (method (colorize-syntax-from pos recoloring?)
    (let ((automata (syntax-automata)))
      (when automata
        (let ((found (automata-search automata (get-paragraphs) (get-limit) 0 0))
              (colorizer (essay (not recoloring?) (new-colorizer self))))
          (while (not-null? found)
            (let ((info (car found)))
              (bind ((target type) row col) info
                (let ((start (new Cell row col))
                      (end (new Cell row (+ col (string-length target)))))
                  (set! found (colorize-type found type start end colorizer #f))))))
          (when colorizer
            (finish-current~ colorizer))))))
  
  
  (method protected (apply-coloring colorizer start end style-name)
    (if (not colorizer)
        (apply-style style-name start end)
      (apply-style~ colorizer start end style-name)))
  
  
  (method protected virtual (colorize-type found type start end colorizer recolorize?)
    )
  
  
  (method protected virtual (colorize-balanced-comment found start end colorizer style)
    (continuation-capture
      (function (return)
        (while (not-null? found)
          (let ((info (car found)))
            (bind ((target type) row col) info
              (if (eq? type 'balanced-comment-backward)
                  (let ((end (new Cell row (+ col 2))))
                    (apply-coloring colorizer start end style)
                    (continuation-return return (cdr found)))
                (set! found (cdr found))))))
        found)))
  
  
  (method protected (colorize-balanced-comment-backward found start end colorizer style recolorize? (open: open "/*") (close: close "*/"))
    (when recolorize?
      (let ((found (text-multisearch (list (make-search-context close user-data: 'close) (make-search-context open user-data: 'open)) position: start reverse?: #t)))
        (when found
          (bind (pos . (target type)) found
            (when (eq? type 'open)
              (apply-coloring colorizer pos end style)
              (cdr found)))))))
  
  
  (method protected (colorize-line-comment found start end colorizer line-style title-style title-char)
    (let ((title? (and title-char (eqv? (get-char (next-pos start 2)) title-char))))
      (if (not title?)
          (apply-coloring colorizer start (new Cell (get-row~ start) (paragraph-length (get-row~ start))) line-style)
        (apply-coloring colorizer start (nu+ start 3) line-style)
        (apply-coloring colorizer (nu+ start 3) (new Cell (get-row~ start) (paragraph-length (get-row~ start))) title-style))
      (let ((row (get-row~ start)))
        (set! found (cdr found))
        (while (and (not-null? found) (= (second (car found)) row))
          (set! found (cdr found)))
        found)))
  
  
  (method protected (colorize-keyword found start end colorizer style)
    (apply-coloring colorizer start end style)
    (cdr found))
  
  
  (method (find-specifier-end start)
    (let* ((row (get-row~ start))
           (col (get-col~ start))
           (str (paragraph-string row)))
      (unless (>= (+ col 1) (cardinality str))
        (let ((nxt (element str (+ col 1))))
          (unless (or (eqv? nxt #\space) (eqv? nxt #\=))
            (let ((col (find-balanced #\< #\> str start: (+ col 1) return: 'position)))
              (when col
                (new Cell row (+ col 1)))))))))

  
  (method (recolorize-text start end-row)
    (let ((pos (new Cell (get-row~ start) 0))
          (targets (syntax-targets)))
      @commented-for-slow-machines-until-optimized
      (when targets
        (let ((opening (text-multisearch (list (make-search-context "/*" user-data: 'open) (make-search-context "*/" user-data: 'close)) position: start reverse?: #t)))
          (when opening
            (bind (start . (target type)) opening
              (when (eq? type 'open)
                (set! pos start))))))
      (let ((range (naturals (get-row~ pos) (+ end-row 1))))
        (for-each uncolorize-row range))
      (let ((automata (syntax-automata)))
        (when automata
          (let ((found (automata-search automata (get-paragraphs) end-row (get-row~ pos) (get-col~ pos)))
                (colorizer (new-colorizer self)))
            (while (not-null? found)
              (let ((info (car found)))
                (bind ((target type) row col) info
                  (let ((start (new Cell row col))
                        (end (new Cell row (+ col (string-length target)))))
                    (set! found (colorize-type found type start end colorizer #f))))))
            (finish-current~ colorizer))))))
  
  
  (method public virtual (colorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (for-each colorize-entry entries))))
  
  
  (method protected virtual (get-parsed-entries)
    (let ((moniker (get-moniker)))
      (when (and moniker (file? moniker) (not (get-modified?)))
        (let ((cataloguer (get-cataloguer~ (get-application))))
          (when cataloguer
            (let ((entries (get-file-entries~ cataloguer moniker context: '(c))))
              (when (not-null? entries)
                (let ((file-entry (car entries)))
                  (when (= (time->seconds (get-time~ file-entry)) (time->seconds (get-moniker-time~ (get-controller))))
                    (get-definitions~ file-entry))))))))))

  
  (method (colorize-entry entry)
    (letrec ((proc
              (function (entry)
                (let* ((name (get-name~ entry))
                       (line (get-line~ entry))
                       (column (get-column~ entry))
                       (start (new Cell line column))
                       (end (new Cell line (+ column (string-length name)))))
                  ;; until the time test of the previous method becomes functional
                  (when (<= line (get-limit))
                    (stylize 'Definition start end)
                    @cannot-work-yet
                    (when (equal? Class-Entry (class-of entry))
                      (colorize-entry (get-extends~ entry))
                      (colorize-entry (get-implements~ entry)))
                    (for-each colorize-entry (get-definitions~ entry)))))))
      (proc entry)))
  
  
  (method public (recolorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (uncolorize-all)
        (colorize-syntax entries?: #f)
        (for-each colorize-entry entries))))

  
  ;;;
  ;;;; Edition
  ;;;


  (method package (on-paste&stay evt)
    (paste&stay))


  (method package (on-paste&next evt)
    (paste&stay)
    (down-arrow-move #f #f))
  
  
  (method (paste&stay)
    (let ((pos (get-start)))
      (paste-clipboard)
      (set-caret pos)))

  
  ;;;
  ;;;; Reading
  ;;;
  
  
  (method protected virtual (get-readtable)
    )
  
  
  (method (read-text-form range (string: string {}) (readtable: readtable (get-readtable)))
    (let ((string (either string (get-string range))))
      (call-with-input-string (list init: string readtable: readtable)
        read)))
  
  
  (method (read-text-forms range (string: string {}) (readtable: readtable (get-readtable)))
    (let ((string (either string (get-string range))))
      (call-with-input-string (list init: string readtable: readtable)
        (function (port)
          (read-until eof-object? port)))))
  
  
  (method (offset-pos/range pos range)
    (if (= 0 (get-row~ (get-start~ range)) (get-row~ (get-end~ range)))
        (new Range$Cell$ (+ pos (get-start~ range)) (+ pos (get-end~ range)))
      (new Range$Cell$
        (new Cell (+ (get-row~ pos) (get-row~ (get-start~ range))) (get-col~ (get-start~ range)))
        (new Cell (+ (get-row~ pos) (get-row~ (get-end~ range))) (get-col~ (get-end~ range))))))

  
  ;;;
  ;;;; Evaluation
  ;;;
  
  
  (method (on-evaluate evt)
    (evaluate-selection))
  
  
  (method (on-evaluate-buffer evt)
    (evaluate-buffer))
  
  
  (method protected virtual (evaluate-selection)
    )
  
  
  (method protected virtual (evaluate-buffer)
    )
  
  
  (method protected virtual (evaluate-range range)
    )

  
  ;;;
  ;;;; Tabulation
  ;;;


  (method public virtual (tabulate)
    (if (has-selection?)
        (for-each (if (shift-down?) untabulate-line tabulate-line)
                  (selected-lines))
      (let* ((pos (get-start))
             (row (get-row~ pos))
             (col (get-col~ pos)))
        (when (and (> row 0) (= col 0))
          (let* ((line (paragraph-string (- row 1)))
                 (rank (find-if (function (c) (not (whitespace? c))) line return: 'position)))
            (if (not rank)
                (insert-string line)
              (insert-string (subseq line 0 rank))))))))
  
  
  (method protected virtual (tabulate-line row)
    (replace-text (new Range$Cell$ (new Cell row 0) (new Cell row 0))
                  (list (string #\tab))))
  
  
  (method (untabulate-line row)
    (when (space/tab? (get-char (new Cell row 0)))
      (replace-text (new Range$Cell$ (new Cell row 0) (new Cell row 1))
                    (list ""))))
  
  
  (method (space/tab? c)
    (memq? c '(#\space #\tab)))
  
  
  (method public virtual (tabulate-lines start end)
    )


  ;;;
  ;;;; Completion
  ;;;
  
  
  (method (auto-complete?)
    #t)


  (method (completion-name pos postfix)
    (unless (text-constituent?~ syntax (get-char (if (has-selection?) (get-end) pos)))
      (let ((prev (previous-cell pos)))
        (if (not prev)
            postfix
          (let ((c (get-char prev)))
            (unless (string-delimiter? c)
              (if (not (text-constituent?~ syntax c))
                  postfix
                (let ((expl <Text-Explorer> (new (explorer-class) self start: pos end: pos)))
                  (when (and (backward-expr~ expl) (memq? (get-kind~ expl) '(symbol keyword string)))
                    (let ((c (char-backward~ expl 0)))
                      (when (or (not c) (not (string-delimiter? c)))
                        (string-append (get-symbol-string~ expl) (either postfix "")))))))))))))
  
  
  (method (symbol-completions name favorites)
    (if (numeric? name)
        '()
      (let ((cataloguer (get-cataloguer~ (get-application))))
        (if (not cataloguer)
            '()
          (let ((table (make-table test: equal?))
                (len (string-length name)))
            (add-completions~ cataloguer table name context: (get-context))
            @not-sure-why-this-is-necessary
            (for-each (function (pair)
                        (let ((favorite (->string (cdr pair))))
                          (when (compare-n favorite name len)
                            (table-set! table favorite #t))))
                      favorites)
            (iterate-table (get-aliases)
                           (function (symbol ignore)
                             (let ((alias (->string symbol)))
                               (when (compare-n alias name len)
                                 (table-set! table alias #t)))))
            (table-keys table))))))
    
  
  ;;;
  ;;;; Arguments
  ;;;
  
  
  (method protected virtual (show-arguments)
    )
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method (left-arrow-move extend? word?)
    (convert-completion)
    (nextmethod extend? word?))
  
  
  (method (right-arrow-move extend? word?)
    (convert-completion)
    (nextmethod extend? word?))
  
  
  (method (up-arrow-move extend? scroll?)
    (convert-completion)
    (nextmethod extend? scroll?))
  
  
  (method (down-arrow-move extend? scroll?)
    (convert-completion)
    (nextmethod extend? scroll?))
  
  
  ;;;
  ;;;; Tabify
  ;;;
  
  
  (method (on-tabify evt)
    (tabify))
  
  
  (method (tabify)
    (for-each tabify-line
              (naturals (get-row~ (get-start)) (+ (get-row~ (get-end)) 1))))
  
  
  (method (tabify-line row)
    @to-convert-to-outline-text
    (let* ((line (paragraph-string row))
           (char (find-if (function (c) (not (whitespace? c))) line return: 'position)))
      (when (and char (> char 0))
        (let* ((column (char->column line char))
               (tabs   (floor (/ column tab-size)))
               (spaces (modulo column tab-size)))
          (replace-text (new Range$Cell$ (new Cell row 0) (new Cell row char))
                        (list (append! (make-string tabs #\tab)
                                       (make-string spaces #\space))))))))


  ;;;
  ;;;; Match
  ;;;


  (method (flash-matching-character)
    (when (and (empty-selection?) (not (at-beginning?)))
      (let ((pos (previous-cell (get-end))))
        (when (flash-character? (get-char pos))
          (catch (Explore-Error err
                   (bell))
            (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-end))))
              (if (not (backward-expr~ expl))
                  (bell)
                (flash-character (get-start~ expl) pos))))))))


  (method (flash-character start end)
    (unless (macro-playing?~ (get-application))
      (if (cell-displayed? start)
          (let ((old (get-selection)))
            (set-selection (new Range$Cell$ start (next-cell start)))
            (update-view)
            (sleep .2)
            (set-selection old)
            (update-view))
        (let* ((pos (text->view end))
               @w(tran (acquire~ (get-desktop) self pos))
               @w(tool (new Tooltip position: tran size: {Dimension 100 20} visible?: #f))
               (expl <Text-Explorer> (new (explorer-class) self start: (nu+ start 1) end: (nu+ start 1))))
          (user-message "{l detail: :human}" (map (function (mark)
                                                    (get-string (get-range~ mark)))
                                                  (collect-forward-exprs~ expl 3)))
          (sleep .2)))))
  
  
  ;;;
  ;;;; Java
  ;;;
    
  
  (method (on-browse-java evt)
    (browse-java))
  
  
  (method (browse-java)
    @wait
    (let ((expr (current-expr)))
      (if (is-not? expr Symbol)
          (bell)
        (let* ((classname (->string expr))
               (javaClass (lookupClass~ org.apache.bcel.Repository classname)))
          (if (not javaClass)
              (error "Unable to find java class: {a}" classname)
            (let* ((host (new-frame Java-Manager))
                   (manager (get-guest~ host)))
              (browse-classes~ manager (list classname))))))))


  ;;;
  ;;;; Read/Write
  ;;;
  
  
  (method (on-set-read/write evt)
    (let ((moniker (get-moniker~ controller)))
      (set-read/write~ moniker)
      (update-status))))


;;;
;;;; Definitions-Menu
;;;


(class Definitions-Menu extends Context-Menu
  
  
  (property definitions  getter get-definitions  setter set-definitions)
  (property history-item getter get-history-item setter set-history-item)
  
  
  (method public (get-definitions)
    definitions)
  
  
  (method public (set-definitions list)
    (set! definitions list))
  
  
  (method public (get-history-item)
    history-item)
  
  
  (method public (set-history-item item)
    (set! history-item item))
  
  
  (method (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (function (definition)
                    (let ((title (present~ definition)))
                      (new Label-Item parent: self title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list definition: definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (function (user-data title parent)
                            (new Label-Item parent: parent title: title action-handler: (new Event-Handler target: menu method-name: 'on-action properties: (list definition: user-data)))))
             (get-string (function (user-data) (present~ user-data))))
        (make-condensed-menu definitions create-item key: get-string))))
  
  
  (method (definition<? x y)
    (string<? (present~ x) (present~ y)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit~ (get-property~ evt definition:))))


;;;
;;;; References-Menu
;;;


(class References-Menu extends Context-Menu
  
  
  (property target       getter get-target       setter set-target)
  (property definitions  getter get-definitions  setter set-definitions)
  (property history-item getter get-history-item setter set-history-item)
  
  
  (method public (get-target)
    target)
  
  
  (method public (set-target trg)
    (set! target trg))
  
  
  (method public (get-definitions)
    definitions)
  
  
  (method public (set-definitions list)
    (set! definitions list))
  
  
  (method public (get-history-item)
    history-item)
  
  
  (method public (set-history-item item)
    (set! history-item item))
  
  
  (method (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (function (definition)
                    (let ((title (->string (present~ definition))))
                      (new Label-Item parent: self title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list definition: definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (function (user-data title parent)
                            (new Label-Item parent: parent title: title action-handler: (new Event-Handler target: menu method-name: 'on-action properties: (list definition: user-data)))))
             (get-string (function (user-data) (present~ user-data))))
        (make-condensed-menu definitions create-item key: get-string))))
  
  
  (method (definition<? x y)
    (string<? (present~ x) (present~ y)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit-reference~ (get-property~ evt definition:) target))))
