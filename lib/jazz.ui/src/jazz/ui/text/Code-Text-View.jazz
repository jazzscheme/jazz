;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Code Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.text.Code-Text-View jazz


(import (jazz.catalog)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.automata)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.ui.view)
        (time))


(class undocumented Code-Text-View extends Text-View
  
  
  (slot matching-highlights initialize '())
  (slot flashing-thread     initialize {})
  
  
  (form
    (<install> default-style: {Text-Style name: Default font: {Font name: Code}} left-padding: 12))
  
  
  (method override (new-syntax)
    (new Code-Syntax))

  
  (method override (install rest)
    (nextmethod rest)
    (let ((pref (preferences)))
      (when pref
        ;; default style
        (let ((default-style-preference (get-default-style~ pref)))
          (when default-style-preference
            (let ((style (add-style-preference 'Default {} default-style-preference)))
              (set-default-style style))))
        ;; base styles
        (let ((base-styles-preferences (get-base-styles~ pref)))
          (for-each (lambda (base-style-preference)
                      (add-style-preference {} 'Default base-style-preference))
                    base-styles-preferences))
        (let ((default (get-name~ default-style)))
          (add-style-preference 'Match default (get-match-style~ pref))))))

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method override (host-workspaces)
    '(text debugger test reference emacs empty multi))
  
  
  ;;;
  ;;;; Access
  ;;;
    

  (method override (tab-press key modifiers)
    (if (or (has-completion?)
            (not accepts-returns?))
        (nextmethod key modifiers)
      (if (or (empty-selection?) (= (get-line~ (get-start)) (get-line~ (get-end))))
          (insert-char #\tab)
        (tabulate))))


  (method override (char-press key)
    (nextmethod key)
    (when (eqv? key #\space)
      (show-arguments)))


  (method override (select-outer)
    (end-completion)
    (nextmethod))


  (method override (context-menu pos)
    (receive (shift? control? alt?) (modifiers-down)
      (let ((move-caret
             (cond ((and (not control?) (not shift?) (not alt?)) 'outside-selection)
                   ((and (not control?) shift? (not alt?)) 'never)
                   ((and control? shift? (not alt?)) 'never)
                   (else 'always))))
        (context-menu-click pos move-caret: move-caret))
      (cond ((and (not control?) shift? (not alt?)) (edit-definitions pos))
            ((and control? shift? (not alt?)) (edit-references pos))
            (else (track-popup-menu (get-context-menu) pos)))))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions)
    (cons (find-actions 'code-text)
          (nextmethod)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-find-imports evt)
    (with-cursor :wait
      (lambda ()
        (find-imports~ (get-syntax) self (current-expr)))))
  
  
  (method (on-find-all-imports evt)
    )
  

  ;;;
  ;;;; Explorer
  ;;;


  (method override (explorer-class)
    Code-Explorer)

  
  ;;;
  ;;;; Moving
  ;;;
  
  
  (method override (backward-compound)
    (backward-expr))
  
  
  (method override (forward-compound)
    (forward-expr))
  
  
  (method override (upward-compound)
    (exit-composite))
  
  
  (method override (downward-compound)
    (enter-composite))
  
  
  (method package (on-backward-composite evt)
    (backward-expr))
  
  
  (method package (on-forward-composite evt)
    (forward-expr))
  
  
  (method package (on-backward-outline evt)
    (backward-expr outline?: #t))
  
  
  (method package (on-forward-outline evt)
    (forward-expr outline?: #t))
  
  
  (method package (on-enter-composite evt)
    (enter-composite))
  
  
  (method package (on-exit-composite evt)
    (exit-composite))


  (method protected virtual (forward-expr (outline?: outline? locked-anchor?))
    (let ((expl <Text-Explorer> (new (explorer-class) self end: (get-end))))
      (when (forward-expr~ expl)
        (if outline?
            (change-selection (get-end~ expl))
          (set-caret (get-end~ expl))))))
  
  
  (method protected virtual (backward-expr (outline?: outline? locked-anchor?))
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start))))
      (when (backward-expr~ expl)
        (if outline?
            (change-selection (get-start~ expl))
          (set-caret (get-start~ expl))))))
  
  
  (method protected virtual (enter-composite)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-start) end: (get-end))))
      (when (enter-composite~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method protected virtual (exit-composite)
    (let ((expl <Text-Explorer> (new (explorer-class) self start: (get-end) end: (get-end))))
      (when (exit-list~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method override (move-caret pos direction shift?)
    (nextmethod pos direction shift?)
    (end-completion))
  
  
  (method (on-transpose-expr evt)
    (transpose-expr))
  
  
  (method public (transpose-expr)
    (transpose-movements forward-expr~ backward-expr~))

  
  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method public virtual (get-context)
    #t)
  
  
  (method protected virtual (edition-workspace)
    {})

  
  (method (on-edit-definitions evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (cond ((string? form)
               (edit-document~ appl (new File (tokenise-filename form))))
              ((file? form)
               (edit-document~ appl form workspace: (edition-workspace)))
              (else
               (let ((item (current-history-item))
                     (form (standardize-form (if (keyword? form) (keyword->symbol form) form))))
                 (if (use-composite-name-heuristic? form)
                     (edit-composite appl item form)
                   (edit-definitions~ appl form workspace: (edition-workspace) history-item: item context: (get-context)))))))))

  
  (method (on-edit-references evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (let ((form (standardize-form form)))
          (edit-references~ appl form constituent-test: (get-constituent-test) history-item: (current-history-item) context: (get-context))))))
    
  
  (method (standardize-form form)
    (cond ((tag? form) (tag->name form))
          ((dispatch? form) (dispatch->name form))
          (else form)))
  
  
  (method (use-composite-name-heuristic? name)
    (and (composite-name? name)
         (let ((parts (split-identifier name)))
           (not (and (= (length parts) 2)
                     (eq? (car parts) 'jazz))))))


  (method protected virtual (expr-at pos)
    )
    
  
  (method protected virtual (edit-symbol-class symbol)
    #f)


  (method protected (edit-definitions pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (cond ((string? form)
               (edit-document~ (get-application) (new File (tokenise-filename form))))
              ((file? form)
               (edit-document~ (get-application) form workspace: (edition-workspace)))
              (else
               (let* ((appl (get-application))
                      (cataloguer (get-cataloguer~ appl)))
                 (when cataloguer
                   (let ((item (current-history-item))
                         (form (standardize-form (if (keyword? form) (keyword->symbol form) form))))
                     (if (use-composite-name-heuristic? form)
                         (edit-composite appl item form)
                       (let ((definitions (get-coalesced-definitions~ cataloguer form context: (get-context))))
                         (case (length definitions)
                           ((0) (bell))
                           ((1) (add-history~ appl item) (edit~ (car definitions)))
                           (else (track-popup-menu (new Definitions-Menu history-item: item definitions: definitions) pos)))))))))))))


  (method protected (edit-references pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (let* ((appl (get-application))
               (cataloguer (get-cataloguer~ appl)))
          (when cataloguer
            (let* ((item (current-history-item))
                   (form (standardize-form form))
                   (references (get-references~ cataloguer form context: (get-context)))
                   (target (list (make-search-context (->string form) whole-words?: #t constituent-test: (get-constituent-test)))))
              (case (length references)
                ((0) (bell))
                ((1) (add-history~ appl item) (edit-reference~ (car references) target))
                (else (track-popup-menu (new References-Menu history-item: item target: target definitions: references) pos)))))))))
  
  
  (definition (edit-composite appl item form)
    (let ((entry (locator->entry form)))
      (if (not entry)
          (bell)
        (add-history~ appl item)
        (edit~ entry))))

  
  ;;;
  ;;;; History
  ;;;
  
  
  (method override (current-history-item)
    (let ((selection (get-selection))
          (moniker (get-moniker)))
      (if (not moniker)
          (let ((frame (get-frame)))
            (when frame
              (new History-Document-Item frame selection)))
        (new History-File-Item moniker selection))))

  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method override (save-content moniker)
    (nextmethod moniker)
    (update-catalog))

  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (let ((moniker (get-moniker)))
      (when moniker
        (let ((catalog (find-catalog)))
          (when catalog
            (post-catalog
              (lambda ()
                (update-file~ catalog moniker))))))))
  
  
  (method (find-catalog)
    (let ((moniker (get-moniker)))
      (when moniker
        (let ((entries (get-file-entries~ (get-cataloguer~ (get-application)) moniker)))
          (when (not-null? entries)
            ;; quicky until we check for catalogs overlapping
            (let ((entry (car entries)))
              (get-catalog~ entry)))))))

  
  ;;;
  ;;;; Coloring
  ;;;


  (method package (on-recolorize-syntax evt)
    (with-cursor :wait
      (lambda ()
        (recolorize-syntax))))
  
  
  (method public (recolorize-syntax)
    (uncolorize-all)
    (colorize-syntax recoloring?: #t))


  (method (uncolorize-all)
    (for-each uncolorize-row (naturals 0 (get-length))))
  
  
  (method protected virtual (syntax-targets)
    {})
  
  
  (method protected virtual (syntax-automata)
    {})
  
  
  (method protected virtual (compute-syntax-targets)
    )
  
  
  (method protected virtual (compute-syntax-automata)
    (let ((targets (syntax-targets)))
      (when targets
        (build-search-automata targets #t #f c-constituent?))))
  
  
  (method override (colorize-syntax (recoloring?: recoloring? #f) (entries?: entries? #t))
    (define (colorize-syntax-from pos)
      (let ((automata (syntax-automata)))
        (when automata
          (let ((found (automata-search automata (new TextTape (get-paragraphs) (get-limit) 0 0)))
                (colorizer (essay (not recoloring?) (new-colorizer self))))
            (while (not-null? found)
              (let ((info (car found)))
                (bind ((target type) line col) info
                  (let ((start (new Cell line col))
                        (end (new Cell line (+ col (string-length target)))))
                    (set! found (colorize-type found type start end colorizer #f))))))
            (when colorizer
              (finish-current~ colorizer))))))
    
    (colorize-syntax-from (text-beginning))
    (when entries?
      (colorize-entries)))
  
  
  (method protected (apply-coloring colorizer start end style-name)
    (if (not colorizer)
        (apply-style style-name start end)
      (apply-style~ colorizer start end style-name)))
  
  
  (method protected virtual (colorize-type found type start end colorizer recolorize?)
    (error "Unknown type: {s}" type))
  
  
  (method protected virtual (colorize-balanced-comment found start end colorizer style)
    (continuation-capture
      (lambda (return)
        (while (not-null? found)
          (let ((info (car found)))
            (bind ((target type) line col) info
              (if (eq? type 'balanced-comment-backward)
                  (let ((end (new Cell line (+ col 2))))
                    (apply-coloring colorizer start end style)
                    (continuation-return return (cdr found)))
                (set! found (cdr found))))))
        found)))
  
  
  (method protected (colorize-balanced-comment-backward found start end colorizer style recolorize? (open: open "/*") (close: close "*/"))
    (cdr found)
    @irregex-to-convert
    (when recolorize?
      (let ((found (text-multisearch (list (make-search-context close user-data: 'close) (make-search-context open user-data: 'open)) position: start reversed?: #t)))
        (when found
          (bind (pos . (target type)) found
            (when (eq? type 'open)
              (apply-coloring colorizer pos end style)
              (cdr found)))))))
  
  
  (method protected (colorize-line-comment found start end colorizer line-style title-style title-char)
    (let ((title? (and title-char (eqv? (get-char (next-pos start 2)) title-char))))
      (if (not title?)
          (apply-coloring colorizer start (new Cell (get-line~ start) (paragraph-length (get-line~ start))) line-style)
        (apply-coloring colorizer start (nu+ start 3) line-style)
        (apply-coloring colorizer (nu+ start 3) (new Cell (get-line~ start) (paragraph-length (get-line~ start))) title-style))
      (let ((line (get-line~ start)))
        (set! found (cdr found))
        (while (and (not-null? found) (= (second (car found)) line))
          (set! found (cdr found)))
        found)))
  
  
  (method protected (colorize-keyword found start end colorizer style)
    (apply-coloring colorizer start end style)
    (cdr found))
  
  
  (method (find-specifier-end start)
    (let* ((line (get-line~ start))
           (col (get-col~ start))
           (str (paragraph-string line)))
      (unless (>= (+ col 1) (cardinality str))
        (let ((nxt (element str (+ col 1))))
          (unless (or (eqv? nxt #\space) (eqv? nxt #\=))
            (let ((col (find-balanced #\< #\> str start: (+ col 1) return: 'position)))
              (when col
                (new Cell line (+ col 1)))))))))

  
  (method override (recolorize-text start end-line)
    (let ((pos (new Cell (get-line~ start) 0))
          (targets (syntax-targets)))
      @commented-for-slow-machines-until-optimized
      (when targets
        (let ((opening (text-multisearch (list (make-search-context "/*" user-data: 'open) (make-search-context "*/" user-data: 'close)) position: start reversed?: #t)))
          (when opening
            (bind (start . (target type)) opening
              (when (eq? type 'open)
                (set! pos start))))))
      (let ((range (naturals (get-line~ pos) (+ end-line 1))))
        (for-each uncolorize-row range))
      (let ((automata (syntax-automata)))
        (when automata
          (let ((found (automata-search automata (new TextTape (get-paragraphs) end-line (get-line~ pos) (get-col~ pos))))
                (colorizer (new-colorizer self)))
            (while (not-null? found)
              (let ((info (car found)))
                (bind ((target type) line col) info
                  (let ((start (new Cell line col))
                        (end (new Cell line (+ col (string-length target)))))
                    (set! found (colorize-type found type start end colorizer #f))))))
            (finish-current~ colorizer))))))
  
  
  (method public virtual (colorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (for-each colorize-entry entries))))
  
  
  (method protected virtual (get-parsed-entries)
    (let ((moniker (get-moniker)))
      (when (and moniker (file? moniker) (not (get-modified?)))
        (let ((cataloguer (get-cataloguer~ (get-application))))
          (when cataloguer
            (let ((entries (get-file-entries~ cataloguer moniker context: '(c))))
              (when (not-null? entries)
                (let ((file-entry (car entries)))
                  (when (= (time->seconds (get-time~ file-entry)) (time->seconds (get-moniker-time~ (get-controller))))
                    (get-definitions~ file-entry))))))))))

  
  (method (colorize-entry entry)
    (letrec ((proc
              (lambda (entry)
                (let* ((name (get-name~ entry))
                       (line (get-line~ entry))
                       (column (get-column~ entry))
                       (start (new Cell line column))
                       (end (new Cell line (+ column (string-length name)))))
                  ;; until the time test of the previous method becomes functional
                  (when (<= line (get-limit))
                    (stylize 'Definition start end)
                    @cannot-work-yet
                    (when (equal? Class-Entry (class-of entry))
                      (colorize-entry (get-extends~ entry))
                      (colorize-entry (get-implements~ entry)))
                    (for-each colorize-entry (get-definitions~ entry)))))))
      (proc entry)))
  
  
  (method public (recolorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (uncolorize-all)
        (colorize-syntax entries?: #f)
        (for-each colorize-entry entries))))

  
  ;;;
  ;;;; Reading
  ;;;
  
  
  (method protected virtual (get-readtable)
    (current-readtable))
  
  
  (method (read-text-form range (string: string {}) (readtable: readtable (get-readtable)))
    (let ((string (either string (get-string range))))
      (call-with-input-string (list init: string readtable: readtable)
        read)))
  
  
  (method (read-text-forms range (string: string {}) (readtable: readtable (get-readtable)))
    (let ((string (either string (get-string range))))
      (call-with-input-string (list init: string readtable: readtable)
        (lambda (port)
          (read-until eof-object? port)))))
  
  
  (definition (offset-pos/range pos range)
    (if (= 0 (get-line~ (get-start~ range)) (get-line~ (get-end~ range)))
        (new Range$Cell$ (+ pos (get-start~ range)) (+ pos (get-end~ range)))
      (new Range$Cell$
        (new Cell (+ (get-line~ pos) (get-line~ (get-start~ range))) (get-col~ (get-start~ range)))
        (new Cell (+ (get-line~ pos) (get-line~ (get-end~ range))) (get-col~ (get-end~ range))))))

  
  ;;;
  ;;;; Evaluation
  ;;;
  
  
  (method (on-evaluate evt)
    (evaluate-selection))
  
  
  (method (on-evaluate-buffer evt)
    (evaluate-buffer))
  
  
  (method protected virtual (evaluate-selection)
    )
  
  
  (method protected virtual (evaluate-buffer)
    )
  
  
  (method protected virtual (evaluate-range range)
    )

  
  ;;;
  ;;;; Tabulation
  ;;;


  (method public virtual (tabulate)
    (define (untabulate-line line)
      (when (space/tab? (get-char (new Cell line 0)))
        (replace-text (new Range$Cell$ (new Cell line 0) (new Cell line 1))
                      (list ""))))
    
    (define (space/tab? c)
      (memq? c '(#\space #\tab)))
    
    (if (has-selection?)
        (for-each (if (shift-down?) untabulate-line tabulate-line)
                  (selected-lines))
      (let* ((pos (get-start))
             (line (get-line~ pos))
             (col (get-col~ pos)))
        (when (and (> line 0) (= col 0))
          (let* ((line (paragraph-string (- line 1)))
                 (rank (find-if (lambda (c) (not (whitespace? c))) line return: 'position)))
            (if (not rank)
                (insert-string line)
              (insert-string (subseq line 0 rank))))))))
  
  
  (method protected virtual (tabulate-line line)
    (replace-text (new Range$Cell$ (new Cell line 0) (new Cell line 0))
                  (list (string #\tab))))
  
  
  (method public virtual (tabulate-lines start end)
    )


  ;;;
  ;;;; Completion
  ;;;
  
  
  (method override (auto-complete?)
    #t)


  (method override (completion-name pos)
    (unless (text-constituent?~ syntax (get-char (if (has-selection?) (get-end) pos)))
      (let ((prev (previous-cell pos)))
        (when prev
          (let ((c (get-char prev)))
            (unless (string-delimiter? c)
              (when (text-constituent?~ syntax c)
                (let ((expl <Text-Explorer> (new (explorer-class) self start: pos end: pos)))
                  (when (and (backward-expr~ expl) (memq? (get-kind~ expl) '(symbol keyword string)))
                    (let ((c (char-backward~ expl 0)))
                      (when (or (not c) (not (string-delimiter? c)))
                        (get-symbol-string~ expl))))))))))))
  
  
  (method override (symbol-completions name)
    (if (numeric? name)
        '()
      (let ((cataloguer (get-cataloguer~ (get-application))))
        (if (not cataloguer)
            '()
          (let ((table (make-table test: equal?))
                (len (string-length name)))
            (add-completions~ cataloguer table name context: (get-context))
            (iterate-table (get-aliases)
                           (lambda (symbol ignore)
                             (let ((alias (->string symbol)))
                               (when (compare-n alias name len)
                                 (table-set! table alias #t)))))
            (table-keys table))))))
    
  
  ;;;
  ;;;; Arguments
  ;;;
  
  
  (method protected virtual (show-arguments)
    )
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method override (left-arrow-move extend? word?)
    (convert-completion)
    (nextmethod extend? word?))
  
  
  (method override (right-arrow-move extend? word?)
    (convert-completion)
    (nextmethod extend? word?))
  
  
  (method override (up-arrow-move extend? scroll?)
    (convert-completion)
    (nextmethod extend? scroll?))
  
  
  (method override (down-arrow-move extend? scroll?)
    (convert-completion)
    (nextmethod extend? scroll?))
  
  
  ;;;
  ;;;; Tabify
  ;;;
  
  
  (method (on-tabify evt)
    (tabify))
  
  
  (method (tabify)
    (define (tabify-line line)
      @to-convert-to-outline-text
      (let* ((line (paragraph-string line))
             (char (find-if (lambda (c) (not (whitespace? c))) line return: 'position)))
        (when (and char (> char 0))
          (let* ((column (char->column line char))
                 (tabs   (floor (/ column tab-size)))
                 (spaces (modulo column tab-size)))
            (replace-text (new Range$Cell$ (new Cell line 0) (new Cell line char))
                          (list (append! (make-string tabs #\tab)
                                         (make-string spaces #\space))))))))
    
    (for-each tabify-line (naturals (get-line~ (get-start)) (+ (get-line~ (get-end)) 1))))
  

  ;;;
  ;;;; Match
  ;;;
  
  
  (method protected virtual (match-backwards? char)
    #f)
  
  
  (method protected virtual (match-forwards? char)
    #f)


  (method (flash-matching-character pref)
    (define flash-delay
      (if (keyboard-input?)
          0
        (get-flash-delay~ pref)))
    
    (define flash-duration
      (get-flash-duration~ pref))
    
    (define (flash-character highlight)
      (let ((start (get-start~ (get-range~ highlight))))
        (if (cell-displayed? start)
            (set! flashing-thread
                  (thread-start!
                    (new-thread
                      (lambda ()
                        (sleep flash-delay)
                        (execute-event
                          (lambda ()
                            (add-matching-highlight highlight)))
                        (sleep flash-duration)
                        (execute-event
                          (lambda ()
                            (remove-matching-highlights)
                            (set! flashing-thread {})))))))
          (let ((expl <Text-Explorer> (new (explorer-class) self start: (nu+ start 1) end: (nu+ start 1))))
            (user-message "{l detail: :human}" (map (lambda (mark)
                                                      (get-string (get-range~ mark)))
                                                    (collect-forward-exprs~ expl 3)))))))
    
    (define (exit-flashing-thread)
      (when flashing-thread
        (thread-interrupt! flashing-thread
          thread-exit)
        (set! flashing-thread {})))
    
    (let ((pref (preferences)))
      (when (and pref (eq? (get-match-action~ pref) 'flash))
        (remove-matching-highlights)
        (exit-flashing-thread)
        (let ((highlight (find-matching-highlight (not (keyboard-input?)))))
          (when (and highlight (neq? flash-delay 'infinity))
            (flash-character (car highlight)))))))
  
  
  (method (highlight-matching-character pref)
    (define (highlight-character)
      (let ((highlight (find-matching-highlight)))
        (when highlight
          (add-matching-highlight (car highlight))
          (when (eq? (get-highlight-mode~ pref) 'both)
            (add-matching-highlight (cdr highlight))))))
    
    (remove-matching-highlights)
    (highlight-character))
  
  
  (method (find-matching-highlight (forward? #t))
    (define (find-backward pos)
      (unless (at-beginning?)
        (let ((previous (previous-cell pos)))
          (when (match-backwards? (get-char previous))
            (catch (Explore-Error err
                     (bell)
                     #f)
              (let ((expl <Text-Explorer> (new (explorer-class) self start: pos)))
                (when (backward-expr~ expl)
                  (let ((start (get-start~ expl)))
                    (cons (new-highlight start (next-cell start))
                          (new-highlight previous pos))))))))))
    
    (define (find-forward pos)
      (unless (at-end?)
        (when (match-forwards? (get-char pos))
          (catch (Explore-Error err
                   (bell)
                     #f)
            (let ((expl <Text-Explorer> (new (explorer-class) self start: pos)))
              (when (forward-expr~ expl)
                (let ((end (get-end~ expl)))
                  (cons (new-highlight (previous-cell end) end)
                        (new-highlight pos (next-cell pos))))))))))
    
    (define (new-highlight start end)
      (let ((range (new-range start end))
            (style (get-style 'Match)))
        (new Text-Highlight range style show-unfocused?: #f)))
    
    (unless (macro-playing?~ (get-application))
      (when (empty-selection?)
        (let ((pos (get-caret)))
          (either (find-backward pos)
                  (and forward? (find-forward pos)))))))
  
  
  (method (add-matching-highlight highlight)
    (add-highlight highlight)
    (invalidate-highlight highlight)
    (set! matching-highlights (cons highlight matching-highlights)))
  
  
  (method (remove-matching-highlights)
    (for-each (lambda (highlight)
                (remove-highlight highlight)
                (invalidate-highlight highlight))
              matching-highlights)
    (set! matching-highlights '()))
  
  
  (method override (selection-change)
    (let ((pref (preferences)))
      (when pref
        (case (get-match-action~ pref)
          ((flash) (flash-matching-character pref))
          ((highlight) (highlight-matching-character pref))))))
  
  
  ;;;
  ;;;; Java
  ;;;
    
  
  (method (on-browse-java evt)
    (browse-java))
  
  
  (method (browse-java)
    @wait
    (let ((expr (current-expr)))
      (if (is-not? expr Symbol)
          (bell)
        (let* ((classname (->string expr))
               (javaClass (lookupClass~ org.apache.bcel.Repository classname)))
          (if (not javaClass)
              (error "Unable to find java class: {a}" classname)
            (let* ((host (new-frame Java-Manager))
                   (manager (get-guest~ host)))
              (browse-classes~ manager (list classname))))))))


  ;;;
  ;;;; Read/Write
  ;;;
  
  
  (method (on-set-read/write evt)
    (let ((moniker (get-moniker~ controller)))
      (set-read/write~ moniker)
      (update-status))))


;;;
;;;; Definitions-Menu
;;;


(class Definitions-Menu extends Context-Menu
  
  
  (property definitions  accessors generate)
  (property history-item accessors generate)
  
  
  (method override (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (lambda (definition)
                    (let ((title (present~ definition)))
                      (new Label-Item parent: self title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list definition: definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (lambda (user-data title parent)
                            (new Label-Item parent: parent title: title action-handler: (new Event-Handler target: menu method-name: 'on-action properties: (list definition: user-data)))))
             (get-string present~))
        (make-condensed-menu definitions create-item key: get-string))))
  
  
  (definition (definition<? x y)
    (string<? (present~ x) (present~ y)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit~ (get-property~ evt definition:))))


;;;
;;;; References-Menu
;;;


(class References-Menu extends Context-Menu
  
  
  (property target       accessors generate)
  (property definitions  accessors generate)
  (property history-item accessors generate)
  
  
  (method override (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (lambda (definition)
                    (let ((title (->string (present~ definition))))
                      (new Label-Item parent: self title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list definition: definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (lambda (user-data title parent)
                            (new Label-Item parent: parent title: title action-handler: (new Event-Handler target: menu method-name: 'on-action properties: (list definition: user-data)))))
             (get-string present~))
        (make-condensed-menu definitions create-item key: get-string))))
  
  
  (definition (definition<? x y)
    (string<? (present~ x) (present~ y)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit-reference~ (get-property~ evt definition:) target))))
