;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Marcel Cote
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.text.Text-View jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.exemplar)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.search)
        (jazz.ui.skin)
        (jazz.ui.view)
        (jazz.ui.window))


(class Text-View extends Outline-View implements Document
  
  
  (property protected selectable?               initialize #t accessors generate)
  (property protected editable?                 initialize #t accessors generate)
  (property protected accepts-returns?          initialize #t accessors generate)
  (property protected focus-selects-all?        initialize #f accessors generate)
  (property protected show-unfocused-selection? initialize #t accessors generate)
  (property protected force-tab-navigate?       initialize #f accessors generate)
  
  
  (slot protected syntax                 initialize #f accessors generate)
  (slot protected controller             initialize #f)
  (slot protected selection-anchor       initialize #f)
  (slot protected locked-anchor?         initialize #f)
  (slot protected mouse-selecting?       initialize #f)
  (slot protected selection-mode         initialize 'char)
  (slot protected special-mode           initialize #f)
  (slot protected virtual-h              initialize #f)
  (slot protected caret-pulse            initialize #f)
  (slot protected caret-pulse?           initialize #t)
  (slot protected caret-visible?         initialize #f)
  (slot protected completion-active?     initialize #f)
  (slot protected mark                   initialize #f accessors generate)
  (slot protected marks                  initialize '())
  (slot protected previous-position      initialize #f)
  (slot protected autoscroll-pulse       initialize #f)
  (slot protected mouse-copy-selection   initialize #f)
  (slot protected mouse-copy-destination initialize #f)
  (slot protected highlights             initialize '() getter generate)
  (slot protected text-actions           initialize #f)
  (slot protected text-listeners         initialize '())
  
  
  (form
    (<install> background: {Color Text-Background}))

  
  (method override (verify-reload));;abstract
  (method override (current-history-item));;abstract
  
  
  (method protected virtual (preferences)
    (new Text-Preferences))
  
  
  (method override (new-model)
    (new Text-Model))
  
  
  (method override (setup-model mdl)
    (nextmethod mdl)
    (when syntax
      (set-model~ syntax mdl))
    (let ((pref (preferences)))
      (when pref
        (let ((base (or (get-base-format~ model) (get-base-format~ pref))))
          (add-format 'Base base)
          (set-default-format~ model (intern-format~ model (or (get-default-format~ pref) (new Format base: 'Base)))))
        (let ((base (or (get-base-style~ model) (get-base-style~ pref))))
          (add-style 'Base base)
          (set-default-style~ model (intern-style~ model (or (get-default-style~ pref) (new Text-Style base: 'Base)))))
        (register-children~ (child~ pref 'styles) (get-styles~ model))
        (register-children~ (child~ pref 'formats) (get-formats~ model)))))
  
  
  (method override (prepare rest)
    (set! selection (new Text-Mark self (empty-selection) strict?: #f change-proc: selection-change))
    (set! selection-anchor (new Text-Mark self (empty-selection) strict?: #f))
    (nextmethod rest))
  
  
  (method override (install rest)
    (nextmethod rest)
    (set! syntax (new-syntax))
    (set-syntax~ model syntax)
    (let ((pref (preferences)))
      (when pref
        (let ((background (get-background~ pref)))
          (when background
            (set-background (symbolic-color background))))
        (set! caret-pulse? (get-pulse-caret?~ pref)))))
  
  
  (method override (install-child form creator creator-branch restore-form)
    (case (get-model~ form)
      ;; until Form <-> Node unification
      ((text) (set-text~ model (form->node form)))
      (else (nextmethod form creator creator-branch restore-form))))
  
  
  (method override (destroy)
    (show-text-cursor)
    (nextmethod))
  
  
  (method protected virtual (new-syntax) <Text-Syntax>
    (new Text-Syntax model))
  
  
  (method override (get-text-view) <Text-View>
    self)
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method protected (get-paragraphs) <Axis>
    (get-paragraphs~ model))
  
  
  (method protected (set-paragraphs lst)
    (set-paragraphs~ model lst))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method override (host-workspaces)
    '(text))
  
  
  (method override (install-in-host host)
    (nextmethod host)
    (install-in-host~ (get-controller) host))
  
  
  (method override (split-view)
    (let ((host (new-frame (class-of self) host-visible?: #f)))
      (let ((view (get-guest~ host)))
        (set-model~ view model)
        (change-moniker~ (get-controller~ view) (get-moniker))
        (scroll-to~ view (get-scrolled-position))
        (set-selection~ view (get-selection) ensure-displayed?: #f)
        (update-status~ view)
        (focus-host~ host)
        host)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions)
    (cons (find-actions 'text)
          (nextmethod)))
  
  
  ;;;
  ;;;; Controller
  ;;;
  
  
  (method override (get-controller)
    (unless controller
      (set! controller (new-controller)))
    controller)
  
  
  (method override (new-controller)
    (new Document-Controller self tool?: (default-tool?) console?: (default-console?)))
  
  
  (method protected virtual (default-tool?)
    #f)
  
  
  (method protected virtual (default-console?)
    #f)
  
  
  (method override (save)
    (save~ (get-controller)))
  
  
  (method override (save-as)
    (save-as~ (get-controller)))
  
  
  (method public virtual (save-all)
    (save-all~ (get-controller)))
  
  
  (method public (get-moniker)
    (get-moniker~ (get-controller)))
  
  
  (method public (set-moniker moniker)
    (set-moniker~ (get-controller) moniker))
  
  
  (method override (get-modified?)
    (get-modified?~ (get-controller)))
  
  
  (method override (set-modified? state)
    (set-modified?~ (get-controller) state))
  
  
  (method (get-read-only?)
    (get-read-only?~ (get-controller)))
  
  
  (method (write-allowed?)
    (and editable? (write-allowed?~ (get-controller))))
  
  
  (method (update-status)
    (update-status~ (get-controller)))
  
  
  (method (update-moniker-time moniker)
    (update-moniker-time~ (get-controller) moniker))
  
  
  (method override (confirm-close . rest)
    (when (last-client?)
      (confirm-close~ (get-controller))))
  
  
  (method override (tool-update tool?)
    )
  
  
  (method override (console-update console?)
    )

  
  (method override (revert-saved)
    (revert-saved~ (get-controller)))

  
  (method override (compare-saved)
    (compare-saved~ (get-controller)))
  
  
  (method override (install-scroller?)
    #t)
  
  
  ;;;
  ;;;; Input/Output
  ;;;
  
  
  (method public (get-string-content) <string>
    (get-string-content~ model))
  
  
  (method public (set-string-content content <string>) <void>
    (set-string-content~ model content))
  
  
  (method override (default-extension)
    (default-extension~ syntax))
  
  
  (method override (extensions)
    (extensions~ syntax))
  
  
  (method override (load-content moniker)
    (load-content~ model moniker))
  
  
  (method override (save-content moniker)
    (save-content~ model moniker))
  
  
  (method override (save-to moniker)
    (save-to~ model moniker))
  
  
  (method override (reload-moniker moniker)
    (let ((line (get-line~ (get-start))))
      (reload-moniker~ model moniker)
      (set-caret (new Cell (min line (cardinality (get-paragraphs))) 0))
      (set-modified?~ model #f)))
  
  
  (method override (compare-moniker moniker)
    (compare-moniker~ model moniker))
  
  
  ;;;
  ;;;; Explorer
  ;;;
  
  
  (method public virtual (explorer-class)
    (explorer-class~ syntax))
  
  
  (method (on-select-outer evt)
    (select-outer))
  
  
  (method protected virtual (select-outer)
    (end-completion)
    (let ((expl <Text-Explorer> (new (explorer-class) model range: (get-selection))))
      (with-safe-explore
        (lambda ()
          (when (outer-expr~ expl)
            (reset-mode)
            (set-selection (get-range~ expl)))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method override (focus-gained)
    (nextmethod)
    (show-text-cursor)
    (update-caret)
    (when focus-selects-all?
      (select-all))
    (when (has-selection?)
      (invalidate-selection (get-selection)))
    (invalidate-non-showed-highlights))
  
  
  (method override (focus-lose)
    (nextmethod)
    (show-text-cursor)
    (end-completion)
    (hide-caret))
  
  
  (method override (focus-lost)
    (nextmethod)
    (when (has-selection?)
      (invalidate-selection (get-selection)))
    (invalidate-non-showed-highlights))
  
  
  (method override (focus-activate)
    (focus-document))
  
  
  (method override (focus-document)
    (acquire-focus))
  
  
  (method override (mouse-leave)
    (show-text-cursor))
  
  
  (method override (on-backspace-press evt)
    (backspace-press #f word?: (get-property~ evt word?:)))
  
  
  (method (on-delete-press evt)
    (delete-press #f word?: (get-property~ evt word?:)))
  
  
  (method (on-paragraph-style evt)
    (set-selection-format/style (get-property~ evt style:) style?: #t))
  
  
  (method (on-numbered evt)
    (unimplemented 'on-numbered))
  
  
  (method (on-bulleted evt)
    (for-each-selected-paragraph
      (lambda (line paragraph)
        (toggle-bulleted~ model line))))
  
  
  (method (on-decrease-indent evt)
    (for-each-selected-paragraph
      (lambda (line paragraph)
        (indent-paragraph~ model line paragraph -32))))
  
  
  (method (on-increase-indent evt)
    (for-each-selected-paragraph
      (lambda (line paragraph)
        (indent-paragraph~ model line paragraph 32))))
  
  
  (method (on-justify evt)
    (let ((justification (get-property~ evt justification:)))
      (for-each-selected-paragraph
        (lambda (line paragraph)
          (set-justification~ model line paragraph justification)))))
  
  
  (method (on-alignment evt)
    (let ((alignment (get-property~ evt alignment:)))
      (set-text-alignment~ model (get-selection) alignment)))
  
  
  (method (on-text-style evt)
    (bell))
  
  
  (method (on-text-font evt)
    (let* ((caret (get-caret))
           (par (get-paragraph (get-line~ caret)))
           (run (get-run~ par (get-col~ caret)))
           (current (and run (get-font~ (get-style~ run))))
           (font (choose-font initial-font: current)))
      (close-popups)
      (set-text-font~ model (get-selection) font)))
  
  
  (method (on-text-color evt)
    (let ((color (get-property~ evt color:))
          (combo (popup-initiator~ (get-sender~ evt))))
      (close-popups)
      (when combo
        (set-color~ (get-body~ combo) (or color {Color Black})))
      (set-text-color~ model (get-selection) color)))
  
  
  (method (on-pick-text-color evt)
    (pick-text-color (get-sender~ evt)))
  
  
  (method (on-highlight-color evt)
    (let ((color (get-property~ evt color:))
          (combo (popup-initiator~ (get-sender~ evt))))
      (close-popups)
      (when combo
        (set-color~ (get-body~ combo) (or color {Color White})))
      (set-highlight-color~ model (get-selection) color)))
  
  
  (method (on-pick-highlight-color evt)
    (pick-highlight-color (get-sender~ evt)))
  
  
  (method (on-frame-color evt)
    (let ((color (get-property~ evt color:))
          (combo (popup-initiator~ (get-sender~ evt))))
      (close-popups)
      (when combo
        (set-color~ (get-body~ combo) (or color {Color White})))
      (set-frame-color~ model (get-selection) color)))
  
  
  (method (on-pick-frame-color evt)
    (pick-frame-color (get-sender~ evt)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-text-listener listener)
    (set! text-listeners (add-listener listener text-listeners)))
  
  
  (method public (remove-text-listener listener)
    (set! text-listeners (remove-listener listener text-listeners)))
  
  
  (method public (text-listener? object)
    (listener? object text-listeners))
  
  
  (method public (process-selection-change)
    (when text-listeners
      (let ((evt (new Text-Event :selection-change self)))
        (for-each (lambda (listener)
                    (invoke~ listener self evt))
                  text-listeners))))
  
  
  ;;;
  ;;;; Model
  ;;;
  
  
  (method protected (model-update)
    (remove-all-text-actions))
  
  
  (method protected (last-client?)
    (= (length (get-clients~ model)) 1))
  
  
  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method override (key-press key)
    (hide-text-cursor)
    (char-press (translate-key~ syntax key)))

  
  (method override (backspace-press key (word?: word? #f))
    (insert-char/backspace #\backspace word?: word?)
    (when completion-active?
      (complete-at (get-start))))
  
  
  (method (delete-press key (word?: word? #f))
    (delete-action word?))
  
  
  (method (on-delete-char evt)
    (delete-char))
  
  
  (method (on-delete-word evt)
    (delete-word))
  
  
  (method (on-kill-line evt)
    (define (kill-range)
      (let* ((pos (selection-tail 'forward))
             (line (get-line~ pos))
             (col (get-col~ pos))
             (len (paragraph-length line)))
        (if (= col len)
            (if (= line (get-limit))
                #f
              (new Range$Cell$ pos (new Cell (+ line 1) 0)))
          (new Range$Cell$ pos (new Cell line len)))))
    
    (let ((range (kill-range)))
      (when range
        (let ((string (get-string range)))
          (define (replace-clipboard)
            (add-clipboard~ (get-application))
            (set-clipboard-text string)
            (set! special-mode 'kill-line))
          
          (define (append-clipboard actual)
            (set-clipboard-text (string-append actual string)))
      
          (if (neq? special-mode 'kill-line)
              (replace-clipboard)
            (let ((actual (get-clipboard-text)))
              (if (not actual)
                  (replace-clipboard)
                (append-clipboard actual))))
          (delete-range~ model range)))))
  
  
  (method (on-open-line evt)
    (insert-newline)
    (left-arrow-move #f #f))
  
  
  (method override (return-press key)
    (when accepts-returns?
      (insert-newline)))


  (method override (escape-press key)
    (remove-completion))
  
  
  (method override (tab-press key modifiers)
    (cond ((has-completion?)
           (end-completion))
          ((or (not accepts-returns?) force-tab-navigate?)
           (navigate-view (shift-key? modifiers)))
          (else
           (insert-char #\tab))))
  
  
  (method public virtual (char-press key)
    (parameterize ((keyboard-input? #t))
      (if (auto-complete?)
          (auto-complete key)
        (insert-char key))))
  
  
  (method (reset-mode (keep: keep #f))
    (set! special-mode #f)
    (unless (eq? keep 'virtual)
      (set! virtual-h #f)))
  
  
  (method package (on-insert evt)
    (let ((kind (get-kind~ evt))
          (content (get-property~ evt content:)))
      (case kind
        ((:key :char) (call-key-press content))
        ((:string) (insert-string content)))))
  
  
  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (hide-text-cursor)
    (when (and (view-enabled?) selectable? editable? (mouse-over?))
      (hide-cursor)))
  
  
  (method public (show-text-cursor)
    (when (and (view-enabled?) selectable? editable?)
      (show-cursor)))
  
  
  (method override (cursor-update view <Point>)
    (show-text-cursor)
    (when (and (view-enabled?) selectable?)
      (if (alt-down?)
          (set-cursor :finger)
        (let ((par (get-paragraph (get-line~ (view->text view)))))
          (if (< (get-h~ view) (paragraph-left~ par))
              (set-cursor :left-arrow)
            (set-cursor :ibeam))))))
  
  
  ;;;
  ;;;; Caret
  ;;;
  
  
  (method (show-caret)
    (define (pulse-caret)
      (when editable?
        (set! caret-visible? (not caret-visible?))
        (invalidate-caret)))
    
    (when (and editable? (not caret-visible?) (has-focus?))
      (set! caret-visible? #t)
      (when (and caret-pulse? (not caret-pulse))
        (set! caret-pulse (new Pulse 'caret 0.5 pulse-caret)))
      (invalidate-caret)))
  
  
  (method (hide-caret)
    (when editable?
      (when caret-pulse
        (close~ caret-pulse))
      (set! caret-visible? #f)
      (set! caret-pulse #f)
      (invalidate-caret)))
  
  
  (method (without-caret proc)
    (if (not editable?)
        (proc)
      (let ((shown? caret-visible?))
        (unwind-protect
            (begin
              (hide-caret)
              (proc))
          (when shown?
            (update-caret))))))
  
  
  (method (update-caret)
    (when (and player editable? (has-focus?))
      (if (has-selection?)
          (hide-caret)
        (show-caret))))
  
  
  (method (invalidate-caret)
    (when editable?
      (let ((rect (caret-rect (get-caret) 1)))
        (when rect
          (invalidate-rect rect)))))
  
  
  (method (caret-rect caret-pos <Cell+> width)
    (when caret-pos
      (let* ((pos <Point> (text->view caret-pos))
             (par <Paragraph> (get-paragraph (get-line~ caret-pos)))
             (lne (get-line-at~ par (get-col~ caret-pos)))
             (run (get-run~ par (get-col~ caret-pos)))
             (height <fx> (if run (get-height~ run) (get-height~ par)))
             (line-height <fx> (get-height~ lne))
             (top <fx> (+ (get-v~ pos)
                          (if run
                              (justify-element~ (get-style~ run) height line-height)
                            (- line-height height)))))
        (new Rect (get-h~ pos) top (+ (get-h~ pos) width) (+ top height)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-down view)
    (when (and (view-enabled?) selectable?)
      (let ((focus? (has-focus?))
            (mouse-copy? (alt-down?))
            (pos (view->text view)))
        (end-completion)
        (unless mouse-copy?
          (acquire-focus))
        (when pos
          (acquire-capture)
          (unlock-anchor)
          (set! mouse-selecting? #t)
          (set! selection-mode 'char)
          (unless (or (shift-down?) (not focus?))
            (reset-caret pos))
          (let ((par (get-paragraph (get-line~ pos))))
            (if (< (get-h~ view) (paragraph-left~ par))
                (set-selection (selection-line (get-line~ pos)) set-anchor?: #t)
              (when (or focus? (not focus-selects-all?))
                (if (shift-down?)
                    (change-selection pos)
                  (set-caret pos))
                (update-caret)))
            (reset-mode)
            (set! previous-position pos))))))

  
  (method override (mouse-copy pos destination)
    (set! mouse-copy-selection (get-selection))
    (set! mouse-copy-destination destination)
    (call-mouse-down pos)
    #t)
  
  
  (method override (drag-move view)
    (when mouse-selecting?
      (drag-move-action view)))
  
  
  (method (drag-move-action view)
    (drag-select view #f)
    (when (get-scroller)
      (setup-autoscroll (calculate-autoscroll-amount view))))
  
  
  (method override (drag-up view . rest)
    (when mouse-selecting?
      (let ((alt?     (alt-down?))
            (control? (control-down?))
            (shift?   (shift-down?))
            (appl     (get-application)))
        (release-capture)
        (kill-autoscroll)
        (drag-select view #t)
        (set! mouse-selecting? #f)
        (set! previous-position #f)
        (update-caret)
        (set! selection-mode 'char)
        (process-selection-change)
        @cant-replace-a-selection-by-pasting!
        (mouse-select-copy
          (lambda ()
            (get-selected-string)))
        (if mouse-copy-selection
            (let ((range (if (has-selection?) (get-selection) (expr-range (get-start)))))
              (when range
                (let ((copy (get-string range)))
                  (set-selection mouse-copy-selection ensure-displayed?: #f)
                  (mouse-insert~ mouse-copy-destination copy))))
          (ensure-displayed))
        (set! mouse-copy-selection #f)
        (set! mouse-copy-destination #f)
        (when (and (not alt?) control? (not shift?))
          (let ((recorder (get-recorder~ appl)))
            (when recorder
              (play-current-recording~ recorder))))
        (update-focus-actions~ appl))))
  
  
  (method (drag-select view final?)
    (let ((pos (view->text view)))
      ;; patch to manage the line selection border
      (when (and pos
                 (< (get-h~ view) (paragraph-left~ (get-paragraph (get-line~ pos))))
                 (cell>=? pos (get-end-anchor)))
        (set! pos (get-end~ (selection-line (get-line~ pos)))))
      (when (and pos #t @parameterized-fix-me (/= pos previous-position))
        (let* ((range (selection-range pos))
               (parts (range-difference range (get-selection)))
               (player (get-player))
               (root (get-root)))
          (receive (dh dv sc) (get-delta~ root self)
            (change-selection pos)
            (with ((region (multi-part-region parts dh dv sc)))
              (when region
                (if final?
                    (invalidate-region~ player region)
                  (redraw-window~ player region: region)
                  (set! previous-position pos)))))))))
  
  
  (method override (double-click view)
    (if (and (view-enabled?) selectable?)
        (let* ((pos (view->text view))
               (par (get-paragraph (get-line~ pos))))
          (if (< (get-h~ view) (paragraph-left~ par))
              (select-paragraph (get-line~ pos))
            (let ((expl <Text-Explorer> (new (explorer-class) model start: pos end: pos)))
              (with-safe-explore
                (lambda ()
                  (when (outer-expr~ expl)
                    (set-selection (get-range~ expl) set-anchor?: #t ensure-displayed?: #f))
                  (set! mouse-selecting? #t)
                  (set! selection-mode 'word)
                  (reset-mode)
                  (set! previous-position pos))))))
      (call-mouse-down view)))
  
  
  (method override (middle-mouse-down pos)
    (unless (middle-mouse-paste
              (lambda (text)
                (paste-clipboard-string text)))
      (mouse-down pos)))
  
  
  (method protected (context-menu-click pos (move-caret: move-caret #f))
    (when (and (view-enabled?) selectable?)
      (acquire-focus)
      (let ((text (view->text pos)))
        (when (and (neq? move-caret 'never)
                   (or (eq? move-caret 'always) (< text (get-start)) (>= text (get-end))))
          (set-caret (view->text pos))
          (update-caret)))))
  
  
  (method override (right-mouse-down pos)
    (context-menu-click pos))
  
  
  (method override (context-menu pos)
    (when (and (view-enabled?) selectable?)
      (let ((menu (get-context-menu)))
        (when menu
          (track-popup-menu menu pos)))))
  
  
  (method override (get-context-menu)
    (text-menu~ (get-application) self))
  
  
  (method public (new-text-context-menu)
    (let ((menu (new Text-Context-Menu)))
      (when (not editable?)
        (set-visible?~ (locate~ menu 'cut) #f)
        (set-visible?~ (locate~ menu 'paste) #f))
      (layout-menu~ menu)
      menu))
  
  
  (method public inline (new-range start end)
    (new Range$Cell$ start end))
  
  
  (method (select-paragraph line)
    (let ((limit (get-limit)))
      (when (<= line limit)
        (let* ((par (get-paragraph line))
               (len (get-length~ par)))
          (set-selection (new Range$Cell$ (new Cell line 0) (new Cell line len)))))))
  
  
  (method (selection-line line <fx>)
    (let ((limit (get-limit)))
      (when (<= line limit)
        (if (= line limit)
            (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length line)))
          (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method (selection-range pos)
    (let ((anchor (get-selection-anchor)))
      (define (selection-range-from-anchor)
        (cond ((before?~ anchor pos)
               (new Range$Cell$ pos (get-end~ anchor)))
              ((after?~ anchor pos)
               (new Range$Cell$ (get-start~ anchor) pos))
              ;; else pos is inside anchor
              (else
               anchor)))
      
      (case selection-mode
        ((char)
         (selection-range-from-anchor))
        ((word)
         (if (inside?~ anchor pos)
             (selection-range-from-anchor)
           (let* ((expl <Text-Explorer> (new (explorer-class) model start: pos end: pos))
                  (kind (outer-expr~ expl explore-whitespace?: #f))
                  (range (and kind (get-range~ expl))))
             (cond ((not range)
                    (selection-range-from-anchor))
                   ((before?~ anchor pos)
                    (new Range$Cell$ (get-start~ range) (maximum (list (get-end~ range) (get-end~ anchor)))))
                   ;; else pos is after anchor
                   (else
                    (new Range$Cell$ (minimum (list (get-start~ range) (get-start~ anchor))) (get-end~ range)))))))
        (else (selection-range-from-anchor)))))
  
  
  (definition (range-difference x <Range$Cell$> y <Range$Cell$>)
    (let ((sx (get-start~ x))
          (ex (get-end~ x))
          (sy (get-start~ y))
          (ey (get-end~ y)))
      (if (and (= sx sy) (= ex ey))
          '()
        (cond ((= sx ex) (list y))
              ((= sy ey) (list x))
              ((or (< ex sy) (> sx ey))
               (list x y))
              (else
               (let ((parts (new List-Factory)))
                 (cond ((< sx sy) (put~ parts (new Range$Cell$ sx sy)))
                       ((> sx sy) (put~ parts (new Range$Cell$ sy sx))))
                 (cond ((< ex ey) (put~ parts (new Range$Cell$ ex ey)))
                       ((> ex ey) (put~ parts (new Range$Cell$ ey ex))))
                 (get-output~ parts)))))))
  
  
  (method (multi-part-region parts dh dv sc)
    (case (length parts)
      ((0) #f)
      ((1) (range-region (car parts) dh dv sc))
      ((2) (with ((region (range-region (first parts) dh dv sc)))
             (let ((union (range-region (second parts) dh dv sc)))
               (when (and region union)
                 (combine!~ union region 'or)
                 union))))))
  
  
  (method (calculate-autoscroll-amount view)
    (let* ((display (view->display view))
           (size (get-display-size))
           (h (get-h~ display))
           (v (get-v~ display))
           (height (get-default-height))
           (ah (cond ((< h 0) 8) ((> h (get-width~ size)) -8) (else 0)))
           (av (cond ((< v 0) height) ((> v (get-height~ size)) (- height)) (else 0))))
      (new Point ah av)))
  
  
  (method (setup-autoscroll amount)
    (define (autoscroll-action)
      (drag-move-action (mouse-position))
      (scroll amount)
      (update-view))
    
    (if (nu=? amount {Point 0 0})
        (kill-autoscroll)
      (when (not autoscroll-pulse)
        (set! autoscroll-pulse (new Pulse 'autoscroll 0.01 autoscroll-action delay: 0)))))
  
  
  (method (kill-autoscroll)
    (close~ autoscroll-pulse)
    (set! autoscroll-pulse #f))
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method protected virtual (home-column line col)
    (let ((column (get-column line)))
      (if (= col 0)
          column
        0)))
  
  
  (method package (on-home evt)
    (goto-home (get-property~ evt document?:)
               (or locked-anchor? (get-property~ evt extend?:))))
  
  
  (method public (goto-home document? extend?)
    (reset-mode)
    (if document?
        (if extend?
            (change-selection (text-beginning))
          (set-caret (text-beginning)))
      (let* ((pos (selection-tail 'backward))
             (line (get-line~ pos))
             (col (home-column line (get-col~ pos)))
             (start (new Cell line col)))
        (if extend?
            (change-selection start)
          (set-caret start))
        (ensure-scrolled-left)))
    (process-selection-change))
  
  
  (method package (on-end evt)
    (goto-end (get-property~ evt document?:)
              (or locked-anchor? (get-property~ evt extend?:))))
  
  
  (method public (goto-end document? extend?)
    (reset-mode)
    (if document?
        (if extend?
            (change-selection (text-ending))
          (set-caret (text-ending)))
      (goto-paragraph-end extend-selection?: extend?))
    (process-selection-change))
  
  
  (method public (goto-paragraph-end (extend-selection?: extend-selection? #f))
    (let* ((pos (selection-tail 'forward))
           (end (new Cell (get-line~ pos) (paragraph-length (get-line~ pos)))))
      (if extend-selection?
          (change-selection end)
        (set-caret end))))
    
  
  (method (on-move evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (arrow-move evt)))


  (method public (arrow-move evt)
    (let ((direction (get-property~ evt direction:))
          (extend? (or locked-anchor? (get-property~ evt extend?:)))
          (word? (get-property~ evt word?:))
          (scroll? (get-property~ evt scroll?:)))
      (case direction
        ((left) (left-arrow-move extend? word?))
        ((right) (right-arrow-move extend? word?))
        ((up) (up-arrow-move extend? scroll?))
        ((down) (down-arrow-move extend? scroll?)))))
  
  
  (method protected virtual (left-arrow-move extend? word?)
    (reset-mode)
    (if extend?
        (change-selection (move-backward (selection-tail 'backward) word?))
      (if (empty-selection?)
          (set-caret (move-backward (selection-tail 'backward) word?))
        (set-caret (get-start))))
    (process-selection-change))
  
  
  (method protected virtual (right-arrow-move extend? word?)
    (reset-mode)
    (if extend?
        (change-selection (move-forward (selection-tail 'forward) word?))
      (if (empty-selection?)
          (set-caret (move-forward (selection-tail 'forward) word?))
        (set-caret (get-end))))
    (process-selection-change))
  
  
  (method protected virtual (up-arrow-move extend? scroll?)
    (reset-mode-on-anchor)
    (let* ((pos (if extend? (selection-tail 'backward) (get-start)))
           (line (get-line~ pos))
           (col (get-col~ pos)))
      (cond (scroll?
              (let ((height (get-default-height)))
                (scroll (new Point 0 height))))
            (else
             (if (> line 0)
                 (move-verticaly line col -1 'backward extend?)
               (unless extend? (reset-caret (get-start))))
             (process-selection-change)))))
  
  
  (method protected virtual (down-arrow-move extend? scroll?)
    (reset-mode-on-anchor)
    (let* ((pos (if extend? (selection-tail 'forward) (get-end)))
           (line (get-line~ pos))
           (col (get-col~ pos)))
      (cond (scroll?
              (let ((height (get-default-height)))
                (scroll (new Point 0 (- height)))))
            (else
             (if (< line (get-limit))
                 (move-verticaly line col 1 'forward extend?)
               (unless extend? (reset-caret (get-end))))
             (process-selection-change)))))
  
  
  (method (on-widen-forward evt)
    (let ((start (get-start))
          (end (get-end)))
      (let ((extend (next-word~ model end)))
        (set-selection (new Range$Cell$ start extend)))))
  
  
  (method (reset-mode-on-anchor)
    (if (and (has-selection?) (nu=? (get-start) (get-start-anchor)) (nu=? (get-end) (get-end-anchor)))
        (reset-mode)
      (reset-mode keep: 'virtual)))
  
  
  (method (move-verticaly line col inc direction shift?)
    (let* ((par     (get-paragraph line))
           (h       (get-h~ (text->view (new Cell line (if (has-selection?) (get-col~ (selection-tail 'forward)) col)))))
           (new-line (+ line inc))
           (new-par (get-paragraph new-line))
           (new-len (paragraph-length new-line))
           (new-end (get-h~ (text->view (new Cell new-line new-len)))))
      (cond (virtual-h
             (move-caret (new Cell new-line (min (get-col~ (view->text (new Point virtual-h (get-top~ new-par)))) new-len)) direction shift?))
            ((> h new-end)
             (set! virtual-h h)
             (move-caret (new Cell new-line new-len) direction shift?))
            (else
             (move-caret (new Cell new-line (get-col~ (view->text (new Point h (get-top~ new-par))))) direction shift?)))))
  
  
  (method protected virtual (move-caret pos direction shift?)
    (unless (cell-displayed? pos)
      (let ((height (get-default-height)))
        (scroll (new Point 0 (case direction ((forward) (- height)) ((backward) height))))))
    (if shift?
        (change-selection pos)
      (set-caret pos)))
  
  
  (method (on-backward-compound evt)
    (let ((extend? (get-property~ evt extend?:)))
      (backward-compound extend?: extend?)))
  
  
  (method (on-forward-compound evt)
    (let ((extend? (get-property~ evt extend?:)))
      (forward-compound extend?: extend?)))
  
  
  (method (on-upward-compound evt)
    (upward-compound))
  
  
  (method (on-downward-compound evt)
    (downward-compound))
  
  
  (method protected virtual (backward-compound (extend?: extend? #f))
    (left-arrow-move extend? #t))
  
  
  (method protected virtual (forward-compound (extend?: extend? #f))
    (right-arrow-move extend? #t))
  
  
  (method protected virtual (upward-compound)
    (up-arrow-move #f #t))
  
  
  (method protected virtual (downward-compound)
    (down-arrow-move #f #t))

  
  (method (on-transpose-word evt)
    (transpose-word))
  
  
  (method public (transpose-movements forward backward)
    (if (has-selection?)
        (bell)
      (with-atomic-undo~ (get-undoer~ model)
        (lambda ()
          (let ((left-expl <Text-Explorer> (new (explorer-class) model))
                (right-expl <Text-Explorer> (new (explorer-class) model)))
            (set-pos~ left-expl (get-start))
            (backward left-expl)
            (set-pos~ right-expl (get-end))
            (forward right-expl)
            (let ((left (get-range~ left-expl))
                  (right (get-range~ right-expl)))
              (if (or (not left) (not right))
                  (bell)
                (let ((ls (range-strings left))
                      (rs (range-strings right)))
                  (replace~ model right ls)
                  (replace~ model left rs)))))
          (set-modified? #t)))))
  
  
  (method public (transpose-word)
    (transpose-movements
      (lambda (expl) (forward-non-word~ expl) (set-start~ expl (get-end~ expl)) (forward-word~ expl))
      (lambda (expl) (backward-non-word~ expl) (set-end~ expl (get-start~ expl)) (backward-word~ expl))))

  
  (method override (prior-page shift?)
    (let* ((start (get-start))
           (v (line->display-v (get-line~ start))))
      (scroll (new Point 0 (get-page-size 'vert)))
      (let* ((line (display-v->row v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection dest)
          (set-caret dest)))))
  
  
  (method override (next-page shift?)
    (let* ((start (get-start))
           (v (line->display-v (get-line~ start))))
      (scroll (new Point 0 (- (get-page-size 'vert))))
      (let* ((line (display-v->row v))
             (dest (new Cell line 0)))
        (if shift?
            (change-selection dest)
          (set-caret dest)))))
  
  
  (method (line->display-v line) <fx>
    (let ((top (- (get-v~ position)))
          (v (line->view line)))
      (- v top)))
  
  
  (method (display-v->row v) <fx>
    (let* ((top (- (get-v~ position)))
           (pos (new Point left-padding (+ top v)))
           (text (view->text pos)))
      (get-line~ text)))
  
  
  (method (selection-tail direction) <Cell>
    (let ((anchor (get-selection-anchor)))
      (cond ((after?~ anchor  (get-end))
             (get-end))
            ((before?~ anchor (get-start))
             (get-start))
            ;; else the selection is the same as the selection-anchor
            (else
             (case direction
               ((backward) (get-start))
               ((forward)  (get-end)))))))
  
  
  (method package (on-remove-spaces evt)
    (if (not (empty-selection?))
        (bell)
      (remove-spaces (get-caret) keep: (get-property~ evt keep:))))
  
  
  (method public (remove-spaces pos (keep: keep 'one/none))
    (let ((expl <Text-Explorer> (new (explorer-class) model start: pos end: pos)))
      (backward-whitespaces~ expl)
      (forward-whitespaces~ expl)
      (let* ((range (get-range~ expl))
             (one-left? (and (= (get-line~ (get-start~ range)) (get-line~ (get-end~ range))) (= (+ (get-col~ (get-start~ range)) 1) (get-col~ (get-end~ range))))))
        (replace~ model (get-range~ expl)
          (case keep
            ((none) (list ""))
            ((one) (list " "))
            ((one/none) (if one-left? (list "") (list " "))))))))
  
  
  (method package (on-display-info evt)
    (user-message (info-message)))
  
  
  (method protected virtual (info-message)
    (let ((start (get-start))
          (end (get-end)))
      (format "Start: line {a} col {a}, End: line {a} col {a}"
              (+ (get-line~ start) 1) (+ (get-col~ start) 1)
              (+ (get-line~ end) 1) (+ (get-col~ end) 1))))
  
  
  (method package (on-user-code evt)
    (let* ((appl (get-application))
           (profile (get-profile~ appl)))
      (text-macro~ profile self)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method (range-region range <Range$Cell$> dh dv sc (top: top #f) (bottom: bottom #f))
    (let ((root (get-root))
          (region (new Region)))
      (keep-rectangles~ region)
      (for-each-logical-range range
        (lambda (line paragraph start end)
          (with ((sub (range-region~ paragraph left-padding start end dh dv sc)))
            (combine!~ region sub 'or))))
      (let ((root-clipper (get-root-clipper)))
        (when root-clipper
          (with ((clipper (new Region root-clipper)))
            (combine!~ region clipper 'and))))
      region))
  
  
  (method (line-range-rect line start end)
    (let ((paragraph (get-paragraph line)))
      (new Rect
        (get-h~ (col->view~ paragraph start))
        (line->view line)
        (if end (get-h~ (col->view~ paragraph (max 1 end))) (get-width))
        (+ (line->view line) (if end (get-height~ (get-line-at~ paragraph end)) (get-default-height))))))
  
  
  (method (block-rect start end)
    (new Rect
      left-padding
      (line->view start)
      (get-width)
      (line->view end)))
  
  
  (method public (invalidate-line line)
    (invalidate-rect (line-range-rect line 0 #f)))
  
  
  (method (invalidate-range range <Range$Cell$>)
    (when (view-visible?)
      (let ((root (get-root)))
        (receive (dh dv sc) (get-delta~ root self)
          (with ((region (range-region range dh dv sc)))
            (invalidate-region~ player region))))))
  
  
  ;; this should be unified with selection-region
  (method (text-selection-region dh dv sc top bottom)
    (range-region (get-selection) dh dv sc top: top bottom: bottom))
  
  
  (method (selection-region-all dh dv sc)
    (text-selection-region dh dv sc 0 (get-display-height)))
  
  
  (method protected virtual (get-selection-color)
    (if completion-active?
        (or (get-completion-color~ (get-look)) {Color red: 128 green: 240 blue: 240})
      (or (get-active-selection-color~ (get-look)) {Color red: 190 green: 190 blue: 230})))
  
  
  (method protected virtual (get-inactive-selection-color)
    (or (get-inactive-selection-color~ (get-look)) {Color Unfocused-Selection}))
  
  
  (method public (for-each-logical-range range <Range$Cell$> proc)
    (let ((start (get-start~ range))
          (end (get-end~ range)))
      (when (/= start end)
        (if (= (get-line~ start) (get-line~ end))
            (let ((line (get-line~ start)))
              (proc line (get-paragraph line) (get-col~ start) (get-col~ end)))
          (let ((beginning (get-line~ start))
                (limit (get-line~ end)))
            (loop (for line from beginning to limit)
                  (let ((paragraph (get-paragraph line)))
                    (cond ((= line beginning) (proc line paragraph (get-col~ start) #f))
                          ((= line limit) (proc line paragraph #f (get-col~ end)))
                          (else (proc line paragraph #f #f))))))))))
  
  
  (method public (for-each-range range <Range$Cell$> proc)
    (for-each-logical-range range
      (lambda (line paragraph start end)
        (proc line
              paragraph
              (or start 0)
              (or end (get-length~ paragraph))))))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method override (can-undo?)
    (can-undo?~ model))
  
  
  (method override (can-redo?)
    (can-redo?~ model))
  
  
  (method override (can-cut?)
    (has-selection?))
  
  
  (method override (can-copy?)
    (has-selection?))
  
  
  (method override (can-paste?)
    #t)
  
  
  (method override (can-delete?)
    (has-selection?))
  
  
  (method override (can-select-all?)
    #t)
  
  
  (method override (undo)
    (undo~ model)
    (update-focus-actions~ (get-application)))
  
  
  (method override (redo)
    (redo~ model)
    (update-focus-actions~ (get-application)))
  
  
  (method override (cut-selection)
    (copy-selection)
    (delete-selection))
  
  
  (method override (copy-selection)
    (if (empty-selection?)
        (bell)
      (add-clipboard~ (get-application))
      (set-clipboard-text (join-lines (selection-lines)))))
  
  
  (method override (paste-clipboard)
    (let ((text (get-clipboard-text)))
      (when text
        (paste-clipboard-string text))))
  
  
  (method public (paste-clipboard-string string)
    (replace-selection (split-lines string)))


  (method package (on-paste&stay evt)
    (paste&stay))


  (method package (on-paste&next evt)
    (paste&stay)
    (down-arrow-move #f #f))
  
  
  (method (paste&stay)
    (let ((pos (get-start)))
      (paste-clipboard)
      (set-caret pos)))
  
  
  (method override (delete-selection)
   (replace-selection (list "")))
  
  
  (method override (select-all . rest)
    (set-selection (buffer-selection)))
  
  
  (method public (clear-all)
    (select-all)
    (delete-selection))
  
  
  ;;;
  ;;;; Mark
  ;;;
  
  
  (method package (on-set-mark evt)
    (set-mark (get-selection))
    (user-message "Marked"))
  
  
  (method package (on-jump-mark evt)
    (when mark
      (if (or locked-anchor? (get-property~ evt extend?:))
          (set-selection (new Range$Cell$
                           (minimum (list (get-start-anchor) (get-start~ mark)))
                           (maximum (list (get-end-anchor) (get-end~ mark)))))
        (let ((new-mark mark))
          (set-mark (get-selection))
          (set-selection new-mark)))))
  
  
  ;;;
  ;;;; Marks
  ;;;
  
  
  (method public (get-marks)
    marks)
  
  
  (method public (add-mark mark)
    (set! marks (cons mark marks)))
  
  
  (method public (remove-mark mark)
    (set! marks (remove! mark marks)))
  
  
  (method protected (adjust-marks range caret)
    (for-each (lambda (mark)
                (adjust~ mark (get-start~ range) (get-end~ range) caret))
              marks))
  
  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (proclaim (warn optimizations))
  
  
  (method override (empty-selection) <Range$Cell$>
    (new Range$Cell$ (text-beginning) (text-beginning)))
  
  
  (method override (reset-selection)
    (set-range~ selection (empty-selection)))
  
  
  (method (buffer-selection) <Range$Cell$>
    (new Range$Cell$ (text-beginning) (text-ending)))
  
  
  (method override (line-selected? line) <bool>
    #f)
  
  
  (method public (text-beginning) <Cell>
    (new Cell 0 0))
  
  
  (method public (text-ending) <Cell>
    (let ((limit (get-limit)))
      (new Cell limit (paragraph-length limit))))
  
  
  (method public (text-range) <Range$Cell$>
    (new Range$Cell$ (text-beginning) (text-ending)))
  
  
  (method public (text-empty?) <bool>
    (= (text-beginning) (text-ending)))
  
  
  (method public inline (get-start) <Cell>
    (get-start~ selection))
  
  
  (method public inline (get-end) <Cell>
    (get-end~ selection))
  
  
  (method inline override (get-selection) <Range$Cell$>
    (get-range~ selection))
  
  
  (method override (set-selection range <Range$Cell$> (ensure-displayed?: ensure-displayed? #t) (set-anchor?: set-anchor? #t))
    (validate-range range)
    (when (and range (/= (cast <Range$Cell$> (get-selection)) range))
      (hide-caret)
      (when set-anchor?
        (set-selection-anchor range))
      (update-selection range)
      (update-caret)
      (when (and ensure-displayed? (not mouse-selecting?))
        (ensure-displayed center?: (eq? ensure-displayed? 'center-caret)))
      (unless (and mouse-down? (eq? (get-mouse-in) self))
        (update-focus-actions~ (get-application)))))
  
  
  (method public (update-selection range <Range$Cell$>)
    (if (not (view-visible?))
        (set-range~ selection range)
      (let ((root (get-root)))
        (receive (dh dv sc) (get-delta~ root self)
          (with ((old (selection-region-all dh dv sc)))
            (set-range~ selection range)
            (with ((new (selection-region-all dh dv sc)))
              (if (and old new)
                  (begin
                    (combine!~ new old 'xor)
                    (invalidate-region~ player new))
                (when old
                  (invalidate-region~ player old))
                (when new
                  (invalidate-region~ player new)))))))))
  
  
  (method public (reset-caret pos <Cell>)
    (set-selection (new Range$Cell$ pos pos)))
  
  
  (method (fit-range range <Range$Cell$>)
    (let* ((ending (text-ending))
           (start (get-start~ range))
           (end (get-end~ range))
           (s (when (> start ending) ending))
           (e (when (> end ending) ending)))
      (when (or s e)
        (new Range$Cell$ (or s start) (or e end)))))
  
  
  (method public (get-selection-anchor)
    (get-range~ selection-anchor))
  
  
  (method public (get-start-anchor)
    (get-start~ selection-anchor))
  
  
  (method public (get-end-anchor)
    (get-end~ selection-anchor))
  
  
  (method public (set-selection-anchor range)
    (set-range~ selection-anchor (copy range)))
  
  
  (method public (lock-anchor)
    (set! locked-anchor? #t))
  
  
  (method public (unlock-anchor)
    (set! locked-anchor? #f))
  
  
  ;; The selection change up to a specified position
  (method public (change-selection pos . rest)
    (bind-keywords ((set-anchor? #f) . others) rest
      (when pos (apply set-selection (selection-range pos) set-anchor?: set-anchor? others))))
  
  
  (method public (get-caret) <Cell>
    (get-start))
  
  
  (method public (set-caret pos)
    (when pos
      ;; lisp tabulate can return negative col
      (let* ((line (min (max 0 (get-line~ pos)) (get-limit)))
             (par (get-paragraph line))
             (col (min (max 0 (get-col~ pos)) (get-length~ par))))
        (if (and (= line (get-line~ pos))
                 (= col (get-col~ pos)))
            (reset-caret pos)
          (reset-caret (new Cell line col))))))
  
  
  (method protected virtual (selection-change)
    )
  
  
  (method public (has-selection?)
    (/= (get-start) (get-end)))
  
  
  (method public (empty-selection?)
    (= (get-start) (get-end)))
  
  
  (method public (at-beginning?)
    (and (= (get-start) (get-end))
         (= (get-start) (text-beginning))))
  
  
  (method public (at-end?)
    (and (= (get-start) (get-end))
         (= (get-start) (text-ending))))
  
  
  (method public (at-line-start?)
    (= (get-col~ (get-start)) 0))
  
  
  (method public (selected-lines)
    (let* ((start (get-start))
           (end (get-end))
           (end-line (if (= (get-col~ end) 0) (- (get-line~ end) 1) (get-line~ end))))
      (naturals (get-line~ start) (+ end-line 1))))
  
  
  (method public (for-each-selected-paragraph proc)
    (let ((selection (get-selection)))
      (for-each-paragraph~ model proc
        start: (get-line~ (get-start~ selection))
        end: (get-line~ (get-end~ selection)))))
  
  
  (method override (invalidate-selection sel)
    (invalidate-range sel))
  
  
  (method override (selection-region sel dh dv sc)
    (range-region self dh dv sc))
  
  
  (method public (get-char pos <Cell>) <char>
    (let ((line (get-line~ pos))
          (col (get-col~ pos)))
      (let ((string (get-string~ (get-paragraph line))))
        (if (< col (cardinality string))
            (element string col)
          #\newline))))
  
  
  (method public (get-string range <Range$Cell$>) <string>
    (join-lines (range-strings range)))
  
  
  (method public (next! pos <Cell>) <bool>
    (cond ((/= (get-col~ pos) (paragraph-length (get-line~ pos)))
           (increase-col~ pos)
           #t)
          ((< (get-line~ pos) (get-limit))
           (increase-line~ pos)
           (set-col~ pos 0)
           #t)
          (else
           #f)))
  
  
  (method public (previous! pos <Cell>) <bool>
    (cond ((/= (get-col~ pos) 0)
           (increase-col~ pos -1)
           #t)
          ((> (get-line~ pos) 0)
           (increase-line~ pos -1)
           (set-col~ pos (paragraph-length (get-line~ pos)))
           #t)
          (else
           #f)))
  
  
  (method public (next-cell pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (when (next! cell)
        cell)))
  
  
  (method public (previous-cell pos <Cell>) <Cell+>
    (let ((cell (copy pos)))
      (when (previous! cell)
        cell)))
  
  
  (method (selection-lines)
    (range-strings (get-selection)))
  
  
  (method public (get-selected-string) <string+>
    (when (has-selection?)
      (get-string (get-selection))))
  
  
  (method public (get-selected-strings)
    (get-range-strings (get-selection)))
  
  
  (method public (get-range-strings range)
    (if (empty?~ range)
        '()
      (range-strings range)))
  
  
  (method public (next-pos pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((next! pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (previous-pos pos <Cell> offset <fx>) <Cell+>
    (let ((pos (copy pos)))
      (let (iterate (offset offset))
        (cond ((<= offset 0)
               pos)
              ((previous! pos)
               (iterate (- offset 1)))
              (else
               #f)))))
  
  
  (method public (get-column line <fx>) <fx>
    (let ((pos (new Cell line 0)))
      (while (memq? (get-char pos) '(#\space #\tab))
        (increase! pos))
      (get-col~ pos)))
  
  
  (method (on-goto-line evt)
    (let* ((start (get-start))
           (line (+ (get-line~ start) 1))
           (string (request-string title: "Goto Line" prefix: "Line no:" initial-value: (->string line))))
      (goto-line (- (parse-integer string) 1))))
  
  
  (method public (goto-line line)
    (cond ((< line 0)
           (set-selection (new Range$Cell$ (new Cell 0 0) (new Cell 1 0))))
          ((>= line (get-limit))
           (let ((line (get-limit)))
             (set-selection (new Range$Cell$ (new Cell line 0) (new Cell line (paragraph-length line))))))
          (else
           (set-selection (new Range$Cell$ (new Cell line 0) (new Cell (+ line 1) 0))))))
  
  
  (method override (added-update-selection line count)
    )
  
  
  (method override (removed-update-selection line count)
    #f)
  
  
  (proclaim (not warn optimizations))
  
  
  (method package (on-lock-anchor evt)
    (lock-anchor)
    (user-message "Anchor locked"))
  
  
  (method package (on-unlock-anchor evt)
    (unlock-anchor)
    (user-message "Anchor unlocked"))
    
  
  (method package (on-toggle-lock-anchor evt)
    (if locked-anchor?
        (on-unlock-anchor evt)
      (on-lock-anchor evt)))
  
  
  ;;;
  ;;;; Text Actions
  ;;;
  
  
  (method public (add-text-action text-action)
    (set! text-actions (cons text-action text-actions)))
  
  
  (method public (run-text-action text-action)
    (when (memq text-action text-actions)
      (text-action)
      (remove! text-action text-actions)))
  
  
  (method public (remove-all-text-actions)
    (set! text-actions '()))
  
  
  ;;;
  ;;;; Highlights
  ;;;
  
  
  (method public (add-highlight highlight)
    (set! highlights (cons highlight highlights)))
  
  
  (method public (remove-highlight highlight)
    (set! highlights (remove! highlight highlights)))
  
  
  (method public (remove-all-highlights)
    (set! highlights '())
    (invalidate-view))
  
  
  (method public (invalidate-highlight highlight)
    (invalidate-range (restrict-range (get-range~ highlight))))
  
  
  (method public (invalidate-non-showed-highlights)
    (for-each (lambda (highlight)
                (when (not (get-show-unfocused?~ highlight))
                  (invalidate-highlight highlight)))
              highlights))

  
  ;;;
  ;;;; Layout
  ;;;
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method override (layout-scrollee-patch)
    (update-displayed))
  
  
  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method override (scrollee-width)
    (let ((width (scrollee-width~ model)))
      (if (and scroller fit-in-scroller?)
          (max (get-display-width) width)
        width)))
  
  
  ;; until we maintain it incrementally
  (method protected virtual (dynamic-scrollee-width?)
    (<= (get-visible-count~ model) 16))
  
  
  (method override (scrollee-content-width)
    (scrollee-content-width~ model))
  
  
  ;;;
  ;;;; Paragraph
  ;;;


  (method public (get-length) <fx>
    (get-length~ model))
  
  
  (method public (get-limit) <fx>
    (get-limit~ model))
  
  
  (method public (get-paragraph line <fx>) <Paragraph>
    (get-paragraph~ model line))
  
  
  (method public (paragraph-string line <fx>) <string>
    (paragraph-string~ model line))
  
  
  (method public (paragraph-length line <fx>) <fx>
    (paragraph-length~ model line))
  
  
  (method (paragraph->string paragraph <Paragraph>) <string>
    (paragraph->string~ model paragraph))
  
  
  (method public (first-paragraph)
    (first-paragraph~ model))
  
  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method override (get-print-area context)
    (get-print-area~ model context))
  
  
  (method override (paginate page-width page-height)
    (let ((selected? #f @tmp (has-selection?)))
      (let ((start (if selected? (get-line~ (get-start)) 0))
            (end (+ (if selected? (get-line~ (get-end)) (get-limit)) 1)))
        (paginate-range~ model start end page-width page-height))))
  
  
  (method override (setup-printing)
    (setup-printing~ model))
  
  
  (method override (restore-printing preserved)
    (restore-printing~ model preserved))
  
  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method protected virtual (draw-enabled?)
    (view-enabled?))
  
  
  (method override (get-drawing-background context)
    (if (not (draw-enabled?))
        {Color Medium}
      (let ((look (get-look)))
        (or (get-background~ look)
            (nextmethod context)))))
  
  
  (method override (draw-children surface nodes context lh lv sh sv sc sc?)
    (define (draw-highlights)
      (let ((focus? (has-focus?))
            (tabs (get-tabs~ model)))
        (for-each (lambda (highlight)
                    (when (or focus? (get-show-unfocused?~ highlight))
                      (let ((range (get-range~ highlight))
                            (style (get-style~ highlight)))
                        (let* ((start (get-start~ range))
                               (end (get-end~ range))
                               (paragraph (get-paragraph (get-line~ start)))
                               (target (subseq (get-string~ paragraph) (get-col~ start) (get-col~ end)))
                               (info (text->view-extended start))
                               (line (car info))
                               (pos (cdr info))
                               (height (get-height~ line))
                               (format (get-format~ paragraph))
                               (left (get-left-margin~ format))
                               (enabled? (draw-enabled?)))
                          (draw-style~ style surface '() target (get-h~ pos) (get-v~ pos) height tabs left enabled?)))))
                  highlights)))
    
    (let ((top #f)
          (bottom #f)
          (printing? (getf context printing?:)))
      (unless printing?
        (draw-selection surface top bottom))
      (nextmethod surface nodes context lh lv sh sv sc sc?)
      (draw-highlights)
      (unless printing?
        (draw-caret surface sc sc?))))
  
  
  (method protected (draw-selection surface top bottom)
    (when (or (has-focus?) show-unfocused-selection?)
      (with ((region (text-selection-region 0.0 0.0 1.0 top bottom)))
        (when region
          (fill-region~ surface region
            (if (has-focus?)
                (get-selection-color)
              (get-inactive-selection-color)))))))
  
  
  (method protected (draw-caret surface sc <fl> sc? <bool>)
    (when (and caret-visible? (empty-selection?) (or (not mouse-down?) (not (alt-down?))))
      (let ((proc
             (lambda (rect)
               (set-color~ surface (or (get-caret-color~ (get-look)) {Color Black}))
               (set-line-width~ surface 1)
               (line~ surface (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-bottom~ rect)))))
        (let ((rect <Rect> (caret-rect (get-caret) 0)))
          (if (not sc?)
              (proc rect)
            ;; this could use some improvements!
            (let ((scaled (new Rect
                            (fxround (if sc? (* (get-left~ rect) sc) (get-left~ rect)))
                            (fxround (if sc? (* (get-top~ rect) sc) (get-top~ rect)))
                            (fxround (if sc? (* (get-right~ rect) sc) (get-right~ rect)))
                            (fxround (if sc? (* (get-bottom~ rect) sc) (get-bottom~ rect))))))
              (proc scaled)))))))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method override (get-look)
    (find-look 'text))
  
  
  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method override (ensure-displayed . rest)
    (let ((selection (get-selection)))
      (when selection
        (apply ensure-range-displayed selection rest))))
  
  
  (method public (ensure-cell-displayed pos <Cell>)
    (let* ((start (text->view pos))
           (end (+ start (new Point 0 (get-height-at pos)))))
      (scroll (scroll-needed start end (get-scroll-context)))))
  
  
  (method public (ensure-range-displayed range <Range$Cell$> . rest)
    (unless (or update-locked? (not player))
      (let* ((start (get-start~ range))
             (end (get-end~ range))
             (end-height (get-height-at end)))
        (scroll (apply scroll-needed (text->view start) (+ (text->view end) (new Point 0 end-height)) (get-scroll-context) rest)))))
  
  
  (method public (ensure-scrolled-left)
    (unless (or update-locked? (not player))
      (when (/= 0 (get-h~ (get-position)))
        (let* ((size (get-display-width))
               (context (cdr (get-scroll-context)))
               (context (if context (fxround (* size context)) 0))
               (tail (+ (get-display-h) size))
               (end (get-h~ (text->view (get-end)))))
          (when (< end (- tail context))
            (scroll (new Point (- tail context end) 0)))))))
  
  
  (method public (cell-displayed? pos)
    (let* ((start (text->view pos))
           (end (+ start (new Point 0 (get-height-at pos)))))
      (= (scroll-needed start end #f) {Point 0 0})))
  
  
  (method (on-center-caret evt)
    (center-caret))
  
  
  (method (on-top-caret evt)
    (top-caret))
  
  
  (method public (center-caret)
    (let* ((start (get-bottom~ (get-row (get-line~ (get-start)))))
           (end (get-top~ (get-row (get-line~ (get-end)))))
           (size (- end start))
           (height (get-display-height))
           (top (if (>= size height)
                    start
                  (let ((half (fxround/ (- height size) 2)))
                    (- start half)))))
      (scroll-to (new Point 0 (- top)))))
  
  
  (method public (center-undisplayed-caret)
    (when (or (not (cell-displayed? (get-start)))
              (not (cell-displayed? (get-end))))
      (center-caret)))
  
  
  (method public (top-caret)
    (let ((start (get-top~ (get-row (get-line~ (get-start))))))
      (scroll-to (new Point 0 (- start)))))
  
  
  ;;;
  ;;;; Constituent
  ;;;
  
  
  (method public virtual (get-constituent-test)
    (get-constituent-test~ syntax))
  
  
  (method public virtual (text-constituent? char)
    (text-constituent?~ syntax char))
  
  
  (method public virtual (get-match-test)
    (get-match-test~ syntax))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method public (move-forward pos word?)
    (move-forward~ model pos word?))
  
  
  (method public (move-backward pos word?)
    (move-backward~ model pos word?))
  
  
  ;;;
  ;;;; Insert
  ;;;
  
  
  (method public (insert-char c)
    (caret-update (insert-char~ model (get-selection) c)))
  
  
  (method public (insert-string str)
    (caret-update (insert-string~ model (get-selection) str)))
  
  
  (method public (insert-styled string style)
    (let ((start (get-start))
          (style (cond ((is? style Style) style) ((not style) (get-default-style~ model)) (else (get-style~ model style)))))
      (insert-string string)
      (set-style~ model (new Range$Cell$ start (get-start)) style)))
  
  
  (method public (replace-styled range strings style)
    (let ((start (get-start~ range))
          (style (cond ((is? style Style) style) ((not style) (get-default-style~ model)) (else (get-style~ model style)))))
      (replace~ model range strings)
      (set-style~ model (new Range$Cell$ start (get-start)) style)))
  
  
  (method public (insert-line line (proper? #t))
    (replace-selection (if proper? (list line "") (list line))))
  
  
  (method public (insert-bulleted-line line)
    (let ((line (get-line~ (get-start))))
      (insert-line line)
      (toggle-bulleted~ model line)))
  
  
  (method public (insert-newline)
    (end-completion)
    (insert-string "\n"))
  
  
  (method public (insert-link string (font: font #f) (anchor: anchor #f) (action: action #f))
    (let* ((font (or font {Font Link}))
           (style (new Link-Style font: font color: {Color Link} anchor: anchor action: action)))
      (insert-styled string style)))
  
  
  (method public (insert-image moniker)
    (let ((style (new Image-Style moniker: moniker)))
      (insert-styled " " style)))
  
  
  (method public (insert-view view/form)
    (let* ((view (if (is? view/form View) view/form (instantiate~ view/form)))
           (end (get-end))
           (paragraph (get-paragraph (get-line~ end))))
      (set-parent~ view paragraph)
      (let ((style (new View-Style view: view)))
        (insert-styled " " style))))
  
  
  ;;;
  ;;;; Replace
  ;;;
  
  
  (method public (backspace word?)
    (when (write-allowed?)
      (unless (at-beginning?)
        (if (has-selection?)
            (delete-selection)
          (caret-update (delete-range~ model (new Range$Cell$ (move-backward (get-start) word?) (get-end))))))))
  
  
  (method public virtual (delete-char)
    (delete-action #f))
  
  
  (method public virtual (delete-word)
    (delete-action #t))
  
  
  (method public (delete-action word?)
    (when (write-allowed?)
      (unless (at-end?)
        (if (has-selection?)
            (delete-selection)
          (caret-update (delete-range~ model (new Range$Cell$ (get-start) (move-forward (get-end) word?))))))))
  
  
  (method public (replace range <Range$Cell$> strings)
    (when (write-allowed?)
      (without-caret
        (lambda ()
          (caret-update (replace~ model range strings))))))
  
  
  (method protected (replace-text range <Range$Cell$> strings)
    (caret-update (replace-text~ model range strings)))
  
  
  (method public (replace-selection strings)
    (caret-update (replace~ model (get-selection) strings)))
  
  
  (method (caret-update caret)
    (when caret
      (set-caret caret)
      (update-caret)))
  
  
  ;;;
  ;;;; Formatted
  ;;;
  
  
  (method (copy-formatted-selection)
    (if (empty-selection?)
        (bell)
      (let ((output (open-output-string)))
        (print-formatted~ model output (get-selection))
        (let ((text (get-output-string output)))
          (set-clipboard-text text format: 'jazz-formatted-text)))))
  
  
  (method (paste-formatted-clipboard)
    (if (clipboard-format-available? 'jazz-formatted-text)
        (let* ((text (get-clipboard-text format: 'jazz-formatted-text))
               (info (with-jazz-readtable (lambda () (read-string-element text)))))
          (replace-formatted~ model (get-selection) info))
      (let ((strings (split-lines (get-clipboard-text))))
        (replace-selection strings))))
  
  
  (method protected (replace-formatted-text range <Range$Cell$> strings formats styles paragraphs)
    (when (write-allowed?)
      (without-caret
        (lambda ()
          (replace-formatted-text~ model range strings formats styles paragraphs)))))
  
  
  ;;;
  ;;;; Text Formatted
  ;;;
  
  
  (definition protected formatted-start-delimiter
    #\x02)
  
  (definition protected formatted-end-delimiter
    #\x03)
  
  
  (method public virtual (insert-formatted-line line)
    (call-with-input-string line
      process-formatted))
  
  
  (method protected (process-formatted input)
    (define (process-string)
      (let ((output (open-output-string)))
        (let (iterate)
          (let ((c (peek-char input)))
            (if (or (eof-object? c)
                    (eqv? c formatted-start-delimiter)
                    (eqv? c formatted-end-delimiter))
                (insert-styled (get-output-string output) 'Output)
              (write-char (read-char input) output)
              (iterate))))))
    
    (define (process)
      (let ((c (peek-char input)))
        (when (and (not (eof-object? c))
                   (not (eqv? c formatted-end-delimiter)))
          (cond ((eqv? c formatted-start-delimiter)
                 (read-char input)
                 (let ((directive (read-formatted-parameter input)))
                   (process-formatted-directive directive input)))
                (else
                 (process-string)))
          (process))))
    
    (process))
  
  
  (method (with-formatted-range input proc)
    (let ((start (get-start)))
      (process-formatted input)
      (let ((end-char (read-char input)))
        (if (eof-object? end-char)
            (error "Incomplete formatted input, EOF reached")
          (let ((end (get-start)))
            (proc (new Range$Cell$ start end)))))))
  
  
  (method protected virtual (process-formatted-directive directive input)
    (case directive
      ((%)
       (insert-newline))
      (($)
       (unless (at-line-start?)
         (insert-newline)))
      ((bold)
       (with-formatted-range input
         (lambda (range)
           (toggle-bold~ model range))))
      ((italic)
       (with-formatted-range input
         (lambda (range)
           (toggle-italic~ model range))))
      ((underline)
       (with-formatted-range input
         (lambda (range)
           (toggle-underline~ model range))))
      ((color)
       (let ((color (read-formatted-parameter input)))
         (with-formatted-range input
           (lambda (range)
             (set-text-color~ model range (registered-color color))))))
      ((font)
       (let ((font (read-formatted-parameter input)))
         (with-formatted-range input
           (lambda (range)
             (set-text-font~ model range (registered-font font))))))
      (else
       (error "Unknown text directive: {s}" directive))))
  
  
  (definition (read-formatted-parameter input)
    (prog1 (read input)
      (read-char input)))
  
  
  ;;;
  ;;;; Format
  ;;;
  
  
  (method public (add-format name pref-format) <Format>
    (add-format~ model name pref-format))
  
  
  ;;;
  ;;;; Styles
  ;;;
  
  
  (method public (add-style name pref-style) <Style>
    (add-style~ model name pref-style))
  
  
  (method public (get-style name/style (error?: error? #t)) <Style>
    (get-style~ model name/style error?: error?))
  
  
  ;;;
  ;;;; Height
  ;;;
  
  
  (method public (get-default-height) <fx>
    (get-default-height~ model))
  
  
  (method public (get-height-at pos <Cell>) <fx>
    (get-height-at~ model pos))
  
  
  ;;;
  ;;;; Chapters
  ;;;
  
  
  (method public virtual (get-headers) <list>
    #f)
  
  
  (method public virtual (get-chapters) <list>
    (let ((headers (get-headers)))
      (if (not headers)
          '()
        (let ((occurences (text-regular-search-all~ model (map make-search-context headers)))
              (chapters (new List-Factory)))
          (for-each (lambda (info)
                      (bind (from . to) info
                        (let ((line (get-line~ from))
                              (col (get-col~ from)))
                          (when (= col (get-column line))
                            (let ((string (paragraph-string line)))
                              (let ((header (subseq string col (get-col~ to)))
                                    (level (if (= col 0) 1 2))
                                    (label (get-chapter-label string col from to)))
                                (put~ chapters (list level from header label))))))))
                    occurences)
          (get-output~ chapters)))))
  
  
  (method public virtual (get-chapter-label string col from to)
    (subseq string (+ col (- (position-offset~ model to) (position-offset~ model from)))))
  
  
  (method public virtual (get-first-special?) <bool>
    #t)
  
  
  (method public virtual (get-first-chapter lst)
    (if (get-first-special?)
        (if (null? lst) #f (car lst))
      (let ((file (get-moniker)))
        (list 0
              (text-beginning)
              ""
              (if (not file)
                  "<Top>"
                (get-name~ file))))))
  
  
  (method public virtual (get-remaining-chapters lst)
    (if (get-first-special?)
        (if (null? lst) '() (cdr lst))
      lst))
  
  
  ;;;
  ;;;; Expression
  ;;;
  
  
  (method public (current-name)
    (let ((range (current-expr-range)))
      (when range
        (name-at range))))
  
  
  (method public (current-symbol)
    (let ((expr (current-expr)))
      (when (symbol? expr)
        expr)))
  
  
  (method public (current-expr)
    (current-name))
  
  
  (method public (current-expr-range)
    (or (effective-selection)
        (expr-range (get-end))))
  
  
  (method public (current-expr-string)
    (let ((range (current-expr-range)))
      (when range
        (get-string range))))
  
  
  (method public virtual (name-at range)
    (name-at~ syntax range))


  (method public virtual (expr-at pos)
    (expr-at~ syntax pos))
  
  
  (method public virtual (range-expr range)
    (range-expr~ syntax range))
  
  
  (method public virtual (expr-range pos)
    (expr-range~ syntax pos))
  
  
  (method public (outer-range range)
    (outer-range~ syntax range))
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method override (mouse-insert copy)
    (define (separate? before after)
      (and (not (or (memv? before '(#\- #\.))
                    (memv? after '(#\- #\.))))
           (or (text-constituent? before) (memv? before '(#\) #\] #\} #\")))
           (or (text-constituent? after) (memv? after '(#\( #\[ #\{ #\" #\' #\,)))))
    
    (let ((start (get-start))
          (end (get-end)))
      (when (nu=? start end)
        (let ((prev (and (/= start (text-beginning)) (get-char (previous-cell start))))
              (next (and (/= end (text-ending)) (get-char end))))
          (when (and prev (separate? prev (element copy 0)))
            (set! copy (string-append " " copy)))
          (when (and next (separate? (last copy) next))
            (set! copy (string-append copy " ")))))
      (insert-string copy)))
  
  
  ;;;
  ;;;; Range
  ;;;
  
  
  (method public (range-strings range <Range$Cell$>) <list>
    (let ((start (get-start~ range))
          (end (get-end~ range)))
      (if (= (get-line~ start) (get-line~ end))
          (list (subseq (paragraph-string (get-line~ start)) (get-col~ start) (get-col~ end)))
        (let ((dest (new List-Factory)))
          (put~ dest (subseq (paragraph-string (get-line~ start)) (get-col~ start)))
          (put-sequence~ dest (map paragraph-string (naturals (+ (get-line~ start) 1) (get-line~ end))))
          (put~ dest (subseq (paragraph-string (get-line~ end)) 0 (get-col~ end)))
          (get-output~ dest)))))
  
  
  (method public (range-first-string range <Range$Cell$>) <string>
    (first (range-strings range)))
  
  
  ;;;
  ;;;; Column
  ;;;
  
  
  (definition Marked-Column
    #f)
  
  
  (method (on-mark-column evt)
    (mark-column))
  
  
  (method (on-fill-to-column evt)
    (fill-to-column))
  
  
  (method (mark-column)
    (let* ((start (get-start))
           (col (get-col~ start)))
      (set! Marked-Column col)
      (user-message "Marked to column {a}" col)))
  
  
  (method (fill-to-column)
    (if (or (has-selection?) (not Marked-Column))
        (bell)
      (let* ((start (get-start))
             (col (get-col~ start))
             (delta (- Marked-Column col)))
        (case (sign delta)
          ((1) (insert-string (make-string delta #\space)))))))
  
  
  ;;;
  ;;;; Format
  ;;;
  
  
  (method (on-upcase-selection evt)
    (if (empty-selection?)
        (bell)
      (with-preserved-selection
        (lambda ()
          (insert-string (upcase (get-selected-string)))))))
  
  
  (method (on-downcase-selection evt)
    (if (empty-selection?)
        (bell)
      (with-preserved-selection
        (lambda ()
          (insert-string (downcase (get-selected-string)))))))
  
  
  (method (on-capitalize-selection evt)
    (if (empty-selection?)
        (bell)
      (with-preserved-selection
        (lambda ()
          (insert-string (capitalize (get-selected-string)))))))
  
  
  (method (with-preserved-selection proc)
    (let ((selection (get-selection)))
      (proc)
      (set-selection selection)))
  
  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method public (view->text pos <Point>) <Cell>
    (let ((v (get-v~ pos)))
      (if (< v 0)
          {Cell 0 0}
        (let* ((line (if (< v (get-visible-height~ model)) (v->row v) (get-limit)))
               (par (get-paragraph line)))
          (new Cell line (view->col~ par (- pos (get-position~ par))))))))
  
  
  (method public (text->view pos <Cell>) <Point>
    (let* ((par (get-paragraph (get-line~ pos)))
           (view (col->view~ par (get-col~ pos))))
      (new Point
        (get-h~ view)
        (+ (line->view (get-line~ pos)) (get-v~ view)))))
  
  
  (method public (text->view-extended pos <Cell>)
    (let* ((par (get-paragraph (get-line~ pos)))
           (info (col->view-extended~ par (get-col~ pos)))
           (line (car info))
           (view (cdr info)))
      (cons line (new Point
                   (get-h~ view)
                   (+ (line->view (get-line~ pos)) (get-v~ view))))))
  
  
  (method (line->view line <fx>) <fx>
    (let ((par (get-paragraph line)))
      (get-v~ (get-position~ par))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-range range <Range$Cell$>) <void>
    (let ((limit (get-limit))
          (start (get-start~ range))
          (end (get-end~ range)))
      (when (or (> (get-line~ start) limit)
                (> (get-line~ end) limit))
        (error "Invalid text range: {t}" range))))
  
  
  (method public (set-selection-safe range . rest)
    (apply set-selection (restrict-range range) rest))
  
  
  (method public (restrict-range range)
    (let ((limit (get-limit)))
      (define (restrict-row cell)
        (if (> (get-line~ cell) limit)
            (new Cell limit 0)
          cell))
      
      (define (restrict-col cell)
        (let ((line (get-line~ cell))
              (col (get-col~ cell)))
          (let ((len (paragraph-length line)))
            (if (> col len)
                (new Cell line len)
              cell))))
    
      (new Range$Cell$
        (restrict-col (restrict-row (get-start~ range)))
        (restrict-col (restrict-row (get-end~ range))))))
  
  
  ;;;
  ;;;; Styles
  ;;;
  
  
  (method public (set-selection-format/style name/exemplar (format?: format? #f) (style?: style? #f))
    (let* ((format (and format? (get-format~ model name/exemplar error?: #f)))
           (style (and style? (get-style~ model name/exemplar error?: #f)))
           (selection (get-selection))
           (start (get-start))
           (end (get-end))
           (span? (neq? (get-paragraph (get-line~ start)) (get-paragraph (get-line~ end)))))
      (when style
        (cond ((or (empty-selection?) span?)
               (for-each-paragraph~ model
                 (lambda (line <fx> paragraph <Paragraph>)
                   (set-text-style~ model (new Range$Cell$ (new Cell line 0) (new Cell line (get-length~ paragraph))) style))
                start: (get-line~ start)
                end: (get-line~ end)))
              (else
               (set-text-style~ model selection style))))
      (when format
        (for-each-paragraph~ model
          (lambda (line <fx> paragraph <Paragraph>)
            (set-paragraph-format~ model paragraph format))
         start: (get-line~ start)
         end: (get-line~ end)))
      (set-modified? #t)
      (layout-scrollee)
      (invalidate-view)))
  
  
  (method (on-bold evt)
    (if (empty-selection?)
        (bell)
      (toggle-bold~ model (get-selection))))
  
  
  (method (on-italic evt)
    (if (empty-selection?)
        (bell)
      (toggle-italic~ model (get-selection))))
  
  
  (method (on-underline evt)
    (if (empty-selection?)
        (bell)
      (toggle-underline~ model (get-selection))))
  
  
  ;;;
  ;;;; Ruler
  ;;;
  
  
  (method public virtual (get-ruler)
    #f)
  
  
  (method (on-toggle-ruler evt)
    (let ((ruler (get-ruler)))
      (if (not ruler)
          (bell)
        (set-shown?~ ruler (not (get-shown?~ ruler))))))
  
  
  ;;;
  ;;;; Fonts
  ;;;
  
  
  (method public (set-selection-font-name name)
    (for-each-range (get-selection)
      (lambda (line paragraph start end)
        (set-font-name~ paragraph start end name)
        (wrap-paragraph~ model '() paragraph)))
    (set-modified? #t)
    (layout-scrollee)
    (invalidate-view))
  
  
  (method public (set-selection-point-size size)
    (for-each-range (get-selection)
      (lambda (line paragraph start end)
        (set-point-size~ paragraph start end size)
        (wrap-paragraph~ model '() paragraph)))
    (set-modified? #t)
    (layout-scrollee)
    (invalidate-view))
  
  
  ;;;
  ;;;; Colors
  ;;;
  
  
  (definition (pick-text-color sender)
    (popup-colors~ (get-parent~ sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-highlight-color sender)
    (popup-colors~ (get-parent~ sender) geometry: {Cell 3 8}))
  
  
  (definition (pick-frame-color sender)
    (popup-colors~ (get-parent~ sender) geometry: {Cell 3 8}))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (method protected (has-completion?)
    (and completion-active? (has-selection?)))
  
  
  (method protected (has-effective-selection?)
    (and (not completion-active?) (has-selection?)))
  
  
  (method protected (empty-effective-selection?)
    (or completion-active? (empty-selection?)))
  
  
  (method protected (effective-selection)
    (when (has-effective-selection?)
      (get-selection)))


  (method protected (set-completion range)
    (set! completion-active? #t)
    (set-selection range))
  

  (method (remove-completion)
    (when completion-active?
      (delete-selection)
      (set! completion-active? #f)))


  (method protected (end-completion)
    (when completion-active?
      (set! completion-active? #f)
      (set-caret (get-end))))
  
  
  (method protected virtual (auto-complete?)
    #f)


  (method protected virtual (favorite-completions?)
    #t)


  (method protected virtual (favorite-completions)
    (favorite-completions~ syntax))


  (method protected virtual (favorite-completion name)
    (assoc-value name (favorite-completions) #f))


  (method protected virtual (completion-name pos)
    )


  (method (completion-string pos)
    (define (skip-prefix name)
      (if name
          (let ((len (string-length name)))
            (if (and (> len 0) (eqv? (string-ref name 0) #\<))
                (substring name 1 len)
              name))
        #f))
    
    (define (alphabetize-completion completions offset)
      (let ((alphabet-char (remove-duplicates
                             (sort char<?
                                   (map (lambda (completion)
                                          (if (> (string-length completion) offset) (element completion offset) #\space))
                                        completions)))))
        (coerce alphabet-char String)))
    
    (let ((name (skip-prefix (completion-name pos))))
      (when name
        (let ((size (string-length name))
              (favorite (and (favorite-completions?) (or (get-user-completion name) (favorite-completion name))))
              (feedback? (not (macro-playing?~ (get-application)))))
          (if favorite
              (begin
                (when feedback?
                  (clear-user-message))
                (subseq favorite size))
            (if (not (complete-name? size))
                (begin
                  (when feedback?
                    (clear-user-message))
                  #f)
              (let* ((completions (symbol-completions name))
                     (count (length completions)))
                (cond ((= count 0)
                       (when feedback?
                         (clear-user-message))
                       #f)
                      ((= count 1)
                       (let ((found (car completions)))
                         (when feedback?
                           (user-message "{a}" found))
                         (if (string=? name found)
                             #f
                           (subseq found size))))
                      ((> count 5)
                       (let* ((common (completions-prefix completions))
                              (offset (string-length common))
                              (alphabet (alphabetize-completion completions offset)))
                         (when feedback?
                           (user-message "{a} ... [{a}]" common alphabet))
                         (subseq common size)))
                      (else
                       (let ((common (completions-prefix completions)))
                         (when feedback?
                           (user-message "{l detail: :human}" completions))
                         (subseq common size)))))))))))
  
  
  (method protected virtual (complete-name? size)
    (>= size 2))
  
  
  (method protected virtual (symbol-completions name)
    '())
  
  
  (method protected virtual (completions-prefix completions)
    (prefix completions))
  
  
  (method protected virtual (auto-complete key)
    (with-atomic-undo~ (get-undoer~ model)
      (lambda ()
        (get-style-at~ model (get-start))
        (let* ((end (get-end))
               (last (and (> (get-col~ end) 0) (get-char (- end 1))))
               (class (class-of self)))
          (if (not (auto-complete-char? key last))
              (begin
                (insert-char key)
                (complete-at (get-start)))
            (let* ((completion (join-lines (selection-lines)))
                   (offset (and completion (find completion key)))
                   (replacement (and offset (subseq completion 0 offset))))
              (when (and completion-active? replacement)
                (replace-selection (list replacement)))
              (end-completion)
              (insert-char/backspace key)
              (complete-at (get-start))))))))
  
  
  (method protected virtual (auto-complete-char? key last)
    (auto-complete-char?~ syntax key last))
  

  (method (complete-at pos <Cell>)
    (unless (or (textual-style?~ model (get-style-at~ model pos))
                (macro-recording?~ (get-application)))
      (let ((completion (completion-string pos)))
        (if (not completion)
            (set! completion-active? #t)
          (insert-string completion)
          (set-completion (new Range$Cell$ pos (+ pos (cast <fx> (cardinality completion)))))))))
  
  
  (method protected (convert-completion)
    (when completion-active?
      (let ((start (get-start))
            (end (get-end)))
        (end-completion)
        (set-selection (new Range$Cell$ start end) set-anchor?: #f))))


  (method protected (insert-char/backspace c (word?: word? #f))
    (parameterize ((keyboard-input? #t))
      (case c
        ((#\backspace)
         ; remove competion before doing backspace
         (when completion-active?
           (delete-selection))
         (backspace word?))
        (else
         (insert-char c)))))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method (on-search-forward-mode evt)
    (select-command-search~ (get-application) 'forward
      (search-context~ model (get-selected-string) ignore-case?: #t)))
  
  
  (method (on-search-backward-mode evt)
    (select-command-search~ (get-application) 'backward
      (search-context~ model (get-selected-string) ignore-case?: #t)))
  
  
  (method (on-search-current evt)
    (define (single-line strings)
      (if (null? strings)
          ""
        (car strings)))
    
    (let ((range (current-expr-range)))
      (if (not range)
          (select-command-search~ (get-application) 'forward (search-context~ model #f ignore-case?: #t))
        (let ((current (single-line (get-range-strings range))))
          (select-command-search-current~ (get-application) 'forward range (search-context~ model current ignore-case?: #t))))))

  
  (method public (text-expression-search string (start: start #f) (end: end (get-limit)) (reversed?: reversed? #f))
    (let* ((expl (new (explorer-class) model start: (text-beginning) end: (text-beginning)))
           (moniker (get-moniker))
           (mode (if (or (not moniker) (ci=? (get-extension~ moniker) "jazz")) 'code 'quotation))
           (found (search-expressions~ expl mode string position #f #f)))
      (when found
        (car found))))

  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method public virtual (select-next search-context (end: end #f))
    (let ((found (text-regular-search~ model search-context start: (get-end) end: end reversed?: #f)))
      (when found
        (bind (from . to) found
          (set-selection (new Range$Cell$ from (offset-position~ model (+ (position-offset~ model from) (- (position-offset~ model to) (position-offset~ model from))))))
          (ensure-displayed)
          (ensure-scrolled-left)
          #t))))
  
  
  (method public virtual (select-previous search-context (end: end #f))
    (let ((found (text-regular-search~ model search-context start: (get-start) end: end reversed?: #t)))
      (when found
        (bind (from . to) found
          (set-selection (new Range$Cell$ from (offset-position~ model (+ (position-offset~ model from) (- (position-offset~ model to) (position-offset~ model from))))))
          (ensure-displayed)
          (ensure-scrolled-left)
          #t))))
  
  
  (method public virtual (select-expr search-context direction)
    (case direction
      ((forward) (select-expr-forward search-context))
      ((backward) (select-expr-backward search-context))))
  
  
  (method public virtual (select-expr-forward search-context)
    (set-caret (text-beginning))
    (select-next search-context))
  
  
  (method public virtual (select-expr-backward search-context)
    (set-caret (text-ending))
    (select-previous search-context))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor)
    (new Text-View-Descriptor)))


;;;
;;;; Design
;;;


(submodule design


(import (jazz.designer))


(class Text-View-Descriptor extends Outline-View-Descriptor
  
  
  (form
    (<install>
      (<properties~>           categorized: (class-info name-info accepts-returns? focus-selects-all? background)
        (<Property-Descriptor> name: selectable? title: "Selectable"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: editable? title: "Editable"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: accepts-returns? title: "Accepts Returns"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: focus-selects-all? title: "Focus Selects All"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: show-unfocused-selection? title: "Show Unfocused Selection"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: force-tab-navigate? title: "Force Tab Navigate"
          (<Boolean-Domain>    name: domain)))))
  
  
  @too-many-icons!
  (method override (class-image class)
    {Image-Resource "Style"})
  
  
  (method override (component-surrogate-class component)
    Text-View-Surrogate)
  
  
  (method override (component-save-properties component designer)
    (when (get-modified?~ component)
      (set-property~ designer component 'text-content (get-content~ component) design-events?: #f)
      (set-modified?~ component #f))))))
