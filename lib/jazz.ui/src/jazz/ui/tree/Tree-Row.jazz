;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Tree Rows
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.tree.Tree-Row jazz


(import (jazz.geometry)
        (jazz.graphic)
	    (jazz.locale)
        (jazz.ui))


(class Tree-Row extends Outline-Row
  
  
  (property protected user-data  initialize {} accessors generate)
  (property protected background initialize {} accessors explicit)
  
  
  (slot protected node-width initialize {} getter generate)
  (slot protected down?      initialize #f)
  
  
  (method override (default-size)
    {Dimension 100 17})


  ;;;
  ;;;; Initialization
  ;;;


  (method override (initialize (parent: parent {}) (father: father {}) (level: level {}) (state: state 'collapsed) (row-height: row-height {}) (children: children '()) (visible?: visible? #t) (user-data: user-data {}))
    (nextmethod)
    (set! parent~self parent)
    (set! father~self father)
    (set! level~self level)
    (set! state~self state)
    (set! row-height~self row-height)
    (set-children children)
    (set! user-data~self user-data)
    (set-installed? #t)
    (set-finished? #t)
    (set-visible-flag visible?))


  ;;;
  ;;;; Print
  ;;;

  
  (method override (print printer readably)
    (print-unreadable self printer
      (lambda (printer)
        (format printer "{s}" user-data))))

  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-tree)
    parent)
  
  
  (method public (get-background)
    background)
  
  
  (method public (set-background value)
    (set! background value)
    (invalidate-view~ parent))
  
  
  ;;;
  ;;;; Children
  ;;;
  
  
  (method override (set-children lst)
    (let ((tree (get-tree)))
      (when tree
        (assert (= (length (get-columns~ tree)) (length lst)))))
    (when (not-null? lst)
      (let ((node (car lst)))
        (when (is? node Tree-Node)
          (set! node-width (text-width~ (effective-font~ parent) (localize (get-title~ node)))))))
    (set! children '())
    (for-each (lambda (child)
                (if (is? child View)
                    (set-parent~ child self)
                  (add-child child)))
              lst))
    
  
  (method override (replace-child rank child)
    (let ((current (element children rank)))
      (if (is? current View)
          (set-parent~ current {})
        (set! children (remove! current children)))
      (if (is? child View)
          (begin
            (set-parent~ child self)
            (set! children (insert! (remove! child children) rank child)))
        (set! children (insert! children rank child)))
      (layout-scrollee~ parent)))
  
  
  (method public (get-child rank)
    (element children rank))
  
  
  (method public (get-node-child)
    (find-if (lambda (child)
               (is? child Tree-Node))
             children))
  
  
  (method public (get-path-child)
    (find-if (lambda (child)
               (is? child Tree-Path))
             children))

  
  ;;;
  ;;;; Flatten
  ;;;
  
  
  (method public (flatten root-row)
    (let ((tree (get-tree)))
      (for-each (lambda (son)
                  (if (flatten-row?~ tree son)
                      (disconnect~ son)
                    (flatten~ son root-row)))
                sons)))
  
  
  (method public (disconnect)
    (let* ((path (get-path-child))
           (father-row (essay path (get-father-row~ path)))
           (root-row (get-root-row~ (get-tree)))
           (position (son-rank~ root-row (first (get-spine)))))
      (change-father root-row position: position)
      (set-descendants-level 0)))
  
  
  (method public (reconnect)
    (let ((father-row (get-father-row)))
      (set-descendants-level (+ 1 (get-level~ father-row)))
      (change-father father-row)))
  
  
  (method public virtual (disconnected?)
    (let ((father-row (get-father-row)))
      (essay father-row (/= father-row father))))
  
  
  (method public virtual (get-father-row)
    (let ((path (get-path-child)))
      (essay path (get-father-row~ path))))

  
  ;;;
  ;;;; State
  ;;;
  
  
  (method public virtual (auto-collapsable?)
    (collapsable?))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method override (layout)
    (let ((tree (get-tree)))
      (when (and tree children)
        (let ((h 0)
              (cs (get-column-spacing~ tree))
              (height (get-effective-height)))
          (for-each (lambda (column data)
                      (let ((width (get-width~ column)))
                        (layout-cell~ column self data h 0 width height)
                        (increase! h (+ width cs))))
                    (get-columns~ tree)
                    children)))))
  
  
  (method override (get-effective-width)
    node-width)
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method public virtual (context-menu pos)
    )
  
  
  (method public virtual (double-click pos)
    )
  
  
  (method public virtual (selector-down)
    (set! down? #t)
    (acquire-capture~ (get-header~ parent))
    (invalidate-row-selector~ (get-header~ parent) self)
    (selector-click~ parent self))


  (method public virtual (selector-up)
    (set! down? #f)
    (release-capture~ (get-header~ parent))
    (invalidate-row-selector~ (get-header~ parent) self))

  
  (method public virtual (selector-move initial-row)
    (invalidate-row-selector~ (get-header~ parent) self)
    (selector-multi-select~ parent self initial-row))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method override (draw-children surface nodes context lh lv sh sv sc sc?)
    (let* ((h 0)
           (v 0)
           (tree (get-tree))
           (cs (get-column-spacing~ tree))
           (height (get-height)))
      (for-each (lambda (column data)
                  (when (get-visible?~ column)
                    (let ((width (get-width~ column))
                          (merge-cell (get-merge-cell~ tree (row-col->site~ tree self column))))
                      (unless merge-cell
                        (let ((cell-h (+ lh h))
                              (cell-v (+ lv v)))
                          (if (is-not? data View)
                              (paint-data~ column surface context cell-h cell-v h v width height self data sh sv sc sc?)
                            (when (is? column Tree-Node-Column)
                              (draw-level~ column surface self data width height)
                              (draw-control~ column surface self data width height))
                            (paint-drawing~ data surface context cell-h cell-v sh sv sc sc?))))
                      (increase! h (+ width cs)))))
                (get-columns~ tree)
                children)))
  
  
  (method override (draw-selection surface)
    )
  
  
  (method public virtual (draw-selector surface context h v width height flat?)
    (if down?
        (draw-sunken-button surface h v width height flat?)
      (draw-raised-button surface h v width height flat?)))

  
  (method (draw-sunken-button surface h v width height flat?)
    (let* ((outer (new Rect h v (+ h width) (+ v height)))
           (inner (inflate-rect outer -1 -1)))
      (set-color~ surface {Color name: Dark})
      (frame-rect~ surface outer {Color name: Dark})
      (fill-rect~ surface inner (either background (header-color~ parent)))
      (set-text-color~ surface {Color name: Black})))
  
  
  (method (draw-raised-button surface h v width height flat?)
    (let ((thick (if flat? -1 -2)))
      ;; when spaced, it's the background that draws the right side shadow
      (let* ((outer (new Rect h v (+ h width) (+ v height)))
             (inner (expand-rect outer 1 1 thick thick)))
        (let ((smaller (expand-rect outer 0 0 0 -1)))
             (draw-edge~ surface smaller inner: 'raised edges: '(top left)))
        (fill-rect~ surface inner (either background (header-color~ parent)))
        (set-text-color~ surface {Color name: Black}))))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (find-by-title title)
    (find-if (lambda (row)
               (string=? (get-title~ (first-child~ row)) title))
             sons))
  
  
  ;;;
  ;;;; Auto
  ;;;
  
  
  (method public virtual (auto-in-place?)
    #f)
  
  
  (method public virtual (auto-expand)
    (when (expandable?)
      (expand/collapse~ parent self)))
  
  
  (method public virtual (auto-select)
    )
  
  
  (method public virtual (auto-collapse)
    (when (collapsable?)
      (collapse~ parent self)))))
