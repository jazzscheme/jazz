;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Tree View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Stephane Le Cornec
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.tree.Tree-View jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.platform)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window))


(class Tree-View extends Outline-View implements Selection-Provider
  

  ;;;
  ;;;; Lexicon
  ;;;
  
  
  ;; visible   : a row that has all its parents expanded
  ;; displayed : a row that is displayed on-screen even if only partially
  ;; row       : a Row object
  ;; column    : a Column object
  ;; site      : a Site object (row + column)
  ;; line      : the rank of a visible row
  ;; col       : the rank of a visible column
  ;; cell      : a Cell object (line + col)
  
  
  ;;;
  ;;;; Notes
  ;;;
  
  
  ;; For now, cell selection-mode only supports single select mode

  
  (definition delayed-autorow
    #f)

  
  (property protected portfolio                 initialize #f   accessors explicit)
  (property protected show-header?              initialize #t   accessors generate)
  ;; row cell node
  (property protected selection-mode            initialize 'row accessors explicit)
  (property protected multiple-selection?       initialize #f   accessors explicit)
  (property protected can-select-empty?         initialize #t   accessors explicit)
  (property protected show-unfocused-selection? initialize #t   accessors explicit)
  (property protected focused-on-descendants?   initialize #f   accessors explicit)
  (property protected auto-expand/collapse?     initialize #f   accessors generate)
  (property protected cell-background           initialize #f   accessors explicit)
  (property protected empty-background          initialize #f   accessors explicit)
  (property protected filled-column             initialize #t   accessors generate)
  (property protected column-spacing            initialize 0    accessors explicit)
  (property protected reorderable?              initialize #f   accessors generate)
  (property protected content                   initialize #f   accessors explicit)
  
  
  (slot protected columns                       initialize '()  getter generate)
  (slot protected node-column                   initialize #f   getter generate)
  (slot protected sorted-column                 initialize #f   getter generate)
  (slot protected sort-ascending?               initialize #t   getter generate)
  (slot protected selection-pivot               initialize #f)
  (slot protected highlighted                   initialize '())
  (slot protected indentation                   initialize 16   getter generate)
  (slot protected columns-borders               initialize '()  getter generate)
  (slot protected columns-right            <fx> initialize 0    getter generate)
  (slot protected edited-cell                   initialize #f   getter generate)
  (slot protected cell-editor                   initialize #f   getter generate)
  (slot protected close-cell-editor?            initialize #t)
  (slot protected auto-expanded-row             initialize #f   setter generate)
  (slot protected locator                       initialize (new Tree-Locator self))
  (slot protected selection-manager             initialize (new Selection-Manager self))
  (slot protected merge-cell-list               initialize '()  getter generate)
  (slot protected merge-cell-table              initialize (make-table test: site=? hash: site-hash) getter generate)
  
  
  (form
    (<install> background: {Color name: White}))


  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (finish rest)
    (nextmethod rest)
    (invalidate-columns))
  
  
  (method override (destroy-component)
    (end-edition)
    (nextmethod))
  

  ;;;
  ;;;; Component
  ;;;


  (method override (add-child child)
    (nextmethod child)
    (when (is? child Tree-Column)
      (set! columns (append! columns (list child)))
      ;; should idealy be done incrementaly
      (invalidate-columns)))
  
  
  (method override (remove-child child)
    (nextmethod child)
    (unless (destroying?)
      (when (is? child Tree-Column)
        (set! columns (remove! child columns))
        ;; should idealy be done incrementaly
        (invalidate-columns))))
  

  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-portfolio)
    (when portfolio
      (if (is? portfolio Portfolio)
          portfolio
        (set! portfolio (child portfolio))
        portfolio)))


  (method public (set-portfolio object)
    (set! portfolio object)
    (invalidate-view))


  (method public (get-multiple-selection?)
    multiple-selection?)


  (method public (set-multiple-selection? flag)
    (set! multiple-selection? flag)
    (invalidate-view))


  (method public (get-can-select-empty?)
    can-select-empty?)


  (method public (set-can-select-empty? flag)
    (set! can-select-empty? flag)
    (invalidate-view))


  (method public (get-show-unfocused-selection?)
    show-unfocused-selection?)


  (method public (set-show-unfocused-selection? flag)
    (set! show-unfocused-selection? flag)
    (invalidate-view))


  (method public (get-focused-on-descendants?)
    focused-on-descendants?)


  (method public (set-focused-on-descendants? flag)
    (set! focused-on-descendants? flag)
    (invalidate-view))


  (method public (get-selection-mode)
    selection-mode)


  (method public (set-selection-mode value)
    (set! selection-mode value)
    (invalidate-view))


  (method public (get-cell-background)
    cell-background)
  
  
  (method public (set-cell-background color)
    (set! cell-background color)
    (invalidate-view))
  
  
  (method public (get-empty-background)
    empty-background)
  
  
  (method public (set-empty-background color)
    (set! empty-background color)
    (invalidate-view))


  (method public (get-column-spacing)
    column-spacing)


  (method public (set-column-spacing spacing)
    (set! column-spacing spacing)
    (invalidate-view))


  ;;;
  ;;;; Focus
  ;;;


  (method override (focus-gained)
    (nextmethod)
    (invalidate-selection selection))


  (method override (focus-lost)
    (nextmethod)
    (invalidate-selection selection))
  
  
  (method public (selection-color)
    (if (focused?)
        (focused-color)
      (unfocused-color)))
  
  
  (method protected virtual (focused-color)
    {Color name: Focused-Selection})
  
  
  (method protected virtual (unfocused-color)
    {Color name: Unfocused-Selection})
  
  
  (method public (selected-text-color)
    (if (focused?)
        {Color name: Focused-Selected-Text}
      {Color name: Unfocused-Selected-Text}))
  
  
  (method public virtual (focused?)
    (or (has-focus?)
        (and focused-on-descendants?
             (let ((focus (get-focus)))
               (and focus (has-parent?~ focus self))))))
  
  
  (method public (focus-and-select)
    (acquire-focus)
    (when (> (get-visible-count) 0)
      (set-single-selection 0)))


  ;;;
  ;;;; Actions
  ;;;
  

  (method override (focus-actions)
    (cons (find-actions 'tree)
          (nextmethod)))


  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-expand evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (expand row))))
  
  
  (method (on-expand-all evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (expand-all row))))
  
  
  (method (on-collapse evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (collapse row))))
  
  
  (method protected virtual (on-properties evt)
    )
  
  
  ;;;
  ;;;; Header
  ;;;
  
  
  (method public (get-header)
    (let ((header (get-parent~ parent)))
      (when (is? header Tree-Header)
        header)))
  
  
  (method public (invalidate-header)
    (let ((header (get-header)))
      (when header
        (invalidate-view~ header))))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method override (find-subdrawing pos <Point> ignore)
    (or (continuation-capture
          (lambda (return)
            (for-each (lambda (merge-cell)
                        (let ((data (get-cell-data (get-master-cell~ merge-cell))))
                          (when (is? data View)
                            (let ((rect (merge-cell-rect merge-cell)))
                              (when (in-rect? pos rect)
                                (continuation-return return (find-drawing~ data (acquire~ data self pos))))))))
                      merge-cell-list)
            #f))
        (nextmethod pos ignore)))


  ;;;
  ;;;; Layout
  ;;;
  
  
  (method protected (layout-column column)
    (let ((row (get-next~ root-row))
          (rt 0))
      (while row
        (let* ((height (get-effective-height~ row))
               (rb (+ rt height)))
          (set-size~ row (new Dimension columns-right height))
          (set! rt rb)
          (set! row (get-next~ row))
          (increase! rt row-spacing)))))
  

  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method override (layout-scrollee)
    ;; column width change must be done before calling nextmethod
    (unless update-locked?
      (when filled-column
        (fill-column)))
    (nextmethod))
  
  
  (method override (scrollee-width)
    (let ((width (if show-header? columns-right (+ visible-width column-spacing))))
      (if (and scroller fit-in-scroller?)
          (max (get-display-width) width)
        width)))
  

  ;;;
  ;;;; Update
  ;;;
  
  
  ;; todo: do both of these in a single pass
  (method override (update-visible)
    (define (update-visible-height)
      (let ((count 0)
            (height 0)
            (first? #t))
        (for-each-visible-row
          (lambda (row line)
            (increase! count)
            (increase! height (get-effective-height~ row))
            (if first?
                (set! first? #f)
              (increase! height row-spacing))))
        (set! visible-count count)
        (set! visible-height height)))
    
    ;; todo: can very easily optimize the text-h call away by calculating at the start the
    ;; base (text-h for some row - level * indentation) and then only adding level * indentation
    (define (update-visible-width)
      (when (not show-header?)
        (let ((width 0))
          ;; a quick not too clean solution for now...
          (when (is? node-column Tree-Node-Column)
            (for-each-visible-row
              (lambda (row line)
                (let* ((highlight-border 3)
                       (nw (+ (or (get-node-width~ row) 0) highlight-border))
                       (w (+ (text-h~ node-column (get-level~ row)) nw)))
                  (when (> w width)
                    (set! width w)))))
            (set! visible-width width)
            (set! columns-right width)
            (set! columns-borders (list (cons 0 width)))
            (set-width~ node-column width)))))
    
    (update-visible-height)
    (update-visible-width))
  
  
  (method override (scroll-invalidate dh dv)
    (nextmethod dh dv)
    (invalidate-header))


  ;;;
  ;;;; Drawing
  ;;;
  
  
  (definition Highlighted-Outer-Color
    (new Color red: 0 green: 0 blue: 128))
  
  (definition Highlighted-Inner-Color
    (new Color red: 218 green: 218 blue: 255))
    
  (definition Highlighted-Insert-Color
    {Color name: Dark-Red})

  
  (method override (draw-outline surface context clipper lh lv sh sv sc sc?)
    (nextmethod surface context clipper lh lv sh sv sc sc?)
    (let* ((pos (get-position))
           (left (+ (get-left~ clipper) (get-h~ pos)))
           (right (+ (get-right~ clipper) (get-h~ pos)))
           (height (get-height)))
      ;; probably buggy in ftx fix with alain
      (when (and (view-enabled?) empty-background (<= columns-right right))
        (let ((rect (new Rect (if sc? (fxround (* columns-right sc)) columns-right) 0 (if sc? (fxround (* right sc)) right) (if sc? (fxround (* height sc)) height))))
          (fill-rect~ surface rect (if (debug-paint?) (cycle-debug-color!) empty-background)))))
    (draw-highlighted surface))
  
  
  ;; probably still buggy when scaling, so limit to tree-view for now
  (method override (draw-empty surface top bottom sh sv sc sc? rt width)
    (when (and (view-enabled?) empty-background (<= rt bottom))
      (let ((rect (new Rect 0 (fxround (if sc? (* rt sc) rt)) (fxround (if sc? (* width sc) width)) (fxround (if sc? (* bottom sc) bottom)))))
        (fill-rect~ surface rect (if (debug-paint?) (cycle-debug-color!) empty-background)))))
  
  
  (method (draw-highlighted surface)
    (for-each-reversed (lambda (highlight)
                         (let ((row (get-row~ highlight))
                               (col (get-col~ highlight))
                               (insert (get-insert~ highlight)))
                           (if (not insert)
                               (draw-highlighted-cell surface row col highlight)
                             (let ((rect (highlighted-insert-rect row insert)))
                               (fill-rect~ surface rect Highlighted-Insert-Color)))))
                       highlighted))
  
  
  (method protected virtual (draw-highlighted-cell surface row col highlight)
    (let* ((inner-rect (highlighted-target-rect row col))
           (outer-rect (inflate-rect inner-rect 1 1)))
      (let ((outer-color (or (get-outer-color~ highlight) (highlighted-outer-color)))
            (inner-color (or (get-inner-color~ highlight) (highlighted-inner-color))))
        (frame-rect~ surface outer-rect outer-color)
        (when (highlight-inner?)
          (frame-rect~ surface inner-rect inner-color)))))
  
  
  (method protected virtual (highlighted-outer-color)
    Highlighted-Outer-Color)
  
  
  (method protected virtual (highlighted-inner-color)
    Highlighted-Inner-Color)
  
  
  (method protected virtual (highlight-inner?)
    #t)
  
  
  (method public virtual (header-color)
    {Color name: Medium})
  
  
  (method override (draw-children surface <Surface> nodes context lh <fx> lv <fx> sh sv sc sc?)
    (define (paint-data context column row lh lv h v width height data)
      (let ((cell-h (+ lh h))
            (cell-v (+ lv v)))
        (if (is-not? data View)
            (paint-data~ column surface context cell-h cell-v h v width height row data sh sv sc sc?)
          (paint-drawing~ data surface context cell-h cell-v sh sv sc sc?))))
    
    (define (merge-geometry top-left bottom-right)
      (let ((top-left-rect (unmerged-site-rect top-left))
            (bottom-right-rect (unmerged-site-rect bottom-right)))
        (let ((top (get-top~ top-left-rect))
              (left (get-left~ top-left-rect))
              (right (get-right~ bottom-right-rect))
              (bottom (get-bottom~ bottom-right-rect)))
          (values left top (- right left) (- bottom top)))))
    
    (define (paint-merge-cell-data merge-cell)
      (receive (top-left bottom-right) (merge-corner-site merge-cell)
        (when (and top-left bottom-right)
          (receive (left top width height) (merge-geometry top-left bottom-right)
            (let ((left-column (get-column~ top-left))
                  (top-line (row->line (get-row~ top-left)))
                  (data (get-cell-data (get-master-cell~ merge-cell)))
                  (selected? (merge-cell-selected? merge-cell)))
              (let ((new-context (cons selected?: (cons selected? (cons line: (cons top-line context))))))
                (paint-data new-context left-column #f (+ lh left) (+ lv top) 0 0 width height data)))))))
    
    (nextmethod surface nodes context lh lv sh sv sc sc?)
    (for-each paint-merge-cell-data merge-cell-list))
  
  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method public (get-highlighted)
    highlighted)
  
  
  (method public (set-highlighted value)
    (define (invalidate-highlighted highlighted)
      (for-each (lambda (highlight)
                  (let ((row (get-row~ highlight))
                        (col (get-col~ highlight))
                        (insert (get-insert~ highlight)))
                    (if (not insert)
                        (invalidate-highlighted-cell row col)
                      (invalidate-rect (highlighted-insert-rect row insert)))))
                highlighted))
    
    (assert (every? (lambda (object) (is? object Tree-Highlight)) value))
    (when (not (equal? value highlighted))
      (let ((old highlighted))
        (set! highlighted value)
        (invalidate-highlighted old)
        (invalidate-highlighted highlighted))))
  
  
  (method protected virtual (invalidate-highlighted-cell row col)
    (with ((inner (highlighted-target-rect row col))
           (outer (inflate-rect inner 1 1))
           (region (frame-region outer insets: {Rect 2 2 2 2})))
      (invalidate-region region)))

  
  (method (highlighted-target-rect row col)
    (if (not col)
        (cell-text-rect (new Cell (row->line row) 0))
      (cell-rect (new Cell (row->line row) col))))
  
  
  (method (highlighted-insert-rect row insert)
    (let* ((height (get-height))
           (line (row->line row))
           (rect (line-rect line) @old-l&f-probably-better (cell-content-rect (new Cell line 0)))
           (before-first? (and (= line 0) (eq? insert 'before)))
           (after-last? (and (= line (- visible-count 1)) (eq? insert 'after)))
           (half-spacing (- (fxround/ row-spacing 2) 1))
           (offset (cond (before-first? 0)
                         (after-last? -2)
                         ((eq? insert 'after) half-spacing)
                         (else (- half-spacing row-spacing))))
           (proc
            (lambda (v)
              (let* ((top (+ v offset))
                     (bottom (+ top 2)))
                (new Rect (get-left~ rect) top (get-right~ rect) bottom)))))
      (case insert
        ((before) (proc (get-top~ rect)))
        ((after) (proc (get-bottom~ rect))))))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method override (update-visible-width-incremental level width)
    @wait-optimized
    (let ((width (+ (text-h~ node-column level) width)))
      (when (> width visible-width)
        (set! visible-width width))))

  
  (method override (remove-row row)
    (when (and (attached?~ row) (eq? row auto-expanded-row))
      (close-auto-expanded-row))
    (nextmethod row))
  
  
  (method override (remove-every-row)
    (close-auto-expanded-row)
    (set-sorted #f #t)
    (set! highlighted '())
    (set! selection-pivot #f)
    (set! merge-cell-list '())
    (empty-table merge-cell-table)
    (nextmethod))
  

  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method override (cursor-update pos)
    (if (alt-down?)
        (set-cursor :finger)
      (nextmethod pos)))
  

  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (allow-start-drag? pos)
    (and (nextmethod pos)
         (allow-start-drag?~ selection-manager)))
  
  
  (method override (mouse-down view)
    (let* ((cell (view->tree view))
           (pos (and cell (cell-coordinates cell view)))
           (part (and cell (find-part~ (get-column (get-col~ cell)) cell pos))))
      (mouse-down~ selection-manager view part (shift-down?) (control-down?) (alt-down?) (get-multiple-selection?)))
    (acquire-focus)
    (acquire-capture)
    (let ((cell (view->tree view))
          (shift? (shift-down?))
          (control? (control-down?)))
      (if (not cell)
          (when can-select-empty?
            (set-selection '()))
        (let ((pos (cell-coordinates cell view))
              (column (get-column (get-col~ cell))))
          (mouse-down~ column cell pos shift? control?)))))
  
  
  (method override (drag-move view)
    (let ((cell (view->tree view)))
      (when cell
        (let ((pos (cell-coordinates cell view))
              (column (get-column (get-col~ cell))))
          (drag-move~ column cell pos)))))
  
  
  (method override (drag-up view (dragging? #f))
    (mouse-up~ selection-manager (shift-down?) (control-down?) (alt-down?))
    (let ((cell (view->tree (or (unless dragging? (get-mouse-down-view~ selection-manager)) view)))
          (shift? (shift-down?))
          (control? (control-down?)))
      (unless (or dragging? cell)
        (set-selection '()))
      ;; the idea is there to do the selection only at mouse-up when the cell is already
      ;; selected (necessary for dnd) but this code is a not very elegant quick solution
      (when (and cell (not dragging?))
        (let ((pos (cell-coordinates cell view))
              (row (get-row (get-line~ cell)))
              (column (get-column (get-col~ cell))))
          (unless (mouse-down-part-control?~ selection-manager)
            (complete-mouse-down~ column cell pos shift? control?)
            (when auto-expand/collapse?
              (auto-select~ row))
            (focus-delegate)
            (drag-up~ column cell pos)))))
    (release-capture)
    (process-action self)
    (reset~ selection-manager))
  
  
  (method override (call-double-click view)
    (let ((cell (view->tree view)))
      (when cell
        (let* ((pos (cell-coordinates cell view))
               (column (get-column (get-col~ cell)))
               (part (find-part~ column cell pos)))
          (case part
            ((control) (mouse-down view))
            ((content) (nextmethod view))
            (else (double-click~ column cell pos)))))))
  
  
  (method override (double-click view)
    (double-click~ selection-manager (shift-down?) (control-down?) (alt-down?))
    (let ((cell (view->tree view)))
      (when cell
        (let* ((pos (cell-coordinates cell view))
               (column (get-column (get-col~ cell)))
               (part (find-part~ column cell pos)))
          (double-click~ column cell pos)))))
  
  
  (method override (context-menu view)
    (let ((cell (view->tree view)))
      (when cell
        (let ((row (get-row (get-line~ cell))))
          (context-menu~ row (acquire~ row self view))))))
  
  
  (method (cell-coordinates cell <Cell> pos <Point>) <Point>
    (- pos (cell-position cell)))


  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method override (mouse-data pos)
    (let ((cell (view->tree pos)))
      (when cell
        (get-cell-title cell))))


  ;;;
  ;;;; Keyboard
  ;;;


  (method override (key-press key)
    (when (and (use-locator?) (alphanumeric? key) (> visible-count 0))
      (enter~ locator key)))


  ;;;
  ;;;; Locator
  ;;;
  
  
  (method protected virtual (use-locator?)
    #t)
  
  
  (method public (locate-prefix prefix)
    (locate~ locator prefix))
  

  ;;;
  ;;;; Sort
  ;;;

  
  (method public virtual (header-click column)
    (sort-column (column->col column))
    (ensure-displayed))
  

  (method public (selector-click row)
    (acquire-focus)
    (case selection-mode
      ((cell)
       (let ((col (if selection-pivot (get-col~ selection-pivot) 0)))
         (let ((select-list
                 (loop (for n from 0 below (get-columns-count))
                       (collect (new Cell (row->line row) n)))))
           (set-selection select-list))))
      (else
       (set-selection (list (row->line row))))))
  
  
  (method public (selector-multi-select row initial-line)
    (let ((new-line (row->line row)))
      (let ((from-line (min initial-line new-line))
            (to-line (max initial-line new-line)))
        (case selection-mode
          ((cell)
           (let ((select-list (new-queue)))
             (loop (for line from from-line to to-line)
                   (loop (for col from 0 below (get-columns-count))
                         (enqueue select-list (new Cell line col))))
             (set-selection (queue-list select-list))))
          (else
           (let ((select-list
                   (loop (for line from from-line to to-line)
                         (collect line))))
             (set-selection select-list)))))))

  
  (method (set-sorted column ascending?)
    (let ((header (get-header))
          (same? (eqv? column sorted-column)))
      (when (and sorted-column (not same?))
        (invalidate-column-header~ header (get-column sorted-column)))
      (set! sort-ascending? ascending?)
      (set! sorted-column column)
      (when sorted-column
        (invalidate-column-header~ header (get-column sorted-column)))))
  
  
  (method public (sort-column column)
    (define (sort-rows rows equal direction)
      (let ((dual? (/= column 0))
            (get-node
              (lambda (row children n)
                (let ((data (element children n)))
                  (or (sort-value~ (get-column n) row data) "")))))
        (sort (lambda (rx ry)
                (let* ((cx (get-children~ rx))
                       (cy (get-children~ ry))
                       (nx (localize (get-node rx cx column)))
                       (ny (localize (get-node ry cy column))))
                  (or (direction nx ny)
                      (and dual?
                           (equal nx ny)
                           (direction (localize (get-node rx cx 0)) (localize (get-node ry cy 0)))))))
              rows)))
    
    (set-sorted column (or (not sorted-column) (/= column sorted-column) (not sort-ascending?)))
    (receive (equal smaller greater) (sort-predicates)
      (letrec ((direction (if sort-ascending? smaller greater))
               (proc (lambda (row)
                       (let ((sorted (sort-rows (get-sons~ row) equal direction)))
                         (reorder-sons~ row sorted)
                         (iterate (get-sons~ row) proc)))))
        (with-preserved-selection
          (lambda ()
            (with-update-locked
              (lambda ()
                (proc root-row))))
          ensure-displayed?: #f))))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method override (get-content)
    content)
  
  
  (method override (set-content value)
    (loop (for row in value)
          (for i from 0)
          (loop (for info in row)
                (for j from 0)
                (do (let* ((cell (new Cell i j))
                           (data (get-cell-data cell)))
                      (set-title~ data info)
                      (invalidate-cell cell))))))


  ;;;
  ;;;; Context
  ;;;

  
  (method override (with-context-click pos proc)
    (acquire-focus)
    (let ((cell (view->tree pos)))
      (if (not cell)
          (when can-select-empty?
            (set-selection '()))
        (let ((row (get-row (get-line~ cell))))
          (case selection-mode
            ((cell)
             (unless (member? cell (get-selection))
               (set-selection (list cell))))
            (else
             (unless (memq? (get-line~ cell) (get-selection))
               (set-selection (list (get-line~ cell))))))
          (when auto-expand/collapse?
            (auto-select~ row)))
        (update-view))
      (proc)))

  
  ;;;
  ;;;; Flatten
  ;;;
  
  
  (method public (flattened?)
    (let ((path-column (get-path-column)))
      (and path-column (get-visible?~ path-column))))
  
  
  (method public (flatten/unflatten)
    (let* ((path-column (get-path-column))
           (flattened? (flattened?)))
      (if (not path-column)
          (error "Unable to find path column")
        (set-visible?~ path-column (not flattened?))
        (fill-column)
        (with-preserved-selection
          (lambda ()
            (with-update-locked
              (lambda ()
                (if flattened?
                    (unflatten)
                  (flatten)))))))))
  
  
  (method public (get-path-column)
    (find-if (lambda (column)
               (is? column Tree-Path-Column))
             columns))
  
  
  (method public virtual (flatten-row? row)
    #t)
  
  
  (method public (flatten)
    (let ((sons (get-sons~ root-row)))
      (iterate sons
               (lambda (son)
                 (if (flatten-row? son)
                     (disconnect~ son)
                   (flatten~ son root-row))))
      (iterate sons
               (lambda (son)
                 (unless (disconnected?~ son)
                   (set-visible?~ son #f))))))
  
  
  (method public (unflatten)
    (iterate (get-sons~ root-row)
             (lambda (son)
               (when (disconnected?~ son)
                 (reconnect~ son))))
    (iterate (get-sons~ root-row)
             (lambda (son)
               (unless (get-visible?~ son)
                 (set-visible?~ son #t)))))
  

  ;;;
  ;;;; Tooltip
  ;;;


  (method override (get-tooltip?)
    #t)
  
  
  (method (calculate-tooltip-bounds cell)
    (cell-rect cell))
  
  
  (method override (get-tooltip-bounds pos)
    (let ((cell (view->tree pos)))
      (when cell
        (calculate-tooltip-bounds cell))))
  
  
  (method override (get-tooltip-context pos)
    (if (get-tooltip-text)
        (nextmethod pos)
      (let ((cell (view->tree pos)))
        (when cell
          (let ((row (get-row (get-line~ cell)))
                (column (get-column (get-col~ cell)))
                (text (localize (get-cell-tooltip cell))))
            (when text
              (let* ((width (column-width (get-col~ cell)))
                     (height (get-height~ row))
                     (content-rect (content-rect~ column row cell width height))
                     (formatted? (get-formatted-tooltip?))
                     (text-width (if formatted? 0 (+ (text-width~ (effective-font) text) 2))))
                (when (or (cell-tooltips? cell) (> text-width (rect-width content-rect)))
                  (let ((rect (calculate-tooltip-bounds cell))
                        (h (+ (content-h~ column (get-level~ row)) (if (= (get-col~ cell) 0) 2 -2))))
                    (new Tooltip-Context
                      view: self
                      text: (if formatted? text (split-lines text))
                      bounds: rect
                      position: (get-tooltip-position text rect h 0)
                      padding: (new Dimension 0 0)
                      font: (effective-font)))))))))))
  
  
  (method protected virtual (cell-tooltips? cell)
    #f)
  
  
  (method protected virtual (get-cell-tooltip cell)
    (let ((column (get-column (get-col~ cell)))
          (data (get-cell-data cell)))
      (get-data-tooltip~ column data)))
  
  
  (method protected virtual (get-tooltip-position text rect h v)
    (+ (rect-position rect) (new Point (- h 10) (+ v (rect-height rect) 5))))
  
  
  (method protected virtual (get-column-tooltip column)
    #f)


  ;;;
  ;;;; Dnd
  ;;;
  
  
  (method override (get-drag-drop)
    (when (view->tree mouse-down-point)
      (nextmethod)))


  ;;;
  ;;;; Drag
  ;;;
  
  
  (method override (get-drag-source)
    (let* ((pos (get-drag-position))
           (cell (view->tree pos))
           (row (get-row (get-line~ cell)))
           (col (get-col~ cell)))
      (get-drag-cell-source pos row col)))
  
  
  (method protected virtual (get-drag-cell-source pos row col)
    (new Tree-Drag-Source view: self position: pos @old image: @old (get-drag-image pos) row: row col: col))
  
  
  (method override (get-drag-hotspot)
    (let* ((cell (view->tree mouse-down-point))
           (row (get-row (get-line~ cell)))
           (left (image-h~ node-column (get-level~ row)))
           (top (get-v~ (get-position~ row))))
      (new Point left top)))
  
  
  (method override (get-drag-image pos)
    (let* ((cell (view->tree pos))
           (line (get-line~ cell)))
      (get-node-image line)))

  
  (method public (get-node-image line)
    @old
    (let* ((cdc (new Client-Surface player))
           (font (effective-font))
           (row (get-row line))
           (data (get-cell-data (new Cell line 0)))
           (image (get-image~ data))
           (title (get-title~ data))
           (width (column-width (get-node-column-index)))
           (height (get-height~ row))
           (bitmap (unspecified))
           (mask (unspecified)))
      (with ((memdc (new Memory-Surface cdc (new Dimension width height) keep-bitmap?: #t))
             (maskdc (new Memory-Surface cdc (new Dimension width height) keep-bitmap?: #t)))
        (fill-rect~ memdc (new Rect 0 0 width height) {Color name: White})
        (fill-rect~ maskdc (new Rect 0 0 width height) {Color name: White})
        (draw-image~ portfolio memdc #f image 0 0)
        (draw-mask~ portfolio maskdc image 0 0)
        (set-font~ memdc font)
        (set-text-color~ memdc {Color name: Black})
        (draw-text~ memdc 19 2 title)
        (set-font~ maskdc font)
        (set-text-color~ maskdc {Color name: Black})
        (draw-text~ maskdc 19 2 title)
        (set! bitmap (get-bitmap~ memdc))
        (set! mask (get-bitmap~ maskdc)))
      (let* ((portfolio (new Portfolio))
             (no (add-masked-bitmap~ portfolio bitmap mask)))
        (new Image portfolio: portfolio resource: no))))
    

  ;;;
  ;;;; Drop
  ;;;
  
  
  (method override (current-drop drag-drop pos)
    (define (get-reorder-target drag-drop pos)
      (call-with-view->tree pos
        (lambda (cell v height)
          (when cell
            (let* ((line (get-line~ cell))
                   (quarter (get-row-quarter v height))
                   (current (get-target~ drag-drop))
                   (row (get-row line)))
              (if (and current (eq? self (get-view~ current)) (eq? row (get-row~ current)) (eqv? quarter (get-quarter~ current)))
                  current
                (get-row-reorder-target drag-drop row quarter)))))))
    
    (define (get-row-quarter v height)
      (let ((quarter (/ height 4))
            (middle (/ height 2)))
        (cond ((< v quarter) 1)
              ((< v middle) 2)
              ((< v (- height quarter)) 3)
              (else 4))))
    
    (if (get-surrogate)
        (nextmethod drag-drop pos)
      (if (and reorderable? (eq? self (get-view~ (get-source~ drag-drop))))
          (get-reorder-target drag-drop pos)
        (get-tree-target drag-drop pos))))
  
  
  (method protected virtual (get-row-reorder-target drag-drop row quarter)
    (let* ((same-row? (memq? (row->line row) selection))
           (src-selection (get-selection~ (get-view~ (get-source~ drag-drop))))
           (src-range (contiguous-range src-selection))
           (dst (get-user-data~ row))
           (dst-line (row->line row))
           (current-rank (if (memq? quarter '(1 2)) dst-line (+ dst-line 1)))
           (accept? (or (not src-range) (and (not (memq? current-rank src-selection)) (/= current-rank (+ (cdr src-range) 1))))))
      (when accept?
        (let ((part (if (= current-rank dst-line) 'before 'after)))
          (new Tree-Drop-Target view: self row: row part: part)))))
  
  
  (method protected virtual (get-tree-target drag-drop pos)
    (call-with-view->tree pos
      (lambda (cell v height)
        (when cell
          (let ((row (get-row (get-line~ cell)))
                (current (get-target~ drag-drop)))
            (if (and current (eq? self (get-view~ current)) (eq? row (get-row~ current)))
                current
              (get-row-target drag-drop row)))))))
  
    
  (method public (get-tree-data-target drag-drop pos)
    (call-with-view->tree pos
      (lambda (cell v height)
        (when cell
          (let ((row (get-row (get-line~ cell)))
                (col (get-col~ cell))
                (source (get-source~ drag-drop))
                (current (get-target~ drag-drop)))
            (when (or (neq? (get-view~ source) self) (neq? (get-row~ source) row) (/= (get-col~ source) col))
              (if (and current (eq? self (get-view~ current)) (eq? row (get-row~ current)) (= col (get-col~ current)))
                  current
                (get-cell-target drag-drop row col))))))))
  
  
  (method protected virtual (get-row-target drag-drop row)
    #f)
  
  
  (method protected virtual (get-cell-target drag-drop row col)
    #f)
    
  
  (method override (highlight-drop drag-drop pos)
    (let ((target (get-target~ drag-drop)))
      ;; temp patch... this should always be a t-d-t
      (when (is? target Tree-Drop-Target)
        (let* ((row (get-row~ target))
               (col (get-col~ target))
               (part (get-part~ target))
               (insert
                (case part
                  ((row) #f)
                  ((before) 'before)
                  ((after) 'after)))
               (highlight (new Tree-Highlight row col insert: insert outer-color: Highlighted-Outer-Color inner-color: Highlighted-Inner-Color)))
          (set-highlighted (cons highlight (get-highlighted)))))))
  
  
  (method override (unhighlight-drop drag-drop)
    (set-highlighted (if (null? highlighted)
                         '()
                       (cdr highlighted))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method override (tab-stop-enter)
    )

  
  ;;;
  ;;;; Edition
  ;;;
    
  
  (method (on-move evt)
    (if arrow-press-handler
        (invoke~ arrow-press-handler self evt)
      (let ((direction (get-property~ evt direction:))
            (modifiers (get-modifiers~ evt)))
        (case direction
          ((up) (up-arrow-action modifiers #t))
          ((down) (down-arrow-action modifiers #t))
          ((left) (left-arrow-action modifiers #t))
          ((right) (right-arrow-action modifiers #t))))))


  (method package (on-home evt)
    (home-action))
  
  
  (method public (home-action)
    (let ((count (get-visible-count)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot (get-col~ selection-pivot) 0)))
             (set-selection (list (new Cell 0 col)))))
          (else
           (set-selection (list 0)))))))


  (method package (on-end evt)
    (end-action))
  
  
  (method public (end-action)
    (let ((count (get-visible-count)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot (get-col~ selection-pivot) 0)))
             (set-selection (list (new Cell (- count 1) col)))))
          (else
           (set-selection (list (- count 1))))))))


  (method override (left-arrow-press modifiers)
    (left-arrow-action modifiers #t))
  
  
  (method public (left-arrow-action modifiers user-origin?)
    (define (logical-col cell)
      (let ((site (cell->site cell)))
        (when site
          (let ((merge-cell (get-merge-cell site)))
            (if merge-cell
                (get-first-col~ merge-cell)
              (get-col~ cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((col (logical-col cell)))
             (when (> col 0)
               (move-cell (new Cell (get-line~ cell) (- col 1)) 'left user-origin?))))))
      ((row)
       (let ((row (get-selected-row)))
         (if (not row)
             (bell)
           (if (expanded?~ row)
               (expand/collapse row)
             (when (> (get-level~ row) 0)
               (set-selection (list (row->line (get-father~ row)))))))))))


  (method override (up-arrow-press modifiers)
    (up-arrow-action modifiers #t))
  
  
  (method public (up-arrow-action modifiers user-origin?)
    (define (logical-row cell)
      (let ((site (cell->site cell)))
        (when site
          (let ((merge-cell (get-merge-cell site)))
            (if merge-cell
                (get-first-line~ merge-cell)
              (get-line~ cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((line (logical-row cell)))
             (when (> line 0)
               (move-cell (new Cell (- line 1) (get-col~ cell)) 'up user-origin?))))))
      (else
       (let ((count (get-visible-count)))
         (if (null? selection)
             (when (> count 0)
               (move-selection (- count 1) 'backward user-origin?))
           (let ((line (car selection)))
             (when (> line 0)
               (move-selection (- line 1) 'backward user-origin?))))))))


  (method override (right-arrow-press modifiers)
    (right-arrow-action modifiers #t))
  
  
  (method public (right-arrow-action modifiers user-origin?)
    (define (logical-col cell)
      (let ((site (cell->site cell)))
        (when site
          (let ((merge-cell (get-merge-cell site)))
            (if merge-cell
                (get-last-col~ merge-cell)
              (get-col~ cell))))))
    
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (let ((col (logical-col cell)))
             (when (< col (- (get-columns-count) 1))
               (move-cell (new Cell (get-line~ cell) (+ col 1)) 'right user-origin?))))))
      (else
       (let ((row (get-selected-row)))
         (if (not row)
             (bell)
           (unless (expanded?~ row)
             (expand/collapse row)))))))


  (method override (down-arrow-press modifiers)
    (down-arrow-action modifiers #t))
  
  
  (method public (down-arrow-action modifiers user-origin?)
    (define (logical-row cell)
      (let ((site (cell->site cell)))
        (when site
          (let ((merge-cell (get-merge-cell site)))
            (if merge-cell
                (get-last-line~ merge-cell)
              (get-line~ cell))))))

    (let* ((count (get-visible-count))
           (last (- count 1)))
      (case selection-mode
        ((cell)
         (when (not-null? selection)
           (let ((cell selection-pivot))
             (let ((line (logical-row cell)))
               (when (< line last)
                 (move-cell (new Cell (+ line 1) (get-col~ cell)) 'down user-origin?))))))
        (else
         (if (null? selection)
             (when (> count 0)
               (move-selection 0 'forward user-origin?))
           (let ((line (car selection)))
             (when (< line last)
               (move-selection (+ line 1) 'forward user-origin?))))))))
    
  
  (method (move-selection line direction user-origin?)
    (let ((row (get-row line)))
      (set-selection (list line) user-origin?: user-origin?)
      (when auto-expand/collapse?
        (auto-select~ row))
      (when user-origin?
        (update-view))))
  
  
  (method (move-cell cell direction user-origin?)
    (set-selection (list cell) ensure-displayed?: #f user-origin?: user-origin?)
    (let ((rect (cell-rect cell)))
      (case direction
        ((left)  (scroll (new Point (horizontal-scroll-needed (get-left~ rect) 'backward) 0)))
        ((up)    (scroll (new Point 0 (vertical-scroll-needed (get-top~ rect) 'backward))))
        ((right) (scroll (new Point (horizontal-scroll-needed (get-right~ rect) 'forward) 0)))
        ((down)  (scroll (new Point 0 (vertical-scroll-needed (get-bottom~ rect) 'forward))))))
    (when user-origin?
      (update-view)))
  
  
  (method (line-displayed? line)
    (let* ((row (get-row line))
           (top (get-top~ row))
           (bottom (get-bottom~ row))
           (needed (scroll-needed (new Point 0 top) (new Point 0 bottom) #f)))
      (= (get-v~ needed) 0)))
  
  
  (method (cell-displayed? cell)
    (let* ((rect (cell-rect cell))
           (needed (scroll-needed (new Point (get-left~ rect) (get-top~ rect)) (new Point (get-right~ rect) (get-bottom~ rect)) #f)))
      (and (= (get-h~ needed) 0)
           (= (get-v~ needed) 0))))
  
  
  (method override (select-all (user-origin?: user-origin? #f))
    (when multiple-selection?
      (set-selection (naturals 0 visible-count) user-origin?: user-origin?)))

  
  ;;;
  ;;;; Columns
  ;;;
  
  
  (method public (fill-column)
    (define (find-filled-column name)
      (cond ((integer? name) (element columns name))
            ((eq? name #t) (and (not-null? columns) (last columns)))
            (else (find-if (lambda (column)
                             (eq? (get-name~ column) name))
                           columns))))
    
    (when (and filled-column (not-null? columns-borders))
      (let ((column (find-filled-column filled-column)))
        (when column
          (let ((col (column->col column)))
            (when (< col (length columns-borders))
              (let* ((filled-borders (element columns-borders col))
                     (space-after (- columns-right (borders-right filled-borders)))
                     (size (get-display-size))
                     (delta (max (- (borders-width filled-borders)) (- (get-width~ size) space-after (borders-right filled-borders))))
                     (old-right (cdr filled-borders))
                     (new-right (+ old-right delta)))
                (for-each (lambda (pair)
                            (set-car! pair (+ (car pair) delta))
                            (set-cdr! pair (+ (cdr pair) delta)))
                          (tail columns-borders (+ col 1)))
                (set-cdr! filled-borders new-right)
                (increase! columns-right delta)
                (set-width~ column (max (+ (get-width~ column) delta) min-column-width))
                (let ((left (max (- (min old-right new-right) 2) 0))
                      (top 0)
                      (right (get-width~ size))
                      (bottom (get-height~ size)))
                  (when (and (< left right) (< top bottom))
                    (invalidate-rect (new Rect left top right bottom))))
                (invalidate-header))))))))

  
  (method public (add-column . rest)
    (bind-keywords ((class Tree-Column) (title #f) (width #f) . others) rest
      (let ((column (apply new class parent: self others)))
        (when (is? column Tree-Node-Column)
          (set! node-column column))
        (when width
          (set-width~ column width))
        (when title
          (set-title~ column title))
        (fill-column)
        (invalidate-header)
        column)))
  
  
  (method public (remove-column column)
    (set! columns (remove! column columns))
    (when (eq? column node-column)
      (set! node-column #f))
    (invalidate-columns)
    (fill-column)
    (invalidate-header))
  
  
  (method public (remove-columns (preserve-node-column?: preserve-node-column? #f) (preserve: preserve '()))
    (define (remove-columns-preserving)
      (remove-every-row)
      (for-each (lambda (column)
                  (unless (or (and preserve-node-column? (is? column Tree-Node-Column))
                              (memq? (get-name~ column) preserve))
                    (remove-column column)))
                (get-columns))
      (invalidate-header))
    
    (define (remove-all-columns)
      (remove-every-row)
      (set-children '())
      (set! columns '())
      (set! columns-borders '())
      (set! columns-right 0)
      (set! node-column #f)
      (invalidate-header))
    
    (if (or preserve-node-column? preserve)
        (remove-columns-preserving)
      (remove-all-columns)))

  
  (method override (invalidate-columns)
    (when (not-null? columns)
      (invalidate-node-column)
      (invalidate-borders)))
  
  
  (method (invalidate-node-column)
    (set! node-column (find-if (lambda (column)
                                 (is? column Tree-Node-Column))
                               columns)))

  
  (method protected (invalidate-borders)
    (let ((left 0))
      (set! columns-borders
            (map (lambda (column)
                   (let* ((width (get-width~ column))
                          (right (+ left width)))
                     (prog1 (cons left right)
                       (when (get-visible?~ column)
                         (set! left (+ right column-spacing))))))
                 columns))
      (set! columns-right (borders-right (last columns-borders)))))
    
  
  (method public (get-columns-count)
    (length columns))
    
  
  (method public (get-column col)
    (element columns col))
  
  
  (method public (find-column name)
    (find-component name))
  
  
  (method public (get-node-column-index)
    (column->col node-column))
  
  
  (method public (column->col column)
    (find columns column))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method override (row-class)
    Tree-Row)
  
  
  (method override (update-father-control father)
    (when (and (not update-locked?) (neq? father root-row) (row-visible?~ father))
      (let* ((line (row->line father))
             (top (row-top line)))
        (when (< top (get-height))
          (invalidate-rect (control-rect~ node-column father top))
          (invalidate-rect (image-rect~ node-column father top))))))
  
  
  (method override (add-empty-row (father: father #f))
    (let ((father (or father root-row)))
      (add-row father: father children: (map (lambda (column)
                                               (new-empty-cell~ column))
                                             columns))))
  
  
  (method override (line-selected? line)
    (case selection-mode
      ((cell) (some? (lambda (cell) (= (get-line~ cell) line)) selection))
      (else (memq? line selection))))
  
  
  (method override (line-draw-selected? line)
    (and (nextmethod line)
         (or (has-focus?) show-unfocused-selection?)))

  
  ;;;
  ;;;; Merge
  ;;;
  
  
  (method public (merge-cells cell nbline nbcol)
    (if (and (> nbline 0) (> nbcol 0))
        (let ((cell-data (get-cell-data cell)))
          (if cell-data
              (let ((title (get-cell-title cell))
                    (site (cell->site cell)))
                (when site
                  (when (get-merge-cell site)
                    (unmerge-cells cell)))
                (when (or (> nbline 1) (> nbcol 1))
                  (let ((cell-line (get-line~ cell))
                        (cell-col (get-col~ cell)))
                    (if (and (< (+ cell-line nbline -1) (get-row-count))
                             (< (+ cell-col nbcol -1) (get-columns-count)))
                        (let ((new-rows (new-queue))
                              (new-columns (new-queue))
                              (new-sites (new-queue)))
                          (loop (for r from cell-line below (+ cell-line nbline))
                                (loop (for c from cell-col below (+ cell-col nbcol))
                                      (let ((merged-cell (new Cell r c)))
                                        (if #t @creates-problems-with-edited-cells (equal? title (get-cell-title merged-cell))
                                            (let ((new-row (get-row r))
                                                  (new-column (get-column c))
                                                  (new-site (new Site (get-row r) (get-column c))))
                                              (enqueue new-rows new-row)
                                              (enqueue new-columns new-column)
                                              (enqueue new-sites new-site))
                                          (error "Merged cells title must be identical")))))
                          (let ((new-merge-cell (new Merge-Cell cell (queue-list new-rows) (queue-list new-columns) self)))
                            (set! merge-cell-list (cons new-merge-cell merge-cell-list))
                            (for-each (lambda (merged-site)
                                        (set-merge-cell! merged-site new-merge-cell))
                                      (queue-list new-sites))
                            (let ((rect (merge-cell-rect new-merge-cell)))
                              (when rect
                                (when (is? cell-data View)
                                  (set-rect~ cell-data (acquire~ (get-parent~ cell-data) self rect)))
                                (invalidate-rect rect)))))
                      (error "Merge cell out of tree bounds")))))
            (error "First cell has no data")))
      (error "Invalid merge-cells")))
  
  
  (method public (unmerge-cells cell)
    (let ((merge-cell-to-remove (get-merge-cell (cell->site cell))))
      (when merge-cell-to-remove
        (let ((rect (merge-cell-rect merge-cell-to-remove)))
          (set! merge-cell-list (remove! merge-cell-to-remove merge-cell-list))
          (for-each-cell~ merge-cell-to-remove
            (lambda (row column)
              (let ((site (row/column->site row column)))
                (clear-merge-cell site))))
          (when rect
            (invalidate-rect rect))))))
  
  
  (method public (add-merged-row row merge-cell)
    (let ((merged-title (get-cell-title (get-master-cell~ merge-cell)))
          (is-valid? #t)
          (site-list '()))
      (for-each (lambda (column)
                  (let ((new-title (get-data-title (get-child~ row (column->col column)))))
                    (if (equal? merged-title new-title)
                        (let ((site (new Site row column)))
                          (set-merge-cell! site merge-cell)
                          (set! site-list (cons site site-list)))
                      (set! is-valid? #f))))
                (get-merged-columns~ merge-cell))
      (if is-valid?
          (add-merged-row~ merge-cell row)
        (for-each clear-merge-cell site-list))
      @creates-problems-with-edited-cells
      (when (not is-valid?)
        (error "Merged cells title must be identical"))))

  
  (method public (get-merge-cell site)
    (table-ref merge-cell-table site #f))
  
  
  (method public (safe-get-merge-cell site)
    (case selection-mode
      ((cell) (get-merge-cell site))
      (else #f)))
  
  
  (method public (set-merge-cell! site merge-cell)
    (table-set! merge-cell-table site merge-cell))
  
  
  (method public (clear-merge-cell site)
    (table-clear merge-cell-table site))
  
  
  (method (merge-cell-selected? merge-cell)
    (and (or (has-focus?) show-unfocused-selection?)
         (case selection-mode
           ((cell)
            (some? (lambda (cell)
                     (let ((site (cell->site cell)))
                       (when site
                         (eq? merge-cell (get-merge-cell site)))))
                   (get-selection)))
           (else
            #f))))
    

  (method (merge-corner-site merge-cell)
    (values (get-first-site~ merge-cell) (get-last-site~ merge-cell)))
    

  (method (merge-corner-cell merge-cell)
    (values (get-first-cell~ merge-cell) (get-last-cell~ merge-cell)))
  
  
  (method public (merge-cell-rect merge-cell)
    (receive (top-left bottom-right) (merge-corner-site merge-cell)
      (if (and top-left bottom-right)
          (let ((top-left-rect (unmerged-site-rect top-left))
                (bottom-right-rect (unmerged-site-rect bottom-right)))
            (new Rect (get-left~ top-left-rect) (get-top~ top-left-rect) (get-right~ bottom-right-rect) (get-bottom~ bottom-right-rect)))
        #f)))
  
  
  (method public (invalidate-merge-cell merge-cell)
    (when (view-visible?)
      (let ((root (get-root)))
        (receive (dh dv sc) (get-delta~ root self)
          (with ((region (new Region (acquire-delta dh dv sc (rect-intersection (merge-cell-rect merge-cell) (get-clipper))))))
            (invalidate-region~ player region))))))
  
  
  (method public (get-master-cell cell)
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (if merge-cell
          (get-master-cell~ merge-cell)
        cell)))
  
  
  (method public (get-top-cell cell)
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (if merge-cell
          (get-first-cell~ merge-cell)
        cell)))
  
  
  (method package (find-merged-view view)
    (continuation-capture
      (lambda (return)
        (for-each (lambda (merge-cell)
                    (let ((data (get-cell-data (get-master-cell~ merge-cell))))
                      (when (eq? data view)
                        (continuation-return return merge-cell))))
                  merge-cell-list)
        #f)))
  

  ;;;
  ;;;; User
  ;;;
  
  
  (method public (row-index target)
    (continuation-capture
      (lambda (return)
        (for-each-visible-row
          (lambda (row line)
            (when (eq? row target)
              (continuation-return return line))))
        #f)))


  (method public (user-data-row data (test: test eqv?) (visible?: visible? #t))
    (continuation-capture
      (lambda (return)
        ((if visible? for-each-visible-row for-each-row)
         (lambda (row line)
           (when (test (get-user-data~ row) data)
             (continuation-return return row))))
        #f)))


  (method public (user-data-rows data-list (test: test eqv?) (visible?: visible? #t))
    (let ((fact (new List-Factory)))
      ((if visible? for-each-visible-row for-each-row)
       (lambda (row line)
         (let ((user-data (get-user-data~ row)))
           (when (member? user-data data-list test: test)
             (put~ fact row)))))
      (get-output~ fact)))


  ;; Because it returns the line, this method only makes sense on visible rows
  (method public (user-data-index data (test: test eqv?))
    (continuation-capture
      (lambda (return)
        (for-each-visible-row
          (lambda (row line)
            (when (test (get-user-data~ row) data)
              (continuation-return return line))))
        #f)))


  ;; Because it returns the line, this method only makes sense on visible rows
  (method public (user-data-indexes data-list (test: test eqv?))
    (let ((fact (new List-Factory)))
      (for-each-visible-row
        (lambda (row line)
          (let ((user-data (get-user-data~ row)))
            (when (member? user-data data-list test: test)
              (put~ fact line)))))
      (get-output~ fact)))
  
  
  (method public (select-user-data-row data)
    (let ((row (user-data-row data)))
      (if (not row)
          (error "Unable to select user-data: {t}" data)
        (set-single-selection (row->line row)))))

  
  ;;;
  ;;;; Cells
  ;;;
  
  
  (method public (get-cell-data cell)
    (let ((row (get-row (get-line~ cell))))
      (when row
        (when (>= (get-col~ cell) (length (get-children~ row)))
          (set! selection '())
          (error "Sequence overrun"))
        (get-child~ row (get-col~ cell)))))
  
  
  (method public (set-cell-data cell data)
    (let ((row (get-row (get-line~ cell))))
      (set-element! (get-children~ row) (get-col~ cell) data)))
  
  
  (method public (get-data-title data)
    (cond ((is? data Tree-Label)
           (get-title~ data))
          ((is? data Tree-Data-View)
           (get-title~ (get-preserved-data~ data)))))
  
  
  (method public (set-data-title data title)
    (cond ((is? data Tree-Label)
           (set-title~ data title))
          ((is? data Tree-Data-View)
           (set-title~ (get-preserved-data~ data) title))))
  
  
  (method public (get-cell-title cell)
    (let ((data (get-cell-data cell)))
      (when data
        (get-data-title data))))
  
  
  (method public (set-cell-title cell title)
    (let ((data (get-cell-data cell)))
      (when data
        (set-data-title data title))))

  
  (method public (invalidate-cell cell)
    (invalidate-rect (cell-rect cell)))
  
  
  (method public (redraw-cell cell)
    (invalidate-cell cell)
    (update-view))


  ;;;
  ;;;; State
  ;;;
  
  
  (method override (expand/collapse row)
    (let ((top (get-v~ (get-position~ row))))
      (invalidate-rect (control-rect~ node-column row top)))
    (case (get-state~ row)
      ((dynamic) (dynamic-expand row))
      (else (nextmethod row))))
  
  
  (method public (dynamic-expand row)
    (update-row row)
    (expand row #t))
  
  
  (method override (invalidate-expand row top dynamic?)
    (when node-column
      (invalidate-rect (image-rect~ node-column row top))
      (if (and dynamic? (= (cardinality (get-sons~ row)) 0))
          (invalidate-rect (control-rect~ node-column row top))
        (invalidate-rect (plus/minus-rect~ node-column row top)))))
  
  
  (method override (invalidate-collapse line row top selected?)
    (when node-column
      (invalidate-rect (image-rect~ node-column row top))
      (if selected?
          (invalidate-rect (line-rect line))
        (invalidate-rect (plus/minus-rect~ node-column row top)))))
  
  
  (method override (collapse-selection line removed)
    (case selection-mode
      ((cell)
       (when removed
         (let ((cell (new Cell line (get-col~ removed))))
           (unless (member? cell selection)
             (set-selection (cons cell selection))))))
      (else
       (when (and removed (not (line-selected? line)))
         (set-selection (cons line selection)))))
    (unless selection-pivot
      (set! selection-pivot (and (not-null? selection) (car selection)))))
  
  
  (method public (auto-expand/collapse row (close-auto-expanded?: close-auto-expanded? #t) (auto-toggle?: auto-toggle? #f))
    (define (auto-toggle row auto-toggle?)
      (if (expanded?~ row)
          (when auto-toggle?
            (auto-collapse~ row)
            (set! auto-expanded-row #f))
        (auto-expand~ row)
        (set! auto-expanded-row row)))
    
    (let ((selected-rows (selection->rows selection)))
      (cond ((mouse-down?~ selection-manager)
             (when (and close-auto-expanded? auto-expanded-row (neq? auto-expanded-row row))
               (close-auto-expanded new-spine: (and row (get-spine~ row)) force?: #f)
               (set! delayed-autorow auto-expanded-row)
               (set! auto-expanded-row #f))
             (when (and row (auto-in-place?~ row))
               (auto-toggle row auto-toggle?)))
            ((mouse-up?~ selection-manager)
             (when delayed-autorow
               (if row
                   (close-delayed-row new-spine: (get-spine~ row))
                 (auto-collapse~ (if (expanded?~ delayed-autorow)
                                     delayed-autorow
                                   (get-father~ delayed-autorow)))
                 (set! delayed-autorow #f)))
             (when (and row (not (auto-in-place?~ row)))
               (auto-toggle row auto-toggle?)))
            (else
             (when close-auto-expanded?
               (close-auto-expanded new-spine: (and row (get-spine~ row))))
             (when row
               (auto-toggle row auto-toggle?))))
      (set! selection (rows->selection selected-rows))))
  
  
  (method public (close-delayed-row (new-spine: new-spine #f))
    (when delayed-autorow
      (let ((old-spine (get-spine~ delayed-autorow))
            (done? #f))
        (set! delayed-autorow #f)
        (for-each-reversed (lambda (row)
                             (unless done?
                               (if (and new-spine (memq? row new-spine))
                                   (set! done? #t)
                                 (auto-collapse~ row))))
                           old-spine))))
  
  
  (method public (close-auto-expanded (new-spine: new-spine #f) (force?: force? #t))
    (when auto-expanded-row
      (let ((old-spine (get-spine~ auto-expanded-row))
            (done? #f))
        (set! auto-expanded-row #f)
        (for-each-reversed (lambda (row)
                             (unless done?
                               (if (and new-spine (memq? row new-spine))
                                   (set! done? #t)
                                 (if (or force? (auto-in-place?~ row))
                                     (auto-collapse~ row)
                                   (set! auto-expanded-row row)
                                   (set! done? #t)))))
                           old-spine))))
  
  
  (method (close-auto-expanded-row)
    (when auto-expanded-row
      (auto-collapse~ auto-expanded-row)
      (set! auto-expanded-row #f)))
  
  
  (method public (set-dynamic row)
    (when (neq? (get-state~ row) 'dynamic)
      (set-state~ row 'dynamic)
      (let* ((line (row->line row))
             (top (row-top line)))
        (invalidate-rect (control-rect~ node-column row top)))))

  
  ;;;
  ;;;; Scroll
  ;;;


  (method override (ensure-displayed . rest)
    (when (not-null? selection)
      (if (eq? selection-mode 'cell)
          (ensure-cell-displayed (car selection))
        (ensure-row-displayed (selection-row (car selection))))))
  
  
  (method (ensure-cell-displayed cell)
    (let ((rect (cell-rect cell)))
      ;; the second pos should take in the cell width and height
      (scroll (scroll-needed (rect-position rect) (rect-end-position rect) (get-scroll-context)))))

  
  ;;;
  ;;;; Selection
  ;;;


  (method (cell->site cell)
    (if (is? cell Cell)
        (let ((column (get-column (get-col~ cell)))
              (row (get-row (get-line~ cell))))
          (new Site row column))
      cell))


  (method (row/column->site row column)
    (new Site row column))


  (method (site->cell site)
    (if (is? site Site)
        (let ((col (column->col (get-column~ site)))
              (line (row->line (get-row~ site))))
          (new Cell line col))
      site))


  (method public (process-selection cell shift? control?)
    (let ((element (case selection-mode ((cell) cell) (else (get-line~ cell)))))
      (if (and multiple-selection? (or shift? control?))
          (cond ((and shift? control?)
                 (set! selection-pivot element)
                 (unless (member? element selection)
                   (set-selection (list element) set-pivot?: #f user-origin?: #t)))
                (shift?
                 (unless (eq? selection-mode 'cell) ; unimplemented
                   (let ((pivot (or selection-pivot 0)))
                     (cond ((= element pivot) (set-selection (list element) set-pivot?: #f user-origin?: #t))
                           ((> element pivot) (set-selection (naturals pivot (+ element 1)) set-pivot?: #f user-origin?: #t))
                           ((< element pivot) (set-selection (naturals element (+ pivot 1)) set-pivot?: #f user-origin?: #t))))))
                (control?
                 (if (member? element selection)
                     (set-selection (remove element selection test: equal?) set-pivot?: #f user-origin?: #t)
                   (set-selection (cons element selection) set-pivot?: #f user-origin?: #t))
                 (when (and selection-pivot (= element selection-pivot))
                   (cond ((null? selection) (set! selection-pivot #f))
                         ((< selection-pivot (car selection)) (set! selection-pivot (car selection)))
                         ((> selection-pivot (last selection)) (set! selection-pivot (last selection)))))))
        (when (and (member? element selection) (allow-start-drag?~ selection-manager))
          (delay-selection~ selection-manager))
        (set! selection-pivot element)
        (set-selection (list element) set-pivot?: #f user-origin?: #t))))
  
  
  (method override (get-selection)
    selection)
  
  
  (method public (get-ordered-selection)
    (sort < selection))
  
  
  (method override (set-selection sel
                                  (force?: force? #f)
                                  (set-pivot?: set-pivot? #t)
                                  (ensure-displayed?: ensure-displayed? #t)
                                  (auto-expand?: auto-expand? #t)
                                  (generate-event?: generate-event? #t)
                                  (user-origin?: user-origin? #f))
    (define (inval-selection selection)
      (when (not-null? selection)
        (for-each (lambda (cell)
                    (let ((merge-cell (and (is? cell Cell) (get-merge-cell (cell->site cell)))))
                      (if merge-cell
                          (invalidate-merge-cell merge-cell)
                        (invalidate-selection (list cell)))))
                  selection)))
    
    (unless (locked?~ selection-manager)
      (reset~ locator)
      (when (change-selection?~ selection-manager)
        (let ((old-selection selection))
          (set! selection sel)
          (when set-pivot?
            (set! selection-pivot (if (null? selection) #f (car selection))))
          (inval-selection old-selection)
          (inval-selection selection)
          (when generate-event?
            (selection-change old-selection force? user-origin?))))
      (let ((auto-row (and (not-null? sel) (get-row (selection-row (car sel))))))
        (when (and auto-expand/collapse? auto-expand?)
          (unless multiple-selection?
            (when (or (not auto-row) (collapsed?~ auto-row))
              (auto-expand/collapse auto-row auto-toggle?: #t)))
          (when auto-row
            (auto-select~ auto-row))))
      (when (and ensure-displayed? (end-delayed?~ selection-manager))
        (ensure-displayed))))
  
  
  (method protected virtual (selection-change old-selection force? user-origin?)
    (with-locked-operation~ selection-manager
      (lambda ()
        (call-selection-handler old-selection selection force? user-origin?))))
  
  
  (method public (with-preserved-selection thunk (use: use 'row) (test: test eqv?) (ensure-displayed?: ensure-displayed? #t) (generate-event?: generate-event? #f))
    (define (save-selection selection)
      (case selection-mode
        ((cell) (map save-cell selection))
        (else (map save-row selection))))
    
    (define (save-cell cell)
      (cons (save-row (get-line~ cell)) (get-col~ cell)))
    
    (define (save-row row)
      (case use
        ((row) (get-row row))
        ((rank) row)
        ((data) (get-user-data~ (get-row row)))))
    
    (define (restore-selection saved-selection)
      (remove-false
        (case selection-mode
          ((cell) (map restore-cell saved-selection))
          (else (map restore-row saved-selection)))))
    
    (define (restore-cell saved)
      (bind (row . col) saved
        (let ((line (restore-row row)))
          (when line
            (new Cell line col)))))
    
    (define (restore-row saved)
      (case use
        ((row) (row->line saved))
        ((rank) saved)
        ((data) (user-data-index saved test: test))))
    
    (define (selection-position selection)
      (with ((region (selection-region selection 0 0 1.0)))
        (rect-position (get-box~ region))))
    
    (let ((saved-selection (save-selection (get-selection)))
          (saved-position (nu+ (get-scrolled-position) (selection-position (get-selection))))
          (saved-pivot (and selection-pivot (save-selection (list selection-pivot))))
          (saved-edited (and edited-cell (save-cell edited-cell))))
      (thunk)
      (when saved-pivot
        (let ((pivot (restore-selection saved-pivot)))
          (set! selection-pivot (cond ((not-null? pivot) (car pivot))
                                      ((null? selection) #f)
                                      (else (car selection))))))
      (when saved-edited
        (let ((edited (restore-cell saved-edited)))
          (if (not edited)
              (kill-edition)
            (set! edited-cell (get-master-cell edited))
            (replace-cell edited-cell cell-editor))))
      (let ((selection (restore-selection saved-selection)))
        (set-selection selection ensure-displayed?: ensure-displayed? generate-event?: generate-event? auto-expand?: #f)
        (scroll-to (nu- saved-position (selection-position selection))))))
  
  
  (method public (get-single-selection)
    (if (null? selection)
        #f
      (car selection)))
  
  
  (method public (set-single-selection sel . rest)
    (assert (or (integer? sel) (is? sel Cell)))
    (apply set-selection (list sel) rest))
  
  
  (method public (auto-select-first)
    (when (and (null? selection) (> (get-visible-count) 0))
      (set-selection (list 0))))
  
  
  (method (selected-row-proc)
    (case selection-mode
      ((cell)
       (lambda (cell)
         (get-row (get-line~ cell))))
      (else
       get-row)))
  
  
  (method public (get-selected-row)
    (let ((selection (get-single-selection)))
      (when selection
        ((selected-row-proc) selection))))
  
  
  (method public (get-selected-rows)
    (map (selected-row-proc) selection))
  
  
  (method public (get-selected-data)
    (map get-user-data~ (get-selected-rows)))
  
  
  (method public (get-single-selected-data)
    (let ((row (get-selected-row)))
      (when row
        (get-user-data~ row))))
  
  
  (method public (get-selection-data selection)
    (map (lambda (line)
           (let ((row (get-row line)))
             (get-user-data~ row)))
         selection))
  
  
  (method public (with-deleted-selection selection proc (can-survive?: can-survive? #f))
    (let ((data (and can-survive? (get-selection-data selection)))
          (smallest (apply min selection)))
      (proc)
      (let ((sel (and can-survive? (remove-false (map user-data-index data)))))
        (if (and can-survive? (= (length selection) (length sel)))
            (set-selection sel)
          (when (and smallest (> smallest 0))
            (let ((previous (- smallest 1)))
              (set-single-selection previous)))))))
  
  
  (method (selection->rows selection)
    (case selection-mode
      ((cell)
       (map (lambda (cell)
              (cons (get-visible-row (get-line~ cell)) (get-col~ cell)))
            selection))
      (else
       (map get-visible-row selection))))
  
  
  (method (rows->selection rows)
    (case selection-mode
      ((cell)
       (remove-false (map (lambda (pair)
                            (bind (row . col) pair
                              (new Cell (row-index row) col)))
                          rows)))
      (else
       (remove-false (map row-index rows)))))
  
  
  ;; update slots that are line based
  (method override (added-update-selection line count)
    (when (and edited-cell (>= (get-line~ edited-cell) line))
      (set-line~ edited-cell (+ (get-line~ edited-cell) count)))
    (let ((proc (case selection-mode
                  ((cell) (lambda (cell)
                            (let ((l (get-line~ cell)))
                              (if (>= l line)
                                  (new Cell (+ l count) (get-col~ cell))
                                cell))))
                  (else (lambda (l)
                          (if (>= l line)
                              (+ l count)
                            l))))))
      (set! selection (map proc selection))
      (when selection-pivot
        (let ((new-pivot (proc selection-pivot)))
          (when new-pivot
            (set! selection-pivot new-pivot))))))
  
  
  ;; update slots that are line based
  (method override (removed-update-selection line count)
    (when (and edited-cell (>= (get-line~ edited-cell) line))
      (set-line~ edited-cell (- (get-line~ edited-cell) count)))
    (let ((end-line (+ line count))
          (removed #f))
      (let ((proc (case selection-mode
                    ((cell) (lambda (cell)
                              (let ((l (get-line~ cell)))
                                (cond ((< l line)
                                       cell)
                                      ((>= l end-line)
                                       (new Cell (- l count) (get-col~ cell)))
                                      (else
                                       #f)))))
                    (else (lambda (l)
                            (cond ((< l line)
                                   l)
                                  ((>= l end-line)
                                   (- l count))
                                  (else
                                   #f)))))))
        (set! selection (collect (lambda (old)
                                   (let ((new (proc old)))
                                     (unless (or new removed)
                                       (set! removed old))
                                     new))
                                 selection))
        (when selection-pivot
          (let ((pivot (proc selection-pivot)))
            (set! selection-pivot (or pivot (and (not-null? selection) (car selection))))))
        removed)))

  
  (method override (selection-region sel dh dv sc)
    (define (element-region element)
      (case selection-mode
        ((cell) (new Region (acquire-delta dh dv sc (cell-rect element))))
        (else (selection-row-region element dh dv sc))))
    
    (let ((region (new Region)))
      (loop (for element in sel)
            (let ((merge-cell (safe-get-merge-cell (cell->site element))))
              (if merge-cell
                  (with ((row-region (new Region (acquire-delta dh dv sc (merge-cell-rect merge-cell)))))
                    (combine!~ region row-region 'or))
                (with ((row-region (element-region element)))
                  (combine!~ region row-region 'or)))))
      (let ((root-clipper (get-root-clipper)))
        (when root-clipper
          (with ((clipper (new Region root-clipper)))
            (combine!~ region clipper 'and))))
      region))
    
  
  (method override (selection-row-rect line)
    (let* ((row (get-row line))
           (node-left (row-text-left~ node-column row))
           (left (if (> (length columns-borders) 1)
                     (min node-left (car (second columns-borders)))
                   node-left))
           (top (get-v~ (get-position~ row)))
           (right columns-right))
      (new Rect (- left 3) top right (+ top (get-height~ row)))))
  
  
  (method (selection-row element)
    (case selection-mode
      ((cell) (get-line~ element))
      (else element)))
  
  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (cell-visible? cell)
    (and (< (get-line~ cell) visible-count)
         (< (get-col~ cell) (get-columns-count))))


  ;;;
  ;;;; Borders
  ;;;
  
  
  (definition (borders-left borders)
    (car borders))
  
  
  (definition (borders-right borders)
    (cdr borders))
  
  
  (definition (borders-width borders)
    (- (borders-right borders) (borders-left borders)))
  
  
  (method public (get-borders col)
    (element columns-borders col))
  
  
  (method public (column-width col)
    (bind (left . right) (get-borders col)
      (- right left)))
  

  ;;;
  ;;;; Coordinates
  ;;;
  
  
  ;; temp patch to be virtual...
  (method override (line-rect line <fx>) <Rect>
    (let* ((row   (get-row line))
           (left  (borders-left (car columns-borders)))
           (top   (get-v~ (get-position~ row)))
           (right columns-right))
      (new Rect left top right (+ top (get-height~ row)))))
  
  
  (method public (cell-position cell <Cell>) <Point>
    (let ((rect (cell-rect cell)))
      (new Point (get-left~ rect) (get-top~ rect))))
  
  
  (method public (cell-rect cell <Cell>) <Rect>
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (if merge-cell
          (merge-cell-rect merge-cell)
        (unmerged-cell-rect cell))))

  
  (method public (unmerged-site-rect site <Site>) <Rect>
    (let* ((borders (get-borders (column->col (get-column~ site))))
           (row (get-row~ site))
           (top (get-v~ (get-position~ row))))
      (new Rect (borders-left borders) top (borders-right borders) (+ top (get-height~ row)))))

  
  (method public (unmerged-cell-rect cell <Cell>) <Rect>
    (let* ((borders (get-borders (get-col~ cell)))
           (row (get-row (get-line~ cell)))
           (top (get-v~ (get-position~ row))))
      (new Rect (borders-left borders) top (borders-right borders) (+ top (get-height~ row)))))
  
  
  (method public (cell-region cell <Cell>) <Region>
    (new Region (cell-rect cell)))
  
  
  (method (cell-content-rect cell <Cell>) <Rect>
    (let* ((line    (get-line~ cell))
           (col     (get-col~ cell))
           (row     (get-row line))
           (top     (get-v~ (get-position~ row)))
           (data    (get-cell-data cell))
           (width   (column-width col))
           (borders (get-borders col))
           (left    (borders-left borders)))
      (offset-rect (content-rect~ (get-column col) row data width (get-height~ row)) left top)))
    
  
  (method (cell-text-rect cell <Cell>) <Rect>
    (let* ((line  (get-line~ cell))
           (col   (get-col~ cell))
           (row   (get-row line))
           (top   (get-v~ (get-position~ row)))
           (data  (get-cell-data cell))
           (width (column-width (get-node-column-index))))
      (offset-rect (text-rect~ (get-column col) row data width (get-height~ row) #f) 0 top)))


  (method public (view->tree pos <Point> (any?: any? #f) (uniform-height?: uniform-height? #f))
    (let ((line (if uniform-height? (quotient (get-v~ pos) default-row-height) (v->row (get-v~ pos))))
          (col (h->col (get-h~ pos))))
      (when (not line)
        (set! line (v->merged-cells-line (get-v~ pos))))
      (when (not col)
        (set! col (h->merged-cells-col (get-h~ pos))))
      (when (and line col (>= line 0))
        (let ((cell (new Cell line col)))
          (set! cell (get-top-cell cell))
          (if any?
              cell
            (when (cell-visible? cell)
              cell))))))


  (method public (call-with-view->tree pos <Point> proc)
    (call-with-v->row (get-v~ pos)
      (lambda (line v height)
        (if line
            (let ((col (h->col (get-h~ pos))))
              (if (and line col (>= line 0))
                  (let ((cell (new Cell line col)))
                    (if (cell-visible? cell)
                        (proc cell v height)
                      (proc #f #f #f)))
                (proc #f #f #f)))
          (proc #f #f #f)))))


  (method public (tree->view cell)
    (new Point
      (col->h (get-col~ cell))
      (row->v (get-line~ cell))))
  

  (method public (h->col h)
    (continuation-capture
      (lambda (return)
        (loop (for borders in columns-borders)
              (for col from 0 below (get-columns-count))
              (bind (left . right) borders
                (when (and (>= h left) (<= h right) (/= left right))
                  (continuation-return return col))))
        #f)))


  (method (col->h col)
    (borders-left (get-borders col)))


  (method public (h->merged-cells-col h)
    (continuation-capture
      (lambda (return)
        (loop (for merge-cell in merge-cell-list)
              (let ((rect (merge-cell-rect merge-cell)))
                (let ((left (get-left~ rect))
                      (right (get-right~ rect)))
                  (when (and (>= h left) (<= h right) (/= left right))
                    (continuation-return return (get-first-col~ merge-cell))))))
        #f)))


  (method public (v->merged-cells-line v)
    (continuation-capture
      (lambda (return)
        (loop (for merge-cell in merge-cell-list)
              (let ((rect (merge-cell-rect merge-cell)))
                (when rect
                  (let ((top (get-top~ rect))
                        (bottom (get-bottom~ rect)))
                    (when (and (>= v top) (<= v bottom) (/= top bottom))
                      (continuation-return return (get-first-line~ merge-cell)))))))
        #f)))
  
  
  ;;;
  ;;;; Embedded Edition
  ;;;
  
  
  (method public (in-edition?)
    edited-cell)
  
  
  (method public (edit-cell cell (editor: editor #f) (cover-spacing?: cover-spacing? #f) (close-editor?: close-editor? #t) (before-end: before-end #f) (after-end: after-end #f))
    (assert (not update-locked?))
    (assert (< (get-col~ cell) (get-columns-count)))
    (end-edition)
    (let ((rect (cell-editor-rect cell))
          (view (new Tree-Data-View
                  cover-spacing?: cover-spacing?
                  preserved-data: (get-cell-data cell)
                  before-end: before-end
                  after-end: after-end
                  visible?: #f
                  children: (list editor))))
      (replace-cell (get-top-cell cell) view)
      (set-rect~ view (acquire~ (get-parent~ view) self rect))
      (set! edited-cell cell)
      (set! cell-editor view)
      (set! close-cell-editor? close-editor?)
      (set-visible?~ view #t)))
  
  
  (method public (end-edition)
    (when edited-cell
      (let ((cell edited-cell)
            (editor cell-editor)
            (bounds (cell-editor-rect edited-cell))
            (before-end (get-before-end~ cell-editor))
            (after-end (get-after-end~ cell-editor)))
        (when before-end
          (before-end cell))
        (set! edited-cell #f)
        (set! cell-editor #f)
        (let ((preserved-data (get-preserved-data~ editor))
              (merge-cell (safe-get-merge-cell (cell->site cell))))
          (if merge-cell
              (replace-cell (get-master-cell~ merge-cell) preserved-data)
            (replace-cell cell preserved-data)))
        (if close-cell-editor?
            (close~ editor)
          (set-parent~ editor #f))
        (when after-end
          (after-end cell))
        (invalidate-rect bounds))))
  
  
  (method public (kill-edition)
    (when edited-cell
      (let ((cell edited-cell)
            (editor cell-editor))
        (set! edited-cell #f)
        (set! cell-editor #f)
        (if close-cell-editor?
            (close~ editor)
          (set-parent~ editor #f)))))
  
  
  (method public (replace-cell cell child)
    (replace-child~ (get-row (get-line~ cell)) (get-col~ cell) child))
  
  
  (method (cell-editor-rect cell)
    ;; quicky
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (if merge-cell
          (merge-cell-rect merge-cell)
        (let* ((line    (get-line~ cell))
               (col     (get-col~ cell))
               (row     (get-row line))
               (column  (get-column col))
               (top     (get-v~ (get-position~ row)))
               (cell    (get-cell-data cell))
               (width   (if show-header? (column-width col) (get-width)))
               (borders (get-borders col))
               (left    (borders-left borders))
               (h       (text-h~ column (get-level~ row)))
               (rect    (content-rect~ column row cell width (get-height~ row))))
          (offset-rect rect left top)))))
  
  
  (method public (cell-up cell)
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (let ((line (- (if merge-cell
                         (get-first-line~ merge-cell)
                       (get-line~ cell)) 1))
            (col (get-col~ cell)))
        (when (>= line 0)
          (new Cell line col)))))
  
  
  (method public (cell-down cell (validate? #t))
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (let ((line (+ (if merge-cell
                         (get-last-line~ merge-cell)
                       (get-line~ cell)) 1))
            (col (get-col~ cell)))
        (when (or (not validate?) (< line (get-visible-count)))
          (new Cell line col)))))
    
  
  (method public (cell-left cell)
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (let ((line (get-line~ cell))
            (col (- (if merge-cell
                        (get-first-col~ merge-cell)
                      (get-col~ cell)) 1)))
        (when (>= col 0)
          (new Cell line col)))))

  
  (method public (cell-right cell)
    (let ((merge-cell (safe-get-merge-cell (cell->site cell))))
      (let ((line (get-line~ cell))
            (col (+ (if merge-cell
                        (get-first-col~ merge-cell)
                      (get-col~ cell)) 1)))
        (when (< col (get-columns-count))
          (new Cell line col)))))
  
  
  (method public (select-up cell)
    (let ((sel (cell-up cell)))
      (when sel
        (end-edition)
        (select-cell sel))))
  
  
  (method public (select-down cell (validate? #t))
    (let ((sel (cell-down cell validate?)))
      (when sel
        (end-edition)
        (select-cell sel))))
    
  
  (method public (select-left cell)
    (let ((sel (cell-left cell)))
      (when sel
        (end-edition)
        (select-cell sel))))

  
  (method public (select-right cell)
    (let ((sel (cell-right cell)))
      (when sel
        (end-edition)
        (select-cell sel))))
  
  
  (method public virtual (select-cell cell)
    (set-single-selection (get-line~ cell)))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor)
    (new Tree-View-Descriptor)))


;;;
;;;; Locator
;;;


(class Tree-Locator extends Locator
  
  
  (slot tree)
  (slot column initialize #f)
  
  
  (method override (initialize tree . rest)
    (set! tree~self tree)
    (apply nextmethod rest))
  
  
  (method override (iterate proc)
    (define (prepare-iterate)
      (let ((sel (get-single-selection~ tree)))
        (case (get-selection-mode~ tree)
          ((cell)
           (set! column (if sel (get-col~ sel) 0))
           (cons (and sel (get-row~ tree (get-line~ sel)))
                 (lambda (row) (element (get-children~ row) column))))
          (else
           (cons (and sel (get-row~ tree sel))
                 (lambda (row) (car (get-children~ row))))))))
    
    (bind (row . proc2) (prepare-iterate)
      (for-each-visible-row~ tree
        (lambda (row line)
          (let* ((node (proc2 row))
                 (title (get-title~ node)))
            (proc title line)))
        start: (when row (if prefix row (get-next~ row)))
        wrap?: #t)))
  
  
  (method override (select line)
    (case (get-selection-mode~ tree)
      ((cell) (set-single-selection~ tree (new Cell line column)))
      (else (set-single-selection~ tree line)))))


;;;
;;;; Merge-Cell
;;;


(class Merge-Cell extends Object
  
  
  (slot master-cell    initialize #f  accessors generate)
  (slot merged-rows    initialize '() accessors generate)
  (slot merged-columns initialize '() accessors generate)
  (slot tree           initialize #f  accessors generate)
  
  
  (method override (initialize cell rows-list columns-list cells-tree)
    (nextmethod)
    (set! master-cell cell)
    (set! merged-rows rows-list)
    (set! merged-columns columns-list)
    (set! tree cells-tree))
  
 
  (method override (print printer readably)
    (print-unreadable self printer
      (lambda (printer)
        (let ((r (length merged-rows))
              (c (length merged-columns)))
          (format printer "{a} row{a} {a} column{a}" r (format-plural r) c (format-plural c))))))
  
  
  (method public (add-merged-row row)
    (set! merged-rows (cons row merged-rows)))
  
  
  (method public (for-each-cell proc)
    (for-each (lambda (row)
                (for-each (lambda (column)
                            (proc row column))
                          merged-columns))
              merged-rows))
  
  
  (method public (get-first-row)
    (first merged-rows))
  
  
  (method public (get-last-row)
    (last merged-rows))
  
  
  (method public (get-first-column)
    (first merged-columns))
  
  
  (method public (get-last-column)
    (last merged-columns))
  
  
  (method public (get-first-site)
    (new Site (get-first-row) (get-first-column)))
  
  
  (method public (get-last-site)
    (new Site (get-last-row) (get-last-column)))
  
  
  (method public (get-first-line)
    (let ((first-line #f))
      (for-each (lambda (row)
                  (when (get-visible?~ row)
                      (let ((line (row->line~ tree row)))
                        (when (or (not first-line)
                                  (< line first-line))
                          (set! first-line line)))))
                merged-rows)
      first-line))
  
  
  (method public (get-last-line)
    (let ((last-line 0))
      (for-each (lambda (row)
                  (when (get-visible?~ row)
                      (let ((line (row->line~ tree row)))
                        (when (> line last-line)
                          (set! last-line line)))))
                merged-rows)
      last-line))
  
  
  (method public (get-first-col)
    (let ((first-col #f))
      (for-each (lambda (column)
                  (when (get-visible?~ column)
                    (let ((col (column->col~ tree column)))
                      (when (or (not first-col)
                                (< col first-col))
                        (set! first-col col)))))
                merged-columns)
      first-col))
  
  
  (method public (get-last-col)
    (let ((last-col 0))
      (for-each (lambda (column)
                  (when (get-visible?~ column)
                      (let ((col (column->col~ tree column)))
                        (when (> col last-col)
                          (set! last-col col)))))
                merged-columns)
      last-col))


  (method public (get-first-cell)
    (let ((first-line (get-first-line))
          (first-col (get-first-col)))
      (if (and first-line first-col)
          (new Cell first-line first-col)
        #f)))


  (method public (get-last-cell)
    (let ((last-line (get-last-line))
          (last-col (get-last-col)))
      (new Cell last-line last-col)))
)


;;;
;;;; Design
;;;


(submodule design


(import (jazz.designer))


(class Tree-View-Descriptor extends Outline-View-Descriptor
  
  
  (form
    (<install>
      (<properties~>
        (<Property-Descriptor> name: portfolio title: "Portfolio"
          (<Portfolio-Domain>  name: domain))
        (<Property-Descriptor> name: show-header? title: "Show Header"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: selection-mode title: "Selection Mode")
        (<Property-Descriptor> name: multiple-selection? title: "Multiple Selection"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: can-select-empty? title: "Can Select Empty"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: show-unfocused-selection? title: "Show Unfocused Selection"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: focused-on-descendants? title: "Focused On Descendants"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: auto-expand/collapse? title: "Auto Expand/Collapse"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: cell-background title: "Cell Background")
        (<Property-Descriptor> name: empty-background title: "Empty Background")
        (<Property-Descriptor> name: filled-column title: "Filled Column")
        (<Property-Descriptor> name: column-spacing title: "Column Spacing")
        (<Property-Descriptor> name: reorderable? title: "Reorderable"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: content title: "Content"))))
  
  
  @too-many-icons!
  (method override (class-image class)
    {Image-Resource "Preferences"}))))
