;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Views
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.ui.view.View jazz


(import (jazz.designer)
        (jazz.graphic)
        (jazz.library)
        (jazz.locale)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.print)
        (jazz.ui.window)
        (jazz.ui.view)
        (jazz.ui.workspace)
        (jazz.utilities)
        (time))


(class View extends Drawing implements (Actionable Context-Provider)

  
  (property title                                initialize {}                 getter get-title           setter set-title)
  (property font                                 initialize {Font name: Label} getter get-font            setter set-font)
  (property background                           initialize {}                 getter get-background      setter set-background)
  (property auto-size?                           initialize #f                 getter get-auto-size?      setter set-auto-size?)
  (property tooltip?                             initialize #f                 getter get-tooltip?        setter set-tooltip?)
  (property tooltip-text                         initialize {}                 getter get-tooltip-text    setter set-tooltip-text)
  (property draggable?                           initialize #f                 getter get-draggable?      setter set-draggable?)
  (property drag-tolerance                       initialize 5                  accessors generate)
  (property enabled?                             initialize #t                 getter get-enabled?        setter set-enabled?)
  (property action                               initialize {}                 getter get-action          setter set-action)
  (property outline-view                         initialize {}                 accessors generate)
  (property offscreen?                 <bool>    initialize #f                 getter get-offscreen?      setter set-offscreen?)
  ;; not implemented yet
  (property layer                                initialize 0                  getter get-layer           setter set-layer)
  (property effect                               initialize {}                 getter get-effect          setter set-effect)
  (property user-data                            initialize {}                 accessors generate)

  
  (property cursor-update-handler                initialize {} accessors generate)
  (property mouse-enter-handler                  initialize {} accessors generate)
  (property mouse-hover-handler                  initialize {} accessors generate)
  (property mouse-leave-handler                  initialize {} accessors generate)
  (property mouse-down-handler                   initialize {} accessors generate)
  (property mouse-move-handler                   initialize {} accessors generate)
  (property mouse-up-handler                     initialize {} accessors generate)
  (property drag-move-handler                    initialize {} accessors generate)
  (property drag-up-handler                      initialize {} accessors generate)
  (property double-click-handler                 initialize {} accessors generate)
  (property current-drop-handler                 initialize {} accessors generate)
  (property receive-drop-handler                 initialize {} accessors generate)
  (property receive-files-handler                initialize {} accessors generate)
  (property context-menu-handler                 initialize {} accessors generate)
  (property key-press-handler                    initialize {} accessors generate)
  (property arrow-press-handler                  initialize {} accessors generate)
  (property escape-press-handler                 initialize {} accessors generate)
  (property backspace-press-handler              initialize {} accessors generate)
  (property return-press-handler                 initialize {} accessors generate)
  (property tab-press-handler                    initialize {} accessors generate)
  (property content-change-handler               initialize {} accessors generate)
  (property selection-handler                    initialize {} accessors generate)
  (property action-handler                       initialize {} getter get-action-handler           setter set-action-handler)

  
  (slot player                      <Window>     initialize {})
  (slot offscreen                                initialize {})
  (slot scroller                                 initialize {})
  (slot renderer                                 initialize {} accessors generate)
  (slot scaled?                     <bool>       initialize #f)
  (slot scaling                     <fl>         initialize 1.0)
  (slot previous-size               <Dimension+> initialize {})
  (slot update-locked?              <bool>       initialize #f)
  (slot scrollee-locked?            <bool>       initialize #f)
  (slot modified?                   <bool>       initialize #f)
  (slot hover-history                            initialize {})
  (slot hover-pulse                              initialize {})
  (slot tools-info                               initialize {})
  
  
  (definition inhibit-context-menu?
    #f)
  
  (method override (shortcut-update action-item));;abstract
  
  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (conclude rest)
    (nextmethod rest)
    (layout)
    (layout-scrollee))

  
  (method override (print printer readably)
    (print-unreadable self printer
      (lambda (printer)
        (format printer "{?{a} ~}{?{s} ~}{a} {a}" name title position size))))
  
  
  ;;;
  ;;;; Destruction
  ;;;
  
  
  (method public virtual (close-with-confirm)
    (close))


  (method override (close)
    (let ((mouse-in (get-mouse-in)))
      (when (and mouse-in (has-ascendant?~ mouse-in self))
        (set-mouse-in {})
        (call-mouse-leave~ mouse-in)))
    (when player
      (let ((focus (get-view-focus~ player)))
        (when (and focus (has-ascendant?~ focus self))
          (set-view-focus~ player {}))))
    (nextmethod))


  (method override (destroy)
    (nextmethod)
    (let ((parent parent)
          (rect (get-rect)))
      (let ((host (get-host)))
        (when host
          (view-destroyed~ host self)))
      (set-offscreen? #f)
      (set! player {})
      (when (is? parent View)
        (invalidate-rect~ parent rect))))
    
  
  ;;;
  ;;;; Aliases
  ;;;

  
  (method override (component-alias name)
    (case name
      ((:host) (get-host))
      ((:guest) (get-guest))
      ((:root) (get-root))
      ((:initiator) (popup-initiator))
      (else (nextmethod name))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (get-player)
    (unless player
      (set! player (essay parent (get-player~ parent))))
    player)
  
  
  (method public (set-player plr)
    (set! player plr)
    (when (and (not plr) (eq? self (get-mouse-in)))
      (set-mouse-in {})
      (call-mouse-leave))
    (for-each-view
      (lambda (view)
        (set-player~ view player))
      include-invisibles?: #t))
  
  
  (method public (in-player?)
    (boolean (get-player)))


  (method public (get-overlapped)
    (let ((player (get-player)))
      (when player
        (get-overlapped~ player))))
  
  
  (method public (different-overlapped? window)
    (or (not window) (neq? (get-overlapped) (get-overlapped~ window))))
  
  
  ;;;
  ;;;; Hosting
  ;;;


  (method public virtual (get-host)
    (find-ascendant Host-View))
  
  
  (method public virtual (get-guest)
    (let ((host (get-host)))
      (essay host (get-guest~ host))))
  
  
  (method public virtual (install-in-host host)
    )
  
  
  (method public virtual (uninstall-from-host host)
    )
  
  
  (method public virtual (save-guest designer session)
    )
  
  
  (method public (add-guest-preferences designer session . initargs)
    (unimplemented 'add-guest-preferences)
    @Guest-Preferences
    (let* ((host (get-host))
           (pref (new Guest-Preferences
                   position: (get-position)
                   size:     (get-size)
                   name:     (type-name (class-of self))
                   initargs: (cons position: (cons (get-position~ host)
                                                   (cons size: (cons (get-size~ host)
                                                                     initargs)))))))
      (add-child~ designer pref session design-events?: #f select?: #f)))
  
  
  (method public virtual (host-activate)
    )
  
  
  (method public virtual (host-deactivate)
    )
  
  
  (method public virtual (focus-default)
    (acquire-focus))
  
  
  (method public virtual (get-text-view)
    {})
  
  
  (method public (frame-guest?)
    (let ((host (get-host)))
      (and (is? host Frame-Host)
           (eq? (get-guest~ host) self))))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta protected virtual (dialog-class)
    Dialog)
  
  
  (method meta protected virtual (frame-class)
    Frame-Host)
  
  
  (method meta protected virtual (palette-class)
    Palette)
  
  
  (method meta protected virtual (docked-class)
    Docked-Host)
  
  
  (method meta protected virtual (toolbar-class)
    Toolbar-Host)
  
  
  (method meta protected virtual (host-icon)
    {Bitmap-Resource "Window"})
  
  
  (method meta protected virtual (host-title)
    {})
  
  
  (method meta protected virtual (host-position)
    {})
  
  
  (method meta protected virtual (host-size)
    {})
  
  
  (method public virtual (host-workspaces)
    '())
  
  
  (method public (effective-host-workspaces)
    (host-workspaces)
    @convert-external-name
    (let* ((pref (get-workspaces-preferences))
           (associations (get-associations~ pref))
           (external (external-name error?: #f)))
      (filter-inexistant-workspaces pref
        (either (essay external (assq external associations))
                (host-workspaces)))))
  
  
  (method (filter-inexistant-workspaces pref workspaces)
    (let ((names (map get-name~ (get-children~ pref))))
      (collect-if (lambda (name)
                    (memq? name names))
                  workspaces)))
  
  
  (method public (for-each-palette proc)
    (for-each (lambda (child)
                (cond ((is? child Splitter-View)
                       (for-each-palette~ child proc))
                      ((is? child Pad-View)
                       (for-each proc (get-children~ child)))
                      (else
                       (proc child))))
              children))
  
  
  (method public (find-palette type)
    (continuation-capture
      (lambda (return)
        (for-each-palette
          (lambda (palette)
            (when (is? palette Host-View)
              (let ((view (get-guest~ palette)))
                (when (is? view type)
                  (continuation-return return view))))))
        {})))
  
  
  (method public (find-host guest-type)
    (find-if (lambda (view)
               (and (is? view Host-View)
                    (is? (get-guest~ view) guest-type)))
             children))
  
  
  (method public (find-guest guest-type)
    (let ((host (find-host guest-type)))
      (when host
        (get-guest~ host))))
  
  
  (method public (collect-guest guest-type)
    (collect (lambda (view)
               (when (is? view Host-View)
                 (let ((guest (get-guest~ view)))
                   (when (is? guest guest-type)
                     guest))))
             children))


  (method public (get-frame)
    (get-host))
  
  
  (method public virtual (guest-icon)
    (host-icon~ (class-of self)))
  
  
  (method public virtual (focus-activate)
    )
  
  
  (method public virtual (focus-deactivate)
    )
  
  
  (method public virtual (maximize)
    )
  
  
  (method public virtual (restore)
    )
  
  
  ;;;
  ;;;; Tool
  ;;;
  
  
  (method public virtual (tool-preferences)
    {})
  
  
  ;; All this tool-info stuff remains to be done. The idea is to give
  ;; docked tools a place to persist information like the selection so that
  ;; when switching documents like designs, the selection is preserved...
  ;; Note: the show-invisibles? slot of Design-Book-View is clearly a handcoded
  ;; piece of code that could be redone using tool-infos
  (method (get-tools-info)
    (unless tools-info
      (set! tools-info (make-table test: eq?)))
    tools-info)
  
  
  (method public virtual (get-tool-info tool-name)
    (table-ref (get-tools-info) tool-name #f))
  
  
  (method public virtual (set-tool-info tool-name info)
    (table-set! (get-tools-info) tool-name info))
  
  
  ;;;
  ;;;; Palette
  ;;;
  
  
  (method public virtual (host-install)
    )
  
  
  (method public virtual (host-uninstall)
    )
  
  
  (method public virtual (client-activate)
    )
  
  
  (method public virtual (client-deactivate)
    )
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method public virtual (get-tools-view)
    {})
  
  
  (method public virtual (workspace-minimisable?)
    #t)
    
  
  ;;;
  ;;;; Dialog
  ;;;
  
  
  (method public virtual (validate-dialog)
    )
  
  
  (method public virtual (get-modal-result)
    {})
  
  
  (method public virtual (has-dialog-result?)
    #f)
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method public virtual (get-editor-view)
    {})
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public virtual (content-valid?)
    #t)
  
  
  (method public virtual (validate-content)
    )
  
  
  ;;;
  ;;;; Parent
  ;;;
  
  
  (method override (set-parent parent)
    (let ((previous-invalidater (essay player (invalidater))))
      (nextmethod parent)
      (set-player (if parent (get-player~ parent) {}))
      (when previous-invalidater
        (previous-invalidater))
      (when parent
        (invalidate-view))))
  
  
  ;;;
  ;;;; Outer
  ;;;
  
  
  (method public (outer-view limit)
    (let ((outer parent)
          (view self))
      (while (and outer (inner?~ outer view) (neq? view limit))
        (set! view outer)
        (set! outer (get-parent~ outer)))
      view))
  
  
  (method public virtual (inner? view)
    #f)
  
  
  ;;;
  ;;;; Title
  ;;;
  
  
  (method public virtual (get-title)
    title)
  
  
  (method public virtual (set-title value)
    (set! title value)
    (adjust-size))
  
  
  ;;;
  ;;;; Visibility
  ;;;


  (method override (show)
    (nextmethod)
    (invalidate-view))


  (method override (hide)
    (nextmethod)
    (invalidate-view))
  
  
  (method protected virtual (update-displayed)
    )
  
  
  ;;;
  ;;;; Enabled
  ;;;
  

  (method public virtual (get-enabled?)
    enabled?)


  (method public virtual (set-enabled? flag)
    (set! enabled? flag)
    (invalidate-view))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method override (get-scaled?)
    scaled?)


  (method override (set-scaled? value)
    (set! scaled? value)
    (update-displayed)
    (update-scrollbars)
    ;; Depending on whether it's the view's point of vue or it's parent
    ;; we either have to invalidate the view or its parent...
    (if parent
        (invalidate-view~ parent)
      (invalidate-view)))
  

  (method override (get-scaling)
    scaling)


  (method override (set-scaling value)
    (set! scaling (/ (round (* value 1000)) 1000)))

  
  ;;;
  ;;;; Actions
  ;;;
  

  (method public (get-action)
    action)


  (method public (set-action value)
    (set! action value)
    (let ((action-item (require-action-item action)))
      (when action-item
        (register-actionable~ action-item self))))

  
  ;;;
  ;;;; Actionable
  ;;;
  
  
  (method override (enabled-update action-item)
    (set-enabled? (get-enabled?~ action-item)))

  
  ;;;
  ;;;; Outline View
  ;;;


  (method public (outline-select (focus?: focus? #f))
    (let* ((row (outline-row))
           (rank (row-rank~ outline-view row))
           (elem (if (and (is? outline-view Tree-View) (eq? (get-selection-mode~ outline-view) 'cell)) (new Cell rank 0) rank)))
      (when focus?
        (acquire-focus~ outline-view))
      (set-selection~ outline-view (list elem))))
  
  
  (method public (outline-row)
    (find-ascendant Outline-Row))


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen?)
    offscreen?)
  
  
  (method override (set-offscreen? flag <bool>)
    (when (neq? flag offscreen?)
      (set! offscreen? flag)
      (when (not offscreen?)
        (close-offscreen))))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method override (get-layer)
    layer)
  
  
  (method override (set-layer value)
    (set! layer value))


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method override (get-effect)
    effect)
  
  
  (method override (set-effect value)
    (set! effect value))

  
  ;;;
  ;;;; User data
  ;;;


  ;;;
  ;;;; Lie
  ;;;
  
  
  (method override (get-lie-parent h <fl> v <fl> sc <fl>)
    (if (or (not parent) (not scaled?))
        (nextmethod h v sc)
      (get-lie-parent~ parent (+ (get-h~ position) (* h scaling)) (+ (get-v~ position) (* v scaling)) (* sc scaling))))

  
  ;;;
  ;;;; Global
  ;;;
  
  
  (method public (get-global) <Point>
    (+ (get-position-in-root~ player) (get-lie)))

  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method override (get-delta origin <View>)
    (let ((origin-player (get-player~ origin)))
      (if (and player origin-player (neq? player origin-player))
          (receive (h <fl> v <fl> sc <fl>) (get-lie-parent 0.0 0.0 1.0)
            (let ((delta <Point> (- (get-global~ origin) (get-global))))
              (values (* (get-h~ delta) sc) (* (get-v~ delta) sc) sc)))
        (nextmethod origin))))
  
  
  ;;;
  ;;;; Position
  ;;;
  
  
  (method override (default-position) <Point>
    {Point 0 0})
  

  (method override (set-position pos <Point>)
    (when (/= pos position)
      ;; todo: it is possible to invalidate more precisely
      (let ((inval? (and player (is? parent View))))
        (let* ((bounds (essay inval? (get-bounds)))
               (old (essay inval? (acquire~ parent self bounds))))
          (set! position pos)
          (when player
            (let ((new (get-bounds)))
              (when old
                (invalidate-rect~ parent old))
              (invalidate-rect new)))))
      (position-change position)))

  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method override (default-size) <Dimension>
    {Dimension 100 100})
  
  
  (method public virtual (minimal-size)
    {})
  
  
  (method public virtual (preferred-size) <Dimension>
    (get-size))
  
  
  (method public virtual (fit-size)
    )
  
  
  (method (invaled-size sz)
    (when (and player (is? parent View))
      (let ((old (get-bounds))
            (new (size-rect sz)))
        (acquire~ parent self (rect-union old new)))))
  

  (method override (set-size sz <Dimension>)
    (when (/= sz size)
      (let ((invaled-size (invaled-size sz)))
        (set! size sz)
        (size-change size)
        (unless scroller
          (content-size-change size))
        (when invaled-size
          (invalidate-rect~ parent invaled-size)))))
  
  
  (method override (set-size-noevent sz <Dimension>)
    (when (/= sz size)
      (let ((invaled-size (invaled-size sz)))
        (set! size sz)
        (when invaled-size
          (invalidate-rect~ parent invaled-size)))))
  
  
  (method public (set-preferred-size)
    (set-size (preferred-size)))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method public (layout-view)
    (layout-drawing))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method public (front-view)
    (last children))
  
  
  (method public (back-view)
    (first children))
  
  
  (method override (send-before target)
    (nextmethod target)
    (invalidate-view))
  
  
  (method override (bring-to-front)
    (nextmethod)
    (invalidate-view))


  (method override (send-to-back)
    (nextmethod)
    (invalidate-view))


  (method override (send-child-to-front child)
    (set! children (move-to-tail! child children)))


  (method override (send-child-to-back child)
    (set! children (move-to-head! child children)))

  
  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method protected virtual (scrollee-width)
    (get-width))
  
  
  (method protected virtual (scrollee-height)
    (get-height))

  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method public (get-update-locked?)
    update-locked?)
  
  
  (method public (with-update-locked proc)
    (if update-locked?
        (proc)
      (unwind-protect
          (begin
            (set! update-locked? #t)
            (proc))
        (set! update-locked? #f)
        (invalidate-update))))
  
  
  (method protected virtual (invalidate-update)
    (invalidate-view)
    (update-scrollbars))

  
  ;;;
  ;;;; Rendering
  ;;;
  

  (method override (render surface context lh lv sh sv sc sc?)
    (if renderer
        (render~ renderer self surface context lh lv sh sv sc sc?)
      (nextmethod surface context lh lv sh sv sc sc?)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method override (draw-background surface context)
    (let ((background (get-drawing-background context)))
      (when background
        (let ((bounds (get-bounds)))
          (fill-rect~ surface bounds background)))))
  
  
  (method public virtual (get-drawing-background context)
    background)
  
  
  (method override (draw-content surface context lh lv sh sv sc sc?)
    (set-font~ surface font)
    (draw surface context lh lv))


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen surface <Surface+>)
    (let ((width (get-width~ size))
          (height (get-height~ size)))
      (if (and offscreen
               (let ((size (get-size~ offscreen)))
                 (and (<= width (get-width~ size))
                      (<= height (get-height~ size)))))
          (begin
            (renew-context~ offscreen)
            offscreen)
        (close-offscreen)
        (set! offscreen (new-offscreen surface width height))
        offscreen)))
  
  
  (definition (new-offscreen surface <Surface> width <fx> height <fx>)
    (new Memory-Surface surface size: (new Dimension width height)))
  
  
  (method package (close-offscreen)
    (when offscreen
      (close~ offscreen)
      (set! offscreen {})))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (method public virtual (get-page-setup)
    (default-page-setup~ (get-application)))
  
  
  (method public virtual (get-page-setup-designer)
    (default-page-setup-designer~ (get-application)))
  
  
  (method public (get-page-setup-for name)
    (let* ((page-setup (get-page-setup))
           (branch (find-component~ page-setup name)))
      (when branch
        (set-active-branch~ page-setup branch))
      page-setup))

  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method public virtual (print-document)
    (platform-print-document self))
  
  
  (method public virtual (print-picture)
    (platform-print-picture self))

  
  (method public virtual (print-layout (from-preview?: from-preview? #f))
    (with-locked-update
      (lambda ()
        (let* ((client (current-document))
               (current (selected-workspace))
               (ws (new Page-Workspace name: 'page previous: current)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-palette~ toplevel Page-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-preview) (not from-preview?))
            (layout-view~ toolbar))
          (let* ((frame (new-frame Page-Editor host-title: "Print Layout" client: client))
                 (pane (get-guest~ frame)))
            (acquire-focus~ pane))))))
  

  (method public virtual (print-preview (from-layout?: from-layout? #f))
    (with-locked-update
      (lambda ()
        (let* ((frame (new-frame Preview-Pane host-title: "Print Preview" host-visible?: #f client: self))
               (pane (get-guest~ frame))
               (current (selected-workspace))
               (ws (new Preview-Workspace name: 'preview previous: current pane: pane)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-palette~ toplevel Preview-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-layout) (not from-layout?))
            (layout-view~ toolbar))
          (set-visible?~ frame #t)
          (acquire-focus~ pane)))))
  
  
  (method public virtual (get-print-area context)
    (position/size->rect {Point 0 0} (scrollee-size)))
  
  
  (method public virtual (paginate page-width page-height)
    (let* ((area (get-print-area {}))
           (width (rect-width area))
           (height (rect-height area))
           (cols (fxceiling/ width page-width))
           (rows (fxceiling/ height page-height))
           (pages (new List-Factory)))
      (for-each (lambda (row)
                  (for-each (lambda (col)
                              (let* ((h (+ (get-left~ area) (* col page-width)))
                                     (v (+ (get-top~ area) (* row page-height)))
                                     (page (new Rect h v (+ h page-width) (+ v page-height))))
                                (put~ pages page)))
                            (naturals 0 cols)))
                (naturals 0 rows))
      (get-output~ pages)))
  
  
  (method protected (with-printing proc)
    (let ((preserved {}))
      (unwind-protect
          (begin
            (set! preserved (setup-printing))
            (proc))
        (when preserved
          (restore-printing preserved)))))
  
  
  (method protected virtual (setup-printing)
    (let ((pos position)
          (sc? scaled?))
      (set! position (new Point 0 0))
      (set! scaled? #f)
      (update-displayed)
      (list position: pos scaled?: sc?)))
  
  
  (method protected virtual (restore-printing preserved)
    (set! position (getf preserved position:))
    (set! scaled? (getf preserved scaled?:))
    (update-displayed))
  
  
  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (export-picture (context: context '()) (where: where 'file) (destination: destination {}))
    (with-closed ((surface (new Memory-Surface {} size: (get-size))))
      (setup-clipper~ surface (new Rect 0 0 (get-width) (get-height)))
      (paint-drawing surface context 0 0 0 0 1.0 #f)
      (export-to-png~ surface (either destination (choose-new-file default-extension: "png")))))


  @convert
  (method public (export-picture (context: context {}) (where: where 'file) (destination: destination {}))
    ;; it is necessary to use a temporary file because directly poping
    ;; the savefile dialog can disrupt the context (ex: popups closing)
    (let ((file (case where ((clipboard) {}) ((file) (create-temporary-file)))))
      (with-cursor :wait
        (lambda ()
          (let ((metafile))
            (with-closed ((picture (new Picture file: file)))
              (with-printing
                (lambda ()
                  (let* ((area (get-print-area context))
                         (lie (get-lie))
                         (lh (get-h~ lie))
                         (lv (get-v~ lie)))
                    (let ((content (offset-rect area lh lv)))
                      (with-clipper~ picture content
                        (lambda ()
                          (paint-drawing picture context lh lv (get-left~ content) (get-top~ content) 1.0 #f)))))))
              (set! metafile (get-metafile~ picture)))
            (if (eq? where 'clipboard)
                (set-clipboard-metafile metafile)
              (delete-metafile~ Picture metafile)
              (catch (Cancel-Signal
                       (delete-file~ file))
                (let ((dest (either destination (choose-new-file default-extension: "emf" extensions: '(("Enhanced metafiles" . "emf"))))))
                  (when (exists?~ dest)
                    (delete-file~ dest))
                  (move-pathname~ file dest)))))))))


  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method public (get-scroller)
    scroller)
  
  
  (method public virtual (set-scroller view)
    (set! scroller view))
  
  
  (method public virtual (set-scroll-pos part pos redraw?)
    (when scroller
      (set-scroll-pos~ scroller part pos redraw?)))
    
  
  (method public virtual (set-scroll-info part min max page)
    (when scroller
      (set-scroll-info~ scroller part min max page)))
  
  
  (method public (update-scrollbars)
    (when (and scroller (not update-locked?))
      (let ((min  0)
            (max  (get-height))
            (page (get-page-size 'vert)))
        (set-vscroll-needed?~ scroller (> max page))
        (when (get-vscroll?~ scroller)
          (set-scroll-info 'vert min max page)))
      (let ((min  0)
            (max  (- (get-width) (if (get-vscroll?~ scroller) 13 0)))
            (page (get-page-size 'horz)))
        (set-hscroll-needed?~ scroller (> max page))
        (when (get-hscroll?~ scroller)
          (set-scroll-info 'horz min max page)))))
  
  
  (method public (vscroll-needed?)
    (> (get-height) (get-page-size 'vert)))
  
  
  (method public (hscroll-needed?)
    (> (- (get-width) (if (get-vscroll?~ scroller) 13 0)) (get-page-size 'horz)))
  
  
  (method public (scroll delta <Point>)
    (unless (= delta {Point 0 0})
      (scroll-to (+ (get-scrolled-position) delta))))
  
  
  (method public (scroll2 delta <Point>)
    (unless (= delta {Point 0 0})
      (scroll-to2 (+ (get-scrolled-position) delta))))
  
  
  (method public (scroll-to dest <Point>)
    (let ((pos (get-scrolled-position)))
      ;; dest and pos are in this view coordinates
      (when (/= dest pos)
        (let* ((size (get-size))
               (display (get-display))
               (display-size (get-size~ display))
               (sc (if scaled? scaling 1.0))
               (min-h (- (/ (get-width~ display-size) sc) (get-width~ size)))
               (min-v (- (/ (get-height~ display-size) sc) (get-height~ size)))
               (max-h 0)
               (max-v 0)
               (h (fxround (min (max (get-h~ dest) min-h) max-h)))
               (v (fxround (min (max (get-v~ dest) min-v) max-v)))
               (new-pos (new Point (fxround (* h sc)) (fxround (* v sc)))))
          (when (/= new-pos position)
            (set! position (new Point (fxround (* h sc)) (fxround (* v sc))))
            (let ((scrolled (get-scrolled-position)))
              (set-scroll-pos 'horz (- h) #t)
              (set-scroll-pos 'vert (- v) #t))
            (update-scrollbars)
            (let ((dh (- h (get-h~ pos)))
                  (dv (- v (get-v~ pos))))
              (scroll-invalidate dh dv)
              ;; temp for testing...
              (if scaled?
                  ;; convert to-fix scroll-view bugs when used from thumb-track
                  (invalidate-view~ scroller)
                (let ((rect (get-bounds~ display))
                      (clip-rect (acquire~ display self (get-clipper))))
                  (scroll-view~ display dh dv rect clip-rect: clip-rect)))))))))
  
  
  (method public (scroll-to2 dest <Point>)
    (let ((pos (get-scrolled-position)))
      ;; dest and pos are in this view coordinates
      (when (/= dest pos)
        (let* ((size (get-size))
               (display (get-display))
               (display-size (get-size~ display))
               (sc (if scaled? scaling 1.0))
               (min-h (- (/ (get-width~ display-size) sc) (get-width~ size)))
               (min-v (- (/ (get-height~ display-size) sc) (get-height~ size)))
               (max-h 0)
               (max-v 0)
               (h (fxround (min (max (get-h~ dest) min-h) max-h)))
               (v (fxround (min (max (get-v~ dest) min-v) max-v)))
               (new-pos (new Point (fxround (* h sc)) (fxround (* v sc)))))
          (when (/= new-pos position)
            (set! position (new Point (fxround (* h sc)) (fxround (* v sc))))
            (let ((scrolled (get-scrolled-position)))
              (set-scroll-pos 'horz (- h) #t)
              (set-scroll-pos 'vert (- v) #t))
            (update-scrollbars)
            (let ((dh (- h (get-h~ pos)))
                  (dv (- v (get-v~ pos))))
              (scroll-invalidate dh dv)
              ;; temp for testing...
              (if scaled?
                  ;; convert to-fix scroll-view bugs when used from thumb-track
                  (invalidate-view~ scroller)
                (scroll-view2 dh dv (get-bounds)))))))))
  
  
  (method protected virtual (redraw-scrollbars)
    )
  
  
  (method protected virtual (scroll-invalidate dh dv)
    )
    
  
  (method public (scroll-view dh dv rect (clip-rect: clip-rect {}))
    (let ((player (get-player))
          (root (get-root))
          (display (get-display)))
      (when (and player (view-visible?))
        (let ((acquired (acquire~ root self rect))
              (clip-rect (acquire~ root display (either clip-rect (get-display-rect)))))
          (receive (h v sc) (get-lie-parent 0.0 0.0 1.0)
            (scroll-window~ player (fxround (* dh sc)) (fxround (* dv sc)) acquired clip-rect: clip-rect))))))
  
  
  (method public (scroll-view2 dh dv rect)
    (let ((player (get-player))
          (root (get-root)))
      (when player
        (let ((acquired (acquire~ root self rect))
              (clip-rect (acquire~ root self (get-clipper))))
          (scroll-offscreen~ root dh dv acquired clip-rect)))))
  
  
  (method (scroll-offscreen dh dv src-rect clip-rect)
    (with-closed ((surface (get-surface)))
      (let* ((src-rect (rect-intersection src-rect clip-rect))
             (dst-rect (offset-rect src-rect dh dv))
             (modified-rect (rect-intersection (rect-union src-rect dst-rect) clip-rect))
             (new-clipper (rect-intersection modified-rect dst-rect))
             (offscreen (get-offscreen {})))
        (set-source-surface~ surface offscreen dh dv)
        (draw-rectangle~ surface new-clipper)
        (fill~ surface)
        (set-source-surface~ offscreen offscreen dh dv)
        (draw-rectangle~ offscreen new-clipper)
        (fill~ offscreen)
        (let ((ml (get-left~ modified-rect))
              (mt (get-top~ modified-rect))
              (mr (get-right~ modified-rect))
              (mb (get-bottom~ modified-rect)))
          (when (< dh 0)
            (invalidate-rect (new Rect (+ mr dh) mt mr mb)))
          (when (< dv 0)
            (invalidate-rect (new Rect ml (+ mb dv) mr mb)))
          (when (> dh 0)
            (invalidate-rect (new Rect ml mt (+ ml dh) mb)))
          (when (> dv 0)
            (invalidate-rect (new Rect ml mt mr (+ mt dv))))))))
 
  
  (method public (get-scrolled-position) <Point>
    (- (get-display-position)))
 
  
  (method public (get-scrolled-h) <fx>
    (get-h~ (get-scrolled-position)))
 
  
  (method public (get-scrolled-v) <fx>
    (get-v~ (get-scrolled-position)))
  
  
  (method public (set-scrolled-position pos <Point>)
    (when scroller
      (set-position pos)))
  
  
  (method public virtual (get-scroll-client)
    self)
  
  
  (method public virtual (get-line-size orientation) <fx>
    (case orientation
      ((vert) 13)
      ((horz) 8)))
  
  
  (method public virtual (get-page-size orientation) <fx>
    (let ((size
           (case orientation
             ((vert) (get-height~ parent))
             ((horz) (get-width~ parent)))))
      (if (not scaled?)
          size
        (fxround (/ size scaling)))))
  
  
  (method public (with-scrollee-locked proc)
    (if scrollee-locked?
        (proc)
      (unwind-protect
          (begin
            (set! scrollee-locked? #t)
            (proc))
        (set! scrollee-locked? #f))))
  
  
  (method public virtual (layout-scrollee)
    (unless update-locked?
      (if (not scroller)
          (layout-scrollee-content)
        (let ((size (scrollee-size)))
          (when size
            (set-size size)
            (fit-in-scroller)
            ;; prevents multiple useless layouts that can occur when update scrollbars
            ;; resizes a view that will call layout-scrollee in response (ex: tree header)
            (unless scrollee-locked?
              ;; it is important to update scrollbars first as this can change
              ;; the scrollee size and we do not want to layout twice for nothing
              (with-scrollee-locked
                (lambda ()
                  (update-scrollbars)))
              (layout-scrollee-content)))))))
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method public virtual (layout-scrollee-patch)
    )
  
  
  (method public virtual (layout-scrollee-content)
    )
  
  
  (method (fit-in-scroller)
    (let ((bottom (get-bottom))
          (fit (get-display-height)))
      (when (< bottom fit)
        (scroll (new Point 0 (- fit bottom)))))
    (let ((right (get-right))
          (fit (get-display-width)))
      (when (< right fit)
        (scroll (new Point (- fit right) 0)))))
  
  
  (method public virtual (scrollee-size) <Dimension>
    (get-size))


  (method package virtual (on-vscroll code thumb-pos orientation)
    )


  (method package virtual (on-hscroll code thumb-pos orientation)
    )


  ;;;
  ;;;; Display
  ;;;


  ;; to-convert clean all this by having the callers use (get-display)...
  
  
  (method public virtual (content-size-change size)
    )

  
  (method public (get-display)
    (if scroller
        parent
      self))
  
  
  (method public (get-display-position) <Point>
    (if scroller
        (let ((pos <Point> (- (get-position))))
          (if (not scaled?)
              pos
            (new Point
              (fxround (/ (get-h~ pos) scaling))
              (fxround (/ (get-v~ pos) scaling)))))
      {Point 0 0}))
    
  
  (method public (get-display-h) <fx>
    (get-h~ (get-display-position)))
    
  
  (method public (get-display-v) <fx>
    (get-v~ (get-display-position)))
    
  
  (method public (get-display-size) <Dimension>
    (if scroller
        (let ((size <Dimension> (get-size~ parent)))
          (if (not scaled?)
              size
            (new Dimension (fxround (/ (get-width~ size) scaling)) (fxround (/ (get-height~ size) scaling)))))
      (get-size)))
    
  
  (method public (get-display-width) <fx>
    (if scroller
        (get-width~ (get-display-size))
      (get-width)))
    
  
  (method public (get-display-height) <fx>
    (if scroller
        (get-height~ (get-display-size))
      (get-height)))
  
  
  (method public (get-display-rect) <Rect>
    (if scroller
        (get-bounds~ parent)
      (get-bounds)))
  
  
  (method public (view->display pos <Point>) <Point>
    (if scroller
        (if (not scaled?)
            (+ pos position)
          (new Point (fxround (+ (get-h~ pos) (/ (get-h~ position) scaling))) (fxround (+ (get-v~ pos) (/ (get-v~ position) scaling)))))
      pos))

  
  (method public (h-view->display h <fx>) <fx>
    (if scroller
        (+ h (get-h~ (get-scrolled-position)))
      h))

  
  (method public (v-view->display v <fx>) <fx>
    (if scroller
        (+ v (get-v~ (get-scrolled-position)))
      v))

  
  (method public (display->view pos <Point>) <Point>
    (if scroller
        (- pos (get-scrolled-position))
      pos))

  
  (method public (h-display->view h) <fx>
    (if scroller
        (- h (get-h~ (get-scrolled-position)))
      h))

  
  (method public (v-display->view v) <fx>
    (if scroller
        (- v (get-v~ (get-scrolled-position)))
      v))
  
  
  (method public (scroll-needed start end context (force-vertical: force-vertical {}) (force-horizontal: force-horizontal {}) (reposition?: reposition? #f) (center?: center? #f)) <Point>
    (let ((display-pos (get-display-position))
          (display-size (get-display-size))
          (needed
            (lambda (start end context pos size force-direction center?)
              (let* ((start-offset (- pos start))
                     (end-offset (- (+ pos size) end))
                     (big-range? (> (- end start) size))
                     (proc (lambda (use-head?)
                             (let ((context (if context (fxround (* size context)) 0)))
                               (if use-head? (+ start-offset context) (- end-offset context))))))
                (cond
                  (center? (if (and (< start-offset 0) (> end-offset 0)) 0 (quotient (+ start-offset end-offset) 2)))
                  (reposition? (proc (neq? force-direction 'tail)))
                  ((and (> start-offset 0) (> end-offset 0)) (proc (if (not force-direction) (not big-range?) (eq? force-direction 'head))))
                  ((and (< start-offset 0) (< end-offset 0)) (proc (if (not force-direction) big-range? (eq? force-direction 'head))))
                  (else 0))))))
      (new Point
        (needed (get-h~ start) (get-h~ end) (essay context (car context)) (get-h~ display-pos) (get-width~ display-size) force-horizontal #f)
        (needed (get-v~ start) (get-v~ end) (essay context (cdr context)) (get-v~ display-pos) (get-height~ display-size) force-vertical center?))))
  
  
  (method public (horizontal-scroll-needed target direction) <fx>
    (let* ((start (get-display-h))
           (end (+ start (get-display-width))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))
  
  
  (method public (vertical-scroll-needed target direction) <fx>
    (let* ((start (get-display-v))
           (end (+ start (get-display-height))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))


  ;;;
  ;;;; Font
  ;;;


  (method public (get-font)
    font)
  

  (method public virtual (set-font fnt)
    (set! font fnt)
    (adjust-size))

  
  ;;;
  ;;;; Background
  ;;;
  
  
  (method public (get-background)
    background)
  
  
  (method public (set-background color)
    (set! background color)
    (invalidate-view))
  
  
  ;;;
  ;;;; Sizing
  ;;;
  

  (method public (get-auto-size?)
    auto-size?)


  (method public (set-auto-size? value)
    (set! auto-size? value)
    (adjust-size))
  
  
  (method public (adjust-size)
    (if (not auto-size?)
        (invalidate-view)
      (set-preferred-size)))

  
  ;;;
  ;;;; Iterate
  ;;;
  
  
  (method public (for-each-view proc (include-invisibles?: include-invisibles? #f))
    (loop (for child in children)
          (when (and (is? child View)
                     (or include-invisibles? (get-visible?~ child)))
            (proc child))))
  
  
  (method public (for-each-view-reversed proc (include-invisibles?: include-invisibles? #f))
    (let ((proc
            (lambda (child)
              (when (and (is? child View)
                         (or include-invisibles? (get-visible?~ child)))
                (proc child)))))
      (for-each-reversed proc children)))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-mouse-view pos)
    (either (get-captured-view)
            (find-drawing pos)))


  ;;;
  ;;;; Children
  ;;;


  (method public (first-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (first views))))


  (method public (second-view)
    (let ((views (get-views)))
      (if (>= (length views) 2)
          (second views)
        #f)))


  (method public (last-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (last views))))
    
  
  (method public (get-views (include-invisibles?: include-invisibles? #f))
    (reverse!
      (collect-if
        (lambda (child)
          (and (is? child View)
               (or include-invisibles? (get-visible?~ child)))) (get-children))))
  

  (method public (front-view?)
    (eq? self (first-view~ parent)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions)
    (cons (find-actions 'view)
          (nextmethod)))
  
  
  (method override (guest-actions)
    (cons (find-actions 'guest)
          (nextmethod)))


  ;;;
  ;;;; Content
  ;;;


  (method (call-content-change origin)
    (if (not content-change-handler)
        (content-change origin)
      (let ((event (new Event :change self (list origin: origin))))
        (invoke~ content-change-handler self event))))
  
  
  (method public virtual (content-change origin)
    )


  ;;;
  ;;;; Selection
  ;;;
  

  (method public (call-selection-handler old selection force? user-origin?)
    (when selection-handler
      (invoke~ selection-handler self (new Selection-Event :selection-change self old selection force?: force? user-origin?: user-origin?))))


  ;;;
  ;;;; Modified State
  ;;;


  (method public virtual (get-modified?)
    modified?)


  (method public virtual (set-modified? state)
    (when (neq? state modified?)
      (set! modified? state)))

  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method public virtual (position-change position <Point>)
    )
  
  
  (method public virtual (size-change size <Dimension>)
    (let ((pw (essay previous-size (get-width~ previous-size)))
          (ph (essay previous-size (get-height~ previous-size)))
          (width (get-width~ size))
          (height (get-height~ size)))
      (set! previous-size size)
      (when pw
        (let ((dh (- width pw))
              (dv (- height ph)))
          (when (or (/= dh 0) (/= dv 0))
            (resize dh dv)))))
    (invalidate-layout)
    (when (get-finished?)
      (call-layout)))


  (method protected virtual (resize dh <fx> dv <fx>)
    )

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (acquire-focus)
    (set-focus self))


  (method public (call-focus-gain)
    (set-focus-actions~ (get-application) (get-focus-actions self))
    (focus-gain))


  (method public (call-focus-lose)
    (set-focus-actions~ (get-application) '())
    (focus-lose))
  
  
  (method public (has-focus?)
    (eq? self (get-focus)))
  
  
  (method public virtual (focus-lose)
    )
  
  
  (method public virtual (focus-master)
    self)
  
  
  (method public virtual (focus-gain)
    )
  
  
  (method public virtual (focus-delegate)
    )
  
  
  (method public virtual (focus-update-actions)
    )


  ;;;
  ;;;; Action
  ;;;
  
  
  (method public (get-action-handler)
    action-handler)
  
  
  (method public virtual (set-action-handler x)
    (set! action-handler x))


  (method public virtual (process-action sender (properties (action-properties)))
    (notify-action sender properties))
  
  
  (method protected virtual (action-properties)
    {})
  
  
  (method public (notify-action sender properties)
    (if (not action-handler)
        (when action
          (call-action action sender properties))
      (let* ((properties (either properties (get-properties~ action-handler)))
             (event (apply new Action-Event :action sender properties)))
        (invoke~ action-handler self event))))
  
  
  ;;;
  ;;;; Receive Files
  ;;;

  
  (method protected (dispatch-receive-files pos files)
    (let ((view (find-mouse-view pos)))
      (when view
        (let ((view-pos (acquire~ view self pos)))
          (call-receive-files~ view view-pos files)))))

  
  (method public (call-receive-files pos files)
    (if receive-files-handler
        (invoke~ receive-files-handler self (new Event :receive-files self position: pos files: files))
      (receive-files pos files)))
  
  
  (method public virtual (receive-files pos pathnames)
    (let ((appl (get-application)))
      (receive-files~ appl pos pathnames)))


  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (call-cursor-update pos)
    (if (not cursor-update-handler)
        (cursor-update pos)
      (let ((event (new Cursor-Event :set-cursor self pos)))
        (invoke~ cursor-update-handler self event))))
  
  
  (method public virtual (cursor-update pos)
    (unless (current-drag-drop)
      (set-cursor :arrow)))
  
  
  (method public (mouse-pressed?)
    mouse-down?)
  
  
  (method public (mouse-right-pressed?)
    (get-mouse-right-down?))
  
  
  (method public (mouse-in?)
    (eq? self (get-mouse-in)))
  
  
  (method public (mouse-over?)
    (over-view? (mouse-position)))


  (method public (over-view? point)
    (let ((bounds (get-bounds)))
      (in-rect? point bounds)))


  (method public (mouse-position)
    (let ((player (get-player))
          (root (get-root)))
      (acquire root (mouse-position~ player))))


  ;;;
  ;;;; Mouse
  ;;;
    
  
  (method (call-mouse-hover pos)
    (if mouse-hover-handler
        (invoke~ mouse-hover-handler self (new Mouse-Event :mouse-hover self pos))
      (mouse-hover pos))
    (when (get-tooltip?)
      (popup-tooltip pos)))
  
  
  (method protected (dispatch-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view event: 'mouse-down)
        (let ((actual-focus (get-focus))
              (acquired (acquire~ view self pos)))
          (set-mouse-down? #t)
          (set-mouse-down-view view)
          (set-mouse-down-point acquired)
          (unless (and (alt-down?) actual-focus (mouse-copy~ view acquired actual-focus))
            (when (mouse-activate?~ view)
              (let ((host (get-host~ view)))
                (when (and host (mouse-activate?~ host) (not (focused-host? host)))
                  (mouse-activate~ host))))
            (call-mouse-down~ view acquired)
            (call-cursor-update~ view acquired))))))

  
  (method public (call-mouse-down pos)
    (if mouse-down-handler
        (invoke~ mouse-down-handler self (new Mouse-Event :mouse-down self pos))
      (mouse-down pos)))
  
  
  (method protected (dispatch-mouse-move h v)
    (let ((pos (new Point h v)))
      (let ((view (find-mouse-view pos)))
        (when view
          (unless (is? (get-overlapped) Tooltip)
            (let ((player (get-player~ view)))
              (when (neq? view (get-mouse-in))
                (when (get-mouse-in)
                  (call-mouse-leave~ (get-mouse-in))
                  (cancel-mouse-leave-tracking (get-handle~ player))
                  (unless (or (is? player Tooltip) (in-tooltip? pos))
                    (cancel-tooltip-tracking)))
                (set-mouse-in view)
                (when (get-mouse-in)
                  (call-mouse-enter~ (get-mouse-in)))
                (track-mouse-leave (get-handle~ player)))
              (unless (or *current-tooltip-context* (current-drag-drop))
                (track-tooltip~ (get-mouse-in)))
              (if mouse-down?
                  (let ((acquired (acquire~ mouse-down-view self pos)))
                    (call-cursor-update~ mouse-down-view acquired)
                    (process-drag-move~ mouse-down-view acquired))
                (let ((acquired (acquire~ view self pos)))
                  (call-cursor-update~ view acquired)
                  (process-mouse-move~ view acquired)))))))))

  
  (method (process-mouse-move pos)
    (when *current-tooltip-context*
      (process-tooltip pos))
    (call-mouse-move pos))
  
  
  (method (call-mouse-move pos)
    (if mouse-move-handler
        (let ((event (new Mouse-Event :mouse-move self pos)))
          (invoke~ mouse-move-handler self event))
      (mouse-move pos)))
  
  
  (method protected (dispatch-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when mouse-down?
        (process-drag-up~ mouse-down-view (acquire~ mouse-down-view self pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (call-cursor-update~ view acquired)
          (process-mouse-up~ view acquired))))
    (when (get-delayed-mouse-action)
      (let ((action (get-delayed-mouse-action)))
        (set-delayed-mouse-action {})
        (action))))

  
  (method (process-mouse-up pos)
    (when (current-drag-drop)
      (drag-drop (current-drag-drop) pos))
    (call-mouse-up pos))

  
  (method (call-mouse-up pos)
    (if mouse-up-handler
        (invoke~ mouse-up-handler self (new Mouse-Event :mouse-up self pos))
      (mouse-up pos)))

  
  (method (process-drag-move pos)
    (if (and (eq? self mouse-down-view) (get-draggable?) (or (not (current-drag-drop)) (eq? self (get-view~ (get-source~ (current-drag-drop))))))
        (begin
          (when (allow-start-drag? pos)
            (let ((drag-drop (get-drag-drop)))
              (when drag-drop
                (drag-start pos (nu- mouse-down-point (get-drag-hotspot)) drag-drop))))
          (when (current-drag-drop)
            (drag-follow pos)))
      (call-drag-move pos)))
  
  
  (method protected virtual (allow-start-drag? pos)
    (and mouse-down? (not (current-drag-drop)) (not (near? pos mouse-down-point drag-tolerance))))
  
  
  (method (call-drag-move pos)
    (if drag-move-handler
        (invoke~ drag-move-handler self (new Mouse-Event :drag-move self pos))
      (drag-move pos)))

  
  (method (process-drag-up pos (dragging? (current-drag-drop)))
    (set-mouse-down? #f)
    (set-mouse-down-view {})
    (set-mouse-down-point {})
    (when player
      (call-drag-up pos dragging?)))

  
  (method (call-drag-up pos dragging?)
    (if drag-up-handler
        (invoke~ drag-up-handler self (new Mouse-Event :drag-up self pos))
      (drag-up pos dragging?)))
  
  
  (method protected (dispatch-double-click h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view event: 'double-click)
        (let ((acquired (acquire~ view self pos)))
          (set-mouse-down? #t)
          (set-mouse-down-view view)
          (set-mouse-down-point acquired)
          (when (mouse-activate?~ view)
            (let ((host (get-host~ view)))
              (when (and host (mouse-activate?~ host) (not (focused-host? host)))
                (mouse-activate~ host))))
          (call-double-click~ view (acquire~ view self pos))))))
  
  
  (method public virtual (call-double-click pos)
    (if double-click-handler
        (invoke~ double-click-handler self (new Mouse-Event :double-click self pos))
      (double-click pos)))
  
  
  (method protected (dispatch-context-menu h v)
    (if inhibit-context-menu?
        (set! inhibit-context-menu? #f)
      (let* ((pos (new Point h v))
             (view (find-mouse-view pos)))
        (when (and view (get-enabled?~ view))
          (close-popups~ view event: 'context-menu)
          (call-context-menu~ view (acquire~ view self pos))))))
  
  
  (method public (call-context-menu pos)
    (if context-menu-handler
        (invoke~ context-menu-handler self (new Mouse-Event :context-menu self pos))
      (context-menu pos)))
  
  
  (method protected (dispatch-middle-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-middle-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set-mouse-right-down? #t)
      (when view
        (right-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set-mouse-right-down? #f)
      (when view
        (right-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method (call-mouse-enter)
    (if mouse-enter-handler
        (invoke~ mouse-enter-handler self (new Mouse-Event :mouse-enter self {}))
      (mouse-enter)))
  
  
  (method (call-mouse-leave)
    (cancel-hovering)
    (close-self-tooltip)
    (if mouse-leave-handler
        (invoke~ mouse-leave-handler self (new Mouse-Event :mouse-leave self {}))
      (mouse-leave)))
  
  
  (method public virtual (mouse-hover pos)
    )
  
  
  (method public virtual (mouse-wheel pos delta)
    (when (get-scroller)
      (if (shift-down?)
          (begin
            (scroll (new Point (quotient delta 3) 0))
            (when (get-mouse-right-down?)
              (set! inhibit-context-menu? #t)))
        (scroll (new Point 0 (quotient delta 3))))))

  
  (method public virtual (mouse-enter)
    )

  
  (method public virtual (mouse-leave)
    )

  
  (method public virtual (mouse-down pos)
    )
  
  
  (method public virtual (mouse-move pos)
    )
  
  
  (method public virtual (mouse-up pos)
    )
  
  
  (method public virtual (drag-move pos)
    )
  
  
  (method public virtual (drag-up pos . rest)
    )
  
  
  (method public virtual (double-click pos)
    (call-mouse-down pos))
  
  
  (method public virtual (with-context-click pos proc)
    (proc))
  
  
  (method public virtual (context-menu pos)
    )
  
  
  (method public virtual (get-context-menu)
    {})
  
  
  (method public virtual (middle-mouse-down pos)
    (mouse-down pos))
  
  
  (method public virtual (middle-mouse-up pos)
    (mouse-up pos))
  
  
  (method public virtual (right-mouse-down pos)
    )
  
  
  (method public virtual (right-mouse-up pos)
    )
  
  
  (method public virtual (mouse-activate?)
    #t)


  (method public (mouse-view)
    (either (get-captured-view) (get-mouse-in)))


  ;;;
  ;;;; Hovering
  ;;;
  
  
  (definition Hovering-Tolerance
    3)
  
  (definition Hovering-Time
    0.5)
  
  (definition Hovering-Steps
    5)
  
  
  (method public (track-hovering (time: time Hovering-Time))
    (cancel-hovering)
    (let ((start (mouse-position))
          (period (/ time Hovering-Steps)))
      (set! hover-history '())
      (set! hover-pulse (new Pulse period (lambda () (check-hovering start)) delay: 0))))
  
  
  (method public (cancel-hovering)
    (when hover-pulse
      (close~ hover-pulse)
      (set! hover-history {})
      (set! hover-pulse {})))
  
  
  (method (check-hovering start)
    (if (neq? (mouse-view) self)
        (cancel-hovering)
      (when hover-history
        (let ((pos (mouse-position)))
          (if (< (length hover-history) Hovering-Steps)
              (set! hover-history (cons pos hover-history))
            (if (every? (lambda (point)
                          (< (distance point pos) Hovering-Tolerance))
                        hover-history)
                (begin
                  (cancel-hovering)
                  (call-mouse-hover pos))
              (set! hover-history (cons pos hover-history))
              (set-cdr! (tail hover-history (- Hovering-Steps 1)) '())))))))
  

  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (definition package *current-tooltip-context*
    {})
  
  (definition *recent-tooltip-close*
    {})
  
  (definition *last-tooltip-position*
    {})
  
  
  (method (track-tooltip)
    (define (recently-closed?)
      (and *recent-tooltip-close* (< (time->seconds (current-time)) *recent-tooltip-close*)))
    
    (when (and (get-tooltip?) (get-player))
      (if (recently-closed?)
          (track-hovering time: 0.1)
        (track-hovering))))
  
  
  (method (cancel-tooltip-tracking)
    (cancel-hovering)
    (close-tooltip))
  
  
  (method public (reset-tooltip)
    (cancel-tooltip-tracking))
  
  
  (method (in-tooltip? pos)
    (when *current-tooltip-context*
      (let ((view (get-view~ *current-tooltip-context*))
            (rect (get-bounds~ *current-tooltip-context*)))
        (when rect
          (in-rect? (acquire~ view self pos) rect)))))
  
  
  (method (process-tooltip pos)
    (let ((overlapped (get-overlapped)))
      (unless (is? overlapped Tooltip)
        (let ((view (get-view~ *current-tooltip-context*))
              (bounds (get-bounds~ *current-tooltip-context*))
              (new-bounds (get-tooltip-bounds pos)))
          (unless (and (eq? overlapped (get-overlapped~ view))
                       (nu=? bounds new-bounds))
            (reset-tooltip))))))
  
  
  (method (popup-tooltip pos)
    (define (same-position?)
      (and *last-tooltip-position* (nu=? pos *last-tooltip-position*)))
    
    (define (new-tooltip-view text)
      (if (and (get-formatted-tooltip?) (pair? text))
          (let* ((view (new Tooltip-Text size: {Dimension 4000 100}))
                 (text-view (get-text~ view)))
            (set-text~ text-view text)
            (set-size~ view (nu+ (scrollee-content-size~ text-view) {Dimension 2 2}))
            view)
        (new Tooltip-Label title: text)))
    
    (define (new-tooltip text font position)
      (let ((view (new-tooltip-view text))
            (border (new Border-View border-type: 'solid)))
        (when font
          (set-font~ view font))
        (set-preferred-size~ view)
        (let ((padding (new Dimension 0 (get-cursor-height)))
              (position (either position pos)))
          (popup view position padding: padding class: Tooltip border: border))))
    
    (unless (or mouse-down? (current-drag-drop) (in-tooltip? pos))
      (close-tooltip)
      (unless (same-position?)
        (set! *current-tooltip-context* (get-tooltip-context pos))
        (if *current-tooltip-context*
            (let ((text (get-text~ *current-tooltip-context*))
                  (font (get-font~ *current-tooltip-context*))
                  (position (get-position~ *current-tooltip-context*)))
              (set-tooltip~ *current-tooltip-context* (new-tooltip text font position)))
          (set! *last-tooltip-position* pos)
          (reset-tooltip)))))
  
  
  ;; only works for rich tooltips for now
  (method public (update-tooltip text)
    (when *current-tooltip-context*
      (let* ((tooltip (get-tooltip~ *current-tooltip-context*))
             (border (first-child~ (get-root~ tooltip)))
             (view (first-child~ border))
             (text-view (get-text~ view)))
        (set-size~ view {Dimension 4000 100})
        (set-text~ text-view text)
        (set-size~ tooltip (nu+ (scrollee-content-size~ text-view) {Dimension 6 6}))
        (set-size~ border (get-size~ tooltip))
        (layout-view~ border))))
  
  
  (method virtual (close-self-tooltip)
    (when (and *current-tooltip-context* (eq? self (get-view~ *current-tooltip-context*)))
      (close-tooltip)))
  
  
  (method (close-tooltip)
    (when *current-tooltip-context*
      (let ((tooltip (get-tooltip~ *current-tooltip-context*)))
        (when (and tooltip (opened?~ tooltip))
          (close-popup tooltip)))
      (set! *current-tooltip-context* {})
      (set! *recent-tooltip-close* (+ (time->seconds (current-time)) 0.5))))
  
  
  (method (get-cursor-height)
    (let ((cursor (get-cursor)))
      (case cursor
        ((:ibeam) 9)
        (else 21))))


  ;;;
  ;;;; Groups
  ;;;
  
  
  (method public (get-selected-element (class: class Radio-Button) (group: group {}))
    (let ((element
            (find-if (lambda (child)
                       (and (is? child class)
                            (or (not group) (eq? (get-group~ child) group))
                            (get-selected?~ child)))
                     children)))
      (when element
        (get-name~ element))))
  
  
  (method public (set-selected-element name (class: class Radio-Button) (group: group {}))
    (let ((found? #f))
      (for-each (lambda (child)
                  (when (and (is? child class)
                             (or (not group) (eq? (get-group~ child) group)))
                    (let ((selected? (eq? (get-name~ child) name)))
                      (set-selected?~ child selected?)
                      (when selected?
                        (set! found? #t)))))
                children)
      (unless found?
        (error "Unable to find element: {t}" name))))
  
  
  (method public (unselect-elements (class: class Radio-Button) (group: group {}))
    (for-each (lambda (child)
                (when (and (is? child class)
                           (or (not group) (eq? (get-group~ child) group)))
                  (unselect~ child)))
              children))


  ;;;
  ;;;; Context Menu
  ;;;
  
  
  (method public (track-popup-menu menu pos (alternate-position: alternate-position {}) (initiator: initiator self))
    (if (is-not? menu Context-Menu)
        (error "{t} is not of the expected Context-Menu class" menu)
      (unless (all-invisible? menu)
        (let ((popup (popup menu pos alternate-position: alternate-position class: Menu-Transient initiator: initiator)))
          popup))))
  
  
  (method (all-invisible? menu)
    (every? (lambda (item)
              (not (get-visible?~ item)))
            (get-children~ menu)))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (get-context-text)
    {})
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;

  
  (method public virtual (mouse-copy pos destination)
    (let ((data (mouse-data pos)))
      (if (not data)
          #f
        (mouse-insert~ destination data)
        #t)))

  
  (method public virtual (mouse-data pos)
    #f)

  
  (method public virtual (mouse-insert object)
    )
  
  
  ;;;
  ;;;; Desktop
  ;;;
  
  
  (method public (to-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire~ desktop player (acquire~ root self shape))))
  
  
  (method public (from-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire root (acquire~ player desktop shape))))
  
  
  ;;;
  ;;;; Popup
  ;;;
  
  
  (method public (popup view <View> position <Point> (padding: padding {}) (alternate-position: alternate-position {}) (initiator: initiator self) (class: class Popup) (border: border {}) (fade-speed: fade-speed {}) (effect: effect {}) (close-behavior: close-behavior {}))
    (let* ((toplevel (get-toplevel))
           (player (get-player))
           (max (rect-size (get-work-area)))
           (alternate (essay alternate-position (to-desktop alternate-position)))
           (position (to-desktop position))
           (size (+ (get-size~ view) {Dimension 4 4}))
           (padding (either padding {Dimension 0 0}))
           (border (either border (new Border-View name: 'border border-type: 'raised)))
           (popup (popup~ player class position: (fit-point position alternate size max padding) size: size close-behavior: close-behavior)))
      (set-initiator~ popup initiator)
      (set-parent~ border (get-root~ popup))
      (set-position~ border {Point 0 0})
      (set-size~ border (get-size~ popup))
      (set-parent~ view border)
      (set-visible?~ view #t)
      (layout-view~ border)
      (set-effect~ (get-root~ popup) effect)
      (fade-in~ popup fade-speed: fade-speed)
      popup))
  
  
  (method public virtual (close-popups (event: event {}) (all?: all? #f) (exclude: exclude {}))
    (when player
      (close-popups~ player all?: all? exclude: exclude)))
  
  
  (method public virtual (popup-destroy popup)
    )
  
  
  (method public (popup-initiator)
    (let ((overlapped (get-overlapped)))
      (when (is? overlapped Popup)
        (get-initiator~ overlapped))))
  
  
  (method public (owned? overlapped)
    (memq? overlapped (get-owners~ (get-overlapped))))


  ;;;
  ;;;; Drag
  ;;;


  (method public virtual (get-draggable?)
    draggable?)


  (method public (set-draggable? flag)
    (set! draggable? flag))


  (method public virtual (get-drag-drop)
    (let ((source (get-drag-source)))
      (when source
        (new DnD source: source))))
  
  
  (method public virtual (get-drag-hotspot)
    {Point 0 0})
  
  
  (method public virtual (get-drag-source)
    (let ((pos (get-drag-position)))
      (new Drag-Source view: self position: pos image: (get-drag-image pos))))
  
  
  (method public virtual (get-drag-position)
    mouse-down-point)
  
  
  (method public virtual (get-drag-image pos)
    {})
  
  
  (method (drag-start pos hotspot drag-drop)
    (set-current-drag-drop drag-drop)
    (let ((view (get-view~ (get-source~ drag-drop))))
      (set-cursor :no)
      (acquire-focus~ view)
      (acquire-capture~ view)
      @old
      (let* ((image (get-image~ (get-source~ drag-drop)))
             (portfolio (get-portfolio~ image))
             (image-name (get-image-name~ image)))
        (ImageList_BeginDrag (get-handle~ portfolio) (get-image~ portfolio image-name) (get-h~ hotspot) (get-v~ hotspot)))
      (let ((global (to-desktop~ view pos)))
        @old(ImageList_DragEnter (get-handle~ (get-desktop)) (get-h~ global) (get-v~ global))
        (hide-drag-image)
        (process-drag-feedback global))))
  
  
  (method (drag-follow pos)
    (when (current-drag-drop)
      (let* ((drag-drop (current-drag-drop))
             (view (get-view~ (get-source~ drag-drop)))
             (global (to-desktop~ view pos)))
        @old(ImageList_DragMove (get-h~ global) (get-v~ global))
        (process-drag-feedback global))))
  
  
  (method (drag-drop drag-drop pos)
    (drag-end)
    (when (get-target~ drag-drop)
      (drop drag-drop pos)))
  
  
  (method (drag-end)
    (when (current-drag-drop)
      (let ((drag-drop (current-drag-drop)))
        (hide-drag-image)
        (unhighlight-current drag-drop)
        @old(ImageList_EndDrag)
        @old(ImageList_DragLeave (get-handle~ (get-desktop)))
        (release-capture~ (get-view~ (get-source~ drag-drop)))
        (set-current-drag-drop {}))))
  
  
  (method (process-drag-feedback global)
    (let* ((drag-drop (current-drag-drop))
           (current (get-view~ drag-drop))
           (desktop (get-desktop))
           (view (find-view~ desktop global)))
      (set-view~ drag-drop view)
      (when view
        (let* ((local (to-view~ desktop global view))
               (target (call-current-drop~ view drag-drop local)))
          (when (neq? target (get-target~ drag-drop))
            (set-cursor (if target :move :no))
            (hide-drag-image)
            (unhighlight-current drag-drop)
            (set-target~ drag-drop target)
            (when target
              (highlight-current drag-drop view local))
            (when target
              (show-drag-image)))))))
  
  
  (method (hide-drag-image)
    @old(ImageList_DragShowNolock #f))
  
  
  (method (show-drag-image)
    @old(ImageList_DragShowNolock #t))
  
  
  (method (highlight-current drag-drop view local)
    (highlight-drop~ view drag-drop local))
  
  
  (method (unhighlight-current drag-drop)
    (let ((current-target (get-target~ drag-drop)))
      (when current-target
        (unhighlight-drop~ (get-view~ current-target) drag-drop))))
  
  
  (method public virtual (highlight-drop drag-drop pos)
    )
  
  
  (method public virtual (unhighlight-drop drag-drop)
    )


  ;;;
  ;;;; Drop
  ;;;
  
  
  (method public (call-current-drop drag-drop pos)
    (if current-drop-handler
        (invoke~ current-drop-handler self (new Drop-Event :drop-target self pos drag-drop))
      (current-drop drag-drop pos)))

  
  (method public virtual (current-drop drag-drop pos)
    {})
  
  
  (method public (standard-current-drop evt acceptance (handler: handler {}))
    (let* ((sender (get-sender~ evt))
           (pos (get-position~ evt))
           (drag-drop (get-drag-drop~ evt))
           (current (get-target~ drag-drop))
           (drag-start (get-view~ (get-source~ drag-drop)))
           (drag-over (get-view~ drag-drop))
           (drag-info (cons drag-start drag-over)))
      (if (neq? drag-start drag-over)
          (let ((criteria (find-if (lambda (criteria) (accepts?~ criteria drag-info)) acceptance)))
            (if criteria
                (new Drop-Target handler: handler view: sender position: pos criteria: criteria)
              (current-drop~ sender drag-drop pos)))
        (current-drop~ sender drag-drop pos))))

  
  (method public virtual (drop drag-drop pos)
    (let* ((src (get-view~ (get-source~ drag-drop)))
           (trg (get-target~ drag-drop))
           (dst (either (get-handler~ trg) (get-view~ trg))))
      (when dst
        (call-receive-drop~ dst self (acquire~ dst src pos) drag-drop))))
  
  
  (method public (call-receive-drop sender pos drag-drop)
    (if receive-drop-handler
        (invoke~ receive-drop-handler self (new Drop-Event :receive-drop sender pos drag-drop))
      (receive-drop sender pos drag-drop)))
  
  
  (method public virtual (receive-drop sender pos drag-drop)
    )


  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method protected (call-key-press key)
    (if key-press-handler
        (invoke~ key-press-handler self (new Keyboard-Event :char self key))
      (key-press key)
      (let ((appl (get-application)))
        (when (macro-recording?~ appl)
          (let ((recorder (get-recorder~ appl)))
            (when recorder
              (let ((handler {Event-Handler :focus on-insert})
                    (event (new Event (if char? :char :key) self content: key)))
                (when (record-event?~ appl event)
                  (record~ recorder handler event)))))))))
  
  
  (method (on-arrow evt)
    (call-arrow-press evt))

  
  (method (call-arrow-press evt)
    (if arrow-press-handler
        (invoke~ arrow-press-handler self evt)
      (arrow-press (get-property~ evt direction:) (get-modifiers~ evt))))


  (method public virtual (arrow-press direction modifiers)
    (case direction
      ((left)  (left-arrow-press  modifiers))
      ((right) (right-arrow-press modifiers))
      ((up)    (up-arrow-press    modifiers))
      ((down)  (down-arrow-press  modifiers))))


  (method public virtual (left-arrow-press modifiers)
    )


  (method public virtual (right-arrow-press modifiers)
    )


  (method public virtual (up-arrow-press modifiers)
    )


  (method public virtual (down-arrow-press modifiers)
    )
  
  
  (method package virtual (on-escape-press evt)
    (call-escape-press #\escape))
  
  
  (method (call-escape-press key)
    (if escape-press-handler
        (invoke~ escape-press-handler self (new Keyboard-Event :char self key))
      (escape-press key)))


  (method public virtual (escape-press key)
    )
  
  
  (method package virtual (on-backspace-press evt)
    (call-backspace-press #\backspace))
  
  
  (method (call-backspace-press key)
    (if backspace-press-handler
        (invoke~ backspace-press-handler self (new Keyboard-Event :char self key))
      (backspace-press key)))


  (method public virtual (backspace-press key . rest)
    )
  
  
  (method package virtual (on-return-press evt)
    (call-return-press #\return))
  

  (method (call-return-press key)
    (if return-press-handler
        (invoke~ return-press-handler self (new Keyboard-Event :char self key))
      (return-press key)))


  (method public virtual (return-press key)
    )
  
  
  (method package virtual (on-tab-press evt)
    (call-tab-press #\tab))
  
  
  (method (call-tab-press key)
    (if tab-press-handler
        (invoke~ tab-press-handler self (new Keyboard-Event :char self key))
      (tab-press key (modifiers-keys))))


  (method public virtual (tab-press key modifiers)
    (navigate-view (shift-key? modifiers)))
  
  
  (method package (on-key-press evt)
    (key-press (get-property~ evt key:)))


  (method public virtual (key-press key)
    )
  
  
  (method protected (dispatch-key-press key)
    (if (and (current-drag-drop) (= key #\escape))
        (begin
          (drag-end)
          (complete-drag-up #t))
      (let ((view (get-focus)))
        (when view
          (call-key-press~ view key)))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method public (find-tab-manager)
    (if (or (get-tab-stops) (not parent))
        self
      (find-tab-manager~ parent)))
  
  
  (method public (navigate-tab from backward?)
    (let ((to (navigated-view from backward?)))
      (when (and to (neq? to from))
        (tab-stop-exit~ from)
        (acquire-focus~ to)
        (tab-stop-enter~ to))))
  
  
  (method public (navigated-view from backward?)
    (let ((stops (get-tab-stops)))
      (when stops
        (let ((count (length stops))
              (rank (find stops from)))
          (when rank
            (let ((new-rank (if backward? (if (= rank 0) (- count 1) (- rank 1)) (modulo (+ rank 1) count))))
              (element stops new-rank)))))))
  
  
  (method package virtual (on-next-view evt)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self #f)))
  
  
  (method package virtual (on-previous-view evt)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self #t)))
  
  
  (method protected (navigate-view backward?)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self backward?)))
  
  
  (method public virtual (get-tab-stops)
    {})
  
  
  (method public virtual (tab-stop-enter)
    (select-all))
  
  
  (method public virtual (tab-stop-exit)
    )


  ;;;
  ;;;; Edition
  ;;;
  
  
  (method (on-undo evt)
    (if (not surrogate)
        (undo)
      (undo~ surrogate)))
  
  
  (method (on-redo evt)
    (if (not surrogate)
        (redo)
      (redo~ surrogate)))
  
  
  (method (on-cut evt)
    (if (not surrogate)
        (cut-selection)
      (cut-selection~ surrogate)))
  
  
  (method (on-copy evt)
    (if (not surrogate)
        (copy-selection)
      (copy-selection~ surrogate)))
  
  
  (method (on-paste evt)
    (if (not surrogate)
        (paste-clipboard)
      (paste-clipboard~ surrogate)))
  
  
  (method (on-paste-properties evt)
    (if (not surrogate)
        (paste-properties)
      (paste-properties~ surrogate)))
  
  
  (method (on-delete evt)
    (if (not surrogate)
        (delete-selection)
      (delete-selection~ surrogate)))
  
  
  (method (on-rename evt)
    (if (not surrogate)
        (rename-selection)
      (rename-selection~ surrogate)))
  
  
  (method (on-select-all evt)
    (if (not surrogate)
        (select-all)
      (select-all~ surrogate)))
  
  
  (method public virtual (can-undo?)
    (if surrogate
        (can-undo?~ surrogate)
      #f))
  
  
  (method public virtual (can-redo?)
    (if surrogate
        (can-redo?~ surrogate)
      #f))
  
  
  (method public virtual (can-cut?)
    (if surrogate
        (can-cut?~ surrogate)
      #f))
  
  
  (method public virtual (can-copy?)
    (if surrogate
        (can-copy?~ surrogate)
      #f))
  
  
  (method public virtual (can-paste?)
    (if surrogate
        (can-paste?~ surrogate)
      #f))
  
  
  (method public virtual (can-paste-properties?)
    (if surrogate
        (can-paste-properties?~ surrogate)
      #f))
  
  
  (method public virtual (can-delete?)
    (if surrogate
        (can-delete?~ surrogate)
      #f))
  
  
  (method public virtual (can-rename?)
    (if surrogate
        (can-rename?~ surrogate)
      #f))
  
  
  (method public virtual (can-select-all?)
    (if surrogate
        (can-select-all?~ surrogate)
      #f))
  
  
  (method public virtual (undo)
    )
  
  
  (method public virtual (redo)
    )
  
  
  (method public virtual (cut-selection)
    )
  
  
  (method public virtual (copy-selection)
    )
  
  
  (method public virtual (paste-clipboard)
    )
  
  
  (method public virtual (paste-properties)
    )
  
  
  (method public virtual (delete-selection)
    )
  
  
  (method public virtual (rename-selection)
    )
  
  
  (method public virtual (select-all . rest)
    )


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method public (acquire-capture)
    (set-captured-view self)
    (acquire-capture~ (get-player)))
  
  
  (method public (release-capture)
    (set-captured-view {})
    (release-capture~ (get-player)))


  ;;;
  ;;;; Tooltips
  ;;;


  (method public virtual (get-tooltip?)
    tooltip?)


  (method public (set-tooltip? flag)
    (when (neq? flag tooltip?)
      (set! tooltip? flag)))


  (method public virtual (get-tooltip-text)
    (let ((text (localize tooltip-text)))
      (if (or (not text) (not action))
          text
        (let ((shortcut (get-shortcut~ (require-action-item action))))
          (if (not shortcut)
              text
            (format "{a} ({a})" text (present-shortcut~ shortcut)))))))


  (method public (set-tooltip-text text)
    (set! tooltip-text text))
  
  
  ;; a quicky... this should probably by default return the value of a property
  (method public virtual (get-formatted-tooltip?)
    #f)
  
  
  (method public virtual (get-tooltip-bounds pos)
    {})
  
  
  (method public virtual (get-tooltip-context pos)
    (let ((text (get-tooltip-text))
          (bounds (get-tooltip-bounds pos)))
      (when text
        (new Tooltip-Context view: self text: text bounds: bounds))))

  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method override (get-translated-clipper h v)
    (let* ((b (get-bounds))
           (r (offset-rect b (fxround h) (fxround v))))
      (if (not parent)
          r
        (let ((sc <fl> (if scaled? scaling 1.0)))
          (with ((p <Rect> (get-translated-clipper~ parent (- (* h sc) (get-h~ position)) (- (* v sc) (get-v~ position)))))
            (when scaled?
              (set-left~ p (fxround (/ (get-left~ p) sc)))
              (set-top~ p (fxround (/ (get-top~ p) sc)))
              (set-right~ p (fxround (/ (get-right~ p) sc)))
              (set-bottom~ p (fxround (/ (get-bottom~ p) sc))))
            (rect-intersection p r))))))
  
  
  ;;;
  ;;;; Surface
  ;;;


  (method public (get-surface)
    (let ((surface (new Surface (get-window-surface (get-player))))
          (lie (get-lie)))
      (set-transform~ surface (get-h~ lie) (get-v~ lie) (get-width) (get-height) 0 0 1.0 #f)
      (setup-clipper~ surface (get-bounds))
      surface))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-view)
    (with ((bounds (get-bounds)))
      (invalidate-rect bounds)))
  
  
  (method public (invalidate-rect rect)
    (let ((player (get-player)))
      (when player
        (let ((root (get-root)))
          (assert root)
          (with ((acquired (acquire~ root self rect)))
            (invalidate-rect~ player acquired))))))
  
  
  ;; todo: not using acquire is a potentiel scaling bug...
  (method public (invalidate-region region)
    (let ((player (get-player)))
      (when player
        (let* ((root (get-root))
               (delta (- (get-lie) (get-lie~ root))))
          (offset!~ region (get-h~ delta) (get-v~ delta))
          (invalidate-region~ player region)))))
  
  
  (method public (redraw-view (rect: rect {}) (region: region {}))
    (let ((player (get-player)))
      (when player
        (let ((root (get-root)))
          (cond (rect
                  (with ((acquired (acquire~ root self rect)))
                    (redraw-window~ player rect: acquired)))
                ;; todo: not using acquire is a potentiel scaling bug...
                (region
                  (let ((delta (- (get-lie) (get-lie~ root))))
                    (offset!~ region (get-h~ delta) (get-v~ delta))
                    (redraw-window~ player region: region)))
                (else
                 (with ((bounds (get-bounds))
                        (acquired (acquire~ root self bounds)))
                   (redraw-window~ player rect: acquired))))))))
  

  ;; Mainly used by the scrollbar to only redraw itself when scrolling
  (method public (redraw-view-only)
    (let ((player (get-player)))
      (when player
        (let ((hwnd (get-handle~ player)))
          (platform-redraw-view-only self hwnd)))))
  
  
  (method public (update-view (effect: effect {}))
    (let ((player (get-player)))
      (when player
        (set-effect effect)
        (update-window~ player))))
  
  
  (method public (invalidater)
    (let ((rect (acquire~ (get-root) self (get-rect)))
          (player player))
      (lambda ()
        (invalidate-rect~ player rect))))

  
  ;;;
  ;;;; Border
  ;;;


  (method public (invalidate-border (insets: insets {Rect 1 1 1 1}))
    (when (get-finished?)
      (with-closed ((region (border-region insets: insets)))
        (invalidate-region region))))


  (method public (redraw-border (insets: insets {Rect 1 1 1 1}))
    (with-closed ((region (border-region insets: insets)))
      (redraw-view region: region)))


  (method public (border-region (insets: insets {Rect 1 1 1 1}))
    (with ((bounds (get-bounds)))
      (frame-region bounds insets: insets)))


  ;;;
  ;;;; Save
  ;;;

  
  (method package (on-save evt)
    (if (not surrogate)
        (save)
      (save~ surrogate)))
  
  
  (method package (on-save-as evt)
    (save-as))
  
  
  (method package (on-revert-saved evt)
    (revert-saved))
        
  
  (method package (on-compare-saved evt)
    (compare-saved))


  (method public virtual (save)
    )


  (method public virtual (save-as)
    )
  
  
  (method public virtual (save-to moniker)
    )

  
  (method public virtual (revert-saved)
    )

  
  (method public virtual (compare-saved)
    )


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method meta override (get-class-image)
    {Bitmap-Resource "View"})

  
  (method meta override (property-presentation property)
    (case (field-name property)
      ((title)          "Title")
      ((font)           "Font")
      ((background)     "Background")
      ((auto-size?)     "Auto Size")
      ((tooltip?)       "Tooltip")
      ((tooltip-text)   "Tooltip Text")
      ((draggable?)     "Draggable")
      ((drag-tolerance) "Drag Tolerance")
      ((enabled?)       "Enabled")
      ((action)         "Action")
      ((outline-view)   "Outline View")
      ((offscreen?)     "Offscreen")
      ((layer)          "Layer")
      ((effect)         "Effect")
      ((user-data)      "User Data")
      (else (nextmethod property))))
  
  
  (method (install-surrogate?)
    #t)
  
  
  (method override (component-surrogate)
    View-Surrogate)
  
  
  (method override (addable-class? class)
    (subtype? class View))

  
  (method override (get-row-class property)
    (case (field-name property)
      ((cursor-update-handler)   Handler-Row)
      ((mouse-enter-handler)     Handler-Row)
      ((mouse-hover-handler)     Handler-Row)
      ((mouse-leave-handler)     Handler-Row)
      ((mouse-down-handler)      Handler-Row)
      ((mouse-move-handler)      Handler-Row)
      ((mouse-up-handler)        Handler-Row)
      ((drag-move-handler)       Handler-Row)
      ((drag-up-handler)         Handler-Row)
      ((double-click-handler)    Handler-Row)
      ((current-drop-handler)    Handler-Row)
      ((receive-drop-handler)    Handler-Row)
      ((receive-files-handler)   Handler-Row)
      ((context-menu-handler)    Handler-Row)
      ((key-press-handler)       Handler-Row)
      ((arrow-press-handler)     Handler-Row)
      ((escape-press-handler)    Handler-Row)
      ((backspace-press-handler) Handler-Row)
      ((return-press-handler)    Handler-Row)
      ((tab-press-handler)       Handler-Row)
      ((content-change-handler)  Handler-Row)
      ((selection-handler)       Handler-Row)
      ((action-handler)          Handler-Row)
      (else (nextmethod property))))

  
  (method override (get-row-instance property)
    (case (field-name property)
      ((title)        (new Localized-Row))
      ((position)     (new Point-Row))
      ((size)         (new Dimension-Row))
      ((font)         (new Font-Row))
      ((background)   (new Color-Row))
      ((auto-size?)   (new Boolean-Row))
      ((tooltip-text) (new String-Row))
      ((transparent?) (new Boolean-Row))
      ((offscreen?)   (new Boolean-Row))
      ((tooltip?)     (new Boolean-Row))
      ((draggable?)   (new Boolean-Row))
      ((enabled?)     (new Boolean-Row))
      (else (nextmethod property))))))
