;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Views
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.ui.view.View jazz


(import (jazz.designer)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.print)
        (jazz.ui.window)
        (jazz.ui.view)
        (jazz.ui.workspace)
        (time))


(class View extends Drawing implements (Actionable Context-Provider)

  
  (property title                                initialize #f accessors explicit)
  (property font                                 initialize #f accessors explicit)
  (property style                                initialize #f accessors explicit)
  (property background                           initialize #f accessors explicit)
  (property auto-size?                           initialize #f accessors explicit)
  (property tooltip?                             initialize #f accessors explicit)
  (property tooltip-text                         initialize #f accessors explicit)
  (property draggable?                           initialize #f accessors explicit)
  (property drag-tolerance                       initialize 5  accessors generate)
  (property enabled?                             initialize #t accessors explicit)
  (property outline-view                         initialize #f accessors generate)
  (property offscreen?                 <bool>    initialize #f accessors explicit)
  ;; not implemented yet
  (property layer                                initialize 0  accessors explicit)
  (property effect                               initialize #f accessors explicit)
  (property user-data                            initialize #f accessors generate)
  (property disabled-navigate?                   initialize #f accessors generate)

  
  (property focus-gained-handler                 initialize #f accessors generate)
  (property focus-lose-handler                   initialize #f accessors generate)
  (property cursor-update-handler                initialize #f accessors generate)
  (property mouse-enter-handler                  initialize #f accessors generate)
  (property mouse-hover-handler                  initialize #f accessors generate)
  (property mouse-leave-handler                  initialize #f accessors generate)
  (property mouse-down-handler                   initialize #f accessors generate)
  (property mouse-move-handler                   initialize #f accessors generate)
  (property mouse-up-handler                     initialize #f accessors generate)
  (property drag-move-handler                    initialize #f accessors generate)
  (property drag-up-handler                      initialize #f accessors generate)
  (property double-click-handler                 initialize #f accessors generate)
  (property current-drop-handler                 initialize #f accessors generate)
  (property receive-drop-handler                 initialize #f accessors generate)
  (property receive-files-handler                initialize #f accessors generate)
  (property context-menu-handler                 initialize #f accessors generate)
  (property key-press-handler                    initialize #f accessors generate)
  (property arrow-press-handler                  initialize #f accessors generate)
  (property escape-press-handler                 initialize #f accessors generate)
  (property backspace-press-handler              initialize #f accessors generate)
  (property return-press-handler                 initialize #f accessors generate)
  (property tab-press-handler                    initialize #f accessors generate)
  (property content-change-handler               initialize #f accessors generate)
  (property selection-handler                    initialize #f accessors generate)
  (property action-handler                       initialize #f accessors explicit)

  
  (slot player                      <Window+>    initialize #f)
  (slot offscreen                                initialize #f)
  (slot scroller                                 initialize #f)
  (slot renderer                                 initialize #f accessors generate)
  (slot scaled?                     <bool>       initialize #f)
  (slot scaling                     <fl>         initialize 1.)
  (slot previous-size               <Dimension+> initialize #f)
  (slot update-locked?              <bool>       initialize #f getter generate)
  (slot scrollee-locked?            <bool>       initialize #f)
  (slot modified?                   <bool>       initialize #f)
  (slot hover-history                            initialize #f)
  (slot hover-pulse                              initialize #f)
  (slot tools-info                               initialize #f)
  
  
  (method override (shortcut-update action-item));;abstract
  
  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (conclude rest)
    (nextmethod rest)
    (layout)
    (layout-scrollee))

  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{?{a} ~}{?{s} ~}{a} {a}" name title position size))))
  
  
  ;;;
  ;;;; Destruction
  ;;;
  
  
  (method public virtual (close-with-confirm)
    (close))
  
  
  (method override (destroy-component)
    (let ((mouse-in (get-mouse-in)))
      (when (and mouse-in (has-ascendant?~ mouse-in self))
        (reset-mouse-in)
        (call-mouse-leave~ mouse-in)))
    (let ((focus (get-focus)))
      (when (and focus (has-ascendant?~ focus self))
        (let ((window-focus (get-window-focus)))
          (when (eq? player window-focus)
            (reset-focus~ window-focus)))))
    (nextmethod))


  (method override (destroy)
    (nextmethod)
    (let ((parent parent)
          (rect (get-rect)))
      (let ((host (get-host)))
        (when host
          (view-destroyed~ host self)))
      (set-offscreen? #f)
      (set! player #f)
      (when (is? parent View)
        (invalidate-rect~ parent rect))))
  
  
  ;;;
  ;;;; Aliases
  ;;;

  
  (method override (component-alias name)
    (case name
      ((:host) (get-host))
      ((:guest) (get-guest))
      ((:root) (get-root))
      ((:initiator) (popup-initiator))
      (else (nextmethod name))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (get-player)
    player)
  
  
  (method override (set-player plr)
    (define (own-focus)
      (let ((focus (get-focus)))
        (when (eq? focus self)
          focus)))
    
    (define (own-mouse)
      (let ((mouse (get-mouse-in)))
        (when (eq? mouse self)
          mouse)))
    
    (when (neq? player plr)
      (let ((focus (own-focus))
            (mouse (own-mouse)))
        (when focus
          (let ((window-focus (get-window-focus)))
            (when (eq? player window-focus)
              (reset-focus~ window-focus))))
        (when (and mouse (not plr))
          (reset-mouse-in)
          (call-mouse-leave))
        (set! player plr)
        (nextmethod plr)
        (when (and player focus)
          (acquire-focus~ focus)))))
  
  
  (method public (in-player?)
    (boolean player))


  (method public (get-overlapped)
    (let ((player (get-player)))
      (when player
        (get-overlapped~ player))))
  
  
  (method public (different-overlapped? window)
    (or (not window) (neq? (get-overlapped) (get-overlapped~ window))))
  
  
  ;;;
  ;;;; Hosting
  ;;;


  (method public virtual (get-host)
    (find-ascendant Host-View))
  
  
  (method public virtual (get-guest)
    (let ((host (get-host)))
      (and host (get-guest~ host))))
  
  
  (method public virtual (install-in-host host)
    )
  
  
  (method public virtual (uninstall-from-host host)
    )
  
  
  (method public virtual (save-guest designer session)
    )
  
  
  (method public (add-guest-preferences designer session . initargs)
    (unimplemented 'add-guest-preferences)
    @Guest-Preferences
    (let* ((host (get-host))
           (pref (new Guest-Preferences
                   position: (get-position)
                   size:     (get-size)
                   name:     (category-identifier (class-of self))
                   initargs: (cons position: (cons (get-position~ host)
                                                   (cons size: (cons (get-size~ host)
                                                                     initargs)))))))
      (add-child~ designer pref session design-events?: #f select?: #f)))
  
  
  (method public virtual (host-activate)
    )
  
  
  (method public virtual (host-deactivate)
    )
  
  
  (method public virtual (focus-default)
    (acquire-focus))
  
  
  (method public virtual (get-text-view)
    #f)
  
  
  (method public (frame-guest?)
    (let ((host (get-host)))
      (and (is? host Frame-Host)
           (eq? (get-guest~ host) self))))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta protected virtual (dialog-class)
    Dialog)
  
  
  (method meta protected virtual (frame-class)
    Internal-Frame-Host)
  
  
  (method meta protected virtual (palette-class)
    Palette)
  
  
  (method meta protected virtual (docked-class)
    Docked-Host)
  
  
  (method meta protected virtual (toolbar-class)
    Toolbar-Host)
  
  
  (method meta protected virtual (host-icon)
    {Image-Resource "Window"})
  
  
  (method meta protected virtual (host-title)
    #f)
  
  
  (method meta protected virtual (host-position)
    #f)
  
  
  (method meta protected virtual (host-size)
    #f)
  
  
  (method public virtual (host-minimal-size)
    {Dimension 100 100})
  
  
  (method public virtual (host-workspaces)
    '())
  
  
  (method public (effective-host-workspaces)
    (define (filter-inexistant-workspaces pref workspaces)
      (let ((names (map get-name~ (get-children~ pref))))
        (collect-if (lambda (name)
                      (memq? name names))
                    workspaces)))
    
    (host-workspaces)
    @convert-external-name
    (let* ((pref (get-workspaces-preferences))
           (associations (get-associations~ pref))
           (external (external-name error?: #f)))
      (filter-inexistant-workspaces pref
                                    (or (and external (assq external associations))
                                        (host-workspaces)))))
  
  
  (method public (for-each-view-docked proc)
    (for-each (lambda (child)
                (cond ((or (is? child Splitter-View)
                           (is? child Pad-View))
                       (for-each-view-docked~ child proc))
                      ((is? child Host-View)
                       (proc (get-guest~ child)))))
              children))
  
  
  (method public (find-view-docked type)
    (continuation-capture
      (lambda (return)
        (for-each-view-docked
          (lambda (guest)
            (when (is? guest type)
              (continuation-return return guest))))
        #f)))
  
  
  (method public (find-host guest-type)
    (find-if (lambda (view)
               (and (is? view Host-View)
                    (is? (get-guest~ view) guest-type)))
             children))
  
  
  (method public (find-guest guest-type)
    (let ((host (find-host guest-type)))
      (when host
        (get-guest~ host))))
  
  
  (method public (collect-guest guest-type)
    (collect (lambda (view)
               (when (is? view Host-View)
                 (let ((guest (get-guest~ view)))
                   (when (is? guest guest-type)
                     guest))))
             children))


  (method public (get-frame)
    (find-ascendant Frame-Host))
  
  
  (method public virtual (guest-icon)
    (host-icon~ (class-of self)))
  
  
  (method public virtual (focus-activate)
    )
  
  
  (method public virtual (focus-deactivate)
    )
  
  
  (method public virtual (maximize)
    )
  
  
  (method public virtual (restore)
    )
  
  
  (method public virtual (split-view)
    #f)
  
  
  ;;;
  ;;;; Frame
  ;;;
  
  
  (method meta public virtual (new-event . rest)
    (apply new-frame self rest))
  
  
  ;;;
  ;;;; Tool
  ;;;
  
  
  (method public virtual (tool-preferences)
    #f)
  
  
  ;; All this tool-info stuff remains to be done. The idea is to give
  ;; docked tools a place to persist information like the selection so that
  ;; when switching documents like designs, the selection is preserved...
  ;; Note: the show-invisibles? slot of Design-Book-View is clearly a handcoded
  ;; piece of code that could be redone using tool-infos
  (method (get-tools-info)
    (unless tools-info
      (set! tools-info (make-table test: eq?)))
    tools-info)
  
  
  (method public virtual (get-tool-info tool-name)
    (table-ref (get-tools-info) tool-name #f))
  
  
  (method public virtual (set-tool-info tool-name info)
    (table-set! (get-tools-info) tool-name info))
  
  
  ;;;
  ;;;; Palette
  ;;;
  
  
  (method public virtual (host-install)
    )
  
  
  (method public virtual (host-uninstall)
    )
  
  
  (method public virtual (client-activate)
    )
  
  
  (method public virtual (client-deactivate)
    )
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method public virtual (get-tools-view)
    #f)
  
  
  (method public virtual (workspace-minimisable?)
    #t)
    
  
  ;;;
  ;;;; Dialog
  ;;;
  
  
  (method public virtual (validate-dialog)
    )
  
  
  (method public virtual (get-modal-result)
    #f)
  
  
  (method public virtual (has-dialog-result?)
    #f)
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method public virtual (get-component-editor)
    #f)
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public virtual (content-valid?)
    #t)
  
  
  (method public virtual (validate-content)
    )
  
  
  ;;;
  ;;;; Parent
  ;;;
  
  
  (method override (setup-parent)
    (nextmethod)
    (set-player (if parent (get-player~ parent) #f)))
  
  
  (method override (set-parent parent)
    (let ((invalidater (view-invalidater)))
      (nextmethod parent)
      (set-player (and parent (get-player~ parent)))
      (when invalidater
        (invalidater))
      (when parent
        (invalidate-view))))
  
  
  ;;;
  ;;;; Title
  ;;;
  
  
  (method public virtual (get-title)
    title)
  
  
  (method public virtual (set-title value)
    (set! title value)
    (adjust-size))
  
  
  ;;;
  ;;;; Visibility
  ;;;
    
  
  (method override (initially-visible?)
    #f)


  (method override (show)
    (nextmethod)
    (invalidate-view))


  (method override (hide)
    (let ((invalidater (view-invalidater)))
      (nextmethod)
      (when invalidater
        (invalidater))))
  
  
  (method protected virtual (update-displayed)
    )
  
  
  ;;;
  ;;;; Enabled
  ;;;
  

  (method public virtual (get-enabled?)
    enabled?)


  (method public virtual (set-enabled? flag)
    (set! enabled? flag)
    (invalidate-view))
  
  
  (method public (view-enabled?)
    (and (get-enabled?)
         (or (is-not? parent View)
             (view-enabled?~ parent))))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method override (get-scaled?)
    scaled?)


  (method override (set-scaled? value)
    (set! scaled? value)
    (update-displayed)
    (update-scrollbars)
    ;; Depending on whether it's the view's point of vue or it's parent
    ;; we either have to invalidate the view or its parent...
    (if parent
        (invalidate-view~ parent)
      (invalidate-view)))
  

  (method override (get-scaling)
    scaling)


  (method override (set-scaling value <fl>)
    (set! scaling (/ (cast <fl> (round (* value 1000))) 1000)))

  
  ;;;
  ;;;; Actionable
  ;;;
  
  
  (method override (enabled-update action-item)
    (set-enabled? (get-enabled?~ action-item)))
  
  
  (method public virtual (actionable-reachable?)
    (view-visible?))

  
  ;;;
  ;;;; Outline View
  ;;;


  (method public (outline-select (focus?: focus? #f))
    (let* ((row (outline-row))
           (line (row->line~ outline-view row))
           (elem (if (and (is? outline-view Tree-View) (eq? (get-selection-mode~ outline-view) 'cell)) (new Cell line 0) line)))
      (when focus?
        (acquire-focus~ outline-view))
      (set-selection~ outline-view (list elem))))
  
  
  (method public (outline-row)
    (find-ascendant Outline-Row))


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen?)
    offscreen?)
  
  
  (method override (set-offscreen? flag <bool>)
    (when (neq? flag offscreen?)
      (set! offscreen? flag)
      (when (not offscreen?)
        (close-offscreen))))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method override (get-layer)
    layer)
  
  
  (method override (set-layer value)
    (set! layer value))


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method override (get-effect)
    effect)
  
  
  (method override (set-effect value)
    (set! effect value))

  
  ;;;
  ;;;; Lie
  ;;;
  
  
  (method override (get-lie-parent h <fl> v <fl> sc <fl>)
    (if (or (not parent) (not scaled?))
        (nextmethod h v sc)
      (get-lie-parent~ parent (+ (get-h~ position) (* h scaling)) (+ (get-v~ position) (* v scaling)) (* sc scaling))))

  
  ;;;
  ;;;; Global
  ;;;
  
  
  (method public (get-global) <Point>
    (+ (get-position-in-root~ (cast <Window> player)) (get-lie)))

  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method override (get-delta origin <View>)
    (let ((origin-player (get-player~ origin)))
      (if (and player origin-player (neq? player origin-player))
          (receive (h <fl> v <fl> sc <fl>) (get-lie-parent 0. 0. 1.)
            (let ((delta <Point> (- (get-global~ origin) (get-global))))
              (values (* (get-h~ delta) sc) (* (get-v~ delta) sc) sc)))
        (nextmethod origin))))
  
  
  ;;;
  ;;;; Position
  ;;;
  
  
  (method override (default-position) <Point>
    {Point 0 0})
  

  (method override (set-position pos <Point>)
    (when (/= pos position)
      ;; todo: it is possible to invalidate more precisely
      (let ((inval? (and player (is? parent View))))
        (let* ((bounds (and inval? (get-bounds)))
               (old (and inval? (acquire~ parent self bounds))))
          (set! position pos)
          (when player
            (let ((new (get-bounds)))
              (when old
                (invalidate-rect~ parent old))
              (invalidate-rect new)))))
      (position-change position)))
  

  (method package (set-position-noupdate pos <Point>)
    (when (/= pos position)
      (set! position pos)
      (position-change position)))

  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method override (default-size) <Dimension>
    {Dimension 100 100})
  
  
  (method public virtual (minimal-size)
    #f)
  
  
  (method public virtual (preferred-size) <Dimension>
    (get-size))
  
  (method public virtual (preferred-width) <fx>
    (get-width~ (preferred-size)))
  
  (method public virtual (preferred-height) <fx>
    (get-height~ (preferred-size)))
  
  
  (method public virtual (fit-size)
    )
  
  
  (method (invaled-size sz)
    (when (and player (is? parent View))
      (let ((old (get-bounds))
            (new (size-rect sz)))
        (acquire~ parent self (rect-union old new)))))
  

  (method override (set-size sz <Dimension>)
    (when (/= sz size)
      (let ((invaled-size (invaled-size sz)))
        (set! size sz)
        (size-change size)
        (unless scroller
          (content-size-change size))
        (when parent
          (adjust-fit~ parent))
        (when invaled-size
          (invalidate-rect~ parent invaled-size)))))
  
  
  (method override (set-size-noevent sz <Dimension>)
    (when (/= sz size)
      (let ((invaled-size (invaled-size sz)))
        (set! size sz)
        (when invaled-size
          (invalidate-rect~ parent invaled-size)))))
  
  
  (method public (set-preferred-size)
    (set-size (preferred-size)))
  
  (method public (set-preferred-width)
    (set-width (preferred-width)))
  
  (method public (set-preferred-height)
    (set-height (preferred-height)))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method public (layout-view)
    (layout-drawing))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method public (front-view)
    (last children))
  
  
  (method public (back-view)
    (first children))
  
  
  (method override (send-before target)
    (nextmethod target)
    (invalidate-view))
  
  
  (method override (bring-to-front)
    (unless (front?)
      (nextmethod)
      (invalidate-view)))


  (method override (send-to-back)
    (unless (back?)
      (nextmethod)
      (invalidate-view)))
  
  
  (method override (front-child? child)
    (eq? child (last children)))
  
  
  (method override (back-child? child)
    (eq? child (first children)))


  (method override (send-child-to-front child)
    (set! children (move-to-tail! child children)))


  (method override (send-child-to-back child)
    (set! children (move-to-head! child children)))

  
  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method public virtual (scrollee-size) <Dimension>
    (new Dimension (scrollee-width) (scrollee-height)))
  
  
  (method protected virtual (scrollee-width)
    (get-width))
  
  
  (method protected virtual (scrollee-height)
    (get-height))
  
  
  ;; not sure yet if we should always resize a scrollee not in a scroller
  ;; so for now we override those methods to implement dynamic scrollees
  (method protected virtual (dynamic-scrollee?)
    #f)
  
  
  (method protected virtual (dynamic-set-scrollee-size)
    (set-size (scrollee-size)))

  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method public (with-update-locked proc)
    (if update-locked?
        (proc)
      (unwind-protect
          (begin
            (set! update-locked? #t)
            (proc))
        (set! update-locked? #f)
        (invalidate-update))))
  
  
  (method protected virtual (invalidate-update)
    (invalidate-view)
    (update-scrollbars))

  
  ;;;
  ;;;; Rendering
  ;;;
  

  (method override (render surface draw-self? nodes context)
    (if renderer
        (render~ renderer self surface draw-self? nodes context)
      (nextmethod surface draw-self? nodes context)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method override (draw-background surface context)
    (let ((background (get-drawing-background context)))
      (when background
        (let ((bounds (get-bounds)))
          (fill-rect~ surface bounds background)))))
  
  
  (method public virtual (get-drawing-background context)
    background)
  
  
  (method override (draw-content surface context)
    (set-font~ surface (effective-font))
    (draw surface context))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method public virtual (get-look)
    )


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen surface <Surface+>)
    (let ((width (get-width~ size))
          (height (get-height~ size)))
      (if (and offscreen
               (let ((size (get-size~ offscreen)))
                 (and (<= width (get-width~ size))
                      (<= height (get-height~ size)))))
          (begin
            (renew-context~ offscreen)
            offscreen)
        (close-offscreen)
        (set! offscreen (new-offscreen surface width height))
        offscreen)))
  
  
  (definition (new-offscreen surface <Surface> width <fx> height <fx>)
    (new Memory-Surface surface (new Dimension width height)))
  
  
  (method package (close-offscreen)
    (when offscreen
      (close~ offscreen)
      (set! offscreen #f)))

  
  ;;;
  ;;;; Transparency
  ;;;

  
  (method override (get-opaque?)
    (boolean background))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (method public virtual (custom-page-setup?)
    #f)
  
  
  (method public virtual (get-page-setup)
    (default-page-setup~ (get-application)))
  
  
  (method public virtual (get-page-setup-designer)
    (default-page-setup-designer~ (get-application)))
  
  
  (method public virtual (get-page-setup-parcel designer)
    (default-page-setup-parcel~ (get-application) designer))
  
  
  (method public virtual (apply-page-setup designer form page-setup)
    (default-apply-page-setup~ (get-application) designer form page-setup))

  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method public virtual (print-document)
    (platform-print-document self))
  
  
  (method public virtual (print-picture)
    (platform-print-picture self))

  
  (method public virtual (print-layout (from-preview?: from-preview? #f))
    (with-locked-update
      (lambda ()
        (let* ((client (current-document))
               (current (selected-workspace))
               (ws (new Page-Workspace name: 'page previous: current)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-docked~ toplevel Page-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-preview) (not from-preview?))
            (layout-view~ toolbar)
            (invalidate-window~ toplevel))
          (let* ((frame (new-frame Page-Editor host-title: "Print Layout" client: client))
                 (pane (get-guest~ frame)))
            (acquire-focus~ pane))))))

  
  (method public virtual (print-layout-debug (from-preview?: from-preview? #f))
    (let ((client (current-document)))
      (let ((frame (new-frame Page-Editor host-title: "Print Layout" client: client)))
        (let ((pane (get-guest~ frame)))
          (acquire-focus~ pane)))))
  

  (method public virtual (print-preview (from-layout?: from-layout? #f))
    (with-locked-update
      (lambda ()
        (let* ((frame (new-frame Preview-Pane host-title: "Print Preview" host-visible?: #f client: self))
               (pane (get-guest~ frame))
               (current (selected-workspace))
               (ws (new Preview-Workspace name: 'preview previous: current pane: pane)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-docked~ toplevel Preview-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-layout) (not from-layout?))
            (layout-view~ toolbar)
            (invalidate-window~ toplevel))
          (set-visible?~ frame #t)
          (acquire-focus~ pane)))))
  

  (method public virtual (print-preview-debug (from-layout?: from-layout? #f))
    (setup-page-setup~ (get-application))
    (let ((frame (new-frame Preview-Pane host-title: "Print Preview" client: self)))
      (let ((pane (get-guest~ frame)))
        (acquire-focus~ pane))))
  
  
  (method public virtual (get-page-area context)
    #f)
  
  
  (method public virtual (get-print-area context)
    (position/size->rect {Point 0 0} (scrollee-size)))
  
  
  (method public virtual (paginate page-width page-height)
    (let* ((area (get-print-area #f))
           (width (rect-width area))
           (height (rect-height area))
           (cols (fxceiling/ width page-width))
           (rows (fxceiling/ height page-height))
           (pages (new List-Factory)))
      (for-each (lambda (row)
                  (for-each (lambda (col)
                              (let* ((h (+ (get-left~ area) (* col page-width)))
                                     (v (+ (get-top~ area) (* row page-height)))
                                     (page (new Rect h v (+ h page-width) (+ v page-height))))
                                (put~ pages page)))
                            (naturals 0 cols)))
                (naturals 0 rows))
      (get-output~ pages)))
  
  
  (method protected (with-printing proc)
    (let ((preserved #f))
      (unwind-protect
          (begin
            (set! preserved (setup-printing))
            (proc))
        (when preserved
          (restore-printing preserved)))))
  
  
  (method protected virtual (setup-printing)
    (let ((pos position)
          (sc? scaled?))
      (set! position (new Point 0 0))
      (set! scaled? #f)
      (update-displayed)
      (list position: pos scaled?: sc?)))
  
  
  (method protected virtual (restore-printing preserved)
    (set! position (getf preserved position:))
    (set! scaled? (getf preserved scaled?:))
    (update-displayed))
  
  
  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (export-picture (context: context '()) (where: where 'file) (destination: destination #f))
    (with ((surface (new Memory-Surface #f (get-size))))
      (set-clipper~ surface (new Rect 0 0 (get-width) (get-height)))
      (paint-drawing surface context)
      (export-to-png~ surface (or destination (choose-new-file default-extension: "png")))))


  @convert
  (method public (export-picture (context: context #f) (where: where 'file) (destination: destination #f))
    ;; it is necessary to use a temporary file because directly poping
    ;; the savefile dialog can disrupt the context (ex: popups closing)
    (let ((file (case where ((clipboard) #f) ((file) (create-temporary-file)))))
      (with-cursor :wait
        (lambda ()
          (let ((metafile))
            (with ((picture (new Picture file: file)))
              (with-printing
                (lambda ()
                  (let* ((area (get-print-area context))
                         (lie (get-lie))
                         (lh (get-h~ lie))
                         (lv (get-v~ lie)))
                    (let ((content (offset-rect area)))
                      (with-clip~ picture content
                        (lambda ()
                          (paint-drawing picture context (get-left~ content) (get-top~ content) 1. #f)))))))
              (set! metafile (get-metafile~ picture)))
            (if (eq? where 'clipboard)
                (set-clipboard-metafile metafile)
              (delete-metafile~ Picture metafile)
              (catch (Cancel-Signal
                       (delete-file~ file))
                (let ((dest (or destination (choose-new-file default-extension: "emf" extensions: '(("Enhanced metafiles" . "emf"))))))
                  (when (exists?~ dest)
                    (delete-file~ dest))
                  (move-pathname~ file dest)))))))))


  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method public (get-scroller)
    scroller)
  
  
  (method public virtual (set-scroller view)
    (set! scroller view))
  
  
  (method public virtual (set-scroll-pos part pos (redraw?: redraw? #f))
    (when scroller
      (set-scroll-pos~ scroller part pos redraw?: redraw?)))
    
  
  (method public virtual (set-scroll-info part min max page)
    (when scroller
      (set-scroll-info~ scroller part min max page)))
  
  
  (method public (compute-scroll-info)
    (let ((vmin #f)
          (vmax #f)
          (vpage #f)
          (vscroll? #f)
          (hmin #f)
          (hmax #f)
          (hpage #f)
          (hscroll? #f))
      (define (vupdate)
        (let ((adjust (if hscroll? scrollbar-size 0)))
          (set! vmin  0)
          (set! vmax  (- (get-height) adjust))
          (set! vpage (- (get-page-size 'vert) adjust))
          (set! vscroll? (> vmax vpage))))
      
      (define (hupdate)
        (let ((adjust (if vscroll? scrollbar-size 0)))
          (set! hmin  0)
          (set! hmax  (- (get-width) adjust))
          (set! hpage (- (get-page-size 'horz) adjust))
          (set! hscroll? (> hmax hpage))))
      
      (vupdate)
      (hupdate)
      (vupdate)
      (hupdate)
      (values vmin vmax vpage hmin hmax hpage)))
  
  
  (method public (update-scrollbars)
    (when (and scroller (not update-locked?))
      (receive (vmin vmax vpage hmin hmax hpage) (compute-scroll-info)
        (set-vscroll-needed?~ scroller (> vmax vpage))
        (when (get-vscroll?~ scroller)
          (set-scroll-info 'vert vmin vmax vpage))
        (set-hscroll-needed?~ scroller (> hmax hpage))
        (when (get-hscroll?~ scroller)
          (set-scroll-info 'horz hmin hmax hpage)))))
  
  
  (method public (vscroll-needed?)
    (receive (vmin vmax vpage hmin hmax hpage) (compute-scroll-info)
      (> vmax vpage)))
  
  
  (method public (hscroll-needed?)
    (receive (vmin vmax vpage hmin hmax hpage) (compute-scroll-info)
      (> hmax hpage)))
  
  
  (method public (scroll delta <Point> (redraw?: redraw? #f))
    (unless (= delta {Point 0 0})
      (scroll-to (+ (get-scrolled-position) delta) redraw?: redraw?)))
  
  
  (method public (scroll2 delta <Point> (redraw?: redraw? #f))
    (unless (= delta {Point 0 0})
      (scroll-to2 (+ (get-scrolled-position) delta) redraw?: redraw?)))
  
  
  (method public (scroll-to dest <Point> (redraw?: redraw? #f))
    (when (get-scroller)
      (let ((pos (get-scrolled-position)))
        ;; dest and pos are in this view coordinates
        (when (/= dest pos)
          (let* ((size (get-size))
                 (display (get-display))
                 (display-size (get-size~ display))
                 (sc (cast <fl> (if scaled? scaling 1.)))
                 (min-h (- (/ (cast <fl> (get-width~ display-size)) sc) (get-width~ size)))
                 (min-v (- (/ (cast <fl> (get-height~ display-size)) sc) (get-height~ size)))
                 (max-h 0)
                 (max-v 0)
                 (h (fxround (min (max (get-h~ dest) min-h) max-h)))
                 (v (fxround (min (max (get-v~ dest) min-v) max-v)))
                 (new-pos (new Point (fxround (* h sc)) (fxround (* v sc)))))
            (when (/= new-pos position)
              (set! position (new Point (fxround (* h sc)) (fxround (* v sc))))
              (let ((scrolled (get-scrolled-position)))
                (set-scroll-pos 'horz (- h) redraw?: redraw?)
                (set-scroll-pos 'vert (- v) redraw?: redraw?))
              (update-scrollbars)
              (let ((dh (- h (get-h~ pos)))
                    (dv (- v (get-v~ pos))))
                (scroll-invalidate dh dv)
                ;; temp for testing...
                (if scaled?
                    ;; convert to-fix scroll-view bugs when used from thumb-track
                    (invalidate-view~ scroller)
                  (let ((rect (get-bounds~ display)))
                    (scroll-view~ display dh dv rect))))))))))
  
  
  (method public (scroll-to2 dest <Point> (redraw?: redraw? #f))
    (let ((pos (get-scrolled-position)))
      ;; dest and pos are in this view coordinates
      (when (/= dest pos)
        (let* ((size (get-size))
               (display (get-display))
               (display-size (get-size~ display))
               (sc (cast <fl> (if scaled? scaling 1.)))
               (min-h (- (/ (cast <fl> (get-width~ display-size)) sc) (get-width~ size)))
               (min-v (- (/ (cast <fl> (get-height~ display-size)) sc) (get-height~ size)))
               (max-h 0)
               (max-v 0)
               (h (fxround (min (max (get-h~ dest) min-h) max-h)))
               (v (fxround (min (max (get-v~ dest) min-v) max-v)))
               (new-pos (new Point (fxround (* h sc)) (fxround (* v sc)))))
          (when (/= new-pos position)
            (set! position (new Point (fxround (* h sc)) (fxround (* v sc))))
            (let ((scrolled (get-scrolled-position)))
              (set-scroll-pos 'horz (- h) redraw?: redraw?)
              (set-scroll-pos 'vert (- v) redraw?: redraw?))
            (update-scrollbars)
            (let ((dh (- h (get-h~ pos)))
                  (dv (- v (get-v~ pos))))
              (scroll-invalidate dh dv)
              ;; temp for testing...
              (if scaled?
                  ;; convert to-fix scroll-view bugs when used from thumb-track
                  (invalidate-view~ scroller)
                (scroll-view2 dh dv (get-bounds)))))))))
  
  
  (method protected virtual (redraw-scrollbars)
    )
  
  
  (method protected virtual (scroll-invalidate dh dv)
    )
    
  
  (method public (scroll-view dh dv rect (clip-rect: clip-rect #f))
    (let ((player (get-player))
          (root (get-root))
          (display (get-display)))
      (when (and player (view-visible?))
        (let ((acquired (acquire~ root self rect))
              (clip-rect (acquire~ root self (or clip-rect (get-view-clipper)))))
          (receive (h v sc) (get-lie-parent 0. 0. 1.)
            (scroll-window~ player (fxround (* dh sc)) (fxround (* dv sc)) acquired clip-rect))))))
  
  
  ;; an attempt at a platform-independant scroll-view
  (method public (scroll-view2 dh dv rect (clip-rect: clip-rect #f))
    (let ((player (get-player))
          (root (get-root)))
      (when player
        (let ((acquired (acquire~ root self rect))
              (clip-rect (acquire~ root self (or clip-rect (get-view-clipper)))))
          (scroll-offscreen~ root dh dv acquired clip-rect)))))
  
  
  (method (scroll-offscreen dh dv src-rect clip-rect)
    (with ((surface (get-view-surface)))
      (let* ((src-rect (rect-intersection src-rect clip-rect))
             (dst-rect (offset-rect src-rect dh dv))
             (modified-rect (rect-intersection (rect-union src-rect dst-rect) clip-rect))
             (new-clipper (rect-intersection modified-rect dst-rect))
             (offscreen (get-offscreen #f)))
        (set-source-surface~ surface offscreen dh dv)
        (draw-rectangle~ surface new-clipper)
        (fill~ surface)
        (set-source-surface~ offscreen offscreen dh dv)
        (draw-rectangle~ offscreen new-clipper)
        (fill~ offscreen)
        (let ((ml (get-left~ modified-rect))
              (mt (get-top~ modified-rect))
              (mr (get-right~ modified-rect))
              (mb (get-bottom~ modified-rect)))
          (when (< dh 0)
            (invalidate-rect (new Rect (+ mr dh) mt mr mb)))
          (when (< dv 0)
            (invalidate-rect (new Rect ml (+ mb dv) mr mb)))
          (when (> dh 0)
            (invalidate-rect (new Rect ml mt (+ ml dh) mb)))
          (when (> dv 0)
            (invalidate-rect (new Rect ml mt mr (+ mt dv))))))))
 
  
  (method public (get-scrolled-position) <Point>
    (- (get-display-position)))
 
  
  (method public (get-scrolled-h) <fx>
    (get-h~ (get-scrolled-position)))
 
  
  (method public (get-scrolled-v) <fx>
    (get-v~ (get-scrolled-position)))
  
  
  (method public virtual (get-scroll-client)
    self)
  
  
  (method public virtual (get-line-size orientation) <fx>
    (case orientation
      ((vert) 13)
      ((horz) 8)))
  
  
  (method public virtual (get-page-size orientation) <fx>
    (let ((size
           (case orientation
             ((vert) (get-height~ parent))
             ((horz) (get-width~ parent)))))
      (if (not scaled?)
          size
        (fxround/ size scaling))))
  
  
  (method public (with-scrollee-locked proc)
    (if scrollee-locked?
        (proc)
      (unwind-protect
          (begin
            (set! scrollee-locked? #t)
            (proc))
        (set! scrollee-locked? #f))))
  
  
  (method public virtual (layout-scrollee)
    (define (scroll-to-fit)
      (let ((bottom (get-bottom))
            (fit (get-display-height)))
        (when (< bottom fit)
          (scroll (new Point 0 (- fit bottom)))))
      (let ((right (get-right))
            (fit (get-display-width)))
        (when (< right fit)
          (scroll (new Point (- fit right) 0)))))
    
    (unless update-locked?
      (when (dynamic-scrollee?)
        (dynamic-set-scrollee-size))
      (if (not scroller)
          (layout-scrollee-content)
        (let ((size (scrollee-size)))
          (when size
            (set-size size)
            (scroll-to-fit)
            ;; prevents multiple useless layouts that can occur when update scrollbars
            ;; resizes a view that will call layout-scrollee in response (ex: tree header)
            (unless scrollee-locked?
              ;; it is important to update scrollbars first as this can change
              ;; the scrollee size and we do not want to layout twice for nothing
              (with-scrollee-locked
                (lambda ()
                  (update-scrollbars)))
              (layout-scrollee-content)))))))
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method public virtual (layout-scrollee-patch)
    )
  
  
  (method public virtual (layout-scrollee-content)
    )


  (method package virtual (on-vscroll code thumb-pos orientation)
    )


  (method package virtual (on-hscroll code thumb-pos orientation)
    )


  ;;;
  ;;;; Display
  ;;;


  ;; to-convert clean all this by having the callers use (get-display)...
  
  
  (method public virtual (content-size-change size)
    )

  
  (method public (get-display)
    (if scroller
        parent
      self))
  
  
  (method public (get-display-position) <Point>
    (if scroller
        (let ((pos <Point> (- (get-position))))
          (if (not scaled?)
              pos
            (new Point
              (fxround/ (get-h~ pos) scaling)
              (fxround/ (get-v~ pos) scaling))))
      {Point 0 0}))
    
  
  (method public (get-display-h) <fx>
    (get-h~ (get-display-position)))
    
  
  (method public (get-display-v) <fx>
    (get-v~ (get-display-position)))
    
  
  (method public (get-display-size) <Dimension>
    (if scroller
        (let ((size <Dimension> (get-size~ parent)))
          (if (not scaled?)
              size
            (new Dimension (fxround/ (get-width~ size) scaling) (fxround/ (get-height~ size) scaling))))
      (get-size)))
    
  
  (method public (get-display-width) <fx>
    (if scroller
        (get-width~ (get-display-size))
      (get-width)))
    
  
  (method public (get-display-height) <fx>
    (if scroller
        (get-height~ (get-display-size))
      (get-height)))
  
  
  (method public (get-display-rect) <Rect>
    (if scroller
        (get-bounds~ parent)
      (get-bounds)))
  
  
  (method public (view->display pos <Point>) <Point>
    (if scroller
        (if (not scaled?)
            (+ pos position)
          (new Point (fxround (+ (get-h~ pos) (/ (cast <fl> (get-h~ position)) scaling))) (fxround (+ (get-v~ pos) (/ (cast <fl> (get-v~ position)) scaling)))))
      pos))

  
  (method public (h-view->display h <fx>) <fx>
    (if scroller
        (+ h (get-h~ (get-scrolled-position)))
      h))

  
  (method public (v-view->display v <fx>) <fx>
    (if scroller
        (+ v (get-v~ (get-scrolled-position)))
      v))

  
  (method public (display->view pos <Point>) <Point>
    (if scroller
        (- pos (get-scrolled-position))
      pos))

  
  (method public (h-display->view h) <fx>
    (if scroller
        (- h (get-h~ (get-scrolled-position)))
      h))

  
  (method public (v-display->view v) <fx>
    (if scroller
        (- v (get-v~ (get-scrolled-position)))
      v))
  
  
  (method public (scroll-needed start end context (force-vertical: force-vertical #f) (force-horizontal: force-horizontal #f) (reposition?: reposition? #f) (center?: center? #f)) <Point>
    (let ((display-pos (get-display-position))
          (display-size (get-display-size))
          (needed
            (lambda (start end context pos size force-direction center?)
              (let* ((start-offset (- pos start))
                     (end-offset (- (+ pos size) end))
                     (big-range? (> (- end start) size))
                     (proc (lambda (use-head?)
                             (let ((context (if context (fxround (* size context)) 0)))
                               (if use-head? (+ start-offset context) (- end-offset context))))))
                (cond
                  (center? (if (and (< start-offset 0) (> end-offset 0)) 0 (quotient (+ start-offset end-offset) 2)))
                  (reposition? (proc (neq? force-direction 'tail)))
                  ((and (> start-offset 0) (> end-offset 0)) (proc (if (not force-direction) (not big-range?) (eq? force-direction 'head))))
                  ((and (< start-offset 0) (< end-offset 0)) (proc (if (not force-direction) big-range? (eq? force-direction 'head))))
                  (else 0))))))
      (new Point
        (needed (get-h~ start) (get-h~ end) (and context (car context)) (get-h~ display-pos) (get-width~ display-size) force-horizontal #f)
        (needed (get-v~ start) (get-v~ end) (and context (cdr context)) (get-v~ display-pos) (get-height~ display-size) force-vertical center?))))
  
  
  (method public (horizontal-scroll-needed target direction) <fx>
    (let* ((start (get-display-h))
           (end (+ start (get-display-width))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))
  
  
  (method public (vertical-scroll-needed target direction) <fx>
    (let* ((start (get-display-v))
           (end (+ start (get-display-height))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))


  ;;;
  ;;;; Font
  ;;;
  
  
  (definition default-font
    'Label)


  (method public (get-font)
    font)
  

  (method public virtual (set-font fnt)
    (set! font fnt)
    (adjust-size))
  
  
  (method public virtual (effective-font)
    (or font (registered-font default-font)))


  ;;;
  ;;;; Style
  ;;;


  (method public (get-style)
    style)


  (method public (set-style value)
    (when (neq? value style)
      (set! style value)
      (style-update)))
  
  
  (method protected virtual (style-update)
    (invalidate-view))

  
  ;;;
  ;;;; Background
  ;;;
  
  
  (method public (get-background)
    background)
  
  
  (method public virtual (set-background color)
    (set! background color)
    (invalidate-view))
  
  
  ;;;
  ;;;; Sizing
  ;;;
  

  (method public (get-auto-size?)
    auto-size?)


  (method public (set-auto-size? value)
    (set! auto-size? value)
    (adjust-size))
  
  
  (method public (adjust-size)
    (when auto-size?
      (case auto-size?
        ((width) (set-preferred-width))
        ((height) (set-preferred-height))
        (else (set-preferred-size))))
    (invalidate-view))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-mouse-view pos)
    (or (get-captured-view)
        (find-drawing pos)))


  ;;;
  ;;;; Children
  ;;;


  (method public (first-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (first views))))


  (method public (second-view)
    (let ((views (get-views)))
      (if (>= (length views) 2)
          (second views)
        #f)))


  (method public (last-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (last views))))
    
  
  (method public (get-views (include-invisibles?: include-invisibles? #f))
    (reverse!
      (collect-if (lambda (child)
                    (and (is? child View)
                         (or include-invisibles? (get-visible?~ child))))
                  (get-children))))
  

  (method public (front-view?)
    (eq? self (first-view~ parent)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions)
    (cons (find-actions 'view)
          (nextmethod)))
  
  
  (method override (guest-actions)
    (cons (find-actions 'guest)
          (nextmethod)))


  ;;;
  ;;;; Content
  ;;;


  (method (call-content-change origin)
    (if content-change-handler
        (invoke-handler self content-change-handler (new Event :change self (list origin: origin)))
      (content-change origin)))
  
  
  (method public virtual (content-change origin)
    )


  ;;;
  ;;;; Selection
  ;;;
  

  (method public (call-selection-handler old selection force? user-origin)
    (when selection-handler
      (invoke-handler self selection-handler (new Selection-Event :selection-change self old selection force?: force? user-origin: user-origin))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method public virtual (get-view-state)
    )
  
  
  (method public virtual (set-view-state state)
    )


  ;;;
  ;;;; Modified State
  ;;;


  (method public virtual (get-modified?)
    modified?)


  (method public virtual (set-modified? state)
    (when (neq? state modified?)
      (set! modified? state)))

  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method public virtual (position-change position <Point>)
    )
  
  
  (method public virtual (size-change size <Dimension>)
    (let ((pw (and previous-size (get-width~ previous-size)))
          (ph (and previous-size (get-height~ previous-size)))
          (width (get-width~ size))
          (height (get-height~ size)))
      (set! previous-size size)
      (when pw
        (let ((dh (- width pw))
              (dv (- height ph)))
          (when (or (/= dh 0) (/= dv 0))
            (resize dh dv)))))
    (unless (adjust?)
      (invalidate-layout)
      (when (get-finished?)
        (call-layout))))


  (method protected virtual (resize dh <fx> dv <fx>)
    )

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (acquire-focus)
    (set-focus self))


  (method public (call-focus-gained)
    (set-focus-actions~ (get-application) (get-focus-actions self))
    (if focus-gained-handler
        (invoke-handler self focus-gained-handler (new Event :focus-gained self))
      (focus-gained)))


  (method public (call-focus-lose)
    (set-focus-actions~ (get-application) '())
    (if focus-lose-handler
        (invoke-handler self focus-lose-handler (new Event :focus-lose self))
      (focus-lose)))
  
  
  (method public (call-focus-lost)
    (focus-lost))
  
  
  (method public (has-focus?)
    (eq? self (get-focus)))
  
  
  (method public (is-focused?)
    (or (has-focus?)
        (memq? self (get-pushed-focuses~ player))))
  
  
  (method public virtual (focus-lose)
    )
  
  
  (method public virtual (focus-lost)
    )
  
  
  (method public virtual (focus-master)
    self)
  
  
  (method public virtual (focus-reset)
    #f)
  
  
  (method public virtual (focus-gained)
    )
  
  
  (method public virtual (focus-delegate)
    )
  
  
  (method public virtual (focus-update-actions)
    )


  (method public virtual (get-focus-container)
    (find-ascendant Focus-Container))
  
  
  (method public virtual (focusable?)
    (and (in-player?)
         (get-visible?)
         (let ((container (get-focus-container)))
           (or (not container)
               (container-focusable?~ container)))))
  
  
  (method public virtual (ensure-focusable)
    (let ((container (get-focus-container)))
      (when container
        (ensure-container-focusable~ container))))


  ;;;
  ;;;; Action
  ;;;
  
  
  (method public (get-action-handler)
    action-handler)
  
  
  (method public virtual (set-action-handler value)
    (set! action-handler value)
    (when (is? action-handler Action)
      (let ((action-item (require-action-item action-handler)))
        (when action-item
          (register-actionable~ action-item self)))))


  (method public virtual (process-action sender (properties (action-properties)))
    (notify-action sender properties))
  
  
  (method protected virtual (action-properties)
    #f)
  
  
  (method public (notify-action sender properties)
    (when action-handler
      (notify-handler self action-handler sender properties)))
  
  
  ;;;
  ;;;; Receive Files
  ;;;

  
  (method protected (dispatch-receive-files pos files)
    (let ((view (find-mouse-view pos)))
      (when view
        (let ((view-pos (acquire~ view self pos)))
          (call-receive-files~ view view-pos files)))))

  
  (method public (call-receive-files pos files)
    (if receive-files-handler
        (invoke-handler self receive-files-handler (new Event :receive-files self position: pos files: files))
      (receive-files pos files)))
  
  
  (method public virtual (receive-files pos pathnames)
    (let ((appl (get-application)))
      (let ((stage (find-ascendant Stage include-self?: #t)))
        (when stage
          (set-current-stage stage)))
      (receive-files~ appl pos pathnames)))


  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (call-cursor-update pos)
    (if cursor-update-handler
        (invoke-handler self cursor-update-handler (new Cursor-Event :set-cursor self pos))
      (cursor-update pos)))
  
  
  (method public virtual (cursor-update pos)
    (unless (current-drag-drop)
      (set-cursor :arrow)))
  
  
  (method public (mouse-pressed?)
    mouse-down?)
  
  
  (method public (mouse-right-pressed?)
    (get-mouse-right-down?))
  
  
  (method public (mouse-in?)
    (eq? self (get-mouse-in)))
  
  
  (method public (mouse-over?)
    (over-view? (mouse-position)))


  (method public (over-view? point)
    (let ((bounds (get-bounds)))
      (in-rect? point bounds)))


  (method public (mouse-position)
    (let ((player (get-player))
          (root (get-root)))
      (acquire root (mouse-position~ player))))


  ;;;
  ;;;; Mouse
  ;;;
    
  
  (method (call-mouse-hover pos)
    (if mouse-hover-handler
        (invoke-handler self mouse-hover-handler (new Mouse-Event :mouse-hover self pos))
      (mouse-hover pos))
    (when (get-tooltip?)
      (popup-tooltip pos)))
  
  
  (method protected (dispatch-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view event: 'mouse-down)
        (let ((actual-focus (get-focus))
              (acquired (acquire~ view self pos)))
          (set-mouse-down? #t)
          (set-mouse-down-view view)
          (set-mouse-down-point acquired)
          (unless (and (alt-down?) actual-focus (mouse-copy~ view acquired actual-focus))
            (when (mouse-activate?~ view)
              (let ((host (get-host~ view)))
                (when (and host (mouse-activate?~ host) (not (focused-host? host)))
                  (mouse-activate~ host))))
            (call-mouse-down~ view acquired)
            (call-cursor-update~ view acquired))))))

  
  (method public (call-mouse-down pos)
    (if mouse-down-handler
        (invoke-handler self mouse-down-handler (new Mouse-Event :mouse-down self pos))
      (mouse-down pos)))
  
  
  (method protected (dispatch-mouse-move h v)
    (let ((pos (new Point h v)))
      (let ((view (find-mouse-view pos)))
        (when view
          (let ((player (get-player~ view)))
            (when (and player (is-not? (get-overlapped) Tooltip))
              (when (neq? view (get-mouse-in))
                (when (get-mouse-in)
                  (call-mouse-leave~ (get-mouse-in))
                  (cancel-mouse-leave-tracking (get-handle~ player))
                  (unless (or (is? player Tooltip) (in-tooltip? pos))
                    (cancel-tooltip-tracking)))
                (set-mouse-in view)
                (when (get-mouse-in)
                  (call-mouse-enter~ (get-mouse-in)))
                (track-mouse-leave (get-handle~ player)))
              (unless (or *current-tooltip-context* (current-drag-drop))
                (track-tooltip~ (get-mouse-in)))
              (if mouse-down?
                  (let ((acquired (acquire~ mouse-down-view self pos)))
                    (call-cursor-update~ mouse-down-view acquired)
                    (process-drag-move~ mouse-down-view acquired))
                (let ((acquired (acquire~ view self pos)))
                  (call-cursor-update~ view acquired)
                  (process-mouse-move~ view acquired)))))))))

  
  (method (process-mouse-move pos)
    (when *current-tooltip-context*
      (process-tooltip pos))
    (call-mouse-move pos))
  
  
  (method (call-mouse-move pos)
    (if mouse-move-handler
        (invoke-handler self mouse-move-handler (new Mouse-Event :mouse-move self pos))
      (mouse-move pos)))
  
  
  (method protected (dispatch-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when mouse-down?
        (process-drag-up~ mouse-down-view (acquire~ mouse-down-view self pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (call-cursor-update~ view acquired)
          (process-mouse-up~ view acquired))))
    (when (get-delayed-mouse-action)
      (let ((action (get-delayed-mouse-action)))
        (set-delayed-mouse-action #f)
        (action))))

  
  (method (process-mouse-up pos)
    (when (current-drag-drop)
      (drag-drop (current-drag-drop) pos))
    (call-mouse-up pos))

  
  (method (call-mouse-up pos)
    (if mouse-up-handler
        (invoke-handler self mouse-up-handler (new Mouse-Event :mouse-up self pos))
      (mouse-up pos)))

  
  (method (process-drag-move pos)
    (if (and (eq? self mouse-down-view) (get-draggable?) (or (not (current-drag-drop)) (eq? self (get-view~ (get-source~ (current-drag-drop))))))
        (begin
          (when (allow-start-drag? pos)
            (let ((drag-drop (get-drag-drop)))
              (when drag-drop
                (drag-start pos drag-drop))))
          (when (current-drag-drop)
            (drag-follow pos)))
      (call-drag-move pos)))
  
  
  (method protected virtual (allow-start-drag? pos)
    (and mouse-down? (not (current-drag-drop)) (not (near? pos mouse-down-point drag-tolerance))))
  
  
  (method (call-drag-move pos)
    (if drag-move-handler
        (invoke-handler self drag-move-handler (new Mouse-Event :drag-move self pos))
      (drag-move pos)))

  
  (method (process-drag-up pos (dragging? (current-drag-drop)))
    (set-mouse-down? #f)
    (set-mouse-down-view #f)
    (set-mouse-down-point #f)
    (when player
      (call-drag-up pos dragging?)))

  
  (method (call-drag-up pos dragging?)
    (if drag-up-handler
        (invoke-handler self drag-up-handler (new Mouse-Event :drag-up self pos))
      (drag-up pos dragging?)))
  
  
  (method protected (dispatch-double-click h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view event: 'double-click)
        (let ((acquired (acquire~ view self pos)))
          (set-mouse-down? #t)
          (set-mouse-down-view view)
          (set-mouse-down-point acquired)
          (when (mouse-activate?~ view)
            (let ((host (get-host~ view)))
              (when (and host (mouse-activate?~ host) (not (focused-host? host)))
                (mouse-activate~ host))))
          (call-double-click~ view (acquire~ view self pos))))))
  
  
  (method public virtual (call-double-click pos)
    (if double-click-handler
        (invoke-handler self double-click-handler (new Mouse-Event :double-click self pos))
      (double-click pos)))
  
  
  (method protected (dispatch-context-menu h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when (and view (view-enabled?~ view))
        (close-popups~ view event: 'context-menu)
        (call-context-menu~ view (acquire~ view self pos)))))
  
  
  (method public (call-context-menu pos)
    (if context-menu-handler
        (invoke-handler self context-menu-handler (new Mouse-Event :context-menu self pos))
      (context-menu pos)))
  
  
  (method protected (dispatch-middle-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-middle-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set-mouse-right-down? #t)
      (when view
        (right-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set-mouse-right-down? #f)
      (when view
        (right-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method (call-mouse-enter)
    (if mouse-enter-handler
        (invoke-handler self mouse-enter-handler (new Mouse-Event :mouse-enter self #f))
      (mouse-enter)))
  
  
  (method (call-mouse-leave)
    (cancel-hovering)
    (close-self-tooltip)
    (if mouse-leave-handler
        (invoke-handler self mouse-leave-handler (new Mouse-Event :mouse-leave self #f))
      (mouse-leave)))
  
  
  (method public virtual (mouse-hover pos)
    )
  
  
  (method public virtual (mouse-wheel pos delta)
    (when (get-scroller)
      (if (shift-down?)
          (scroll (new Point (quotient delta 3) 0))
        (scroll (new Point 0 (quotient delta 3))))))

  
  (method public virtual (mouse-enter)
    )

  
  (method public virtual (mouse-leave)
    )

  
  (method public virtual (mouse-down pos)
    )
  
  
  (method public virtual (mouse-move pos)
    )
  
  
  (method public virtual (mouse-up pos)
    )
  
  
  (method public virtual (drag-move pos)
    )
  
  
  (method public virtual (drag-up pos . rest)
    )
  
  
  (method public virtual (double-click pos)
    (call-mouse-down pos))
  
  
  (method public virtual (with-context-click pos proc)
    (proc))
  
  
  (method public virtual (context-menu pos)
    )
  
  
  (method public virtual (get-context-menu)
    #f)
  
  
  (method public virtual (middle-mouse-down pos)
    (mouse-down pos))
  
  
  (method public virtual (middle-mouse-up pos)
    (mouse-up pos))
  
  
  (method public virtual (right-mouse-down pos)
    )
  
  
  (method public virtual (right-mouse-up pos)
    )
  
  
  (method public virtual (mouse-activate?)
    #t)


  (method public (mouse-view)
    (or (get-captured-view) (get-mouse-in)))


  ;;;
  ;;;; Hovering
  ;;;
  
  
  (definition Hovering-Tolerance
    3)
  
  (definition Hovering-Time
    0.5)
  
  (definition Hovering-Steps
    5)
  
  
  (method public (track-hovering (time: time Hovering-Time))
    (define (check-hovering start)
      (if (neq? (mouse-view) self)
          (cancel-hovering)
        (when hover-history
          (let ((pos (mouse-position)))
            (if (< (length hover-history) Hovering-Steps)
                (set! hover-history (cons pos hover-history))
              (if (every? (lambda (point)
                            (< (distance point pos) Hovering-Tolerance))
                          hover-history)
                  (begin
                    (cancel-hovering)
                    (call-mouse-hover pos))
                (set! hover-history (cons pos hover-history))
                (set-cdr! (tail hover-history (- Hovering-Steps 1)) '())))))))
    
    (cancel-hovering)
    (let ((start (mouse-position))
          (period (/ (cast <fl> time) Hovering-Steps)))
      (set! hover-history '())
      (set! hover-pulse (new Pulse 'hovering period (lambda () (check-hovering start)) delay: 0))))
  
  
  (method public (cancel-hovering)
    (when hover-pulse
      (close~ hover-pulse)
      (set! hover-history #f)
      (set! hover-pulse #f)))
  

  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (definition package *current-tooltip-context*
    #f)
  
  (definition *recent-tooltip-close*
    #f)
  
  (definition *last-tooltip-position*
    #f)
  
  
  (method (track-tooltip)
    (define (recently-closed?)
      (and *recent-tooltip-close* (< (time->seconds (current-time)) *recent-tooltip-close*)))
    
    (when (and (get-tooltip?) (get-player))
      (if (recently-closed?)
          (track-hovering time: 0.1)
        (track-hovering))))
  
  
  (method (cancel-tooltip-tracking)
    (cancel-hovering)
    (close-tooltip))
  
  
  (method public (reset-tooltip)
    (cancel-tooltip-tracking))
  
  
  (method (in-tooltip? pos)
    (when *current-tooltip-context*
      (let ((view (get-view~ *current-tooltip-context*))
            (rect (get-bounds~ *current-tooltip-context*)))
        (when rect
          (in-rect? (acquire~ view self pos) rect)))))
  
  
  (method (process-tooltip pos)
    (let ((overlapped (get-overlapped)))
      (unless (is? overlapped Tooltip)
        (let ((view (get-view~ *current-tooltip-context*))
              (bounds (get-bounds~ *current-tooltip-context*))
              (new-bounds (get-tooltip-bounds pos)))
          (unless (and (eq? overlapped (get-overlapped~ view))
                       (nu=? bounds new-bounds))
            (reset-tooltip))))))
  
  
  (method (popup-tooltip pos)
    (define (same-position?)
      (and *last-tooltip-position* (nu=? pos *last-tooltip-position*)))
    
    (define (new-tooltip-view text)
      (if (and (get-formatted-tooltip?) (pair? text))
          (let* ((view (new Tooltip-Text size: {Dimension 4000 100}))
                 (text-view (get-text~ view))
                 (text-model (get-model~ text-view)))
            (set-text~ text-model text)
            (set-size~ view (nu+ (scrollee-content-size~ text-view) {Dimension 2 2}))
            view)
        (new Tooltip-Label title: text)))
    
    (define (new-tooltip text font position padding)
      (let ((view (new-tooltip-view text))
            (border (new Border-View border-type: 'solid)))
        (when font
          (set-font~ view font))
        (set-preferred-size~ view)
        (let ((padding (or padding (new Dimension 0 (get-cursor-height))))
              (position (or position pos)))
          (popup view position padding: padding class: Tooltip border: border))))
    
    (define (get-cursor-height)
      (let ((cursor (get-cursor)))
        (case cursor
          ((:ibeam) 9)
          (else 21))))
    
    (unless (or mouse-down? (current-drag-drop) (in-tooltip? pos))
      (close-tooltip)
      (unless (same-position?)
        (set! *current-tooltip-context* (get-tooltip-context pos))
        (if *current-tooltip-context*
            (let ((text (get-text~ *current-tooltip-context*))
                  (font (get-font~ *current-tooltip-context*))
                  (position (get-position~ *current-tooltip-context*))
                  (padding (get-padding~ *current-tooltip-context*)))
              (set-tooltip~ *current-tooltip-context* (new-tooltip text font position padding)))
          (set! *last-tooltip-position* pos)
          (reset-tooltip)))))
  
  
  ;; only works for rich tooltips for now
  (method public (update-tooltip text)
    (when *current-tooltip-context*
      (let* ((tooltip (get-tooltip~ *current-tooltip-context*))
             (border (first-child~ (get-root~ tooltip)))
             (view (first-child~ border))
             (text-view (get-text~ view)))
        (set-size~ view {Dimension 4000 100})
        (set-text~ (get-model~ text-view) text)
        (set-size~ tooltip (nu+ (scrollee-content-size~ text-view) {Dimension 6 6}))
        (set-size~ border (get-size~ tooltip))
        (layout-view~ border))))
  
  
  (method virtual (close-self-tooltip)
    (when (and *current-tooltip-context* (eq? self (get-view~ *current-tooltip-context*)))
      (close-tooltip)))
  
  
  (method (close-tooltip)
    (when *current-tooltip-context*
      (let ((tooltip (get-tooltip~ *current-tooltip-context*)))
        (when (and tooltip (opened?~ tooltip))
          (close-popup tooltip)))
      (set! *current-tooltip-context* #f)
      (set! *recent-tooltip-close* (+ (time->seconds (current-time)) 0.5))))


  ;;;
  ;;;; Groups
  ;;;
  
  
  (method public (get-selected-element (class: class Radio-Button) (group: group #f))
    (let ((element
            (find-if (lambda (child)
                       (and (is? child class)
                            (eqv? (get-group~ child) group)
                            (get-selected?~ child)))
                     children)))
      (when element
        (get-name~ element))))
  
  
  (method public (set-selected-element name (class: class Radio-Button) (group: group #f))
    (let ((found? #f))
      (for-each (lambda (child)
                  (when (and (is? child class)
                             (eqv? (get-group~ child) group))
                    (let ((selected? (eq? (get-name~ child) name)))
                      (set-selected?~ child selected?)
                      (when selected?
                        (set! found? #t)))))
                children)
      (unless found?
        (error "Unable to find element: {t}" name))))
  
  
  (method public (unselect-elements (class: class Radio-Button) (group: group #f))
    (for-each (lambda (child)
                (when (and (is? child class)
                           (eqv? (get-group~ child) group))
                  (unselect~ child)))
              children))


  ;;;
  ;;;; Context Menu
  ;;;
  
  
  (method public (track-popup-menu menu pos (alternate-position: alternate-position #f) (initiator: initiator self))
    (define (all-invisible? menu)
      (every? (lambda (item)
                (not (get-visible?~ item)))
              (get-children~ menu)))
    
    (if (is-not? menu Context-Menu)
        (error "{t} is not of the expected Context-Menu class" menu)
      (unless (all-invisible? menu)
        (clear-highlighted~ menu)
        (let ((popup (popup menu pos alternate-position: alternate-position class: Menu-Transient initiator: initiator)))
          (push-focus menu)
          popup))))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method override (get-context-text)
    #f)
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;

  
  (method public virtual (mouse-copy pos destination)
    (let ((data (mouse-data pos)))
      (if (not data)
          #f
        (mouse-insert~ destination data)
        #t)))

  
  (method public virtual (mouse-data pos)
    #f)

  
  (method public virtual (mouse-insert object)
    )
  
  
  ;;;
  ;;;; Desktop
  ;;;
  
  
  (method public (to-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire~ desktop player (acquire~ root self shape))))
  
  
  (method public (from-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire root (acquire~ player desktop shape))))
  
  
  ;;;
  ;;;; Popup
  ;;;
  
  
  (method public (popup view <View> position <Point> (padding: padding #f) (alternate-position: alternate-position #f) (initiator: initiator self) (class: class Popup) (border: border #f) (fade-speed: fade-speed #f) (effect: effect #f) (close-behavior: close-behavior #f))
    (let* ((player (get-player))
           (max (rect-size (get-work-area)))
           (alternate (and alternate-position (to-desktop alternate-position)))
           (position (to-desktop position))
           (size (+ (get-size~ view) {Dimension 4 4}))
           (padding (or padding {Dimension 0 0}))
           (border (or border (new Border-View name: 'border border-type: 'raised)))
           (popup (popup~ player class position: (fit-point position alternate size max padding) size: size close-behavior: close-behavior)))
      (set-initiator~ popup initiator)
      (set-parent~ border (get-root~ popup))
      (set-position~ border {Point 0 0})
      (set-size~ border (get-size~ popup))
      (set-parent~ view border)
      (set-visible?~ view #t)
      (layout-view~ border)
      (set-effect~ (get-root~ popup) effect)
      (fade-in~ popup fade-speed: fade-speed)
      popup))
  
  
  (method package (close-current-popup)
    (when (is? player Popup)
      (close-popup player)))
  
  
  (method public virtual (close-popups (event: event #f) (all?: all? #f) (exclude: exclude #f))
    (when player
      (close-popups~ player all?: all? exclude: exclude)))
  
  
  (method public virtual (popup-destroy popup)
    )
  
  
  (method public (popup-initiator)
    (let ((overlapped (get-overlapped)))
      (when (is? overlapped Popup)
        (get-initiator~ overlapped))))
  
  
  (method public (owned? overlapped)
    (memq? overlapped (get-owners~ (get-overlapped))))


  ;;;
  ;;;; Drag
  ;;;


  (method public virtual (get-draggable?)
    draggable?)


  (method public (set-draggable? flag)
    (set! draggable? flag))


  (method public virtual (get-drag-drop)
    (let ((source (get-drag-source)))
      (when source
        (new DnD source: source))))
  
  
  (method public virtual (get-drag-source)
    (let ((pos (get-drag-position)))
      (new Drag-Source view: self position: pos image: (get-drag-image pos))))
  
  
  (method public virtual (get-drag-position)
    mouse-down-point)
  
  
  (method public virtual (get-drag-image pos)
    #f)
  
  
  (method (drag-start pos drag-drop)
    (set-current-drag-drop drag-drop)
    (let ((view (get-view~ (get-source~ drag-drop))))
      (set-cursor :no)
      (acquire-focus~ view)
      (acquire-capture~ view)
      (let ((global (to-desktop~ view pos)))
        (hide-drag-image)
        (process-drag-feedback global))))
  
  
  (method (drag-follow pos)
    (when (current-drag-drop)
      (let* ((drag-drop (current-drag-drop))
             (view (get-view~ (get-source~ drag-drop)))
             (global (to-desktop~ view pos)))
        (process-drag-feedback global))))
  
  
  (method (drag-drop drag-drop pos)
    (drag-end)
    (when (get-target~ drag-drop)
      (drop drag-drop pos)))
  
  
  (method (drag-end)
    (when (current-drag-drop)
      (let ((drag-drop (current-drag-drop)))
        (hide-drag-image)
        (unhighlight-current drag-drop)
        (release-capture~ (get-view~ (get-source~ drag-drop)))
        (set-current-drag-drop #f))))
  
  
  (method (process-drag-feedback global)
    (let* ((drag-drop (current-drag-drop))
           (current (get-view~ drag-drop))
           (desktop (get-desktop))
           (view (find-view~ desktop global)))
      (set-view~ drag-drop view)
      (when view
        (let* ((local (to-view~ desktop global view))
               (target (call-current-drop~ view drag-drop local)))
          (when (neq? target (get-target~ drag-drop))
            (set-cursor (if target :move :no))
            (hide-drag-image)
            (unhighlight-current drag-drop)
            (set-target~ drag-drop target)
            (when target
              (highlight-current drag-drop view local))
            (when target
              (show-drag-image)))))))
  
  
  (method (hide-drag-image)
    @old(ImageList_DragShowNolock #f))
  
  
  (method (show-drag-image)
    @old(ImageList_DragShowNolock #t))
  
  
  (method (highlight-current drag-drop view local)
    (highlight-drop~ view drag-drop local))
  
  
  (method (unhighlight-current drag-drop)
    (let ((current-target (get-target~ drag-drop)))
      (when current-target
        (unhighlight-drop~ (get-view~ current-target) drag-drop))))
  
  
  (method public virtual (highlight-drop drag-drop pos)
    )
  
  
  (method public virtual (unhighlight-drop drag-drop)
    )


  ;;;
  ;;;; Drop
  ;;;
  
  
  (method public (call-current-drop drag-drop pos)
    (if current-drop-handler
        (invoke-handler self current-drop-handler (new Drop-Event :drop-target self pos drag-drop))
      (current-drop drag-drop pos)))

  
  (method public virtual (current-drop drag-drop pos)
    #f)
  
  
  (method public (standard-current-drop evt acceptance (handler: handler #f))
    (let* ((sender (get-sender~ evt))
           (pos (get-position~ evt))
           (drag-drop (get-drag-drop~ evt))
           (current (get-target~ drag-drop))
           (drag-start (get-view~ (get-source~ drag-drop)))
           (drag-over (get-view~ drag-drop))
           (drag-info (cons drag-start drag-over)))
      (if (neq? drag-start drag-over)
          (let ((criteria (find-if (lambda (criteria) (accepts?~ criteria drag-info)) acceptance)))
            (if criteria
                (new Drop-Target handler: handler view: sender position: pos criteria: criteria)
              (current-drop~ sender drag-drop pos)))
        (current-drop~ sender drag-drop pos))))

  
  (method public virtual (drop drag-drop pos)
    (let* ((src (get-view~ (get-source~ drag-drop)))
           (trg (get-target~ drag-drop))
           (dst (or (get-handler~ trg) (get-view~ trg))))
      (when dst
        (call-receive-drop~ dst self (acquire~ dst src pos) drag-drop))))
  
  
  (method public (call-receive-drop sender pos drag-drop)
    (if receive-drop-handler
        (invoke-handler self receive-drop-handler (new Drop-Event :receive-drop sender pos drag-drop))
      (receive-drop sender pos drag-drop)))
  
  
  (method public virtual (receive-drop sender pos drag-drop)
    )


  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method protected (call-key-press key)
    (if key-press-handler
        (invoke-handler self key-press-handler (new Keyboard-Event :char self key))
      (let ((handler {Event-Handler :focus on-insert})
            (event (new Event (if char? :char :key) self content: key)))
        (hook-event handler event
          (lambda ()
            (key-press key))))))
  
  
  (method (on-arrow evt)
    (call-arrow-press evt))

  
  (method (call-arrow-press evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (arrow-press evt)))


  (method public virtual (arrow-press evt)
    (let ((direction (get-property~ evt direction:))
          (modifiers (get-modifiers~ evt)))
      (case direction
        ((left)  (left-arrow-press  modifiers))
        ((right) (right-arrow-press modifiers))
        ((up)    (up-arrow-press    modifiers))
        ((down)  (down-arrow-press  modifiers)))))


  (method public virtual (left-arrow-press modifiers)
    )


  (method public virtual (right-arrow-press modifiers)
    )


  (method public virtual (up-arrow-press modifiers)
    )


  (method public virtual (down-arrow-press modifiers)
    )
  
  
  (method package virtual (on-escape-press evt)
    (call-escape-press #\escape))
  
  
  (method (call-escape-press key)
    (if escape-press-handler
        (invoke-handler self escape-press-handler (new Keyboard-Event :char self key))
      (escape-press key)))


  (method public virtual (escape-press key)
    )
  
  
  (method package virtual (on-backspace-press evt)
    (call-backspace-press #\backspace))
  
  
  (method (call-backspace-press key)
    (if backspace-press-handler
        (invoke-handler self backspace-press-handler (new Keyboard-Event :char self key))
      (backspace-press key)))


  (method public virtual (backspace-press key . rest)
    )
  
  
  (method package virtual (on-return-press evt)
    (call-return-press #\return))
  

  (method (call-return-press key)
    (if return-press-handler
        (invoke-handler self return-press-handler (new Keyboard-Event :char self key))
      (return-press key)))


  (method public virtual (return-press key)
    )
  
  
  (method package virtual (on-tab-press evt)
    (call-tab-press #\tab))
  
  
  (method (call-tab-press key)
    (if tab-press-handler
        (invoke-handler self tab-press-handler (new Keyboard-Event :char self key))
      (tab-press key (modifiers-keys))))


  (method public virtual (tab-press key modifiers)
    (navigate-view (shift-key? modifiers)))
  
  
  (method package (on-key-press evt)
    (key-press (get-property~ evt key:)))


  (method public virtual (key-press key)
    )
  
  
  (method protected (dispatch-key-press key)
    (if (and (current-drag-drop) (eqv? key #\escape))
        (begin
          (drag-end)
          (complete-drag-up #t))
      (let ((view (get-focus)))
        (when view
          (call-key-press~ view key)))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method public (find-tab-manager)
    (if (get-tab-stops)
        self
      (let ((ascendant (find-ascendant View)))
        (if (not ascendant)
            self
          (find-tab-manager~ ascendant)))))
  
  
  (method public virtual (navigate-tab from backward?)
    (define (navigate from to)
      (tab-stop-exit~ from)
      (acquire-focus~ to)
      (tab-stop-enter~ to))

    (let ((to (navigated-view from backward?)))
      (if to
          (let ((enabled (view-enabled?~ to)))
            (while (and (not disabled-navigate?) (not enabled))
              (set! to (navigated-view to backward?))
              (set! enabled (view-enabled?~ to)))
            (if (is? to View)
                  (navigate-tab~ to self backward?)
                (navigate from to)))
        (navigate from self))))
  
  
  (method public (navigated-view from backward? (test: test #f))
    (let ((stops (get-tab-stops)))
      (when stops
        (let ((count (length stops))
              (rank (find stops from test: test)))
          (when rank
            (let ((new-rank (if backward? (if (= rank 0) (- count 1) (- rank 1)) (modulo (+ rank 1) count))))
              (element stops new-rank)))))))
  
  
  (method protected (navigate-view backward?)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self backward?)))
  
  
  (method public virtual (get-tab-stops)
    #f)
  
  
  (method public virtual (tab-stop-enter)
    (select-all))
  
  
  (method public virtual (tab-stop-exit)
    )


  ;;;
  ;;;; Edition
  ;;;
  
  
  (method (on-undo evt)
    (if (not surrogate)
        (undo)
      (undo~ surrogate)))
  
  
  (method (on-redo evt)
    (if (not surrogate)
        (redo)
      (redo~ surrogate)))
  
  
  (method (on-cut evt)
    (if (not surrogate)
        (cut-selection)
      (cut-selection~ surrogate)))
  
  
  (method (on-copy evt)
    (if (not surrogate)
        (copy-selection)
      (copy-selection~ surrogate)))
  
  
  (method (on-paste evt)
    (if (not surrogate)
        (paste-clipboard)
      (paste-clipboard~ surrogate)))
  
  
  (method (on-paste-properties evt)
    (if (not surrogate)
        (paste-properties)
      (paste-properties~ surrogate)))
  
  
  (method (on-delete evt)
    (if (not surrogate)
        (delete-selection)
      (delete-selection~ surrogate)))
  
  
  (method (on-rename evt)
    (if (not surrogate)
        (rename-selection)
      (rename-selection~ surrogate)))
  
  
  (method (on-select-all evt)
    (if (not surrogate)
        (select-all)
      (select-all~ surrogate)))
  
  
  (method public (can-view-undo?)
    (if surrogate
        (can-undo?~ surrogate)
      (can-undo?)))
  
  
  (method public virtual (can-undo?)
    #f)
  
  
  (method public (can-view-redo?)
    (if surrogate
        (can-redo?~ surrogate)
      (can-redo?)))
  
  
  (method public virtual (can-redo?)
    #f)
  
  
  (method public (can-view-cut?)
    (if surrogate
        (can-cut?~ surrogate)
      (can-cut?)))
  
  
  (method public virtual (can-cut?)
    #f)
  
  
  (method public (can-view-copy?)
    (if surrogate
        (can-copy?~ surrogate)
      (can-copy?)))
  
  
  (method public virtual (can-copy?)
    #f)
  
  
  (method public (can-view-paste?)
    (if surrogate
        (can-paste?~ surrogate)
      (can-paste?)))
  
  
  (method public virtual (can-paste?)
    #f)
  
  
  (method public (can-view-paste-properties?)
    (if surrogate
        (can-paste-properties?~ surrogate)
      (can-paste-properties?)))
  
  
  (method public virtual (can-paste-properties?)
    #f)
  
  
  (method public (can-view-delete?)
    (if surrogate
        (can-delete?~ surrogate)
      (can-delete?)))
  
  
  (method public virtual (can-delete?)
    #f)
  
  
  (method public (can-view-rename?)
    (if surrogate
        (can-rename?~ surrogate)
      (can-rename?)))
  
  
  (method public virtual (can-rename?)
    #f)
  
  
  (method public (can-view-select-all?)
    (if surrogate
        (can-select-all?~ surrogate)
      (can-select-all?)))
  
  
  (method public virtual (can-select-all?)
    #f)
  
  
  (method public virtual (undo)
    )
  
  
  (method public virtual (redo)
    )
  
  
  (method public virtual (cut-selection)
    )
  
  
  (method public virtual (copy-selection)
    )
  
  
  (method public virtual (paste-clipboard)
    )
  
  
  (method public virtual (paste-properties)
    )
  
  
  (method public virtual (delete-selection)
    )
  
  
  (method public virtual (rename-selection)
    )
  
  
  (method public virtual (select-all . rest)
    )


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method public (acquire-capture)
    (set-captured-view self)
    (acquire-capture~ (get-player)))
  
  
  (method public (release-capture)
    (set-captured-view #f)
    (release-capture~ (get-player)))


  ;;;
  ;;;; Tooltips
  ;;;


  (method public virtual (get-tooltip?)
    tooltip?)


  (method public (set-tooltip? flag)
    (when (neq? flag tooltip?)
      (set! tooltip? flag)))


  (method public virtual (get-tooltip-text)
    (let ((text (localize tooltip-text)))
      (if (not text)
          #f
        (let ((shortcut (and (is? action-handler Action) (get-shortcut~ (require-action-item action-handler)))))
          (if (not shortcut)
              text
            (format "{a} ({a})" text (present-shortcut~ shortcut)))))))


  (method public (set-tooltip-text text)
    (set! tooltip-text text))
  
  
  ;; a quicky... this should probably by default return the value of a property
  (method public virtual (get-formatted-tooltip?)
    #f)
  
  
  (method public virtual (get-tooltip-bounds pos)
    #f)
  
  
  (method public virtual (get-tooltip-context pos)
    (let ((text (get-tooltip-text))
          (bounds (get-tooltip-bounds pos)))
      (when text
        (new Tooltip-Context view: self text: text bounds: bounds))))

  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method override (get-parent/child-clipper child h v)
    (if (not scaled?)
        (nextmethod child h v)
      (let ((p (get-translated-clipper (- (* h scaling) (get-h~ (get-position~ child))) (- (* v scaling) (get-v~ (get-position~ child)))))
            (c (offset-rect (get-bounds~ child) (fxround h) (fxround v))))
        (set-left~ p (fxround/ (get-left~ p) scaling))
        (set-top~ p (fxround/ (get-top~ p) scaling))
        (set-right~ p (fxround/ (get-right~ p) scaling))
        (set-bottom~ p (fxround/ (get-bottom~ p) scaling))
        (rect-intersection p c))))
  
  
  ;;;
  ;;;; Surface
  ;;;


  (method public (get-view-surface)
    (let ((surface (new Surface (get-window-surface (get-player))))
          (lie (get-lie)))
      (set-transform~ surface (get-h~ lie) (get-v~ lie) (get-width) (get-height) (get-scaling) (get-scaled?))
      surface))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-view)
    (let ((bounds (get-bounds)))
      (invalidate-rect bounds)))
  
  
  (method public (invalidate-rect rect)
    (when (view-visible?)
      (let ((acquired (acquire~ (get-root) self (rect-intersection rect (get-view-clipper)))))
        (invalidate-rect~ player acquired))))
  
  
  ;; todo: not using acquire is a potentiel scaling bug...
  (method public (invalidate-region region)
    (when (view-visible?)
      (let ((root (cast <View> (get-root))))
        (let ((delta (- (get-lie) (get-lie~ root))))
          (offset!~ region (get-h~ delta) (get-v~ delta))
          (with ((clipper (new Region (acquire~ root self (get-view-clipper)))))
            (combine!~ region clipper 'and))
          (invalidate-region~ player region)))))
  
  
  (method public (redraw-view (rect: rect #f) (region: region #f))
    (let ((player (get-player)))
      (when player
        (let ((root (get-root)))
          (cond (rect
                  (let ((acquired (acquire~ root self (rect-intersection rect (get-view-clipper)))))
                    (redraw-window~ player rect: acquired)))
                ;; todo: not using acquire is a potentiel scaling bug...
                (region
                  (let ((delta (- (get-lie) (get-lie~ root))))
                    (offset!~ region (get-h~ delta) (get-v~ delta))
                    (with ((clipper (new Region (acquire~ root self (get-view-clipper)))))
                      (combine!~ region clipper 'and))
                    (redraw-window~ player region: region)))
                (else
                 (let ((acquired (acquire~ root self (rect-intersection (get-bounds) (get-view-clipper)))))
                   (redraw-window~ player rect: acquired))))))))
  

  ;; Mainly used by the scrollbar to only redraw itself when scrolling
  (method public (redraw-view-only)
    (let ((player (get-player)))
      (when player
        (let ((hwnd (get-handle~ player)))
          (platform-redraw-view-only self hwnd)))))
  
  
  (method public (update-view (effect: effect #f))
    (let ((player (get-player)))
      (when player
        (set-effect effect)
        (update-window~ player))))
  
  
  (method public (view-invalidater)
    (when player
      (let ((rect (acquire~ (get-root) self (get-bounds)))
            (player player))
        (lambda ()
          (when player
            (invalidate-rect~ player rect))))))

  
  ;;;
  ;;;; Border
  ;;;


  (method public (invalidate-border (insets: insets {Rect 1 1 1 1}))
    (when (get-finished?)
      (with ((region (border-region insets: insets)))
        (invalidate-region region))))


  (method public (redraw-border (insets: insets {Rect 1 1 1 1}))
    (with ((region (border-region insets: insets)))
      (redraw-view region: region)))


  (method public (border-region (insets: insets {Rect 1 1 1 1}))
    (let ((bounds (get-bounds)))
      (frame-region bounds insets: insets)))


  ;;;
  ;;;; Save
  ;;;

  
  (method package (on-save evt)
    (if (not surrogate)
        (save)
      (save~ surrogate)))
  
  
  (method package (on-save-as evt)
    (save-as))
  
  
  (method package (on-revert-saved evt)
    (revert-saved))
        
  
  (method package (on-compare-saved evt)
    (compare-saved))


  (method public virtual (save)
    )


  (method public virtual (save-as)
    )
  
  
  (method public virtual (save-to moniker)
    )

  
  (method public virtual (revert-saved)
    )

  
  (method public virtual (compare-saved)
    )
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor)
    (new View-Descriptor)))


;;;
;;;; Design
;;;


(submodule design


(import (jazz.designer))


(class View-Descriptor extends Figure-Descriptor
  
  
  (form
    (<install>                 image: {Image-Resource "View"}
      (<properties~>
        (<Property-Descriptor> name: title title: "Title"
          (<Localized-Domain>  name: domain))
        (<Property-Descriptor> name: font title: "Font"
          (<Font-Domain>       name: domain))
        (<Property-Descriptor> name: style title: "Style"
          (<Style-Domain>      name: domain))
        (<Property-Descriptor> name: background title: "Background"
          (<Color-Domain>      name: domain))
        (<Property-Descriptor> name: auto-size? title: "Auto Size"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: tooltip? title: "Tooltip"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: tooltip-text title: "Tooltip Text"
          (<String-Domain>     name: domain nullable?: #t))
        (<Property-Descriptor> name: draggable? title: "Draggable"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: drag-tolerance title: "Drag Tolerance")
        (<Property-Descriptor> name: enabled? title: "Enabled"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: action title: "Action")
        (<Property-Descriptor> name: outline-view title: "Outline View")
        (<Property-Descriptor> name: offscreen? title: "Offscreen"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: layer title: "Layer")
        (<Property-Descriptor> name: effect title: "Effect")
        (<Property-Descriptor> name: user-data title: "User Data")
        (<Property-Descriptor> name: disabled-navigate? title: "Disabled Navigate"
          (<Boolean-Domain>    name: domain))
        (<Property-Descriptor> name: focus-gained-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: focus-lose-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: cursor-update-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-enter-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-hover-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-leave-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-down-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-move-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: mouse-up-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: drag-move-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: drag-up-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: double-click-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: current-drop-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: receive-drop-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: receive-files-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: context-menu-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: key-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: arrow-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: escape-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: backspace-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: return-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: tab-press-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: content-change-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: selection-handler category: handler
          (<Handler-Domain>    name: domain))
        (<Property-Descriptor> name: action-handler category: handler
          (<Handler-Domain>    name: domain)))))
  
  
  (method override (component-surrogate-class component)
    View-Surrogate))))
