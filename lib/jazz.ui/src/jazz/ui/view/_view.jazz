;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; View Definitions
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module jazz.ui.view jazz


(import (jazz.debuggee)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.ui.workspace))


;;;
;;;; Mouse
;;;


(definition package mouse-in          {})
(definition package mouse-down?       #f)
(definition package mouse-right-down? #f)
(definition package mouse-down-view   {})
(definition package mouse-down-point  {})


;; Support for mouse down actions that have to occur at mouse up time
;; See Application.activate for an example usage
(definition delayed-mouse-action
  {})


(definition public (get-delayed-mouse-action)
  delayed-mouse-action)

(definition public (set-delayed-mouse-action action)
  (set! delayed-mouse-action action))


(definition public (get-mouse-in)
  mouse-in)

(definition public (set-mouse-in view)
  (set! mouse-in view))


(definition public (get-mouse-down?)
  mouse-down?)

(definition public (set-mouse-down? flag)
  (set! mouse-down? flag))


(definition public (get-mouse-right-down?)
  mouse-right-down?)

(definition public (set-mouse-right-down? flag)
  (set! mouse-right-down? flag))


(definition public (get-mouse-down-view)
  mouse-down-view)

(definition public (set-mouse-down-view view)
  (set! mouse-down-view view))


(definition public (get-mouse-down-point)
  mouse-down-point)

(definition public (set-mouse-down-point point)
  (set! mouse-down-point point))


(definition public (mouse-view)
  (either Captured-View mouse-in))


;; This covers the special case where a mouse-down event triggers
;; a modal dialog. In this case, Windows will not generate the
;; mouse-up event, hence this bizarre code...
(definition public (toplevel-deactivate)
  (set! mouse-down? #f)
  (set! mouse-down-view {})
  (set! mouse-down-point {}))


;;;
;;;; Cursor
;;;


(definition public (with-cursor cursor proc (duration: duration {}))
  (unwind-protect
      (begin
        (set-cursor cursor)
        (when duration
          (sleep duration))
        (proc))
    (update-cursor)))


(definition public (update-cursor)
  (when (and mouse-in (in-player?~ mouse-in))
    (call-cursor-update~ mouse-in (mouse-position~ mouse-in))))


;;;
;;;; Dnd
;;;


(definition Current-Drag-Drop
  {})


(definition public (current-drag-drop)
  Current-Drag-Drop)

(definition public (set-current-drag-drop drag-drop)
  (set! Current-Drag-Drop drag-drop))


;;;
;;;; Capture
;;;


(definition Captured-View
  {})


(definition public (get-captured-view)
  Captured-View)

(definition public (set-captured-view view)
  (set! Captured-View view))


(definition package (release-captured-view)
  (when Captured-View
    (set! Captured-View {})
    (unset-capture)))


;;;
;;;; External
;;;


;; first draft
(definition public (external-name guest-class)
  (category-name guest-class))


;;;
;;;; Host
;;;


(definition public (get-focused-host)
  (let ((focus (get-focus)))
    (when focus
      (get-host~ focus))))


(definition public (focused-host? host)
  (eq? host (get-focused-host)))


;;;
;;;; Guest
;;;


(definition (new-guest guest-class rest)
  (apply new guest-class rest))


;;;
;;;; Dialog
;;;


(definition public (get-modal guest-class . rest)
  (receive (process? dialog/result) (apply new-dialog guest-class host-visible?: #f rest)
    (if (not process?)
        dialog/result
      (process-modal~ dialog/result))))


(definition public (new-dialog guest-class . rest)
  (bind-keywords ((host-title {}) (host-sizable? #f) (host-closable? #t) (host-visible? #t) (guest {}) (initialize {}) . others) rest
    (let* ((player (new (dialog-class~ guest-class) sizable?: host-sizable? closable?: host-closable? visible?: #f))
           (host (get-root~ player))
           (guest (either guest (new-guest guest-class others)))
           (size (either (host-size~ guest-class) (get-size~ guest)))
           (pos (either (host-position~ guest-class) (center-dialog size))))
      (set-title~ player (either host-title (host-title~ guest-class) "Dialog"))
      (set-size~ player size)
      (set-position~ player pos)
      (set-guest~ host guest)
      ;; Should initialisations done here generate errors, at least
      ;; parent install is still not done at this point.
      (when initialize
        (initialize host guest))
      (if (has-dialog-result?~ guest)
          (values #f (get-modal-result~ player))
        (when host-visible?
          (set-visible?~ player #t))
        (select-foreground-window (get-handle~ player))
        (focus-host~ host)
        (values #t host)))))


(definition public (center-dialog inner)
  (let* ((outer (get-size~ (get-desktop)))
         (pos (center inner outer)))
    (new Point (get-h~ pos) (- (get-v~ pos) 50))))


;;;
;;;; Palette
;;;


(definition package Palettes
  (make-table test: eq?))


(definition public (singleton-palette guest-class name . rest)
  (let ((ref (either name (category-identifier guest-class))))
    (either (table-ref Palettes ref {})
            (let ((palette
                    ;; quick solution until we decide on the right approach
                    (if (procedure? guest-class)
                        (guest-class)
                      (apply new-palette guest-class host-visible?: #f rest))))
              (table-set! Palettes ref palette)
              palette))))


(definition public (new-palette guest-class . rest)
  (bind-keywords ((host-title {}) (host-position (host-position~ guest-class)) (host-size (host-size~ guest-class)) (host-visible? #t) (guest {}) (initialize {}) . others) rest
    (let* ((player (new (palette-class~ guest-class) visible?: #f))
           (host (get-root~ player)))
      (set-title~ player (either host-title (host-title~ guest-class) "Palette"))
      (when host-position
        (set-position~ player host-position))
      (when host-size
        (set-size~ player host-size))
      ;; It is important to set the palette's size before installing the guest
      ;; in order to minimize layouting by having the size right the first time!
      (let ((guest (either guest (new-guest guest-class others))))
        (set-guest~ host guest)
        ;; Should initialisations done here generate errors, at least
        ;; parent install is still not done at this point
        (when initialize
          (initialize host guest))
        (layout-view~ host)
        (when host-visible?
          (fade-in~ player)
          (focus-host~ host))
        host))))


(definition public (show-palette guest-class . rest)
  (let* ((host (apply singleton-palette guest-class (external-name~ guest-class) rest))
         (guest (get-guest~ host))
         (palette (get-player~ host))
         (initialize (getf rest initialize:)))
    (when initialize
      (initialize palette guest))
    (client-activate~ guest)
    (let ((visible? (get-visible?~ palette)))
      (bring-to-front~ palette)
      (unless visible?
        (fade-in~ palette))
      (focus-host~ host))
    palette))


(definition public (collect-palettes)
  (collect-if (lambda (window)
                (is? window Palette))
              (get-windows~ (palette-parent))))


(definition package (reset-palettes)
  (set! Palettes (make-table test: eq?)))


;;;
;;;; Docked
;;;


(definition package Dockeds
  (make-table test: eq?))


(definition public (singleton-docked guest-class name . rest)
  (let ((ref (either name (external-name guest-class))))
    (either (table-ref Dockeds ref {})
            (let ((palette (new-docked guest-class name: name)))
              (table-set! Dockeds ref palette)
              palette))))


(definition public (new-docked guest-class . rest)
  (bind-keywords ((host-title {}) (host-location {}) . others) rest
    (let ((host (new Docked-Host visible?: #f)))
      (set-title~ host (either host-title (host-title~ guest-class) "Docked"))
      (when host-location
        (set-location~ host host-location))
      (set-guest~ host (new-guest guest-class others))
      host)))


(definition package (reset-dockeds)
  (set! Dockeds (make-table test: eq?)))


;;;
;;;; Stage
;;;


(definition package *stages*
  '())

(definition package *current-stage*
  {})


(definition public (get-stages)
  *stages*)

(definition public (get-active-stages)
  (collect-if in-player?~ *stages*))


(definition public (current-stage)
  *current-stage*)

(definition public (set-current-stage stage)
  (let ((previous *current-stage*))
    (set! *current-stage* stage)
    (when stage
      (set! *stages* (cons stage (remove! stage *stages*))))
    (when previous
      (invalidate-border~ (get-border~ previous)))
    (when stage
      (invalidate-border~ (get-border~ stage))
      (stage-activate~ stage))
    (activate-current-frame)
    (update-menubar-buttons~ (get-application))))

(definition public (reset-current-stage)
  (set-current-stage {}))


(definition public (create-stage)
  (let ((stage (new-stage~ (get-application))))
    (set! *stages* (cons stage *stages*))
    stage))


(definition public (current-stage-border)
  (let ((stage (current-stage)))
    (when stage
      (get-parent~ stage))))


(definition public (all-frames (include-invisibles?: include-invisibles? #f))
  (append (all-internal-frames include-invisibles?: include-invisibles?)
          (all-external-frames include-invisibles?: include-invisibles?)))


(definition public (all-internal-frames (include-invisibles?: include-invisibles? #f))
  (collect-if (lambda (frame)
                (and (is? frame Internal-Frame-Host)
                     (or include-invisibles? (get-visible?~ frame))))
              (get-frames)))


(definition public (all-external-frames (include-invisibles?: include-invisibles? #f))
  (collect-if (lambda (frame)
                (and (is? frame External-Frame-Host)
                     (or include-invisibles? (get-visible?~ frame))))
              (get-frames)))


(definition public (first-frame)
  (let ((frames (all-frames)))
    (if (null? frames)
        {}
      (first frames))))


(definition public (second-frame)
  (let ((frames (all-frames)))
    (if (>= (length frames) 2)
        (second frames)
      {})))


(definition public (last-frame)
  (let ((frames (all-frames)))
    (if (null? frames)
        {}
      (last frames))))


(definition public (collect-frames)
  (collect-if (lambda (frame)
                (let ((guest (get-guest~ frame)))
                  (or (is-not? guest Document)
                      (not (get-tool?~ (get-controller~ guest))))))
              (all-frames)))


(definition public (find-frame-host guest-type)
  (find-if (lambda (view)
             (and (is? view Host-View)
                  (is? (get-guest~ view) guest-type)))
           (all-frames include-invisibles?: #t)))


(definition public (find-frame-guest guest-type)
  (let ((host (find-frame-host guest-type)))
    (when host
      (get-guest~ host))))


;;;
;;;; Workspace
;;;


(definition public (delete-stage)
  (let ((designer (get-preferences-designer~ (get-application)))
        (current-stage (current-stage)))
    (let ((stage (get-figure-preferences~ current-stage)))
      (let ((splitter (get-parent~ stage)))
        (if (is-not? splitter Splitter-Preferences)
            (bell)
          (delete-stages designer stage splitter))))))


(definition public (delete-other-stages)
  (define (find-splitter splitter parent)
    (if (stage-splitter? parent)
        (find-splitter parent (get-parent~ parent))
      splitter))
  
  (define (stage-splitter? splitter)
    (and (is? splitter Splitter-Preferences)
         (every? (lambda (pref)
                    (or (is? pref Stage-Preferences)
                        (stage-splitter? pref)))
                  (get-children~ splitter))))
  
  (let ((designer (get-preferences-designer~ (get-application)))
        (current-stage (current-stage)))
    (let ((stage (get-figure-preferences~ current-stage)))
      (let ((splitter (get-parent~ stage)))
        (if (is-not? splitter Splitter-Preferences)
            (bell)
          (delete-stages designer stage (find-splitter splitter (get-parent~ splitter))))))))


(definition (delete-stages designer stage splitter)
  (let ((parent (get-parent~ splitter)))
    (if (not (can-move-component?~ designer stage parent))
        (bell)
      (set-property~ designer stage 'location (get-location~ splitter))
      (move-component~ designer stage parent)
      (remove-child~ designer splitter)
      (select-current-workspace))))


(definition public (split-stage-vertically)
  (split-stage 'vert))


(definition public (split-stage-horizontally)
  (split-stage 'horz))


(definition (split-stage direction)
  (let ((designer (get-preferences-designer~ (get-application)))
        (current-stage (current-stage)))
    (if (not current-stage)
        (bell)
      (let ((stage (get-figure-preferences~ current-stage)))
        (let ((parent (get-parent~ stage))
              (new-splitter (new Splitter-Preferences))
              (new-stage (new Stage-Preferences)))
          (add-child~ designer new-splitter parent)
          (move-component~ designer stage new-splitter)
          (add-child~ designer new-stage new-splitter)
          (set-property~ designer new-splitter 'location (get-location~ stage))
          (set-property~ designer new-splitter 'orientation direction)
          (set-property~ designer new-splitter 'mode 'relative)
          (set-property~ designer new-splitter 'division 50)
          (set-property~ designer stage 'location 'first)
          (set-property~ designer new-stage 'location 'second)
          (set-property~ designer new-stage 'maximized? (get-maximized?~ stage))))
      (select-current-workspace))))


(definition public (navigate-frame)
  (let ((stages (get-active-stages)))
    (let ((count (length stages)))
      (define (navigate stage frame)
        (let ((rank (find stages stage)))
          (let ((next (element stages (modulo (- rank 1) count))))
            (when frame
              (set-parent~ frame next)
              (maximize/restore~ frame)
              (remember-workspace-stage~ frame))
            (set-current-stage next))))
      
      (if (< count 2)
          (bell)
        (let ((frame (current-frame)))
          (if frame
              (navigate (get-stage~ frame) frame)
            (navigate (current-stage) {})))))))


;;;
;;;; Frame Management
;;;


(definition *active-frame*
  {})


(definition package (active-frame)
  *active-frame*)

(definition package (set-active-frame frame)
  (set! *active-frame* frame))


(definition package (activate-current-frame)
  (define (front-frame)
    (let ((stage (current-stage)))
      (when stage
        (first-view~ stage))))
  
  (let ((front (front-frame))
        (active *active-frame*))
    (when (neq? front active)
      (when active
        (deactivate-frame~ active))
      (if front
          (activate-frame~ front)
        (let ((stage (current-stage)))
          (when stage
            (stage-empty-activate~ stage)))))))


;;;
;;;; Frame Region
;;;


(definition public (frame-region frame <Rect> (insets: insets (new Rect 1 1 1 1)))
  (let ((left   (get-left~ frame))
        (top    (get-top~ frame))
        (right  (get-right~ frame))
        (bottom (get-bottom~ frame))
        (region (new Region)))
    (with-closed ((l (new Region left: left                          top: top                             right: (+ left (get-left~ insets)) bottom: bottom))
                  (t (new Region left: left                          top: top                             right: right                       bottom: (+ top (get-top~ insets))))
                  (r (new Region left: (- right (get-right~ insets)) top: top                             right: right                       bottom: bottom))
                  (b (new Region left: left                          top: (- bottom (get-bottom~ insets)) right: right                       bottom: bottom)))
      (combine!~ region l 'or)
      (combine!~ region t 'or)
      (combine!~ region r 'or)
      (combine!~ region b 'or)
      region)))


;;;
;;;; Frame
;;;


(definition public (new-frame guest-class . rest)
  (bind-keywords ((kind {}) . others) rest
    (case (either kind 'internal)
      ((internal) (apply new-internal-frame guest-class others))
      ((external) (apply new-external-frame guest-class others)))))


;;;
;;;; Internal Frame
;;;


(definition public (new-internal-frame guest-class . rest)
  (bind-keywords ((host-title {}) (host-position (host-position~ guest-class)) (host-size (host-size~ guest-class)) (host-workspace {}) (host-visible? #t) (host-focus? #t) (guest {}) (initialize {}) . others) rest
    (let ((guest (either guest (new-guest guest-class others))))
      (let ((host (new Internal-Frame-Host parent: (current-stage) visible?: #f)))
        (set-title~ host (either host-title (host-title~ guest-class) "Frame"))
        (set-position~ host (either host-position (cascade-position host guest)))
        (set-size~ host (either host-size (nu+ (get-size~ guest) {Point 8 28})))
        (when host-workspace
          (set-workspace~ host host-workspace))
        (set-guest~ host guest)
        ;; Should initialisations done here generate errors, at least
        ;; parent install is still not done at this point
        (when initialize
          (initialize host guest))
        (ensure-displayed~ host)
        (when host-visible?
          (bring-to-front~ host)
          (set-visible?~ host #t)
          (when host-focus?
            (focus-host~ host)))
        host))))


;;;
;;;; Cascade
;;;


(definition Cascade-Position
  {Point 25 25})

(definition Cascade-Step
  {Dimension 22 22})


(definition (cascade-position host guest)
  (define (collect-positions stage)
    (let ((maximized? (get-maximized?~ stage)))
      (collect (lambda (frame)
                 (when (and (is? frame Internal-Frame-Host)
                            (eq? (class-of (get-guest~ frame)) (class-of guest)))
                   (if maximized?
                       (get-preserved-position~ frame)
                     (get-position~ frame))))
                 (get-views~ stage))))
  
  (let ((positions (collect-positions (get-stage~ host))))
    (let (iterate (pos Cascade-Position))
      (if (member? pos positions test: nu=?)
          (iterate (nu+ pos Cascade-Step))
        pos))))


;;;
;;;; External Frame
;;;


(definition public (new-external-frame guest-class . rest)
  (bind-keywords ((host-title {}) (host-position (host-position~ guest-class)) (host-size (host-size~ guest-class)) (host-workspace {}) (host-visible? #t) (host-focus? #t) (guest {}) (initialize {}) . others) rest
    (let* ((player (new External-Frame visible?: #f))
           (host (get-root~ player)))
      (set-title~ host (either host-title (host-title~ guest-class) "Frame"))
      (when host-position
        (set-position~ player host-position))
      (when host-size
        (set-size~ player host-size))
      ;; It is important to set the frame's size before installing the guest
      ;; in order to minimize layouting by having the size right the first time!
      (let ((guest (either guest (new-guest guest-class others))))
        (set-guest~ host guest)
        ;; Should initialisations done here generate errors, at least
        ;; parent install is still not done at this point
        (when initialize
          (initialize host guest))
        (layout-view~ host)
        (when host-visible?
          (fade-in~ player)
          (when host-focus?
            (focus-host~ host))
          (activate-frame~ host))
        host))))


;;;
;;;; Toolbar
;;;


(definition package Toolbars
  (make-table test: eq?))


(definition public (get-toolbar name)
  (table-ref Toolbars name {}))


(definition public (singleton-toolbar guest-class name . rest)
  (let ((ref (either name (category-identifier guest-class))))
    (either (table-ref Toolbars ref {})
            (let ((palette (new-toolbar guest-class name: name)))
              (table-set! Toolbars ref palette)
              palette))))


(definition public (new-toolbar guest-class . rest)
  (bind-keywords ((host-title {}) (host-location {}) . others) rest
    (let ((host (new Toolbar-Host visible?: #f)))
      (set-title~ host (either host-title (host-title~ guest-class) "Toolbar"))
      (when host-location
        (set-location~ host host-location))
      (set-guest~ host (new-guest guest-class others))
      host)))


(definition package (reset-toolbars)
  (set! Toolbars (make-table test: eq?)))


;;;
;;;; Scrollbar
;;;


(definition public scrollbar-size
  13)


;;;
;;;; Progress
;;;


(definition (with-progress proc (threaded?: threaded? #t) (name: name {}) (progress-reporter: progress-reporter Progress-Reporter) (cancelable?: cancelable? #t) (abnormal-cleanup: abnormal-cleanup {}))
  (unimplemented 'with-progress)
  @convert-thread
  (if (not threaded?)
      (proc (new User-Reporter))
    (receive (process? dialog) (new-dialog progress-reporter host-closable?: cancelable?)
      (let ((reporter (get-guest~ dialog)))
        (when (not cancelable?)
          (disable-cancel~ reporter))
        (thread-start!
          (new-thread
            (lambda ()
              (let* ((result)
                     (resignal {})
                     (abnormal
                       (lambda (sig)
                         (when abnormal-cleanup
                           (abnormal-cleanup))
                         (set! resignal sig))))
                (unwind-protect
                    ;; Conceptually, the with-progress proc is executed in the same thread as the caller...
                    ;; The fact that we are using a thread for user interface responsiveness should not affect
                    ;; the semantics of proc which is why we resignal forwardable signals through the signal-modal
                    ;; definition which will resignal them to the calling thread
                    (catch (Signal sig
                             (if (forwardable?~ sig)
                                 (abnormal sig)
                               (signal sig)))
                      (set! result (proc reporter)))
                  (if resignal
                      (signal-modal~ dialog resignal)
                    (end-modal~ dialog result)))))
            'worker))
        (process-modal~ dialog)))))


;;;
;;;; Message
;;;


;; Type
;; - message
;; - question
;; - confirmation
;; - problem
;; - error
;; - custom


(definition public (message-box text
                                (class: class {})
                                (type: type 'message)
                                (title: title {})
                                (size: size {})
                                (icon: icon {})
                                (content: content {})
                                (sound: sound 'default)
                                (selection: selection {})
                                (yes: yes {})
                                (no: no {})
                                (cancel: cancel {})
                                (actions: actions '())
                                (default-button: default-button {})
                                (process-keys?: process-keys? #t)
                                (sizable?: sizable? #f))
  (receive (process? dialog) (new-dialog (either class Message-Box) host-visible?: #f host-sizable?: sizable?)
    (let ((guest (get-guest~ dialog)))
      (process-box~ guest text
        type: type
        title: title
        size: size
        icon: icon
        content: content
        sound: sound
        selection: selection
        yes: yes
        no: no
        cancel: cancel
        actions: actions
        default-button: default-button
        process-keys?: process-keys?))))


;;;
;;;; Safety
;;;


(definition public (with-safe-execution context thunk (continue-text: continue-text {}) (continue-handler: continue-handler {}))
  (define (ask-continue err)
    (let ((text (format "The following error occured while {a}:{%}{%}{a}{%}{%}Press Continue {a}, Exit to exit immediately"
                        context
                        (exception-reason err)
                        (either continue-text "to bypass this problem"))))
      (let ((result (message-box text type: 'confirmation yes: "Continue" no: "Debug Now" cancel: "Exit")))
        (case result
          ((yes)
           (post-stop err)
           #t)
          ((no)
           #f)
          ((cancel)
           (exit))))))
  
  (define (warn-exit err)
    (let ((text (format "The following error occured while {a}:{%}{%}{a}"
                        context
                        (exception-reason err))))
      (message-box text yes: "Exit")
      (exit)))
  
  (if (get-controller-debugger)
      (thunk)
    (with-exception-filter
      (lambda (obj)
        (let ((err (wrap-exception obj)))
          (if continue-handler
              (ask-continue err)
            (warn-exit err))))
      (lambda (err)
        (continue-handler err))
      thunk)))


(definition public (with-catched-exception filter thunk)
  (define (ask err)
    (let ((text (exception-reason err)))
      (let ((result (message-box text type: 'question yes: "OK" no: "Debug")))
        (case result
          ((yes)
           #t)
          ((no)
           #f)))))
  
  (with-exception-filter
    (lambda (obj)
      (if (filter obj)
          (let ((err (wrap-exception obj)))
            (ask err))
        #f))
    (lambda (err)
      (throw-cancel))
    thunk))


;;;
;;;; Request
;;;


;; These should really be hooks to modify the dialog at creation time...


(definition public (request-string (class: class String-Request) (title: title {}) (prefix: prefix {}) (initial-value: initial-value {}) (accepts-empty?: accepts-empty? #t) (unicity-domain: unicity-domain {}) (validator: validator {}))
  (receive (process? host) (new-dialog class)
    (let* ((view (get-guest~ host))
           (text (locate~ view 'text)))
      (set-title~ (get-player~ host) (either title "Enter String"))
      (set-accepts-empty?~ view accepts-empty?)
      (set-unicity-domain~ view unicity-domain)
      (set-validator~ view validator)
      (set-prefix~ view (either prefix "String:"))
      (set-string-content~ text (if initial-value (->string initial-value) ""))
      (select-all~ text)
      (acquire-focus~ text)
      (let ((string (process-modal~ host)))
        (if (empty-string? string)
            {}
          string)))))


(definition public (request-name . rest)
  (bind-keywords ((title {}) (prefix {}) . others) rest
    (let* ((title (either title "Enter Name"))
           (prefix (either prefix "Name:"))
           (string (apply request-string title: title prefix: prefix others)))
      (if (not string)
          {}
        (string->symbol string)))))


(definition public (request-text (class: class Text-Request) (title: title {}) (initial-text: initial-text {}))
  (unimplemented 'request-text)
  @Text-Request
  (receive (process? dialog) (new-dialog class)
    (let* ((view (get-guest~ dialog))
           (text (locate~ view 'text)))
      (set-title~ dialog (either title "Enter Text"))
      (set-string-content~ text (either initial-text ""))
      (select-all~ text)
      (acquire-focus~ text)
      (let ((string (process-modal~ dialog)))
        (if (empty-string? string)
            {}
          string)))))


(definition public (request-date (class: class Date-Request) (title: title {}) (prefix: prefix {}) (initial-date: initial-date {}))
  (unimplemented 'request-date)
  @Date-Request
  (receive (process? dialog) (new-dialog class)
    (let* ((view (get-guest~ dialog))
           (text (locate~ view 'text)))
      (set-title~ dialog (either title "Enter Date"))
      (set-prefix~ view (either prefix "Date:"))
      (set-string-content~ text (if initial-date (present~ initial-date) ""))
      (select-all~ text)
      (acquire-focus~ text)
      (let ((string (process-modal~ dialog)))
        (if (empty-string? string)
            {}
          (parse-string~ Date string))))))


;;;
;;;; Various
;;;


(definition public (get-output-log)
  (get-output-log~ (get-application)))


(definition public (get-active-results)
  (get-active-results~ (get-application)))


(definition public (all-windows)
  (let ((toplevel (get-toplevel)))
    (if toplevel
        (cons toplevel (get-windows~ toplevel))
      '())))


(definition public (select-docked class (name: name {}) (workspace: workspace 'home) (focus?: focus? #f))
  (define (select-view view)
    (when view
      (let* ((host (get-host~ view))
             (parent (get-parent~ host)))
        (when (is? parent Pad-View)
          (set-selection~ parent host))
        (ensure-unzoomed (if (is? parent Splitter-View) host parent))
        (when focus?
          (focus-host~ host))
        view)))
  
  (let ((guest (find-docked class)))
    (if guest
        (select-view guest)
      (when workspace
        (apply-preferences~ (get-workspace workspace))
        (select-view (find-docked class))))))


(definition public (find-docked class)
  (continuation-capture
    (lambda (return)
      (for-each-docked
        (lambda (view)
          (when (is? view class)
            (continuation-return return view))))
      {})))


(definition public (for-each-docked proc)
  (for-each (lambda (window)
              (for-each-docked~ window
                proc))
            (all-windows)))


(definition public (for-each-splitter view proc)
  (let ((splitter (get-parent~ view))
        (splitter-class Splitter-View))
    (while (is? splitter splitter-class)
      (proc splitter view)
      (set! view splitter)
      (set! splitter (get-parent~ splitter)))))


(definition public (ensure-unzoomed view)
  (for-each-splitter view
    (lambda (splitter view)
      (when (and (eq? (get-state~ splitter) 'zoom)
                 (neq? (get-effective-target~ splitter) view))
        (unzoom~ splitter)))))


(definition public (current-frame)
  (first-frame))


(definition public (current-document)
  (let ((frame (current-frame)))
    (when (is? frame Frame-Host)
      (get-guest~ frame))))


(definition public (current-guest)
  (let ((host (get-focused-host)))
    (when host
      (get-guest~ host))))


(definition public (focused-host)
  (let ((focus (get-focus)))
    (when focus
      (get-host~ focus))))


(definition public (focused-guest)
  (let ((focus (get-focus)))
    (when focus
      (get-guest~ focus))))


;;;
;;;; Focus
;;;


(definition public (get-focus)
  (let ((player (get-focused-window)))
    (when player
      (get-view-focus~ player))))


(definition public (set-focus new-focus)
  (ensure-focusable~ new-focus)
  (let ((old-focus (get-focus)))
    (when (neq? new-focus old-focus)
      (let ((old-player (get-focused-window))
            (new-player (get-player~ new-focus)))
        (assert new-player)
        (if (eq? old-player new-player)
            (begin
              (unfocus-view~ old-player)
              (focus-view~ new-player new-focus))
          (set-view-focus~ new-player new-focus)
          (bring-to-front~ new-player)
          (set-window-focus new-player))))))


(definition public (set-default-focus)
  (acquire-focus~ (get-root~ (get-toplevel))))


(definition public (get-focus-actions view)
  (let ((surrogate (get-surrogate~ view)))
    (if surrogate
        (focus-actions~ surrogate)
      (focus-actions~ view))))


(definition public (refresh-focus-actions view)
  (when (eq? view (get-focus))
    (set-focus-actions~ (get-application) (get-focus-actions view))))


;;;
;;;; Debug
;;;


(definition public *debug-paint*
  #f)


(definition *debug-colors*
  '({Color name: Dark-Red}
    {Color name: Dark-Orange}
    {Color name: Dark-Yellow}
    {Color name: Dark-Green}
    {Color name: Dark-Blue}
    {Color name: Dark-Purple}))

(definition *nb-debug-colors*
  (length *debug-colors*))

(definition *current-debug-color*
  0)


(definition public (cycle-debug-color!)
  (prog1 (element *debug-colors* *current-debug-color*)
    (set! *current-debug-color* (modulo (+ *current-debug-color* 1) *nb-debug-colors*))))


(definition public (debug-paint? . rest)
  (if (null? rest)
      *debug-paint*
    (set! *debug-paint* (car rest))))


;;;
;;;; Debugger
;;;


(definition package (cleanup-mouse-processing)
  (release-captured-view)
  (complete-drag-and-drop)
  (complete-drag-up #f))


(definition package (complete-drag-and-drop)
  (when Current-Drag-Drop
    (drag-end~ (get-view~ (get-source~ Current-Drag-Drop)))))


(definition package (complete-drag-up dragging?)
  (when mouse-down?
    (let ((pos (mouse-position~ mouse-down-view)))
      (process-drag-up~ mouse-down-view pos dragging?)))))
