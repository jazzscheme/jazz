;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Views
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.view.View jazz


(import (jazz.action)
        (jazz.application)
        (jazz.cairo)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.locale)
        (jazz.menu)
        (jazz.outline)
        (jazz.platform)
        (jazz.print)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.view)
        (jazz.view.dnd)
        (jazz.window)
        (jazz.workspace))


(class View extends Drawing implements Actionable
  
  
  (property title                                initialize #f accessors explicit)
  (property font                                 initialize #f accessors explicit)
  (property style                                initialize #f accessors explicit)
  (property background                           initialize #f accessors explicit)
  (property auto-size?                           initialize #f accessors explicit)
  (property tooltip?                             initialize #f accessors explicit)
  (property tooltip-text                         initialize #f accessors explicit)
  (property draggable?                           initialize #f accessors explicit)
  (property drag-tolerance                       initialize 5  accessors generate)
  (property enabled?                             initialize #t accessors explicit)
  (property navigable?                           initialize #t accessors generate)
  (property outline-view                         initialize #f accessors generate)
  (property offscreen?                 <bool>    initialize #f accessors explicit)
  (property scaling                              initialize #f accessors explicit)
  (property rotation                             initialize #f accessors explicit)
  ;; not implemented yet
  (property layer                                initialize 0  accessors explicit)
  (property effect                               initialize #f accessors explicit)
  (property user-data                            initialize #f accessors generate)

  
  (property focus-gained-handler                 initialize #f accessors generate)
  (property focus-lose-handler                   initialize #f accessors generate)
  (property cursor-update-handler                initialize #f accessors generate)
  (property mouse-enter-handler                  initialize #f accessors generate)
  (property mouse-hover-handler                  initialize #f accessors generate)
  (property mouse-leave-handler                  initialize #f accessors generate)
  (property mouse-down-handler                   initialize #f accessors generate)
  (property mouse-move-handler                   initialize #f accessors generate)
  (property mouse-up-handler                     initialize #f accessors generate)
  (property drag-move-handler                    initialize #f accessors generate)
  (property drag-up-handler                      initialize #f accessors generate)
  (property double-click-handler                 initialize #f accessors generate)
  (property multiple-click-handler               initialize #f accessors generate)
  (property current-drop-handler                 initialize #f accessors generate)
  (property receive-drop-handler                 initialize #f accessors generate)
  (property receive-files-handler                initialize #f accessors generate)
  (property context-menu-handler                 initialize #f accessors generate)
  (property key-press-handler                    initialize #f accessors generate)
  (property arrow-press-handler                  initialize #f accessors generate)
  (property escape-press-handler                 initialize #f accessors generate)
  (property backspace-press-handler              initialize #f accessors generate)
  (property return-press-handler                 initialize #f accessors generate)
  (property tab-press-handler                    initialize #f accessors generate)
  (property content-change-handler               initialize #f accessors generate)
  (property selection-handler                    initialize #f accessors generate)
  (property action-handler                       initialize #f accessors explicit)

  
  (slot player                      <Window+>    initialize #f)
  (slot offscreen                                initialize #f)
  (slot scroller                                 initialize #f)
  (slot renderer                                 initialize #f accessors generate)
  (slot transformation                           initialize #f)
  (slot previous-size               <Dimension+> initialize #f)
  (slot update-locked?              <bool>       initialize #f getter generate)
  (slot scrollee-locked?            <bool>       initialize #f)
  (slot modified?                   <bool>       initialize #f)
  (slot hover-history                            initialize #f)
  (slot hover-pulse                              initialize #f)
  (slot tools-info                               initialize #f)
  (slot device-transformation                    initialize #f getter generate) ; DANGER, DO NOT SHARE!!
  
  
  (method override (shortcut-update action-item));;abstract
  
  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method override (conclude rest)
    (nextmethod rest)
    (layout)
    (layout-scrollee))

  
  (method override (print output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{?{a} ~}{?{s} ~}{a} {a}" name title position size))))
  
  
  ;;;
  ;;;; Destruction
  ;;;
  
  
  (method public virtual (close-with-confirm)
    (close))
  
  
  (method override (destroy-component)
    (detach-mouse-in)
    (detach-view-focus)
    (flush-device-transformation)
    (nextmethod))


  (method override (destroy)
    (nextmethod)
    (let ((parent parent)
          (rect (get-rect)))
      (let ((host (get-host)))
        (when host
          (view-destroyed~ host self)))
      (set-offscreen? #f)
      (set! player #f)
      (when transformation
        (cairo_matrix_t-free transformation)
        (set! transformation #f))
      (when (is? parent View)
        (invalidate-rect~ parent rect))))
  
  
  ;;;
  ;;;; Reset
  ;;;
  
  
  (method protected (detach-mouse-in)
    (let ((mouse-in (get-mouse-in)))
      (when (and mouse-in (has-ascendant?~ mouse-in self))
        (reset-mouse-in)
        (dispatch-mouse-leave~ mouse-in))))
  
  
  (method protected (detach-view-focus)
    (let ((focus (get-focus)))
      (and focus (has-ascendant?~ focus self)
        (let ((window-focus (get-window-focus)))
          ;; quick hack for cocoa pending bug
          (and window-focus
               (and (eq? player window-focus)
                    (reset-focus~ window-focus)
                    focus))))))
  
  
  ;;;
  ;;;; Aliases
  ;;;

  
  (method override (component-alias name)
    (case name
      ((:host) (get-host))
      ((:guest) (get-guest))
      ((:root) (get-root))
      ((:initiator) (popup-initiator))
      (else (nextmethod name))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method override (get-player)
    player)
  
  
  (method override (set-player plr)
    (when (neq? player plr)
      (detach-mouse-in)
      (let ((own-focus (detach-view-focus)))
        (set! player plr)
        (nextmethod plr)
        (when (and player own-focus)
          (acquire-focus~ own-focus)))))
  
  
  (method public (in-player?)
    (boolean player))


  (method public (get-overlapped)
    (let ((player (get-player)))
      (and player
           (get-overlapped~ player))))
  
  
  (method public (different-overlapped? window)
    (or (not window) (neq? (get-overlapped) (get-overlapped~ window))))
  
  
  ;;;
  ;;;; Hosting
  ;;;


  (method public virtual (get-host)
    (find-ascendant Host-View))
  
  
  (method public virtual (get-guest)
    (let ((host (get-host)))
      (and host (get-guest~ host))))
  
  
  (method public virtual (install-in-host host)
    )
  
  
  (method public virtual (uninstall-from-host host)
    )
  
  
  (method public virtual (save-guest designer session)
    )
  
  
  (method public (add-guest-preferences designer session . initargs)
    (unimplemented 'add-guest-preferences)
    @Guest-Preferences
    (let* ((host (get-host))
           (pref (new Guest-Preferences
                   position: (get-position)
                   size:     (get-size)
                   name:     (category-identifier (class-of self))
                   initargs: (cons position: (cons (get-position~ host)
                                                   (cons size: (cons (get-size~ host)
                                                                     initargs)))))))
      (add-child~ designer pref session design-events?: #f select?: #f)))
  
  
  (method public virtual (host-activate)
    )
  
  
  (method public virtual (host-deactivate)
    )
  
  
  (method public virtual (focus-default)
    (acquire-focus))
  
  
  (method public virtual (get-text-view)
    #f)
  
  
  (method public (frame-guest?)
    (let ((host (get-host)))
      (and (is? host Frame-Host)
           (eq? (get-guest~ host) self))))
  
  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta protected virtual (dialog-class)
    Dialog)
  
  
  (method meta protected virtual (frame-class)
    Internal-Frame-Host)
  
  
  (method meta protected virtual (palette-class)
    Palette)
  
  
  (method meta protected virtual (docked-class)
    Docked-Host)
  
  
  (method meta protected virtual (toolbar-class)
    Toolbar-Host)
  
  
  (method meta protected virtual (host-icon)
    {Image-Resource "Window"})
  
  
  (method meta protected virtual (host-title)
    #f)
  
  
  (method meta protected virtual (host-position)
    #f)
  
  
  (method meta protected virtual (host-size)
    #f)
  
  
  (method public virtual (host-minimal-size)
    {Dimension 100 100})
  
  
  (method public virtual (host-workspaces)
    '())
  
  
  (method public (effective-host-workspaces)
    (define (pref-workspace pref)
      (let ((associations (get-associations~ pref)))
        (continuation-capture
          (lambda (return)
            (for-each (lambda (association)
                        (bind (reference . workspace) association
                          (let ((class (resolve-reference~ reference)))
                            (when (is? self class)
                              (continuation-return return workspace)))))
                      associations)
            #f))))
    
    (define (host-workspace)
      (get-workspace~ (get-host)))
    
    (define (filter-inexistant-workspaces pref workspaces)
      ;; also add dynamically generated workspaces page and preview
      (let ((names (cons 'page (cons 'preview (map get-name~ (get-children~ pref))))))
        (collect-if (lambda (name)
                      (and name (memq? name names)))
                    workspaces)))
    
    (let ((pref (get-workspaces-preferences)))
      (filter-inexistant-workspaces pref
        (cons (pref-workspace pref) (cons (host-workspace) (host-workspaces))))))
  
  
  (method public (for-each-view-docked proc)
    (for-each (lambda (child)
                (cond ((or (is? child Splitter-View)
                           (is? child Pad-View))
                       (for-each-view-docked~ child proc))
                      ((is? child Host-View)
                       (proc (get-guest~ child)))))
              children))
  
  
  (method public (find-view-docked type)
    (continuation-capture
      (lambda (return)
        (for-each-view-docked
          (lambda (guest)
            (when (is? guest type)
              (continuation-return return guest))))
        #f)))
  
  
  (method public (find-host guest-type)
    (find-if (lambda (view)
               (and (is? view Host-View)
                    (is? (get-guest~ view) guest-type)))
             children))
  
  
  (method public (find-guest guest-type)
    (let ((host (find-host guest-type)))
      (and host
           (get-guest~ host))))
  
  
  (method public (collect-guest guest-type)
    (collect (lambda (view)
               (and (is? view Host-View)
                    (let ((guest (get-guest~ view)))
                      (and (is? guest guest-type)
                           guest))))
             children))


  (method public (get-frame)
    (find-ascendant Frame-Host))
  
  
  (method public virtual (guest-icon)
    (host-icon~ (class-of self)))
  
  
  (method public virtual (focus-activate)
    )
  
  
  (method public virtual (focus-deactivate)
    )
  
  
  (method public virtual (maximize)
    )
  
  
  (method public virtual (restore)
    )
  
  
  (method public virtual (split-view)
    #f)
  
  
  ;;;
  ;;;; Frame
  ;;;
  
  
  (method meta public virtual (new-event . rest)
    (apply new-frame self rest))
  
  
  ;;;
  ;;;; Tool
  ;;;
  
  
  (method public virtual (tool-preferences)
    #f)
  
  
  ;; All this tool-info stuff remains to be done. The idea is to give
  ;; docked tools a place to persist information like the selection so that
  ;; when switching documents like designs, the selection is preserved...
  ;; Note: the show-invisibles? slot of Design-Book-View is clearly a handcoded
  ;; piece of code that could be redone using tool-infos
  (method (get-tools-info)
    (unless tools-info
      (set! tools-info (make-table test: eq?)))
    tools-info)
  
  
  (method public virtual (get-tool-info tool-name)
    (table-ref (get-tools-info) tool-name #f))
  
  
  (method public virtual (set-tool-info tool-name info)
    (table-set! (get-tools-info) tool-name info))
  
  
  ;;;
  ;;;; Palette
  ;;;
  
  
  (method public virtual (host-install)
    )
  
  
  (method public virtual (host-uninstall)
    )
  
  
  (method public virtual (client-activate)
    )
  
  
  (method public virtual (client-deactivate)
    )
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method public virtual (get-tools-view)
    #f)
  
  
  (method public virtual (workspace-minimisable?)
    #t)
    
  
  ;;;
  ;;;; Dialog
  ;;;
  
  
  (method public virtual (validate-dialog)
    )
  
  
  (method public virtual (get-modal-result)
    #f)
  
  
  (method public virtual (has-dialog-result?)
    #f)
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method public virtual (get-component-editor)
    #f)
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public virtual (content-valid?)
    #t)
  
  
  (method public virtual (validate-content)
    )
  
  
  ;;;
  ;;;; Parent
  ;;;
  
  
  (method override (setup-parent)
    (nextmethod)
    (set-player (if parent (get-player~ parent) #f)))
  
  
  (method override (set-parent parent)
    (assert (primordial-thread?))
    (let ((invalidater (view-invalidater)))
      (nextmethod parent)
      (set-player (and parent (get-player~ parent)))
      (when invalidater
        (invalidater))
      (when parent
        (invalidate-view))))
  
  
  ;;;
  ;;;; Title
  ;;;
  
  
  (method public virtual (get-title)
    title)
  
  
  (method public virtual (set-title value)
    (set! title value)
    (adjust-title))
  
  
  (method protected virtual (adjust-title)
    (adjust-size))
  
  
  ;;;
  ;;;; Visibility
  ;;;
    
  
  (method override (initially-visible?)
    #f)


  (method override (show)
    (nextmethod)
    (call-layout)
    (invalidate-view))


  (method override (hide)
    (let ((invalidater (view-invalidater)))
      (nextmethod)
      (when invalidater
        (invalidater))))
  
  
  (method protected virtual (update-displayed)
    )
  
  
  ;;;
  ;;;; Enabled
  ;;;
  

  (method public virtual (get-enabled?)
    enabled?)


  (method public virtual (set-enabled? flag)
    (set! enabled? flag)
    (invalidate-view))
  
  
  (method public (view-enabled?)
    (and (get-enabled?)
         (or (is-not? parent View)
             (view-enabled?~ parent))))
  
  
  ;;;
  ;;;; Transformation
  ;;;
  

  (method public (get-scaling)
    scaling)
  
  
  (method public (effective-scaling)
    (or scaling 1.))


  (method public (set-scaling value)
    (set! scaling value)
    (update-transformation))
  
  
  (method public (scale-view factor)
    (set-scaling (and factor (* (effective-scaling) factor))))
  

  (method public (get-rotation)
    rotation)
  
  
  (method public (effective-rotation)
    (or rotation 0.))


  (method public (set-rotation value)
    (set! rotation value)
    (update-transformation))
  
  
  (method override (get-transformation)
    transformation)
  
  
  (method (update-transformation)
    (set! transformation (and (or scaling rotation)
                              (let ((matrix (cairo_matrix_t-make)))
                                (cairo_matrix_init_identity matrix)
                                (when rotation
                                  (cairo_matrix_rotate matrix (degree->radian rotation)))
                                (when scaling
                                  (cairo_matrix_scale matrix scaling scaling))
                                matrix)))
    (update-displayed)
    (update-scrollbars)
    ;; Depending on whether it's the view's point of vue or it's parent
    ;; we either have to invalidate the view or its parent...
    (if parent
        (invalidate-view~ parent)
      (invalidate-view)))

  
  ;;;
  ;;;; Actionable
  ;;;
  
  
  (method override (enabled-update action-item)
    (set-enabled? (get-enabled?~ action-item)))
  
  
  (method public virtual (actionable-reachable?)
    (view-visible?))

  
  ;;;
  ;;;; Outline View
  ;;;


  (method public (outline-select)
    (let* ((row (outline-row))
           (column (outline-column))
           (line (row->line~ outline-view row))
           (col (column->col~ outline-view column))
           (elem (if (and (is? outline-view Tree-View) (eq? (get-selection-mode~ outline-view) 'cell)) (new Cell line col) line)))
      (acquire-focus)
      (set-selection~ outline-view (list elem))))
  
  
  (method public (outline-row)
    (find-ascendant Outline-Row))
  
  
  (method public (outline-column)
    (get-column~ outline-view (find (get-children~ parent) self)))


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen?)
    offscreen?)
  
  
  (method override (set-offscreen? flag <bool>)
    (when (neq? flag offscreen?)
      (set! offscreen? flag)
      (when (not offscreen?)
        (close-offscreen))))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method override (get-layer)
    layer)
  
  
  (method override (set-layer value)
    (set! layer value))


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method override (get-effect)
    effect)
  
  
  (method override (set-effect value)
    (set! effect value))
  
  
  ;;;
  ;;;; Position
  ;;;
  

  (method override (set-position pos <Point>)
    (when (/= pos position)
      ;; todo: it is possible to invalidate more precisely
      (let ((inval? (and player (is? parent View) (not (inhibit-invalidates?)))))
        (let* ((bounds (and inval? (get-bounds)))
               (old (and inval? (acquire~ parent self bounds))))
          (set! position pos)
          (when player
            (let ((new (get-bounds)))
              (when old
                (invalidate-rect~ parent old))
              (invalidate-rect new)))))
      (position-change position)))
  

  (method package (set-position-noupdate pos <Point>)
    (when (/= pos position)
      (set! position pos)
      (position-change position)))

  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method override (default-size) <Dimension>
    {Dimension 100 100})
  
  
  (method public virtual (minimal-size)
    #f)
  
  
  (method public virtual (preferred-size) <Dimension>
    (get-size))
  
  (method public virtual (preferred-width) <fx>
    (get-width~ (preferred-size)))
  
  (method public virtual (preferred-height) <fx>
    (get-height~ (preferred-size)))
  
  
  (method public virtual (fit-size)
    )
  
  
  (method (invalidated-size sz)
    (and player (is? parent View) (not (inhibit-invalidates?))
      (let ((old (get-bounds))
            (new (size-rect sz)))
        (acquire~ parent self (rect-union old new)))))
  

  (method override (set-size sz <Dimension>)
    @validate-size
    (assert (and (>= (get-width~ sz) 0)
                 (>= (get-height~ sz) 0)))
    (when (/= sz size)
      (let ((invalidated-size (invalidated-size sz)))
        (set! size sz)
        (size-change size)
        (unless scroller
          (content-size-change size))
        (when parent
          (adjust-fit~ parent))
        (when invalidated-size
          (invalidate-rect~ parent invalidated-size)))))
  
  
  (method override (set-size-noevent sz <Dimension>)
    (when (/= sz size)
      (let ((invalidated-size (invalidated-size sz)))
        (set! size sz)
        (when invalidated-size
          (invalidate-rect~ parent invalidated-size)))))
  
  
  (method public (set-preferred-size)
    (set-size (preferred-size)))
  
  (method public (set-preferred-width)
    (set-width (preferred-width)))
  
  (method public (set-preferred-height)
    (set-height (preferred-height)))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method public (layout-view)
    (layout-drawing))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method public (front-view)
    (last children))
  
  
  (method public (back-view)
    (first children))
  
  
  (method override (send-before target)
    (nextmethod target)
    (invalidate-view))
  
  
  (method override (bring-to-front)
    (unless (front?)
      (nextmethod)
      (invalidate-view)))


  (method override (send-to-back)
    (unless (back?)
      (nextmethod)
      (invalidate-view)))
  
  
  (method override (front-child? child)
    (eq? child (last children)))
  
  
  (method override (back-child? child)
    (eq? child (first children)))


  (method override (send-child-to-front child)
    (set! children (move-to-tail! child children)))


  (method override (send-child-to-back child)
    (set! children (move-to-head! child children)))

  
  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method public virtual (scrollee-size) <Dimension>
    (new Dimension (scrollee-width) (scrollee-height)))
  
  
  (method protected virtual (scrollee-width)
    (get-width))
  
  
  (method protected virtual (scrollee-height)
    (get-height))
  
  
  ;; not sure yet if we should always resize a scrollee not in a scroller
  ;; so for now we override those methods to implement dynamic scrollees
  (method protected virtual (dynamic-scrollee?)
    #f)
  
  
  (method protected virtual (dynamic-set-scrollee-size)
    (set-size (scrollee-size)))

  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method public (with-update-locked proc)
    (if update-locked?
        (proc)
      (unwind-protect
          (begin
            (set! update-locked? #t)
            (proc))
        (set! update-locked? #f)
        (invalidate-update))))
  
  
  (method protected virtual (invalidate-update)
    (invalidate-view)
    (update-scrollbars))

  
  ;;;
  ;;;; Rendering
  ;;;
  

  (method override (render surface draw-self? nodes context)
    (if renderer
        (render~ renderer self surface draw-self? nodes context)
      (nextmethod surface draw-self? nodes context)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method override (draw-background surface context)
    (let ((background (get-drawing-background context)))
      (when background
        (let ((bounds (get-bounds)))
          (fill-rect~ surface bounds background)))))
  
  
  (method public virtual (get-drawing-background context)
    background)
  
  
  (method override (draw-content surface context)
    (set-font~ surface (effective-font))
    (draw surface context))
  
  
  ;;;
  ;;;; Skin
  ;;;
  
  
  (method public virtual (get-skin)
    )


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method override (get-offscreen surface <Surface+>)
    (let ((width (get-width~ size))
          (height (get-height~ size)))
      (if (and offscreen
               (let ((size (get-size~ offscreen)))
                 (and (<= width (get-width~ size))
                      (<= height (get-height~ size)))))
          (begin
            (renew-context~ offscreen)
            offscreen)
        (close-offscreen)
        (set! offscreen (new-offscreen surface width height))
        offscreen)))
  
  
  (definition (new-offscreen surface <Surface+> width <fx> height <fx>)
    (new Memory-Surface surface (new Dimension width height)))
  
  
  (method package (close-offscreen)
    (when offscreen
      (close~ offscreen)
      (set! offscreen #f)))

  
  ;;;
  ;;;; Opaqueness
  ;;;

  
  (method override (get-opaque?)
    (boolean (and background (>= (get-alpha~ background) 1.))))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (method public virtual (custom-page-setup?)
    #f)
  
  
  (method public virtual (get-page-setup)
    (default-page-setup~ (get-application)))
  
  
  (method public virtual (get-page-setup-designer)
    (default-page-setup-designer~ (get-application)))
  
  
  (method public virtual (get-page-setup-parcel designer)
    (default-page-setup-parcel~ (get-application) designer))
  
  
  (method public virtual (apply-page-setup designer form page-setup)
    (default-apply-page-setup~ (get-application) designer form page-setup))

  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method public virtual (print-document)
    (platform-print-document self))

  
  (method public virtual (print-layout (from-preview?: from-preview? #f))
    (with-locked-update
      (lambda ()
        (let* ((client (current-document))
               (current (selected-workspace))
               (ws (new Page-Workspace name: 'page previous: current)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-docked~ toplevel Page-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-preview) (not from-preview?))
            (layout-view~ toolbar)
            (invalidate-window~ toplevel))
          (let* ((frame (new-frame Page-Editor host-title: "Print Layout" client: client))
                 (pane (get-guest~ frame)))
            (acquire-focus~ pane))))))

  
  (method public virtual (print-layout-debug (from-preview?: from-preview? #f))
    (let ((client (current-document)))
      (let ((frame (new-frame Page-Editor host-title: "Print Layout" client: client)))
        (let ((pane (get-guest~ frame)))
          (acquire-focus~ pane)))))
  

  (method public virtual (print-preview (from-layout?: from-layout? #f))
    (with-locked-update
      (lambda ()
        (let* ((frame (new-frame Preview-Pane host-title: "Print Preview" client: self))
               (pane (get-guest~ frame))
               (current (selected-workspace))
               (ws (new Preview-Workspace name: 'preview previous: current pane: pane)))
          (apply-preferences~ ws)
          (let* ((toplevel (get-toplevel))
                 (toolbar (find-docked~ toplevel Preview-Toolbar)))
            (set-visible?~ (locate~ toolbar 'print-layout) (not from-layout?))
            (layout-view~ toolbar)
            (invalidate-window~ toplevel))
          (set-visible?~ frame #t)
          (acquire-focus~ pane)))))
  

  (method public virtual (print-preview-debug (from-layout?: from-layout? #f))
    (setup-page-setup~ (get-application))
    (let ((frame (new-frame Preview-Pane host-title: "Print Preview" client: self)))
      (let ((pane (get-guest~ frame)))
        (acquire-focus~ pane))))
  
  
  (method public virtual (get-page-area context)
    #f)
  
  
  (method public virtual (get-print-area context)
    (position/size->rect {Point 0 0} (scrollee-size)))
  
  
  (method public virtual (paginate page-width page-height)
    (let* ((area (get-print-area #f))
           (width (rect-width area))
           (height (rect-height area))
           (cols (fxceiling/ width page-width))
           (rows (fxceiling/ height page-height))
           (pages (new List-Factory)))
      (for-each (lambda (row)
                  (for-each (lambda (col)
                              (let* ((h (+ (get-left~ area) (* col page-width)))
                                     (v (+ (get-top~ area) (* row page-height)))
                                     (page (new Rect h v (+ h page-width) (+ v page-height))))
                                (put~ pages page)))
                            (naturals 0 cols)))
                (naturals 0 rows))
      (get-output~ pages)))
  
  
  (method protected (with-printing proc)
    (let ((preserved #f))
      (unwind-protect
          (begin
            (set! preserved (setup-printing))
            (proc))
        (when preserved
          (restore-printing preserved)))))
  
  
  (method protected virtual (setup-printing)
    (let ((pos position))
      (set! position (new Point 0 0))
      (update-displayed)
      (list position: pos)))
  
  
  (method protected virtual (restore-printing preserved)
    (set! position (getf preserved position:))
    (update-displayed))
  
  
  ;;;
  ;;;; Export
  ;;;
  
  
  (method public (export-picture (context: context '()) (where: where 'file) (destination: destination #f))
    (with ((surface (new Memory-Surface #f (get-size))))
      (set-clipper~ surface (new Rect 0 0 (get-width) (get-height)))
      (paint-drawing surface context)
      (export-to-png~ surface (or destination (choose-new-file default-extension: "png")))))


  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method public (get-scroller)
    scroller)
  
  
  (method public virtual (set-scroller view)
    (set! scroller view))
  
  
  (method public virtual (set-scroll-pos pos (redraw?: redraw? #f))
    (when scroller
      (set-scroll-pos~ scroller pos redraw?: redraw?)))
    
  
  (method public virtual (set-scroll-info part min max line page)
    (when scroller
      (set-scroll-info~ scroller part min max line page)))
  
  
  (method public (compute-scroll-info)
    (let ((vmin #f)
          (vmax #f)
          (vline #f)
          (vpage #f)
          (vscroll? #f)
          (hmin #f)
          (hmax #f)
          (hline #f)
          (hpage #f)
          (hscroll? #f))
      (define (vupdate)
        (let ((adjust (if hscroll? scrollbar-size 0)))
          (set! vmin  0)
          (set! vmax  (- (get-height) adjust))
          (set! vline (get-line-size 'vert))
          (set! vpage (- (get-page-size 'vert) adjust))
          (set! vscroll? (> vmax vpage))))
      
      (define (hupdate)
        (let ((adjust (if vscroll? scrollbar-size 0)))
          (set! hmin  0)
          (set! hmax  (- (get-width) adjust))
          (set! hline (get-line-size 'horz))
          (set! hpage (- (get-page-size 'horz) adjust))
          (set! hscroll? (> hmax hpage))))
      
      (vupdate)
      (hupdate)
      (vupdate)
      (hupdate)
      (values vmin vmax vline vpage hmin hmax hline hpage)))
  
  
  (method public (update-scrollbars)
    (when (and scroller (not update-locked?))
      (receive (vmin vmax vline vpage hmin hmax hline hpage) (compute-scroll-info)
        (set-vscroll-needed?~ scroller (> vmax vpage))
        (when (get-vscroll?~ scroller)
          (set-scroll-info 'vert vmin vmax vline vpage))
        (set-hscroll-needed?~ scroller (> hmax hpage))
        (when (get-hscroll?~ scroller)
          (set-scroll-info 'horz hmin hmax hline hpage)))))
  
  
  (method public (vscroll-needed?)
    (receive (vmin vmax vline vpage hmin hmax hline hpage) (compute-scroll-info)
      (> vmax vpage)))
  
  
  (method public (hscroll-needed?)
    (receive (vmin vmax vline vpage hmin hmax hline hpage) (compute-scroll-info)
      (> hmax hpage)))
  
  
  (method public (scroll delta <Point> (redraw?: redraw? #f))
    (unless (= delta {Point 0 0})
      (scroll-to (+ (get-scrolled-position) delta) redraw?: redraw?)))
  
  
  (method public (scroll-to dest <Point> (redraw?: redraw? #f))
    (when (get-scroller)
      (let ((pos (get-scrolled-position)))
        (when (/= dest pos)
          (let* ((size (get-size))
                 (display-size (get-display-size))
                 (min-dist {Distance 0 0})
                 (max-dist (dimension->distance (- display-size size)))
                 (new-dist (distance-min (distance-max (point->distance dest) max-dist) min-dist))
                 (new-pos (get-display-position (distance->point new-dist))))
            (when (/= new-pos position)
              (set! position new-pos)
              (let ((delta (- new-dist (point->distance pos))))
                (set-scroll-pos (distance->point (- new-dist)) redraw?: redraw?)
                (update-scrollbars)
                (scroll-invalidate delta)
                (if (or transformation (not (get-scrollable?)))
                    (invalidate-view)
                  (let ((display (get-display)))
                    (let ((rect (get-bounds~ display)))
                      (scroll-view~ display delta rect)))))))))))
  
  
  (method public (scroll2 delta <Point> (redraw?: redraw? #f))
    (unless (= delta {Point 0 0})
      (scroll-to2 (+ (get-scrolled-position) delta) redraw?: redraw?)))
  
  
  (method public (scroll-to2 dest <Point> (redraw?: redraw? #f))
    (when (get-scroller)
      (let ((pos (get-scrolled-position)))
        (when (/= dest pos)
          (let* ((size (get-size))
                 (display-size (get-display-size))
                 (min-dist {Distance 0 0})
                 (max-dist (dimension->distance (- display-size size)))
                 (new-dist (distance-min (distance-max (point->distance dest) max-dist) min-dist))
                 (new-pos (get-display-position (distance->point new-dist))))
            (when (/= new-pos position)
              (set! position new-pos)
              (let ((delta (- new-dist (point->distance pos))))
                (set-scroll-pos (distance->point (- new-dist)) redraw?: redraw?)
                (update-scrollbars)
                (scroll-invalidate delta)
                (if (or transformation (not (get-scrollable?)))
                    (invalidate-view)
                  (let ((display (get-display)))
                    (let ((rect (get-bounds~ display)))
                      (scroll-view2~ display delta rect)))))))))))
  
  
  (method protected virtual (redraw-scrollbars)
    )
  
  
  (method protected virtual (scroll-invalidate delta)
    )
  
  
  (method public (scroll-view delta rect)
    (let ((player (get-player)))
      (when (and player (view-visible?))
        (with-clipped-transformation-surface
          (lambda (surface)
            (let ((delta (device->logical~ surface delta))
                  (acquired (logical->device~ surface rect))
                  (clip-rect (logical->device~ surface (get-clipper~ surface))))
              (scroll-window~ player delta acquired clip-rect)))))))
  
  
  ;; an attempt at a platform-independent scroll-view
  (method public (scroll-view2 delta rect)
    (let ((player (get-player))
          (root (get-root)))
      (when (and player (view-visible?))
        (with-clipped-transformation-surface
          (lambda (surface)
            (let ((delta (device->logical~ surface delta))
                  (acquired (logical->device~ surface rect))
                  (clip-rect (logical->device~ surface (get-clipper~ surface))))
              (scroll-offscreen2~ root delta acquired clip-rect)))))))
  
  
  (method (scroll-offscreen2 delta src-rect clip-rect)
    (with-view-surface
      (lambda (surface)
        (let* ((dh (get-x~ delta))
               (dv (get-y~ delta))
               (src-rect (rect-intersection src-rect clip-rect))
               (dst-rect (offset-rect src-rect dh dv))
               (modified-rect (rect-intersection (rect-union src-rect dst-rect) clip-rect))
               (new-clipper (rect-intersection modified-rect dst-rect))
               (offscreen (get-offscreen #f)))
          (set-source-surface~ surface offscreen dh dv)
          (draw-rectangle~ surface new-clipper)
          (fill~ surface)
          (set-source-surface~ offscreen offscreen dh dv)
          (draw-rectangle~ offscreen new-clipper)
          (fill~ offscreen)
          (let ((ml (get-left~ modified-rect))
                (mt (get-top~ modified-rect))
                (mr (get-right~ modified-rect))
                (mb (get-bottom~ modified-rect)))
            (when (< dh 0)
              (invalidate-rect (new Rect (+ mr dh) mt mr mb)))
            (when (< dv 0)
              (invalidate-rect (new Rect ml (+ mb dv) mr mb)))
            (when (> dh 0)
              (invalidate-rect (new Rect ml mt (+ ml dh) mb)))
            (when (> dv 0)
              (invalidate-rect (new Rect ml mt mr (+ mt dv)))))))))
 
  
  (method public (get-scrolled-distance) <Distance>
    (if scroller
        (nu- (display->view (point->distance position)))
      {Distance 0 0}))
 
  
  (method public (get-scrolled-distance-h) <fx>
    (get-x~ (get-scrolled-distance)))
 
  
  (method public (get-scrolled-distance-v) <fx>
    (get-y~ (get-scrolled-distance)))
 
  
  (method public (get-scrolled-position) <Point>
    (if scroller
        (distance->point (display->view (point->distance position)))
      {Point 0 0}))
 
  
  (method public (get-scrolled-h) <fx>
    (get-h~ (get-scrolled-position)))
 
  
  (method public (get-scrolled-v) <fx>
    (get-v~ (get-scrolled-position)))
  
  
  (method public virtual (get-scroll-client)
    self)
  
  
  (method public virtual (get-line-size orientation) <fx>
    (case orientation
      ((vert) 13)
      ((horz) 8)))
  
  
  (method public virtual (get-page-size orientation) <fx>
    (let ((size (get-display-size)))
      (case orientation
        ((vert) (get-height~ size))
        ((horz) (get-width~ size)))))
  
  
  (method public virtual (get-scrollable?)
    #t)
  
  
  (method public (with-scrollee-locked proc)
    (if scrollee-locked?
        (proc)
      (unwind-protect
          (begin
            (set! scrollee-locked? #t)
            (proc))
        (set! scrollee-locked? #f))))
  
  
  (method public virtual (layout-scrollee)
    (define (scroll-to-fit)
      (let ((bottom (get-bottom))
            (fit (get-display-height)))
        (when (< bottom fit)
          (scroll (new Point 0 (- fit bottom)))))
      (let ((right (get-right))
            (fit (get-display-width)))
        (when (< right fit)
          (scroll (new Point (- fit right) 0)))))
    
    (unless update-locked?
      (unless (inhibit-scrollee-layouts?)
        (let ((dynamic? (dynamic-scrollee?)))
          (when dynamic?
            (dynamic-set-scrollee-size))
          (if (not scroller)
              (layout-scrollee-content)
            (let ((size (scrollee-size)))
              (when size
                (unless dynamic?
                  (set-size size))
                (scroll-to-fit)
                ;; prevents multiple useless layouts that can occur when update scrollbars
                ;; resizes a view that will call layout-scrollee in response (ex: tree header)
                (unless scrollee-locked?
                  ;; it is important to update scrollbars first as this can change
                  ;; the scrollee size and we do not want to layout twice for nothing
                  (with-scrollee-locked
                    (lambda ()
                      (update-scrollbars)))
                  (layout-scrollee-content)))))))))
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method public virtual (layout-scrollee-patch)
    )
  
  
  (method public virtual (layout-scrollee-content)
    )


  (method package virtual (scroll-action action line page thumb-pos orientation)
    )


  ;;;
  ;;;; Display
  ;;;
  
  
  (method public virtual (content-size-change size)
    )

  
  (method public (get-display)
    (if scroller
        parent
      self))
  
  
  (method public (get-display-position pos <Point>) <Point>
    (distance->point (view->display (point->distance pos))))
    
  
  (method public (get-display-size) <Dimension>
    (display->view (get-size~ (get-display))))
    
  
  (method public (get-display-width) <fx>
    (get-width~ (get-display-size)))
    
  
  (method public (get-display-height) <fx>
    (get-height~ (get-display-size)))
  
  
  (method public (view->display shape)
    (acquire~ (get-display) self shape))

  
  (method public (display->view shape)
    (acquire~ self (get-display) shape))
  
  
  (method public (scroll-needed start end context (force-vertical: force-vertical #f) (force-horizontal: force-horizontal #f) (reposition: reposition #f) (center?: center? #f)) <Point>
    (let ((distance (get-scrolled-distance))
          (display-size (get-display-size))
          (needed
            (lambda (start end context pos size force-direction reposition? center?)
              (let* ((start-offset (- pos start))
                     (end-offset (- (+ pos size) end))
                     (big-range? (> (- end start) size))
                     (proc (lambda (use-head?)
                             (let ((context (if context (fxround (cast <fl> (* size context))) 0)))
                               (if use-head? (+ start-offset context) (- end-offset context))))))
                (cond
                  (reposition? (proc (neq? force-direction 'tail)))
                  (center? (if (and (< start-offset 0) (> end-offset 0)) 0 (quotient (+ start-offset end-offset) 2)))
                  ((and (> start-offset 0) (> end-offset 0)) (proc (if (not force-direction) (not big-range?) (eq? force-direction 'head))))
                  ((and (< start-offset 0) (< end-offset 0)) (proc (if (not force-direction) big-range? (eq? force-direction 'head))))
                  (else 0))))))
      (new Point
        (needed (get-h~ start) (get-h~ end) (and context (car context)) (get-x~ distance) (get-width~ display-size) force-horizontal (eq? reposition 'horizontal) #f)
        (needed (get-v~ start) (get-v~ end) (and context (cdr context)) (get-y~ distance) (get-height~ display-size) force-vertical (eq? reposition 'vertical) center?))))
  
  
  (method public (horizontal-scroll-needed target direction) <fx>
    (let* ((start (get-scrolled-distance-h))
           (end (+ start (get-display-width))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))
  
  
  (method public (vertical-scroll-needed target direction) <fx>
    (let* ((start (get-scrolled-distance-v))
           (end (+ start (get-display-height))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))


  ;;;
  ;;;; Font
  ;;;
  
  
  (definition default-font
    'Label)


  (method public (get-font)
    font)
  

  (method public virtual (set-font fnt)
    (set! font fnt)
    (adjust-size))
  
  
  (method public virtual (effective-font)
    (or font (registered-font default-font)))


  ;;;
  ;;;; Style
  ;;;


  (method public (get-style)
    style)


  (method public (set-style value)
    (when (neq? value style)
      (set! style value)
      (style-update)))
  
  
  (method protected virtual (style-update)
    (invalidate-view))

  
  ;;;
  ;;;; Background
  ;;;
  
  
  (method public (get-background)
    background)
  
  
  (method public virtual (set-background color)
    (set! background color)
    (invalidate-view))
  
  
  ;;;
  ;;;; Sizing
  ;;;
  

  (method public (get-auto-size?)
    auto-size?)


  (method public (set-auto-size? value)
    (set! auto-size? value)
    (adjust-size))
  
  
  (method public (adjust-size)
    (when auto-size?
      (case auto-size?
        ((width) (set-preferred-width))
        ((height) (set-preferred-height))
        (else (set-preferred-size))))
    (invalidate-view))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-mouse-view pos)
    (or (get-captured-view)
        (find-drawing pos)))


  ;;;
  ;;;; Children
  ;;;


  (method public (first-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (first views))))


  (method public (second-view)
    (let ((views (get-views)))
      (if (>= (length views) 2)
          (second views)
        #f)))


  (method public (last-view)
    (let ((views (get-views)))
      (if (null? views)
          #f
        (last views))))
    
  
  (method public (get-views (include-invisibles?: include-invisibles? #f))
    (reverse!
      (collect-if (lambda (child)
                    (and (is? child View)
                         (or include-invisibles? (get-visible?~ child))))
                  (get-children))))
  

  (method public (front-view?)
    (eq? self (first-view~ parent)))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method override (focus-actions)
    (cons (find-actions 'view)
          (nextmethod)))
  
  
  (method override (guest-actions)
    (cons (find-actions 'guest)
          (nextmethod)))


  ;;;
  ;;;; Content
  ;;;


  (method (call-content-change origin)
    (if content-change-handler
        (invoke-handler self content-change-handler (make-event Event :change self (list origin: origin)))
      (content-change origin)))
  
  
  (method public virtual (content-change origin)
    )


  ;;;
  ;;;; Selection
  ;;;
  

  (method public (call-selection-handler old selection force? user-origin)
    (when selection-handler
      (invoke-handler self selection-handler (new Selection-Event :selection-change self (modifiers-mask) old selection force?: force? user-origin: user-origin))))
  
  
  ;;;
  ;;;; State
  ;;;
  
  
  (method public virtual (get-view-state)
    )
  
  
  (method public virtual (set-view-state state)
    )


  ;;;
  ;;;; Modified State
  ;;;


  (method public virtual (get-modified?)
    modified?)


  (method public virtual (set-modified? state)
    (when (neq? state modified?)
      (set! modified? state)))

  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method public virtual (position-change position <Point>)
    )
  
  
  (method public virtual (size-change size <Dimension>)
    (let ((pw (and previous-size (get-width~ previous-size)))
          (ph (and previous-size (get-height~ previous-size)))
          (width (get-width~ size))
          (height (get-height~ size)))
      (set! previous-size size)
      (when pw
        (let ((dh (- width pw))
              (dv (- height ph)))
          (when (or (/= dh 0) (/= dv 0))
            (resize dh dv)))))
    (layout-scrollee)
    (unless (adjust?)
      (invalidate-layout)
      (when (get-finished?)
        (call-layout))))


  (method protected virtual (resize dh <fx> dv <fx>)
    )

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (acquire-focus)
    (set-focus self))


  (method public (call-focus-gained)
    (set-focus-actions~ (get-application) (get-focus-actions self))
    (if focus-gained-handler
        (invoke-handler self focus-gained-handler (make-event Event :focus-gained self))
      (focus-gained)))


  (method public (call-focus-lose)
    (set-focus-actions~ (get-application) '())
    (if focus-lose-handler
        (invoke-handler self focus-lose-handler (make-event Event :focus-lose self))
      (focus-lose)))
  
  
  (method public (call-focus-lost)
    (focus-lost))
  
  
  (method public (has-focus?)
    (eq? self (get-focus)))
  
  
  (method public (is-focused?)
    (or (has-focus?)
        (and player (memq? self (get-pushed-focuses~ player)))
        (let ((focus (get-focus)))
          (and focus (eq? (get-outline-view~ focus) self)))))
  
  
  (method public (contains-focus?)
    (define (contains? view)
      (has-ascendant?~ view self))
    
    (let ((focus (get-focus)))
      (or (and focus (contains? focus))
          (and player (some? contains? (get-pushed-focuses~ player))))))
  
  
  (method public virtual (focus-lose)
    )
  
  
  (method public virtual (focus-lost)
    )
  
  
  (method public virtual (focus-master)
    self)
  
  
  (method public virtual (focus-reset)
    #f)
  
  
  (method public virtual (focus-gained)
    )
  
  
  (method public virtual (focus-delegate)
    )
  
  
  (method public virtual (focus-update-actions)
    )


  (method public virtual (get-focus-container)
    (find-ascendant Focus-Container))
  
  
  (method public virtual (focusable?)
    (and (in-player?)
         (get-visible?)
         (let ((container (get-focus-container)))
           (or (not container)
               (container-focusable?~ container)))))
  
  
  (method public virtual (ensure-focusable)
    (let ((container (get-focus-container)))
      (when container
        (ensure-container-focusable~ container))))


  ;;;
  ;;;; Action
  ;;;
  
  
  (method public (get-action-handler)
    action-handler)
  
  
  (method public virtual (set-action-handler value)
    (set! action-handler value)
    (when (is? action-handler Action)
      (let ((action-item (require-action-item action-handler)))
        (when action-item
          (register-actionable~ action-item self)))))


  (method public virtual (process-action sender (properties (action-properties)))
    (notify-action sender properties))
  
  
  (method protected virtual (action-properties)
    #f)
  
  
  (method public (notify-action sender properties)
    (when action-handler
      (notify-handler self action-handler sender properties)))
  
  
  ;;;
  ;;;; Receive Files
  ;;;

  
  (method protected (dispatch-receive-files pos files)
    (let ((view (find-mouse-view pos)))
      (when view
        (let ((view-pos (acquire~ view self pos)))
          (call-receive-files~ view view-pos files)))))

  
  (method public (call-receive-files pos files)
    (if receive-files-handler
        (invoke-handler self receive-files-handler (make-event Event :receive-files self position: pos files: files))
      (receive-files pos files)))
  
  
  (method public virtual (receive-files pos pathnames)
    (let ((appl (get-application)))
      (let ((stage (find-ascendant Stage include-self?: #t)))
        (when stage
          (set-current-stage stage)))
      (receive-files~ appl pos pathnames)))


  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (call-cursor-update event)
    (if cursor-update-handler
        (invoke-handler self cursor-update-handler event)
      (cursor-update event)))
  
  
  (method public virtual (cursor-update evt)
    (unless (current-drag-drop)
      (set-cursor :arrow)))
  
  
  (method public (mouse-pressed?)
    mouse-down?)
  
  
  (method public (mouse-right-pressed?)
    (get-mouse-right-down?))
  
  
  (method public (mouse-in?)
    (eq? self (get-mouse-in)))
  
  
  (method public (mouse-over?)
    (over-view? (mouse-position)))


  (method public (over-view? point)
    (let ((bounds (get-bounds)))
      (in-rect? point bounds)))


  (method public (mouse-position)
    (let ((player (get-player))
          (root (get-root)))
      (acquire root (mouse-position~ player))))


  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method (make-mouse-event count . rest)
    (let ((event (apply make-event Mouse-Event rest)))
      (set-count~ event count)
      event))
    
  
  (method (call-mouse-hover pos)
    (if mouse-hover-handler
        (invoke-handler self mouse-hover-handler (make-event Mouse-Event :mouse-hover self position: pos))
      (mouse-hover pos))
    (when (get-tooltip?)
      (popup-tooltip pos)))
  
  
  (method protected (root-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-mouse-down view (make-mouse-event 1 :mouse-down view position: acquired))))))
  
  
  (method protected (dispatch-mouse-down view event)
    (when (view-enabled?~ view)
      (hook-event event)
      (close-popups~ view event: 'mouse-down)
      (let ((actual-focus (get-focus)))
        (set-mouse-down? #t)
        (set-mouse-down-view view)
        (set-mouse-down-point (get-position-value~ event))
        (unless (and (mouse-copy-down? event) actual-focus (mouse-copy~ view event actual-focus))
          (when (mouse-activate?~ view)
            (let ((host (get-host~ view)))
              (when (and host (mouse-activate?~ host) (not (focused-host? host)))
                (mouse-activate~ host))))
          (call-mouse-down~ view event)
          (call-cursor-update~ view event)))))

  
  (method public (call-mouse-down event)
    (if mouse-down-handler
        (invoke-handler self mouse-down-handler event)
      (mouse-down event)))
  
  
  (method protected (dispatch-mouse-move h v)
    (let ((pos (new Point h v)))
      (let ((view (find-mouse-view pos)))
        (when view
          (let ((player (get-player~ view)))
            (when (and player (is-not? (get-overlapped) Tooltip))
              (when (neq? view (get-mouse-in))
                (when (get-mouse-in)
                  (dispatch-mouse-leave~ (get-mouse-in))
                  (cancel-mouse-leave-tracking (get-handle~ player))
                  (unless (or (is? player Tooltip) (in-tooltip? pos))
                    (cancel-tooltip-tracking)))
                (set-mouse-in view)
                (when (get-mouse-in)
                  (dispatch-mouse-enter~ (get-mouse-in)))
                (track-mouse-leave (get-handle~ player)))
              (unless (or *current-tooltip-context* (current-drag-drop))
                (track-tooltip~ (get-mouse-in)))
              (if mouse-down?
                  (let ((acquired (acquire~ mouse-down-view self pos)))
                    (let ((event (make-event Mouse-Event :mouse-move mouse-down-view position: acquired)))
                      (call-cursor-update~ mouse-down-view event)
                      (process-drag-move~ mouse-down-view event)))
                (let ((acquired (acquire~ view self pos)))
                  (let ((event (make-event Mouse-Event :mouse-move view position: acquired)))
                    (call-cursor-update~ view event)
                    (process-mouse-move~ view event))))))))))

  
  (method (process-mouse-move event)
    (when *current-tooltip-context*
      (process-tooltip event))
    (call-mouse-move event))
  
  
  (method (call-mouse-move event)
    (if mouse-move-handler
        (invoke-handler self mouse-move-handler event)
      (mouse-move event)))
  
  
  (method protected (root-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos))
           (acquired (and view (acquire~ view self pos))))
      (dispatch-mouse-up view (make-event Mouse-Event :mouse-up (or view self) position: acquired))))
  
  
  (method protected (dispatch-mouse-up view event)
    (when view
      (let ((position (get-position-value~ event)))
        (when mouse-down?
          (let ((drag-event (make-event Mouse-Event :mouse-up mouse-down-view position: (acquire~ mouse-down-view view position))))
            (hook-event drag-event)
            (process-drag-up~ mouse-down-view drag-event)))
        (let ((event (make-event Mouse-Event :mouse-move view position: position)))
          (call-cursor-update~ view event)
          (process-mouse-up~ view event))))
    (when (get-delayed-mouse-action)
      (let ((action (get-delayed-mouse-action)))
        (set-delayed-mouse-action #f)
        (action))))

  
  (method (process-mouse-up event)
    (when (current-drag-drop)
      (drag-drop (current-drag-drop) (get-position-value~ event)))
    (call-mouse-up event))

  
  (method (call-mouse-up event)
    (if mouse-up-handler
        (invoke-handler self mouse-up-handler event)
      (mouse-up event)))

  
  (method (process-drag-move event)
    (let ((pos (get-position-value~ event)))
      (if (and (eq? self mouse-down-view) (get-draggable?) (or (not (current-drag-drop)) (eq? self (get-view~ (get-source~ (current-drag-drop))))))
          (begin
            (when (allow-start-drag? pos)
              (let ((drag-drop (get-drag-drop)))
                (when drag-drop
                  (drag-start pos drag-drop))))
            (when (current-drag-drop)
              (drag-follow pos)))
        (call-drag-move event))))
  
  
  (method protected virtual (allow-start-drag? pos)
    (and mouse-down? (not (current-drag-drop)) (not (near? pos mouse-down-point drag-tolerance))))
  
  
  (method (call-drag-move event)
    (if drag-move-handler
        (invoke-handler self drag-move-handler event)
      (drag-move event)))

  
  (method (process-drag-up event (dragging? (current-drag-drop)))
    (set-mouse-down? #f)
    (set-mouse-down-view #f)
    (set-mouse-down-point #f)
    (when player
      (call-drag-up event dragging?)))

  
  (method (call-drag-up event dragging?)
    (if drag-up-handler
        (invoke-handler self drag-up-handler event)
      (drag-up event dragging?)))
  
  
  (method protected (root-double-click h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-double-click view (make-mouse-event 2 :double-click view position: acquired))))))
  
  
  (method protected (dispatch-double-click view event)
    (when (view-enabled?~ view)
      (hook-event event)
      (close-popups~ view event: 'double-click)
      (set-mouse-down? #t)
      (set-mouse-down-view view)
      (set-mouse-down-point (get-position-value~ event))
      (when (mouse-activate?~ view)
        (let ((host (get-host~ view)))
          (when (and host (mouse-activate?~ host) (not (focused-host? host)))
            (mouse-activate~ host))))
      (call-double-click~ view event)))
  
  
  (method public virtual (call-double-click event)
    (if double-click-handler
        (invoke-handler self double-click-handler event)
      (double-click event)))
  
  
  (method protected (root-multiple-click count h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-multiple-click view (make-mouse-event count :multiple-click view position: acquired))))))
  
  
  (method protected (dispatch-multiple-click view event)
    (when (view-enabled?~ view)
      (hook-event event)
      (close-popups~ view event: 'multiple-click)
      (set-mouse-down? #t)
      (set-mouse-down-view view)
      (set-mouse-down-point (get-position-value~ event))
      (when (mouse-activate?~ view)
        (let ((host (get-host~ view)))
          (when (and host (mouse-activate?~ host) (not (focused-host? host)))
            (mouse-activate~ host))))
      (call-multiple-click~ view event)))
  
  
  (method public virtual (call-multiple-click event)
    (if multiple-click-handler
        (invoke-handler self multiple-click-handler event)
      (multiple-click event)))
  
  
  (method protected (root-context-menu h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-context-menu view (make-event Mouse-Event :context-menu view position: acquired))))))
  
  
  (method protected (dispatch-context-menu view event)
    (when (view-enabled?~ view)
      (hook-event event)
      (close-popups~ view event: 'context-menu)
      (call-context-menu~ view event)))
  
  
  (method public (call-context-menu event)
    (if context-menu-handler
        (invoke-handler self context-menu-handler event)
      (context-menu event)))
    
  
  (method protected (root-middle-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-middle-mouse-down view (make-event Mouse-Event :middle-mouse-down view position: acquired))))))

  
  (method protected (dispatch-middle-mouse-down view event)
    (when (view-enabled?~ view)
      (middle-mouse-down~ view event)))
    
  
  (method protected (root-middle-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-middle-mouse-up view (make-event Mouse-Event :middle-mouse-up view position: acquired))))))
  
  
  (method protected (dispatch-middle-mouse-up view event)
    (when (view-enabled?~ view)
      (middle-mouse-up~ view event)))
    
  
  (method protected (root-right-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-right-mouse-down view (make-event Mouse-Event :right-mouse-down view position: acquired))))))
  
  
  (method protected (dispatch-right-mouse-down view event)
    (set-mouse-right-down? #t)
    (when (view-enabled?~ view)
      (right-mouse-down~ view event)))
    
  
  (method protected (root-right-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (dispatch-right-mouse-up view (make-event Mouse-Event :right-mouse-up view position: acquired))))))
  
  
  (method protected (dispatch-right-mouse-up view event)
    (set-mouse-right-down? #f)
    (when (view-enabled?~ view)
      (right-mouse-up~ view event)))
  
  
  (method (dispatch-mouse-enter)
    (call-mouse-enter))
  
  
  (method (call-mouse-enter)
    (if mouse-enter-handler
        (invoke-handler self mouse-enter-handler (make-event Mouse-Event :mouse-enter self))
      (mouse-enter)))
  
  
  (method (dispatch-mouse-leave)
    (call-mouse-leave))
  
  
  (method (call-mouse-leave)
    (cancel-hovering)
    (close-self-tooltip)
    (if mouse-leave-handler
        (invoke-handler self mouse-leave-handler (make-event Mouse-Event :mouse-leave self))
      (mouse-leave)))
  
  
  (method public virtual (mouse-hover pos)
    )
  
  
  (method public virtual (mouse-wheel pos delta)
    (unless (get-mouse-down?)
      (let ((scroller (find-ascendant Scroller-View)))
        (when scroller
          (let ((client (get-client~ scroller)))
            (when client
              (scroll~ client delta)))))))

  
  (method public virtual (mouse-enter)
    )

  
  (method public virtual (mouse-leave)
    )

  
  (method public virtual (mouse-down evt)
    )
  
  
  (method public virtual (mouse-move evt)
    )
  
  
  (method public virtual (mouse-up evt)
    )
  
  
  (method public virtual (drag-move evt)
    )
  
  
  (method public virtual (drag-up evt . rest)
    )
  
  
  (method public virtual (double-click evt)
    (call-mouse-down evt))
  
  
  (method public virtual (multiple-click evt)
    (if (odd? (get-count~ evt))
        (call-mouse-down evt)
      (call-double-click evt)))
  
  
  (method public virtual (with-context-click pos proc)
    (proc))
  
  
  (method public virtual (context-menu evt)
    )
  
  
  (method public virtual (get-context-menu)
    #f)
  
  
  (method public virtual (middle-mouse-down evt)
    (mouse-down evt))
  
  
  (method public virtual (middle-mouse-up evt)
    (mouse-up evt))
  
  
  (method public virtual (right-mouse-down evt)
    )
  
  
  (method public virtual (right-mouse-up evt)
    )
  
  
  (method public virtual (mouse-activate?)
    #t)


  (method public (mouse-view)
    (or (get-captured-view) (get-mouse-in)))


  ;;;
  ;;;; Hovering
  ;;;
  
  
  (definition Hovering-Tolerance
    3)
  
  (definition Hovering-Time
    0.5)
  
  (definition Hovering-Steps
    5)
  
  
  (method public (track-hovering (time: time Hovering-Time))
    (define (check-hovering start)
      (if (neq? (mouse-view) self)
          (cancel-hovering)
        (when hover-history
          (let ((pos (mouse-position)))
            (if (< (length hover-history) Hovering-Steps)
                (set! hover-history (cons pos hover-history))
              (if (every? (lambda (point)
                            (< (distance point pos) Hovering-Tolerance))
                          hover-history)
                  (begin
                    (cancel-hovering)
                    (call-mouse-hover pos))
                (set! hover-history (cons pos hover-history))
                (set-cdr! (tail hover-history (- Hovering-Steps 1)) '())))))))
    
    (cancel-hovering)
    (let ((start (mouse-position))
          (period (/ (cast <fl> time) Hovering-Steps)))
      (set! hover-history '())
      (set! hover-pulse (new Pulse 'hovering period (lambda () (check-hovering start)) delay: 0))))
  
  
  (method public (cancel-hovering)
    (when hover-pulse
      (close~ hover-pulse)
      (set! hover-history #f)
      (set! hover-pulse #f)))
  

  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (definition package *current-tooltip-context*
    #f)
  
  (definition *recent-tooltip-close*
    #f)
  
  (definition *last-tooltip-position*
    #f)
  
  
  (method (track-tooltip)
    (define (recently-closed?)
      (and *recent-tooltip-close* (< (current-seconds) *recent-tooltip-close*)))
    
    (when (and (get-tooltip?) (get-player))
      (if (recently-closed?)
          (track-hovering time: 0.1)
        (track-hovering))))
  
  
  (method (cancel-tooltip-tracking)
    (cancel-hovering)
    (close-tooltip))
  
  
  (method public (reset-tooltip)
    (cancel-tooltip-tracking))
  
  
  (method (in-tooltip? pos)
    (and *current-tooltip-context*
         (let ((view (get-view~ *current-tooltip-context*))
               (rect (get-bounds~ *current-tooltip-context*)))
           (and rect
                (in-rect? (acquire~ view self pos) rect)))))
  
  
  (method (process-tooltip evt)
    (let ((overlapped (get-overlapped)))
      (unless (is? overlapped Tooltip)
        (let ((view (get-view~ *current-tooltip-context*))
              (bounds (get-bounds~ *current-tooltip-context*))
              (new-bounds (get-tooltip-bounds (get-position-value~ evt))))
          (unless (and (eq? overlapped (get-overlapped~ view))
                       (nu=? bounds new-bounds))
            (reset-tooltip))))))
  
  
  (method (popup-tooltip pos)
    (define (same-position?)
      (and *last-tooltip-position* (nu=? pos *last-tooltip-position*)))
    
    (define (new-tooltip-view text)
      (if (and (get-formatted-tooltip?) (pair? text))
          (let* ((view (new Tooltip-Text size: {Dimension 4000 100}))
                 (text-view (get-text~ view))
                 (text-model (get-model~ text-view)))
            (set-text~ text-model text)
            (set-size~ view (nu+ (scrollee-content-size~ text-view) {Dimension 2 2}))
            view)
        (new Tooltip-Label title: text)))
    
    (define (new-tooltip text font position padding new-view new-border)
      (let ((view (if new-view (new-view text) (new-tooltip-view text)))
            (border (if new-border (new-border) (new Border-View border-type: 'solid))))
        (when font
          (set-font~ view font))
        (set-preferred-size~ view)
        (let ((padding (or padding (new Dimension 0 (get-cursor-height))))
              (position (or position pos)))
          (popup view position padding: padding class: Tooltip border: border))))
    
    (define (get-cursor-height)
      (let ((cursor (get-cursor)))
        (case cursor
          ((:ibeam) 9)
          (else 21))))
    
    (unless (or mouse-down? (current-drag-drop) (in-tooltip? pos))
      (close-tooltip)
      (unless (same-position?)
        (set! *current-tooltip-context* (get-tooltip-context pos))
        (if *current-tooltip-context*
            (let ((text (get-text~ *current-tooltip-context*))
                  (font (get-font~ *current-tooltip-context*))
                  (position (get-position~ *current-tooltip-context*))
                  (padding (get-padding~ *current-tooltip-context*))
                  (new-view (get-new-view~ *current-tooltip-context*))
                  (new-border (get-new-border~ *current-tooltip-context*)))
              (set-tooltip~ *current-tooltip-context* (new-tooltip text font position padding new-view new-border)))
          (set! *last-tooltip-position* pos)
          (reset-tooltip)))))
  
  
  ;; only works for rich tooltips for now
  (method public (update-tooltip text)
    (when *current-tooltip-context*
      (let* ((tooltip (get-tooltip~ *current-tooltip-context*))
             (border (first-child~ (get-root~ tooltip)))
             (view (first-child~ border))
             (text-view (get-text~ view)))
        (set-size~ view {Dimension 4000 100})
        (set-text~ (get-model~ text-view) text)
        (set-size~ tooltip (nu+ (scrollee-content-size~ text-view) {Dimension 6 6}))
        (set-size~ border (get-size~ tooltip))
        (layout-view~ border))))
  
  
  (method virtual (close-self-tooltip)
    (when (and *current-tooltip-context* (eq? self (get-view~ *current-tooltip-context*)))
      (close-tooltip)))
  
  
  (method (close-tooltip)
    (when *current-tooltip-context*
      (let ((tooltip (get-tooltip~ *current-tooltip-context*)))
        (when (and tooltip (opened?~ tooltip))
          (close-popup tooltip)))
      (set! *current-tooltip-context* #f)
      (set! *recent-tooltip-close* (+ (current-seconds) 0.5))))


  ;;;
  ;;;; Groups
  ;;;
  
  
  (method public (get-selected-element (class: class Radio-Button) (group: group #f))
    (let ((element
            (find-if (lambda (child)
                       (and (is? child class)
                            (eqv? (get-group~ child) group)
                            (get-selected?~ child)))
                     children)))
      (when element
        (get-name~ element))))
  
  
  (method public (set-selected-element name (class: class Radio-Button) (group: group #f))
    (let ((found? #f))
      (for-each (lambda (child)
                  (when (and (is? child class)
                             (eqv? (get-group~ child) group))
                    (let ((selected? (eq? (get-name~ child) name)))
                      (set-selected?~ child selected?)
                      (when selected?
                        (set! found? #t)))))
                children)
      (unless found?
        (error "Unable to find element: {t}" name))))
  
  
  (method public (unselect-elements (class: class Radio-Button) (group: group #f))
    (for-each (lambda (child)
                (when (and (is? child class)
                           (eqv? (get-group~ child) group))
                  (unselect~ child)))
              children))


  ;;;
  ;;;; Context Menu
  ;;;
  
  
  (method public (track-popup-menu menu pos (alternate-position: alternate-position #f) (initiator: initiator self))
    (define (all-invisible? menu)
      (every? (lambda (item)
                (not (get-visible?~ item)))
              (get-children~ menu)))
    
    (if (is-not? menu Context-Menu)
        (error "{t} is not of the expected Context-Menu class" menu)
      (and (not (all-invisible? menu))
           (clear-highlighted~ menu)
           (let ((popup (popup menu pos alternate-position: alternate-position class: Menu-Transient initiator: initiator)))
             (push-focus menu)
             popup))))
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;

  
  (method public virtual (mouse-copy event destination)
    (let ((data (mouse-data (get-position~ event))))
      (if (not data)
          #f
        (mouse-insert~ destination data)
        #t)))

  
  (method public virtual (mouse-data pos)
    #f)

  
  (method public virtual (mouse-insert object)
    )
  
  
  ;;;
  ;;;; Desktop
  ;;;
  
  
  (method public (to-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire~ desktop player (acquire~ root self shape))))
  
  
  (method public (from-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire root (acquire~ player desktop shape))))
  
  
  ;;;
  ;;;; Popup
  ;;;
  
  
  (method public (popup . rest)
    (apply (~ popup (get-window-manager)) self rest))
  
  
  (method package (close-current-popup)
    (when (is? player Popup)
      (close-popup player)))
  
  
  (method public virtual (close-popups (event: event #f) (all?: all? #f) (exclude: exclude #f) (initiator: initiator #f))
    (when player
      (close-popups~ player all?: all? exclude: exclude initiator: initiator)))
  
  
  (method public virtual (popup-destroy popup)
    )
  
  
  (method public (popup-initiator)
    (let ((overlapped (get-overlapped)))
      (and (is? overlapped Popup)
           (get-initiator~ overlapped))))
  
  
  (method public (owned? overlapped)
    (memq? overlapped (get-owners~ (get-overlapped))))


  ;;;
  ;;;; Drag
  ;;;


  (method public virtual (get-draggable?)
    draggable?)


  (method public (set-draggable? flag)
    (set! draggable? flag))


  (method public virtual (get-drag-drop)
    (let ((source (get-drag-source)))
      (and source
           (new DnD source: source))))
  
  
  (method public virtual (get-drag-source)
    (let ((pos (get-drag-position)))
      (new Drag-Source view: self position: pos image: (get-drag-image pos))))
  
  
  (method public virtual (get-drag-position)
    mouse-down-point)
  
  
  (method public virtual (get-drag-image pos)
    #f)
  
  
  (method protected virtual (drag-acquires-focus?)
    #t)
  
  
  (method (drag-start pos drag-drop)
    (set-current-drag-drop drag-drop)
    (let ((view (get-view~ (get-source~ drag-drop))))
      (when (drag-acquires-focus?~ view)
        (acquire-focus~ view))
      (acquire-capture~ view)
      (let ((global (to-desktop~ view pos)))
        (hide-drag-image)
        (process-drag-feedback global))))
  
  
  (method (drag-follow pos)
    (when (current-drag-drop)
      (let* ((drag-drop (current-drag-drop))
             (view (get-view~ (get-source~ drag-drop)))
             (global (to-desktop~ view pos)))
        (process-drag-feedback global))))
  
  
  (method (drag-drop drag-drop pos)
    (drag-end)
    (if (get-target~ drag-drop)
        (drop drag-drop pos)
      (drop-void drag-drop)))
  
  
  (method (drag-end)
    (when (current-drag-drop)
      (let ((drag-drop (current-drag-drop)))
        (hide-drag-image)
        (unhighlight-current drag-drop)
        (release-capture~ (get-view~ (get-source~ drag-drop)))
        (set-current-drag-drop #f)
        (update-cursor))))
  
  
  (method (process-drag-feedback global)
    (let* ((drag-drop (current-drag-drop))
           (current (get-view~ drag-drop))
           (desktop (get-desktop))
           (view (find-view~ desktop global)))
      (set-view~ drag-drop view)
      (when view
        (let* ((local (to-view~ desktop global view))
               (target (call-current-drop~ view drag-drop local)))
          (if (not target)
              (set-cursor :no)
            (when (neq? target (get-target~ drag-drop))
              (set-cursor (if target :move :no))
              (hide-drag-image)
              (unhighlight-current drag-drop)
              (set-target~ drag-drop target)
              (when target
                (highlight-current drag-drop view local))
              (when target
                (show-drag-image))))))))
  
  
  (method (hide-drag-image)
    @old(ImageList_DragShowNolock #f))
  
  
  (method (show-drag-image)
    @old(ImageList_DragShowNolock #t))
  
  
  (method (highlight-current drag-drop view local)
    (highlight-drop~ view drag-drop local))
  
  
  (method (unhighlight-current drag-drop)
    (let ((current-target (get-target~ drag-drop)))
      (when current-target
        (unhighlight-drop~ (get-view~ current-target) drag-drop))))
  
  
  (method public virtual (highlight-drop drag-drop pos)
    )
  
  
  (method public virtual (unhighlight-drop drag-drop)
    )


  ;;;
  ;;;; Drop
  ;;;
  
  
  (method public (call-current-drop drag-drop pos)
    (if current-drop-handler
        (invoke-handler self current-drop-handler (new Drop-Event :drop-target self (modifiers-mask) drag-drop position: pos))
      (current-drop drag-drop pos)))

  
  (method public virtual (current-drop drag-drop pos)
    #f)
  
  
  (method public (standard-current-drop evt acceptance (handler: handler #f))
    (let* ((sender (get-sender~ evt))
           (pos (get-position~ evt))
           (drag-drop (get-drag-drop~ evt))
           (current (get-target~ drag-drop))
           (drag-start (get-view~ (get-source~ drag-drop)))
           (drag-over (get-view~ drag-drop))
           (drag-info (cons drag-start drag-over)))
      (if (neq? drag-start drag-over)
          (let ((criteria (find-if (lambda (criteria) (accepts?~ criteria drag-info)) acceptance)))
            (if criteria
                (new Drop-Target handler: handler view: sender position: pos criteria: criteria)
              (current-drop~ sender drag-drop pos)))
        (current-drop~ sender drag-drop pos))))

  
  (method public virtual (drop drag-drop pos)
    (let* ((src (get-view~ (get-source~ drag-drop)))
           (trg (get-target~ drag-drop))
           (dst (or (get-handler~ trg) (get-view~ trg))))
      (when dst
        (call-receive-drop~ dst self (acquire~ dst src pos) drag-drop))))
  
  
  (method public virtual (drop-void drag-drop)
    )
  
  
  (method public (call-receive-drop sender pos drag-drop)
    (if receive-drop-handler
        (invoke-handler self receive-drop-handler (new Drop-Event :receive-drop sender (modifiers-mask) drag-drop position: pos))
      (receive-drop sender pos drag-drop)))
  
  
  (method public virtual (receive-drop sender pos drag-drop)
    )


  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method protected (call-key-press event)
    (if key-press-handler
        (invoke-handler self key-press-handler event)
      (let ((handler {Event-Handler :focus on-insert}))
        (hook-action handler event
          (lambda ()
            (key-press event))))))
  
  
  (method (on-arrow evt)
    (call-arrow-press evt))

  
  (method (call-arrow-press evt)
    (if arrow-press-handler
        (invoke-handler self arrow-press-handler evt)
      (arrow-press evt)))


  (method public virtual (arrow-press evt)
    (let ((direction (get-property~ evt direction:))
          (modifiers (get-modifiers~ evt)))
      (case direction
        ((left)  (left-arrow-press  modifiers))
        ((right) (right-arrow-press modifiers))
        ((up)    (up-arrow-press    modifiers))
        ((down)  (down-arrow-press  modifiers)))))


  (method public virtual (left-arrow-press modifiers)
    )


  (method public virtual (right-arrow-press modifiers)
    )


  (method public virtual (up-arrow-press modifiers)
    )


  (method public virtual (down-arrow-press modifiers)
    )
  
  
  (method package virtual (on-escape-press evt)
    (let ((event (new Keyboard-Event :char (get-sender~ evt) (get-modifiers~ evt) key: #\escape)))
      (call-escape-press event)))
  
  
  (method (call-escape-press event)
    (if escape-press-handler
        (invoke-handler self escape-press-handler event)
      (escape-press event)))


  (method public virtual (escape-press evt)
    )
  
  
  (method package virtual (on-backspace-press evt)
    (let ((event (new Keyboard-Event :char (get-sender~ evt) (get-modifiers~ evt) key: #\backspace)))
      (call-backspace-press event)))
  
  
  (method (call-backspace-press event)
    (if backspace-press-handler
        (invoke-handler self backspace-press-handler event)
      (backspace-press event)))


  (method public virtual (backspace-press evt . rest)
    )
  
  
  (method package virtual (on-return-press evt)
    (let ((event (new Keyboard-Event :char (get-sender~ evt) (get-modifiers~ evt) key: #\return)))
      (call-return-press event)))
  

  (method (call-return-press event)
    (if return-press-handler
        (invoke-handler self return-press-handler event)
      (return-press event)))


  (method public virtual (return-press evt)
    )
  
  
  (method package virtual (on-tab-press evt)
    (let ((event (new Keyboard-Event :char (get-sender~ evt) (get-modifiers~ evt) key: #\tab)))
      (call-tab-press event)))
  
  
  (method (call-tab-press event)
    (if tab-press-handler
        (invoke-handler self tab-press-handler event)
      (tab-press event)))


  (method public virtual (tab-press evt)
    (navigate-view (get-shift?~ evt)))
  
  
  (method virtual (on-key-press evt)
    (key-press (get-property~ evt key:)))


  (method public virtual (key-press evt)
    )
  
  
  (method protected (dispatch-key-press key)
    (if (and (current-drag-drop) (eqv? key #\escape))
        (begin
          (drag-end)
          (complete-drag-up #t))
      (let ((view (get-focus)))
        (when view
          (let ((event (make-event Keyboard-Event :char self key: key)))
            (hook-event event)
            (call-key-press~ view event))))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method public (find-tab-manager)
    (if (get-tab-stops)
        self
      (let ((ascendant (find-ascendant View)))
        (if (not ascendant)
            self
          (find-tab-manager~ ascendant)))))
  
  
  (method public virtual (navigate-tab from backward?)
    (define (navigate from to)
      (tab-stop-exit~ from)
      (acquire-focus~ to)
      (tab-stop-enter~ to))

    (let ((to (navigated-view from backward?)))
      (if to
          (let ((enabled (view-enabled?~ to)))
            (while (and navigable? (not enabled))
              (set! to (navigated-view to backward?))
              (set! enabled (view-enabled?~ to)))
            (if (is? to View)
                (navigate-tab~ to self backward?)
              (navigate from to)))
        (navigate from self))))
  
  
  (method public (navigated-view from backward? (test: test #f))
    (let ((stops (get-tab-stops)))
      (and stops
           (let ((count (length stops))
                 (rank (find stops from test: test)))
             (and rank
                  (let ((new-rank (if backward? (if (= rank 0) (- count 1) (- rank 1)) (modulo (+ rank 1) count))))
                    (element stops new-rank)))))))
  
  
  (method protected (navigate-view backward?)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self backward?)))
  
  
  (method public virtual (get-tab-stops)
    #f)
  
  
  (method public virtual (tab-stop-enter)
    (select-all))
  
  
  (method public virtual (tab-stop-exit)
    )


  ;;;
  ;;;; Edition
  ;;;
  
  
  (method (on-undo evt)
    (if (not surrogate)
        (undo)
      (undo~ surrogate)))
  
  
  (method (on-redo evt)
    (if (not surrogate)
        (redo)
      (redo~ surrogate)))
  
  
  (method (on-cut evt)
    (if (not surrogate)
        (cut-selection)
      (cut-selection~ surrogate)))
  
  
  (method (on-copy evt)
    (if (not surrogate)
        (copy-selection)
      (copy-selection~ surrogate)))
  
  
  (method (on-paste evt)
    (if (not surrogate)
        (paste-clipboard)
      (paste-clipboard~ surrogate)))
  
  
  (method (on-paste-properties evt)
    (if (not surrogate)
        (paste-properties)
      (paste-properties~ surrogate)))
  
  
  (method (on-delete evt)
    (if (not surrogate)
        (delete-selection)
      (delete-selection~ surrogate)))
  
  
  (method (on-rename evt)
    (if (not surrogate)
        (rename-selection)
      (rename-selection~ surrogate)))
  
  
  (method (on-select-all evt)
    (if (not surrogate)
        (select-all)
      (select-all~ surrogate)))
  
  
  (method public (can-view-undo?)
    (if surrogate
        (can-undo?~ surrogate)
      (can-undo?)))
  
  
  (method public virtual (can-undo?)
    #f)
  
  
  (method public (can-view-redo?)
    (if surrogate
        (can-redo?~ surrogate)
      (can-redo?)))
  
  
  (method public virtual (can-redo?)
    #f)
  
  
  (method public (can-view-cut?)
    (if surrogate
        (can-cut?~ surrogate)
      (can-cut?)))
  
  
  (method public virtual (can-cut?)
    #f)
  
  
  (method public (can-view-copy?)
    (if surrogate
        (can-copy?~ surrogate)
      (can-copy?)))
  
  
  (method public virtual (can-copy?)
    #f)
  
  
  (method public (can-view-paste?)
    (if surrogate
        (can-paste?~ surrogate)
      (can-paste?)))
  
  
  (method public virtual (can-paste?)
    #f)
  
  
  (method public (can-view-paste-properties?)
    (if surrogate
        (can-paste-properties?~ surrogate)
      (can-paste-properties?)))
  
  
  (method public virtual (can-paste-properties?)
    #f)
  
  
  (method public (can-view-delete?)
    (if surrogate
        (can-delete?~ surrogate)
      (can-delete?)))
  
  
  (method public virtual (can-delete?)
    #f)
  
  
  (method public (can-view-rename?)
    (if surrogate
        (can-rename?~ surrogate)
      (can-rename?)))
  
  
  (method public virtual (can-rename?)
    #f)
  
  
  (method public (can-view-select-all?)
    (if surrogate
        (can-select-all?~ surrogate)
      (can-select-all?)))
  
  
  (method public virtual (can-select-all?)
    #f)
  
  
  (method public virtual (undo)
    )
  
  
  (method public virtual (redo)
    )
  
  
  (method public virtual (cut-selection)
    )
  
  
  (method public virtual (copy-selection)
    )
  
  
  (method public virtual (paste-clipboard)
    )
  
  
  (method public virtual (paste-clipboard-value value)
    )
  
  
  (method public virtual (cycle-paste-clipboard previous-clipboard clipboard)
    )
  
  
  (method public virtual (paste-properties)
    )
  
  
  (method public virtual (delete-selection)
    )
  
  
  (method public virtual (rename-selection)
    )
  
  
  (method public virtual (select-all . rest)
    )


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method public (acquire-capture)
    (set-captured-view self)
    (acquire-capture~ (get-player)))
  
  
  (method public (release-capture)
    (set-captured-view #f)
    (release-capture~ (get-player)))


  ;;;
  ;;;; Tooltips
  ;;;


  (method public virtual (get-tooltip?)
    tooltip?)


  (method public (set-tooltip? flag)
    (when (neq? flag tooltip?)
      (set! tooltip? flag)))


  (method public virtual (get-tooltip-text)
    (and tooltip-text
         (let* ((shortcut (and (is? action-handler Action)
                               (get-shortcut~ (require-action-item action-handler))))
                (add-shortcut (if shortcut (lambda (text) (format "{a} ({a})" text (present-shortcut~ shortcut))) identity)))
           (if (string? tooltip-text)
               (add-shortcut tooltip-text)
             (apply new Locales (alist->plist (map (lambda (locale-name)
                                                     (cons locale-name (add-shortcut (localize~ tooltip-text locale-name))))
                                                   (provide-locales~ tooltip-text))))))))
  
  
  (method public virtual (set-tooltip-text text)
    (set! tooltip-text text))
  
  
  ;; a quicky... this should probably by default return the value of a property
  (method public virtual (get-formatted-tooltip?)
    #f)
  
  
  (method public virtual (get-tooltip-bounds pos)
    #f)
  
  
  (method public virtual (get-tooltip-context pos)
    (let ((text (get-tooltip-text))
          (bounds (get-tooltip-bounds pos)))
      (and text
           (new Tooltip-Context view: self text: text bounds: bounds))))
  
  
  ;;;
  ;;;; Surface
  ;;;


  (method public (with-view-surface proc)
    (with-window-surface (get-player)
      (lambda (cairo-surface)
        (with ((surface (new Surface cairo-surface)))
          (with-clipping-view-transformation surface (get-rootmost)
            (lambda ()
              (proc surface)))))))
  
  
  (method public (flush-device-transformation)
    (when device-transformation
      (for-each (lambda (child)
                  (flush-device-transformation~ child))
                children)
      (cairo_matrix_t-free device-transformation) ; DANGER, should handle it through wills
      (set! device-transformation #f)))
  
  
  (method public (build-device-transformation)
    (let ((surface (transformation-surface)))
      (with-cached-transformation surface
        (lambda ()
          ;; hacked for testing
          (cairo_matrix_t-xx-ref (cairo_get_matrix_raw (get-context~ surface)))))))
  
  
  (method public (with-cached-transformation surface thunk)
    (define (save-and-thunk)
      (set! device-transformation (cairo_matrix_t-make))
      (cairo_get_matrix (get-context~ surface) device-transformation)
      (thunk))
    
    (if (not device-transformation)
        (if parent
            (with-cached-transformation~ parent surface
              (lambda ()
                (with-self-transformation surface save-and-thunk)))
          (with-pristine-transformation~ surface save-and-thunk))
      (with-preserved-matrix~ surface
        (lambda ()
          (cairo_set_matrix (get-context~ surface) device-transformation)
          (thunk)))))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-view)
    (let ((bounds (get-bounds)))
      (invalidate-rect bounds)))
  
  
  (method public (invalidate-rect rect)
    (when (and (not (inhibit-invalidates?)) (view-visible?))
      (let ((acquired
              (with-clipped-transformation-surface
                (lambda (surface)
                  (logical->device~ surface (if (inhibit-clipping?)
                                                rect
                                              (rect-intersection rect (get-clipper~ surface))))))))
        (invalidate-rect~ player acquired))))
  
  
  ;; todo: not using acquire is a potentiel scaling bug...
  (method public (invalidate-region region)
    (when (and (not (inhibit-invalidates?)) (view-visible?))
      (with-clipped-transformation-surface
        (lambda (surface)
          (let ((delta (logical->device~ surface {Point 0 0})))
            (offset!~ region (get-h~ delta) (get-v~ delta))
            (unless (inhibit-clipping?)
              (with ((clipper (new Region rect: (logical->device~ surface (get-clipper~ surface)))))
                (combine-and!~ region clipper))))))
      (invalidate-region~ player region)))
  
  
  (method public (redraw-view (rect: rect #f) (region: region #f))
    (let ((player (get-player)))
      (when player
        (cond (rect
               (let ((acquired
                       (with-clipped-transformation-surface
                         (lambda (surface)
                           (logical->device~ surface (rect-intersection rect (get-clipper~ surface)))))))
                 (redraw-window~ player rect: acquired)))
              ;; todo: not using acquire is a potentiel scaling bug...
              (region
               (with-clipped-transformation-surface
                 (lambda (surface)
                   (let ((delta (logical->device~ surface {Point 0 0})))
                     (offset!~ region (get-h~ delta) (get-v~ delta))
                     (with ((clipper (new Region rect: (logical->device~ surface (get-clipper~ surface)))))
                       (combine-and!~ region clipper)))))
               (redraw-window~ player region: region))
              (else
               (let ((acquired
                       (with-clipped-transformation-surface
                         (lambda (surface)
                           (logical->device~ surface (rect-intersection (get-bounds) (get-clipper~ surface)))))))
                 (redraw-window~ player rect: acquired)))))))
  

  ;; Mainly used by the scrollbar to only redraw itself when scrolling
  (method public (redraw-view-only)
    (let ((player (get-player)))
      (when player
        (let ((hwnd (get-handle~ player)))
          (platform-redraw-view-only self hwnd)))))
  
  
  (method public (update-view (effect: effect #f))
    (let ((player (get-player)))
      (when player
        (set-effect effect)
        (update-window~ player))))
  
  
  (method public (without-invalidates thunk)
    (prog1 (parameterize ((inhibit-invalidates? #t))
             (thunk))
      (invalidate-view)))
  
  
  (method public (view-invalidater)
    (and player (not (inhibit-invalidates?))
      (with-clipped-transformation-surface
        (lambda (surface)
          (let ((player player)
                (rect (logical->device~ surface (get-clipper~ surface))))
            (lambda ()
              (invalidate-rect~ player rect)))))))

  
  ;;;
  ;;;; Border
  ;;;


  (method public (invalidate-border (insets: insets {Rect 1 1 1 1}))
    (when (get-finished?)
      (with ((region (border-region insets: insets)))
        (invalidate-region region))))


  (method public (redraw-border (insets: insets {Rect 1 1 1 1}))
    (with ((region (border-region insets: insets)))
      (redraw-view region: region)))


  (method public (border-region (insets: insets {Rect 1 1 1 1}))
    (let ((bounds (get-bounds)))
      (frame-region bounds insets: insets)))


  ;;;
  ;;;; Save
  ;;;

  
  (method package (on-save evt)
    (if (not surrogate)
        (save)
      (save~ surrogate)))
  
  
  (method package (on-save-as evt)
    (save-as))
  
  
  (method package (on-revert-saved evt)
    (revert-saved))
        
  
  (method package (on-compare-saved evt)
    (compare-saved))


  (method public virtual (save)
    )


  (method public virtual (save-as)
    )
  
  
  (method public virtual (save-to moniker)
    )

  
  (method public virtual (revert-saved)
    )

  
  (method public virtual (compare-saved)
    )
  
  
  ;;;
  ;;;; Recording
  ;;;
  
  
  (method protected virtual (record-actions?)
    #t)
  
  
  ;;;
  ;;;; Try Out
  ;;;
  
  
  (method meta override (try-out)
    (new-frame self))
  
  
  ;;;
  ;;;; Descriptor
  ;;;
  
  
  (method meta override (get-class-descriptor (context: context #f))
    (new jazz.view.descriptors:View-Descriptor))))
