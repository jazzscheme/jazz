;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Website Transformation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.website.transformation.JazzWebsite-Transformation jazz


(import (jazz.doc)
        (jazz.jml)
        (jazz.utilities))


(class JazzWebsite-Transformation extends DocToHTML-Transformation
  
  
  (definition Generate-Manual?
    #f)
  
  
  (slot anchors)
  (slot anchor-names)
  (slot next-section)
  
  
  ;;;
  ;;;; Patterns
  ;;;
  
  
  (pattern (<website> node)
    (user-message "Generating website...")
    (process-website node))
  
  
  (pattern (<division> node)
    (let ((title (get-property~ node 'title)))
      `(<span>
         (<p>)
         (<b> ,title)
         (<p>)
         ,@(children->jml~ node))))
  
  
  (pattern (<screenshot> node)
    (let ((label (get-property~ node 'label))
          (preview (get-property~ node 'preview))
          (image (get-property~ node 'image)))
      `(<div>
         (<a> href: ,image
           (<img> src: ,preview))
         (<div> class: "screenshot" align: "center" ,label))))
  
  
  ;;;
  ;;;; Website
  ;;;
  
  
  (method (process-website website)
    (let ((pages (new List-Factory))
          (sections (collect-sections website)))
      (process-sections sections pages)
      (user-message "Parsing website...")
      `(<website>
         ,@(get-output~ pages))))
  
  
  (method (collect-sections website)
    (map (function (section)
           (cons section (collect-if (function (node)
                                       (eq? (get-tag~ node) 'section))
                                     (get-children~ section))))
         (get-children~ website)))
  
  
  (method (validate-anchor-names)
    (let ((fact (new List-Factory)))
      (iterate-table anchor-names
        (function (name lst)
          (when (> (length lst) 1)
            (put~ fact name))))
      (let ((ambiguities (get-output~ fact)))
        (when (not-null? ambiguities)
          (let ((message
                 (cons "The following anchors are multiply defined:"
                       (map (function (name)
                              (list :bulleted (->string name)))
                            ambiguities))))
            (message-box message))))))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method (process-sections sections pages)
    (for-each (function (info)
                (bind (section . subsections) info
                  (process-section section sections pages)
                  (for-each (function (subsection)
                              (process-section subsection sections pages))
                            subsections)))
              sections))
  
  
  (method (process-section section sections pages)
    (user-message "Generating {a}..." (get-property~ section 'name))
    (reset-section)
    (let ((html (section-output section sections)))
      (when (or Generate-Manual? (not (get-property~ section 'manual? #f)))
        (put~ pages `(<page> path: ,(format "{a}" (section-path section))
                                   ,html))))
    (validate-anchor-names))
  
  
  (method (reset-section)
    (set! anchors       (make-table test: eq?))
    (set! anchor-names  (make-table test: eq?))
    (set! next-section  1))
  
  
  (method (section-path section)
    (let ((name (get-property~ section 'name)))
      (if (eq? name 'home)
          'index
        name)))
  
  
  (method (section-output section sections)
    (let ((title (get-property~ section 'title)))
      `(<html>
         (<head>
           (<link> href: "css/master.css" rel: "stylesheet" type: "text/css")
           (<title> ,title))
         (<body>
          (<div> id: "page"
            (<h1> id: "title" "JazzScheme")
            (<div> id: "sectionnav" ,@(navigation-output section sections))
            (<div> id: "content"
              ,@(if (get-property~ section 'manual? #f)
                    (manual-output section)
                  (section-content-output section))
              (<div> id: "footer"
                (<p> "Copyright &copy; 1996-2008 Guillaume Cartier"))))))))
  
  
  (method (section-content-output section)
    (let ((output (new List-Factory)))
      (for-each (function (node)
                  (if (is? node JML-Element)
                      (case (get-tag~ node)
                        ((section)) ;; section will get its own page
                        ((article) (output-article node 1 output))
                        (else (error "Ill-formed section")))
                    (error "Ill-formed section")))
                (get-children~ section))
      (get-output~ output)))
  
  
  ;;;
  ;;;; Navigation
  ;;;
  
  
  (method (navigation-output section sections)
    (let ((output (new List-Factory)))
      (for-each (function (info)
                  (bind (sec . subsecs) info
                    (let ((name (get-property~ sec 'name))
                          (path (format "{a}.htm" (section-path sec)))
                          (title (get-property~ sec 'title))
                          (selected? (eq? sec section)))
                      (unless (nu=? title "DownloadBeta")
                      (put~ output `(<a> class: "section" href: ,path ,(if selected? `(<b> ,title) title)))
                      (when (or (eq? sec section) (memq? section subsecs))
                        (for-each (function (subsec)
                                    (let ((name (get-property~ subsec 'name))
                                          (path (format "{a}.htm" (section-path subsec)))
                                          (title (get-property~ subsec 'title))
                                          (selected? (eq? subsec section)))
                                      (put~ output `(<a> class: "subsection" href: ,path ,(if selected? `(<b> ,title) title)))))
                                  subsecs))))))
                sections)
      (get-output~ output)))
  
  
  ;;;
  ;;;; Manual
  ;;;
  
  
  (method (manual-output section)
    (let* ((title (get-property~ section 'title))
           (project-paths (get-property~ section 'projects '()))
           (projects (apply append (map find-docs project-paths)))
           (content (manual-content-output projects))
           (index (if (get-property~ section 'index? #t) (index-output) '()))
           (toc (toc-output projects))
           (summary (summary-output title section projects)))
      (append summary
              content
              toc
              index)))
  
  
  (method (manual-content-output projects)
    (let ((output (new List-Factory)))
      (for-each (function (project)
                  (output-manual-doc-children project 0 '() output))
                projects)
      (get-output~ output)))
  
  
  (method (output-manual-doc doc level path output)
    (typecase doc
      ((Project-Doc)   (output-manual-project   doc level path output))
      ((Section-Doc)   (output-manual-section   doc level path output))
      ((Package-Doc)   (output-manual-package   doc level path output))
      ((Interface-Doc) (output-manual-interface doc level path output))
      ((Class-Doc)     (output-manual-class     doc level path output))
      ((Form-Doc)      (output-manual-form      doc level path output))
      ((Concept-Doc)   (output-manual-concept   doc level path output))
      ((Syntax-Doc)    (output-manual-syntax    doc level path output))
      ((Primitive-Doc) (output-manual-primitive doc level path output))
      ((Constant-Doc)  (output-manual-constant  doc level path output))
      ((Slot-Doc)      (output-manual-slot      doc level path output))
      ((Property-Doc)  (output-manual-property  doc level path output))
      ((Method-Doc)    (output-manual-method    doc level path output)))
    (output-manual-doc-children doc level path output))
  
  
  (method (output-manual-project doc level path output)
    (output-anchor doc output)
    (put~ output `(<h3> class: "section1" ,(get-effective-title~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-section doc level path output)
    (output-anchor doc output)
    (let ((title (format "{a}. {a}" (present-toc-path path) (get-effective-title~ doc))))
      (case level
        ((1) (put~ output `(<h3> class: "section1" ,title)))
        ((2) (put~ output `(<h4> class: "section2" ,title)))
        (else (put~ output `(<h4> class: "section3" ,title)))))
    (output-doc-description doc output))
  
  
  (method (output-manual-package doc level path output)
    (output-anchor doc output)
    (put~ output `(<h4> class: "package" ,(get-effective-title~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-interface doc level path output)
    (output-anchor doc output)
    (put~ output `(<h4> class: "interface" ,(get-effective-title~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-class doc level path output)
    (output-anchor doc output)
    (put~ output `(<h4> class: "class" ,(get-effective-title~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-form doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "form-definition" (<b> ,(get-effective-title~ doc)) " " (<i> ,(either (get-parameters~ doc) ""))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-concept doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (output-doc-description doc output))
  
  
  (method (output-manual-syntax doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc)) " " (<i> ,(either (get-parameters~ doc) ""))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-primitive doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-constant doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-slot doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-property doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (put~ output `(<p>))
    (output-doc-description doc output))
  
  
  (method (output-manual-method doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc)) " " (<i> ,(either (get-parameters~ doc) ""))))
    (put~ output `(<p>))
    (output-doc-description doc output)
    (output-doc-examples doc output))
  
  
  (method (output-doc-description doc output)
    (let ((description (get-description~ doc)))
      (when description
        (bind (tag . paragraphs) (->jml~ (form->node description))
          (put-sequence~ output paragraphs)))))
  
  
  (method (output-doc-examples doc output)
    (let ((examples (get-examples~ doc)))
      (when (not-null? examples)
        (put~ output `(<p>))
        (put~ output `(<p> "Examples"))
        (put~ output `(<node>
                       ,@(map (function (example)
                                (bind (tag . rest) (->jml~ (form->node example))
                                  `(<span> ,@rest)))
                              (get-children~ examples)))))))
  
  
  (method (output-manual-doc-children doc level path output)
    (let* ((sort? (and (is? doc Section-Doc) (get-sort?~ doc)))
           (children (effective-manual-doc-children doc))
           (sorted (if sort?
                       (sort < children key: (function (child) (get-name~ child)))
                     children)))
      (for-each (function (doc rank)
                  (output-manual-doc doc (+ level 1) (cons (+ rank 1) path) output))
                sorted
                (naturals 0 (length sorted)))))
  
  
  (method (effective-manual-doc-children doc)
    (let ((fact (new List-Factory)))
      (for-each (function (child)
                  (if (is? child Doc-Insert)
                      (let* ((path (get-path~ child))
                             (docs (find-docs path)))
                        (put-sequence~ fact docs))
                    (put~ fact child)))
                (get-children~ doc))
      (get-output~ fact)))
  
  
  (method (find-docs path)
    (let* ((appl (get-application))
           (cataloguer (get-documentation-cataloguer~ appl))
           (docs (new List-Factory)))
      (bind (name . rest) (if (symbol? path) (list path) path)
        (let ((catalog (find-catalog~ cataloguer name)))
          (cond ((null? rest)
                 (put~ docs (get-client~ catalog)))
                ((equal? rest '(*))
                 (let ((parent (get-project~ catalog)))
                   (for-each (function (catalog)
                               (when (eq? (get-parent-project~ (get-project~ catalog)) parent)
                                 (put~ docs (get-client~ catalog))))
                             (get-catalogs~ cataloguer))))
                (else
                 (unimplemented 'find-docs)))))
      (get-output~ docs)))
  
  
  (method (output-anchor doc output)
    (let ((name (get-name~ doc))
          (anchor (register-anchor doc (get-name~ doc) anchors)))
      (put~ output `(<a> name: ,anchor))
      (when name
        (table-add anchor-names name doc))))
  
  
  (method (register-anchor object name anchors)
    (let ((anchor (if name (->string name) (prog1 (format "SEC{a}" next-section) (increase! next-section)))))
      (table-set! anchors object anchor)
      anchor))
  
  
  ;;;
  ;;;; Summary
  ;;;
  
  
  (method (summary-output title section projects)
    (user-message "Generating Summary...")
    `((<div> style: "margin-top: 22;")
      (<h3> class: "summary" ,title)
      (<div> class: "summary_toc" (<a> href: "#TOC" "Table of Contents"))
      ,@(if (get-property~ section 'index? #t)
            `((<div> class: "summary_index" (<a> href: "#INDEX" "Index")))
          `((<p>)))
      ,@(let ((docs (if (= (length projects) 1) (get-children~ (car projects)) projects)))
          (map (function (doc rank)
                 (doc-summary-output doc 1 (list (+ rank 1))))
               docs
               (naturals 0 (length docs))))))
  
  
  (method (doc-summary-output doc level path)
    (let* ((title (present-doc-title doc))
           (text (format "{a}. {a}" (present-toc-path path) title))
           (anchor (format "#{a}" (table-ref anchors doc #f)))
           (children (collect-summary-children doc)))
      `(<div>
         (<div> class: ,(format "summary{a}" level) (<a> href: ,anchor ,text))
         ,@(if (null? children)
               '()
             `((<div>
                 ,@(map (function (child rank)
                          (doc-summary-output child (+ level 1) (cons (+ rank 1) path)))
                        children
                        (naturals 0 (length children)))))))))
  
  
  (method (collect-summary-children doc)
    (let ((sort? (and (is? doc Section-Doc) (get-sort?~ doc)))
          (children (effective-manual-doc-children doc)))
      (collect-if has-project-descendant?
                  (if sort?
                      (sort < children key: (function (child) (get-name~ child)))
                    children))))
  
  
  (method (has-project-descendant? doc)
    (let ((has? #f))
      (letrec ((iter
                (function (doc)
                  (typecase doc
                    ((Project-Doc) (set! has? #t))
                    ((Section-Doc) (for-each iter (effective-manual-doc-children doc)))))))
       (iter doc))
      has?))
  
  
  ;;;
  ;;;; ToC
  ;;;
  
  
  (method (toc-output projects)
    (user-message "Generating Table of Contents...")
    `((<a> name: "TOC" (<h3> class: "toc" "Table of Contents"))
      ,@(let ((docs (if (= (length projects) 1) (get-children~ (car projects)) projects)))
          (map (function (doc rank)
                 (doc-toc-output doc 1 (list (+ rank 1))))
               docs
               (naturals 0 (length docs))))))
  
  
  (method (doc-toc-output doc level path)
    (let* ((title (present-doc-title doc))
           (text (format "{a}. {a}" (present-toc-path path) title))
           (anchor (format "#{a}" (table-ref anchors doc #f)))
           (children (collect-toc-children doc))
           (rank (car path))
           (toc-prefix (if (and (= rank 1) (<= level 3)) "toc_first" "toc")))
      `(<div>
         (<div> class: ,(format "{a}{a}" toc-prefix level) (<a> href: ,anchor ,text))
         ,@(if (null? children)
               '()
             `((<div>
                 ,@(map (function (child rank)
                          (doc-toc-output child (+ level 1) (cons (+ rank 1) path)))
                        children
                        (naturals 0 (length children)))))))))
  
  
  (method (present-doc-title doc)
    (get-effective-title~ doc))
  
  
  (method (present-toc-path path)
    (join (map ->string (reverse path)) "."))
  
  
  (method (collect-toc-children doc)
    (let ((sort? (and (is? doc Section-Doc) (get-sort?~ doc)))
          (children (effective-manual-doc-children doc)))
      (collect-if (function (child)
                    (or (is? child Project-Doc)
                        (is? child Section-Doc)
                        (is? child Package-Doc)
                        (is? child Category-Doc)))
                  (if sort?
                      (sort < children key: (function (child) (get-name~ child)))
                    children))))
  
  
  ;;;
  ;;;; Index
  ;;;
  
  
  (method (index-output)
    (user-message "Generating Index...")
    (let ((letters (sort nu<? (letters-partition) key: car))
           (letter-anchors (make-table test: eq?))
           (output (new List-Factory)))
      (for-each (function (letter)
                  (output-letter letter letter-anchors output))
                letters)
      `((<a> name: "INDEX" (<h3> class: "index" "Index"))
        ,@(index-navigator letters letter-anchors)
        (<table> width: "100%"
          ,@(get-output~ output)))))
  
  
  (method (output-letter letter letter-anchors output)
    (bind (char . infos) letter
      (let ((anchor (register-anchor letter {} letter-anchors)))
        (put~ output `(<tr> (<td> colspan: "2" (<div> class: "index-letter" (<a> name: ,anchor ,(string char)))))))
      (for-each (function (info)
                  (bind (doc anchor title) info
                    (let ((anchor (format "#{a}" anchor)))
                      (put~ output `(<tr>
                                     (<td>)
                                     (<td> (<a> href: ,anchor (<code> ,title))))))))
                infos)))
  
  
  (method (letters-partition)
    (partition (gather-anchors) key: (function (info) (upcase (first (third info))))))
  
  
  (method (gather-anchors)
    (let ((lst '()))
      (iterate-table anchors
        (function (doc anchor)
          (when (get-name~ doc)
            (let ((title (get-effective-title~ doc)))
              (set! lst (cons (list doc anchor title) lst))))))
      (sort nu<? lst key: third)))
  
  
  (method (index-navigator letters letter-anchors)
    (let* ((partition (alphabetic-partition letters))
           (non-alpha (assv-value #f partition '()))
           (alpha (assv-value #t partition '()))
           (output (new List-Factory))
           (process-letter-set
            (function (letter-set)
              (for-each (function (letter)
                          (let ((char (car letter))
                                (anchor (format "#{a}" (table-ref letter-anchors letter #f))))
                            (put~ output `(<a> class: "letter-navigator" href: ,anchor (<b> ,(string char))))
                            (put~ output "&nbsp;")))
                        letter-set))))
      (when (not-null? non-alpha)
        (process-letter-set non-alpha)
        (put~ output `(<br>)))
      (when (not-null? alpha)
        (process-letter-set alpha))
      (get-output~ output)))
  
  
  (method (alphabetic-partition letters)
    (partition letters key: (function (letter)
                              (let ((char (car letter)))
                                (alphabetic? char)))))
  
  
  ;;;
  ;;;; Article
  ;;;
  
  
  (method (output-article article level output)
    (for-each (function (node)
                (if (is? node JML-Element)
                    (case (get-tag~ node)
                      ((description) (output-article-description article node level output))
                      ((article) (output-article node (+ level 1) output))
                      (else (error "Ill-formed article")))
                  (error "Ill-formed article")))
              (get-children~ article)))
  
  
  (method (output-article-description article description level output)
    (put~ output
          `(<div>
            ,@(let ((name (get-property~ article 'name)))
                (if (null? name)
                    '()
                  `((<a> name: ,(->string name)))))
            ,(let ((title (get-property~ article 'title)))
               (case level
                 ((1) `(<h3> ,title))
                 ((2) `(<h4> class: "section2" ,title))
                 (else `(<h4> class: "section3" ,title))))
            ,@(children->jml~ description))))))
