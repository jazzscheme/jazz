;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Website Transformation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.website.transformation.JazzWebsite-Transformation jazz


(import (jazz.catalog)
        (jazz.doc)
        (jazz.io)
        (jazz.jml)
        (jazz.library.component)
        (jazz.system))


(class JazzWebsite-Transformation extends DocToHTML-Transformation
  
  
  (definition Generate-Manual?
    #f)
  
  
  (slot anchors)
  (slot anchor-names)
  (slot next-section)
  
  
  ;;;
  ;;;; Patterns
  ;;;
  
  
  (pattern (<website> node)
    (user-message "Generating website...")
    (process-website node))
  
  
  (pattern (<division> node)
    (let ((name (get-property~ node 'name))
          (title (get-property~ node 'title)))
      `(<span>
         ,@(if (not name)
               '()
             `((<a> name: ,(->string name))))
         (<p>)
         (<b> ,title)
         (<p>)
         ,@(children->jml~ node))))
  
  
  (pattern (<screenshot> node)
    (let ((label (get-property~ node 'label))
          (preview (get-property~ node 'preview))
          (image (get-property~ node 'image)))
      `(<div>
         (<a> href: ,image
           (<img> src: ,preview))
         (<div> class: "screenshot" align: "center" ,label))))
  
  
  ;;;
  ;;;; Website
  ;;;
  
  
  (method (process-website website)
    (let ((pages (new List-Factory))
          (sections (collect-sections website)))
      (process-sections sections pages)
      (user-message "Parsing website...")
      `(<website>
         ,@(get-output~ pages))))
  
  
  (method (collect-sections website)
    (map (lambda (section)
           (cons section (collect-if (lambda (node)
                                       (eq? (get-tag~ node) 'section))
                                     (get-children~ section))))
         (get-children~ website)))
  
  
  (method (validate-anchor-names)
    @wait
    (let ((fact (new List-Factory)))
      (iterate-table anchor-names
        (lambda (name lst)
          (when (> (length lst) 1)
            (put~ fact name))))
      (let ((ambiguities (get-output~ fact)))
        (when (not-null? ambiguities)
          (let ((message
                 (cons "The following anchors are multiply defined:"
                       (map (lambda (name)
                              (list :bulleted (->string name)))
                            ambiguities))))
            (message-box message))))))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method (process-sections sections pages)
    (for-each (lambda (info)
                (bind (section . subsections) info
                  (process-section section sections pages)
                  (for-each (lambda (subsection)
                              (process-section subsection sections pages))
                            subsections)))
              sections))
  
  
  (method (process-section section sections pages)
    (user-message "Generating {a}..." (get-property~ section 'name))
    (reset-section)
    (let ((html (section-output section sections)))
      (when (or Generate-Manual? (not (get-property~ section 'manual? #f)))
        (put~ pages `(<page> path: ,(format "{a}" (section-path section))
                                   ,html))))
    (validate-anchor-names))
  
  
  (method (reset-section)
    (set! anchors       (make-table test: eq?))
    (set! anchor-names  (make-table test: eq?))
    (set! next-section  1))
  
  
  (method (section-path section)
    (let ((name (get-property~ section 'name)))
      (if (eq? name 'home)
          'index
        name)))
  
  
  (method (section-output section sections)
    (let ((title (get-property~ section 'title)))
      `(<html>
         (<head>
           (<link> href: "css/master.css" rel: "stylesheet" type: "text/css")
           (<title> ,title))
         (<body>
          (<div> id: "page"
            (<h1> id: "title" "JazzScheme")
            (<div> id: "sectionnav" ,@(navigation-output section sections))
            (<div> id: "content"
              ,@(if (get-property~ section 'manual? #f)
                    (manual-output section)
                  (section-content-output section))
              (<div> id: "footer"
                (<p> "Copyright &copy; 1996-2009 Guillaume Cartier"))))))))
  
  
  (method (section-content-output section)
    (let ((output (new List-Factory)))
      (for-each (lambda (node)
                  (if (is? node JML-Element)
                      (case (get-tag~ node)
                        ((section)) ;; section will get its own page
                        ((article) (output-article node 1 output))
                        (else (error "Ill-formed section")))
                    (error "Ill-formed section")))
                (get-children~ section))
      (get-output~ output)))
  
  
  ;;;
  ;;;; Navigation
  ;;;
  
  
  (method (navigation-output section sections)
    (let ((output (new List-Factory)))
      (for-each (lambda (info)
                  (bind (sec . subsecs) info
                    (let ((name (get-property~ sec 'name))
                          (path (format "{a}.htm" (section-path sec)))
                          (title (get-property~ sec 'title))
                          (selected? (eq? sec section)))
                      (put~ output `(<a> class: "section" href: ,path ,(if selected? `(<b> ,title) title)))
                      (when (or (eq? sec section) (memq? section subsecs))
                        (for-each (lambda (subsec)
                                    (let ((name (get-property~ subsec 'name))
                                          (path (format "{a}.htm" (section-path subsec)))
                                          (title (get-property~ subsec 'title))
                                          (selected? (eq? subsec section)))
                                      (put~ output `(<a> class: "subsection" href: ,path ,(if selected? `(<b> ,title) title)))))
                                  subsecs)))))
                sections)
      (get-output~ output)))
  
  
  ;;;
  ;;;; Manual
  ;;;
  
  
  (method (manual-output section)
    (define (new-projects-cataloguer projects)
      (let ((cataloguer (new Cataloguer)))
        (for-each (lambda (project)
                    (let ((name (get-name~ project)))
                      (let ((catalog (new Component-Catalog name project)))
                        (add-catalog~ cataloguer catalog))))
                  projects)
        cataloguer))
    
    (let* ((title (get-property~ section 'title))
           (project-paths (get-property~ section 'projects '()))
           (projects (sort string<? (apply append (map find-docs project-paths)) key: present-doc-title))
           (cataloguer (new-projects-cataloguer projects))
           (content (manual-content-output cataloguer projects))
           (index (if (get-property~ section 'index? #t) (index-output) '()))
           (toc (toc-output projects))
           (summary (summary-output title section projects)))
      (append summary
              content
              toc
              index)))
  
  
  (method (manual-content-output cataloguer projects)
    (let ((output (new List-Factory)))
      (for-each (lambda (project)
                  ;; quicky
                  (if (or (is? project Module-Doc)
                          (is? project Library-Doc))
                      (output-manual-doc cataloguer project 0 '() output)
                    (output-manual-doc-children cataloguer project 0 '() output)))
                projects)
      (get-output~ output)))
  
  
  (method (output-manual-doc cataloguer doc level path output)
    (typecase doc
      ((Project-Doc)    (output-manual-project    cataloguer doc level path output))
      ((Section-Doc)    (output-manual-section    cataloguer doc level path output))
      ((Package-Doc)    (output-manual-package    cataloguer doc level path output))
      ((Module-Doc)     (output-manual-module     cataloguer doc level path output))
      ((Library-Doc)    (output-manual-library    cataloguer doc level path output))
      ((Interface-Doc)  (output-manual-interface  cataloguer doc level path output))
      ((Class-Doc)      (output-manual-class      cataloguer doc level path output))
      ((Form-Doc)       (output-manual-form       cataloguer doc level path output))
      ((Concept-Doc)    (output-manual-concept    cataloguer doc level path output))
      ((Syntax-Doc)     (output-manual-syntax     cataloguer doc level path output))
      ((Primitive-Doc)  (output-manual-primitive  cataloguer doc level path output))
      ((Constant-Doc)   (output-manual-constant   cataloguer doc level path output))
      ((Slot-Doc)       (output-manual-slot       cataloguer doc level path output))
      ((Property-Doc)   (output-manual-property   cataloguer doc level path output))
      ((Method-Doc)     (output-manual-method     cataloguer doc level path output))
      ((Export-Doc)     (output-manual-export     cataloguer doc level path output))
      ((Definition-Doc) (output-manual-definition cataloguer doc level path output))
      ((Generic-Doc)    (output-manual-generic    cataloguer doc level path output))
      (else             (error "Unable to output doc for: {s}" doc))))
  
  
  (method (output-manual-project cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<h3> class: "section1" ,(get-effective-title~ doc)))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output))
  
  
  (method (output-manual-section cataloguer doc level path output)
    (output-anchor doc output)
    (let ((title (format "{a}. {a}" (present-toc-path path) (get-effective-title~ doc))))
      (case level
        ((1) (put~ output `(<h3> class: "section1" ,title)))
        ((2) (put~ output `(<h4> class: "section2" ,title)))
        (else (put~ output `(<h4> class: "section3" ,title)))))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output))
  
  
  (method (output-manual-package cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<h3> class: "section1" ,(get-effective-title~ doc)))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output))
  
  
  (method (output-manual-module cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<h3> class: "section1" ,(get-effective-title~ doc)))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output))
  
  
  (method (output-manual-library cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<h3> class: "section1" ,(get-effective-title~ doc)))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output
      sort?: #t
      key: (lambda (child)
             (cons (if (is? child Category-Doc)
                       2
                     1)
                   (get-effective-title~ child)))))
  
  
  (method (output-manual-export cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "native" (<span> class: "definition" ,(get-effective-title~ doc))))
    (output-doc-description doc output)
    (output-doc-examples doc output))
  
  
  (method (output-manual-definition cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "definition" ,(present-text~ doc)))
    (output-doc-description doc output)
    (output-doc-examples doc output))
  
  
  (method (output-manual-generic cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "generic" ,(present-text~ doc)))
    (output-doc-description doc output)
    (output-doc-examples doc output))
  
  
  (method (output-manual-interface cataloguer doc level path output)
    (define (get-definition doc)
      (get-definition~ cataloguer doc))
    
    (output-anchor doc output)
    (put~ output `(<h4> class: "interface" ,(get-effective-title~ doc)))
    (let ((ascendants (collect get-definition (get-ascendants~ doc))))
      (when (not-null? ascendants)
        (put~ output `(<p>))
        (put~ output "extends")
        (let ((first? #t))
          (for-each (lambda (ascendant-doc)
                      (if first?
                          (set! first? #f)
                        (put~ output ", "))
                      (put~ output `(<a> href: ,(format "#{a}" (get-name~ ascendant-doc)) ,(get-effective-title~ ascendant-doc))))
                    ascendants))
        (put~ output `(<p>))))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output sort?: #t))
  
  
  (method (output-manual-class cataloguer doc level path output)
    (define (get-definition doc)
      (get-definition~ cataloguer doc))
    
    (output-anchor doc output)
    (put~ output `(<h4> class: "class" ,(get-effective-title~ doc)))
    (let ((ascendant (get-ascendant~ doc)))
      (when ascendant
        (let ((ascendant-doc (get-definition ascendant)))
          (when ascendant-doc
            (put~ output `(<p>))
            (put~ output "extends")
            (put~ output `(<a> href: ,(format "#{a}" ascendant) ,(get-effective-title~ ascendant-doc)))
            (put~ output `(<p>))))))
    (let ((interfaces (collect get-definition (get-interfaces~ doc))))
      (when (not-null? interfaces)
        (put~ output `(<p>))
        (put~ output "implements")
        (let ((first? #t))
          (for-each (lambda (interface-doc)
                      (if first?
                          (set! first? #f)
                        (put~ output ", "))
                      (put~ output `(<a> href: ,(format "#{a}" (get-name~ interface-doc)) ,(get-effective-title~ interface-doc))))
                    interfaces))
        (put~ output `(<p>))))
    (output-doc-description doc output)
    (output-manual-doc-children cataloguer doc level path output sort?: #t))
  
  
  (method (output-manual-form cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "form-definition" (<b> ,(get-effective-title~ doc)) " " (<i> ,(either (get-parameters~ doc) ""))))
    (output-doc-description doc output))
  
  
  (method (output-manual-concept cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (output-doc-description doc output))
  
  
  (method (output-manual-syntax cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "syntax" ,(present-text~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-primitive cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (output-doc-description doc output))
  
  
  (method (output-manual-constant cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<p> class: "definition" (<b> ,(get-effective-title~ doc))))
    (output-doc-description doc output))
  
  
  (method (output-manual-slot cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "slot" ,(present-text~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-property cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> "property" ,(present-text~ doc)))
    (output-doc-description doc output))
  
  
  (method (output-manual-method cataloguer doc level path output)
    (output-anchor doc output)
    (put~ output `(<docterm> ,(if (eq? (get-propagation~ doc) 'virtual)
                                  "virtual method"
                                "method")
                    ,(present-text~ doc)))
    (output-doc-description doc output)
    (output-doc-examples doc output))
  
  
  (method (<docterm> node)
    (let ((children (get-children~ node)))
      (let ((term (first children))
            (body (second children)))
        `(<table> width: "100%"
           (<tr>
             (<td> ,body)
             (<td> align: "right" ,term))))))
  
  
  (method (output-doc-description doc output)
    (let ((description (get-description~ doc)))
      (when description
        (bind (tag . paragraphs) (->jml~ (form->node description))
          (put-sequence~ output paragraphs)))))
  
  
  (method (output-doc-examples doc output)
    (let ((examples (get-examples~ doc)))
      (when (not-null? examples)
        (put~ output `(<p>))
        (put~ output `(<p> "Examples"))
        (put~ output `(<node>
                       ,@(map (lambda (example)
                                (bind (tag . rest) (->jml~ (form->node example))
                                  `(<span> ,@rest)))
                              (get-children~ examples)))))))
  
  
  (method (output-manual-doc-children cataloguer doc level path output (sort?: sort? #f) (key: key {}))
    (let* ((sort? (or sort? (and (is? doc Section-Doc) (get-sort?~ doc))))
           (children (effective-manual-doc-children doc))
           (sorted (if sort?
                       (sort nu<? children key: (either key present-doc-title))
                     children)))
      (for-each (lambda (doc rank)
                  (output-manual-doc cataloguer doc (+ level 1) (cons (+ rank 1) path) output))
                sorted
                (naturals 0 (length sorted)))))
  
  
  (method (effective-manual-doc-children doc)
    (let ((fact (new List-Factory)))
      (for-each (lambda (child)
                  (if (is? child Doc-Insert)
                      (let* ((path (get-path~ child))
                             (docs (find-docs path)))
                        (put-sequence~ fact docs))
                    (put~ fact child)))
                (get-children~ doc))
      (get-output~ fact)))
  
  
  (method (find-docs path)
    (let* ((appl (get-application))
           (cataloguer (get-documentation-cataloguer~ appl))
           (docs (new List-Factory)))
      (bind (name . rest) (if (symbol? path) (list path) path)
        (if (eq? name :reference)
            (let ((reference-dir {Directory jazz.website "reference"}))
              (when (exists?~ reference-dir)
                (iterate-directory~ reference-dir
                  (lambda (file)
                    (when (ci=? (get-extension~ file) "jml")
                      (put~ docs (instantiate~ (read-from-file file))))))))
          (let ((catalog (find-catalog~ cataloguer name)))
            (assert catalog)
            (cond ((null? rest)
                   (put~ docs (get-client~ catalog)))
                  ((equal? rest '(*))
                   (let ((parent (get-project~ catalog)))
                     (for-each (lambda (catalog)
                                 (when (eq? (get-parent-project~ (get-project~ catalog)) parent)
                                   (put~ docs (get-client~ catalog))))
                               (get-catalogs~ cataloguer))))
                  (else
                   (unimplemented 'find-docs))))))
      (get-output~ docs)))
  
  
  (method (output-anchor doc output)
    (let ((name (get-name~ doc))
          (anchor (register-anchor doc (get-name~ doc) anchors)))
      (put~ output `(<a> name: ,anchor))
      (when name
        (table-add anchor-names name doc))))
  
  
  (method (register-anchor object name anchors)
    (let ((anchor (if name (->string name) (prog1 (format "SEC{a}" next-section) (increase! next-section)))))
      (table-set! anchors object anchor)
      anchor))
  
  
  ;;;
  ;;;; Summary
  ;;;
  
  
  (method (summary-output title section projects)
    (user-message "Generating Summary...")
    `((<div> style: "margin-top: 22;")
      (<h3> class: "summary" ,title)
      (<div> class: "summary_toc" (<a> href: "#TOC" "Table of Contents"))
      ,@(if (get-property~ section 'index? #t)
            `((<div> class: "summary_index" (<a> href: "#INDEX" "Index")))
          `((<p>)))
      ,@(let ((docs (if (= (length projects) 1) (get-children~ (car projects)) projects)))
          (map (lambda (doc rank)
                 (doc-summary-output doc 1 (list (+ rank 1))))
               docs
               (naturals 0 (length docs))))))
  
  
  (method (doc-summary-output doc level path)
    (let* ((title (present-doc-title doc))
           (text (format "{a}. {a}" (present-toc-path path) title))
           (anchor (format "#{a}" (table-ref anchors doc #f)))
           (children (collect-summary-children doc)))
      `(<div>
         (<div> class: ,(format "summary{a}" level) (<a> href: ,anchor ,text))
         ,@(if (null? children)
               '()
             `((<div>
                 ,@(map (lambda (child rank)
                          (doc-summary-output child (+ level 1) (cons (+ rank 1) path)))
                        children
                        (naturals 0 (length children)))))))))
  
  
  (method (collect-summary-children doc)
    (let ((children (effective-manual-doc-children doc)))
      (collect-if has-project-descendant?
                  (sort string<? children key: present-doc-title))))
  
  
  (method (has-project-descendant? doc)
    (let ((has? #f))
      (letrec ((iter
                (lambda (doc)
                  (typecase doc
                    ((Project-Doc) (set! has? #t))
                    ((Section-Doc) (for-each iter (effective-manual-doc-children doc)))))))
       (iter doc))
      has?))
  
  
  ;;;
  ;;;; ToC
  ;;;
  
  
  (method (toc-output projects)
    (user-message "Generating Table of Contents...")
    `((<a> name: "TOC" (<h3> class: "toc" "Table of Contents"))
      ,@(let ((docs (if (= (length projects) 1) (get-children~ (car projects)) projects)))
          (map (lambda (doc rank)
                 (doc-toc-output doc 1 (list (+ rank 1))))
               docs
               (naturals 0 (length docs))))))
  
  
  (method (doc-toc-output doc level path)
    (let* ((title (present-doc-title doc))
           (text (format "{a}. {a}" (present-toc-path path) title))
           (anchor (format "#{a}" (table-ref anchors doc #f)))
           (children (collect-toc-children doc))
           (rank (car path))
           (toc-prefix (if (and (= rank 1) (<= level 3)) "toc_first" "toc")))
      `(<div>
         (<div> class: ,(format "{a}{a}" toc-prefix level) (<a> href: ,anchor ,text))
         ,@(if (null? children)
               '()
             `((<div>
                 ,@(map (lambda (child rank)
                          (doc-toc-output child (+ level 1) (cons (+ rank 1) path)))
                        children
                        (naturals 0 (length children)))))))))
  
  
  (method (present-doc-title doc)
    (get-effective-title~ doc))
  
  
  (method (present-toc-path path)
    (join (map ->string (reverse path)) "."))
  
  
  (method (collect-toc-children doc)
    (let ((children (effective-manual-doc-children doc)))
      (collect-if (lambda (child)
                    (or (is? child Project-Doc)
                        (is? child Section-Doc)
                        (is? child Package-Doc)
                        (is? child Module-Doc)
                        (is? child Library-Doc)
                        (is? child Category-Doc)))
                  (sort string<? children key: present-doc-title))))
  
  
  ;;;
  ;;;; Index
  ;;;
  
  
  (method (index-output)
    (user-message "Generating Index...")
    (let ((letters (sort nu<? (letters-partition) key: car))
          (letter-anchors (make-table test: eq?))
          (output (new List-Factory)))
      (for-each (lambda (letter)
                  (output-letter letter letter-anchors output))
                letters)
      `((<a> name: "INDEX" (<h3> class: "index" "Index"))
        ,@(index-navigator letters letter-anchors)
        (<table> width: "100%"
          ,@(get-output~ output)))))
  
  
  (method (output-letter letter letter-anchors output)
    (bind (char . infos) letter
      (let ((anchor (register-anchor letter {} letter-anchors)))
        (put~ output `(<tr> (<td> colspan: "2" (<div> class: "index-letter" (<a> name: ,anchor ,(string char)))))))
      (for-each (lambda (info)
                  (bind (doc anchor title) info
                    (let ((anchor (format "#{a}" anchor)))
                      (put~ output `(<tr>
                                     (<td>)
                                     (<td> (<a> href: ,anchor (<code> ,title))))))))
                infos)))
  
  
  (method (letters-partition)
    (partition (gather-anchors) key: (lambda (info) (upcase (first (third info))))))
  
  
  (method (gather-anchors)
    (let ((lst '()))
      (iterate-table anchors
        (lambda (doc anchor)
          (when (get-name~ doc)
            (let ((title (get-effective-title~ doc)))
              (set! lst (cons (list doc anchor title) lst))))))
      (sort nu<? lst key: third)))
  
  
  (method (index-navigator letters letter-anchors)
    (let* ((partition (alphabetic-partition letters))
           (non-alpha (assv-value #f partition '()))
           (alpha (assv-value #t partition '()))
           (output (new List-Factory))
           (process-letter-set
            (lambda (letter-set)
              (for-each (lambda (letter)
                          (let ((char (car letter))
                                (anchor (format "#{a}" (table-ref letter-anchors letter #f))))
                            (put~ output `(<a> class: "letter-navigator" href: ,anchor (<b> ,(string char))))
                            (put~ output "&nbsp;")))
                        letter-set))))
      (when (not-null? non-alpha)
        (process-letter-set non-alpha)
        (put~ output `(<br>)))
      (when (not-null? alpha)
        (process-letter-set alpha))
      (get-output~ output)))
  
  
  (method (alphabetic-partition letters)
    (partition letters key: (lambda (letter)
                              (let ((char (car letter)))
                                (alphabetic? char)))))
  
  
  ;;;
  ;;;; Article
  ;;;
  
  
  (method (output-article article level output)
    (for-each (lambda (node)
                (if (is? node JML-Element)
                    (case (get-tag~ node)
                      ((description) (output-article-description article node level output))
                      ((article) (output-article node (+ level 1) output))
                      (else (error "Ill-formed article")))
                  (error "Ill-formed article")))
              (get-children~ article)))
  
  
  (method (output-article-description article description level output)
    (put~ output
          `(<div>
            ,@(let ((name (get-property~ article 'name)))
                (if (not name)
                    '()
                  `((<a> name: ,(->string name)))))
            ,(let ((title (get-property~ article 'title)))
               (case level
                 ((1) `(<h3> ,title))
                 ((2) `(<h4> class: "section2" ,title))
                 (else `(<h4> class: "section3" ,title))))
            ,@(children->jml~ description))))))
