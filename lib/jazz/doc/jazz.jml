;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; jazz Documentation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(<Product-Doc> name: jazz title: "Jazz Platform"
  (<Section-Doc> name: overview title: "Overview"
    (<description>
      (<p> "Jazz is a programming language based on Scheme. ")
      (<definition> name: scheme title: "Scheme"
        (<p> "Jazz conforms to the R5RS Scheme standard and implements all optional features. For documentation, see "
          (<a> href: "http://www.schemers.org/Documents/Standards/R5RS/HTML/" "R5RS Documentation")))
      (<definition> name: gambit title: "Gambit"
        (<p> "Jazz is built on top of the Gambit system. As such, it has access to every feature of Gambit. For documentation, see "
          (<a> href: "http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html" "Gambit Manual"))))
    (<Section-Doc> name: scheme title: "Scheme"
    (<description>
      "Jazz fully supports every Scheme feature of the underlying Scheme system. "
      "By using Scheme's load primitive, you can load any existing Scheme code. "))
    (<Section-Doc> name: toplevel_syntax title: "Toplevel Syntax"
      (<Form-Doc> name: module parameters: "module-name ..."
        )
      (<Form-Doc> name: library parameters: "library-name ..."
        ))
    
    (<Section-Doc> name: naming title: "Naming Conventions"
      (<description>
        (<definition> name: naming_comments title: "Comments"
          (<node>
            (<span> "; Code comment : put at the end of a line of code to document it.")
            (<span> ";; Definition comment : documents a definition and many lines may be used.")
            (<span> ";;; Section comment : documents a section.")
            (<span> ";;;; Chapter comment : specifies a section title naming and will be gathered in a chapter.")))
        (<p>)
        (<p>)
        (<definition> name: naming_modules title: "Modules & Libraries"
          (<p> "Modules and libraries names are lowercase separated by .")
          (<node>
            (<span> (<code> "jazz.ui"))
            (<span> (<code> "jedi.product"))))
        (<p>)
        (<p>)
        (<definition> name: naming_classes title: "Classes & Interfaces"
          (<p> "Class & Interfaces names are capitalized")
          (<node>
            (<span> (<code> "View"))
            (<span> (<code> "Java-Text"))))
        (<p>)
        (<p>)
        (<definition> name: naming_methods title: "Methods"
          (<p> "Methods are in lowercase separated by -")
          (<node>
            (<span> (<code> "get-application"))))
        (<p>)
        (<p>)
        (<definition> name: naming_predicates title: "Predicates"
          (<p> "Predicates end with ?")
          (<node>
            (<span> (<code> "eq?"))
            (<span> (<code> "string?"))))
        (<p>)
        (<p>)
        (<definition> name: naming_mutators title: "Mutators"
          (<p> "Destructive functions end with !")
          (<node>
            (<span> (<code> "set-cdr!"))
            (<span> (<code> "append!"))))
        (<p>)
        (<p>)
        (<definition> name: naming_convertors title: "Convertors"
          (<p> "Type conversion functions have -> in their name")
          (<node>
            (<span> (<code> "symbol->string"))
            (<span> (<code> "symbol->keyword")))))))
  (<Section-Doc> name: lexical title: "Lexical Syntax"
      (<description>
        (<definition> name: identifiers title: "Identifiers"
          (<p> "Identifiers in Jazz are case sensitive. A common usage of this is to have a class named X and a variable containing an instance of X named x.")
          (<p>)
          (<p> "The following characters are considered alphabetic and can thus be used in identifiers:")
          (<p> "! $ % & * + - . / : < = > ? ^ _ ~"))
        (<p>)
        (<p>)
        (<definition> name: whitespace title: "Whitespace"
          (<p> "Spaces, tabs, carriage returns and line feeds are considered whitespace and can be freely inserted in Jazz code without changing the meaning of the code."))
        (<p>)
        (<p>)
        (<definition> name: comments title: "Comments"
          (<p> "Jazz offers two types of comments:")
          (<node>
            (<span> "; starts a line based comment and")
            (<span> "@name starts an sexpr based comment where name can be any symbol. "
              "It is completely ignored and can be used for documentation purposes.")))))
  (<Section-Doc> name: functional title: "Functional Programming"
    (<description>
        (<definition> title: "Variable value"
          (<p> (<code> "x")))
        (<p>)
        (<definition> title: "Function invocation"
          (<p> (<code> "(f x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "x")
          (<code> "(f 2 3)")))
    (<Section-Doc> name: functional_syntax title: "Functional Syntax"
      (<Form-Doc> name: definition parameters: "name value"
        (<description>
          (<p> "A definition associates name to value inside the defining unit. A definition is as field and as such is stored in the class and doesn't take any space in instances. At class instantiation, value is evaluated in an empty lexical environment and in an empty object environment."))))
    (<Section-Doc> name: functions title: "Functions"
      (<description>
        (<p> "In Jazz, functions are first order objects and can be freely manipulated as any other objects. "
          "They can be passed as parameters, stored in variables, ..."
          "Anyone who says functions are not object-oriented is just showing they have'nt really went far enough in their understanding of the problem!")
        (<p>)
        (<definition> name: function_parameters title: "Parameters"
          (<p> "On top of the standard positional parameter passing scheme, Jazz offers the following:")
          (<node>
            (<span> "Variable number of parameters")
            (<span> "Optional parameters")
            (<span> "Keyword parameters")))))
    (<Section-Doc> name: syntax_forms title: "Syntax"
    (<Syntax-Doc> name: bind parameters: "variables-tree values-tree expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-optionals parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-keywords parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: receive parameters: "(variable ...) values expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: quote parameters: "expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: if parameters: "test yes-expr no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: when parameters: "test yes-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unless parameters: "test no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: while parameters: "test expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: begin parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: prog1 parameters: "result-expr1 expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: loop parameters: "..."
      (<description>
        (<code> "for")
        (<code> "in")
        (<code> "in-properties")
        (<code> "iterate")
        (<code> "from")
        (<code> "repeat")
        (<code> "do")
        (<code> "sum")
        (<code> "collect")))
    (<Syntax-Doc> name: tie
      (<description>
        (<p>)))
    (<Syntax-Doc> name: cond parameters: "(test expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: case parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: ecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: typecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: set! parameters: "variable expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: increase! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: decrease! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: let parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: let* parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: letrec parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: catch parameters: "name expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unwind-protect parameters: "protected-expr protection-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: lambda parameters: "parameters-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: function parameters: "parameters-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: and parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if and only if all expr... are true. Note that and will stop as soon as it encounters a false value."))
      (<examples>
        (<example> "(and true (= 2 (+ 1 1))) returns true.")
        (<example> "(and (symbol-bound? 'not-a-bound-variable) not-a-bound-variable) will not signal an error because the first test will fail.")))
    (<Syntax-Doc> name: or parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if one of the expr... is true. Note that or will stop as soon as it encounters a true value."))
      (<examples>
        (<example>
          (<p> "One simple application of the fact that or stops as soon as it encounters a true value is in very clean code for managing simple lazy structures.")
          (<p>)
          (<p> "(define a-big-structure-only-on-demand nil)")
          (<p> "(define (get-structure)")
          (<p> "  (or a-big-structure-only-on-demand")
          (<p> "      (set! a-big-structure-only-on-demand (new-structure))))"))))
    (<Syntax-Doc> name: essay parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: either parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert parameters: "asserted-expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert-type parameters: "asserted-type"
      (<description>
        (<p>)))))
  (<Section-Doc> name: object-oriented title: "Object-Oriented Programming"
    (<Section-Doc> name: object_oriented_syntax title: "Object-Oriented Syntax"
      (<Form-Doc> name: class parameters: "extends implements uses ..."
        (<description>
          (<p> "Jazz uses a single inheritance model where a class can extend only one superclass. "
            "A class can implement any number of interfaces.")))
      (<Form-Doc> name: interface parameters: "extends uses ..."
        (<description>
          (<p> "An interface defines a new type but cannot contain code.")))
      (<Form-Doc> name: method parameters: "{modifiers} (name . parameters) {return-type} . body"
        (<description>
          (<p> "A method is where code resides.")))
      (<Form-Doc> name: slot parameters: "name <initialize> <initial-value>"
        (<description>
          (<p> "A slot is a field that defines the structure of the instances of a class.")))
      (<Form-Doc> name: property parameters: "name <initialize> <initial-value> <getter> <getter-name> <setter> <setter-name>"
        (<description>
          (<p> "A property is a slot that can specify a getter and a setter."))))
    (<Section-Doc> name: objects title: "Objects"
      (<description>
        (<p> "Jazz offers an object-oriented layer with :")
        (<p>)
        (<definition> title: "Method invocation"
          (<p> (<xmp> "(f~ obj x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "(get-size~ window)")
          (<code> "(invalidate-view~ (get-parent~ view))"))
        (<p>)
        (<node>
          (<span> "Classes with single inheritance and multiple interfaces implemented")
          (<span> "Metaclasses")
          (<span> "Generic multi-dispatch methods 'a la' CommonLisp")
          (<span> "Single-dispatch 'a la' Java")))
      (<Section-Doc> title: "Literals"
        (<description>
          (<definition> name: literals title: "Literals"
            (<p> "Jazz supports a powerfull concept where any class can define it's own literal constants using the following syntax: {class-name ...}. "
              "This integrates classes fully with the reader and printer.")
            (<p> "Examples:")
            (<node>
              (<code> "{Point 2 3}")
              (<code> "{Dimension 100 100}")
              (<code> "{Color name: Red}")
              (<code> "{Font name: Code}"))))))
    (<Section-Doc> title: "Classes"
    (<Class-Doc> name: Object
      (<description>
        (<p> "The base class of every other class."))
      (<Method-Doc> name: initialize parameters: "object ...")
      (<Method-Doc> name: destroy parameters: "")
      (<Method-Doc> name: close parameters: "")
      (<Method-Doc> name: print parameters: "printer detail"))))
  (<Section-Doc> name: component title: "Component Programming"
    (<description>
        (<p> "One of the biggest strength of components is the full integration of the programming metaphor with the visual design metaphor they enable. "
          "By seamlessly intermixing programming code and designer data, components brings all the power of programming tools to the design part.")))
  (<Section-Doc> name: types title: "Type Annotations"
    (<description>
      (<p> "Jazz is a dynamically typed language. Types are associated with objects as opposed to statically typed languages where types are associated with variables. With a dynamically typed language, type information is always available at runtime contrary to statically typed languages where only the compiler has access to type information")
      (<p>)
      (<p> "Jazz offer optional type declarations.")
      (<p>)
      (<p> "Types are denoted by :")
      (<xmp> "<primitive> (ex: <int> <bool>)")
      (<xmp> "<class> (ex: <View> <Window>)")
      (<p> "denote the type of all objects of type class, the null not included")
      (<xmp> "<class+> (ex: <Point+> <Rect+>)")
      (<p> "denote the type of all objects of type class, the null included")
      (<p>)
      (<p> "Using a &lt;class&gt; type specifier instead of the more generic &lt;class+&gt; specifier will enable the compiler to enforce non null.")))
  (<Section-Doc> name: lists title: "Lists"
      (<description>
        (<p> "Lists are the most flexible data structure available in Jazz. They can grow to accommodate any number of elements and this very efficiently. As they are sequences, they are supported by a large number of manipulation functions")))
    (<Section-Doc> name: symbols title: "Symbols"
      (<description>
        (<p> "Jazz is symbolic language where symbols are used extensively. Symbols can be used as a very efficient higher level abstraction replacement for integer enumerations")))
  (<Section-Doc> name: exceptions title: "Exceptions")
  (<Section-Doc> name: input/output title: "Input / Output"
    (<Section-Doc> name: formatted_output title: "Formatted Output"
      (<description>
        (<p> "Implements formatted output.")
        (<p>)
        (<definition> name: format_directives title: "Directives"
          (<format-directives>
            (<directive> "ASCII" "a" "human readable")
            (<directive> "SEXPR" "s" "reader readable")
            (<directive> "TEXT" "t" "textual representation")
            (<directive> "PRINT" "p" "ascii or sexpr or text")
            (<directive> "REAL" "r" "real number")
            (<directive> "CHAR" "h" "character")
            (<directive> "LIST" "l" "remove parenthesis")
            (<directive> "PROPERTIES" "k" "properties list")
            (<directive> "UNSIGNED" "u" "unsigned integer")
            (<directive> "HEXADECIMAL" "x" "hexadecimal integer")
            (<directive> "COLUMN" "c" "column")
            (<directive> "TAB" "&" "insert tab character")
            (<directive> "NEW_LINE" "%" "insert new line")
            (<directive> "LOCALIZE" "z" "localized string")
            (<directive> "FORMATTED" "f" "formatted control")))
        (<p>)
        (<definition> name: format_parameters title: "Parameters"
          (<p> "{x :a value :b value ?}")
          (<p> ":v -> takes the info from the parameters")
          (<p>)
          (<p> "Examples:")
          (<node>
            (<code> "(format :string \"{_ 5}\")")
            (<code> "(format :string \"{a :width :v :justify right}\" bonjour 20)"))
          (<p>)
          (<p> "Parameters can be optional and can be keyword based.")
          (<node>
            (<span> "list?")
            (<span> "width")
            (<span> "justify -> :left :right")
            (<span> "padding")
            (<span> "separator")
            (<span> "last-separator")
            (<span> "precision")
            (<span> "properties")
            (<span> "empty-value")
            (<span> "detail")))))
    (<Section-Doc> name: alias title: "Alias"
      (<description>
        "Aliases are symbolic names for directories. "
        "They are similar to CommonLisp's logical pathnames. "
        (<p>)
        "The following aliases are predefined:"
        (<node>
          "Home"
          "User"
          "Install"
          "Jazz"))))
  (<Section-Doc> name: regular-expressions title: "Regular Expressions")
  (<Section-Doc> name: date/time title: "Date / Time")
  (<Section-Doc> name: markup title: "Markup Language")
  (<Section-Doc> name: database title: "Database")
  (<Section-Doc> name: profiling title: "Profiling")
  (<Section-Doc> name: remoting title: "Remoting")
  (<Section-Doc> name: system title: "System")
  (<Section-Doc> name: user-interface title: "User Interface"
    (<Section-Doc> title: "Activation"
      (<description>
        (<node>
          "focus-gain        : sent to a view that gains focus"
          "focus-lose        : sent to a view that loses focus"
          "host-activate     : sent to guest when host gains focus"
          "host-deactivate   : sent to guest when host loses focus"
          "client-activate   : sent to each tool when a document activates"
          "client-deactivate : sent to each tool when last document closes"
          "stage-activate    : sent to stage when last document closes"
          "stage-deactivate  : sent to stage when a first document activates"))))
  (<Section-Doc> name: c-interface title: "C Interface"
    (<Section-Doc> name: c-interface.syntax title: "Syntax"
      (<Form-Doc> name: c-constant parameters: "name value"
        (<description>
          (<p> "A c-constant cannot be modified. Note that currently, a constant definition is simply a definition.")
          ))
      (<Form-Doc> name: c-enumeration parameters: "enumeration-name (name1 value1) (name2 value2) ..."
        (<description>
          (<p> "A c-enumeration definition. "
            "This enumeration will create a definition enumeration-name containing an Enumeration object that can be queried at runtime and create constant definitions name1 : value1, name2 : value2, ...")
          ))
      (<Form-Doc> name: c-structure parameters: "structure-name (type1 field1 <n1>) (type2 field2 <n2>) ..."
        (<description>
          (<p> "A c-structure is a template that can be used to create records containing primitive types. Here, type is any primitive type and field is a symbol that can be used to access this field is records of type structure-name. If the optional n is specified, then an array of n elements of type will be inserted.")
          ))
      (<Form-Doc> name: c-external parameters: "module-name return-type (name param1 param2 ...) <entry-name>"
        (<description>
          (<p> "A c-external entry point into a Windows module, i.e. a dynamic-link library or an executable.")
          ))))
  @wait
  (<Section-Doc> title: "Modules"
      (<Package-Doc> name: jazz title: "jazz"
        (<Section-Doc> title: "Boolean"
          (<Method-Doc> name: eq? parameters: "x y"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "x")
                " is physicaly equal to "
                (<parameter> "y")
                ". In other words, if both memory pointers are the same.")))
          (<Method-Doc> name: neq? parameters: "x y"
            (<description>
              (<p> "The inverse test of eq?.")))
          (<Method-Doc> name: eqv? parameters: "x y"
            (<description>
              (<p> "eqv? will succed if the two objects are eq? or if they can be simply compared without going into their structures. For example, (eq? 2.3 2.3) migth return false whereas (eqv? 2.3 2.3) will always return true.")))
          (<Method-Doc> name: equal? parameters: "x y"
            (<description>
              (<p> "The most general equivalence predicate of all.")
              (<p> "equal? will succed if the two objects are eqv? but will also try to determine if the two objets structures are identical. For example, (eq? (list 1 2 3) (list 1 2 3)) returns false but (equal? (list 1 2 3) (list 1 2 3)) returns true.")))
          (<Method-Doc> name: not parameters: "obj"
            (<description>
              (<p>
                "Returns the logical negation of "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: boolean? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is of "
                (<code> "Boolean")
                " type."))
            (<examples>
              (<example>
                (<code> "(boolean? true)")
                " returns true.")
              (<example>
                (<code> "(boolean? false)")
                " returns true.")
              (<example>
                (<code> "(boolean? nil)")
                " return false.")))
          (<Method-Doc> name: xor parameters: "x y")
          (<Method-Doc> name: = parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: /= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: < parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: <= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: > parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: >= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci/= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci< parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci<= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci> parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci>= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: boolean parameters: "obj")
          (<Method-Doc> name: boolean->integer parameters: "bool")
          (<Method-Doc> name: integer->boolean parameters: "z"))
        (<Section-Doc> title: "Char"
          (<Method-Doc> name: char? parameters: "obj")
          (<Method-Doc> name: jazz-constituent? parameters: "obj")
          (<Method-Doc> name: cpp/java-constituent? parameters: "obj")
          (<Method-Doc> name: alphabetic? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is alphabetic. An object is alphabetic if it is an alphabetic character or a sequence composed only of alphabetic parts.")))
          (<Method-Doc> name: numeric? parameters: "obj"
            (<description>
              (<p> "Tests if obj is numeric. An object is numeric if it is a numeric character or a sequence composed only of numeric parts.")))
          (<Method-Doc> name: alphanumeric? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: whitespace? parameters: "obj"
            (<description>
              (<p> "Tests if obj is whitespace. An object is whitespace if it is a whitespace character or a sequence composed only of whitespace parts.")))
          (<Method-Doc> name: upper-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is upper-case. An object is upper-case if it is an upper-case character or a sequence composed only of upper-case parts.")))
          (<Method-Doc> name: lower-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is lower-case. An object is lower-case if it is a lower-case character or a sequence composed only of lower-case parts.")))
          (<Method-Doc> name: upcase parameters: "obj"
            (<description>
              (<p> "Converts obj to upper-case. If obj is a sequence, every part of obj with be converted to upper-case.")))
          (<Method-Doc> name: downcase parameters: "obj"
            (<description>
              (<p> "Converts obj to lower-case. If obj is a sequence, every part of obj with be converted to lower-case.")))
          (<Method-Doc> name: capitalize parameters: "obj"
            (<description>
              (<p> "Converts obj to capitalized form where every word starts with a capital letter and the rest is in lower-case. If obj is a sequence, every part of obj with be converted to capitalized form."))))
        (<Section-Doc> title: "Class"
          (<description>
            (<p> "The Class type is the supertype of every class. It enables a class to be inspected and manipulated as any other object."))
          (<Method-Doc> name: class? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: class-members parameters: "class"
            (<description>
              (<p> "Returns a list of all members of class.")))
          (<Method-Doc> name: class-fields parameters: "class"
            (<description>
              (<p> "Returns a list of all fields of class.")))
          (<Method-Doc> name: class-slots parameters: "class"
            (<description>
              (<p> "Returns a list of all slots of class."))))
        (<Section-Doc> title: "Closure"
          (<Method-Doc> name: closure? parameters: "obj"))
        (<Section-Doc> title: "Collector"
          (<Method-Doc> name: gc parameters: ""))
        (<Section-Doc> title: "Control"
          (<Method-Doc> name: throw parameters: "name")
          (<Method-Doc> name: exit parameters: ""))
        (<Section-Doc> title: "Debugger"
          (<Method-Doc> name: signal parameters: "exception")
          (<Method-Doc> name: error parameters: "format-string obj ..."))
        (<Section-Doc> title: "Enumeration"
          (<Method-Doc> name: enumeration? parameters: "obj"))
        (<Section-Doc> title: "Eval"
          (<Method-Doc> name: eval parameters: "expr")
          (<Method-Doc> name: identity parameters: "obj"))
        (<Section-Doc> title: "Format"
          (<Method-Doc> name: format parameters: "format-string obj ..."))
        (<Section-Doc> title: "Function"
          (<Method-Doc> name: function? parameters: "obj"))
        (<Section-Doc> title: "Hashtable"
          (<Method-Doc> name: hash-ref parameters: "hashtable key" package-name: Language
            (<description>
              (<p>
                "Gets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                ".")))
          (<Method-Doc> name: hash-set! parameters: "hashtable key value" package-name: Language
            (<description>
              (<p>
                "Sets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                " to "
                (<parameter> "value")
                ".")))
          (<Method-Doc> name: hash-clear parameters: "hashtable key")
          (<Method-Doc> name: empty-hashtable parameters: "hashtable")
          (<Method-Doc> name: load-hashtable parameters: "hashtable file")
          (<Method-Doc> name: hash-remove! parameters: "hashtable key value")
          (<Method-Doc> name: for-each-hash parameters: "proc hashtable"))
        (<Section-Doc> title: "Integer"
          (<Method-Doc> name: integer? parameters: "obj")
          (<Method-Doc> name: even? parameters: "z")
          (<Method-Doc> name: odd? parameters: "z")
          (<Method-Doc> name: quotient parameters: "z1 z2")
          (<Method-Doc> name: modulo parameters: "z1 z2")
          (<Method-Doc> name: separate parameters: "z1 z2")
          (<Method-Doc> name: randomize parameters: "")
          (<Method-Doc> name: random parameters: "n")
          (<Method-Doc> name: bit-not parameters: "n")
          (<Method-Doc> name: bit-and parameters: "n ...")
          (<Method-Doc> name: bit-or parameters: "n ...")
          (<Method-Doc> name: bit-xor parameters: "n ...")
          (<Method-Doc> name: bit-set parameters: "n1 n2 n3")
          (<Method-Doc> name: bit-set? parameters: "n1 n2")
          (<Method-Doc> name: shift-left parameters: "n1 n2")
          (<Method-Doc> name: shift-right parameters: "n1 n2"))
        (<Section-Doc> title: "Interface"
          (<Method-Doc> name: interface? parameters: "obj"))
        (<Section-Doc> title: "List"
          (<Method-Doc> name: car parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: set-car! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the car field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: set-cdr! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the cdr field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: cons parameters: "x y"
            (<description>
              (<p>
                "Returns a newly allocated pair whose car is "
                (<parameter> "x")
                " and whose cdr is "
                (<parameter> "y")
                ".")))
          (<Method-Doc> name: reverse parameters: "seq"
            (<description>
              (<p> "Reverses a sequence.")))
          (<Method-Doc> name: list? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a list, false otherwise."))
            (<examples>
              (<example> "(list? nil) -> true")
              (<example> "(list? '(a b c)) -> true")
              (<example> "(list? 2) -> false")))
          (<Method-Doc> name: nil? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is the empty list, false otherwise.")))
          (<Method-Doc> name: not-nil?)
          (<Method-Doc> name: pair? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a pair and otherwise returns false."))
            (<examples>
              (<example> "(pair? 2) -> false")
              (<example> "(pair? nil) -> false")
              (<example> "(pair? (cons 1 2)) -> true")
              (<example> "(pair? '(a b c)) -> true")))
          (<Method-Doc> name: atom? parameters: "obj")
          (<Method-Doc> name: caar parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cadr parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdar parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cddr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: list parameters: "obj ..."
            (<description>
              (<p> "Returns a list constructed of all its arguments.")))
          (<Method-Doc> name: memq? parameters: "obj list")
          (<Method-Doc> name: memv? parameters: "obj list")
          (<Method-Doc> name: member? parameters: "obj list &key key test")
          (<Method-Doc> name: assq parameters: "obj list")
          (<Method-Doc> name: assv parameters: "obj list")
          (<Method-Doc> name: assoc parameters: "obj list &key key test")
          (<Method-Doc> name: rassoc parameters: "obj list &key key test")
          (<Method-Doc> name: reverse! parameters: "list")
          (<Method-Doc> name: remove! parameters: "obj list")
          (<Method-Doc> name: getprop parameters: "plist key")
          (<Method-Doc> name: getf parameters: "plist key")
          (<Method-Doc> name: setf parameters: "plist key value")
          (<Method-Doc> name: for-each-pair parameters: "proc list")
          (<Method-Doc> name: for-each-property parameters: "proc list"))
        (<Section-Doc> title: "Manifest"
          (<Method-Doc> name: load parameters: "unit-name")
          (<Method-Doc> name: unit-loaded? parameters: "unit-name")
          (<Method-Doc> name: in-manifest? parameters: "unit-name"))
        (<Section-Doc> title: "Map"
          (<Method-Doc> name: map-ref parameters: "map key")
          (<Method-Doc> name: map-set! parameters: "map key value")
          (<Method-Doc> name: map-clear parameters: "map key")
          (<Method-Doc> name: empty-map parameters: "map")
          (<Method-Doc> name: load-map parameters: "map file")
          (<Method-Doc> name: for-each-map parameters: "proc map"))
        (<Section-Doc> title: "Metaclass"
          (<Method-Doc> name: metaclass? parameters: "obj")
          (<Method-Doc> name: metaclass-instance parameters: "metaclass"))
        (<Section-Doc> title: "Number"
          (<Method-Doc> name: + parameters: "obj ...")
          (<Method-Doc> name: - parameters: "obj1 obj2 ...")
          (<Method-Doc> name: * parameters: "obj ...")
          (<Method-Doc> name: number? parameters: "obj")
          (<Method-Doc> name: zero? parameters: "obj")
          (<Method-Doc> name: positive? parameters: "obj")
          (<Method-Doc> name: negative? parameters: "obj")
          (<Method-Doc> name: / parameters: "obj1 obj2 ...")
          (<Method-Doc> name: relate parameters: "x y")
          (<Method-Doc> name: sign parameters: "z")
          (<Method-Doc> name: floor parameters: "r")
          (<Method-Doc> name: round parameters: "r")
          (<Method-Doc> name: ceil parameters: "r")
          (<Method-Doc> name: abs parameters: "z")
          (<Method-Doc> name: min parameters: "obj ...")
          (<Method-Doc> name: max parameters: "obj ...")
          (<Method-Doc> name: between? parameters: "n lower upper")
          (<Method-Doc> name: between parameters: "lower n upper")
          (<Method-Doc> name: in-interval? parameters: "n lower upper")
          (<Method-Doc> name: norm parameters: "x")
          (<Method-Doc> name: near? parameters: "x y distance"))
        (<Section-Doc> title: "Object"
          (<Method-Doc> name: object? parameters: "obj")
          (<Method-Doc> name: copy parameters: "obj"))
        (<Section-Doc> title: "Package"
          (<Method-Doc> name: package? parameters: "obj"))
        (<Section-Doc> title: "Printer"
          (<Method-Doc> name: display parameters: "obj &optional printer")
          (<Method-Doc> name: write parameters: "obj &optional printer")
          (<Method-Doc> name: describe parameters: "obj &optional printer")
          (<Method-Doc> name: new-line parameters: "&optional printer")
          (<Method-Doc> name: print-unreadable parameters: "obj printer proc"))
        (<Section-Doc> title: "Procedure"
          (<Method-Doc> name: procedure? parameters: "obj"))
        (<Section-Doc> title: "Reader"
          (<Method-Doc> name: read parameters: "&optional reader")
          (<Method-Doc> name: get-char parameters: "&optional reader")
          (<Method-Doc> name: unget-char parameters: "char &optional reader")
          (<Method-Doc> name: peek-char parameters: "&optional reader")
          (<Method-Doc> name: end-of-stream? parameters: "&optional reader"))
        (<Section-Doc> title: "Real"
          (<Method-Doc> name: real? parameters: "obj")
          (<Method-Doc> name: sin parameters: "r")
          (<Method-Doc> name: cos parameters: "r")
          (<Method-Doc> name: tan parameters: "r")
          (<Method-Doc> name: asin parameters: "r")
          (<Method-Doc> name: acos parameters: "r")
          (<Method-Doc> name: atan parameters: "r1 r2")
          (<Method-Doc> name: sqrt parameters: "r")
          (<Method-Doc> name: exp parameters: "r")
          (<Method-Doc> name: log parameters: "r")
          (<Method-Doc> name: expt parameters: "r1 r2")
          (<Method-Doc> name: percentage parameters: "part total")
          (<Method-Doc> name: percent parameters: "percent n"))
        (<Section-Doc> title: "Sequence"
          (<description>
            "Sequences are an abstract data type representing objects capable of storing sequences of objects. Some examples of sequences are lists, strings and vectors. The Jazz language possesses a important number of sequence manipulation functions")
          (<Method-Doc> name: sequence? parameters: "obj"
            (<description>
              (<p> "Tests if obj is of Sequence type.")))
          (<Method-Doc> name: length parameters: "sequence"
            (<description>
              (<p>
                "Returns the number of elements in "
                (<parameter> "seq")
                ".")))
          (<Method-Doc> name: element parameters: "sequence n"
            (<description>
              (<p> "Returns the nth element of sequence.")))
          (<Method-Doc> name: set-element! parameters: "sequence n value"
            (<description>
              (<p> "Destructively sets the nth element of sequence to value.")))
          (<Method-Doc> name: empty? parameters: "sequence")
          (<Method-Doc> name: tail parameters: "sequence n"
            (<description>
              (<p> "Returns the elements of sequence that range from n to the end. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: last parameters: "sequence"
            (<description>
              (<p> "Returns the last element of sequence.")))
          (<Method-Doc> name: last-tail parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made-up of only the last element of sequence. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: butlast parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made up of every element of sequence except the last.")))
          (<Method-Doc> name: subseq parameters: "sequence start &optional end"
            (<description>
              (<p> "Returns a sequence made up of the elements of sequence that range from start to end exclusively. If end is omited, the elements are taken till the end of sequence.")))
          (<Method-Doc> name: subseq! parameters: "sequence start &optional end")
          (<Method-Doc> name: sort parameters: "predicate sequence &key key test")
          (<Method-Doc> name: for-each-reversed parameters: "sequence")
          (<Method-Doc> name: append parameters: "sequence"
            (<description>
              (<p>
                "Returns a sequence composed of all the elements of "
                (<parameter> "seq")
                "."))
            (<examples>
              (<example> "(append) -> nil")
              (<example> "(append '(a b c) nil '(1 2) '(1 2 3)) -> (a b c 1 2 1 2 3)")
              (<example> "(append \\\"Hello\\\" \\\" \\\" \\\"there\\\") -> \\\"Hello there\\\"")
              (<example> "(append 2 3) -> <error>\"")))
          (<Method-Doc> name: append! parameters: "sequence ...")
          (<Method-Doc> name: insert! parameters: "obj sequence pos")
          (<Method-Doc> name: insert-sequence! parameters: "sequence inserted pos")
          (<Method-Doc> name: replace-subseq! parameters: "sequence start end replacement")
          (<Method-Doc> name: element-reversed parameters: "sequence n")
          (<Method-Doc> name: for-each parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2")))
          (<Method-Doc> name: map parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2 and collects the results in a list that it returns.")))
          (<Method-Doc> name: map-to parameters: "type proc sequence")
          (<Method-Doc> name: gather parameters: "sequence")
          (<Method-Doc> name: collect parameters: "proc sequence")
          (<Method-Doc> name: collect-if parameters: "predicate sequence")
          (<Method-Doc> name: collect-type parameters: "type sequence")
          (<Method-Doc> name: count parameters: "obj sequence"
            (<description>
              (<p> "Finds the number of occurrences of obj in sequence.")))
          (<Method-Doc> name: count-if parameters: "predicate sequence")
          (<Method-Doc> name: count-type parameters: "type sequence")
          (<Method-Doc> name: find parameters: "object sequence")
          (<Method-Doc> name: find-if parameters: "predicate sequence")
          (<Method-Doc> name: skip parameters: "predicate sequence")
          (<Method-Doc> name: some? parameters: "predicate sequence")
          (<Method-Doc> name: every? parameters: "predicate sequence")
          (<Method-Doc> name: union parameters: "sequence ...")
          (<Method-Doc> name: intersection parameters: "sequence ...")
          (<Method-Doc> name: difference parameters: "sequence1 sequence2"
            (<description>
              (<p> "Returns the set difference sequence1 \\ sequence2.")))
          (<Method-Doc> name: remove parameters: "target sequence")
          (<Method-Doc> name: remove-trailing parameters: "target list")
          (<Method-Doc> name: remove-duplicates parameters: "sequence"
            (<description>
              (<p> "Returns a sequence that has exactly the same elements as sequence and in the same order but with no duplicates.")))
          (<Method-Doc> name: remove-nils parameters: "sequence")
          (<Method-Doc> name: mismatch parameters: "target sequence")
          (<Method-Doc> name: prefix parameters: "sequences")
          (<Method-Doc> name: prefix? parameters: "target sequence")
          (<Method-Doc> name: search parameters: "target sequence")
          (<Method-Doc> name: split parameters: "sequence separator")
          (<Method-Doc> name: split-justified parameters: "sequence width separators")
          (<Method-Doc> name: join parameters: "sequences separator")
          (<Method-Doc> name: substitute parameters: "old new sequence")
          (<Method-Doc> name: substitute-alist parameters: "replacements sequence")
          (<Method-Doc> name: fill! parameters: "sequence object")
          (<Method-Doc> name: replace! parameters: "sequence replacement")
          (<Method-Doc> name: insert-ordered! parameters: "object sequence")
          (<Method-Doc> name: merge-ordered parameters: "proc x y")
          (<Method-Doc> name: random-element parameters: "sequence")
          (<Method-Doc> name: partition parameters: "sequence &key key test")
          (<Method-Doc> name: starts-with? parameters: "string target")
          (<Method-Doc> name: ends-with? parameters: "string target")
          (<Method-Doc> name: first parameters: "sequence")
          (<Method-Doc> name: second parameters: "sequence")
          (<Method-Doc> name: third parameters: "sequence")
          (<Method-Doc> name: fourth parameters: "sequence")
          (<Method-Doc> name: fifth parameters: "sequence")
          (<Method-Doc> name: sixth parameters: "sequence")
          (<Method-Doc> name: seventh parameters: "sequence")
          (<Method-Doc> name: eighth parameters: "sequence")
          (<Method-Doc> name: ninth parameters: "sequence")
          (<Method-Doc> name: tenth parameters: "sequence")
          (<Method-Doc> name: set-first! parameters: "sequence object")
          (<Method-Doc> name: set-second! parameters: "sequence object")
          (<Method-Doc> name: set-third! parameters: "sequence object")
          (<Method-Doc> name: set-fourth! parameters: "sequence object")
          (<Method-Doc> name: set-fifth! parameters: "sequence object")
          (<Method-Doc> name: set-sixth! parameters: "sequence object")
          (<Method-Doc> name: set-seventh! parameters: "sequence object")
          (<Method-Doc> name: set-eighth! parameters: "sequence object")
          (<Method-Doc> name: set-ninth! parameters: "sequence object")
          (<Method-Doc> name: set-tenth! parameters: "sequence object"))
        (<Section-Doc> title: "String"
          (<Method-Doc> name: string? parameters: "object")
          (<Method-Doc> name: empty-string? parameters: "object"))
        (<Section-Doc> title: "Symbol"
          (<Method-Doc> name: symbol? parameters: "object")
          (<Method-Doc> name: keyword? parameters: "object")
          (<Method-Doc> name: symbol->keyword parameters: "symbol")
          (<Method-Doc> name: keyword->symbol parameters: "keyword")
          (<Method-Doc> name: string->symbol parameters: "string")
          (<Method-Doc> name: symbol->string parameters: "symbol")
          (<Method-Doc> name: find-symbol parameters: "string")
          (<Method-Doc> name: generate-symbol parameters: "&optional prefix")
          (<Method-Doc> name: symbol-bound? parameters: "symbol")
          (<Method-Doc> name: symbol-unbound? parameters: "symbol"))
        (<Section-Doc> title: "Thread"
          (<Method-Doc> name: primordial-thread parameters: "")
          (<Method-Doc> name: current-thread parameters: ""))
        (<Section-Doc> title: "Time"
          (<Method-Doc> name: clock parameters: ""))
        (<Section-Doc> title: "Type"
          (<Method-Doc> name: type? parameters: "object")
          (<Method-Doc> name: new parameters: "class object ...")
          (<Method-Doc> name: new-in parameters: "context class object ...")
          (<Method-Doc> name: coerce parameters: "object type")
          (<Method-Doc> name: class-of parameters: "object")
          (<Method-Doc> name: is? parameters: "object type")
          (<Method-Doc> name: is-not? parameters: "object type")
          (<Method-Doc> name: typed? parameters: "object type-name")
          (<Method-Doc> name: subtype? parameters: "class type")
          (<Method-Doc> name: subtyped? parameters: "class type-name")
          (<Method-Doc> name: type-name parameters: "type")
          (<Method-Doc> name: type-ascendant parameters: "type")
          (<Method-Doc> name: type-descendants parameters: "type")
          (<Method-Doc> name: type-ancestors parameters: "type"))
        (<Section-Doc> title: "Unit"
          (<Method-Doc> name: unit? parameters: "object")
          (<Method-Doc> name: all-units parameters: ""))
        (<Section-Doc> title: "Values"
          (<Method-Doc> name: values parameters: "object ..."))
        (<Section-Doc> title: "Vector"
          (<Method-Doc> name: vector? parameters: "object"))))
  )
