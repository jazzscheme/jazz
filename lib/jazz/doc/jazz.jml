;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; jazz Documentation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(<Product-Doc> name: jazz title: "Jazz Platform"
  (<Section-Doc> name: overview title: "Overview"
    (<description>
      (<p> "Jazz is a programming language based on Scheme. ")
      (<definition> name: scheme title: "Scheme"
        (<p> "Jazz conforms to the R5RS Scheme standard and implements all optional features. For documentation, see "
          (<a> href: "http://www.schemers.org/Documents/Standards/R5RS/HTML/" "R5RS Documentation")))
      (<definition> name: gambit title: "Gambit"
        (<p> "Jazz is built on top of the Gambit system. As such, it has access to every feature of Gambit. For documentation, see "
          (<a> href: "http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html" "Gambit Manual"))))
    (<Section-Doc> name: scheme title: "Scheme"
    (<description>
      "Jazz fully supports every Scheme feature of the underlying Scheme system. "
      "By using Scheme's load primitive, you can load any existing Scheme code. "))
    (<Section-Doc> name: toplevel_syntax title: "Toplevel Syntax"
      (<Form-Doc> name: module parameters: "module-name ..."
        )
      (<Form-Doc> name: library parameters: "library-name ..."
        ))
    
    (<Section-Doc> name: naming title: "Naming Conventions"
      (<description>
        (<definition> name: naming_comments title: "Comments"
          (<node>
            (<span> "; Code comment : put at the end of a line of code to document it.")
            (<span> ";; Definition comment : documents a definition and many lines may be used.")
            (<span> ";;; Section comment : documents a section.")
            (<span> ";;;; Chapter comment : specifies a section title naming and will be gathered in a chapter.")))
        (<p>)
        (<p>)
        (<definition> name: naming_modules title: "Modules & Libraries"
          (<p> "Modules and libraries names are lowercase separated by .")
          (<node>
            (<span> (<code> "jazz.ui"))
            (<span> (<code> "jedi.product"))))
        (<p>)
        (<p>)
        (<definition> name: naming_classes title: "Classes & Interfaces"
          (<p> "Class & Interfaces names are capitalized")
          (<node>
            (<span> (<code> "View"))
            (<span> (<code> "Java-Text"))))
        (<p>)
        (<p>)
        (<definition> name: naming_methods title: "Methods"
          (<p> "Methods are in lowercase separated by -")
          (<node>
            (<span> (<code> "get-application"))))
        (<p>)
        (<p>)
        (<definition> name: naming_predicates title: "Predicates"
          (<p> "Predicates end with ?")
          (<node>
            (<span> (<code> "eq?"))
            (<span> (<code> "string?"))))
        (<p>)
        (<p>)
        (<definition> name: naming_mutators title: "Mutators"
          (<p> "Destructive functions end with !")
          (<node>
            (<span> (<code> "set-cdr!"))
            (<span> (<code> "append!"))))
        (<p>)
        (<p>)
        (<definition> name: naming_convertors title: "Convertors"
          (<p> "Type conversion functions have -> in their name")
          (<node>
            (<span> (<code> "symbol->string"))
            (<span> (<code> "symbol->keyword")))))))
  (<Section-Doc> name: lexical title: "Lexical Syntax"
      (<description>
        (<definition> name: identifiers title: "Identifiers"
          (<p> "Identifiers in Jazz are case sensitive. A common usage of this is to have a class named X and a variable containing an instance of X named x.")
          (<p>)
          (<p> "The following characters are considered alphabetic and can thus be used in identifiers:")
          (<p> "! $ % & * + - . / : < = > ? ^ _ ~"))
        (<p>)
        (<p>)
        (<definition> name: whitespace title: "Whitespace"
          (<p> "Spaces, tabs, carriage returns and line feeds are considered whitespace and can be freely inserted in Jazz code without changing the meaning of the code."))
        (<p>)
        (<p>)
        (<definition> name: comments title: "Comments"
          (<p> "Jazz offers two types of comments:")
          (<node>
            (<span> "; starts a line based comment and")
            (<span> "@name starts an sexpr based comment where name can be any symbol. "
              "It is completely ignored and can be used for documentation purposes.")))))
  (<Section-Doc> name: functional title: "Functional Programming"
    (<description>
        (<definition> title: "Variable value"
          (<p> (<code> "x")))
        (<p>)
        (<definition> title: "Function invocation"
          (<p> (<code> "(f x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "x")
          (<code> "(f 2 3)")))
    (<Section-Doc> name: functional_syntax title: "Functional Syntax"
      (<Form-Doc> name: definition parameters: "name value"
        (<description>
          (<p> "A definition associates name to value inside the defining unit. A definition is as field and as such is stored in the class and doesn't take any space in instances. At class instantiation, value is evaluated in an empty lexical environment and in an empty object environment."))))
    (<Section-Doc> name: functions title: "Functions"
      (<description>
        (<p> "In Jazz, functions are first order objects and can be freely manipulated as any other objects. "
          "They can be passed as parameters, stored in variables, ..."
          "Anyone who says functions are not object-oriented is just showing they have'nt really went far enough in their understanding of the problem!")
        (<p>)
        (<definition> name: function_parameters title: "Parameters"
          (<p> "On top of the standard positional parameter passing scheme, Jazz offers the following:")
          (<node>
            (<span> "Variable number of parameters")
            (<span> "Optional parameters")
            (<span> "Keyword parameters")))))
    (<Section-Doc> name: syntax_forms title: "Syntax"
    (<Syntax-Doc> name: bind parameters: "variables-tree values-tree expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-optionals parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-keywords parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: receive parameters: "(variable ...) values expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: quote parameters: "expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: if parameters: "test yes-expr no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: when parameters: "test yes-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unless parameters: "test no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: while parameters: "test expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: begin parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: prog1 parameters: "result-expr1 expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: tie
      (<description>
        (<p>)))
    (<Syntax-Doc> name: cond parameters: "(test expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: case parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: ecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: typecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: set! parameters: "variable expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: increase! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: decrease! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: let parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: let* parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: letrec parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: catch parameters: "name expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unwind-protect parameters: "protected-expr protection-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: lambda parameters: "parameters-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: function parameters: "parameters-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: and parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if and only if all expr... are true. Note that and will stop as soon as it encounters a false value."))
      (<examples>
        (<example> "(and true (= 2 (+ 1 1))) returns true.")
        (<example> "(and (symbol-bound? 'not-a-bound-variable) not-a-bound-variable) will not signal an error because the first test will fail.")))
    (<Syntax-Doc> name: or parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if one of the expr... is true. Note that or will stop as soon as it encounters a true value."))
      (<examples>
        (<example>
          (<p> "One simple application of the fact that or stops as soon as it encounters a true value is in very clean code for managing simple lazy structures.")
          (<p>)
          (<p> "(define a-big-structure-only-on-demand nil)")
          (<p> "(define (get-structure)")
          (<p> "  (or a-big-structure-only-on-demand")
          (<p> "      (set! a-big-structure-only-on-demand (new-structure))))"))))
    (<Syntax-Doc> name: essay parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: either parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert parameters: "asserted-expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert-type parameters: "asserted-type"
      (<description>
        (<p>)))))
  (<Section-Doc> name: object-oriented title: "Object-Oriented Programming"
    (<Section-Doc> name: classes title: "Classes"
      (<description>
        (<p> "Jazz offers an object-oriented layer with :")
        (<p>)
        (<definition> title: "Method invocation"
          (<p> (<xmp> "(f~ obj x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "(get-size~ window)")
          (<code> "(invalidate-view~ (get-parent~ view))"))
        (<p>)
        (<node>
          (<span> "Classes with single inheritance and multiple interfaces implemented")
          (<span> "Metaclasses")
          (<span> "Single-dispatch 'a la' Java")
          (<span> "Generic multi-dispatch methods 'a la' CommonLisp")))
      (<Form-Doc> name: class parameters: "extends implements uses ..."
        (<description>
          (<p> "Jazz uses a single inheritance model where a class can extend only one superclass. "
            "A class can implement any number of interfaces.")))
      (<Form-Doc> name: slot parameters: "name <initialize> <initial-value>"
        (<description>
          (<p> "A slot is a field that defines the structure of the instances of a class.")))
      (<Form-Doc> name: property parameters: "name <initialize> <initial-value> <getter> <getter-name> <setter> <setter-name>"
        (<description>
          (<p> "A property is a slot that can specify a getter and a setter.")))
      (<Form-Doc> name: method parameters: "{modifiers} (name . parameters) {return-type} . body"
        (<description>
          (<p> "A method is where code resides.")))
    (<Section-Doc> name: meta-classes title: "Meta-Classes"
      (<description>))
      )
    (<Section-Doc> name: interfaces title: "Interfaces"
      (<Form-Doc> name: interface parameters: "extends uses ..."
        (<description>
          (<p> "An interface defines a new type but cannot contain code."))))
    (<Class-Doc> name: Object
      (<description>
        (<p> "The base class of every other class."))
      (<Method-Doc> name: initialize parameters: "object ...")
      (<Method-Doc> name: destroy parameters: "")
      (<Method-Doc> name: close parameters: "")
      (<Method-Doc> name: print parameters: "printer detail")
      (<Section-Doc> title: "Literals"
        (<description>
          (<definition> name: literals title: "Literals"
            (<p> "Jazz supports a powerfull concept where any class can define it's own literal constants using the following syntax: {class-name ...}. "
              "This integrates classes fully with the reader and printer.")
            (<p> "Examples:")
            (<node>
              (<code> "{Point 2 3}")
              (<code> "{Dimension 100 100}")
              (<code> "{Color name: Red}")
              (<code> "{Font name: Code}"))))))
    (<Section-Doc> name: dynamic-dispatch title: "Dynamic Dispatch"
      (<description>))
    (<Section-Doc> name: generic-methods title: "Generic methods"
      (<description>)))
  (<Section-Doc> name: component-programming title: "Component Programming"
    (<description>
        (<p> "One of the biggest strength of components is the full integration of the programming metaphor with the visual design metaphor they enable. "
          "By seamlessly intermixing programming code and designer data, components brings all the power of programming tools to the design part."))
    (<Class-Doc> name: Component
      (<description>
        (<p> "Object-Oriented Databases")
        (<p>)
        (<p> "Inheritance and Composition")
        (<p>)
        (<p> "The Jazz component system unifies the inheritance and composition based programming models.")
        (<p>)
        (<p>
          "The Component class is by far the most fundamental one. "
          "It is the foundation of all the graphical user interface but can also be extremely usefull in non graphical contexes.")
        (<p>)
        (<p> "Components are the result the following design goals:")
        (<node>
          (<span> " Components should be editable by a graphical editor.")
          (<span> " Components should be savable to disk and restorable from disk.")
          (<span> " Components should be hierarchical.")
          (<span> " Components should integrate seamlessly with the object model.")
          (<span> " Components should integrate seamlessly with the programming language.")))
      (<Property-Doc> name: name getter: get-name setter: set-name
        (<description>
          (<p> "Every component can be named. A name must be a symbol or nil. A name of nil represents an anonymous component.")))
      (<Property-Doc> name: parent getter: get-parent setter: set-parent)
      (<Property-Doc> name: children getter: get-children setter: set-children)
      (<Method-Doc> name: find-component parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, nil is returned.")))
      (<Method-Doc> name: child parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, an error is signaled.")))
      (<Method-Doc> name: install)
      (<Method-Doc> name: conclude)
      (<Method-Doc> name: finish)
      (<Method-Doc> name: prepare)
      (<Method-Doc> name: locate))
    (<Class-Doc> name: Form
      (<description>
        (<p>
          "Forms contain properties. "
          "Each subform can redefine parts of the parent form. "
          "Properties can be added, modified or even removed.")
        (<p>)
        (<p>
          "For example, a class X has two properties, a and b. "
          "The derived class Y change the property a. "
          "The resulting form would contain both a and b, with a being the redefined property.")
        (<p>)
        (<p> "X (a = 2, b = 3) -> Y (a = 5) ---> a = 5, b = 3")
        (<p>)
        (<p> "When a form is created, the base form is loaded, then each modification of the successive branches are applied, up to our final form.")
        (<p>)
        (<p> "A property initialized in a class can be impacted by the class's form and all subsequent form redefinitions in the subclasses.")))
    (<Class-Doc> name: Branch
      (<description>
        (<p> "A branch is simply a component that encapsulates a form. "
          "This branch can be installed or removed at will. "
          "Branchs can also be hierarchicaly nested. "
          "Thinking about components, you can now give them static shape with a form, or go further and collect some branchs that can be applied to them or go even further and thats the complete flexibility of programming. ")
        (<p>)
        (<p> "With this naming, every thing becomes very clean -> for example the saved searches are branchs of the search that you package (maybe to a file or maybe you are copy pasting them or even drag and dropping them!) to a file and later on unpackage and reinstall in the search! "
          "Seeing it this way really makes it clear that branchs are clearly an outstanding feature of Jazz. ")
        (<p>)
        (<p> "If I can reach a point where everytning is components that can be packaged for saving, copy pasting, ... and all the tools are based on that, I see branches as a concept that will show that a huge portion of the code out there is basically doing branch management stuff without knowing it. "))))
  (<Section-Doc> name: types title: "Type Annotations"
    (<description>
      (<p> "Jazz is a dynamically typed language. Types are associated with objects as opposed to statically typed languages where types are associated with variables. With a dynamically typed language, type information is always available at runtime contrary to statically typed languages where only the compiler has access to type information")
      (<p>)
      (<p> "Jazz offer optional type declarations.")
      (<p>)
      (<p> "Types are denoted by :")
      (<xmp> "<primitive> (ex: <int> <bool>)")
      (<xmp> "<class> (ex: <View> <Window>)")
      (<p> "denote the type of all objects of type class, the null not included")
      (<xmp> "<class+> (ex: <Point+> <Rect+>)")
      (<p> "denote the type of all objects of type class, the null included")
      (<p>)
      (<p> "Using a &lt;class&gt; type specifier instead of the more generic &lt;class+&gt; specifier will enable the compiler to enforce non null.")))
  (<Section-Doc> name: numbers title: "Numbers"
    (<description>
      )
    (<Section-Doc> name: generic-arithmetic title: "Generic Arithmetic"
      (<description>
        )))
  (<Section-Doc> name: symbols title: "Symbols"
    (<description>
      (<p> "Jazz is symbolic language where symbols are used extensively. Symbols can be used as a very efficient higher level abstraction replacement for integer enumerations")))
  (<Section-Doc> name: sequences title: "Sequences"
      (<description>
        )
    (<Section-Doc> name: list title: "List"
      (<description>
        (<p> "Lists are the most flexible data structure available in Jazz. They can grow to accommodate any number of elements and this very efficiently. As they are sequences, they are supported by a large number of manipulation functions")))
    (<Section-Doc> name: vector title: "Vector"
      (<description>
        ))
    (<Section-Doc> name: u8vector title: "U8Vector"
      (<description>
        ))
    (<Section-Doc> name: string title: "String"
      (<description>
        ))
    (<Section-Doc> name: queue title: "Queue"
      (<description>
        ))
    (<Section-Doc> name: axis title: "Axis"
      (<description>
        ))
    (<Section-Doc> name: subseq title: "Subseq"
      (<description>
        )))
  (<Section-Doc> name: iteration title: "Iteration"
    (<description>
      )
    (<Section-Doc> name: sequences-iteration title: "Sequences"
      (<description>
        ))
    (<Section-Doc> name: loop-macro title: "Loop Macro"
      (<description>
        )
    (<Syntax-Doc> name: loop parameters: "..."
      (<description>
        (<code> "for")
        (<code> "in")
        (<code> "in-properties")
        (<code> "iterate")
        (<code> "from")
        (<code> "repeat")
        (<code> "do")
        (<code> "sum")
        (<code> "collect")))))
  (<Section-Doc> name: exceptions title: "Exceptions"
    (<Section-Doc> name: exception title: "Exception"
      (<description>
        ))
    (<Section-Doc> name: error title: "Error"
      (<description>
        )))
  (<Section-Doc> name: input/output title: "Input / Output"
    (<Section-Doc> name: file title: "File"
      (<description>))
    (<Section-Doc> name: directory title: "Directory"
      (<description>))
    (<Section-Doc> name: aliases title: "Aliases"
      (<description>
        "Aliases are symbolic names for directories. "
        "They are similar to CommonLisp's logical pathnames. "
        (<p>)
        "The following aliases are predefined:"
        (<node>
          "Home"
          "User"
          "Install"
          "Jazz")))
    (<Section-Doc> name: formatted_output title: "Formatted Output"
      (<description>
        (<p> "Implements formatted output.")
        (<p>)
        (<definition> name: format_directives title: "Directives"
          (<table> class: "terminology" width: "500"
            (<th> "Name") (<th> "Accessor") (<th> "Description")
            (<tr> (<td> "ASCII") (<td> "a") (<td> "human readable"))
            (<tr> (<td> "SEXPR") (<td> "s") (<td> "reader readable"))
            (<tr> (<td> "TEXT") (<td> "t") (<td> "textual representation"))
            (<tr> (<td> "PRINT") (<td> "p") (<td> "ascii or sexpr or text"))
            (<tr> (<td> "REAL") (<td> "r") (<td> "real number"))
            (<tr> (<td> "CHAR") (<td> "h") (<td> "character"))
            (<tr> (<td> "LIST") (<td> "l") (<td> "remove parenthesis"))
            (<tr> (<td> "PROPERTIES") (<td> "k") (<td> "properties list"))
            (<tr> (<td> "UNSIGNED") (<td> "u") (<td> "unsigned integer"))
            (<tr> (<td> "HEXADECIMAL") (<td> "x") (<td> "hexadecimal integer"))
            (<tr> (<td> "COLUMN") (<td> "c") (<td> "column"))
            (<tr> (<td> "TAB") (<td> "&") (<td> "insert tab character"))
            (<tr> (<td> "NEW_LINE") (<td> "%") (<td> "insert new line"))
            (<tr> (<td> "LOCALIZE") (<td> "z") (<td> "localized string"))
            (<tr> (<td> "FORMATTED") (<td> "f") (<td> "formatted control"))))
        (<p>)
        (<definition> name: format_parameters title: "Parameters"
          (<p> "{x :a value :b value ?}")
          (<p> ":v -> takes the info from the parameters")
          (<p>)
          (<p> "Examples:")
          (<node>
            (<code> "(format :string \"{_ 5}\")")
            (<code> "(format :string \"{a :width :v :justify right}\" bonjour 20)"))
          (<p>)
          (<p> "Parameters can be optional and can be keyword based.")
          (<node>
            (<span> "list?")
            (<span> "width")
            (<span> "justify -> :left :right")
            (<span> "padding")
            (<span> "separator")
            (<span> "last-separator")
            (<span> "precision")
            (<span> "properties")
            (<span> "empty-value")
            (<span> "detail"))))))
  (<Section-Doc> name: regular-expressions title: "Regular Expressions")
  (<Section-Doc> name: date/time title: "Date / Time")
  (<Section-Doc> name: jml title: "Markup"
    (<description>
      (<p> "JML plays a key role in Jazz. "
        "Almost all data externaly persisted will use JML as its representation format.")
      (<p>)
      (<p> "Key Classes:")
      (<definition> name: JML
        (<p> "A module of JML related functions."))
      (<definition> name: JML-Node
        )
      (<definition> name: JML-Element
        )
      (<definition> name: JML-Text
        )
      (<definition> name: JML-Parser
        )
      (<definition> name: JML-Transformation
        )
      (<definition> name: JML-Renderer
        )))
  (<Section-Doc> name: depot title: "Source Control"
    (<description>
      "A depot is an abstraction for a source control system. "))
  (<Section-Doc> name: database title: "Database"
    (<description>)
    (<Class-Doc> name: Connection
      (<description>
        (<p> "A database connection.")))
    (<Class-Doc> name: Request
      (<description>
        (<p> "A request to a stored procedure.")))
    (<Class-Doc> name: Recordset
      (<description>
        (<p> "A recordset returned by a request."))))
  (<Section-Doc> name: profiling title: "Profiling")
  (<Section-Doc> name: remoting title: "Remoting"
    (<Section-Doc> name: proxies title: "Proxies")
    (<Section-Doc> name: stubs title: "Stubs"))
  (<Section-Doc> name: system title: "System"
    (<Section-Doc> name: process title: "Process")
    (<Section-Doc> name: application title: "Application"))
  (<Section-Doc> name: user-interface title: "User Interface"
    (<Section-Doc> title: "Drawing"
      (<description>)
      (<Section-Doc> title: "Cairo"
        (<description>))
      (<Section-Doc> title: "Surface"
        (<description>))
      (<Section-Doc> title: "Color"
        (<description>))
      (<Section-Doc> title: "Font"
        (<description>))
      (<Section-Doc> title: "Point"
        (<description>))
      (<Section-Doc> title: "Dimension"
        (<description>))
      (<Section-Doc> title: "Rect"
        (<description>))
      (<Section-Doc> title: "Cell"
        (<description>))
      (<Section-Doc> title: "Range"
        (<description>)))
    (<Section-Doc> title: "Windows"
      (<description>)
      (<Class-Doc> name: Window
        (<description>))
      (<Class-Doc> name: Toplevel
        (<description>))
      (<Class-Doc> name: Stage
        (<description>
          "A stage window is the parent window of all documents. "))
      (<Class-Doc> name: Palette
        (<description>
          "Windows of this class should be permanent popups."))
      (<Class-Doc> name: Popup
        (<description>
          "Windows of this class should be temporary popup windows like tooltips, menus, ... "
          "For permanent popups see Palette. "))
      (<Class-Doc> name: Dialog
        (<description>)))
    (<Section-Doc> title: "Basic Views"
      (<description>)
      (<Class-Doc> name: View
        (<description>))
      (<Class-Doc> name: Border-View
        (<description>))
      (<Class-Doc> name: Check-Box
        (<description>))
      (<Class-Doc> name: Group-Box
        (<description>))
      (<Class-Doc> name: Label-View
        (<description>))
      (<Class-Doc> name: Layout-View
        (<description>))
      (<Class-Doc> name: Push-Button
        (<description>))
      (<Class-Doc> name: Radio-Button
        (<description>))
      (<Class-Doc> name: Scroller-View
        (<description>)))
    (<Section-Doc> title: "Text-View"
      (<Class-Doc> name: Text-View
        (<description>)))
    (<Section-Doc> title: "Tree-View"
      (<Class-Doc> name: Tree-View
        (<description>))
      (<Class-Doc> name: Tree-Header
        (<description>))
      (<Class-Doc> name: Tree-Node-Column
        (<description>))
      (<Class-Doc> name: Tree-Label-Column
        (<description>))
      (<Class-Doc> name: Tree-Row
        (<description>)))
    (<Section-Doc> title: "Hosting"
      (<description>)
      (<Section-Doc> title: "Host"
        (<description>))
      (<Section-Doc> title: "Guest"
        (<description>)))
    (<Section-Doc> title: "Layouting"
      (<description>)
      (<Class-Doc> name: Flow-Layout
        (<description>))
      (<Class-Doc> name: Border-Layout
        (<description>)))
    (<Section-Doc> title: "Activation"
      (<description>
        (<table> class: "terminology" width: "500"
          (<th> "Event") (<th> "Description")
          (<tr> (<td> "focus-gain") (<td> "Sent to a view that gains focus"))
          (<tr> (<td> "focus-lose") (<td> "Sent to a view that loses focus"))
          (<tr> (<td> "host-activate") (<td> "Sent to guest when host gains focus"))
          (<tr> (<td> "host-deactivate") (<td> "Sent to guest when host loses focus"))
          (<tr> (<td> "client-activate") (<td> "Sent to each tool when a document activates"))
          (<tr> (<td> "client-deactivate") (<td> "Sent to each tool when last document closes"))
          (<tr> (<td> "stage-activate") (<td> "Sent to stage when last document closes"))
          (<tr> (<td> "stage-deactivate") (<td> "Sent to stage when a first document activates")))))
    (<Section-Doc> title: "Menus"
      (<Class-Doc> name: Menu
        (<description>))
      (<Class-Doc> name: Label-Item
        (<description>))
      (<Class-Doc> name: Separator-Item
        (<description>)))
    (<Section-Doc> title: "Events"
      (<description>
        "Event encapsulation puts almost no pressure on the framework because almost everywhere the direct class override is used. "
        "Events encapsulate amongst other things, modifiers state that is necessary for recording user actions. ")
      (<Class-Doc> name: Event
        (<description>)))
    (<Section-Doc> title: "Clipboard"
      (<description>))
    (<Section-Doc> title: "User Interaction"
      (<description>
        "message-box")))
  (<Section-Doc> name: c-interface title: "C Interface"
    (<Section-Doc> name: c-interface.syntax title: "Syntax"
      (<Form-Doc> name: c-constant parameters: "name value"
        (<description>
          (<p> "A c-constant cannot be modified. Note that currently, a constant definition is simply a definition.")
          ))
      (<Form-Doc> name: c-enumeration parameters: "enumeration-name (name1 value1) (name2 value2) ..."
        (<description>
          (<p> "A c-enumeration definition. "
            "This enumeration will create a definition enumeration-name containing an Enumeration object that can be queried at runtime and create constant definitions name1 : value1, name2 : value2, ...")
          ))
      (<Form-Doc> name: c-structure parameters: "structure-name (type1 field1 <n1>) (type2 field2 <n2>) ..."
        (<description>
          (<p> "A c-structure is a template that can be used to create records containing primitive types. Here, type is any primitive type and field is a symbol that can be used to access this field is records of type structure-name. If the optional n is specified, then an array of n elements of type will be inserted.")
          ))
      (<Form-Doc> name: c-external parameters: "module-name return-type (name param1 param2 ...) <entry-name>"
        (<description>
          (<p> "A c-external entry point into a Windows module, i.e. a dynamic-link library or an executable.")
          ))))
  @wait
  (<Module-Doc> name: License
  (<description>
    (<p> "Licensing module."
      "This module which is in development, will provide classes to enforce commercial licensing strategies.")))
  @wait
  (<Module-Doc> name: Designer
  (<description>
    (<definition> name: Designer
      (<p> "A Designer is the interface between a jazz object and a form"))
    (<definition> name: Component-Editor)
    (<definition> name: View-Editor)
    (<definition> name: Branches-Editor)
    (<definition> name: Components-Editor)
    (<p>)
    (<definition> name: Card)
    (<definition> name: Custom-Card)
    (<definition> name: Properties-Card)
    (<definition> name: Value-Row)
    (<p>)
    (<definition> name: Component-Surrogate)
    (<p>)
    (<definition> name: Property)
    (<definition> name: Property-Entry)
    (<definition> name: Property-View)
    (<definition> name: Domain)
    (<p>)
    (<definition> title: "Designer Events"
      (<node>
        (<span> "property-change ")
        (<span> "child-add ")
        (<span> "child-remove ")
        (<span> "child-move ")
        (<span> "update")
        (<span> "refresh")))
    (<p>)
    (<definition> title: "Editor Events"
      (<node>
        (<span> "client-change ")
        (<span> "designer-change ")
        (<span> "branch-changing ")
        (<span> "branch-change ")
        (<span> "selection-changing ")
        (<span> "selection-change")
        (<span> "saving")))
    (<p>)
    (<definition> title: "Notes"
      (<node>
        (<span> "Editing a form is done through a Designer and an instance of the form. Any changes to the instance or its children should be done by calling methods of the designer instead of going to the instance directly. The designer will take care of making the changes as well as recording them.")
        (<span> "Note that by having events generated when properties are modified and some others, this process could be made more automatic. But, this would imply a great performance overhead on the system and also we do not want programmatically modified properties to be recorded by the designer. This is why Jazz sticks will a manually calling the designer approach.")
        (<span> "So, if we have a Z -> Y -> X class hierarchy, an instance of Z can be used to edit the class form of X, Y or Z.")
        (<span> "When Jazz edits an object, it monitors every descendant by installing surrogates in them. Even if the edited component is changed (by double-clicking), we keep the upper surrogates installed (even if they could conceptually be removed) so as to still be able to double-click on them to change again the edited component.")
        (<span> "Surrogates take the place of an edited component and its descendants when there's a need to trap user events sent to the component. They are most commonly used for visual components like views.")
        (<span> "An editor is an view that will permit edition of its client and do so by calling designer methods in response to events generated three optional subviews: a branches tree, a descendants tree and a properties tree. An editor has an installed client on which you can put one or more (currently only one) designers on specific descendants of the client. Each designer will record edition to its part of the client descendants tree.")
        (<span> "So, we have a component and its descendants being monitored by surrogates and one of then is the edited component (so changes to it or any of its descendants is being sent to the designer).")
        (<span> "When editing a form I should also specify the edited branch (can be nil of course).")
        (<span> "Note that branch and form unification while desirable is not a good idea because always having an installed branch for every component instance would impose to great a memory load for a very small gain. Also the present approach has the very nice property of having branches as ordinary objects that could have been developed outside of the main system. They are as any other component, they simply have a different behavior.")
        (<span> "The designer and the various elements of the editor follow the MVC model. "
          "The designer plays the model role and the editor elements are views of this model. "
          "The editor never modifies its view directly. "
          "Instead it calls methods of the designer that will modify the edited component and also send events to every listening view who can then update their interface accordingly.")))))
  @wait
  (<Module-Doc> name: Library
  (<Class-Doc> name: Node
    (<description>
      (<p> "A node is a class that supports dynamic properties")
      (<p>)
      (<node> "An node can optionally be named")
      (<p>
        "Node properties, for efficiency are stored as slots for direct access but can also be accessed in a generic fashion via the "
        (<reference> href: "get-property")
        " method")
      (<p>)))
  (<Class-Doc> name: Element
    (<description>
      (<p> "An element is a node with a hierarchical structure")
      (<p>)))
  (<Class-Doc> name: Exemplar
    (<description>
      (<p> "An Exemplar is a dynamic class whose hierarchy can be modified at runtime")
      (<p>)
      (<node>
        (<span>
          "Exemplars don't have instances"))
      (<node>
        (<span>
          "All properties are fully inherited in the sense that whenever an exemplar is modified, every descendant is automatically updated. "
          "Because the most used operation is by far property access, exemplars have a full internal copy of every property. "
          "To implement inheritance, exemplars also have a list of which properties are owned by the exemplar, "
          "i.e. what properties should not be updated when an ascendant is modified"))
      (<node>
        (<span>
          "Exemplar properties, for efficiency are stored as slots for direct access but they can also be accessed in a generic fashion via the "
          (<reference> href: "get-property")
          " method"))
      (<node>
        (<span>
          "Exemplars are grouped in an "
          (<reference> href: "Exemplar-Domain")
          " which is the domain in which an exemplar name is a valid reference"))
      (<node>
        (<span>
          "An Exemplar can be named and can inherit from another exemplar via its "
          (<code> "base"))))))
  @wait
  (<Module-Doc> name: Java
  (<description>
    (<p> "Java integration module")
    (<p>)
    (<p> "This module is at an experimental stage at the moment though it was used to implement full database access through Java's JDBC library.")))
  @wait
  (<Module-Doc> name: SQL
  (<description>
    (<p> "SQL access module.")
    (<p>)
    (<p> "This module is a very mature module that provides a sophisticated UI over the database access classes of the Access module.")))
  @wait
  (<Section-Doc> title: "Modules"
      (<Package-Doc> name: jazz title: "jazz"
        (<Section-Doc> title: "Boolean"
          (<Method-Doc> name: eq? parameters: "x y"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "x")
                " is physicaly equal to "
                (<parameter> "y")
                ". In other words, if both memory pointers are the same.")))
          (<Method-Doc> name: neq? parameters: "x y"
            (<description>
              (<p> "The inverse test of eq?.")))
          (<Method-Doc> name: eqv? parameters: "x y"
            (<description>
              (<p> "eqv? will succed if the two objects are eq? or if they can be simply compared without going into their structures. For example, (eq? 2.3 2.3) migth return false whereas (eqv? 2.3 2.3) will always return true.")))
          (<Method-Doc> name: equal? parameters: "x y"
            (<description>
              (<p> "The most general equivalence predicate of all.")
              (<p> "equal? will succed if the two objects are eqv? but will also try to determine if the two objets structures are identical. For example, (eq? (list 1 2 3) (list 1 2 3)) returns false but (equal? (list 1 2 3) (list 1 2 3)) returns true.")))
          (<Method-Doc> name: not parameters: "obj"
            (<description>
              (<p>
                "Returns the logical negation of "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: boolean? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is of "
                (<code> "Boolean")
                " type."))
            (<examples>
              (<example>
                (<code> "(boolean? true)")
                " returns true.")
              (<example>
                (<code> "(boolean? false)")
                " returns true.")
              (<example>
                (<code> "(boolean? nil)")
                " return false.")))
          (<Method-Doc> name: xor parameters: "x y")
          (<Method-Doc> name: = parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: /= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: < parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: <= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: > parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: >= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci/= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci< parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci<= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci> parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci>= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: boolean parameters: "obj")
          (<Method-Doc> name: boolean->integer parameters: "bool")
          (<Method-Doc> name: integer->boolean parameters: "z"))
        (<Section-Doc> title: "Char"
          (<Method-Doc> name: char? parameters: "obj")
          (<Method-Doc> name: jazz-constituent? parameters: "obj")
          (<Method-Doc> name: cpp/java-constituent? parameters: "obj")
          (<Method-Doc> name: alphabetic? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is alphabetic. An object is alphabetic if it is an alphabetic character or a sequence composed only of alphabetic parts.")))
          (<Method-Doc> name: numeric? parameters: "obj"
            (<description>
              (<p> "Tests if obj is numeric. An object is numeric if it is a numeric character or a sequence composed only of numeric parts.")))
          (<Method-Doc> name: alphanumeric? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: whitespace? parameters: "obj"
            (<description>
              (<p> "Tests if obj is whitespace. An object is whitespace if it is a whitespace character or a sequence composed only of whitespace parts.")))
          (<Method-Doc> name: upper-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is upper-case. An object is upper-case if it is an upper-case character or a sequence composed only of upper-case parts.")))
          (<Method-Doc> name: lower-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is lower-case. An object is lower-case if it is a lower-case character or a sequence composed only of lower-case parts.")))
          (<Method-Doc> name: upcase parameters: "obj"
            (<description>
              (<p> "Converts obj to upper-case. If obj is a sequence, every part of obj with be converted to upper-case.")))
          (<Method-Doc> name: downcase parameters: "obj"
            (<description>
              (<p> "Converts obj to lower-case. If obj is a sequence, every part of obj with be converted to lower-case.")))
          (<Method-Doc> name: capitalize parameters: "obj"
            (<description>
              (<p> "Converts obj to capitalized form where every word starts with a capital letter and the rest is in lower-case. If obj is a sequence, every part of obj with be converted to capitalized form."))))
        (<Section-Doc> title: "Class"
          (<description>
            (<p> "The Class type is the supertype of every class. It enables a class to be inspected and manipulated as any other object."))
          (<Method-Doc> name: class? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: class-members parameters: "class"
            (<description>
              (<p> "Returns a list of all members of class.")))
          (<Method-Doc> name: class-fields parameters: "class"
            (<description>
              (<p> "Returns a list of all fields of class.")))
          (<Method-Doc> name: class-slots parameters: "class"
            (<description>
              (<p> "Returns a list of all slots of class."))))
        (<Section-Doc> title: "Closure"
          (<Method-Doc> name: closure? parameters: "obj"))
        (<Section-Doc> title: "Collector"
          (<Method-Doc> name: gc parameters: ""))
        (<Section-Doc> title: "Control"
          (<Method-Doc> name: throw parameters: "name")
          (<Method-Doc> name: exit parameters: ""))
        (<Section-Doc> title: "Debugger"
          (<Method-Doc> name: signal parameters: "exception")
          (<Method-Doc> name: error parameters: "format-string obj ..."))
        (<Section-Doc> title: "Enumeration"
          (<Method-Doc> name: enumeration? parameters: "obj"))
        (<Section-Doc> title: "Eval"
          (<Method-Doc> name: eval parameters: "expr")
          (<Method-Doc> name: identity parameters: "obj"))
        (<Section-Doc> title: "Format"
          (<Method-Doc> name: format parameters: "format-string obj ..."))
        (<Section-Doc> title: "Function"
          (<Method-Doc> name: function? parameters: "obj"))
        (<Section-Doc> title: "Hashtable"
          (<Method-Doc> name: hash-ref parameters: "hashtable key" package-name: Language
            (<description>
              (<p>
                "Gets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                ".")))
          (<Method-Doc> name: hash-set! parameters: "hashtable key value" package-name: Language
            (<description>
              (<p>
                "Sets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                " to "
                (<parameter> "value")
                ".")))
          (<Method-Doc> name: hash-clear parameters: "hashtable key")
          (<Method-Doc> name: empty-hashtable parameters: "hashtable")
          (<Method-Doc> name: load-hashtable parameters: "hashtable file")
          (<Method-Doc> name: hash-remove! parameters: "hashtable key value")
          (<Method-Doc> name: for-each-hash parameters: "proc hashtable"))
        (<Section-Doc> title: "Integer"
          (<Method-Doc> name: integer? parameters: "obj")
          (<Method-Doc> name: even? parameters: "z")
          (<Method-Doc> name: odd? parameters: "z")
          (<Method-Doc> name: quotient parameters: "z1 z2")
          (<Method-Doc> name: modulo parameters: "z1 z2")
          (<Method-Doc> name: separate parameters: "z1 z2")
          (<Method-Doc> name: randomize parameters: "")
          (<Method-Doc> name: random parameters: "n")
          (<Method-Doc> name: bit-not parameters: "n")
          (<Method-Doc> name: bit-and parameters: "n ...")
          (<Method-Doc> name: bit-or parameters: "n ...")
          (<Method-Doc> name: bit-xor parameters: "n ...")
          (<Method-Doc> name: bit-set parameters: "n1 n2 n3")
          (<Method-Doc> name: bit-set? parameters: "n1 n2")
          (<Method-Doc> name: shift-left parameters: "n1 n2")
          (<Method-Doc> name: shift-right parameters: "n1 n2"))
        (<Section-Doc> title: "Interface"
          (<Method-Doc> name: interface? parameters: "obj"))
        (<Section-Doc> title: "List"
          (<Method-Doc> name: car parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: set-car! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the car field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: set-cdr! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the cdr field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: cons parameters: "x y"
            (<description>
              (<p>
                "Returns a newly allocated pair whose car is "
                (<parameter> "x")
                " and whose cdr is "
                (<parameter> "y")
                ".")))
          (<Method-Doc> name: reverse parameters: "seq"
            (<description>
              (<p> "Reverses a sequence.")))
          (<Method-Doc> name: list? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a list, false otherwise."))
            (<examples>
              (<example> "(list? nil) -> true")
              (<example> "(list? '(a b c)) -> true")
              (<example> "(list? 2) -> false")))
          (<Method-Doc> name: nil? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is the empty list, false otherwise.")))
          (<Method-Doc> name: not-nil?)
          (<Method-Doc> name: pair? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a pair and otherwise returns false."))
            (<examples>
              (<example> "(pair? 2) -> false")
              (<example> "(pair? nil) -> false")
              (<example> "(pair? (cons 1 2)) -> true")
              (<example> "(pair? '(a b c)) -> true")))
          (<Method-Doc> name: atom? parameters: "obj")
          (<Method-Doc> name: caar parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cadr parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdar parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cddr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: list parameters: "obj ..."
            (<description>
              (<p> "Returns a list constructed of all its arguments.")))
          (<Method-Doc> name: memq? parameters: "obj list")
          (<Method-Doc> name: memv? parameters: "obj list")
          (<Method-Doc> name: member? parameters: "obj list &key key test")
          (<Method-Doc> name: assq parameters: "obj list")
          (<Method-Doc> name: assv parameters: "obj list")
          (<Method-Doc> name: assoc parameters: "obj list &key key test")
          (<Method-Doc> name: rassoc parameters: "obj list &key key test")
          (<Method-Doc> name: reverse! parameters: "list")
          (<Method-Doc> name: remove! parameters: "obj list")
          (<Method-Doc> name: getprop parameters: "plist key")
          (<Method-Doc> name: getf parameters: "plist key")
          (<Method-Doc> name: setf parameters: "plist key value")
          (<Method-Doc> name: for-each-pair parameters: "proc list")
          (<Method-Doc> name: for-each-property parameters: "proc list"))
        (<Section-Doc> title: "Manifest"
          (<Method-Doc> name: load parameters: "unit-name")
          (<Method-Doc> name: unit-loaded? parameters: "unit-name")
          (<Method-Doc> name: in-manifest? parameters: "unit-name"))
        (<Section-Doc> title: "Map"
          (<Method-Doc> name: map-ref parameters: "map key")
          (<Method-Doc> name: map-set! parameters: "map key value")
          (<Method-Doc> name: map-clear parameters: "map key")
          (<Method-Doc> name: empty-map parameters: "map")
          (<Method-Doc> name: load-map parameters: "map file")
          (<Method-Doc> name: for-each-map parameters: "proc map"))
        (<Section-Doc> title: "Metaclass"
          (<Method-Doc> name: metaclass? parameters: "obj")
          (<Method-Doc> name: metaclass-instance parameters: "metaclass"))
        (<Section-Doc> title: "Number"
          (<Method-Doc> name: + parameters: "obj ...")
          (<Method-Doc> name: - parameters: "obj1 obj2 ...")
          (<Method-Doc> name: * parameters: "obj ...")
          (<Method-Doc> name: number? parameters: "obj")
          (<Method-Doc> name: zero? parameters: "obj")
          (<Method-Doc> name: positive? parameters: "obj")
          (<Method-Doc> name: negative? parameters: "obj")
          (<Method-Doc> name: / parameters: "obj1 obj2 ...")
          (<Method-Doc> name: relate parameters: "x y")
          (<Method-Doc> name: sign parameters: "z")
          (<Method-Doc> name: floor parameters: "r")
          (<Method-Doc> name: round parameters: "r")
          (<Method-Doc> name: ceil parameters: "r")
          (<Method-Doc> name: abs parameters: "z")
          (<Method-Doc> name: min parameters: "obj ...")
          (<Method-Doc> name: max parameters: "obj ...")
          (<Method-Doc> name: between? parameters: "n lower upper")
          (<Method-Doc> name: between parameters: "lower n upper")
          (<Method-Doc> name: in-interval? parameters: "n lower upper")
          (<Method-Doc> name: norm parameters: "x")
          (<Method-Doc> name: near? parameters: "x y distance"))
        (<Section-Doc> title: "Object"
          (<Method-Doc> name: object? parameters: "obj")
          (<Method-Doc> name: copy parameters: "obj"))
        (<Section-Doc> title: "Package"
          (<Method-Doc> name: package? parameters: "obj"))
        (<Section-Doc> title: "Printer"
          (<Method-Doc> name: display parameters: "obj &optional printer")
          (<Method-Doc> name: write parameters: "obj &optional printer")
          (<Method-Doc> name: describe parameters: "obj &optional printer")
          (<Method-Doc> name: new-line parameters: "&optional printer")
          (<Method-Doc> name: print-unreadable parameters: "obj printer proc"))
        (<Section-Doc> title: "Procedure"
          (<Method-Doc> name: procedure? parameters: "obj"))
        (<Section-Doc> title: "Reader"
          (<Method-Doc> name: read parameters: "&optional reader")
          (<Method-Doc> name: get-char parameters: "&optional reader")
          (<Method-Doc> name: unget-char parameters: "char &optional reader")
          (<Method-Doc> name: peek-char parameters: "&optional reader")
          (<Method-Doc> name: end-of-stream? parameters: "&optional reader"))
        (<Section-Doc> title: "Real"
          (<Method-Doc> name: real? parameters: "obj")
          (<Method-Doc> name: sin parameters: "r")
          (<Method-Doc> name: cos parameters: "r")
          (<Method-Doc> name: tan parameters: "r")
          (<Method-Doc> name: asin parameters: "r")
          (<Method-Doc> name: acos parameters: "r")
          (<Method-Doc> name: atan parameters: "r1 r2")
          (<Method-Doc> name: sqrt parameters: "r")
          (<Method-Doc> name: exp parameters: "r")
          (<Method-Doc> name: log parameters: "r")
          (<Method-Doc> name: expt parameters: "r1 r2")
          (<Method-Doc> name: percentage parameters: "part total")
          (<Method-Doc> name: percent parameters: "percent n"))
        (<Section-Doc> title: "Sequence"
          (<description>
            "Sequences are an abstract data type representing objects capable of storing sequences of objects. Some examples of sequences are lists, strings and vectors. The Jazz language possesses a important number of sequence manipulation functions")
          (<Method-Doc> name: sequence? parameters: "obj"
            (<description>
              (<p> "Tests if obj is of Sequence type.")))
          (<Method-Doc> name: length parameters: "sequence"
            (<description>
              (<p>
                "Returns the number of elements in "
                (<parameter> "seq")
                ".")))
          (<Method-Doc> name: element parameters: "sequence n"
            (<description>
              (<p> "Returns the nth element of sequence.")))
          (<Method-Doc> name: set-element! parameters: "sequence n value"
            (<description>
              (<p> "Destructively sets the nth element of sequence to value.")))
          (<Method-Doc> name: empty? parameters: "sequence")
          (<Method-Doc> name: tail parameters: "sequence n"
            (<description>
              (<p> "Returns the elements of sequence that range from n to the end. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: last parameters: "sequence"
            (<description>
              (<p> "Returns the last element of sequence.")))
          (<Method-Doc> name: last-tail parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made-up of only the last element of sequence. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: butlast parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made up of every element of sequence except the last.")))
          (<Method-Doc> name: subseq parameters: "sequence start &optional end"
            (<description>
              (<p> "Returns a sequence made up of the elements of sequence that range from start to end exclusively. If end is omited, the elements are taken till the end of sequence.")))
          (<Method-Doc> name: subseq! parameters: "sequence start &optional end")
          (<Method-Doc> name: sort parameters: "predicate sequence &key key test")
          (<Method-Doc> name: for-each-reversed parameters: "sequence")
          (<Method-Doc> name: append parameters: "sequence"
            (<description>
              (<p>
                "Returns a sequence composed of all the elements of "
                (<parameter> "seq")
                "."))
            (<examples>
              (<example> "(append) -> nil")
              (<example> "(append '(a b c) nil '(1 2) '(1 2 3)) -> (a b c 1 2 1 2 3)")
              (<example> "(append \\\"Hello\\\" \\\" \\\" \\\"there\\\") -> \\\"Hello there\\\"")
              (<example> "(append 2 3) -> <error>\"")))
          (<Method-Doc> name: append! parameters: "sequence ...")
          (<Method-Doc> name: insert! parameters: "obj sequence pos")
          (<Method-Doc> name: insert-sequence! parameters: "sequence inserted pos")
          (<Method-Doc> name: replace-subseq! parameters: "sequence start end replacement")
          (<Method-Doc> name: element-reversed parameters: "sequence n")
          (<Method-Doc> name: for-each parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2")))
          (<Method-Doc> name: map parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2 and collects the results in a list that it returns.")))
          (<Method-Doc> name: map-to parameters: "type proc sequence")
          (<Method-Doc> name: gather parameters: "sequence")
          (<Method-Doc> name: collect parameters: "proc sequence")
          (<Method-Doc> name: collect-if parameters: "predicate sequence")
          (<Method-Doc> name: collect-type parameters: "type sequence")
          (<Method-Doc> name: count parameters: "obj sequence"
            (<description>
              (<p> "Finds the number of occurrences of obj in sequence.")))
          (<Method-Doc> name: count-if parameters: "predicate sequence")
          (<Method-Doc> name: count-type parameters: "type sequence")
          (<Method-Doc> name: find parameters: "object sequence")
          (<Method-Doc> name: find-if parameters: "predicate sequence")
          (<Method-Doc> name: skip parameters: "predicate sequence")
          (<Method-Doc> name: some? parameters: "predicate sequence")
          (<Method-Doc> name: every? parameters: "predicate sequence")
          (<Method-Doc> name: union parameters: "sequence ...")
          (<Method-Doc> name: intersection parameters: "sequence ...")
          (<Method-Doc> name: difference parameters: "sequence1 sequence2"
            (<description>
              (<p> "Returns the set difference sequence1 \\ sequence2.")))
          (<Method-Doc> name: remove parameters: "target sequence")
          (<Method-Doc> name: remove-trailing parameters: "target list")
          (<Method-Doc> name: remove-duplicates parameters: "sequence"
            (<description>
              (<p> "Returns a sequence that has exactly the same elements as sequence and in the same order but with no duplicates.")))
          (<Method-Doc> name: remove-nils parameters: "sequence")
          (<Method-Doc> name: mismatch parameters: "target sequence")
          (<Method-Doc> name: prefix parameters: "sequences")
          (<Method-Doc> name: prefix? parameters: "target sequence")
          (<Method-Doc> name: search parameters: "target sequence")
          (<Method-Doc> name: split parameters: "sequence separator")
          (<Method-Doc> name: split-justified parameters: "sequence width separators")
          (<Method-Doc> name: join parameters: "sequences separator")
          (<Method-Doc> name: substitute parameters: "old new sequence")
          (<Method-Doc> name: substitute-alist parameters: "replacements sequence")
          (<Method-Doc> name: fill! parameters: "sequence object")
          (<Method-Doc> name: replace! parameters: "sequence replacement")
          (<Method-Doc> name: insert-ordered! parameters: "object sequence")
          (<Method-Doc> name: merge-ordered parameters: "proc x y")
          (<Method-Doc> name: random-element parameters: "sequence")
          (<Method-Doc> name: partition parameters: "sequence &key key test")
          (<Method-Doc> name: starts-with? parameters: "string target")
          (<Method-Doc> name: ends-with? parameters: "string target")
          (<Method-Doc> name: first parameters: "sequence")
          (<Method-Doc> name: second parameters: "sequence")
          (<Method-Doc> name: third parameters: "sequence")
          (<Method-Doc> name: fourth parameters: "sequence")
          (<Method-Doc> name: fifth parameters: "sequence")
          (<Method-Doc> name: sixth parameters: "sequence")
          (<Method-Doc> name: seventh parameters: "sequence")
          (<Method-Doc> name: eighth parameters: "sequence")
          (<Method-Doc> name: ninth parameters: "sequence")
          (<Method-Doc> name: tenth parameters: "sequence")
          (<Method-Doc> name: set-first! parameters: "sequence object")
          (<Method-Doc> name: set-second! parameters: "sequence object")
          (<Method-Doc> name: set-third! parameters: "sequence object")
          (<Method-Doc> name: set-fourth! parameters: "sequence object")
          (<Method-Doc> name: set-fifth! parameters: "sequence object")
          (<Method-Doc> name: set-sixth! parameters: "sequence object")
          (<Method-Doc> name: set-seventh! parameters: "sequence object")
          (<Method-Doc> name: set-eighth! parameters: "sequence object")
          (<Method-Doc> name: set-ninth! parameters: "sequence object")
          (<Method-Doc> name: set-tenth! parameters: "sequence object"))
        (<Section-Doc> title: "String"
          (<Method-Doc> name: string? parameters: "object")
          (<Method-Doc> name: empty-string? parameters: "object"))
        (<Section-Doc> title: "Symbol"
          (<Method-Doc> name: symbol? parameters: "object")
          (<Method-Doc> name: keyword? parameters: "object")
          (<Method-Doc> name: symbol->keyword parameters: "symbol")
          (<Method-Doc> name: keyword->symbol parameters: "keyword")
          (<Method-Doc> name: string->symbol parameters: "string")
          (<Method-Doc> name: symbol->string parameters: "symbol")
          (<Method-Doc> name: find-symbol parameters: "string")
          (<Method-Doc> name: generate-symbol parameters: "&optional prefix")
          (<Method-Doc> name: symbol-bound? parameters: "symbol")
          (<Method-Doc> name: symbol-unbound? parameters: "symbol"))
        (<Section-Doc> title: "Thread"
          (<Method-Doc> name: primordial-thread parameters: "")
          (<Method-Doc> name: current-thread parameters: ""))
        (<Section-Doc> title: "Time"
          (<Method-Doc> name: clock parameters: ""))
        (<Section-Doc> title: "Type"
          (<Method-Doc> name: type? parameters: "object")
          (<Method-Doc> name: new parameters: "class object ...")
          (<Method-Doc> name: new-in parameters: "context class object ...")
          (<Method-Doc> name: coerce parameters: "object type")
          (<Method-Doc> name: class-of parameters: "object")
          (<Method-Doc> name: is? parameters: "object type")
          (<Method-Doc> name: is-not? parameters: "object type")
          (<Method-Doc> name: typed? parameters: "object type-name")
          (<Method-Doc> name: subtype? parameters: "class type")
          (<Method-Doc> name: subtyped? parameters: "class type-name")
          (<Method-Doc> name: type-name parameters: "type")
          (<Method-Doc> name: type-ascendant parameters: "type")
          (<Method-Doc> name: type-descendants parameters: "type")
          (<Method-Doc> name: type-ancestors parameters: "type"))
        (<Section-Doc> title: "Unit"
          (<Method-Doc> name: unit? parameters: "object")
          (<Method-Doc> name: all-units parameters: ""))
        (<Section-Doc> title: "Values"
          (<Method-Doc> name: values parameters: "object ..."))
        (<Section-Doc> title: "Vector"
          (<Method-Doc> name: vector? parameters: "object"))))
  )
