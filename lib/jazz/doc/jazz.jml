;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Documentation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


; TODO: - see commit "Added examples of every clause supported by the loop syntax"

(<Project-Doc> name: jazz title: "Jazz Platform"
  (<Section-Doc> name: overview title: "Overview"
    (<description>
      (<p> "Jazz is a programming language based on Scheme, conforming to the R5RS Scheme standard and implementing all optional features. "
           "For documentation, see " (<a> href: "http://www.schemers.org/Documents/Standards/R5RS/HTML/" "R5RS Documentation") ". "
           "Jazz is built on top of the Gambit system, and has full access to every feature of Gambit. "
           "For documentation, see " (<a> href: "http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html" "Gambit Manual") ". "
           "By using Scheme's load primitive, you can load any existing Scheme code. ")))



  (<Section-Doc> name: naming title: "Naming Conventions"
    (<description>
      (<definition> name: naming_comments title: "Comments"
        (<node>
          (<span> ";;;; Chapter comment : specifies the section title, and will be gathered in a chapter.")
          (<span> ";;; Section comment : documents a section.")
          (<span> ";; Definition comment : documents a definition; many lines may be used.")
          (<span> "; Code comment : put at the end of a line of code to document it.")))
      (<p>)

      (<definition> name: naming_units title: "Units & Modules"
        (<p> "Units and modules names are lowercase separated by .")
        (<node>
          (<span> (<code> "jazz.ui"))
          (<span> (<code> "jedi.product"))))
      (<p>)
      
      (<definition> name: naming_classes title: "Classes & Interfaces"
        (<p> "Class & Interfaces names are capitalized")
        (<node>
          (<span> (<code> "View"))
          (<span> (<code> "Java-Text"))))
      (<p>)

      (<definition> name: naming_methods title: "Methods"
        (<p> "Methods are in lowercase separated by -")
        (<node>
          (<span> (<code> "get-application"))))
      (<p>)

      (<definition> name: naming_predicates title: "Predicates"
        (<p> "Predicates end with ?")
        (<node>
          (<span> (<code> "eq?"))
          (<span> (<code> "string?"))))
      (<p>)

      (<definition> name: naming_mutators title: "Mutators"
        (<p> "Destructive functions end with !")
        (<node>
          (<span> (<code> "set-cdr!"))
          (<span> (<code> "append!"))))
      (<p>)

      (<definition> name: naming_convertors title: "Convertors"
        (<p> "Type conversion functions have -> in their name")
        (<node>
          (<span> (<code> "symbol->string"))
          (<span> (<code> "symbol->keyword"))))))



  (<Section-Doc> name: lexical title: "Lexical Syntax"
    (<description>
      (<definition> name: identifiers title: "Identifiers"
        (<p> "Identifiers in Jazz are case sensitive, thus 'Foo' and 'foo' are treated as separate. "
             "This is commonly used to name a class 'X', and a variable containing an instance of 'X' as 'x'.")
        (<p>)
        (<p> "Identifiers can consist of any alphanumeric character, in addition to the following: "
             (<b> "! $ % & * + - . / : < = > ? ^ _") ". "
             "All of the following are examples of valid identifiers: ")
        (<pre> class: "code"
               "3d-matrix                                                                             \n"
               "Point                                                                                 \n"
               "eqv?                                                                                  \n"
               "^$31337$:a-strange-identifier!                                                        \n"))

      (<definition> name: whitespace title: "Whitespace"
        (<p> "Since spaces, tabs, carriage returns and line feeds are considered whitespace, they can be freely inserted in Jazz code without changing its meaning."
             "Both the following evaluate to 30: ")
        (<pre> class: "code"
               "(* 5 10 (/ 3 5))"          "\n"
                                           "\n"
               "(          *"              "\n"
               "5"                         "\n"
               "10 (/ 3"                   "\n"
               "                5 )   )"   "\n"))

      (<definition> name: comments title: "Comments"
        (<p> "Jazz offers two types of comments:")
        (<node>
          (<span> "; starts a line based comment. It works like # or // in other languages.")
          (<span> "@name, where 'name' can be any symbol, is a powerful means of commenting out entire expressions. "
                  "When placed before an s-exp, that entire s-exp is ignored."))
        (<pre> class: "code"
              "(* 5 10 (/ 3 5))    " (<span> class: "purple" "; this comment has no effect on the preceeding expression") "\n"
                                                                                                                          "\n"
              (<span> class: "gray" "@this-comment-actually-comments-out-the-entire-following-sexp")                      "\n"
              "(* 5 10 (/ 3 5))"                                                                                          "\n"
                                                                                                                          "\n"
              (<span> class: "purple" "; the following expression evaluates to 50 because the ") (<span> class: "gray" "@foo") (<span> class: "purple" " comments out the (/ 3 5)") "\n"
              "(* 5 10 " (<span> class: "gray" "@foo") " (/ 3 5))"                                                        "\n"))))



  (<Section-Doc> name: functional title: "Functional Programming"
    (<description>
        (<definition> title: "Variable value"
          (<p> (<code> "x")))
        (<definition> title: "Function invocation"
          (<p> (<code> "(f ...)")))
        (<p> "Example:")
        (<pre> class: "code"
               (<span> class: "purple" "; define a function that squares its argument")            "\n"
               "(" (<span> class: "blue" "define") " (" (<span> class: "green" "square") " x)"     "\n"
               "  (* x x)"                                                                         "\n"
                                                                                                   "\n"
               (<span> class: "purple" "; now apply it to 2; result is 4")                         "\n"
               "(square 2)"                                                                        "\n")))




    (<Section-Doc> name: functional_syntax title: "Functional Syntax"
      (<Form-Doc> name: definition parameters: "name value"
        (<description>
          (<p> "A definition associates a name to a value within the scope of the module or class it's defined within. "
               "A definition never takes any space in instances.; it is stored in the class itself when defined within one. "
               "At class instantiation, the value is evaluated in empty lexical and object environments.")
          (<pre> class: "code"
                "(" (<span> class: "blue" "definition") " " (<span> class: "green" "PI") " 3.14159265)"   "\n"
                                                                                                          "\n"
                "(" (<span> class: "blue" "definition") " " (<span> class: "green" "circumference")       "\n"
                "  (lambda (diameter) (* diameter PI)))"                                                  "\n"
                                                                                                          "\n"
                "(circumference 10)   " (<span> class: "purple" "; returns 31.4159265"                    "\n")))))



    (<Section-Doc> name: functions title: "Functions"
      (<description>
        (<p> "In Jazz, functions are first-order objects and can be freely manipulated like other objects, including being passed as parameters or stored in variables. "
             "Anyone who says functions are not object-oriented is just showing that they haven't thought enough on the problem! ")
        (<p> "Jazz supports the standard Scheme 'define', as well as 'definition' and 'method'. 'definition' is an extended form of 'define' that supports more features, "
             "and 'method' is used with classes. In the following examples we'll omit 'define'.")
        (<definition> name: function_parameters title: "Parameters"
          (<p> "Parameters can be passed using several techniques in Jazz: ")
          (<p> "Jazz uses the typical positional parameters seen in most languages. It also supports variadic functions and optional keyword parameters. ")
          (<pre> class: "code"
                 (<span> class: "purple" "; standard positional")                                                              "\n"
                 "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "double") " x)"                           "\n"
                 "  (* x x))"                                                                                                  "\n"
                                                                                                                               "\n"
                 "(" (<span> class: "blue" "method") " (" (<span> class: "green" "double") " x)"                               "\n"
                 "  (* x x))"                                                                                                  "\n"
                                                                                                                               "\n"
                 (<span> class: "purple" "; variable number of parameters")                                                    "\n"
                 (<span> class: "purple" "; args is a list containing the passed parameters")                                  "\n"
                 "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "sum") " . args)"                         "\n"
                 "  (apply + args))"                                                                                           "\n"
                                                                                                                               "\n"
                 "(" (<span> class: "blue" "method") " (" (<span> class: "green" "sum") " . args)"                             "\n"
                 "  (apply + args))"                                                                                           "\n"
                 "  (* w h))"                                                                                                  "\n"
                                                                                                                               "\n"
                 (<span> class: "purple" "; in this example 'base' is optional, and defaults to 10")                          "\n"
                 "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "any-log") " number (base 10))"     "\n"
                 "  (/ (log number) (log base)))"                                                                              "\n"
                                                                                                                               "\n"
                 "(" (<span> class: "blue" "method") " (" (<span> class: "green" "any-log") " number (base 10))"         "\n"
                 "  (/ (log number) (log base)))"                                                                              "\n"
                                                                                                                               "\n"
                 (<span> class: "purple" "; optional keyword parameters")                                                      "\n"
                 (<span> class: "purple" "; in this case 'width:' and 'height:' default to 1 when not provided")               "\n"
                 "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "area") " (width: w 1) (height: h 1))"    "\n"
                 "  (* w h))"                                                                                                  "\n"
                                                                                                                               "\n"
                 "(" (<span> class: "blue" "method") " (" (<span> class: "green" "area") " (width: w 1) (height: h 1))"        "\n"))))


    (<Section-Doc> name: syntax_forms title: "Syntax"
    (<Syntax-Doc> name: bind parameters: "variables-tree values-tree expr ..."
      (<description>
        (<p> "This is a little like Scheme's let, but can bind multiple values through pattern-matching; "
             "it takes a tree of identifiers and binds them by pattern-matching against a tree of values. "
             "Bind can also handle variadics. These are best understood by example:")
        (<pre> class: "code"
               (<span> class: "purple" "; not too different from let")                                                     "\n"
               "(bind (x) '(1)      " (<span> class: "purple" "; x is now bound to 1")                                     "\n"
               "  x)                " (<span> class: "purple" "; return 1 from expression")                                "\n"
                                                                                                                           "\n"
               (<span> class: "purple" "; bind a list of identifiers to a list of numbers")                                "\n"
               "(bind (x y) '(1 2)  " (<span> class: "purple" "; x is 1, y is 2")                                          "\n"
               "  (+ x y))          " (<span> class: "purple" "; return 3, the result of x + y")                           "\n"
                                                                                                                           "\n"
               (<span> class: "purple" "; bind a list of identifiers to a tree of numbers")                                "\n"
               "(bind (x y z) '(1 (2 3) ((4)))            " (<span> class: "purple" "; x is 1, y is (2 3), z is ((4))")    "\n"
               "  (+ x (first y) (second y) (caar z)))    " (<span> class: "purple" "; returns 10")                        "\n"
                                                                                                                           "\n"
               (<span> class: "purple" "; bind a tree of identifiers to a tree of numbers -- destructuring them")          "\n"
               "(bind (x (y1 y2) ((z))) '(1 (2 3) ((4)))  " (<span> class: "purple" "; x is 1, y1 is 2, y2 is 3, z is 4")  "\n"
               "  (+ x y1 y2 z))                          " (<span> class: "purple" "; returns 10")                        "\n"
                                                                                                                           "\n"
               (<span> class: "purple" "; variadics")                                                                      "\n"
               "(bind (x . rest) '(1 2 3 4)   " (<span> class: "purple" "; x is 1, rest is (2 3 4)")                       "\n"
               "  (/ (apply + rest) x))       " (<span> class: "purple" "; sum rest, then divide by x; returns 9"          "\n"))))

    (<Syntax-Doc> name: receive parameters: "(variable ...) values expr ..."
      (<description>
        (<p> "It's possible to return multiple values from a Scheme expression using 'values'. "
             "'receive' takes these returned values and binds them to the given identifiers.")
        (<pre> class: "code"
               "(receive (x y) (values 1 2)    " (<span> class: "purple" "; x is 1, y is 2")                                       "\n"
               "  (+ x y))                     " (<span> class: "purple" "; evaluates to 3")                                       "\n"
                                                                                                                                   "\n"
               "(let ((foo (lambda () (values +2 -2))))    " (<span> class: "purple" "; foo will return +2, -2")                   "\n"
               "  (receive (x y) (foo)                     " (<span> class: "purple" "; evaluate foo and assign values to x, y")   "\n"
               "    (+ x y )))                             " (<span> class: "purple" "; returns 0")                                "\n")))

    (<Syntax-Doc> name: quote parameters: "expr"
      (<description>
        (<p> "This turns off the Scheme evaluator and returns its first argument without evaluating it first. "
             "The short form in particular is useful for list literals. This is best understood by example: ")
        (<pre> class: "code"
               "(quote (1 2 3))   " (<span> class: "purple" "; evaluates as (1 2 3)")                                              "\n"
               "'(1 2 3)          " (<span> class: "purple" "; short form, also returns (1 2 3)")                                  "\n"
               "(1 2 3)           " (<span> class: "purple" "; this results in an evaluation error, since 1 is not a procedure")   "\n"
                                                                                                                                   "\n"
               "(quote 12345)     " (<span> class: "purple" "; quoting a value returns that value, so 12345 in this case")         "\n"
               "'12345            " (<span> class: "purple" "; same thing")                                                        "\n")))

    (<Syntax-Doc> name: if parameters: "test yes-expr no-expr ..."
      (<description>
        (<p> "Works much like you'd expect. It requires the yes-expr, but the no-expr is optional (although inadvisable -- use 'when' instead of 'if'). "
             "You'll want to look at 'begin' as well; it's handy in the common case where you'd like to evaluate multiple expressions in a conditional branch. ")
        (<pre> class: "code"
               "(if " (<span> class: "ochre" "#t") " 1 2)       " (<span> class: "purple" "; evaluates as 1")                     "\n"
               "(if " (<span> class: "ochre" "#f") " 1 2)       " (<span> class: "purple" "; evaluates as 2")                     "\n"
               "(if " (<span> class: "ochre" "#t") " 1)         " (<span> class: "purple" "; can also omit the false branch")     "\n"
                                                                                                                                  "\n"
               "(if (&gt; 5 1)"                                                                                                   "\n"
               "    " (<span> class: "purple" "; we use begin here because we're evaluating two expressions:")                    "\n"
               "    (begin (display " (<span> class: "ochre" "\"congratulations!\"") ")"                                          "\n"
               "           " (<span> class: "purple" "; if we omitted begin, then this would accidentally be the false branch:")  "\n"
               "           (display " (<span> class: "ochre" "\"math works on this machine\"") "))"                               "\n"
               "    (display " (<span> class: "ochre" "\"uh-oh!\"") "))                            " (<span> class: "purple" "; the actual false branch") "\n")))

    (<Syntax-Doc> name: when parameters: "test yes-expr ..."
      (<description>
        (<p> "If test is true, all following expressions are evaluated. Similar to if, but doesn't take a false branch and can evaluate multiple expressions without begin.")
        (<pre> class: "code"
              "(when " (<span> class: "ochre" "#f") " (display 1))    " (<span> class: "purple" "; returns #f and displays nothing")  "\n"
              "(when " (<span> class: "ochre" "#t") " (display 1))    " (<span> class: "purple" "; displays 1")                       "\n"
                                                                                                                                      "\n"
              (<span> class: "purple" "; this evaluates multiple expressions")                                                        "\n"
              "(when " (<span> class: "ochre" "#t") " (display " (<span> class: "ochre" "\"The secret of the universe is...\"") ")   " (<span> class: "purple" "; first it shows a sentence") "\n"
              "         42)                                              " (<span> class: "purple" "; then it returns 42")            "\n")))

    (<Syntax-Doc> name: unless parameters: "test no-expr ..."
      (<description>
        (<p> "Works just like 'when', but only evaluates no-expr if test is false. ")
        (<pre> class: "code"
               "(unless " (<span> class: "ochre" "#t") " (display 1))    " (<span> class: "purple" "; returns #f and displays nothing")  "\n"
               "(unless " (<span> class: "ochre" "#f") " (display 1))    " (<span> class: "purple" "; displays 1")                       "\n"
                                                                                                                                         "\n"
               (<span> class: "purple" "; this evaluates multiple expressions")                                                          "\n"
               "(unless " (<span> class: "ochre" "#f") " (display " (<span> class: "ochre" "\"Does this example seem familiar?\"") ")  " (<span> class: "purple" "; first it shows a sentence") "\n"
               "           " (<span> class: "ochre" "\"it should!\"") ")                                 " (<span> class: "purple" "; then it returns a string") "\n")))

    (<Syntax-Doc> name: while parameters: "test expr ..."
      (<description>
        (<p> "Works like a normal while loop -- as long as test is true, it re-evaluates its expressions. ")
        (<pre> class: "code"
               (<span> class: "purple" "; bind counter to 10")                                    "\n"
               "(" (<span> class: "blue" "define") " " (<span> class: "green" "counter") " 10)"   "\n"
                                                                                                  "\n"
               (<span> class: "purple" "; print a count-down from 10 to 0")                       "\n"
               "(while (&gt;= counter 0)"                                                         "\n"
               "  (display counter)"                                                              "\n"
               "  (decrease! counter))   " (<span> class: "purple" "; decrement counter by 1")    "\n")))

    (<Syntax-Doc> name: begin parameters: "expr ..."
      (<description>
        (<p> "Wraps one or more expressions and returns the result of the last one evaluated. Handy when used by special forms like 'if'. ")
        (<pre> class: "code"
               "(begin 1)                   " (<span> class: "purple" "; evaluates to 1")                                  "\n"
               "(begin (* 2 3) (* 4 5))     " (<span> class: "purple" "; returns 20, the result of the last expression")   "\n")))

    (<Syntax-Doc> name: prog1 parameters: "result-expr1 expr ..."
      (<description>
        (<p> "This behaves much like 'begin', evaluating all its expressions, except that it always returns the result of the first evaluated expression, not the last."
             "This is sometimes useful to avoid an explicit temporary variable.")
        (<pre> class: "code"
               "(prog1 (* 2 3))         " (<span> class: "purple" "; returns 6")                                                 "\n"
               "(prog1 (* 2 3) (* 4 5)) " (<span> class: "purple" "; returns 6 -- contrast with the example in 'begin' above")   "\n"
                                                                                                                                 "\n"
               "(prog1 42                                           " (<span> class: "purple" "; returns 42")                    "\n"
               "  (display " (<span> class: "ochre" "\"The secret of the universe is...\"") "))   " (<span> class: "purple" "; but shows string before return") "\n")))
 
    (<Syntax-Doc> name: tie
      (<description>
        (<p> "A convenient way to interpolate strings. If an identifier is bound in the scope where tie is used, the value of the identifier can be interpolated into "
             "the string using {identifier_name}. ")
        (<pre> class: "code"
               "(bind (x y z) '(1 2 3)"                                       "\n"
               "  (tie " (<span> class: "ochre" "\"{x} + {y} = {z}\"") "))"   "\n")))

    (<Syntax-Doc> name: case parameters: "value ((key ...) expr ...) ... (else exp ...)"
      (<description>
        (<p> "This works similar to the switch statement in C-derivatives, except it's more flexible. "
             "A value is given to 'case' which then finds a key that matches, then evaluates the associated expression(s). "
             "The else clause at the end is optional. ")
        (<p> "NB: case uses 'eqv?' to determine the equality of two values. Cetain types of values, like strings and non-empty lists, always return false. "
             "If you need to use 'equal?' or some other sophisticated means of comparison, see 'cond' below. ")
        (<pre> class: "code"
               (<span> class: "purple" "; a toy function that checks whether a number is one of the first ten primes")               "\n"
               (<span> class: "purple" "; in this case it'll evaluate to 'not-prime, since 10 is not one of them")                   "\n"
               "(case 10                                  " (<span> class: "purple" "; take value of 10 and check it against...")    "\n"
               "  ((2 3 5 7 11 13 17 19 23 29) 'prime)    " (<span> class: "purple" "; any of numbers listed are prime")             "\n"
               "  (else 'not-prime))                      " (<span> class: "purple" "; otherwise not a prime")                       "\n"
                                                                                                                                     "\n"
               (<span> class: "purple" "; another example, using symbols -- displays 'edible fruit' and returns 'edible")            "\n"
               "(case 'apple                                                         " (<span> class: "purple" "; match for this")   "\n"
               "  ((carrot lettuce tomato) (display " (<span> class: "ochre" "\"edible vegetable\"") ") 'edible)"                    "\n"
               "  ((pear plum apple)       (display " (<span> class: "ochre" "\"edible fruit\"") ")     'edible)   " (<span> class: "purple" "; this matches") "\n"
               "  ((rock)                  (display " (<span> class: "ochre" "\"yummy rock\"") ")       'in-edible))"                "\n")))
 
    (<Syntax-Doc> name: ecase parameters: "value (key expr ...) ... (else exp ...)"
      (<description>
        (<p> "A specialized version of 'case' that only has one key per branch. This works almost identical to C-derivative switch statements. "
             "It can take an optional else clause. ")
        (<pre> class: "code"
               "(ecase 1                  " (<span> class: "purple" "; matches against 1")                                                  "\n"
               "  (0 (display " (<span> class: "ochre" "\"zero\"") "))"                                                                     "\n"
               "  (1 (display " (<span> class: "ochre" "\"one\"") "))     " (<span> class: "purple" "; takes this branch, displays 'one'")  "\n"
               "  (2 (display " (<span> class: "ochre" "\"two\"") ")))"                                                                     "\n")))

    (<Syntax-Doc> name: typecase parameters: "value ((key ...) expr ...) ... (else exp ...)"
      (<description>
        (<p> "Like 'case', except matches on the object type of the value. ")
        (<pre> class: "code"
               "(typecase " (<span> class: "ochre" "\"this is a string\"") "     " (<span> class: "purple" "; value to match is a String")     "\n"
               "  ((List)           1)"                                                                                                        "\n"
               "  ((String)         2)           " (<span> class: "purple" "; matches String class, returns 2")                                "\n"
               "  ((Number Symbol)  3)"                                                                                                        "\n"
               "  (else             4))"                                                                                                       "\n"
                                                                                                                                               "\n"
               (<span> class: "purple" "; another example, testing an object for a class type from most- to least-specific")                   "\n"
               "(typecase 1+2i                                     " (<span> class: "purple" "; value to match is a Complex")                  "\n"
               "  ((Rational)  (display " (<span> class: "ochre" "\"this is a rational\"") "))"                                                "\n"
               "  ((Number)    (display " (<span> class: "ochre" "\"this is a number\"") "))       " (<span> class: "purple" "; matches here") "\n"
               "  ((Object)    (display " (<span> class: "ochre" "\"this is an object\"") ")))"                                                "\n")))

    (<Syntax-Doc> name: cond parameters: "(test exp) ... (else exp)"
      (<description>
        (<p> "Somewhat like case, but much more flexible. 'cond' does not take a value, but rather tests a series of expressions until it finds one that evaluates to true, "
             "then evaluates the branch of expressions associated with it. It can take an optional else clause. ")
        (<pre> class: "code"
               (<span> class: "purple" "; returns the absolute value of a number")                                 "\n"
               "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "abs") " n)"                    "\n"
               "  (cond"                                                                                           "\n"
               "    ((&lt; n 0) (* -1 n))  " (<span> class: "purple" "; if n &lt; 0, multiply by -1 and return")   "\n"
               "    ((&gt; n 0) n)         " (<span> class: "purple" "; if n &gt; 0, return n")                    "\n"
               "    (else 0)))          " (<span> class: "purple" "; otherwise return 0")                          "\n"
                                                                                                                   "\n"
               (<span> class: "purple" "; same function without the else clause")                                  "\n"
               "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "abs") " n)"                    "\n"
               "  (cond"                                                                                           "\n"
               "    ((&lt; n 0) (* -1 n))  " (<span> class: "purple" "; if n &lt; 0, multiply by -1 and return")   "\n"
               "    ((&gt;= n 0) n)))      " (<span> class: "purple" "; if n &gt;= 0, return n")                   "\n")))

    (<Syntax-Doc> name: set! parameters: "variable expr"
      (<description>
        (<p> "Changes the value an existing identifier is bound to. This is the same as assignment in other languages. ")
        (<pre> class: "code"
               "(" (<span> class: "blue" "definition") " " (<span> class: "green" "a-variable") " 10)                      " (<span> class: "purple" "; bind a-variable to 10") "\n"
               "(set! a-variable 25)                            " (<span> class: "purple" "; a-variable is now 25")          "\n"
               "(set! a-variable (/ a-variable 2))              " (<span> class: "purple" "; a-variable is now 25/2")        "\n"
               "(set! a-variable (number-&gt;string a-variable))   " (<span> class: "purple" "; a-variable is now '25/2'")   "\n")))

    (<Syntax-Doc> name: increase! parameters: "variable expr {value}"
      (<description>
        (<p> "Increments a variable. This is a short-hand for (set! foo (+ foo 1)). ")
        (<pre> class: "code"
               "(" (<span> class: "blue" "definition") " " (<span> class: "green" "a-variable") " 10)     " (<span> class: "purple" "; bind a-variable to 10") "\n"
               "(increase! a-variable)         " (<span> class: "purple" "; a-variable is now 11")                 "\n"
               "(increase! a-variable)         " (<span> class: "purple" "; a-variable is now 12")                 "\n"
               "(increase! a-variable 8)       " (<span> class: "purple" "; increase by 8, a-variable is now 20")  "\n")))

    (<Syntax-Doc> name: decrease! parameters: "variable expr {value}"
      (<description>
        (<p> "Decrements a variable. This is a short-hand for (set! foo (- foo 1)). ")
        (<pre> class: "code"
               "(" (<span> class: "blue" "definition") " " (<span> class: "green" "a-variable") " 10)     " (<span> class: "purple" "; bind a-variable to 10") "\n"
               "(decrease! a-variable)         " (<span> class: "purple" "; a-variable is now 9")                  "\n"
               "(decrease! a-variable)         " (<span> class: "purple" "; a-variable is now 8")                  "\n"
               "(decrease! a-variable 3)       " (<span> class: "purple" "; decrease by 3, a-variable is now 5")   "\n")))

    (<Syntax-Doc> name: let parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "'let' is a powerful tool that avoids most of the problems that assignment has in lesser languages (ahem); variable dependencies and scope are more explicit, "
              "uninitialized identifiers are unlikely and unidentified identifiers are caught at compile-time. ")
        (<p> "'let' binds a set of identifers to a set of evaluations before evaluating the main body. If the same identifier is in use before a 'let', its old value is shadowed "
             "only within the body of that 'let'. Note that within the section that binds values, evaluations that bind to prior let bindings cannot be used "
             "(see 'let*' and 'letrec' instead). 'let' is best understood by demonstation: ")
        (<pre> class: "code"
               "(let ((x 1)    " (<span> class: "purple" "; x is bound to 1")                                                 "\n"
               "      (y 2))   " (<span> class: "purple" "; y is bound to 2")                                                 "\n"
               "  (+ x y))     " (<span> class: "purple" "; evaluates to 3")                                                  "\n"
                                                                                                                              "\n"
               (<span> class: "purple" "; a more complicated example")                                                        "\n"
               "(let ((list-1 (list (* 2 3) (+ 4 5)))           " (<span> class: "purple" "; list-1 is bound to (5 9)")       "\n"
               "      (list-2 '(12 14 15))                      " (<span> class: "purple" "; list-2 is bound to (12 14 15)")  "\n"
               "      (list-3 '(1)))                            " (<span> class: "purple" "; list-3 is bound to (1)")         "\n"
               "  (display list-1)                              " (<span> class: "purple" "; display (5 9)")                  "\n"
               "  (display list-2)                              " (<span> class: "purple" "; display (12 14 15)")             "\n"
                                                                                                                              "\n"
               "  " (<span> class: "purple" "; list-1 is rebound to (5 9 12 14 15 1)")                                        "\n"
               "  (let ((list-1 (append list-1 list-2 list-3)))"                                                              "\n"
               "    (display list-1))                           " (<span> class: "purple" "; display (5 9 12 14 15 1)")       "\n"
                                                                                                                              "\n"
               "  " (<span> class: "purple" "; since we've left the prior let, list-1 is back to (5 9)")                      "\n"
               "  (display list-1))"                                                                                          "\n")))
  
    (<Syntax-Doc> name: let* parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "This works like let, but after an identifier is bound you can use it in following lines binding variables. ")
        (<pre> class: "code"
               "(let* ((x 1)            " (<span> class: "purple" "; x is bound to 1")                                            "\n"
               "       (y (+ x 2))      " (<span> class: "purple" "; note that x is now a valid identifier, so y is bound to 3")  "\n"
               "       (z (/ x y)))     " (<span> class: "purple" "; x and y are both bound here, so z is 1/3")                   "\n"
               "  (+ x y z))            " (<span> class: "purple" "; returns 13/3")                                               "\n")))

    (<Syntax-Doc> name: letrec parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "One of the limitations of 'let' is that it won't allow you to write recursive functions. An identifier is not bound until after its associated "
             "expression is evaluated. Unfortunately, recursive functions require an identifier to exist during definition. 'letrec' allows you to refer to an "
             "expression's identifier during evaluation. ")
       (<pre> class: "code"
              (<span> class: "purple" "; this here is a function that benchmarks function f count times")                           "\n"
              "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "bench-times") " f count)"                        "\n"
              "  " (<span> class: "purple" "; start the definition of the function assigned to 'times'")                            "\n"
              "  (letrec ((times (lambda (f remaining)"                                                                           "\n"
              "                    (when (&gt; remaining 0)"                                                                        "\n"
              "                      (f)"                                                                                           "\n"
              "                      " (<span> class: "purple" "; notice that 'times' is used here recursively, even though the")   "\n"
              "                      " (<span> class: "purple" "; definition is not yet complete:")                                 "\n"
              "                      (times f (- remaining 1))))))"                                                                 "\n"
              "    (time (times f count))))"                                                                                        "\n")))

    (<Syntax-Doc> name: catch parameters: "(type variable expr ...) expr ..."
      (<description>
        (<p> "Evaluates expressions, and if an exception is thrown that matches the exception type, evaluates the catch expressions. ")
        (<pre> class: "code"
               (<span> class: "purple" "; the exception we'll catch, and an identifier to bind it to")                                   "\n"
               "(catch (Server-Error error"                                                                                              "\n"
               "         " (<span> class: "purple" "; these two lines are evaluated when a Server-Error is caught")                      "\n"
               "         (display " (<span> class: "ochre" "\"Caught exception: \"") ")"                                                 "\n"
               "         (display error))"                                                                                               "\n"
               "  " (<span> class: "purple" "; the next three lines are where we can catch exceptions")                                  "\n"
               "  (display " (<span> class: "ochre" "\"Before exception. \\n\"") ")"                                                     "\n"
               "  (throw (new Server-Error))                " (<span> class: "purple" "; throw a Server-Error")                          "\n"
               "  (display " (<span> class: "ochre" "\"Should never get here... \"") "))  " (<span> class: "purple" "; never executed")  "\n"
                                                                                                                                         "\n"
               (<span> class: "purple" "; a simple version that doesn't do anything when it catches an exception")                       "\n"
               "(catch Server-Error"                                                                                                     "\n"
               "  (display " (<span> class: "ochre" "\"Before exception. \\n\"") ")"                                                     "\n"
               "  (throw (new Server-Error))"                                                                                            "\n"
               "  (display " (<span> class: "ochre" "\"Should never get here... \"") "))"                                                "\n")))

    (<Syntax-Doc> name: throw parameters: "value"
      (<description>
        (<p> "Raises an exception. Please see the catch example above. ")))

    (<Syntax-Doc> name: unwind-protect parameters: "protected-expr protection-expr ..."
      (<description>
        (<p> "If you need perform some expressions regardless of whether an exception occurs, this is a nice way to do it; it is similar to 'finally' in Java or Python. "
             "'unwind-protect' takes two expressions, one which it will attempt to evaluate, and another which it will always evaluate. "
             "If an exception occurs during the first evaluation attempt, the second will still be run. This is particularly useful when "
             "dealing with external resources like files or sockets; regardless of whether an error occurs while writing to a file, you can "
             "ensure it's closed before returning or unwinding the stack due to an exception. " )
        (<pre> class: "code"
               (<span> class: "purple" "; both the following examples display 'after'")                                         "\n"
               "(catch Server-Error"                                                                                            "\n"
               "  (unwind-protect"                                                                                              "\n"
               "    (throw (new Server-Error))     " (<span> class: "purple" "; expression to attempt evaluation")              "\n"
               "    (display " (<span> class: "ochre" "\"after\"") ")))          " (<span> class: "purple" "; expression to always evaluate at the end") "\n"
                                                                                                                                "\n"
               "(catch Server-Error"                                                                                            "\n"
               "  (unwind-protect"                                                                                              "\n"
               "    " (<span> class: "purple" "; in this case an exception isn't thrown, but 'after' will still be displayed")  "\n"
               "    (* 2 3)"                                                                                                    "\n"
               "    (display " (<span> class: "ochre" "\"after\"") ")))"                                                        "\n")))

    (<Syntax-Doc> name: lambda parameters: "parameters-list expr ..."
      (<description>
        (<p> "An anonymous function. "
             "It binds the parameters with the passed arguments, then evaluates the body. This is particuarly useful with 'let' and higher-order functions. " )
        (<pre> class: "code"
              (<span> class: "purple" "; short-hand way to define a function")                                                    "\n"
              "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "inverse-sum") " . numbers)"                    "\n"
              "  (/ 1 (apply + numbers)))"                                                                                        "\n"
                                                                                                                                  "\n"
              (<span> class: "purple" "; actually, it's syntactic sugar for assigning an anonymous function to an identifier")    "\n"
              (<span> class: "purple" "; this is the same as the above function")                                                 "\n"
              "(" (<span> class: "blue" "definition") " " (<span> class: "green" "inverse-sum")                                   "\n"
              "  (function numbers"                                                                                               "\n"
              "     (/ 1 (apply + numbers))))"                                                                                    "\n"
                                                                                                                                  "\n"
              (<span> class: "purple" "; map is a higher-order function that applies the given function to each member of a")     "\n"
              (<span> class: "purple" "; list, returning a new list. In this case we're squaring a list of numbers, which")       "\n"
              (<span> class: "purple" "; evaluates to (1 4 9 16 25 36 49 64 81 100)")                                             "\n"
              "(map (lambda (x)"                                                                                                "\n"
              "       (* x x))"                                                                                                   "\n"
              "  '(1 2 3 4 5 6 7 8 9 10))"                                                                                        "\n"
                                                                                                                                  "\n"
              (<span> class: "purple" "; there are several ways to pass arguments to lambda -- if you omit the parens around")    "\n"
              (<span> class: "purple" "; the parameters, it becomes a variadic")                                                  "\n"
              "(let ((foo (lambda x x)))"                                                                                       "\n"
              "  " (<span> class: "purple" "; all the arguments -- 1 2 3 4 5 -- are pushed into x, thus returning the")           "\n"
              "  " (<span> class: "purple" "; list (1 2 3 4 5)")                                                                  "\n"
              "  (foo 1 2 3 4 5))"                                                                                                "\n"
                                                                                                                                  "\n"
              (<span> class: "purple" "; if you keep the parens around the parameters, it behaves like normal positional")        "\n"
              (<span> class: "purple" "; parameters")                                                                             "\n"
              "(let ((foo (lambda (x y) x)))   " (<span> class: "purple" "; returns only the first of two required arguments")  "\n"
              "  (foo 1 2))                      " (<span> class: "purple" "; evaluates to 1")                                    "\n"
                                                                                                                                  "\n"
              (<span> class: "purple" "; and you can mix the two, but placing a '.' between the required args and the rest")      "\n"
              "(let ((foo (lambda (f . numbers)   " (<span> class: "purple" "; f is required, everything else goes in numbers") "\n"
              "             (apply f numbers))))    " (<span> class: "purple" "; turns numbers into the arguments for f")         "\n"
              "  " (<span> class: "purple" "; f binds to +, numbers binds to (1 2 3 4 5)")                                        "\n"
              "  (foo + 1 2 3 4 5))                 " (<span> class: "purple" "; the result is the sum of the numbers, 15")       "\n")))

    (<Syntax-Doc> name: and parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true unless one of its expressions are false. It will stop as soon as it encounters a false value and return false. ")
        (<p> "It differs from R5RS 'and' since it only guarantees that a returned true value will be true, not the last evaluated value. If you want R5RS semantics, "
             "use 'essay'. ")
        (<p> "Some examples: ")
        (<pre> class: "code"
               "(and)                      " (<span> class: "purple" "; returns true")                                 "\n"
               "(and 1)                    " (<span> class: "purple" "; returns true")                                 "\n"
               "(and 1 2 3)                " (<span> class: "purple" "; returns true")                                 "\n"
               "(and 1 " (<span> class: "ochre" "#f") ")                 " (<span> class: "purple" "; returns false")  "\n"
               "(and true (= 2 (+ 1 1)))   " (<span> class: "purple" "; returns true")                                 "\n"
                                                                                                                       "\n"
               (<span> class: "purple" "; will not signal an error because the first test will fail:")                 "\n"
               "(and (symbol-bound? 'not-a-bound-variable) not-a-bound-variable)"                                      "\n")))

    (<Syntax-Doc> name: or parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return false unless any of the expressions are true. It will stop as soon as it encounters a true value and return true. ")
        (<p> "It differs from R5RS 'or' since it only guarantees that a returned true value will be true, not the first non-#f value. If you want R5RS "
             "semantics, use 'either'. ")
        (<pre> class: "code"
               "(or)         " (<span> class: "purple" "; false")                                                               "\n"
               "(or 1)       " (<span> class: "purple" "; true")                                                                "\n"
               "(or " (<span> class: "ochre" "#f") " " (<span> class: "ochre" "#f") " 3) " (<span> class: "purple" "; true")    "\n"
                                                                                                                                "\n"
               (<span> class: "purple" "; one simple application of the fact that 'or' stops as soon as it encounters a true")  "\n"
               (<span> class: "purple" "; value is in very clean code for managing simple lazy structures.")                    "\n"
               "(" (<span> class: "blue" "define") " " (<span> class: "green" "a-big-structure-only-on-demand") " nil)"         "\n"
               "(" (<span> class: "blue" "define") " (" (<span> class: "green" "get-structure") ")"                             "\n"
               "  (or a-big-structure-only-on-demand"                                                                           "\n"
               "      (set! a-big-structure-only-on-demand (new-structure))))"                                                  "\n")))
  
    (<Syntax-Doc> name: assert parameters: "asserted-expr"
      (<description>
        (<p> "Asserts the expression is true. If the expression returns false, an exception is thrown. ")
        (<pre> class: "code"
               "(assert " (<span> class: "ochre" "#t") ")           " (<span> class: "purple" "; nothing happens")  "\n"
               "(assert (* 12 82 54)) " (<span> class: "purple" "; nothing happens")                                "\n"
               "(assert (zero? 10))   " (<span> class: "purple" "; exception is raised")                            "\n"))))

  (<Section-Doc> name: units title: "Units"
    (<Form-Doc> name: unit parameters: "modifier unit-name expr ..."
      (<description>
        (<p> "A unit is effectively a named bundle of code in a file. Units can be automatically located and loaded by name, and the kernel ensures they're "
             "only loaded once. They can also load other units into their namespace. Unit names roughly match their filesystem path inside a package. "
              "'unit' is primarily used in pure-scheme files, as is 'require' which is often used with 'unit'; Jazz files use 'module' and 'import' (see below). ")
        (<pre> class: "code"
          (<span> class: "purple" "; in file example/foo.scm")                                              "\n"
          "(" (<span> class: "blue" "unit") " " (<span> class: "green" "example.foo")                     "\n"
          "  (" (<span> class: "blue" "define") " (" (<span> class: "green" "hello-foo") ")"                "\n"
          "    (display " (<span> class: "ochre" "\"Hello Foo!\"") ")))"                                    "\n"
                                                                                                            "\n"
          (<span> class: "purple" "; in file example/bar.scm")                                              "\n"
          "(" (<span> class: "blue" "unit") " " (<span> class: "green" "example.bar")                     "\n"
          "  (" (<span> class: "blue" "require") " (example.foo))       " (<span> class: "purple" "; pull in code from example.foo unit just above") "\n"
                                                                                                            "\n"
          "  (" (<span> class: "blue" "define") " (" (<span> class: "green" "hello-bar") ")"                "\n"
          "    (hello-foo)                 " (<span> class: "purple" "; hello-foo comes from example.foo")  "\n"
          "    (display " (<span> class: "ochre" "\"Hello Bar!\"") ")))"                                    "\n")))

    (<Form-Doc> name: module parameters: "module-name dialect ..."
      (<description>
        (<p> "A module is a unit that implements a specific dialect -- scheme or jazz. Whereas 'unit' is normally used with Scheme files, Jazz file always "
             "use 'module', and sometimes Scheme files do as well. Since modules are a superset of units, they are also automatically located and loaded "
             "by name, and the kernel ensures they're only loaded once. Modules offer the ability to export and import only specific definitions and are "
             "preferable to plain units. They're loaded with 'import'. ")
        (<pre> class: "code"
               (<span> class: "purple" "; this example assumes we're also using example/foo.scm and example/bar.scm from")                  "\n"
               (<span> class: "purple" "; 'unit' just above")                                                                             "\n"
                                                                                                                                            "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example.xyzzy") " jazz"                                     "\n"
               "  " (<span> class: "purple" "; note that this definition has a 'public' modifier -- no modifier defaults to")               "\n"
               "  " (<span> class: "purple" "; private and wouldn't export")                                                                "\n"
               "  (" (<span> class: "blue" "definition") " " (<span> class: "blue" "public") " (" (<span> class: "green" "hello-xyzzy") ")" "\n"
               "    (display " (<span> class: "ochre" "\"Hello Xyzzy!\"") ")))"                                                             "\n"
                                                                                                                                            "\n"
               (<span> class: "purple" "; in example/quux.jazz")                                                                            "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example.quux") " jazz"                                      "\n"
               "  " (<span> class: "purple" "; when example.quux is imported, it'll also import example.xyzzy, not just the")               "\n"
               "  " (<span> class: "purple" ";definitions inside example.quux")                                                             "\n"
               "  (" (<span> class: "blue" "export") " (example.xyzzy))"                                                                    "\n"
                                                                                                                                            "\n"
               "  (" (<span> class: "blue" "definition") " " (<span> class: "blue" "public") " (" (<span> class: "green" "hello-quux") ")"  "\n"
               "    (display " (<span> class: "ochre" "\"Hello Quux!\"") ")))"                                                              "\n"
                                                                                                                                            "\n"
               (<span> class: "purple" "; in example/baz.jazz")                                                                             "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example.baz") " jazz"                                       "\n"
               "  " (<span> class: "purple" "; this is used to import pure scheme code:")                                                   "\n"
               "  (" (<span> class: "blue" "require") " (example.bar))"                                                                     "\n"
               "  " (<span> class: "purple" "; Jazz doesn't know about 'require'd pure scheme definitions, so this tells it")               "\n"
               "  " (<span> class: "purple" "; what to import from example.bar:")                                                           "\n"
               "  (" (<span> class: "blue" "native") " " (<span> class: "green" "hello-bar") ")"                                            "\n"
               "  " (<span> class: "purple" "; this imports what example.quux exports -- its public definitions and the public")            "\n"
               "  " (<span> class: "purple" "; definitions of example.xyzzy")                                                               "\n"
               "  (" (<span> class: "blue" "import") " (example.quux))"                                                                     "\n"
                                                                                                                                            "\n"
               "  (" (<span> class: "blue" "definition") " (" (<span> class: "green" "run") " descriptor)"                                  "\n"
               "    (hello-bar)                       " (<span> class: "purple" "; displays 'Hello Foo!' 'Hello Bar!'")                     "\n"
               "    (hello-quux)                      " (<span> class: "purple" "; displays 'Hello Quux!'")                                 "\n"
               "    (hello-xyzzy))                    " (<span> class: "purple" "; displays 'Hello Xyzzy!'")                                "\n"
                                                                                                                                            "\n"
               (<span> class: "purple" "  ; see 'products' below for details -- this is a detail unrelated to modules:")                  "\n"
               "  (register-product 'baz"                                                                                                   "\n"
               "    title: " (<span> class: "ochre" "\"Baz\"")                                                                              "\n"
               "    run: run))"                                                                                                             "\n")
        
        (<p> "'import' and 'export' can both be conditional. If an identifier exists during compilation, it can be used to decide what to export. ")
        (<pre> class: "code"
               (<span> class: "purple" "; 'x11', 'windows' and 'carbon' identify which platform the code is running on")                   "\n"
                                                                                                                                           "\n"
               (<span> class: "purple" "; in example-b/carbon.jazz")                                                                       "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example-b.carbon") " jazz"                                 "\n"
               "  (" (<span> class: "blue" "definition") " " (<span> class: "blue" "public") " (" (<span> class: "green" "what-am-i") ")"  "\n"
               "    (display " (<span> class: "ochre" "\"carbon\"") ")))"                                                                  "\n"
                                                                                                                                           "\n"
               (<span> class: "purple" "; in example-b/windows.jazz")                                                                      "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example-b.windows") " jazz"                                "\n"
               "  (" (<span> class: "blue" "definition") " " (<span> class: "blue" "public") " (" (<span> class: "green" "what-am-i") ")"  "\n"
               "    (display " (<span> class: "ochre" "\"windows\"") ")))"                                                                 "\n"
                                                                                                                                           "\n"
               (<span> class: "purple" "; in example-b/x11.jazz")                                                                          "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example-b.x11") " jazz"                                    "\n"
               "  (" (<span> class: "blue" "definition") " " (<span> class: "blue" "public") " (" (<span> class: "green" "what-am-i") ")"  "\n"
               "    (display " (<span> class: "ochre" "\"x11\"") ")))"                                                                     "\n"
                                                                                                                                           "\n"
               (<span> class: "purple" "; in example-b/product.jazz")                                                                      "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "example-b.product") " jazz"                                "\n"
                                                                                                                                           "\n"
               "  (" (<span> class: "blue" "import") " (example-b.carbon  (cond carbon))  " (<span> class: "purple" "; import this file if on straight Mac") "\n"
               "          (example-b.windows (cond windows)) " (<span> class: "purple" "; import this file if on Windowss")                "\n"
               "          (example-b.x11     (cond x11)))    " (<span> class: "purple" "; import this file if using X11")                  "\n"
                                                                                                                                           "\n"
               "  (" (<span> class: "blue" "definition") " (" (<span> class: "green" "run") " descriptor)"                                 "\n"
               "    " (<span> class: "purple" "; what-am-i was only imported from one, so displays your platform")                         "\n"
               "    (what-am-i))"                                                                                                          "\n"
                                                                                                                                           "\n"
               "  " (<span> class: "purple" "; see 'products' below for details -- this is a detail unrelated to modules")               "\n"
               "  (register-product 'baz"                                                                                                  "\n"
               "    title: " (<span> class: "ochre" "\"Example-B\"")                                                                       "\n"
               "    run: run))"                                                                                                            "\n"))))
  
  (<Section-Doc> name: object-oriented title: "Object-Oriented Programming"
    (<Section-Doc> name: classes title: "Classes"
      (<description>
        (<p> "Jazz supports a single-inheritance object system with multiple interfaces, similar to Java. "
             "The root class -- from which all classes eventually inherit -- is 'Object'. Jazz's object system is fairly dynamic, "
             "but with some restrictions: methods can be dynamically added at runtime, but slots cannot. Dynamically adding methods "
             "is a useful but sharp tool, so please only use this with caution; avoid 'monkey-patching'. " )
        (<p> "Classes can only be defined at the module level.")
        (<p> "A basic example of a class and its use: ")
        (<pre> class: "code"
               (<span> class: "purple" "; in class-example/Example.jazz:")                                                                   "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "class-example.ExampleClass") " jazz"                         "\n"
                                                                                                                                             "\n"
               "(" (<span> class: "blue" "import") " (jazz.tie))                " (<span> class: "purple" "; so we can use (tie ...)") "\n"
                                                                                                                                             "\n"
               (<span> class: "purple" "; defining 'ExampleCass', inherits from 'Object'")                                                   "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ExampleClass") " " (<span> class: "blue" "extends") " Object"  "\n"
                                                                                                                                             "\n"
               "  " (<span> class: "purple" "; instance variable 'name', initializes to empty string")                                       "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "name") " " (<span> class: "blue" "initialize") " " (<span> class: "ochre" "\"\"") ")" "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "initialize") " a-name)      " (<span> class: "purple" "; the constructor -- takes a single argument") "\n"
               "    (nextmethod)                   " (<span> class: "purple" "; invoke the constructor of the parent class first")           "\n"
               "    (randomize)                    " (<span> class: "purple" "; seed the random function")                                   "\n"
               "    (set! name a-name))            " (<span> class: "purple" "; change the value of 'name' to the given argument")           "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-hi") ")           " (<span> class: "purple" "; public method") "\n"
               "    (display (tie " (<span> class: "ochre" "\"Hi, {name}!\\n\"") ")))    " (<span> class: "purple" "; display greeting with the value of 'name'") "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-bye") ")"      "\n"
               "    (display " (<span> class: "ochre" "\"Bye!\\n\"") "))"                                                                    "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-a-number") ")" "\n"
               "    " (<span> class: "purple" "; method calls -within- a class behave like normal function calls")                           "\n"
               "    (display (make-a-random-prime))"                                                                                         "\n"
               "    (display " (<span> class: "ochre" "\"\\n\"") "))"                                                                        "\n"
                                                                                                                                             "\n"
               "  " (<span> class: "purple" "; this method defaults to private, so cannot be accessed outside class")                        "\n"
               "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "make-a-random-prime") ")"                                  "\n"
               "    (let ((primes      '(2 3 5 7 11 13 17 19 23 29))"                                                                        "\n"
               "          (prime-index (random 10)))"                                                                                        "\n"
               "      (element primes prime-index)))    " (<span> class: "purple" "; fetch randomly one of the first ten primes")            "\n"
                                                                                                                                             "\n"
               "))"                                                                                                                          "\n"
                                                                                                                                             "\n"
                                                                                                                                             "\n"
               (<span> class: "purple" "; in class-example/product.jazz")                                                                    "\n"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "class-example.product") " jazz"                              "\n"
                                                                                                                                             "\n"
               "(" (<span> class: "blue" "import") " (class-example.ExampleClass))"                                                          "\n"
                                                                                                                                             "\n"
               "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "run") " descriptor)"                                     "\n"
               "  (let ((example (new ExampleClass " (<span> class: "ochre" "\"Jane Doe\"") "))) " (<span> class: "purple" "; create new ExampleClass") "\n"
               "    " (<span> class: "purple" "; '~' appended to method name invokes method on passed object")                               "\n"
               "    (display-hi~       example)"                                                                                             "\n"
               "    (display-a-number~ example)"                                                                                             "\n"
               "    (display-bye~      example)))"                                                                                           "\n"
                                                                                                                                             "\n"
               (<span> class: "purple" "; see 'products' below for details -- this is a detail unrelated to modules")                      "\n"
               "(register-product 'class-example"                                                                                            "\n"
               "  title: " (<span> class: "ochre" "\"Class-Example\"")                                                                       "\n"
               "  run: run))"                                                                                                                "\n")))
        
    (<Form-Doc> name: slot parameters: "name <initialize> <initial-value>"
      (<description>
        (<p> "A slot is an object instance variable. The set of slots in a class defines the structure of the class's instances, "
             "thus the data that each instance can store. ")
        (<p> "Initialization of a slot is optional, but always initializing is safer. If it's not initialized, it'll default to #f.")
        (<pre> class: "code"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "Point") " " (<span> class: "blue" "extends") " Object"   "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "graph-id") ")            " (<span> class: "purple" "; when a Point object is created, this isn't initialized") "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "x") " " (<span> class: "blue" "initialize") " 0)      " (<span> class: "purple" "; but the following three are initialized to 0") "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "y") " " (<span> class: "blue" "initialize") " 0)"       "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "z") " " (<span> class: "blue" "initialize") " 0))"      "\n")))

    (<Form-Doc> name: property parameters: "name <initialize> <initial-value> <getter> <getter-name> <setter> <setter-name>"
      (<description>
        (<p> "A property is a slot that can specify a getter and a setter. While this can be a short-cut for writing the getter and setter methods "
             "yourself, by using 'accessors generate' (see example), it also provides metadata to the system while is needed for object literals. ")
        (<p> "As with slots, initialization is optional, but it's safer to do so. They default to #f if not explicitly initialized. " )
        (<pre> class: "code"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ExamplePoint") " " (<span> class: "blue" "extends") " Object"  "\n"
               "  " (<span> class: "purple" "; similar to (slot foo):")                                                                      "\n"
               "  (" (<span> class: "blue" "property") " " (<span> class: "green" "foo") ")"                                                 "\n"
               "  " (<span> class: "purple" "; makes slot 'x' and 'get-x', 'set-x' methods:")                                                "\n"
               "  (" (<span> class: "blue" "property") " " (<span> class: "green" "x") " " (<span> class: "blue" "accessors") " generate)"   "\n"
               "  " (<span> class: "purple" "; similar to 'x', but initializes slot 'y' to 0:")                                              "\n"
               "  (" (<span> class: "blue" "property") " " (<span> class: "green" "y") " " (<span> class: "blue" "initialize") " 0 " (<span> class: "blue" "accessors") " generate)" "\n"
               "  " (<span> class: "purple" "; specifies names of implemented getter and setter:")                                           "\n"
               "  (" (<span> class: "blue" "property") " " (<span> class: "green" "z") " " (<span> class: "blue" "getter") " get-z " (<span> class: "blue" "setter") " set-z)" "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "get-z") ")"            "\n"
               "    z)"                                                                                                                      "\n"
                                                                                                                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "set-z") " z)"          "\n"
               "    " (<span> class: "purple" "; 'z~self' refers to object's slot 'z' to disambiguate with local variable 'z'")              "\n"
               "    (set! z~self z)))"                                                                                                       "\n")))

    (<Form-Doc> name: method parameters: "{modifiers} (name . parameters) {return-type} . body"
      (<description>
        (<p> "A method is where an object's code resides. A method is effectively a function that works with objects. ")
        (<pre> class: "code"
               (<span> class: "purple" "; a robot that says what it thinks")                                                              "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "Robot")                                                     "\n"
               "  " (<span> class: "purple" "; since no modifier present, defaults to private")                                           "\n"
               "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "think") ")"                                             "\n"
               "    " (<span> class: "ochre" "\"EXTERMINATE! EXTERMINATE!\"") ")             " (<span> class: "purple" "; evaluates to a string") "\n"
                                                                                                                                          "\n"
               "  " (<span> class: "purple" "; modifier says it's a public method with a single argument: 'name'")                        "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "speak") " name)"    "\n"
               "    (display (tie " (<span> class: "ochre" "\"Attention, {name}!\\n\"") "))   " (<span> class: "purple" "; greets user")  "\n"
               "    (diplay  (think))))                      " (<span> class: "purple" "; says what it thinks (exterminate!)")            "\n")))

    (<Form-Doc> name: methods title: "Method invocation"
      (<description>
        (<p> "A method looks exactly like a function call when invoking from within the same class where it is defined. When called "
             "from outside, a tilde (~) is appended to the method name and the object is passed as the first argument; remaining arguments "
             "are passed after it. The scope within which a method can be called is affected by modifiers in the definition. ")
        (<pre> class: "code"
               (<span> class: "purple" "; invokes method 'display-hi' on object 'foo'")                                       "\n"
               "(display-hi~ foo)"                                                                                            "\n"
                                                                                                                              "\n"
               (<span> class: "purple" "; couple of method calls, the first returning an object that's used for the second")  "\n"
               "(invalidate-view~ (get-parent~ view))"                                                                        "\n")))
    
    (<Section-Doc> name: interfaces title: "Interfaces"
      (<description>
        (<p> "Jazz interfaces work much like Java interfaces. An interface describe an API that classes using that interface promise to "
             "implement. The descriptive quality of interfaces must be emphasized -- they only describe the external interface -- "
             "i.e. methods that must be present and can be called -- but they do not implement the code necessary for API to actually function; "
             "that must be done by the classes implementing the interface.")
        (<p> "Interfaces can only contain abstract methods. While a class can only inherit from a single parent, it can implement "
             "many interfaces. Like classes, interfaces can only be defined within modules.")
        (<pre> class: "code"
               "(" (<span> class: "blue" "module") " " (<span> class: "green" "class-example.DangerousGerbil") " jazz"   "\n"
                                                                                                                          "\n"
               (<span> class: "purple" "; all animals must have a sound, appearance and action methods")                  "\n"
               "(" (<span> class: "blue" "interface") " " (<span> class: "green" "Animal")                                "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "virtual") " " (<span> class: "blue" "abstract") " (" (<span> class: "green" "sound") "))" "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "virtual") " " (<span> class: "blue" "abstract") " (" (<span> class: "green" "appearance") "))" "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "virtual") " " (<span> class: "blue" "abstract") " (" (<span> class: "green" "action") ")))" "\n"
                                                                                                                          "\n"
               (<span> class: "purple" "; anything dangerous must have a weapon")                                         "\n"
               "(" (<span> class: "blue" "interface") " " (<span> class: "green" "Dangerous")                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "virtual") " " (<span> class: "blue" "abstract") " (" (<span> class: "green" "weapon") ")))" "\n"
                                                                                                                          "\n"
               (<span> class: "purple" "; here we have a class of gerbils -- dangerous animals!")                         "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "DangerousGerbil") " " (<span> class: "blue" "extends") " Object " (<span> class: "blue" "implements") " Dangerous Animal" "\n"
               "  " (<span> class: "purple" "; these methods are overrides of the interface's virtual methods -- if a method is") "\n"
               "  " (<span> class: "purple" "; virtual, any class that inherits and overrides it must explicitly state")  "\n"
               "  " (<span> class: "purple" "; 'override' (just like in C#)")                                             "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "override") " (" (<span> class: "green" "sound") ")" "\n"
               "    " (<span> class: "ochre" "\"Squeak!\"") ")"                                                           "\n"
                                                                                                                          "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "override") " (" (<span> class: "green" "appearance") ")" "\n"
               "    " (<span> class: "ochre" "\"A man-eating gerbil.\"") ")"                                              "\n"
                                                                                                                          "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "override") " (" (<span> class: "green" "weapon") ")" "\n"
               "    " (<span> class: "ochre" "\"Long incisors!\"") ")"                                                    "\n"
                                                                                                                          "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "override") " (" (<span> class: "green" "action") ")" "\n"
               "    " (<span> class: "ochre" "\"Nibbles at your finger ferociously!\"") "))"                              "\n"
                                                                                                                          "\n"
               ")"                                                                                                        "\n")))

    (<Section-Doc> name: meta-classes title: "Meta-Classes"
      (<description>
        (<p> "Classes are objects in Jazz, so just as objects have classes, classes have metaclasses. The methods of an object are stored in a "
             "class, not the object itself; they can use instance variables. Likewise, the methods of a class are stored in the metaclass, not the class; "
             "they can use class variables. Metaclasses are also notable since they're involved in construction of objects, inheritance hierarchy, "
             "and other strange things. ")
        (<p> "There are two ways of working with metaclasses: explicity make one, or use the 'meta' modifier on methods in a class. ")
        (<pre> class: "code"
               (<span> class: "purple" "; metaclasses are also classes, but they inherit from Class")                                          "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ExampleClass-Class") " " (<span> class: "blue" "extends") " Class"                                                                        "\n"
               "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "meta-string") ")"                                            "\n"
               "    " (<span> class: "ochre" "\"meta\"") "))                       " (<span> class: "purple" "; all this method does is return string 'meta'")                                                          "\n"
                                                                                                                                               "\n"
               (<span> class: "purple" "; this class has the above metaclass")                                                                 "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ExampleClass") " " (<span> class: "blue" "metaclass") " ExampleClass-Class " (<span> class: "blue" "extends") " Object"                   "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-class") ")"      "\n"
               "    (display " (<span> class: "ochre" "\"class\"") "))             " (<span> class: "purple" "; this method displays the string 'class'")                                                               "\n"
                                                                                                                                               "\n"
               "  " (<span> class: "purple" "; this method displays the string 'meta'")                                                        "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-meta") ")"       "\n"
               "    " (<span> class: "purple" "; this gets the class of the object and invokes the meta-string method")                        "\n"
               "    " (<span> class: "purple" "; in effect it acts as a class method")                                                         "\n"
               "    (display (meta-string~ (class-of self)))))"                                                                                "\n"
                                                                                                                                               "\n"
                                                                                                                                               "\n"
               (<span> class: "purple" "; this is exactly the same as the above, but uses the 'meta' modifier, so it doesn't")                 "\n"
               (<span> class: "purple" "; require an explicit metaclass")                                                                      "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ShortExampleClass") " " (<span> class: "blue" "extends") " Object     " (<span> class: "purple" "; note that we omit the metaclass here") "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-class") ")"      "\n"
               "    (display " (<span> class: "ochre" "\"class\"") "))"                                                                        "\n"
                                                                                                                                               "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "meta") " (" (<span> class: "green" "meta-string") ")                " (<span> class: "purple" "; note the 'meta' modifier")             "\n"
               "    " (<span> class: "ochre" "\"meta\"") ")"                                                                                   "\n"
                                                                                                                                               "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "display-meta") ")"       "\n"
               "    (display (meta-string~ (class-of self)))))"                                                                                "\n")))
          
      (<Section-Doc> name: lifecycle title: "Construction & Destruction"
        (<description>
          (<p> "Jazz invokes the 'initialize' method on every method creation. 'destroy' can be explicitly invoked using (destroy~ obj), "
               "or used with (with-destroy ...). 'initialize' can take arguments, while 'destroy' does not. ")
          (<p> "'destroy' is not automatically invoked by the GC upon collection, like Java's finalize(). Instead, Jazz supports deterministic "
               "finalization similar to C++, making idioms like RAII possible. Deterministic finalization is particularly useful for handling "
               "non-memory resources like file handles and sockets. ")
          (<p> "Jazz achieves this with 'with'. (with ...) behaves much like (let ...), except that objects that are newly bound by "
               "'with' will have their destructor invoked when the 'with' expression completes evaluation. See the example: ")
          (<pre> class: "code"
                 "(" (<span> class: "blue" "class") " " (<span> class: "green" "LifecycleExample") " " (<span> class: "blue" "extends") " Object" "\n"
                 "  " (<span> class: "purple" "; example of a constructor taking a parameter")                                       "\n"
                 "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "initialize") " foo)"                             "\n"
                 "    " (<span> class: "purple" "; invokes constructors of parent classes -- leaving this out can cause problems")   "\n"
                 "    (nextmethod))"                                                                                                 "\n"
                 "    (display (tie " (<span> class: "ochre" "\"starting with {foo}\\n\"") "))"                                      "\n"
                                                                                                                                     "\n"
                 "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "destroy") ")                          " (<span> class: "purple" "; example of a destructor") "\n"
                 "    " (<span> class: "purple" "; as with the constructor, calls parent destructors -- leaving this out can")       "\n"
                 "    " (<span> class: "purple" "; cause problems")                                                                  "\n"
                 "    (nextmethod)))"                                                                                                "\n"
                 "    (display " (<span> class: "ochre" "\"ending\\n\"") ")"                                                         "\n"
                                                                                                                                     "\n"
                 (<span> class: "purple" "; an example of using LifecycleExample that invokes the constructor but not")              "\n"
                 (<span> class: "purple" "; the destructor")                                                                         "\n"
                 (<span> class: "purple" "; this displays:")                                                                         "\n"
                 (<span> class: "purple" "; - starting with 42")                                                                     "\n"
                 (<span> class: "purple" "; - leaving scope")                                                                        "\n"
                 "(let ((obj (new LifecycleExample 42)))"                                                                            "\n"
                 "  (display " (<span> class: "ochre" "\"leaving scope\\n\"") "))"                                                   "\n"
                                                                                                                                     "\n"
                 (<span> class: "purple" "; an example of using LifecycleExample that invokes the constructor and the")              "\n"
                 (<span> class: "purple" "; destructor")                                                                             "\n"
                 (<span> class: "purple" "; this displays:")                                                                         "\n"
                 (<span> class: "purple" "; - starting with 42")                                                                     "\n"
                 (<span> class: "purple" "; - leaving scope")                                                                        "\n"
                 (<span> class: "purple" "; - ending")                                                                               "\n"
                 "(with ((obj (new LifecycleExample 42)))"                                                                           "\n"
                 "  (display " (<span> class: "ochre" "\"leaving scope\\n\"") "))"                                                   "\n")))

      (<Section-Doc> title: "Literals"
        (<description>
          (<definition> name: literals title: "Literals"
            (<p> "Jazz supports object literals, a useful sugar for creating objects, and powerful concept when combined in forms (see "
                 "components below). Any class can define its own literal constants. A literal is enclosed in #f and begins with the "
                 "class name. ")
            (<pre> class: "code"
                   (<span> class: "purple" "; a couple examples from the standard jazz library")              "\n"
                   "{Point 2 3}         " (<span> class: "purple" "; creates a Point with the given values")  "\n"
                   "{Color name: Red}   " (<span> class: "purple" "; creates a Color with the give value")    "\n")
            (<p> "Since object literals must be understood by the compiler before their use in the rest of the code, they can be added by "
                 "creating install.scm and literal.jazz files which are used by '.package' in a package's root. Here's an example: ")
            (<pre> class: "code"
                   (<span> class: "purple" "; in the .package file")                                                                "\n"
                   "(" (<span> class: "blue" "package") " " (<span> class: "green" "literal-example")                               "\n"
                   "  " (<span> class: "purple" "; this is the line that is needed to call install:")                               "\n"
                   "  (" (<span> class: "blue" "root") " " (<span> class: "ochre" "\"src\"") ")"                                    "\n"
                   "  (" (<span> class: "blue" "install") " literal-example.install)"                                               "\n"
                   "  ... )                                " (<span> class: "purple" "; the rest doesn't matter for this example")  "\n"
                                                                                                                                    "\n"
                   (<span> class: "purple" "; in src/literal-example/install.scm")                                                  "\n"
                   "(" (<span> class: "blue" "unit") " " (<span> class: "green" "literal-example.install")                        "\n"
                   "  " (<span> class: "purple" "; this line adds the LiteralExample literal")                                      "\n"
                   "  (" (<span> class: "blue" "jazz.define-literal") " " (<span> class: "green" "LiteralExample") " literal-example.literals.construct-literalexample))" "\n"
                                                                                                                                    "\n"
                   (<span> class: "purple" "; in src/literal-example/literals.jazz")                                                "\n"
                   "(" (<span> class: "blue" "module") " " (<span> class: "green" "literal-example.literals") " jazz"              "\n"
                   "(" (<span> class: "blue" "import") " (literal-example.LiteralClass))"                                           "\n"
                                                                                                                                    "\n"
                   (<span> class: "purple" "; the function called to create the object when the literal is encountered")            "\n"
                   "(" (<span> class: "blue" "definition") " " (<span> class: "blue" "package") " (" (<span> class: "green" "construct-literalexample") " h v)" "\n"
                   "  (new LiteralExample h v)))"                                                                                   "\n"))))

    (<Section-Doc> name: generic-functions title: "Generic functions"
      (<description>
        (<p> "Generic functionss are a useful way to extend classes without modifying the class itself. In many languages, in order to add a method to "
             "a class, the class must be inherited from. In more dynamic languages, classes can be reopened to add methods to them at runtime -- "
             "as can Jazz. ")
        (<p> "An alternate way to add functionality to a class are generic methods, which look and behave like functions, but dispatch on the type of "
             "arguments. Generic methods can be defined for any class regardless of which module the class is in and which module the generic method "
             "is defined in. Indeed, a generic method for a set of classes may be spread across many files. ")
        (<p> "Generic functions shine when dispatching against the types of multiple arguments -- a common example is binary operators. An experimental "
             "CLOS-like extension for Jazz exists which supports multiple-dispatch, but for now mainline Jazz dispatches solely on the type of the "
             "first argument. ")
        (<pre> class: "code"
               (<span> class: "purple" "; classes we want to use with a generic function")                                                "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "Sum") " " (<span> class: "blue" "extends") " Object)"       "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "Mul") " " (<span> class: "blue" "extends") " Object)"       "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "InverseSum") " " (<span> class: "blue" "extends") " Sum)"   "\n"
                                                                                                                                          "\n"
               (<span> class: "purple" "; indicate to Jazz we're creating a new generic function")                                        "\n"
               "(" (<span> class: "blue" "generic") " (" (<span> class: "green" "perform") " (" (<span> class: "purple" "&lt;Object&gt;") " x) . rest)" "\n"
               "  " (<span> class: "ochre" "#f") ")"                                                                                      "\n"
                                                                                                                                          "\n"
               (<span> class: "purple" "; specialize the generic function for Sum -- if a Sum object is the first")                       "\n"
               (<span> class: "purple" "; argument, this executes")                                                                       "\n"
               "(" (<span> class: "blue" "specific") " (" (<span> class: "green" "perform") " (" (<span> class: "purple" "&lt;Sum&gt;") " x) . rest)" "\n"
               "  (apply + rest))"                                                                                                        "\n"
                                                                                                                                          "\n"
               (<span> class: "purple" "; specialize the generic function for Mul -- if a Mul object is the first")                       "\n"
               (<span> class: "purple" "; argument, this executes")                                                                       "\n"
               "(" (<span> class: "blue" "specific") " (" (<span> class: "green" "perform") " (" (<span> class: "purple" "&lt;Mul&gt;") " x) . rest)" "\n"
               "  (apply * rest))"                                                                                                        "\n"
                                                                                                                                          "\n"
               (<span> class: "purple" "; specialize the generic function for InverseSum -- if an InverseSum object")                     "\n"
               (<span> class: "purple" "; is the first argument, this executes     i")                                                    "\n"
               "(" (<span> class: "blue" "specific") " (" (<span> class: "green" "perform") " (" (<span> class: "purple" "&lt;InverseSum&gt;") " x) . rest)" "\n"
               "  " (<span> class: "purple" "; here we also call to the parent, invoking the Sum specialization")                         "\n"
               "  (/ 1 (apply nextmethod x rest)))"                                                                                       "\n"
                                                                                                                                          "\n"
               (<span> class: "purple" "; using a generic function")                                                                      "\n"
               "(display (perform (new Sum) 1 2 3 4))           " (<span> class: "purple" "; displays 10")                                "\n"
               "(display (perform (new Mul) 1 2 3 4))           " (<span> class: "purple" "; displays 24")                                "\n"
               "(display (perform (new InverseSum) 1 2 3 4))    " (<span> class: "purple" "; displays 1/10")                              "\n"))))
  
    (<Section-Doc> name: modifiers title: "Modifiers"
      (<description>
        (<p> "Modifiers are used with methods and sometimes functions. They modify the scope of a method or function, and other attributes "
             "related to inheritance. Here's an example of a class with modifiers: ")
        (<pre> class: "code"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ModifierExample") " " (<span> class: "blue" "extends") " Object"                                         "\n"
                                                                                                                                                                                       "\n"
               "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "foo") ")"                                                                                               "\n"
                                                                                                                                                                                       "\n"
               "  " (<span> class: "purple" "; a class method that creates objects of this or inheriting classes")                                                                     "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "meta") " " (<span> class: "blue" "public") " (" (<span> class: "green" "factory-method") " foo)"       "\n"
               "    (new self (* 2 foo)))"                                                                                                                                             "\n"
                                                                                                                                                                                       "\n"
               "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "initialize") " foo)                            " (<span> class: "purple" "; a typical constructor")  "\n"
               "    (set! foo~self foo))"                                                                                                                                              "\n"
                                                                                                                                                                                       "\n"
               "  " (<span> class: "purple" "; an abstract method that must be implemented by an inheriting class")                                                                    "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "abstract") " " (<span> class: "blue" "chained") " " (<span> class: "blue" "public") " (" (<span> class: "green" "public-method") "))" "\n"
                                                                                                                                                                                       "\n"
               "  " (<span> class: "purple" "; a private method that cannot be overridden")                                                                                            "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "private") " " (<span> class: "blue" "final") " (" (<span> class: "green" "unoverridable-method") ")"   "\n"
               "    " (<span> class: "ochre" "\"too bad, so sad\"") "))"                                                                                                               "\n"
                                                                                                                                                                                       "\n"
               "(" (<span> class: "blue" "class") " " (<span> class: "green" "ChildModifierExample") " " (<span> class: "blue" "extends") " ModifierExample   " (<span> class: "purple" "; inherit from the above class") "\n"
                                                                                                                                                                                       "\n"
               "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " " (<span> class: "blue" "override") " (" (<span> class: "green" "public-method") ")             " (<span> class: "purple" "; implement the required method") "\n"
               "    foo))"                                                                                                                                                             "\n")

        (<definition> name: meta
          (<p> "Defines a field of the meta class. Because a class is an object, meta methods can use self to refer to themselves (i.e. the class)."))
        (<definition> name: private
          (<p> "Access is restricted to classes that reside in the same file."))
        (<definition> name: protected
          (<p> "Access is restricted to sub-classes and classes in the same package."))
        (<definition> name: public
          (<p> "Access is unrestricted."))
        (<definition> name: final
          (<p> "A final definition cannot be overridden."))
        (<definition> name: virtual
          (<p> "A virtual definition can be overridden in sub-classes."))
        (<definition> name: override
          (<p> "When overriding a virtual or chained definition in a sub-class, 'override' must be explicitly used to explicitly indicate this intention."))
        (<definition> name: chained
          (<p> "A chained method can be overridden in sub-classes and the override must call the overridden method. It's effectively a virtual method with mandatory (nextmethod)."))
        (<definition> name: abstract
          (<p> "A abstract definition must be overridden in some sub-class. This modifier is currently unimplemented."))
        (<definition> name: inline
          (<p> "An inline method permits the compiler to inline its code."))
        (<definition> name: synchronized
          (<p> "A synchronized method is guaranteed to executing in at most one thread at a time."))))



  (<Section-Doc> name: types title: "Type Annotations"
    (<description>
      (<p> "Jazz is a dynamically-typed language. It supports a superset of Gambit's types. ")
      (<p> "In dynamically-typed (also called untyped) languages, the type is attached to the objects themselves and is available at "
           "run-time. In statically-typed languages -- like most C-derivatives -- types are attached to identifiers. Dynamically-typed "
           "languages are more flexible than statically-typed languages, but they trade off some performance and the earlier detection "
           "of some classes of program errors in return. ")
      (<p> "In order to provide the programmer a choice between these two trade-offs in any piece of code, Jazz supports optional type "
           "declarations. This allows rapid early development and experimentation by using the strengths of dynamic typing, and once the "
           "design solidifies and bottlenecks are identified, type annotations can be added where needed to increase correctness and "
           "performance. ")
      (<p> "Types annotations can be added in all function and method signatures for arguments and return values. They're also used in "
           "slots and properties. ")
      (<p> "Types are denoted by <> brackes and the type name. For example, a few primitive types: ")
      (<xmp> "<int>, <bool>, <fx>, <double>")
      (<p> "There are quite a few primitive types. To read the full list, find 'jazz.primitive-types' in walker.scm. A short list of the "
           "more common types is: null, char, string, number, fx (a fixnum), fl (a float), int, list, pair, symbol, vector. Note that "
           "some of these types are specializations of others. E.g. a fx is also a number. ")
      (<p> "Programmers can freely add types through classes as well, since every class has a type. Some examples of these: ")
      (<xmp> "<View>, <Window>, <Point>, <Dimension>")
      (<p> "Note that the above examples do not allow null. If your type signature must support null, append a '+' to the type name: ")
      (<xmp> "<int+>,  <double+>,  <Point+>, <Dimension+>")
      (<p> "To increase the robustness of your code and catch errors earlier, do not allow nulls (using '+') unless necessary. The common "
           "NullPointerException in Java is caused by allowing nulls with every type. ")
      (<p> "Some examples of type annotations in action: ")
      (<pre> class: "code"
             (<span> class: "purple" "; this just squares an argument of type number, returning number")                                    "\n"
             "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "square") " num " (<span> class: "gray" "&lt;number&gt;") ") " (<span> class: "gray" "&lt;number&gt;")                                               "\n"
             "  (* num num))"                                                                                                               "\n"
                                                                                                                                            "\n"
             (<span> class: "purple" "; this takes a list, and returns a float")                                                            "\n"
             "(" (<span> class: "blue" "definition") " (" (<span> class: "green" "inv-sum-floats") " num-list " (<span> class: "gray" "&lt;list&gt;") " ) " (<span> class: "gray" "&lt;fl&gt;")                                       "\n"
             "  (/ 1 (apply + num-list)))"                                                                                                  "\n"
                                                                                                                                            "\n"
             (<span> class: "purple" "; example of a class that uses type annotations in places")                                           "\n"
             "(" (<span> class: "blue" "class") " " (<span> class: "green" "TypeExample") " " (<span> class: "blue" "extends") " Object"    "\n"
                                                                                                                                            "\n"
             "  (" (<span> class: "blue" "slot") " " (<span> class: "green" "divisor") " " (<span> class: "gray" "&lt;number&gt;") ")                     " (<span> class: "purple" "; slot is a number")                             "\n"
                                                                                                                                            "\n"
             "  (" (<span> class: "blue" "method") " (" (<span> class: "green" "initialize") " divisor " (<span> class: "gray" "&lt;number&gt;") ")       " (<span> class: "purple" "; takes a number as an argument")                "\n"
             "    (nextmethod)"                                                                                                             "\n"
             "    (set! divisor~self divisor))"                                                                                             "\n"
                                                                                                                                            "\n"
             "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "is-divisor-even?") ") " (<span> class: "gray" "&lt;bool&gt;") "    " (<span> class: "purple" "; returns a bool")  "\n"
             "    (= (modulo divisor 2) 0))"                                                                                                "\n"
                                                                                                                                            "\n"
             "  (" (<span> class: "blue" "method") " " (<span> class: "blue" "public") " (" (<span> class: "green" "sum-and-divide") " num-list)    " (<span> class: "purple" "; untyped")                                            "\n"
             "    (/ (apply + num-list) divisor)))"                                                                                         "\n")))
 

  
  (<Section-Doc> name: component-programming title: "Component Programming"
    (<description>
      (<p> "One of the strengths of components is the integration of programming with the visual design it enables. By mixing programming "
           "code and view data, components bring the power of programming tools to design. Components are the basis for much of the UI. ")
      (<p> "More concretely, components are a means to create a hierarchy of objects without necessarily using inheritance, that can be "
           "entirely instantiated with a single 'new'. Components help unify composition and inheritance, and also provide ways to track "
           "parents, children and creators of each component in the hierarchy. ")
      (<p> "They're probably best understood by example: ")
      (<pre> class: "code"
             (<span> class: "purple" "; inherit from Component to support component behaviour")                                                    "\n"
             "(" (<span> class: "blue" "class") " " (<span> class: "green" "Engine") " " (<span> class: "blue" "extends") " Component"             "\n"
             "  " (<span> class: "purple" "; some properties to make data accessible to forms")                                                    "\n"
             "  (" (<span> class: "blue" "property") " " (<span> class: "green" "type") " " (<span> class: "blue" "accessors") " generate)"        "\n"
             "  (" (<span> class: "blue" "property") " " (<span> class: "green" "size") " " (<span> class: "blue" "accessors") " generate)"        "\n"
             "  (" (<span> class: "blue" "property") " " (<span> class: "green" "fuel") " " (<span> class: "blue" "accessors") " generate))"       "\n"
                                                                                                                                                   "\n"
             "(" (<span> class: "blue" "class") " " (<span> class: "green" "Vehicle") " " (<span> class: "blue" "extends") " Component"            "\n"
             "  (" (<span> class: "blue" "property") " " (<span> class: "green" "wheels") " " (<span> class: "blue" "accessors") " generate)"      "\n"
             "  (" (<span> class: "blue" "property") " " (<span> class: "green" "passengers") " " (<span> class: "blue" "accessors") " generate))" "\n"
                                                                                                                                                   "\n"
             (<span> class: "purple" "; this inherits from a component, so it's still a component")                                                "\n"
             "(" (<span> class: "blue" "class") " " (<span> class: "green" "Car") " " (<span> class: "blue" "extends") " Vehicle"                  "\n"
             (<span> class: "purple" "; a form is a bit like a constructor that initializes a composition of components")                          "\n"
             (<span> class: "purple" "; and their properties")                                                                                     "\n"
             "  (" (<span> class: "blue" "form")                                                                                                   "\n"
             "    " (<span> class: "purple" "; install refers to the current component -- we're setting the two properties")                       "\n"
             "    " (<span> class: "purple" "; inherited from Vehicle")                                                                            "\n"
             "    (" (<span> class: "purple" "&lt;install&gt;") " wheels: 4 passengers: 4"                                                         "\n"
             "      " (<span> class: "purple" "; here we create a child component of type Engine, setting its properties and")                     "\n"
             "      " (<span> class: "purple" "; giving it the reference name 'engine'")                                                           "\n"
             "      (" (<span> class: "purple" "&lt;Engine&gt;") " name: engine type: internal size: 350 fuel: gasoline))))"                       "\n"
                                                                                                                                                   "\n"
             (<span> class: "purple" "; we inherit from the above component")                                                                      "\n"
             "(" (<span> class: "blue" "class") " " (<span> class: "green" "SportsCar") " " (<span> class: "blue" "extends") " Car"                "\n"
             "  (" (<span> class: "blue" "form") "                                         " (<span> class: "purple" "; note that forms can inherit too") "\n"
             "    (" (<span> class: "purple" "&lt;install&gt;")                                                                                    "\n"
             "      " (<span> class: "purple" "; with the ! we override the initialization of component 'engine' (see Car form)")                  "\n"
             "      (" (<span> class: "purple" "&lt;!&gt;") " name: engine size: 450))))"                                                          "\n"))

    (<Class-Doc> name: Component
      (<description>
        (<p> "Inheritance and Composition")
        (<p> "The Component class is the fundamental class for components. Is the foundation of the graphical user interface, but can be "
             "useful in non-graphical contexts. Here are some of the many methods: "))
      (<Property-Doc> name: name getter: get-name setter: set-name
        (<description>
          (<p> "Every component can be named. A name must be a symbol or nil. A name of nil represents an anonymous component. ")))
      (<Property-Doc> name: parent getter: get-parent setter: set-parent
        (<description>
          (<p> "The parent component of this component -- the object one step higher up the hierarchy. ")))
      (<Property-Doc> name: children getter: get-children setter: set-children
        (<description>
          (<p> "A list of all children of this component. ")))

      (<Method-Doc> name: find-component parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, nil is returned. ")))
      (<Method-Doc> name: child parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, an error is signaled. ")))
      (<Method-Doc> name: locate parameters: "name"
        (<description>
          (<p> "Similar to child, but probably preferable in use since it detects ambiguous names. ")))

      (<Method-Doc> name: prepare parameters: "initargs"
        (<description>
          (<p> "Invoked before the form gets installed. ")))
      (<Method-Doc> name: install parameters: "initargs"
        (<description>
          (<p> "Installs the class form. ")))
      (<Method-Doc> name: finish parameters: "initargs"
        (<description>
          (<p> "Invoked before the form structure from a containing form gets installed. ")))
      (<Method-Doc> name: conclude parameters: "initargs"
        (<description>
          (<p> "Invoked after all initialization is complete, but before calling show. "))))
    
    (<Class-Doc> name: Form
      (<description>
        (<p> "A forms contains properties. Each child form -- forms on children of a class -- can redefine parts of the parent form. "
             "Properties can be added, modified or even removed.")
        (<p> "For example, if class X has two properties, 'a' and 'b', the derived class Y can change either of them (e.g. 'a'). "
             "The resulting form after inheritance would contain both 'a' and 'b', with 'a' being the redefined property.")
        (<p> "When a form is created, the base form is loaded, then each modification of the successive branches are applied, up to "
             "the final form.")
        (<p> "A property initialized in a class can be impacted by the class's form and all subsequent form redefinitions in the "
             "subclasses. "))))
  
  
  
  (<Section-Doc> name: packages title: "Packages"
    (<description>
      (<p> "This is a listing of many of the packages in Jazz. More commonly-used ones get more attention. "))
    
    (<Section-Doc> name: jazz.calendar title: "jazz.calendar"
      (<description>
        (<p> "This is a calendar widget. It shows months and days, and tracks holidays and events. It also contains many of the components used as "
             "sub-elements in the widget. ")))

    (<Section-Doc> name: jazz.console title: "jazz.console"
      (<description>
        (<p> "This is a multi-console widget often used as a REPL. Entering text in this will cause the text to be sent through a provided port. "
             "It includes formatting, text completion, history and features useful for navigating definitions and references. ")))

    (<Section-Doc> name: jazz.database title: "jazz.database"
      (<description>
        (<p> "jazz.database is the package for interfacing with databases. It provides an abstracted API that can use several different relational "
             "databases. At the moment ADO and SQL Server are supported through jazz.database.ado and jazz.database.sqlserver. It also provides a "
             "UI for querying databases. ")
        (<p> "The actual call and response API for DBs is found in jazz.database.connection. Connection contains data about an existing connection, "
             "and provides an API for making requests and transactions. Connection-Printer is a subclass that provides the same API, but pretty-prints "
             "all arguments given to it. Recordset holds the results of a request, and provides various means to extract or iterate over these results. "
             "Recordset-Metadata holds information about the columns themselves, such as name and type. ")
        (<p> (<b> "jazz.database.designer ")
             "contains UI widgets for editing column types. ")
        (<p> "This is a multi-console widget often used as a REPL. Entering text in this will cause the text to be sent through a provided port. "
             "It includes formatting, text completion, history and features useful for navigating definitions and references. ")
        (<p> (<b> "jazz.database.view ")
             "has UI widgets for navigating different data sources and schemas. Data-Source-Chooser uses Data-Source-Browser to "
             "select a database. Likewise, Schema-Chooser uses Schema-Browser to select various schemas in a database. ")))

    (<Section-Doc> name: jazz.debuggee title: "jazz.debuggee"
      (<description>
        (<p> "Remote debugger. This is the part of the debugger that is kept in the app that is being debugged. ")))
    
    (<Section-Doc> name: jazz.debugger title: "jazz.debugger"
      (<description>
        (<p> "This contains the debugger interface and the underlying communication mechanism to interact with the debuggee. The UI developers can use "
             "to debug a local or remote process is kept here. ")))
    
    (<Section-Doc> name: jazz.designer title: "jazz.designer"
      (<description>
        (<p> "This contains the the support classes for the UI builder. ")))

    (<Section-Doc> name: jazz.editor title: "jazz.editor.*"
      (<description>
        (<p> "Widgets with syntax highlighting and preferences for various languages, the most interesting being jazz.editor.c, jazz.editor.lisp, "
             "jazz.editor.jazz and jazz.editor.sql. Some of them contain support for catalogues. jazz.editor.sql also supports live connections and "
             "interactions with databases, the management of these connections, and the widgets needed for all this. ")))

    (<Section-Doc> name: jazz.graphic title: "jazz.graphic"
      (<description>
        (<p> "This handles most interesting operations in 2D graphics. It builds on surface operations -- like transforms and clipping -- and handles "
             "basic drawing operations like ellipses, quadrilaterals and lines. jazz.graphic also provides higher-level operations like colour "
             "conversions and fonts. ")))

    (<Section-Doc> name: jazz.graphic.opengl title: "jazz.graphic.opengl"
      (<description>
        (<p> "This package is a fairly complete cross-platform interface to OpenGL, GLU and GLUT, with some windowing operations. The API follows "
             "OpenGL's C API closely, so popular idioms will continue to work as expected. ")))

    (<Section-Doc> name: jazz.groupware title: "jazz.groupware"
      (<description>
        (<p> "This contains the operations and UI needed for comparing forms, files, directories and databases. jazz.groupware's basis is Compare-Text "
             "and Compare-Tree. All the other comparators use them. It also contains the groupware workspace. ")))

    (<Section-Doc> name: jazz.io title: "jazz.io"
      (<description>
        (<p> "This contains most of the file and directory handling. This includes filesystem navigation and file manipulation. ")))

    (<Section-Doc> name: jazz.jml title: "jazz.jml"
      (<description>
        (<p> "This contains a JML parser, transformer, and renderer. JML is Jazz's Markup Language, and shares much in common with HTML, except using "
             "s-expressions. Like HTML, JML nodes are organized in a tree, and each node has a tag, properties and possibly children. ")
        (<p> (<b> "jazz.jml.model ")
             "contains the node classes used for construction of JML trees. JML-Element behaves much like an HTML element, and JML-Text "
             "stores plaintext in the tree. Both inherit from JML-Node, which provides the implementation for maintaining and traversing JML trees. ")
        (<p> (<b> "jazz.jml.parser ")
             "contains JML-Parser. It takes a set of s-expressions conforming with JML and converts them to a tree of JML-Element and "
             "JML-Text. ")
        (<p> (<b> "jazz.jml.renderer "
             "has a basic class for rendering JML. It doesn't do much itself, but it's used by jazz.jml.xhtml. ")
        (<p> (<b> "jazz.jml.transformation ")
             "contains JML-Transformation, which can be used to convert between JML trees that have different types of nodes. ")
        (<p> (<b> "jazz.jml.xhtml ")
             "includes an JML-XHTML parser and renderer. The XHTML-Parser converts XHTML represented in JML into a JML tree, while "
             "XHTML-Renderer converts the tree into actual XHMTL. Jazz docs are written in JML and later transformed into XHTML. ")))

    (<Section-Doc> name: jazz.jrm title: "jazz.jrm"
      (<description>
        (<p> "This is used for remote object invocation, for other OS processes and processes on other machines. It also includes object serialization "
             "and deserialization. ")
        (<p> (<b> "jazz.jrm.register ")
             "tracks objects by name. The Register class provides an API for registering and unregistering objects with various aliases. "
             "These objects can then be looked up by their alias. ")
        (<p> (<b> "jazz.jrm.remote ")
             "contains the meat of remote invocation. IOR are Internet Object References; they refer to remote objects on machines that "
             "can be anywhere on the Internet. Local-Proxy acts as a proxy for a local object, while Remote-Proxy is used for any object addressable by an "
             "IOR. Remote-Listener is the server that receives remote invocations on local objects. ")))

    (<Section-Doc> name: jazz.library title: "jazz.library"
      (<description>
        (<p> "This is a big bag of tricks. It contains Components, Events, logging, cryptography and even raster resource handling and finite automata. "
             "If you can't find what you're looking for elsewhere, check here. ")
        (<p> "One of the more unusual things it contains is Exemplar. This is a small OO system where everything is modifiable at runtime, and has no "
             "class / instance distinction. ")))

    (<Section-Doc> name: jazz.media title: "jazz.media"
      (<description>
        (<p> "This provides a simple cross-platform API for playing sounds and music, although it is best supported on Windows. ")))

    (<Section-Doc> name: jazz.network title: "jazz.network"
      (<description>
        (<p> "This contains mechanisms for communicating over IPv4 networks with TCP, both as server and client. It also has a basic web server. ")
        (<p> (<b> "jazz.network.host ")
             "contains classes for the TCP server and client. Host represents hosts on IPv4 networks, and can convert between IP "
             "addresses and domain names. There's not much in TCP-Client, but TCP-Server is the basis of processes that can receive packets from over the "
             "Internet. It attaches a thread to a host interface and port and listens. ")
        (<p> (<b> "jazz.network.http ")
             "contains a client and server, much like jazz.network.host, but specialized for HTTP traffic. HTTP-Client can retrieve HTTP "
             "resources from across the Internet, and includes cookie handling for that purpose. HTML-Page represents page objects, with names and content. "
             "HTTP-Cookie stores a cookie name and value. HTTP-File-Response loads up a file off the filesystem and sends it out a port. HTTP-Message "
             "parses, stores and sends HTTP headers, including cookies. HTTP-Recorder records all traffic that occurs on an open port. HTTP-Request "
             "represents requests, and includes parsing for them. Similar applies to HTTP-Response. HTTP-Session is for tracking of live sessions. ")
        (<p> "HTTP-Server and Web-Server together comprise the web-server. It responds to most common HTTP requests, has session tracking, and handles basic "
             "authentication. ")
        (<p> "Web-Servers-Manager and Web-Servers-Actions create a UI for starting, stopping and changing local servers. jazz.network.server.Server-Panel "
             "provides a more basic functionality for the console. ")))

    (<Section-Doc> name: jazz.platform title: "jazz.platform"
      (<description>
        (<p> "Much of the platform-specific code is kept in this package. This includes windows, surfaces, event reception, rendering of fonts and crash "
             "handling. ")))

    (<Section-Doc> name: jazz.profile title: "jazz.profile"
      (<description>
        (<p> "Profiles are where user-specific preferences are stored for Jedi. This includes hot-keys for custom tests, recordings, and even SQL connections. "
             "It does not store key-bindings. ")))

    (<Section-Doc> name: jazz.sample title: "jazz.sample"
      (<description>
        (<p> "A number of Jazz examples. They range from Hello World and fibonacci to Mandelbrot and a game server. ")))
    
    (<Section-Doc> name: jazz.system title: "jazz.system"
      (<description>
        (<p> "Some low-level facilities for applications. This includes jazz processes, handling for command-line arguments, some platform-specific key-handling, "
             "and platform-specific performance counters and logging. This contains the Application class, which serves as the basis for the IDE; it takes care "
             "of the starting menus, events, the clipboard, key bindings, and other basic facilities you'd expect a basic GUI to provide. It also has an API for "
             "windows services. ")
        (<p> (<b> "jazz.application ")
             "serves as the basis for the IDE, and can be used for other GUI apps. Action-Actions contains a form with a  number of actions useful for an editor "
             "-- e.g. new/open/close/copy/paste/etc -- which all have associated events that are sent to the application when triggered. Application-Bindings "
             "takes several different sets of actions, including Action-Actions, and combines them into a final set of key-bindings. Application-Preferences "
             "does the same for several sets of preferences. Exception-Presenter builds a UI that displays an exception stack. Application itself makes use of "
             "all these things to handle application setup and tear-down, clipboard, history, preferences, workspaces, windows and other basic UI handling for "
             "the app. ")
        (<p> (<b> "jazz.system.log ")
             "is currently unimplemented.")
        (<p> (<b> "jazz.system.performance ")
             "can monitor CPU, memory, I/O, and Windows-specific resources. It supports counters as well. Currently this is only supported on Windows. ")
        (<p> (<b> "jazz.system.platform ")
             "interfaces with the operating system to receive mouse and keyboard events, as well as a few other minor platform-specific things. ")
        (<p> (<b> "jazz.system.process ")
             "contains the basis for Jazz processes. Command-Line is primarily devoted to display of options and help screens at the command-line. "
             "Process-Preferences keeps track of which directory a process is home to as well as the protocols it understands. The meat is in Process, which "
             "takes care of setting up the process for debugging, loads preferences, sets up a crash handler, and handles process threading and tear-down. ")
        (<p> (<b>"jazz.system.service ")
             "handles registration, execution and debugging of Jazz processes as Windows services. It's currently disabled. ")))

    (<Section-Doc> name: jazz.ui title: "jazz.ui"
      (<description>
        (<p> "This is where most of the UI and various widgets reside. ")
        
        (<p> (<b> "jazz.ui.action ") "is used for key-bindings. An Action has a name and a context it operates within (e.g. 'application). An Action-Item provides "
             "handlers and shortcuts for actions and tracks whether they're currently active. Actions is a component whose children are Action-Items. Bindings is a "
             "component whose children are Actions. Figure-Mover is used for dragging. A Shortcut is a set of keys and modifiers that create a shortcut. ")
        
        (<p> (<b> "jazz.ui.activity ")
             "is used for background processes and their management. An Activity is a background Jazz process, supporting Thread but adding registration and status "
             "reporting. Activity-Reporter is a widget that displays the relative progress and messages from an Activity, and provides a means of terminating the "
             "Activity. Activities register with an Activity-Manager and receive back and Activity-Reporter; the Activity-Manager is a widget which displays "
             "Activity-Reporters. ")
        
        (<p> (<b>"jazz.ui.clipboard ")
             "handles copy & paste across all platforms.")
        
        (<p> (<b> "jazz.ui.dialog ")
             "contains a UI dialog and a large number of widgets that can be fitted in it. ")
        (<p> "Dialog is the the pop-up dialog window itself. Message-Box displays different messages or questions, and based on the type it provides combinations "
             "of OK/Yes/No/Cancel buttons in the dialog. ")
        (<p> "Color-Request has a UI for selecting an RGB colour. Date-Request is for dates. Directories-Request navigates, adds and removes from a list of "
             "directories. Directory-Request picks one directory. File-Request picks one file. Font-Request is for font handling. NewFile-Request is like "
             "File-Request, but for both saving and replacing a file. Password-Request does what you'd expect. Pathname-Request navigates the filesystem; it is "
             "the basis for Directory-Request, File-Request and NewFileRequest. Progress-Request shows the progress of an operation and provides an option to "
             "cancel. String-Request can accept any string in a box, but it can also be provided validator (and/or check that the value is unique). "
             "Text-File-Request is like File-Request, but provides various text encoding options with which to open a file. Text-Request is like String-Request, "
             "but allows vertical scrolling and will accept any string. ")
        
        (<p> (<b> "jazz.ui.dnd ")
             "handles dragging and dropping. DnD tracks which view the drag'n'drop operation occurred in, and what the source and targets were. Drag-Source "
             "specifies what can be dragged from, and Drop-Target specifies where an object -- as well as what kind of object -- can be dragged to. A Drop-Event "
             "is what is fired when a user does a drag'n'drop. ")
        
        (<p> (<b> "jazz.ui.document ")
             "is an interface for text-edit widgets and the surrounding framework that supports them. E.g. for opening/saving/closing them. Document-Controller "
             "provides basic services for all documents, such as watching for close-window or file modification events, generating summary captions for windows, "
             "and deciding whether a scrollbar is needed. Document-Moniker is a reference to a file on the filesystem. Document is the interface that any text "
             "editor widget that wants Document-Controller services must conform to. Documents-Preferences simply provides a default dimensions and colour for "
             "documents. ")
        
        (<p> (<b> "jazz.ui.effect ")
             "has various visual effects that can be used to change content on the screen. Wipe-Effect is the sole one at the moment, allowing transitions up, "
             "down, left and right. ")
        
        (<p> (<b>"jazz.ui.event ")
             "contains a default set of specializations of Event that are useful with the UI. E.g. the Focus event is fired when the focus between windows "
             "changes, and keeps track of the old and new focused windows. ")
        
        (<p> (<b> "jazz.ui.handler ")
             "are specializations of event handlers. Right now there's just one: Selection-Handler. ")
        
        (<p> (<b> "jazz.ui.history ")
             "for anything needing the tracking and display of prior user actions. History-Document-Item tracks a selection inside a document. "
             "History-File-Item is the same, but for a file. History-Menu is a piece of UI that lets the user move backward and forward through a history. ")
        
        (<p> (<b> "jazz.ui.hosting ")
             "allows widgets to host other widgets, so they're not stuck to only behaving like the class they inherited from. It's split in two halves: the "
             "host and guest. The guest is the view with the meat; you can put it in a dialog host, a frame host, and so on. ")
        
        (<p> (<b>"jazz.ui.image ")
             "contains image handling and the UI for their display. Image-Browser displays the images in a directory. Image-View is the UI for the display of "
             "a single image. Image represents the image data itself, as well as rendering and various manipulations and scaling thereof. Portfolio is a cache "
             "for images. ")
        
        (<p> (<b>"jazz.ui.layout ")
             "contains the various layout engines, used to figure out how to arrange content within a view. Border-Layout keeps children on the north, south, "
             "east, west or centre of a view. Figure sticks the content at a specific pixel location. Flow-Layout places children one after the other, much like "
             "a toolbar. Snap-Layout snaps one widget relative to another. Split-Layout divides a view in two. ")
        
        (<p> (<b>"jazz.ui.locales ")
             "is used for localization.")
        
        (<p> (<b>"jazz.ui.look ")
             "has various visual styles for widgets. Flat-Look and Windows-Look are two existing styles. ")
        
        (<p> (<b> "jazz.ui.menu ")
             "contains a menuing system and various widgets for building menus. ")
        (<p> "Item is the basis of every row in a menu; it mainly deals with width. Label-Item extends Item with shortcuts, icons, whether it's enabled or not, "
             "and much of the width calculations, fonts and rendering. Check-Item is a menu row that can either be enabled or not. Radio-Item is like "
             "Check-Item, but instead only one of the rows in a group can be checked at any one time. ")
        (<p> "Menu handles the placement of all the rows and whether the menu is open or not. Menubar contains a list of possible menus, whether they're open or "
             "not, and comes with a default maximize and close buttons. Context-Menu is the basis of context menus. Edit-Base-Menu is a menu with basic "
             "edit-related options -- e.g. edit/undo/copy/paste/etc. Edit-Menu extends Edit-Base-Menu with a history and a paste stack. File-Base-Menu is the "
             "basic File menu most apps have. File-Menu extends this with printing options and diffing against a saved file. Recorder-Menu lists options for "
             "recording a series of actions as well as their playback. Separator-Item is a horizontal divider line that goes in a menu. Window-Menu shows a list "
             "of existing frames as well as various ways of tiling them. Workspace-Menu lists existing workspaces. ")
        
        (<p> (<b>"jazz.ui.outline ")
             "is the basis of the Text-View and Tree-View. Outline-Row renders an outlined row, and tracks relationships between rows. Outline-View handles "
             "operations on groups: the logic of expanding/contracting rows/trees, scrolling, selection and rendering. ")
        
        (<p> (<b> "jazz.ui.picker ")
             "handles dragging of selection boxes and provides some functions related to selection. ")
        
        (<p> (<b> "jazz.ui.preferences ")
             "contains preference classes for many different components as well as the UI to change them. There are many difference preference classes, named "
             "*-Preferences. Their name matches what they do, and they solely contain preference data that can be used elsewhere. E.g. Print-Preferences "
             "contains options useful for printing. ")
        (<p> "Bindings-Manager is the UI for changing and editing key-bindings for the app; Bindings-Tree is used for each row. Code-Text-Actions are a set of "
             "actions useful for code, such as evaluations, editing of definitions or references, as the ilk. Preferences-Manager is like Bindings-Manager but "
             "for a set of preferences. Shortcut-Chooser extends Shortcut-Viewer to display shortcut conflicts. Shortcut-Viewer is a UI for editing shortcuts. "
             "Text-Actions are a set of actions useful for editing text; e.g. moving around, scrolling, deletion, cut/copy/paste and anchors. View-Actions is a "
             "more limited form of Text-Actions. ")
        
        (<p> (<b>"jazz.ui.print ")
             "is where all the widgets for printing to paper reside. ")
        (<p> "Page-Header and Page-Footer are used for rendering headers and footers respectively. Page-Setup is the layout for page display, and tracks the "
             "paper type, print resolution and orientation for printed paper. Page-Status is a UI status bar that lists the current printing status. "
             "Page-Text-Palette lists various page-metadata options which can go on the header and footer of every printed page, like file name, page number, "
             "date and time. Page-Text-View is a Text-View with a few minor specializations useful for the handling of page metadata. Page-Toolbar is a UI "
             "toolbar that lists various print-related options, like printing, preview, page setup and resizing. Page-Workspace is the workspace UI for dealing "
             "with printing and uses much of the above Page-* classes. ")
        (<p> "Preview-Page is a view used for the display of how a page will appear when printed. Preview-Pane the layout (and navigation) used for print "
             "preview. Preview-Status is a status bar for the preview display. Preview-Toolbar has various UI options for the navigation, zoom and printing of "
             "the preview. Preview-Workspace is a workspace UI for the preview of pages for printing, and uses much of the Preview-* classes. ")
        (<p> "Print-Job and Printer-Job handles the internal rendering and printing of pages. ")
        
        
        (<p> (<b>"jazz.ui.resizer ")
             "is the little draggable resize widget seen on the lower-right of windows.")
        
        (<p> (<b> "jazz.ui.search ")
             "contains much of the searching-related UI. Directories-Search is a view that accepts directories and extensions, scans for matches and displays "
             "the results. History-Search-Item remembers various searches. Navigatable-Results is used by Search-Results; it contains a UI list of matches for "
             "a search. Projects-Search is the UI for searching a project for definitions or references of a class. Search-Manager is a window with tabs for "
             "various search types; it preserves a history and lists various options useful for any search type -- e.g. ignore case and whole-words. "
             "Search-Manager-Actions are a set of actions used by Search-Manager. Search-Menu is the main-menu item 'Search' seen in Jedi; it contains various "
             "search-related menu items. Search-Results-Tree shows the results of a search in tree form. Search-Results contains Search-Tree-Results and adds "
             "some widgets for search history. Search-View is another UI for search (and replace). Text-Search lists option for where to perform a search -- "
             "i.e. current file, jazz files or other files. ")
        
        (<p> (<b> "jazz.ui.selection ")
             "provides an API for selection of rows or text. If a class implements the Selection-Provider interface, it can be used by Selection-Manager. "
             "Selection-Manager tracks the current selection operation, whether there are multiple selections, and any key modifiers that apply. ")
        
        (<p> (<b> "jazz.ui.syntax ")
             "is the basis of syntax highlighting and code completion. Code-Syntax is used by many syntax specializations, and is a thin wrapper around "
             "Text-Syntax. Text-Syntax provides auto-completion, services for syntax highlighting, a catalog, and even some form of key translation. ")
        
        (<p> (<b> "jazz.ui.text ")
             "contains widgets useful for the display of text. ")
        (<p> "Text-View is a critical component in text handling and rendering; many of the above classes work together here. Modification and saving are "
             "tracked in Text-View, although it can also be set read-only. Focus, key-handling and mouse-events go through here too. Paragraph creation, "
             "colourization, the cursor and the caret (the little blinky thing which appears where you type) occur here. Drag'n'drop does. Text navigation "
             "and context menus... the list goes on. In order to use text-related widgets, you need to understand what this class offers. ")
        (<p> "A Style supports arbitrary stylistic attributes that can be applied to text, including images. A Run is a chunk of text with a single style; "
             "it handles rendering and can wrap. Line is a paragraph line containing text, offset and calculations for height and width. Paragraph contains "
             "text too, but also tracks format and number of lines. It handles wrapping and style as well. Text is just a storage for paragraphs of text. ")
        (<p> "Code-Explorer programatically navigates through expressions in the code -- backward, forward, and also can remove comments. Column-Menu is a "
             "context menu that includes a couple options useful with columns. Explorer-Mark tracks symbols: the kind (e.g. char) and range it exists in the "
             "text. Symbolic-Completer searches a domain and returns all strings that begin with the same prefix. ")
        (<p> "Format-Menu is a context menu with options for upcasing/downcasing/capitalizing/etc text. Format tracks non-font-related formatting for text like "
             "margins, justification and bulleting. Formatted-Text-Action contains various actions (and shortcuts) that can change formatting, like heading "
             "style. Formatted-Text tracks formats, styles and paragraphs of text. ")
        (<p> "Hyperlink-Style tracks a chunk of text and the action that should fire if clicked. Image-Style is an image that sits next to text. Info-Style "
             "renders various information about a page, such as what page number, how many total, and which file it came from. ")
        (<p> "Code-Text-View is the basis of much of the text editing UI in Jedi; it navigates through code, finds definitions and references, handles syntax "
             "highlighting, editing, and copy'n'paste. A Date-Text-View is a Text-View specialized for dates -- it doesn't do anything beyond its parent. "
             "Entry-Text-View adds some focus and manager handling to a Text-View.  Formatted-Text-View renders formatted text; it includes a ruler, anchors, "
             "and has a table of content with chapters based on headings. Password-Text-View renders '*' instead of characters when entering a password, and "
             "disables copying. Plain-Formatted-Text-View is a Formatted-Text-View with some default formats and styles provided. Plain-Text-View has a single "
             "default style and includes some heuristics to guess if the file is Jazz or C (although it doesn't have to be either). Ruler is a horizontal "
             "ruler widget that can be rendered as a header. ")
        (<p> "Table-Border is a bordered view with a header and a Table-Tree-View inside. Table-Cell is a single table element, also with a small border. "
             "Table-Text-View is a normal text view with some padding. Table-Tree-View contains trees and behaves more like a table. ")
        (<p> "Text-Color-Combo is a button with a name that pops up a Color-Picker. Text-Colorizer actually applies styles, not colours specifically, to runs "
             "in a section of paragraph. Text-Combo is the parent of several classes used for font and style of text: Text-Font-Combo (pick one of several "
             "type-faces), Text-Size-Combo (pick one of several font sizes), and Text-Style-Combo (apply one of several styles). ")
        (<p> "Text-Context-Menu lists text-related options like cut/copy/paste. Text-Explorer is a programmatic interface for navigating through the "
             "characters, words, paragraphs and styles of some text. Text-Palette is a panel with typeface, size, alignment, colour and indentation options "
             "that affect currently-selected text. Text-Style has various attributes for font faces, weights, colour and highlighting; it also handles "
             "wrapping and rendering. ")
        (<p> "TextToHTML-Explorer converts a chunk of text into a a chunk of HTML with the same content. While text is preserved, the style of the HTML is an "
             "approximation of styles on the text. ")
        
        (<p> (<b> "jazz.ui.tree ")
             "is used for the display and manipulation of tabular and tree-related data. Tree-View does much of the work with trees. Using many of the below "
             "classes it handles highlighting, scrolling, resizing, drag'n'drop, tooltips, keyboard navigation, expand/collapse, and so forth. To understand "
             "trees or excel-like tabular layout, Tree-View is the first step. ")
        (<p> "Tree-Actions are the set of actions that can be sent to a tree by default; these including moving around, expanding and collapsing. Tree-Column "
             "are the equivalent of Excel-style columns; it handles the title, width, tooltips, sorting and selection. Tree-Layout-View is a layout engine. "
             "Tree-Data tracks  the background and frame colour, but isn't used at the moment. Tree-Drag-Source and Tree-Drag-Target are used for dragging "
             "cells around in a columnar tree view. Tree-Header is the box that contains all the column titles; it handles scrolling titles horizontally "
             "(titles don't scroll vertically) and column resizing. Tree-Highlight tracks which cells are highlight and with which colours. Tree-Image-Column "
             "is a column that renders a title cell with an image or icon -- note the title is actually optional. Tree-Image is the image or icon itself. "
             "Tree-Label-Column is a column that renders a title cell. Tree-Node-Column renders the switches (and titles) that expand/contract children of a "
             "node, as well as passing on other clicks that could potentially be used for editing. Tree-Node has a title and image. Tree-Path-Column and "
             "Tree-Path are used to display how a tree was traversed to reach the wnode. Tree-Row renders a single row; all the children of a row compose "
             "each column of the row. ")
        
        ; this one is a bit of a mess and needs an internal reorganization
        (<p> (<b> "jazz.ui.view ")
             "has a large number of UI containers and a few buttons. The most critical file is View, which is the Jazz concept of windowing. As can be expected "
             "for something used for windowing, View has many properties useful for this: title, font, background, tooltips, size, draggability and the many "
             "handlers for events that are useful. Some examples of these handlers are for move movement and clicks, key handling, cursor updates, drag'n'drop "
             "and even reception of files.  Many of the things necessary to make windows work hook together here, including scrolling, printing, context menus, "
             "tooltips, layouts and even workspaces. Note that views can contain other views, which is essential since many widgets and containers are views "
             "themselves. In short, to understand the UI, View is the first step. ")
        (<p> "Action-Icon is a small icon with a tooltip. Border-View renders various borders around its contents. Check-Box tracks the state of a checkbox: "
             "whether it's active, editable, in focus, and its colour. Chooser is a view that lists a title, description, several options and okay/cancel. ")
        (<p> "A Color-Button is a pushable button that displays the currently-selected colour. Color-Combo is a dropdown which offers several colours as "
             "choices. Color-Picker displays a choice of 23 different colours as well as a button leading to a popup that allows selection of an arbitrary "
             "colour. Color-Text-View is like a Color-Combo, but displays the text names of colours instead of the colours themselves. ")
        (<p> "A Combo-Box is a drop-down option box that allows selection of several choices, but when inactive only shows the selected option. Combo-Button "
             "is the button pushed to expand a combo. Combo-Text-View displays the combo text options in a dropdown. Combo-View is more general than "
             "Combo-Text-View. ")
        (<p> "A Container really just lays out content within itself; Content-View allows resizing and scrolling. Drawing is a surface for painting on; it can "
             "have children drawings and understands scaling. Entry-Combo-Box and Entry-Combo-View allow a text combo box that also accepts arbitrary strings "
             "by the user. Frame-Button renders the maximize/restore/close buttons seen on most windows. Group-Box draws a box around its contained content. "
             "Header-View is a Container with a header. Horizontal-Line is exactly what it sounds like. Image-Tool is the basis of buttons that have a raster "
             "image inside them, like radio buttons. Label-Tool is just a label, and Label-Views are good for that too. Layout-View lays content out inside "
             "according to an algorithm; the algorithms can be found in jazz.ui.layout. Line-View draws lines of various styles. Pad-View is a padded view. "
             "Progress-Bar renders a bar that displays the stepped progress of something. ")
        (<p> "Push-Button is your typical button. Push-Combo, Push-Icon and Push-Tool are all used for a button that displays options so long as the mouse "
             "button is down. Radio-Button and Radio-Tool renders buttons that only allows one of a group to be selected. Scrollbar does exactly what it sounds "
             "like. ")
        (<p> "Scroller-View is a container that is affected by a Scrollbar. Separator-View separates two areas. Splitter-View is a much more flexible version "
             "that allows orientations and multiple divisions. A Splitter is a bar with an orientation that often can also be dragged. Stage is the parent of "
             "internal frames (as opposed to external frames -- frames in an OS window). ")
        (<p> "Status-Label and Status-Toolbar both are used for displaying the status of something. Tab-View is a set of tabs, each leading to a Tab-Sheet; "
             "only one Tab-Sheet at a time can be displayed. Tool-Button is actually a layout with four states: inactive, highlighted, pushed, out-pushed. "
             "Toolbar lays out various option widgets from left to right. Tooltip-* are all used for tooltips. Vertical-Line does what it says. ")
        
        (<p> (<b> "jazz.ui.widget ")
             "contains some random widgets. The most interesting of these are related to monikers; monikers acts a bit like high-level references. ")
        
        (<p> (<b> "jazz.ui.window ")
             "deals with actual OS windows, including their creation, min/maximization, drag'n'drop, key events, scrolling and the underlying message pumps. "
             "Desktop is an abstraction of the OS desktop; under X11 it's the root window. A Frame is a window, but it can either be based on Window (an OS "
             "window) or Stage (parent of internal Jazz frames). Menu-Transient, Popup and Tooltip are all similar; they deal with temporary menus, popups, "
             "and tooltips respectively. Toplevel is the top-level in a window. View-Player is any window that supports the viewing system. Window is "
             "non-platform-specific code that deals with most events a window is interested in -- such as minimization, resizing and closing. ")
        
        (<p> (<b> "jazz.ui.workspace ")
             "has the basis for workspaces. Default-Workspace is a blank workspace. Standard-Workspace adds a menu-bar, tool-bar and status-bar. "
             "Workspace-Button is a radio button which switches between spaces; it can also display if there are errors in a space. Workspace-Preferences is "
             "the basis of workspaces; it tracks various things like maximization and shortcut, and maintains children frames and status. "
             "Workspaces-Preferences can contain several workspaces. ")))

    (<Section-Doc> name: jazz.validation title: "jazz.validation"
      (<description>
        (<p> "This has the framework necessary to run unit tests. It includes a set of tests for various important classes in Jazz. ")))

    (<Section-Doc> name: jazz.contrib.irregex title: "jazz.contrib.irregex"
      (<description>
        (<p> "While there is also a basic regular expression system in jazz.library, this is what you want to use when munging text with regex. It is "
             "Unicode-clean, can optimize regex, and supports most of the non-regular features of PCRE. ")))

    (<Section-Doc> name: jazz.contrib.statprof title: "jazz.contrib.statprof"
      (<description>
        (<p> "A profiler! It will not give the exact number of invocations per method or function, but it has low overhead. ")))

    (<Section-Doc> name: jazz.contrib.srfi-19 title: "jazz.contrib.srfi-19"
      (<description>
        (<p> "A fairly comprehensive set of date-time objects and their handling. This includes time and date parsing, conversions, and rendering. Handles "
             "leap years and even includes the modified Julian calendar. Veni, vidi, vici. ")))))

  

  (<Section-Doc> name: numbers title: "Numbers"
    (<description>
      )
    (<Section-Doc> name: generic-arithmetic title: "Generic Arithmetic"
      (<description>
        )))
  (<Section-Doc> name: symbols title: "Symbols"
    (<description>
      (<p> "Jazz is symbolic language where symbols are used extensively. Symbols can be used as a very efficient higher level abstraction replacement for integer enumerations")))
  (<Section-Doc> name: sequences title: "Sequences"
      (<description>
        )
    (<Section-Doc> name: lists title: "List"
      (<description>
        (<p> "Lists are the most flexible data structure available in Jazz. They can grow to accommodate any number of elements and this very efficiently. As they are sequences, they are supported by a large number of manipulation functions")))
    (<Section-Doc> name: vectors title: "Vector"
      (<description>
        ))
    (<Section-Doc> name: u8vectors title: "U8Vector"
      (<description>
        ))
    (<Section-Doc> name: strings title: "String"
      (<description>
        ))
    (<Section-Doc> name: queues title: "Queue"
      (<description>
        ))
    (<Section-Doc> name: axises title: "Axis"
      (<description>
        ))
    (<Section-Doc> name: subseqs title: "Subseq"
      (<description>
        )))
  (<Section-Doc> name: iteration title: "Iteration"
    (<description>
      )
    (<Section-Doc> name: sequences-iteration title: "Sequences"
      (<description>
        ))
    (<Section-Doc> name: loop-macro title: "Loop Macro"
      (<description>
        )
    (<Syntax-Doc> name: loop parameters: "..."
      (<description>
        (<code> "for")
        (<code> "in")
        (<code> "in-properties")
        (<code> "iterate")
        (<code> "from")
        (<code> "repeat")
        (<code> "do")
        (<code> "sum")
        (<code> "collect")))))
  (<Section-Doc> name: exceptions title: "Exceptions"
    (<Section-Doc> name: exception title: "Exception"
      (<description>
        )))
  (<Section-Doc> name: input/output title: "Input / Output"
    (<Section-Doc> name: file title: "File"
      (<description>))
    (<Section-Doc> name: directory title: "Directory"
      (<description>))
    (<Section-Doc> name: aliases title: "Aliases"
      (<description>
        "Aliases are symbolic names for directories. "
        "They are similar to CommonLisp's logical pathnames. "
        (<p>)
        "The following aliases are predefined:"
        (<node>
          "Home"
          "Jazz"
          "User"
          "Build")))
    (<Section-Doc> name: formatted_output title: "Formatted Output"
      (<description>
        (<p> "Implements formatted output.")
        (<p>)
        (<definition> name: format_directives title: "Directives"
          (<table> class: "terminology" width: "500"
            (<th> "Name") (<th> "Accessor") (<th> "Description")
            (<tr> (<td> "ASCII") (<td> "a") (<td> "human readable"))
            (<tr> (<td> "SEXPR") (<td> "s") (<td> "reader readable"))
            (<tr> (<td> "TEXT") (<td> "t") (<td> "textual representation"))
            (<tr> (<td> "PRINT") (<td> "p") (<td> "ascii or sexpr or text"))
            (<tr> (<td> "REAL") (<td> "r") (<td> "real number"))
            (<tr> (<td> "CHAR") (<td> "h") (<td> "character"))
            (<tr> (<td> "LIST") (<td> "l") (<td> "remove parenthesis"))
            (<tr> (<td> "PROPERTIES") (<td> "k") (<td> "properties list"))
            (<tr> (<td> "UNSIGNED") (<td> "u") (<td> "unsigned integer"))
            (<tr> (<td> "HEXADECIMAL") (<td> "x") (<td> "hexadecimal integer"))
            (<tr> (<td> "COLUMN") (<td> "c") (<td> "column"))
            (<tr> (<td> "TAB") (<td> "&") (<td> "insert tab character"))
            (<tr> (<td> "NEW_LINE") (<td> "%") (<td> "insert new line"))
            (<tr> (<td> "LOCALIZE") (<td> "z") (<td> "localized string"))
            (<tr> (<td> "FORMATTED") (<td> "f") (<td> "formatted control"))))
        (<p>)
        (<definition> name: format_parameters title: "Parameters"
          (<p> "{x :a value :b value ?}")
          (<p> ":v -> takes the info from the parameters")
          (<p>)
          (<p> "Examples:")
          (<node>
            (<code> "(format :string \"{_ 5}\")")
            (<code> "(format :string \"{a :width :v :justify right}\" bonjour 20)"))
          (<p>)
          (<p> "Parameters can be optional and can be keyword based.")
          (<node>
            (<span> "list?")
            (<span> "width")
            (<span> "justify -> :left :right")
            (<span> "padding")
            (<span> "separator")
            (<span> "last-separator")
            (<span> "precision")
            (<span> "properties")
            (<span> "empty-value")
            (<span> "detail"))))))
  (<Section-Doc> name: regular-expressions title: "Regular Expressions")
  (<Section-Doc> name: date/time title: "Date / Time")
  (<Section-Doc> name: depot title: "Source Control"
    (<description>
      "A depot is an abstraction for a source control system. "))
  (<Section-Doc> name: user-interface title: "User Interface"
    (<description>
      "The cross-platform UI is a high level framework written in Jazz that uses Cairo for backend. It runs on Mac OS X, Windows and X11. ")
    (<Section-Doc> title: "Drawing"
      (<description>)
      (<Section-Doc> title: "Cairo"
        (<description>))
      (<Section-Doc> title: "Surface"
        (<description>))
      (<Section-Doc> title: "Color"
        (<description>))
      (<Section-Doc> title: "Font"
        (<description>))
      (<Section-Doc> title: "Point"
        (<description>))
      (<Section-Doc> title: "Dimension"
        (<description>))
      (<Section-Doc> title: "Rect"
        (<description>))
      (<Section-Doc> title: "Cell"
        (<description>))
      (<Section-Doc> title: "Range"
        (<description>)))
    (<Section-Doc> title: "Windows"
      (<description>)
      (<Class-Doc> name: Window
        (<description>))
      (<Class-Doc> name: Toplevel
        (<description>))
      (<Class-Doc> name: Stage
        (<description>
          "A stage window is the parent window of all documents. "))
      (<Class-Doc> name: Palette
        (<description>
          "Windows of this class should be permanent popups."))
      (<Class-Doc> name: Popup
        (<description>
          "Windows of this class should be temporary popup windows like tooltips, menus, ... "
          "For permanent popups see Palette. "))
      (<Class-Doc> name: Dialog
        (<description>)))
    (<Section-Doc> title: "Basic Views"
      (<description>)
      (<Class-Doc> name: View
        (<description>))
      (<Class-Doc> name: Border-View
        (<description>))
      (<Class-Doc> name: Check-Box
        (<description>))
      (<Class-Doc> name: Group-Box
        (<description>))
      (<Class-Doc> name: Label-View
        (<description>))
      (<Class-Doc> name: Layout-View
        (<description>))
      (<Class-Doc> name: Push-Button
        (<description>))
      (<Class-Doc> name: Radio-Button
        (<description>))
      (<Class-Doc> name: Scroller-View
        (<description>)))
    (<Section-Doc> title: "Text-View"
      (<Class-Doc> name: Text-View
        (<description>)))
    (<Section-Doc> title: "Tree-View"
      (<Class-Doc> name: Tree-View
        (<description>))
      (<Class-Doc> name: Tree-Header
        (<description>))
      (<Class-Doc> name: Tree-Node-Column
        (<description>))
      (<Class-Doc> name: Tree-Label-Column
        (<description>))
      (<Class-Doc> name: Tree-Row
        (<description>)))
    (<Section-Doc> title: "Hosting"
      (<description>)
      (<Section-Doc> title: "Host"
        (<description>))
      (<Section-Doc> title: "Guest"
        (<description>)))
    (<Section-Doc> title: "Layouting"
      (<description>)
      (<Class-Doc> name: Flow-Layout
        (<description>))
      (<Class-Doc> name: Border-Layout
        (<description>)))
    (<Section-Doc> title: "Activation"
      (<description>
        (<table> class: "terminology" width: "500"
          (<th> "Event") (<th> "Description")
          (<tr> (<td> "focus-gained") (<td> "Sent to a view that gained focus"))
          (<tr> (<td> "focus-lose") (<td> "Sent to a view that loses focus"))
          (<tr> (<td> "host-activate") (<td> "Sent to guest when host gains focus"))
          (<tr> (<td> "host-deactivate") (<td> "Sent to guest when host loses focus"))
          (<tr> (<td> "client-activate") (<td> "Sent to each tool when a document activates"))
          (<tr> (<td> "client-deactivate") (<td> "Sent to each tool when last document closes"))
          (<tr> (<td> "stage-activate") (<td> "Sent to stage when last document closes"))
          (<tr> (<td> "stage-deactivate") (<td> "Sent to stage when a first document activates")))))
    (<Section-Doc> title: "Menus"
      (<Class-Doc> name: Menu
        (<description>))
      (<Class-Doc> name: Label-Item
        (<description>))
      (<Class-Doc> name: Separator-Item
        (<description>)))
    (<Section-Doc> title: "Events"
      (<description>
        "Event encapsulation puts almost no pressure on the framework because almost everywhere the direct class override is used. "
        "Events encapsulate amongst other things, modifiers state that is necessary for recording user actions. ")
      (<Class-Doc> name: Event
        (<description>)))
    (<Section-Doc> title: "Clipboard"
      (<description>))
    (<Section-Doc> title: "User Interaction"
      (<description>
        "message-box")))
  (<Section-Doc> name: c-interface title: "C Interface"
    (<Section-Doc> name: c-interface.syntax title: "Syntax"
      (<Form-Doc> name: c-constant parameters: "name value"
        (<description>
          (<p> "A c-constant cannot be modified. Note that currently, a constant definition is simply a definition.")
          ))
      (<Form-Doc> name: c-enumeration parameters: "enumeration-name (name1 value1) (name2 value2) ..."
        (<description>
          (<p> "A c-enumeration definition. "
            "This enumeration will create a definition enumeration-name containing an Enumeration object that can be queried at runtime and create constant definitions name1 : value1, name2 : value2, ...")
          ))
      (<Form-Doc> name: c-structure parameters: "structure-name (type1 field1 <n1>) (type2 field2 <n2>) ..."
        (<description>
          (<p> "A c-structure is a template that can be used to create records containing primitive types. Here, type is any primitive type and field is a symbol that can be used to access this field is records of type structure-name. If the optional n is specified, then an array of n elements of type will be inserted.")
          ))
      (<Form-Doc> name: c-external parameters: "unit-name return-type (name param1 param2 ...) <entry-name>"
        (<description>
          (<p> "A c-external entry point into a Windows unit, i.e. a dynamic-link library or an executable.")
          ))))
  (<Unit-Doc> name: License
  (<description>
    (<p> "Licensing module."
      "This module which is in development, will provide classes to enforce commercial licensing strategies.")))
  (<Unit-Doc> name: Designer
  (<description>
    (<definition> name: Designer
      (<p> "A Designer is the interface between a jazz object and a form"))
    (<definition> name: Component-Editor)
    (<definition> name: View-Editor)
    (<definition> name: Traits-Editor)
    (<definition> name: Components-Editor)
    (<p>)
    (<definition> name: Card)
    (<definition> name: Custom-Card)
    (<definition> name: Properties-Card)
    (<definition> name: Value-Row)
    (<p>)
    (<definition> name: Component-Surrogate)
    (<p>)
    (<definition> name: Property)
    (<definition> name: Property-Entry)
    (<definition> name: Property-View)
    (<definition> name: Domain)
    (<p>)
    (<definition> title: "Designer Events"
      (<node>
        (<span> "property-change ")
        (<span> "child-add ")
        (<span> "child-remove ")
        (<span> "child-move ")
        (<span> "update")
        (<span> "refresh")))
    (<p>)
    (<definition> title: "Editor Events"
      (<node>
        (<span> "client-change ")
        (<span> "designer-change ")
        (<span> "branch-changing ")
        (<span> "branch-change ")
        (<span> "selection-changing ")
        (<span> "selection-change")
        (<span> "saving")))
    (<p>)
    (<definition> title: "Notes"
      (<node>
        (<span> "Editing a form is done through a Designer and an instance of the form. Any changes to the instance or its children should be done by calling methods of the designer instead of going to the instance directly. The designer will take care of making the changes as well as recording them.")
        (<span> "Note that by having events generated when properties are modified and some others, this process could be made more automatic. But, this would imply a great performance overhead on the system and also we do not want programmatically modified properties to be recorded by the designer. This is why Jazz sticks will a manually calling the designer approach.")
        (<span> "So, if we have a Z -> Y -> X class hierarchy, an instance of Z can be used to edit the class form of X, Y or Z.")
        (<span> "When Jazz edits an object, it monitors every descendant by installing surrogates in them. Even if the edited component is changed (by double-clicking), we keep the upper surrogates installed (even if they could conceptually be removed) so as to still be able to double-click on them to change again the edited component.")
        (<span> "Surrogates take the place of an edited component and its descendants when there's a need to trap user events sent to the component. They are most commonly used for visual components like views.")
        (<span> "An editor is an view that will permit edition of its client and do so by calling designer methods in response to events generated three optional subviews: a traits tree, a descendants tree and a properties tree. An editor has an installed client on which you can put one or more (currently only one) designers on specific descendants of the client. Each designer will record edition to its part of the client descendants tree.")
        (<span> "So, we have a component and its descendants being monitored by surrogates and one of then is the edited component (so changes to it or any of its descendants is being sent to the designer).")
        (<span> "When editing a form I should also specify the edited branch (can be nil of course).")
        (<span> "Note that branch and form unification while desirable is not a good idea because always having an installed branch for every component instance would impose to great a memory load for a very small gain. Also the present approach has the very nice property of having branches as ordinary objects that could have been developed outside of the main system. They are as any other component, they simply have a different behavior.")
        (<span> "The designer and the various elements of the editor follow the MVC model. "
          "The designer plays the model role and the editor elements are views of this model. "
          "The editor never modifies its view directly. "
          "Instead it calls methods of the designer that will modify the edited component and also send events to every listening view who can then update their interface accordingly.")))))
  (<Unit-Doc> name: Library
  (<Class-Doc> name: Node
    (<description>
      (<p> "A node is a class that supports dynamic properties")
      (<p>)
      (<node> "An node can optionally be named")
      (<p>
        "Node properties, for efficiency are stored as slots for direct access but can also be accessed in a generic fashion via the "
        (<reference> href: "get-property")
        " method")
      (<p>)))
  (<Class-Doc> name: Element
    (<description>
      (<p> "An element is a node with a hierarchical structure")
      (<p>)))
  (<Class-Doc> name: Exemplar
    (<description>
      (<p> "An Exemplar is a dynamic class whose hierarchy can be modified at runtime")
      (<p>)
      (<node>
        (<span>
          "Exemplars don't have instances"))
      (<node>
        (<span>
          "All properties are fully inherited in the sense that whenever an exemplar is modified, every descendant is automatically updated. "
          "Because the most used operation is by far property access, exemplars have a full internal copy of every property. "
          "To implement inheritance, exemplars also have a list of which properties are owned by the exemplar, "
          "i.e. what properties should not be updated when an ascendant is modified"))
      (<node>
        (<span>
          "Exemplar properties, for efficiency are stored as slots for direct access but they can also be accessed in a generic fashion via the "
          (<reference> href: "get-property")
          " method"))
      (<node>
        (<span>
          "Exemplars are grouped in an "
          (<reference> href: "Exemplar-Domain")
          " which is the domain in which an exemplar name is a valid reference"))
      (<node>
        (<span>
          "An Exemplar can be named and can inherit from another exemplar via its "
          (<code> "base"))))))
  (<Unit-Doc> name: Java
  (<description>
    (<p> "Java integration module")
    (<p>)
    (<p> "This module is at an experimental stage at the moment though it was used to implement full database access through Java's JDBC library.")))
  (<Unit-Doc> name: SQL
  (<description>
    (<p> "SQL access module.")
    (<p>)
    (<p> "This module is a very mature module that provides a sophisticated UI over the database access classes of the Access module.")))
  (<Section-Doc> title: "Units"
      (<Package-Doc> name: jazz title: "jazz"
        (<Section-Doc> title: "Boolean"
          (<Method-Doc> name: eq? parameters: "x y"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "x")
                " is physicaly equal to "
                (<parameter> "y")
                ". In other words, if both memory pointers are the same.")))
          (<Method-Doc> name: neq? parameters: "x y"
            (<description>
              (<p> "The inverse test of eq?.")))
          (<Method-Doc> name: eqv? parameters: "x y"
            (<description>
              (<p> "eqv? will succed if the two objects are eq? or if they can be simply compared without going into their structures. For example, (eq? 2.3 2.3) migth return false whereas (eqv? 2.3 2.3) will always return true.")))
          (<Method-Doc> name: equal? parameters: "x y"
            (<description>
              (<p> "The most general equivalence predicate of all.")
              (<p> "equal? will succed if the two objects are eqv? but will also try to determine if the two objets structures are identical. For example, (eq? (list 1 2 3) (list 1 2 3)) returns false but (equal? (list 1 2 3) (list 1 2 3)) returns true.")))
          (<Method-Doc> name: not parameters: "obj"
            (<description>
              (<p>
                "Returns the logical negation of "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: boolean? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is of "
                (<code> "Boolean")
                " type."))
            (<examples>
              (<example>
                (<code> "(boolean? true)")
                " returns true.")
              (<example>
                (<code> "(boolean? false)")
                " returns true.")
              (<example>
                (<code> "(boolean? nil)")
                " return false.")))
          (<Method-Doc> name: xor parameters: "x y")
          (<Method-Doc> name: = parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: /= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: < parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: <= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: > parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: >= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci/= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci< parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci<= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci> parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci>= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: boolean parameters: "obj")
          (<Method-Doc> name: boolean->integer parameters: "bool")
          (<Method-Doc> name: integer->boolean parameters: "z"))
        (<Section-Doc> title: "Char"
          (<Method-Doc> name: char? parameters: "obj")
          (<Method-Doc> name: jazz-constituent? parameters: "obj")
          (<Method-Doc> name: cpp/java-constituent? parameters: "obj")
          (<Method-Doc> name: alphabetic? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is alphabetic. An object is alphabetic if it is an alphabetic character or a sequence composed only of alphabetic parts.")))
          (<Method-Doc> name: numeric? parameters: "obj"
            (<description>
              (<p> "Tests if obj is numeric. An object is numeric if it is a numeric character or a sequence composed only of numeric parts.")))
          (<Method-Doc> name: alphanumeric? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: whitespace? parameters: "obj"
            (<description>
              (<p> "Tests if obj is whitespace. An object is whitespace if it is a whitespace character or a sequence composed only of whitespace parts.")))
          (<Method-Doc> name: upper-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is upper-case. An object is upper-case if it is an upper-case character or a sequence composed only of upper-case parts.")))
          (<Method-Doc> name: lower-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is lower-case. An object is lower-case if it is a lower-case character or a sequence composed only of lower-case parts.")))
          (<Method-Doc> name: upcase parameters: "obj"
            (<description>
              (<p> "Converts obj to upper-case. If obj is a sequence, every part of obj with be converted to upper-case.")))
          (<Method-Doc> name: downcase parameters: "obj"
            (<description>
              (<p> "Converts obj to lower-case. If obj is a sequence, every part of obj with be converted to lower-case.")))
          (<Method-Doc> name: capitalize parameters: "obj"
            (<description>
              (<p> "Converts obj to capitalized form where every word starts with a capital letter and the rest is in lower-case. If obj is a sequence, every part of obj with be converted to capitalized form."))))
        (<Section-Doc> title: "Class"
          (<description>
            (<p> "The Class type is the supertype of every class. It enables a class to be inspected and manipulated as any other object."))
          (<Method-Doc> name: class? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: class-members parameters: "class"
            (<description>
              (<p> "Returns a list of all members of class.")))
          (<Method-Doc> name: class-fields parameters: "class"
            (<description>
              (<p> "Returns a list of all fields of class.")))
          (<Method-Doc> name: class-slots parameters: "class"
            (<description>
              (<p> "Returns a list of all slots of class."))))
        (<Section-Doc> title: "Closure"
          (<Method-Doc> name: closure? parameters: "obj"))
        (<Section-Doc> title: "Collector"
          (<Method-Doc> name: gc parameters: ""))
        (<Section-Doc> title: "Control"
          (<Method-Doc> name: throw parameters: "name")
          (<Method-Doc> name: exit parameters: ""))
        (<Section-Doc> title: "Debugger"
          (<Method-Doc> name: signal parameters: "exception")
          (<Method-Doc> name: error parameters: "format-string obj ..."))
        (<Section-Doc> title: "Enumeration"
          (<Method-Doc> name: enumeration? parameters: "obj"))
        (<Section-Doc> title: "Eval"
          (<Method-Doc> name: eval parameters: "expr")
          (<Method-Doc> name: identity parameters: "obj"))
        (<Section-Doc> title: "Format"
          (<Method-Doc> name: format parameters: "format-string obj ..."))
        (<Section-Doc> title: "Function"
          (<Method-Doc> name: function? parameters: "obj"))
        (<Section-Doc> title: "Hashtable"
          (<Method-Doc> name: hash-ref parameters: "hashtable key" package-name: Language
            (<description>
              (<p>
                "Gets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                ".")))
          (<Method-Doc> name: hash-set! parameters: "hashtable key value" package-name: Language
            (<description>
              (<p>
                "Sets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                " to "
                (<parameter> "value")
                ".")))
          (<Method-Doc> name: hash-clear parameters: "hashtable key")
          (<Method-Doc> name: empty-hashtable parameters: "hashtable")
          (<Method-Doc> name: load-hashtable parameters: "hashtable file")
          (<Method-Doc> name: hash-remove! parameters: "hashtable key value")
          (<Method-Doc> name: for-each-hash parameters: "proc hashtable"))
        (<Section-Doc> title: "Integer"
          (<Method-Doc> name: integer? parameters: "obj")
          (<Method-Doc> name: even? parameters: "z")
          (<Method-Doc> name: odd? parameters: "z")
          (<Method-Doc> name: quotient parameters: "z1 z2")
          (<Method-Doc> name: modulo parameters: "z1 z2")
          (<Method-Doc> name: separate parameters: "z1 z2")
          (<Method-Doc> name: randomize parameters: "")
          (<Method-Doc> name: random parameters: "n")
          (<Method-Doc> name: bit-not parameters: "n")
          (<Method-Doc> name: bit-and parameters: "n ...")
          (<Method-Doc> name: bit-or parameters: "n ...")
          (<Method-Doc> name: bit-xor parameters: "n ...")
          (<Method-Doc> name: bit-set parameters: "n1 n2 n3")
          (<Method-Doc> name: bit-set? parameters: "n1 n2")
          (<Method-Doc> name: shift-left parameters: "n1 n2")
          (<Method-Doc> name: shift-right parameters: "n1 n2"))
        (<Section-Doc> title: "Interface"
          (<Method-Doc> name: interface? parameters: "obj"))
        (<Section-Doc> title: "List"
          (<Method-Doc> name: car parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: set-car! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the car field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: set-cdr! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the cdr field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: cons parameters: "x y"
            (<description>
              (<p>
                "Returns a newly allocated pair whose car is "
                (<parameter> "x")
                " and whose cdr is "
                (<parameter> "y")
                ".")))
          (<Method-Doc> name: reverse parameters: "seq"
            (<description>
              (<p> "Reverses a sequence.")))
          (<Method-Doc> name: list? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a list, false otherwise."))
            (<examples>
              (<example> "(list? nil) -> true")
              (<example> "(list? '(a b c)) -> true")
              (<example> "(list? 2) -> false")))
          (<Method-Doc> name: nil? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is the empty list, false otherwise.")))
          (<Method-Doc> name: not-nil?)
          (<Method-Doc> name: pair? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a pair and otherwise returns false."))
            (<examples>
              (<example> "(pair? 2) -> false")
              (<example> "(pair? nil) -> false")
              (<example> "(pair? (cons 1 2)) -> true")
              (<example> "(pair? '(a b c)) -> true")))
          (<Method-Doc> name: atom? parameters: "obj")
          (<Method-Doc> name: caar parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cadr parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdar parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cddr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: list parameters: "obj ..."
            (<description>
              (<p> "Returns a list constructed of all its arguments.")))
          (<Method-Doc> name: memq? parameters: "obj list")
          (<Method-Doc> name: memv? parameters: "obj list")
          (<Method-Doc> name: member? parameters: "obj list &key key test")
          (<Method-Doc> name: assq parameters: "obj list")
          (<Method-Doc> name: assv parameters: "obj list")
          (<Method-Doc> name: assoc parameters: "obj list &key key test")
          (<Method-Doc> name: rassoc parameters: "obj list &key key test")
          (<Method-Doc> name: reverse! parameters: "list")
          (<Method-Doc> name: remove! parameters: "obj list")
          (<Method-Doc> name: getprop parameters: "plist key")
          (<Method-Doc> name: getf parameters: "plist key")
          (<Method-Doc> name: setf parameters: "plist key value")
          (<Method-Doc> name: for-each-pair parameters: "proc list")
          (<Method-Doc> name: for-each-property parameters: "proc list"))
        (<Section-Doc> title: "Manifest"
          (<Method-Doc> name: load parameters: "unit-name")
          (<Method-Doc> name: unit-loaded? parameters: "unit-name")
          (<Method-Doc> name: in-manifest? parameters: "unit-name"))
        (<Section-Doc> title: "Map"
          (<Method-Doc> name: map-ref parameters: "map key")
          (<Method-Doc> name: map-set! parameters: "map key value")
          (<Method-Doc> name: map-clear parameters: "map key")
          (<Method-Doc> name: empty-map parameters: "map")
          (<Method-Doc> name: load-map parameters: "map file")
          (<Method-Doc> name: for-each-map parameters: "proc map"))
        (<Section-Doc> title: "Metaclass"
          (<Method-Doc> name: metaclass? parameters: "obj")
          (<Method-Doc> name: metaclass-instance parameters: "metaclass"))
        (<Section-Doc> title: "Number"
          (<Method-Doc> name: + parameters: "obj ...")
          (<Method-Doc> name: - parameters: "obj1 obj2 ...")
          (<Method-Doc> name: * parameters: "obj ...")
          (<Method-Doc> name: number? parameters: "obj")
          (<Method-Doc> name: zero? parameters: "obj")
          (<Method-Doc> name: positive? parameters: "obj")
          (<Method-Doc> name: negative? parameters: "obj")
          (<Method-Doc> name: / parameters: "obj1 obj2 ...")
          (<Method-Doc> name: relate parameters: "x y")
          (<Method-Doc> name: sign parameters: "z")
          (<Method-Doc> name: floor parameters: "r")
          (<Method-Doc> name: round parameters: "r")
          (<Method-Doc> name: ceil parameters: "r")
          (<Method-Doc> name: abs parameters: "z")
          (<Method-Doc> name: min parameters: "obj ...")
          (<Method-Doc> name: max parameters: "obj ...")
          (<Method-Doc> name: between? parameters: "n lower upper")
          (<Method-Doc> name: between parameters: "lower n upper")
          (<Method-Doc> name: in-interval? parameters: "n lower upper")
          (<Method-Doc> name: norm parameters: "x")
          (<Method-Doc> name: near? parameters: "x y distance"))
        (<Section-Doc> title: "Object"
          (<Method-Doc> name: object? parameters: "obj")
          (<Method-Doc> name: copy parameters: "obj"))
        (<Section-Doc> title: "Package"
          (<Method-Doc> name: package? parameters: "obj"))
        (<Section-Doc> title: "Printer"
          (<Method-Doc> name: display parameters: "obj &optional printer")
          (<Method-Doc> name: write parameters: "obj &optional printer")
          (<Method-Doc> name: describe parameters: "obj &optional printer")
          (<Method-Doc> name: new-line parameters: "&optional printer")
          (<Method-Doc> name: print-unreadable parameters: "obj printer proc"))
        (<Section-Doc> title: "Procedure"
          (<Method-Doc> name: procedure? parameters: "obj"))
        (<Section-Doc> title: "Reader"
          (<Method-Doc> name: read parameters: "&optional reader")
          (<Method-Doc> name: get-char parameters: "&optional reader")
          (<Method-Doc> name: unget-char parameters: "char &optional reader")
          (<Method-Doc> name: peek-char parameters: "&optional reader")
          (<Method-Doc> name: end-of-stream? parameters: "&optional reader"))
        (<Section-Doc> title: "Real"
          (<Method-Doc> name: real? parameters: "obj")
          (<Method-Doc> name: sin parameters: "r")
          (<Method-Doc> name: cos parameters: "r")
          (<Method-Doc> name: tan parameters: "r")
          (<Method-Doc> name: asin parameters: "r")
          (<Method-Doc> name: acos parameters: "r")
          (<Method-Doc> name: atan parameters: "r1 r2")
          (<Method-Doc> name: sqrt parameters: "r")
          (<Method-Doc> name: exp parameters: "r")
          (<Method-Doc> name: log parameters: "r")
          (<Method-Doc> name: expt parameters: "r1 r2")
          (<Method-Doc> name: percentage parameters: "part total")
          (<Method-Doc> name: percent parameters: "percent n"))
        (<Section-Doc> title: "Sequence"
          (<description>
            "Sequences are an abstract data type representing objects capable of storing sequences of objects. Some examples of sequences are lists, strings and vectors. The Jazz language possesses a important number of sequence manipulation functions")
          (<Method-Doc> name: sequence? parameters: "obj"
            (<description>
              (<p> "Tests if obj is of Sequence type.")))
          (<Method-Doc> name: length parameters: "sequence"
            (<description>
              (<p>
                "Returns the number of elements in "
                (<parameter> "seq")
                ".")))
          (<Method-Doc> name: element parameters: "sequence n"
            (<description>
              (<p> "Returns the nth element of sequence.")))
          (<Method-Doc> name: set-element! parameters: "sequence n value"
            (<description>
              (<p> "Destructively sets the nth element of sequence to value.")))
          (<Method-Doc> name: empty? parameters: "sequence")
          (<Method-Doc> name: tail parameters: "sequence n"
            (<description>
              (<p> "Returns the elements of sequence that range from n to the end. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: last parameters: "sequence"
            (<description>
              (<p> "Returns the last element of sequence.")))
          (<Method-Doc> name: last-tail parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made-up of only the last element of sequence. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: butlast parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made up of every element of sequence except the last.")))
          (<Method-Doc> name: subseq parameters: "sequence start &optional end"
            (<description>
              (<p> "Returns a sequence made up of the elements of sequence that range from start to end exclusively. If end is omited, the elements are taken till the end of sequence.")))
          (<Method-Doc> name: subseq! parameters: "sequence start &optional end")
          (<Method-Doc> name: sort parameters: "predicate sequence &key key test")
          (<Method-Doc> name: for-each-reversed parameters: "sequence")
          (<Method-Doc> name: append parameters: "sequence"
            (<description>
              (<p>
                "Returns a sequence composed of all the elements of "
                (<parameter> "seq")
                "."))
            (<examples>
              (<example> "(append) -> nil")
              (<example> "(append '(a b c) nil '(1 2) '(1 2 3)) -> (a b c 1 2 1 2 3)")
              (<example> "(append \\\"Hello\\\" \\\" \\\" \\\"there\\\") -> \\\"Hello there\\\"")
              (<example> "(append 2 3) -> <error>\"")))
          (<Method-Doc> name: append! parameters: "sequence ...")
          (<Method-Doc> name: insert! parameters: "obj sequence pos")
          (<Method-Doc> name: insert-sequence! parameters: "sequence inserted pos")
          (<Method-Doc> name: replace-subseq! parameters: "sequence start end replacement")
          (<Method-Doc> name: element-reversed parameters: "sequence n")
          (<Method-Doc> name: for-each parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2")))
          (<Method-Doc> name: map parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2 and collects the results in a list that it returns.")))
          (<Method-Doc> name: map-to parameters: "type proc sequence")
          (<Method-Doc> name: gather parameters: "sequence")
          (<Method-Doc> name: collect parameters: "proc sequence")
          (<Method-Doc> name: collect-if parameters: "predicate sequence")
          (<Method-Doc> name: collect-type parameters: "type sequence")
          (<Method-Doc> name: count parameters: "obj sequence"
            (<description>
              (<p> "Finds the number of occurences of obj in sequence.")))
          (<Method-Doc> name: count-if parameters: "predicate sequence")
          (<Method-Doc> name: count-type parameters: "type sequence")
          (<Method-Doc> name: find parameters: "object sequence")
          (<Method-Doc> name: find-if parameters: "predicate sequence")
          (<Method-Doc> name: skip parameters: "predicate sequence")
          (<Method-Doc> name: some? parameters: "predicate sequence")
          (<Method-Doc> name: every? parameters: "predicate sequence")
          (<Method-Doc> name: union parameters: "sequence ...")
          (<Method-Doc> name: intersection parameters: "sequence ...")
          (<Method-Doc> name: difference parameters: "sequence1 sequence2"
            (<description>
              (<p> "Returns the set difference sequence1 \\ sequence2.")))
          (<Method-Doc> name: remove parameters: "target sequence")
          (<Method-Doc> name: remove-trailing parameters: "target list")
          (<Method-Doc> name: remove-duplicates parameters: "sequence"
            (<description>
              (<p> "Returns a sequence that has exactly the same elements as sequence and in the same order but with no duplicates.")))
          (<Method-Doc> name: remove-nils parameters: "sequence")
          (<Method-Doc> name: mismatch parameters: "target sequence")
          (<Method-Doc> name: prefix parameters: "sequences")
          (<Method-Doc> name: prefix? parameters: "target sequence")
          (<Method-Doc> name: search parameters: "target sequence")
          (<Method-Doc> name: split parameters: "sequence separator")
          (<Method-Doc> name: split-justified parameters: "sequence width separators")
          (<Method-Doc> name: join parameters: "sequences separator")
          (<Method-Doc> name: substitute parameters: "old new sequence")
          (<Method-Doc> name: substitute-alist parameters: "replacements sequence")
          (<Method-Doc> name: fill! parameters: "sequence object")
          (<Method-Doc> name: replace! parameters: "sequence replacement")
          (<Method-Doc> name: insert-ordered! parameters: "object sequence")
          (<Method-Doc> name: merge-ordered parameters: "proc x y")
          (<Method-Doc> name: random-element parameters: "sequence")
          (<Method-Doc> name: partition parameters: "sequence &key key test")
          (<Method-Doc> name: starts-with? parameters: "string target")
          (<Method-Doc> name: ends-with? parameters: "string target")
          (<Method-Doc> name: first parameters: "sequence")
          (<Method-Doc> name: second parameters: "sequence")
          (<Method-Doc> name: third parameters: "sequence")
          (<Method-Doc> name: fourth parameters: "sequence")
          (<Method-Doc> name: fifth parameters: "sequence")
          (<Method-Doc> name: sixth parameters: "sequence")
          (<Method-Doc> name: seventh parameters: "sequence")
          (<Method-Doc> name: eighth parameters: "sequence")
          (<Method-Doc> name: ninth parameters: "sequence")
          (<Method-Doc> name: tenth parameters: "sequence")
          (<Method-Doc> name: set-first! parameters: "sequence object")
          (<Method-Doc> name: set-second! parameters: "sequence object")
          (<Method-Doc> name: set-third! parameters: "sequence object")
          (<Method-Doc> name: set-fourth! parameters: "sequence object")
          (<Method-Doc> name: set-fifth! parameters: "sequence object")
          (<Method-Doc> name: set-sixth! parameters: "sequence object")
          (<Method-Doc> name: set-seventh! parameters: "sequence object")
          (<Method-Doc> name: set-eighth! parameters: "sequence object")
          (<Method-Doc> name: set-ninth! parameters: "sequence object")
          (<Method-Doc> name: set-tenth! parameters: "sequence object"))
        (<Section-Doc> title: "String"
          (<Method-Doc> name: string? parameters: "object")
          (<Method-Doc> name: empty-string? parameters: "object"))
        (<Section-Doc> title: "Symbol"
          (<Method-Doc> name: symbol? parameters: "object")
          (<Method-Doc> name: keyword? parameters: "object")
          (<Method-Doc> name: symbol->keyword parameters: "symbol")
          (<Method-Doc> name: keyword->symbol parameters: "keyword")
          (<Method-Doc> name: string->symbol parameters: "string")
          (<Method-Doc> name: symbol->string parameters: "symbol")
          (<Method-Doc> name: find-symbol parameters: "string")
          (<Method-Doc> name: generate-symbol parameters: "&optional prefix")
          (<Method-Doc> name: symbol-bound? parameters: "symbol")
          (<Method-Doc> name: symbol-unbound? parameters: "symbol"))
        (<Section-Doc> title: "Thread"
          (<Method-Doc> name: primordial-thread parameters: "")
          (<Method-Doc> name: current-thread parameters: ""))
        (<Section-Doc> title: "Time"
          (<Method-Doc> name: clock parameters: ""))
        (<Section-Doc> title: "Type"
          (<Method-Doc> name: type? parameters: "object")
          (<Method-Doc> name: new parameters: "class object ...")
          (<Method-Doc> name: new-in parameters: "context class object ...")
          (<Method-Doc> name: coerce parameters: "object type")
          (<Method-Doc> name: class-of parameters: "object")
          (<Method-Doc> name: is? parameters: "object type")
          (<Method-Doc> name: is-not? parameters: "object type")
          (<Method-Doc> name: typed? parameters: "object type-name")
          (<Method-Doc> name: subtype? parameters: "class type")
          (<Method-Doc> name: subtyped? parameters: "class type-name"))
        (<Section-Doc> title: "Unit"
          (<Method-Doc> name: unit? parameters: "object")
          (<Method-Doc> name: all-units parameters: ""))
        (<Section-Doc> title: "Values"
          (<Method-Doc> name: values parameters: "object ..."))
        (<Section-Doc> title: "Vector"
          (<Method-Doc> name: vector? parameters: "object"))))
  
  
  
    (<Section-Doc> title: "Jedi"
      (<Section-Doc> title: "Searching directories"
        (<description>
          (<p> "Note that searching in directories works a little different in Jedi. If you go to Search > Find In > Directories, there is "
               "a field that accepts directories. These are not actual directory paths though. Instead, aliases are used. For example, "
               "'Jazz' (without the quotes) will search the Jazz source tree. All repositories and packages have aliases that refer to "
               "themselves (e.g. jazz.ui), so if you create your own repository named 'foo', searching in 'foo' (without the quotes) will "
               "dig through all the files in that repository. ")
          (<p> "Note that you can use expressions like {Directory Home} in the 'Directory:' field as well. If you want to search arbitrary "
               "locations outside of existing aliases, paths can be found by issuing certain expressions to Jedi's console to find the path. "
               "When the following expressions are evaluated in Jedi's console, a popup appears that does the following based on the "
               "expression: ")
          (<p> "(cf) = choose file "
               (<br>)
               "(cd) = choose directory "
               (<br>)
               "(cp) = choose directory and put the path in clipboard ")
          (<p> "Note that you can configure what is searched by the Jazz and Scheme file options in the search dialogues by using "
               "Text-Search-Preferences; the labels, directories and extensions can be changed. "))))

  
  )
