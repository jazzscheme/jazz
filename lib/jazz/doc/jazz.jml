;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Documentation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(<Project-Doc> name: jazz title: "Jazz Platform"
  (<Section-Doc> name: overview title: "Overview"
    (<description>
      (<p> "Jazz is a programming language based on Scheme, conforming to the R5RS Scheme standard and implementing all optional features. "
           "For documentation, see " (<a> href: "http://www.schemers.org/Documents/Standards/R5RS/HTML/" "R5RS Documentation") ". "
           "Jazz is built on top of the Gambit system, and has full access to every feature of Gambit. " 
           "For documentation, see " (<a> href: "http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html" "Gambit Manual") ". "
           "By using Scheme's load primitive, you can load any existing Scheme code. ")))



  (<Section-Doc> name: naming title: "Naming Conventions"
    (<description>
      (<definition> name: naming_comments title: "Comments"
        (<node>
          (<span> ";;;; Chapter comment : specifies the section title, and will be gathered in a chapter.")
          (<span> ";;; Section comment : documents a section.")
          (<span> ";; Definition comment : documents a definition; many lines may be used.")
          (<span> "; Code comment : put at the end of a line of code to document it.")))
      (<p>)

      (<definition> name: naming_modules title: "Modules & Libraries"
        (<p> "Modules and libraries names are lowercase separated by .")
        (<node>
          (<span> (<code> "jazz.ui"))
          (<span> (<code> "jedi.product"))))
      (<p>)
      
      (<definition> name: naming_classes title: "Classes & Interfaces"
        (<p> "Class & Interfaces names are capitalized")
        (<node>
          (<span> (<code> "View"))
          (<span> (<code> "Java-Text"))))
      (<p>)

      (<definition> name: naming_methods title: "Methods"
        (<p> "Methods are in lowercase separated by -")
        (<node>
          (<span> (<code> "get-application"))))
      (<p>)

      (<definition> name: naming_predicates title: "Predicates"
        (<p> "Predicates end with ?")
        (<node>
          (<span> (<code> "eq?"))
          (<span> (<code> "string?"))))
      (<p>)

      (<definition> name: naming_mutators title: "Mutators"
        (<p> "Destructive functions end with !")
        (<node>
          (<span> (<code> "set-cdr!"))
          (<span> (<code> "append!"))))
      (<p>)

      (<definition> name: naming_convertors title: "Convertors"
        (<p> "Type conversion functions have -> in their name")
        (<node>
          (<span> (<code> "symbol->string"))
          (<span> (<code> "symbol->keyword"))))))



  (<Section-Doc> name: lexical title: "Lexical Syntax"
    (<description>
      (<definition> name: identifiers title: "Identifiers"
        (<p> "Identifiers in Jazz are case sensitive, thus 'Foo' and 'foo' are treated as separate. "
             "This is commonly used to name a class 'X', and a variable containing an instance of 'X' as 'x'.")
        (<p>)
        (<p> "Identifiers can consist of any alphanumeric character, in addition to the following: "
             (<b> "! $ % & * + - . / : < = > ? ^ _") ". "
             "All of the following are examples of valid identifiers: ")
        (<pre> class: "code" 
               "3d-matrix                         \n"
               "Point                             \n"
               "eqv?                              \n"
               "^$31337$:a-strange-identifier!    \n"))

      (<definition> name: whitespace title: "Whitespace"
        (<p> "Since spaces, tabs, carriage returns and line feeds are considered whitespace, they can be freely inserted in Jazz code without changing its meaning."
             "Both the following evaluate to 30: ")
        (<pre> class: "code" 
               "(* 5 10 (/ 3 5))          \n" 
               "                          \n" 
               "(          *              \n"
               "5                         \n"
               "10 (/ 3                   \n" 
               "                 5 )   )  \n")) 

      (<definition> name: comments title: "Comments"
        (<p> "Jazz offers two types of comments:")
        (<node>
          (<span> "; starts a line based comment. It works like # or // in other languages.")
          (<span> "@name, where 'name' can be any symbol, is a powerful means of commenting out entire expressions. " 
                  "When placed before an s-exp, that entire s-exp is ignored."))
        (<pre> class: "code" 
               "(* 5 10 (/ 3 5))    ; this comment has no effect on the preceeding expression         \n"
               "                                                                                      \n" 
               "@this-comment-actually-comments-out-the-entire-following-sexp                         \n"
               "(* 5 10 (/ 3 5))                                                                      \n"
               "                                                                                      \n"
               "; the following expression evaluates to 50 because the @foo comments out the (/ 3 5)  \n"
               "(* 5 10 @foo (/ 3 5))                                                                 \n" ))))



  (<Section-Doc> name: functional title: "Functional Programming"
    (<description>
        (<definition> title: "Variable value"
          (<p> (<code> "x")))
        (<p>)
        (<definition> title: "Function invocation"
          (<p> (<code> "(f ...)")))
        (<p>)
        (<p> "Example:")
        (<pre> class: "code"
               "; define a function that squares its argument   \n"
               "(define (square x)                              \n"
               "  (* x x)                                       \n"
               "                                                \n"
               "; now apply it to 2; result is 4                \n"
               "(square 2)                                      \n")))




    (<Section-Doc> name: functional_syntax title: "Functional Syntax"
      (<Form-Doc> name: definition parameters: "name value"
        (<description>
          (<p> "A definition associates a name to a value within the scope of the module or class it's defined within. "
               "A definition never takes any space in instances.; it is stored in the class itself when defined within one. "
               "At class instantiation, the value is evaluated in empty lexical and object environments.")
          (<pre> class: "code"
                 "(definition PI 3.14159265)                  \n"
                 "                                            \n"
                 "(definition circumference                   \n" 
                 "  (lambda (diameter) (* diameter PI)))      \n"
                 "                                            \n"
                 "(circumference 10)   ; returns 31.4159265   \n" ))))



    (<Section-Doc> name: functions title: "Functions"
      (<description>
        (<p> "In Jazz, functions are first-order objects and can be freely manipulated like other objects, including being passed as parameters or stored in variables. "
             "Anyone who says functions are not object-oriented is just showing that they haven't thought enough on the problem! ")
        (<p> "Jazz supports the standard Scheme 'define', as well as 'definition' and 'method'. 'definition' is an extended form of 'define' that supports more features, "
             "and 'method' is used with classes. In the following examples we'll omit 'define'.")
        (<definition> name: function_parameters title: "Parameters"
          (<p> "Parameters can be passed using several techniques in Jazz: ")
          (<p> "Jazz uses the typical positional parameters seen in most languages. It also supports variadic functions and optional keyword parameters. ")
          (<pre> class: "code"
            "; standard positional                                                  \n"
            "(definitione (double x)                                                \n"
            "  (* x x))                                                             \n"
            "                                                                       \n"
            "(method (double x)                                                     \n"
            "  (* x x))                                                             \n"
            "                                                                       \n"
            "; variable number of parameters                                        \n"
            "; args is a list containing the passed parameters                      \n"
            "(definition (sum . args)                                               \n"
            "  (apply + args))                                                      \n"
            "                                                                       \n"
            "(method (sum . args)                                                   \n"
            "  (apply + args))                                                      \n"
            "                                                                       \n"
            "; optional keyword parameters                                          \n"
            "; in this case 'width:' and 'height:' default to 1 when not provided   \n"
            "(definition (area (width: w 1) (height: h 1))                          \n"
            "  (* w h))                                                             \n"
            "                                                                       \n"
            "(method (area (width: w 1) (height: h 1))                              \n"
            "  (* w h))                                                             \n"
            "                                                                       \n"
            "; in this example 'base:' is optional, and defaults to 10              \n"
            "(definition (any-log number (base: base 10))                           \n"
            "  (/ (log number) (log base)))                                         \n"
            "                                                                       \n"
            "(method (any-log number (base: base 10))                               \n"
            "  (/ (log number) (log base)))                                         \n"))))


    (<Section-Doc> name: syntax_forms title: "Syntax"
    (<Syntax-Doc> name: bind parameters: "variables-tree values-tree expr ..."
      (<description>
        (<p> "This is a little like Scheme's let, but can bind multiple values through pattern-matching; "
             "it takes a tree of identifiers and binds them by pattern-matching against a tree of values. "
             "Bind can also handle variadics. These are best understood by example:")
        (<pre> class: "code"
               "; not too different from let                                                   \n"
               "(bind (x) '(1)      ; x is now bound to 1                                      \n"
               "  x)                ; return 1 from expression                                 \n"
               "                                                                               \n"
               "; bind a list of identifiers to a list of numbers                              \n"
               "(bind (x y) '(1 2)  ; x is 1, y is 2                                           \n"
               "  (+ x y))          ; return 3, the result of x + y                            \n"
               "                                                                               \n"
               "; bind a list of identifiers to a tree of numbers                              \n"
               "(bind (x y z) '(1 (2 3) ((4)))            ; x is 1, y is (2 3), z is ((4))     \n"
               "  (+ x (first y) (second y) (caar z)))    ; returns 10                         \n"
               "                                                                               \n"
               "; bind a tree of identifiers to a tree of numbers -- destructuring them        \n"
               "(bind (x (y1 y2) ((z))) '(1 (2 3) ((4)))  ; x is 1, y1 is 2, y2 is 3, z is 4   \n"
               "  (+ x y1 y2 z))                          ; returns 10                         \n"
               "                                                                               \n"
               "; variadics                                                                    \n"
               "(bind (x . rest) '(1 2 3 4)   ; x is 1, rest is (2 3 4)                        \n"
               "  (/ (apply + rest) x))       ; sum rest, then divide by x; returns 9          \n")))

    (<Syntax-Doc> name: bind-keywords parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p> "Takes a list of keywords and values, and binds those values to identifiers of the same name -- note that order does not matter. "
             "Unbound identifiers are remain unbound are then bound to their default values. "
             "Like bind, bind-keywords can place overflow values in a list (see bind variadic example).")
        (<pre> class: "code"
               "(bind-keywords ((x 1) (y 2)) '()            ; both x and y are bound to their default values: x is 1, y is 2   \n" 
               "  (+ x y))                                  ; evaluates to 3                                                   \n"
               "                                                                                                               \n"
               "(bind-keywords ((x 1) (y 2)) '(x: 5 y: 3)   ; x is 5, y is 3                                                   \n"
               "  (+ x y))                                  ; evaluates to 8                                                   \n"
               "                                                                                                               \n"
               "(bind-keywords ((x 1) (y 2) . rest) '(x: 5 y: 3 z: 4 s: 5)    ; x is 5, y is 3, rest is (z: 4 s: 5)            \n"
               "  (+ x y))                                                                                                     \n")))

    (<Syntax-Doc> name: bind-optionals parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p> "This takes a list of values and binds as indentifiers as it can. The remainder are assigned their default values. "
             "Unlike bind or bind-keywords, bind-optionals doesn't support capturing overflow of values (see variadic bind examples above). ")
        (<pre> class: "code"
               "(bind-optionals ((x 1) (y 2)) '()     ; x is 1, y is 2    \n"
               "  (+ x y))                            ; evaluates to 3    \n"
               "                                                          \n"
               "(bind-optionals ((x 1) (y 2)) '(5)    ; x is 5, y is 2    \n"
               "  (+ x y))                            ; evaluates to 7    \n"
               "                                                          \n"
               "(bind-optionals ((x 1) (y 2)) '(5 9)  ; x is 5, y is 9    \n"
               "  (+ x y))                            ; evaluates to 14   \n")))

    (<Syntax-Doc> name: receive parameters: "(variable ...) values expr ..."
      (<description>
        (<p> "It's possible to return multiple values from a Scheme expression using 'values'. "
             "'receive' takes these returned values and binds them to the given identifiers.")
        (<pre> class: "code"
               "(receive (x y) (values 1 2)    ; x is 1, y is 2                                       \n"
               "  (+ x y))                     ; evaluates to 3                                       \n"
               "                                                                                      \n"
               "(let ((foo (lambda () (values +2 -2))))    ; foo will return +2, -2                   \n"
               "  (receive (x y) (foo)                     ; evaluate foo and assign values to x, y   \n"
               "    (+ x y )))                             ; returns 0                                \n")))

    (<Syntax-Doc> name: quote parameters: "expr"
      (<description>
        (<p> "This turns off the Scheme evaluator and returns its first argument without evaluating it first. "
             "The short form in particular is useful for list literals. This is best understood by example: ")
        (<pre> class: "code"
               "(quote (1 2 3))   ; evaluates as (1 2 3)                                                                                 \n"
               "'(1 2 3)          ; short form, also returns (1 2 3)                                                                     \n"
               "(1 2 3)           ; this results in an evaluation error, since 1 is not a procedure -- this is why quoting is necessary  \n"
               "                                                                                                                         \n"
               "(quote 12345)     ; quoting a value returns that value, so 12345 in this case                                            \n"
               "'12345            ; same thing                                                                                           \n")))

    (<Syntax-Doc> name: if parameters: "test yes-expr no-expr ..."
      (<description>
        (<p> "Works much like you'd expect. It requires the yes-expr, but the no-expr is optional (although inadvisable -- use 'when' instead of 'if'). "
             "You'll want to look at 'begin' as well; it's handy in the common case where you'd like to evaluate multiple expressions in a conditional branch. ")
        (<pre> class: "code"
               "(if #t 1 2)       ; evaluates as 1                                                                                                        \n"
               "(if #f 1 2)       ; evaluates as 2                                                                                                        \n"
               "(if #t 1)         ; can also omit the false branch                                                                                        \n"
               "                                                                                                                                          \n"
               "(if (> 5 1)                                                                                                                               \n"
               "    (begin (display \"congratulations!\")            ; we use begin here because we're evaluating two expressions                         \n"
               "           (display \"math works on this machine\")) ; if we omitted begin, then this line would be the false branch, not the next line   \n"
               "    (display \"uh-oh!\"))                            ; false branch                                                                       \n")))

    (<Syntax-Doc> name: when parameters: "test yes-expr ..."
      (<description>
        (<p> "If test is true, all following expressions are evaluated. Similar to if, but doesn't take a false branch and can evaluate multiple expressions without begin.")
        (<pre> class: "code"
               "(when #f (display 1))    ; returns #f and displays nothing                                                                        \n" 
               "(when #t (display 1))    ; displays 1                                                                                             \n"
               "                                                                                                                                  \n"
               "(when #t (display \"The secret of the universe is...\")   ; this evaluates multiple expressions -- first it displays a sentence   \n"
               "         42)                                              ; then it returns 42                                                    \n"))) 

    (<Syntax-Doc> name: unless parameters: "test no-expr ..."
      (<description>
        (<p> "Works just like 'when', but only evaluates no-expr if test is false. ")
        (<pre> class: "code"
               "(unless #t (display 1))    ; returns #f and displays nothing                                                                        \n" 
               "(unless #f (display 1))    ; displays 1                                                                                             \n"
               "                                                                                                                                    \n"
               "(unless #f (display \"Does this example seem familiar?\")   ; this evaluates multiple expressions -- first it displays a sentence   \n"
               "           \"it should!\")                                  ; then it returns a string                                              \n"))) 

    (<Syntax-Doc> name: while parameters: "test expr ..."
      (<description>
        (<p> "Works like a normal while loop -- as long as test is true, it re-evaluates its expressions. ")
        (<pre> class: "code"
               "; bind counter to 10                                \n"
               "(define counter 10)                                 \n"
               "                                                    \n"
               "; print a count-down from 10 to 0                   \n"
               "(while (>= counter 0)                               \n"
               "  (display counter)                                 \n"
               "  (decrease! counter))   ; decrement counter by 1   \n")))

    (<Syntax-Doc> name: begin parameters: "expr ..."
      (<description>
        (<p> "Wraps one or more expressions and returns the result of the last one evaluated. Handy when used by special forms like 'if'. ")
        (<pre> class: "code"
               "(begin 1)                   ; evaluates to 1                                   \n"
               "(begin (* 2 3) (* 4 5))     ; returns 20, the result of the last expression    \n")))

    (<Syntax-Doc> name: prog1 parameters: "result-expr1 expr ..."
      (<description>
        (<p> "This behaves much like 'begin', evaluating all its expressions, except that it always returns the result of the first evaluated expression, not the last."
             "This is sometimes useful to avoid an explicit temporary variable.")
        (<pre> class: "code"
               "(prog1 (* 2 3))         ; returns 6                                                                   \n"
               "(prog1 (* 2 3) (* 4 5)) ; returns 6 -- contrast with the similar example in 'begin' above             \n" 
               "                                                                                                      \n"
               "(prog1 42                                              ; returns 42                                   \n"
               "  (display \"The secret of the universe is...\"))      ; but displays this string before returning    \n")))
 
    (<Syntax-Doc> name: tie
      (<description>
        (<p> "A convenient way to interpolate strings. If an identifier is bound in the scope where tie is used, the value of the identifier can be interpolated into "
             "the string using {identifier_name}. ")
        (<pre> class: "code"
               "(bind (x y z) '(1 2 3)        "
               "  (tie \"{x} + {y} = {z}\"))  ")))

    (<Syntax-Doc> name: case parameters: "value ((key ...) expr ...) ... (else exp ...)"
      (<description>
        (<p> "This works similar to the switch statement in C-derivatives, except it's more flexible. "
             "A value is given to 'case' which then finds a key that matches, then evaluates the associated expression(s). "
             "The else clause at the end is optional. ")
        (<p> "NB: case uses 'eqv?' to determine the equality of two values. Cetain types of values, like strings and non-empty lists, always return false. "
             "If you need to use 'equal?' or some other sophisticated means of comparison, see 'cond' below. ")
        (<pre> class: "code"
               "; a toy function that checks whether a number is one of the first ten primes                                       \n"
               "; in this case it'll evaluate to 'not-prime, since 10 is not one of them                                           \n"
               "(case 10                                  ; take the value of 10 and check it against...                           \n"
               "  ((2 3 5 7 11 13 17 19 23 29) 'prime)    ; any of numbers listed are prime                                        \n"
               "  (else 'not-prime))                      ; otherwise not a prime                                                  \n"
               "                                                                                                                   \n"
               "; another example, using symbols -- displays 'edible fruit' and returns 'edible                                    \n"
               "(case 'apple                                                           ; match for 'apple                          \n"
               "  ((carrot lettuce tomato) (display \"edible vegetable\") 'edible)                                                 \n"
               "  ((pear plum apple)       (display \"edible fruit\")     'edible)       ; this is what matches and is evaluated   \n"
               "  ((rock)                  (display \"yummy rock\")       'in-edible))                                             \n")))
 
    (<Syntax-Doc> name: ecase parameters: "value (key expr ...) ... (else exp ...)"
      (<description>
        (<p> "A specialized version of 'case' that only has one key per branch. This works almost identical to C-derivative switch statements. "
             "It can take an optional else clause. ")
        (<pre> class: "code"
               "(ecase 1                   ; matches against 1                    \n"
               "  (0 (display \"zero\"))                                          \n"
               "  (1 (display \"one\"))    ; takes this branch, displays 'one'    \n"
               "  (2 (display \"two\")))                                          \n")))

    (<Syntax-Doc> name: typecase parameters: "value ((key ...) expr ...) ... (else exp ...)"
      (<description>
        (<p> "Like 'case', except matches on the object type of the value. ")
        (<pre> class: "code"
               "(typecase \"this is a string\"   ; value to match is a String                         \n"
               "  ((List)           1)                                                                \n"
               "  ((String)         2)           ; matches String class, returns 2                    \n"
               "  ((Number Symbol)  3)                                                                \n"
               "  (else             4))                                                               \n"
               "                                                                                      \n"
               "; another example, testing an object for a class type from most- to least-specific    \n"
               "(typecase 1+2i                                     ; value to match is a Complex      \n"
               "  ((Rational)  (display \"this is a rational\"))                                      \n"
               "  ((Number)    (display \"this is a number\"))     ; matches here                     \n"
               "  ((Object)    (display \"this is an object\")))                                      \n")))

    (<Syntax-Doc> name: cond parameters: "(test exp) ... (else exp)"
      (<description>
        (<p> "Somewhat like case, but much more flexible. 'cond' does not take a value, but rather tests a series of expressions until it finds one that evaluates to true, "
             "then evaluates the branch of expressions associated with it. It can take an optional else clause. ")
        (<pre> class: "code"
               "; returns the absolute value of a number                         \n"
               "(definition (abs n)                                              \n"
               "  (cond                                                          \n"
               "    ((< n 0) (* -1 n))  ; if n < 0, multiply by -1 and return    \n"
               "    ((> n 0) n)         ; if n > 0, return n                     \n"
               "    (else 0)))          ; otherwise return 0                     \n"
               "                                                                 \n"
               "; same function without the else clause                          \n"
               "(definition (abs n)                                              \n"
               "(cond                                                            \n"
               "  ((< n 0) (* -1 n))  ; if n < 0, multiply by -1 and return      \n"
               "  ((>= n 0) n)))      ; if n >= 0, return n                      \n")))


    (<Syntax-Doc> name: set! parameters: "variable expr"
      (<description>
        (<p> "Changes the value an existing identifier is bound to. This is the same as assignment in other languages. ")
        (<pre> class: "code"
               "(definition a-variable 10)                      ; bind a-variable to 10       \n"
               "(set! a-variable 25)                            ; a-variable is now 25        \n"
               "(set! a-variable (/ a-variable 2))              ; a-variable is now 25/2      \n"
               "(set! a-variable (number->string a-variable))   ; a-variable is now '25/2'    \n")))

    (<Syntax-Doc> name: increase! parameters: "variable expr {value}"
      (<description>
        (<p> "Increments a variable. This is a short-hand for (set! foo (+ foo 1)). ")
        (<pre> class: "code"
               "(definition a-variable 10)     ; bind a-variable to 10    \n"
               "(increase! a-variable)         ; a-variable is now 11     \n"
               "(increase! a-variable)         ; a-variable is now 12     \n")))

    (<Syntax-Doc> name: decrease! parameters: "variable expr {value}"
      (<description>
        (<p> "Decrements a variable. This is a short-hand for (set! foo (- foo 1)). ")
        (<pre> class: "code"
               "(definition a-variable 10)     ; bind a-variable to 10    \n"
               "(decrease! a-variable)         ; a-variable is now 9      \n"
               "(decrease! a-variable)         ; a-variable is now 8      \n")))

    (<Syntax-Doc> name: let parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "'let' is a powerful tool that avoids most of the problems that assignment has in lesser languages (ahem); variable dependencies and scope are more explicit, "
              "uninitialized identifiers are unlikely and unidentified identifiers are caught at compile-time. ")
        (<p> "'let' binds a set of identifers to a set of evaluations before evaluating the main body. If the same identifier is in use before a 'let', its old value is shadowed "
             "only within the body of that 'let'. Note that within the section that binds values, evaluations that bind to prior let bindings cannot be used "
             "(see 'let*' and 'letrec' instead). 'let' is best understood by demonstation: ")
        (<pre> class: "code"
               "(let ((x 1)    ; x is bound to 1                                                                    \n"
               "      (y 2))   ; y is bound to 2                                                                    \n"
               "  (+ x y))     ; evaluates to 3                                                                     \n"
               "                                                                                                    \n"
               "; a more complicated example                                                                        \n"
               "(let ((list-1 (list (* 2 3) (+ 4 5)))  ; list-1 is bound to (5 9)                                   \n"
               "      (list-2 '(12 14 15))             ; list-2 is bound to (12 14 15)                              \n"
               "      (list-3 '(1)))                   ; list-3 is bound to (1)                                     \n"
               "  (display list-1)                     ; display (5 9)                                              \n"
               "  (display list-2)                     ; display (12 14 15)                                         \n"
               "                                                                                                    \n"
               "  (let ((list-1 (append list-1 list-2 list-3)))  ; list-1 is rebound to (5 9 12 14 15 1)            \n"
               "    (display list-1))                            ; display (5 9 12 14 15 1)                         \n"
               "                                                                                                    \n"
               "  (display list-1))                    ; since we've left the prior let, list-1 is back to (5 9)    \n")))

    (<Syntax-Doc> name: let* parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "This works like let, but after an identifier is bound you can use it in following lines binding variables. ")
        (<pre> class: "code"
               "(let* ((x 1)            ; x is bound to 1                                              \n"
               "       (y (+ x 2))      ; note that x is now a valid identifier, so y is bound to 3    \n"
               "       (z (/ x y)))     ; x and y are both bound here, so z is 1/3                     \n"
               "  (+ x y z))            ; returns 13/3                                                 \n")))

    (<Syntax-Doc> name: letrec parameters: "((variable expr) ...) expr ..."
      (<description>
        (<p> "One of the limitations of 'let' is that it won't allow you to write recursive functions. An identifier is not bound until after its associated "
             "expression is evaluated. Unfortunately, recursive functions require an identifier to exist during definition. 'letrec' allows you to refer to an "
             "expression's identifier during evaluation. ")
        (<pre> class: "code"
               "; this here is a function that benchmarks function f count times                                                                                         \n"
               "(definition (bench-times f count)                                                                                                                        \n"
               "  (letrec ((times (function (f remaining)              ; start the definition of the function assigned to 'times'                                        \n"
               "                    (when (> remaining 0)                                                                                                                \n"
               "                      (f)                                                                                                                                \n"
               "                      (times f (- remaining 1))))))    ; notice that 'times' is used here recursively, even though the definition is not yet complete    \n"
               "    (time (times f count))))                                                                                                                             \n")))

    (<Syntax-Doc> name: catch parameters: "(type variable expr ...) expr ..."
      (<description>
        (<p> "Evaluates expressions, and if an exception is thrown that matches the exception type, evaluates the catch expressions. ")
        (<pre> class: "code"
               "(catch (Server-Error error                  ; the exception we'll catch, and an identifier to bind it to              \n"
               "         (display \"Caught exception: \")   ; this and the next line are evaluated when a Server-Error is caught      \n"
               "         (display error))                                                                                             \n"
               "  (display \"Before exception. \n\")        ; the next three lines are where we can catch exceptions                  \n"
               "  (throw (new Server-Error))                ; throw a Server-Error                                                    \n"
               "  (display \"Should never get here... \"))  ; never executed                                                          \n"
               "                                                                                                                      \n"
               "; a simple version that doesn't do anything when it catches an exception                                              \n"
               "(catch Server-Error                                                                                                   \n"
               "  (display \"Before exception. \n\")                                                                                  \n"
               "  (throw (new Server-Error))                                                                                          \n"
               "  (display \"Should never get here... \"))                                                                            \n")))

    (<Syntax-Doc> name: throw parameters: "value"
      (<description>
        (<p> "Raises an exception. Please see the catch example above. ")))

    (<Syntax-Doc> name: unwind-protect parameters: "protected-expr protection-expr ..."
      (<description>
        (<p> "If you need perform some expressions regardless of whether an exception occurs, this is a nice way to do it; it is similar to 'finally' in Java or Python. "
             "'unwind-protect' takes two expressions, one which it will attempt to evaluate, and another which it will always evaluate. "
             "If an exception occurs during the first evaluation attempt, the second will still be run. This is particularly useful when "
             "dealing with external resources like files or sockets; regardless of whether an error occurs while writing to a file, you can "
             "ensure it's closed before returning or unwinding the stack due to an exception. " )
        (<pre> class: "code"
               "; both the following examples display 'after'                                                                      \n"
               "(catch Server-Error                                                                                                \n"
               "  (unwind-protect                                                                                                  \n"
               "    (throw (new Server-Error))     ; expression to attempt evaluation                                              \n"
               "    (display \"after\")))          ; expression to always evaluate at the end                                      \n"
               "                                                                                                                   \n"
               "(catch Server-Error                                                                                                \n"
               "  (unwind-protect                                                                                                  \n"
               "    (* 2 3)                        ; in this case an exception isn't thrown, but 'after' will still be displayed   \n"
               "    (display \"after\")))                                                                                          \n")))

    (<Syntax-Doc> name: function parameters: "parameters-list expr ..."
      (<description>
        (<p> "An anonymous function; equivalent to Scheme's 'lamdba'. "
             "It binds the parameters with the passed arguments, then evaluates the body. This is particuarly useful with 'let' and higher-order functions. " )
        (<pre> class: "code"
               "; short-hand way to define a function                                                                                           \n"
               "(definition (inverse-sum . numbers)                                                                                             \n"
               "  (/ 1 (apply + numbers)))                                                                                                      \n"
               "                                                                                                                                \n"
               "; actually, it's syntactic sugar for assigning an anonymous function to an identifier                                           \n"
               "; this is the same as the above function                                                                                        \n"
               "(definition inverse-sum                                                                                                         \n"
               "  (function numbers                                                                                                             \n"
               "     (/ 1 (apply + numbers))))                                                                                                  \n"
               "                                                                                                                                \n"
               "; map is a higher-order function that applies the given function to each member of a list, returning a new list                 \n"
               "; in this case we're squaring a list of numbers, which evaluates to (1 4 9 16 25 36 49 64 81 100)                               \n"
               "(map (function (x)                                                                                                              \n"
               "       (* x x))                                                                                                                 \n"
               "  '(1 2 3 4 5 6 7 8 9 10))                                                                                                      \n"
               "                                                                                                                                \n"
               "; there are several ways to pass arguments to lambda -- if you omit the parens around the parameters, it becomes a variadic     \n"
               "(let ((foo (function x x)))                                                                                                     \n"
               "  (foo 1 2 3 4 5))           ; all the arguments -- 1 2 3 4 5 -- are pushed into x, thus returning the list (1 2 3 4 5)         \n"
               "                                                                                                                                \n"
               "; if you keep the parens around the parameters, it behaves like normal positional parameters                                    \n"
               "(let ((foo (function (x y) x)))   ; returns only the first of two required arguments                                            \n"
               "  (foo 1 2))                      ; evaluates to 1                                                                              \n"
               "                                                                                                                                \n"
               "; and you can mix the two, but placing a '.' between the required args and the rest                                             \n"
               "(let ((foo (function (f . numbers)   ; f is required, everything else goes in numbers                                           \n"
               "             (apply f numbers))))    ; turns numbers into the arguments for f                                                   \n"
               "  (foo + 1 2 3 4 5))                 ; f binds to +, numbers binds to (1 2 3 4 5) -- the result is the sum of the numbers, 15   \n")))

    (<Syntax-Doc> name: lambda parameters: "parameters-list expr ..."
      (<description>
        (<p> "This is equivalent to 'function'; please use that in preference to 'lambda' except in pure R5RS code. ")))

    (<Syntax-Doc> name: and parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true unless one of its expressions are false. It will stop as soon as it encounters a false value and return false. ")
        (<p> "It differs from R5RS 'and' since it only guarantees that a returned true value will be true, not the last evaluated value. If you want R5RS semantics, "
             "use 'essay'. ")
        (<p> "Some examples: ")
        (<pre> class: "code"
               "(and)                      ; returns true                                                                                         \n"
               "(and 1)                    ; returns true                                                                                         \n"
               "(and 1 2 3)                ; returns true                                                                                         \n"
               "(and 1 #f)                 ; returns false                                                                                        \n"
               "(and true (= 2 (+ 1 1)))   ; returns true                                                                                         \n"
               "(and (symbol-bound? 'not-a-bound-variable) not-a-bound-variable)    ; will not signal an error because the first test will fail   \n")))

    (<Syntax-Doc> name: or parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return false unless any of the expressions are true. It will stop as soon as it encounters a true value and return true. ")
        (<p> "It differs from R5RS 'or' since it only guarantees that a returned true value will be true, not the first non-#f value. If you want R5RS "
             "semantics, use 'either'. ")
        (<pre> class: "code"
               "(or)         ; false                                                                                                                                 \n"
               "(or 1)       ; true                                                                                                                                  \n"
               "(or #f #f 3) ; true                                                                                                                                  \n"
               "                                                                                                                                                     \n"
               "; one simple application of the fact that or stops as soon as it encounters a true value is in very clean code for managing simple lazy structures.  \n"
               "(define a-big-structure-only-on-demand nil)                                                                                                          \n"
               "(define (get-structure)                                                                                                                              \n"
               "  (or a-big-structure-only-on-demand                                                                                                                 \n"
               "      (set! a-big-structure-only-on-demand (new-structure))))                                                                                        \n")))

    (<Syntax-Doc> name: essay parameters: "expr ..."
      (<description>
        (<p> "Works like 'and', but returns the value of the last evaluation. This works closer to R5RS's 'and'. ")
        (<pre> class: "code"
               "(essay 1)     ; evaluates to 1    \n"
               "(essay 1 2 3) ; evaluates to 3    \n"
               "(essay #f 2)  ; evaluates to #f   \n")))

    (<Syntax-Doc> name: either parameters: "expr ..."
      (<description>
        (<p> "Works like 'or', but returns the first true value instead of just true. This works closer to R5RS's 'or'. ")
        (<pre> class: "code"
               "(either 1)      ; evaluates to 1   \n"
               "(either 1 2 3)  ; evaluates to 1   \n"
               "(either #f 1)   ; evaluates to 1   \n")))

    (<Syntax-Doc> name: assert parameters: "asserted-expr"
      (<description>
        (<p> "Asserts the expression is true. If the expression returns false, an exception is thrown. ")
        (<pre> class: "code"
               "(assert #t)           ; nothing happens      \n"
               "(assert (* 12 82 54)) ; nothing happens      \n" 
               "(assert (zero? 10))   ; exception is raised  \n"))))



  (<Section-Doc> name: modules title: "Modules"
    (<Form-Doc> name: module parameters: "modifier module-name expr ..."
      (<description>
        (<p> "A module is effectively a named bundle of code in a file. Modules can be automatically located and loaded by name, and the kernel ensures they're "
             "only loaded once. They can also load other modules into their namespace. Module names roughly match their filesystem path inside a package. "
              "'module' is primarily used in pure-scheme files, as is 'require' which is often used with 'module'; Jazz files use 'library' and 'import' (see below). ")
        (<pre> class: "code"
               "; in file example/foo.scm                                                                     \n"
               "(module example.foo                                                                           \n"
               "  (define (hello-foo)                                                                         \n"
               "    (display \"Hello Foo!\")))                                                                \n"
               "                                                                                              \n"
               "; in file example/bar.scm                                                                     \n"
               "(module example.bar                                                                           \n"
               "  (require (example.foo))        ; pull in the code from the example.foo module just above    \n"
               "                                                                                              \n"
               "  (define (hello-bar)                                                                         \n"
               "    (hello-foo)                  ; hello-foo comes from example.foo                           \n"
               "    (display \"Hello Bar!\")))                                                                \n")))

    (<Form-Doc> name: library parameters: "library-name dialect ..."
      (<description>
        (<p> "A library is a module that implements a specific dialect -- scheme or jazz. Whereas 'module' is normally used with Scheme files, Jazz file always "
             "use 'library', and sometimes Scheme files do as well. Since libraries are a superset of modules, they are also automatically located and loaded "
             "by name, and the kernel ensures they're only loaded once. Libraries offer the ability to export and import only specific definitions and are "
             "preferable to plain modules. They're loaded with 'import'. ")
        (<pre> class: "code"
               "; this example assumes we're also using example/foo.scm and example/bar.scm from 'module' just above                                                 \n"
               "                                                                                                                                                     \n"
               "(library example.xyzzy jazz                                                                                                                          \n"
               "  (definition public (hello-xyzzy)  ; note that this definition has a 'public' modifier -- no modifier defaults to private and wouldn't export       \n"
               "    (display \"Hello Xyzzy!\")))                                                                                                                     \n"
               "                                                                                                                                                     \n"
               "; in example/quux.jazz                                                                                                                               \n"
               "(library example.quux jazz                                                                                                                           \n"
               "  (export (example.xyzzy))          ; when example.quux is imported, it'll also import example.xyzzy, not just the definitions inside example.quux   \n"
               "                                                                                                                                                     \n"
               "  (definition public (hello-quux)                                                                                                                    \n"
               "    (display \"Hello Quux!\")))                                                                                                                      \n"
               "                                                                                                                                                     \n"
               "; in example/baz.jazz                                                                                                                                \n" 
               "(library example.baz jazz                                                                                                                            \n"
               "  (require (example.bar))           ; this is used to import pure scheme code                                                                        \n"
               "  (native hello-bar)                ; Jazz doesn't know about 'require'd pure scheme definitions, so this tells it what to import from example.bar   \n"
               "  (import (example.quux))           ; this imports what example.quux exports -- its public definitions and the public definitions of example.xyzzy   \n"
               "                                                                                                                                                     \n"
               "(definition (run descriptor)                                                                                                                         \n"
               "  (hello-bar)                       ; displays 'Hello Foo!' 'Hello Bar!'                                                                             \n"
               "  (hello-quux)                      ; displays 'Hello Quux!'                                                                                         \n"
               "  (hello-xyzzy))                    ; displays 'Hello Xyzzy!'                                                                                        \n"
               "                                                                                                                                                     \n"
               "(register-product 'baz              ; see 'products' below for details -- this is a detail unrelated to libraries                                    \n"
               "  title: \"Baz\"                    ;                                                                                                                \n"
               "  run: run))                        ;                                                                                                                \n")
        (<p> "'import' and 'export' can both be conditional. If an identifier exists during compilation, it can be used to decide what to export. ")
        (<pre> class: "code"
               "; 'x11', 'windows' and 'carbon' identify which platform the code is running on                                      \n"
               "                                                                                                                    \n"
               "; in example-b/carbon.jazz                                                                                          \n"
               "(library example-b.carbon jazz                                                                                      \n" 
               "  (definition public (what-am-i)                                                                                    \n"
               "    (display \"carbon\")))                                                                                          \n"
               "                                                                                                                    \n"
               "; in example-b/windows.jazz                                                                                         \n"
               "(library example-b.windows jazz                                                                                     \n"
               "  (definition public (what-am-i)                                                                                    \n"
               "    (display \"windows\")))                                                                                         \n"
               "                                                                                                                    \n"
               "; in example-b/x11.jazz                                                                                             \n"
               "(library example-b.x11 jazz                                                                                         \n"
               "  (definition public (what-am-i)                                                                                    \n"
               "    (display \"x11\")))                                                                                             \n"
               "                                                                                                                    \n"
               "; in example-b/product.jazz                                                                                         \n"
               "(library example-b.product jazz                                                                                     \n"
               "                                                                                                                    \n"
               "(import (example-b.carbon  (cond carbon))  ; import this file if on straight Mac                                    \n"
               "        (example-b.windows (cond windows)) ; import this file if on Windowss                                        \n"
               "        (example-b.x11     (cond x11)))    ; import this file if using X11                                          \n"
               "                                                                                                                    \n"
               "(definition (run descriptor)                                                                                        \n"
               "  (what-am-i))                             ; what-am-i was only imported from one, so displays your platform        \n"
               "                                                                                                                    \n"
               "(register-product 'baz              ; see 'products' below for details -- this is a detail unrelated to libraries   \n"
               "  title: \"Example-B\"              ;                                                                               \n"
               "  run: run))                        ;                                                                               \n"))))

  
  
  (<Section-Doc> name: object-oriented title: "Object-Oriented Programming"
    (<Section-Doc> name: classes title: "Classes"
      (<description>
        (<p> "Jazz offers an object-oriented layer with :")
        (<p>)
        (<definition> title: "Method invocation"
          (<p> (<xmp> "(f~ obj x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "(get-size~ window)")
          (<code> "(invalidate-view~ (get-parent~ view))"))
        (<p>)
        (<node>
          (<span> "Classes with single inheritance and multiple interfaces implemented")
          (<span> "Metaclasses")
          (<span> "Single-dispatch 'a la' Java")
          (<span> "Generic multi-dispatch methods 'a la' CommonLisp")))
      (<Form-Doc> name: class parameters: "extends implements uses ..."
        (<description>
          (<p> "Jazz uses a single inheritance model where a class can extend only one superclass. "
            "A class can implement any number of interfaces.")))
      (<Form-Doc> name: slot parameters: "name <initialize> <initial-value>"
        (<description>
          (<p> "A slot is a field that defines the structure of the instances of a class.")))
      (<Form-Doc> name: property parameters: "name <initialize> <initial-value> <getter> <getter-name> <setter> <setter-name>"
        (<description>
          (<p> "A property is a slot that can specify a getter and a setter.")))
      (<Form-Doc> name: method parameters: "{modifiers} (name . parameters) {return-type} . body"
        (<description>
          (<p> "A method is where code resides.")))
    (<Section-Doc> name: meta-classes title: "Meta-Classes"
      (<description>))
      )
    (<Section-Doc> name: interfaces title: "Interfaces"
      (<Form-Doc> name: interface parameters: "extends uses ..."
        (<description>
          (<p> "An interface defines a new type but cannot contain code."))))
    (<Class-Doc> name: Object
      (<description>
        (<p> "The base class of every other class."))
      (<Method-Doc> name: initialize parameters: "object ...")
      (<Method-Doc> name: destroy parameters: "")
      (<Method-Doc> name: close parameters: "")
      (<Method-Doc> name: print parameters: "printer detail")
      (<Section-Doc> title: "Literals"
        (<description>
          (<definition> name: literals title: "Literals"
            (<p> "Jazz supports a powerfull concept where any class can define it's own literal constants using the following syntax: {class-name ...}. "
              "This integrates classes fully with the reader and printer.")
            (<p> "Examples:")
            (<node>
              (<code> "{Point 2 3}")
              (<code> "{Dimension 100 100}")
              (<code> "{Color name: Red}")
              (<code> "{Font name: Code}"))))))
    (<Section-Doc> name: dynamic-dispatch title: "Dynamic Dispatch"
      (<description>))
    (<Section-Doc> name: generic-methods title: "Generic methods"
      (<description>)))
  
  
  
    (<Concept-Doc> name: modifiers title: "Modifiers"
      (<description>
        (<definition> name: meta
          (<p> "Defines a field of the meta class. Because a class is an object, meta methods can use self to refer to themselves (i.e. the class)."))
        (<p>)
        (<p>)
        (<definition> name: private
          (<p> "Access is restricted to classes that reside in the same file."))
        (<p>)
        (<p>)
        (<definition> name: protected
          (<p> "Access is restricted to sub-classes and classes in the same package."))
        (<p>)
        (<p>)
        (<definition> name: public
          (<p> "Access is unrestricted."))
        (<p>)
        (<p>)
        (<definition> name: final
          (<p> "A final definition cannot be overridden."))
        (<p>)
        (<p>)
        (<definition> name: virtual
          (<p> "A virtual definition can be overridden in sub-classes."))
        (<p>)
        (<p>)
        (<definition> name: chained
          (<p> "A chained method can be overridden in sub-classes and the override must call the overridden method."))
        (<p>)
        (<p>)
        (<definition> name: abstract
          (<p> "A abstract definition must overridden in some sub-class. This modifier is currently unimplemented."))
        (<p>)
        (<p>)
        (<definition> name: inline
          (<p> "An inline method permits the compiler to inline its code."))
        (<p>)
        (<p>)
        (<definition> name: synchronized
          (<p> "A synchronized method is guarantied to always be executing in at most one thread at a time."))
        (<p>)
        (<p>)
        (<definition> name: remote
          (<p> "A remote method can be used remotely (see the JRM package)."))
        (<p>)))
 

  
  (<Section-Doc> name: component-programming title: "Component Programming"
    (<description>
        (<p> "One of the biggest strength of components is the full integration of the programming metaphor with the visual design metaphor they enable. "
          "By seamlessly intermixing programming code and designer data, components brings all the power of programming tools to the design part."))
    (<Class-Doc> name: Component
      (<description>
        (<p> "Object-Oriented Databases")
        (<p>)
        (<p> "Inheritance and Composition")
        (<p>)
        (<p> "The Jazz component system unifies the inheritance and composition based programming models.")
        (<p>)
        (<p>
          "The Component class is by far the most fundamental one. "
          "It is the foundation of all the graphical user interface but can also be extremely usefull in non graphical contexes.")
        (<p>)
        (<p> "Components are the result the following design goals:")
        (<node>
          (<span> " Components should be editable by a graphical editor.")
          (<span> " Components should be savable to disk and restorable from disk.")
          (<span> " Components should be hierarchical.")
          (<span> " Components should integrate seamlessly with the object model.")
          (<span> " Components should integrate seamlessly with the programming language.")))
      (<Property-Doc> name: name getter: get-name setter: set-name
        (<description>
          (<p> "Every component can be named. A name must be a symbol or nil. A name of nil represents an anonymous component.")))
      (<Property-Doc> name: parent getter: get-parent setter: set-parent)
      (<Property-Doc> name: children getter: get-children setter: set-children)
      (<Method-Doc> name: find-component parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, nil is returned.")))
      (<Method-Doc> name: child parameters: "name"
        (<description>
          (<p> "Returns the child whose name is name. If no such child is found, an error is signaled.")))
      (<Method-Doc> name: install)
      (<Method-Doc> name: conclude)
      (<Method-Doc> name: finish)
      (<Method-Doc> name: prepare)
      (<Method-Doc> name: locate))
    (<Class-Doc> name: Form
      (<description>
        (<p>
          "Forms contain properties. "
          "Each subform can redefine parts of the parent form. "
          "Properties can be added, modified or even removed.")
        (<p>)
        (<p>
          "For example, a class X has two properties, a and b. "
          "The derived class Y change the property a. "
          "The resulting form would contain both a and b, with a being the redefined property.")
        (<p>)
        (<p> "X (a = 2, b = 3) -> Y (a = 5) ---> a = 5, b = 3")
        (<p>)
        (<p> "When a form is created, the base form is loaded, then each modification of the successive branches are applied, up to our final form.")
        (<p>)
        (<p> "A property initialized in a class can be impacted by the class's form and all subsequent form redefinitions in the subclasses.")))
    (<Class-Doc> name: Branch
      (<description>
        (<p> "A branch is simply a component that encapsulates a form. "
          "This branch can be installed or removed at will. "
          "Branchs can also be hierarchicaly nested. "
          "Thinking about components, you can now give them static shape with a form, or go further and collect some branchs that can be applied to them or go even further and thats the complete flexibility of programming. ")
        (<p>)
        (<p> "With this naming, every thing becomes very clean -> for example the saved searches are branchs of the search that you package (maybe to a file or maybe you are copy pasting them or even drag and dropping them!) to a file and later on unpackage and reinstall in the search! "
          "Seeing it this way really makes it clear that branchs are clearly an outstanding feature of Jazz. ")
        (<p>)
        (<p> "If I can reach a point where everytning is components that can be packaged for saving, copy pasting, ... and all the tools are based on that, I see branches as a concept that will show that a huge portion of the code out there is basically doing branch management stuff without knowing it. "))))
  (<Section-Doc> name: types title: "Type Annotations"
    (<description>
      (<p> "Jazz is a dynamically typed language. Types are associated with objects as opposed to statically typed languages where types are associated with variables. With a dynamically typed language, type information is always available at runtime contrary to statically typed languages where only the compiler has access to type information")
      (<p>)
      (<p> "Jazz offer optional type declarations.")
      (<p>)
      (<p> "Types are denoted by :")
      (<xmp> "<primitive> (ex: <int> <bool>)")
      (<xmp> "<class> (ex: <View> <Window>)")
      (<p> "denote the type of all objects of type class, the null not included")
      (<xmp> "<class+> (ex: <Point+> <Rect+>)")
      (<p> "denote the type of all objects of type class, the null included")
      (<p>)
      (<p> "Using a &lt;class&gt; type specifier instead of the more generic &lt;class+&gt; specifier will enable the compiler to enforce non null.")))
  (<Section-Doc> name: numbers title: "Numbers"
    (<description>
      )
    (<Section-Doc> name: generic-arithmetic title: "Generic Arithmetic"
      (<description>
        )))
  (<Section-Doc> name: symbols title: "Symbols"
    (<description>
      (<p> "Jazz is symbolic language where symbols are used extensively. Symbols can be used as a very efficient higher level abstraction replacement for integer enumerations")))
  (<Section-Doc> name: sequences title: "Sequences"
      (<description>
        )
    (<Section-Doc> name: lists title: "List"
      (<description>
        (<p> "Lists are the most flexible data structure available in Jazz. They can grow to accommodate any number of elements and this very efficiently. As they are sequences, they are supported by a large number of manipulation functions")))
    (<Section-Doc> name: vectors title: "Vector"
      (<description>
        ))
    (<Section-Doc> name: u8vectors title: "U8Vector"
      (<description>
        ))
    (<Section-Doc> name: strings title: "String"
      (<description>
        ))
    (<Section-Doc> name: queues title: "Queue"
      (<description>
        ))
    (<Section-Doc> name: axises title: "Axis"
      (<description>
        ))
    (<Section-Doc> name: subseqs title: "Subseq"
      (<description>
        )))
  (<Section-Doc> name: iteration title: "Iteration"
    (<description>
      )
    (<Section-Doc> name: sequences-iteration title: "Sequences"
      (<description>
        ))
    (<Section-Doc> name: loop-macro title: "Loop Macro"
      (<description>
        )
    (<Syntax-Doc> name: loop parameters: "..."
      (<description>
        (<code> "for")
        (<code> "in")
        (<code> "in-properties")
        (<code> "iterate")
        (<code> "from")
        (<code> "repeat")
        (<code> "do")
        (<code> "sum")
        (<code> "collect")))))
  (<Section-Doc> name: exceptions title: "Exceptions"
    (<Section-Doc> name: exception title: "Exception"
      (<description>
        )))
  (<Section-Doc> name: input/output title: "Input / Output"
    (<Section-Doc> name: file title: "File"
      (<description>))
    (<Section-Doc> name: directory title: "Directory"
      (<description>))
    (<Section-Doc> name: aliases title: "Aliases"
      (<description>
        "Aliases are symbolic names for directories. "
        "They are similar to CommonLisp's logical pathnames. "
        (<p>)
        "The following aliases are predefined:"
        (<node>
          "Home"
          "User"
          "Bin"
          "Jazz")))
    (<Section-Doc> name: formatted_output title: "Formatted Output"
      (<description>
        (<p> "Implements formatted output.")
        (<p>)
        (<definition> name: format_directives title: "Directives"
          (<table> class: "terminology" width: "500"
            (<th> "Name") (<th> "Accessor") (<th> "Description")
            (<tr> (<td> "ASCII") (<td> "a") (<td> "human readable"))
            (<tr> (<td> "SEXPR") (<td> "s") (<td> "reader readable"))
            (<tr> (<td> "TEXT") (<td> "t") (<td> "textual representation"))
            (<tr> (<td> "PRINT") (<td> "p") (<td> "ascii or sexpr or text"))
            (<tr> (<td> "REAL") (<td> "r") (<td> "real number"))
            (<tr> (<td> "CHAR") (<td> "h") (<td> "character"))
            (<tr> (<td> "LIST") (<td> "l") (<td> "remove parenthesis"))
            (<tr> (<td> "PROPERTIES") (<td> "k") (<td> "properties list"))
            (<tr> (<td> "UNSIGNED") (<td> "u") (<td> "unsigned integer"))
            (<tr> (<td> "HEXADECIMAL") (<td> "x") (<td> "hexadecimal integer"))
            (<tr> (<td> "COLUMN") (<td> "c") (<td> "column"))
            (<tr> (<td> "TAB") (<td> "&") (<td> "insert tab character"))
            (<tr> (<td> "NEW_LINE") (<td> "%") (<td> "insert new line"))
            (<tr> (<td> "LOCALIZE") (<td> "z") (<td> "localized string"))
            (<tr> (<td> "FORMATTED") (<td> "f") (<td> "formatted control"))))
        (<p>)
        (<definition> name: format_parameters title: "Parameters"
          (<p> "{x :a value :b value ?}")
          (<p> ":v -> takes the info from the parameters")
          (<p>)
          (<p> "Examples:")
          (<node>
            (<code> "(format :string \"{_ 5}\")")
            (<code> "(format :string \"{a :width :v :justify right}\" bonjour 20)"))
          (<p>)
          (<p> "Parameters can be optional and can be keyword based.")
          (<node>
            (<span> "list?")
            (<span> "width")
            (<span> "justify -> :left :right")
            (<span> "padding")
            (<span> "separator")
            (<span> "last-separator")
            (<span> "precision")
            (<span> "properties")
            (<span> "empty-value")
            (<span> "detail"))))))
  (<Section-Doc> name: regular-expressions title: "Regular Expressions")
  (<Section-Doc> name: date/time title: "Date / Time")
  (<Section-Doc> name: jml title: "Markup"
    (<description>
      (<p> "JML plays a key role in Jazz. "
        "Almost all data externaly persisted will use JML as its representation format.")
      (<p>)
      (<p> "Key Classes:")
      (<definition> name: JML
        (<p> "A module of JML related functions."))
      (<definition> name: JML-Node
        )
      (<definition> name: JML-Element
        )
      (<definition> name: JML-Text
        )
      (<definition> name: JML-Parser
        )
      (<definition> name: JML-Transformation
        )
      (<definition> name: JML-Renderer
        )))
  (<Section-Doc> name: depot title: "Source Control"
    (<description>
      "A depot is an abstraction for a source control system. "))
  (<Section-Doc> name: database title: "Database"
    (<description>)
    (<Class-Doc> name: Connection
      (<description>
        (<p> "A database connection.")))
    (<Class-Doc> name: Request
      (<description>
        (<p> "A request to a stored procedure.")))
    (<Class-Doc> name: Recordset
      (<description>
        (<p> "A recordset returned by a request."))))
  (<Section-Doc> name: profiling title: "Profiling")
  (<Section-Doc> name: remoting title: "Remoting"
    (<Section-Doc> name: proxies title: "Proxies")
    (<Section-Doc> name: stubs title: "Stubs"))
  (<Section-Doc> name: system title: "System"
    (<Section-Doc> name: process title: "Process")
    (<Section-Doc> name: application title: "Application"))
  (<Section-Doc> name: user-interface title: "User Interface"
    (<description>
      "The cross-platform UI is a high level framework written in Jazz that uses Cairo for backend. It runs on Mac OS X, Windows and X11. ")
    (<Section-Doc> title: "Drawing"
      (<description>)
      (<Section-Doc> title: "Cairo"
        (<description>))
      (<Section-Doc> title: "Surface"
        (<description>))
      (<Section-Doc> title: "Color"
        (<description>))
      (<Section-Doc> title: "Font"
        (<description>))
      (<Section-Doc> title: "Point"
        (<description>))
      (<Section-Doc> title: "Dimension"
        (<description>))
      (<Section-Doc> title: "Rect"
        (<description>))
      (<Section-Doc> title: "Cell"
        (<description>))
      (<Section-Doc> title: "Range"
        (<description>)))
    (<Section-Doc> title: "Windows"
      (<description>)
      (<Class-Doc> name: Window
        (<description>))
      (<Class-Doc> name: Toplevel
        (<description>))
      (<Class-Doc> name: Stage
        (<description>
          "A stage window is the parent window of all documents. "))
      (<Class-Doc> name: Palette
        (<description>
          "Windows of this class should be permanent popups."))
      (<Class-Doc> name: Popup
        (<description>
          "Windows of this class should be temporary popup windows like tooltips, menus, ... "
          "For permanent popups see Palette. "))
      (<Class-Doc> name: Dialog
        (<description>)))
    (<Section-Doc> title: "Basic Views"
      (<description>)
      (<Class-Doc> name: View
        (<description>))
      (<Class-Doc> name: Border-View
        (<description>))
      (<Class-Doc> name: Check-Box
        (<description>))
      (<Class-Doc> name: Group-Box
        (<description>))
      (<Class-Doc> name: Label-View
        (<description>))
      (<Class-Doc> name: Layout-View
        (<description>))
      (<Class-Doc> name: Push-Button
        (<description>))
      (<Class-Doc> name: Radio-Button
        (<description>))
      (<Class-Doc> name: Scroller-View
        (<description>)))
    (<Section-Doc> title: "Text-View"
      (<Class-Doc> name: Text-View
        (<description>)))
    (<Section-Doc> title: "Tree-View"
      (<Class-Doc> name: Tree-View
        (<description>))
      (<Class-Doc> name: Tree-Header
        (<description>))
      (<Class-Doc> name: Tree-Node-Column
        (<description>))
      (<Class-Doc> name: Tree-Label-Column
        (<description>))
      (<Class-Doc> name: Tree-Row
        (<description>)))
    (<Section-Doc> title: "Hosting"
      (<description>)
      (<Section-Doc> title: "Host"
        (<description>))
      (<Section-Doc> title: "Guest"
        (<description>)))
    (<Section-Doc> title: "Layouting"
      (<description>)
      (<Class-Doc> name: Flow-Layout
        (<description>))
      (<Class-Doc> name: Border-Layout
        (<description>)))
    (<Section-Doc> title: "Activation"
      (<description>
        (<table> class: "terminology" width: "500"
          (<th> "Event") (<th> "Description")
          (<tr> (<td> "focus-gain") (<td> "Sent to a view that gains focus"))
          (<tr> (<td> "focus-lose") (<td> "Sent to a view that loses focus"))
          (<tr> (<td> "host-activate") (<td> "Sent to guest when host gains focus"))
          (<tr> (<td> "host-deactivate") (<td> "Sent to guest when host loses focus"))
          (<tr> (<td> "client-activate") (<td> "Sent to each tool when a document activates"))
          (<tr> (<td> "client-deactivate") (<td> "Sent to each tool when last document closes"))
          (<tr> (<td> "stage-activate") (<td> "Sent to stage when last document closes"))
          (<tr> (<td> "stage-deactivate") (<td> "Sent to stage when a first document activates")))))
    (<Section-Doc> title: "Menus"
      (<Class-Doc> name: Menu
        (<description>))
      (<Class-Doc> name: Label-Item
        (<description>))
      (<Class-Doc> name: Separator-Item
        (<description>)))
    (<Section-Doc> title: "Events"
      (<description>
        "Event encapsulation puts almost no pressure on the framework because almost everywhere the direct class override is used. "
        "Events encapsulate amongst other things, modifiers state that is necessary for recording user actions. ")
      (<Class-Doc> name: Event
        (<description>)))
    (<Section-Doc> title: "Clipboard"
      (<description>))
    (<Section-Doc> title: "User Interaction"
      (<description>
        "message-box")))
  (<Section-Doc> name: c-interface title: "C Interface"
    (<Section-Doc> name: c-interface.syntax title: "Syntax"
      (<Form-Doc> name: c-constant parameters: "name value"
        (<description>
          (<p> "A c-constant cannot be modified. Note that currently, a constant definition is simply a definition.")
          ))
      (<Form-Doc> name: c-enumeration parameters: "enumeration-name (name1 value1) (name2 value2) ..."
        (<description>
          (<p> "A c-enumeration definition. "
            "This enumeration will create a definition enumeration-name containing an Enumeration object that can be queried at runtime and create constant definitions name1 : value1, name2 : value2, ...")
          ))
      (<Form-Doc> name: c-structure parameters: "structure-name (type1 field1 <n1>) (type2 field2 <n2>) ..."
        (<description>
          (<p> "A c-structure is a template that can be used to create records containing primitive types. Here, type is any primitive type and field is a symbol that can be used to access this field is records of type structure-name. If the optional n is specified, then an array of n elements of type will be inserted.")
          ))
      (<Form-Doc> name: c-external parameters: "module-name return-type (name param1 param2 ...) <entry-name>"
        (<description>
          (<p> "A c-external entry point into a Windows module, i.e. a dynamic-link library or an executable.")
          ))))
  (<Module-Doc> name: License
  (<description>
    (<p> "Licensing module."
      "This module which is in development, will provide classes to enforce commercial licensing strategies.")))
  (<Module-Doc> name: Designer
  (<description>
    (<definition> name: Designer
      (<p> "A Designer is the interface between a jazz object and a form"))
    (<definition> name: Component-Editor)
    (<definition> name: View-Editor)
    (<definition> name: Branches-Editor)
    (<definition> name: Components-Editor)
    (<p>)
    (<definition> name: Card)
    (<definition> name: Custom-Card)
    (<definition> name: Properties-Card)
    (<definition> name: Value-Row)
    (<p>)
    (<definition> name: Component-Surrogate)
    (<p>)
    (<definition> name: Property)
    (<definition> name: Property-Entry)
    (<definition> name: Property-View)
    (<definition> name: Domain)
    (<p>)
    (<definition> title: "Designer Events"
      (<node>
        (<span> "property-change ")
        (<span> "child-add ")
        (<span> "child-remove ")
        (<span> "child-move ")
        (<span> "update")
        (<span> "refresh")))
    (<p>)
    (<definition> title: "Editor Events"
      (<node>
        (<span> "client-change ")
        (<span> "designer-change ")
        (<span> "branch-changing ")
        (<span> "branch-change ")
        (<span> "selection-changing ")
        (<span> "selection-change")
        (<span> "saving")))
    (<p>)
    (<definition> title: "Notes"
      (<node>
        (<span> "Editing a form is done through a Designer and an instance of the form. Any changes to the instance or its children should be done by calling methods of the designer instead of going to the instance directly. The designer will take care of making the changes as well as recording them.")
        (<span> "Note that by having events generated when properties are modified and some others, this process could be made more automatic. But, this would imply a great performance overhead on the system and also we do not want programmatically modified properties to be recorded by the designer. This is why Jazz sticks will a manually calling the designer approach.")
        (<span> "So, if we have a Z -> Y -> X class hierarchy, an instance of Z can be used to edit the class form of X, Y or Z.")
        (<span> "When Jazz edits an object, it monitors every descendant by installing surrogates in them. Even if the edited component is changed (by double-clicking), we keep the upper surrogates installed (even if they could conceptually be removed) so as to still be able to double-click on them to change again the edited component.")
        (<span> "Surrogates take the place of an edited component and its descendants when there's a need to trap user events sent to the component. They are most commonly used for visual components like views.")
        (<span> "An editor is an view that will permit edition of its client and do so by calling designer methods in response to events generated three optional subviews: a branches tree, a descendants tree and a properties tree. An editor has an installed client on which you can put one or more (currently only one) designers on specific descendants of the client. Each designer will record edition to its part of the client descendants tree.")
        (<span> "So, we have a component and its descendants being monitored by surrogates and one of then is the edited component (so changes to it or any of its descendants is being sent to the designer).")
        (<span> "When editing a form I should also specify the edited branch (can be nil of course).")
        (<span> "Note that branch and form unification while desirable is not a good idea because always having an installed branch for every component instance would impose to great a memory load for a very small gain. Also the present approach has the very nice property of having branches as ordinary objects that could have been developed outside of the main system. They are as any other component, they simply have a different behavior.")
        (<span> "The designer and the various elements of the editor follow the MVC model. "
          "The designer plays the model role and the editor elements are views of this model. "
          "The editor never modifies its view directly. "
          "Instead it calls methods of the designer that will modify the edited component and also send events to every listening view who can then update their interface accordingly.")))))
  (<Module-Doc> name: Library
  (<Class-Doc> name: Node
    (<description>
      (<p> "A node is a class that supports dynamic properties")
      (<p>)
      (<node> "An node can optionally be named")
      (<p>
        "Node properties, for efficiency are stored as slots for direct access but can also be accessed in a generic fashion via the "
        (<reference> href: "get-property")
        " method")
      (<p>)))
  (<Class-Doc> name: Element
    (<description>
      (<p> "An element is a node with a hierarchical structure")
      (<p>)))
  (<Class-Doc> name: Exemplar
    (<description>
      (<p> "An Exemplar is a dynamic class whose hierarchy can be modified at runtime")
      (<p>)
      (<node>
        (<span>
          "Exemplars don't have instances"))
      (<node>
        (<span>
          "All properties are fully inherited in the sense that whenever an exemplar is modified, every descendant is automatically updated. "
          "Because the most used operation is by far property access, exemplars have a full internal copy of every property. "
          "To implement inheritance, exemplars also have a list of which properties are owned by the exemplar, "
          "i.e. what properties should not be updated when an ascendant is modified"))
      (<node>
        (<span>
          "Exemplar properties, for efficiency are stored as slots for direct access but they can also be accessed in a generic fashion via the "
          (<reference> href: "get-property")
          " method"))
      (<node>
        (<span>
          "Exemplars are grouped in an "
          (<reference> href: "Exemplar-Domain")
          " which is the domain in which an exemplar name is a valid reference"))
      (<node>
        (<span>
          "An Exemplar can be named and can inherit from another exemplar via its "
          (<code> "base"))))))
  (<Module-Doc> name: Java
  (<description>
    (<p> "Java integration module")
    (<p>)
    (<p> "This module is at an experimental stage at the moment though it was used to implement full database access through Java's JDBC library.")))
  (<Module-Doc> name: SQL
  (<description>
    (<p> "SQL access module.")
    (<p>)
    (<p> "This module is a very mature module that provides a sophisticated UI over the database access classes of the Access module.")))
  (<Section-Doc> title: "Modules"
      (<Package-Doc> name: jazz title: "jazz"
        (<Section-Doc> title: "Boolean"
          (<Method-Doc> name: eq? parameters: "x y"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "x")
                " is physicaly equal to "
                (<parameter> "y")
                ". In other words, if both memory pointers are the same.")))
          (<Method-Doc> name: neq? parameters: "x y"
            (<description>
              (<p> "The inverse test of eq?.")))
          (<Method-Doc> name: eqv? parameters: "x y"
            (<description>
              (<p> "eqv? will succed if the two objects are eq? or if they can be simply compared without going into their structures. For example, (eq? 2.3 2.3) migth return false whereas (eqv? 2.3 2.3) will always return true.")))
          (<Method-Doc> name: equal? parameters: "x y"
            (<description>
              (<p> "The most general equivalence predicate of all.")
              (<p> "equal? will succed if the two objects are eqv? but will also try to determine if the two objets structures are identical. For example, (eq? (list 1 2 3) (list 1 2 3)) returns false but (equal? (list 1 2 3) (list 1 2 3)) returns true.")))
          (<Method-Doc> name: not parameters: "obj"
            (<description>
              (<p>
                "Returns the logical negation of "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: boolean? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is of "
                (<code> "Boolean")
                " type."))
            (<examples>
              (<example>
                (<code> "(boolean? true)")
                " returns true.")
              (<example>
                (<code> "(boolean? false)")
                " returns true.")
              (<example>
                (<code> "(boolean? nil)")
                " return false.")))
          (<Method-Doc> name: xor parameters: "x y")
          (<Method-Doc> name: = parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: /= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: < parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: <= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: > parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: >= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci/= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci< parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci<= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci> parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci>= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: boolean parameters: "obj")
          (<Method-Doc> name: boolean->integer parameters: "bool")
          (<Method-Doc> name: integer->boolean parameters: "z"))
        (<Section-Doc> title: "Char"
          (<Method-Doc> name: char? parameters: "obj")
          (<Method-Doc> name: jazz-constituent? parameters: "obj")
          (<Method-Doc> name: cpp/java-constituent? parameters: "obj")
          (<Method-Doc> name: alphabetic? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is alphabetic. An object is alphabetic if it is an alphabetic character or a sequence composed only of alphabetic parts.")))
          (<Method-Doc> name: numeric? parameters: "obj"
            (<description>
              (<p> "Tests if obj is numeric. An object is numeric if it is a numeric character or a sequence composed only of numeric parts.")))
          (<Method-Doc> name: alphanumeric? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: whitespace? parameters: "obj"
            (<description>
              (<p> "Tests if obj is whitespace. An object is whitespace if it is a whitespace character or a sequence composed only of whitespace parts.")))
          (<Method-Doc> name: upper-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is upper-case. An object is upper-case if it is an upper-case character or a sequence composed only of upper-case parts.")))
          (<Method-Doc> name: lower-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is lower-case. An object is lower-case if it is a lower-case character or a sequence composed only of lower-case parts.")))
          (<Method-Doc> name: upcase parameters: "obj"
            (<description>
              (<p> "Converts obj to upper-case. If obj is a sequence, every part of obj with be converted to upper-case.")))
          (<Method-Doc> name: downcase parameters: "obj"
            (<description>
              (<p> "Converts obj to lower-case. If obj is a sequence, every part of obj with be converted to lower-case.")))
          (<Method-Doc> name: capitalize parameters: "obj"
            (<description>
              (<p> "Converts obj to capitalized form where every word starts with a capital letter and the rest is in lower-case. If obj is a sequence, every part of obj with be converted to capitalized form."))))
        (<Section-Doc> title: "Class"
          (<description>
            (<p> "The Class type is the supertype of every class. It enables a class to be inspected and manipulated as any other object."))
          (<Method-Doc> name: class? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: class-members parameters: "class"
            (<description>
              (<p> "Returns a list of all members of class.")))
          (<Method-Doc> name: class-fields parameters: "class"
            (<description>
              (<p> "Returns a list of all fields of class.")))
          (<Method-Doc> name: class-slots parameters: "class"
            (<description>
              (<p> "Returns a list of all slots of class."))))
        (<Section-Doc> title: "Closure"
          (<Method-Doc> name: closure? parameters: "obj"))
        (<Section-Doc> title: "Collector"
          (<Method-Doc> name: gc parameters: ""))
        (<Section-Doc> title: "Control"
          (<Method-Doc> name: throw parameters: "name")
          (<Method-Doc> name: exit parameters: ""))
        (<Section-Doc> title: "Debugger"
          (<Method-Doc> name: signal parameters: "exception")
          (<Method-Doc> name: error parameters: "format-string obj ..."))
        (<Section-Doc> title: "Enumeration"
          (<Method-Doc> name: enumeration? parameters: "obj"))
        (<Section-Doc> title: "Eval"
          (<Method-Doc> name: eval parameters: "expr")
          (<Method-Doc> name: identity parameters: "obj"))
        (<Section-Doc> title: "Format"
          (<Method-Doc> name: format parameters: "format-string obj ..."))
        (<Section-Doc> title: "Function"
          (<Method-Doc> name: function? parameters: "obj"))
        (<Section-Doc> title: "Hashtable"
          (<Method-Doc> name: hash-ref parameters: "hashtable key" package-name: Language
            (<description>
              (<p>
                "Gets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                ".")))
          (<Method-Doc> name: hash-set! parameters: "hashtable key value" package-name: Language
            (<description>
              (<p>
                "Sets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                " to "
                (<parameter> "value")
                ".")))
          (<Method-Doc> name: hash-clear parameters: "hashtable key")
          (<Method-Doc> name: empty-hashtable parameters: "hashtable")
          (<Method-Doc> name: load-hashtable parameters: "hashtable file")
          (<Method-Doc> name: hash-remove! parameters: "hashtable key value")
          (<Method-Doc> name: for-each-hash parameters: "proc hashtable"))
        (<Section-Doc> title: "Integer"
          (<Method-Doc> name: integer? parameters: "obj")
          (<Method-Doc> name: even? parameters: "z")
          (<Method-Doc> name: odd? parameters: "z")
          (<Method-Doc> name: quotient parameters: "z1 z2")
          (<Method-Doc> name: modulo parameters: "z1 z2")
          (<Method-Doc> name: separate parameters: "z1 z2")
          (<Method-Doc> name: randomize parameters: "")
          (<Method-Doc> name: random parameters: "n")
          (<Method-Doc> name: bit-not parameters: "n")
          (<Method-Doc> name: bit-and parameters: "n ...")
          (<Method-Doc> name: bit-or parameters: "n ...")
          (<Method-Doc> name: bit-xor parameters: "n ...")
          (<Method-Doc> name: bit-set parameters: "n1 n2 n3")
          (<Method-Doc> name: bit-set? parameters: "n1 n2")
          (<Method-Doc> name: shift-left parameters: "n1 n2")
          (<Method-Doc> name: shift-right parameters: "n1 n2"))
        (<Section-Doc> title: "Interface"
          (<Method-Doc> name: interface? parameters: "obj"))
        (<Section-Doc> title: "List"
          (<Method-Doc> name: car parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: set-car! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the car field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: set-cdr! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the cdr field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: cons parameters: "x y"
            (<description>
              (<p>
                "Returns a newly allocated pair whose car is "
                (<parameter> "x")
                " and whose cdr is "
                (<parameter> "y")
                ".")))
          (<Method-Doc> name: reverse parameters: "seq"
            (<description>
              (<p> "Reverses a sequence.")))
          (<Method-Doc> name: list? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a list, false otherwise."))
            (<examples>
              (<example> "(list? nil) -> true")
              (<example> "(list? '(a b c)) -> true")
              (<example> "(list? 2) -> false")))
          (<Method-Doc> name: nil? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is the empty list, false otherwise.")))
          (<Method-Doc> name: not-nil?)
          (<Method-Doc> name: pair? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a pair and otherwise returns false."))
            (<examples>
              (<example> "(pair? 2) -> false")
              (<example> "(pair? nil) -> false")
              (<example> "(pair? (cons 1 2)) -> true")
              (<example> "(pair? '(a b c)) -> true")))
          (<Method-Doc> name: atom? parameters: "obj")
          (<Method-Doc> name: caar parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cadr parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdar parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cddr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: list parameters: "obj ..."
            (<description>
              (<p> "Returns a list constructed of all its arguments.")))
          (<Method-Doc> name: memq? parameters: "obj list")
          (<Method-Doc> name: memv? parameters: "obj list")
          (<Method-Doc> name: member? parameters: "obj list &key key test")
          (<Method-Doc> name: assq parameters: "obj list")
          (<Method-Doc> name: assv parameters: "obj list")
          (<Method-Doc> name: assoc parameters: "obj list &key key test")
          (<Method-Doc> name: rassoc parameters: "obj list &key key test")
          (<Method-Doc> name: reverse! parameters: "list")
          (<Method-Doc> name: remove! parameters: "obj list")
          (<Method-Doc> name: getprop parameters: "plist key")
          (<Method-Doc> name: getf parameters: "plist key")
          (<Method-Doc> name: setf parameters: "plist key value")
          (<Method-Doc> name: for-each-pair parameters: "proc list")
          (<Method-Doc> name: for-each-property parameters: "proc list"))
        (<Section-Doc> title: "Manifest"
          (<Method-Doc> name: load parameters: "unit-name")
          (<Method-Doc> name: unit-loaded? parameters: "unit-name")
          (<Method-Doc> name: in-manifest? parameters: "unit-name"))
        (<Section-Doc> title: "Map"
          (<Method-Doc> name: map-ref parameters: "map key")
          (<Method-Doc> name: map-set! parameters: "map key value")
          (<Method-Doc> name: map-clear parameters: "map key")
          (<Method-Doc> name: empty-map parameters: "map")
          (<Method-Doc> name: load-map parameters: "map file")
          (<Method-Doc> name: for-each-map parameters: "proc map"))
        (<Section-Doc> title: "Metaclass"
          (<Method-Doc> name: metaclass? parameters: "obj")
          (<Method-Doc> name: metaclass-instance parameters: "metaclass"))
        (<Section-Doc> title: "Number"
          (<Method-Doc> name: + parameters: "obj ...")
          (<Method-Doc> name: - parameters: "obj1 obj2 ...")
          (<Method-Doc> name: * parameters: "obj ...")
          (<Method-Doc> name: number? parameters: "obj")
          (<Method-Doc> name: zero? parameters: "obj")
          (<Method-Doc> name: positive? parameters: "obj")
          (<Method-Doc> name: negative? parameters: "obj")
          (<Method-Doc> name: / parameters: "obj1 obj2 ...")
          (<Method-Doc> name: relate parameters: "x y")
          (<Method-Doc> name: sign parameters: "z")
          (<Method-Doc> name: floor parameters: "r")
          (<Method-Doc> name: round parameters: "r")
          (<Method-Doc> name: ceil parameters: "r")
          (<Method-Doc> name: abs parameters: "z")
          (<Method-Doc> name: min parameters: "obj ...")
          (<Method-Doc> name: max parameters: "obj ...")
          (<Method-Doc> name: between? parameters: "n lower upper")
          (<Method-Doc> name: between parameters: "lower n upper")
          (<Method-Doc> name: in-interval? parameters: "n lower upper")
          (<Method-Doc> name: norm parameters: "x")
          (<Method-Doc> name: near? parameters: "x y distance"))
        (<Section-Doc> title: "Object"
          (<Method-Doc> name: object? parameters: "obj")
          (<Method-Doc> name: copy parameters: "obj"))
        (<Section-Doc> title: "Package"
          (<Method-Doc> name: package? parameters: "obj"))
        (<Section-Doc> title: "Printer"
          (<Method-Doc> name: display parameters: "obj &optional printer")
          (<Method-Doc> name: write parameters: "obj &optional printer")
          (<Method-Doc> name: describe parameters: "obj &optional printer")
          (<Method-Doc> name: new-line parameters: "&optional printer")
          (<Method-Doc> name: print-unreadable parameters: "obj printer proc"))
        (<Section-Doc> title: "Procedure"
          (<Method-Doc> name: procedure? parameters: "obj"))
        (<Section-Doc> title: "Reader"
          (<Method-Doc> name: read parameters: "&optional reader")
          (<Method-Doc> name: get-char parameters: "&optional reader")
          (<Method-Doc> name: unget-char parameters: "char &optional reader")
          (<Method-Doc> name: peek-char parameters: "&optional reader")
          (<Method-Doc> name: end-of-stream? parameters: "&optional reader"))
        (<Section-Doc> title: "Real"
          (<Method-Doc> name: real? parameters: "obj")
          (<Method-Doc> name: sin parameters: "r")
          (<Method-Doc> name: cos parameters: "r")
          (<Method-Doc> name: tan parameters: "r")
          (<Method-Doc> name: asin parameters: "r")
          (<Method-Doc> name: acos parameters: "r")
          (<Method-Doc> name: atan parameters: "r1 r2")
          (<Method-Doc> name: sqrt parameters: "r")
          (<Method-Doc> name: exp parameters: "r")
          (<Method-Doc> name: log parameters: "r")
          (<Method-Doc> name: expt parameters: "r1 r2")
          (<Method-Doc> name: percentage parameters: "part total")
          (<Method-Doc> name: percent parameters: "percent n"))
        (<Section-Doc> title: "Sequence"
          (<description>
            "Sequences are an abstract data type representing objects capable of storing sequences of objects. Some examples of sequences are lists, strings and vectors. The Jazz language possesses a important number of sequence manipulation functions")
          (<Method-Doc> name: sequence? parameters: "obj"
            (<description>
              (<p> "Tests if obj is of Sequence type.")))
          (<Method-Doc> name: length parameters: "sequence"
            (<description>
              (<p>
                "Returns the number of elements in "
                (<parameter> "seq")
                ".")))
          (<Method-Doc> name: element parameters: "sequence n"
            (<description>
              (<p> "Returns the nth element of sequence.")))
          (<Method-Doc> name: set-element! parameters: "sequence n value"
            (<description>
              (<p> "Destructively sets the nth element of sequence to value.")))
          (<Method-Doc> name: empty? parameters: "sequence")
          (<Method-Doc> name: tail parameters: "sequence n"
            (<description>
              (<p> "Returns the elements of sequence that range from n to the end. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: last parameters: "sequence"
            (<description>
              (<p> "Returns the last element of sequence.")))
          (<Method-Doc> name: last-tail parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made-up of only the last element of sequence. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: butlast parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made up of every element of sequence except the last.")))
          (<Method-Doc> name: subseq parameters: "sequence start &optional end"
            (<description>
              (<p> "Returns a sequence made up of the elements of sequence that range from start to end exclusively. If end is omited, the elements are taken till the end of sequence.")))
          (<Method-Doc> name: subseq! parameters: "sequence start &optional end")
          (<Method-Doc> name: sort parameters: "predicate sequence &key key test")
          (<Method-Doc> name: for-each-reversed parameters: "sequence")
          (<Method-Doc> name: append parameters: "sequence"
            (<description>
              (<p>
                "Returns a sequence composed of all the elements of "
                (<parameter> "seq")
                "."))
            (<examples>
              (<example> "(append) -> nil")
              (<example> "(append '(a b c) nil '(1 2) '(1 2 3)) -> (a b c 1 2 1 2 3)")
              (<example> "(append \\\"Hello\\\" \\\" \\\" \\\"there\\\") -> \\\"Hello there\\\"")
              (<example> "(append 2 3) -> <error>\"")))
          (<Method-Doc> name: append! parameters: "sequence ...")
          (<Method-Doc> name: insert! parameters: "obj sequence pos")
          (<Method-Doc> name: insert-sequence! parameters: "sequence inserted pos")
          (<Method-Doc> name: replace-subseq! parameters: "sequence start end replacement")
          (<Method-Doc> name: element-reversed parameters: "sequence n")
          (<Method-Doc> name: for-each parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2")))
          (<Method-Doc> name: map parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2 and collects the results in a list that it returns.")))
          (<Method-Doc> name: map-to parameters: "type proc sequence")
          (<Method-Doc> name: gather parameters: "sequence")
          (<Method-Doc> name: collect parameters: "proc sequence")
          (<Method-Doc> name: collect-if parameters: "predicate sequence")
          (<Method-Doc> name: collect-type parameters: "type sequence")
          (<Method-Doc> name: count parameters: "obj sequence"
            (<description>
              (<p> "Finds the number of occurrences of obj in sequence.")))
          (<Method-Doc> name: count-if parameters: "predicate sequence")
          (<Method-Doc> name: count-type parameters: "type sequence")
          (<Method-Doc> name: find parameters: "object sequence")
          (<Method-Doc> name: find-if parameters: "predicate sequence")
          (<Method-Doc> name: skip parameters: "predicate sequence")
          (<Method-Doc> name: some? parameters: "predicate sequence")
          (<Method-Doc> name: every? parameters: "predicate sequence")
          (<Method-Doc> name: union parameters: "sequence ...")
          (<Method-Doc> name: intersection parameters: "sequence ...")
          (<Method-Doc> name: difference parameters: "sequence1 sequence2"
            (<description>
              (<p> "Returns the set difference sequence1 \\ sequence2.")))
          (<Method-Doc> name: remove parameters: "target sequence")
          (<Method-Doc> name: remove-trailing parameters: "target list")
          (<Method-Doc> name: remove-duplicates parameters: "sequence"
            (<description>
              (<p> "Returns a sequence that has exactly the same elements as sequence and in the same order but with no duplicates.")))
          (<Method-Doc> name: remove-nils parameters: "sequence")
          (<Method-Doc> name: mismatch parameters: "target sequence")
          (<Method-Doc> name: prefix parameters: "sequences")
          (<Method-Doc> name: prefix? parameters: "target sequence")
          (<Method-Doc> name: search parameters: "target sequence")
          (<Method-Doc> name: split parameters: "sequence separator")
          (<Method-Doc> name: split-justified parameters: "sequence width separators")
          (<Method-Doc> name: join parameters: "sequences separator")
          (<Method-Doc> name: substitute parameters: "old new sequence")
          (<Method-Doc> name: substitute-alist parameters: "replacements sequence")
          (<Method-Doc> name: fill! parameters: "sequence object")
          (<Method-Doc> name: replace! parameters: "sequence replacement")
          (<Method-Doc> name: insert-ordered! parameters: "object sequence")
          (<Method-Doc> name: merge-ordered parameters: "proc x y")
          (<Method-Doc> name: random-element parameters: "sequence")
          (<Method-Doc> name: partition parameters: "sequence &key key test")
          (<Method-Doc> name: starts-with? parameters: "string target")
          (<Method-Doc> name: ends-with? parameters: "string target")
          (<Method-Doc> name: first parameters: "sequence")
          (<Method-Doc> name: second parameters: "sequence")
          (<Method-Doc> name: third parameters: "sequence")
          (<Method-Doc> name: fourth parameters: "sequence")
          (<Method-Doc> name: fifth parameters: "sequence")
          (<Method-Doc> name: sixth parameters: "sequence")
          (<Method-Doc> name: seventh parameters: "sequence")
          (<Method-Doc> name: eighth parameters: "sequence")
          (<Method-Doc> name: ninth parameters: "sequence")
          (<Method-Doc> name: tenth parameters: "sequence")
          (<Method-Doc> name: set-first! parameters: "sequence object")
          (<Method-Doc> name: set-second! parameters: "sequence object")
          (<Method-Doc> name: set-third! parameters: "sequence object")
          (<Method-Doc> name: set-fourth! parameters: "sequence object")
          (<Method-Doc> name: set-fifth! parameters: "sequence object")
          (<Method-Doc> name: set-sixth! parameters: "sequence object")
          (<Method-Doc> name: set-seventh! parameters: "sequence object")
          (<Method-Doc> name: set-eighth! parameters: "sequence object")
          (<Method-Doc> name: set-ninth! parameters: "sequence object")
          (<Method-Doc> name: set-tenth! parameters: "sequence object"))
        (<Section-Doc> title: "String"
          (<Method-Doc> name: string? parameters: "object")
          (<Method-Doc> name: empty-string? parameters: "object"))
        (<Section-Doc> title: "Symbol"
          (<Method-Doc> name: symbol? parameters: "object")
          (<Method-Doc> name: keyword? parameters: "object")
          (<Method-Doc> name: symbol->keyword parameters: "symbol")
          (<Method-Doc> name: keyword->symbol parameters: "keyword")
          (<Method-Doc> name: string->symbol parameters: "string")
          (<Method-Doc> name: symbol->string parameters: "symbol")
          (<Method-Doc> name: find-symbol parameters: "string")
          (<Method-Doc> name: generate-symbol parameters: "&optional prefix")
          (<Method-Doc> name: symbol-bound? parameters: "symbol")
          (<Method-Doc> name: symbol-unbound? parameters: "symbol"))
        (<Section-Doc> title: "Thread"
          (<Method-Doc> name: primordial-thread parameters: "")
          (<Method-Doc> name: current-thread parameters: ""))
        (<Section-Doc> title: "Time"
          (<Method-Doc> name: clock parameters: ""))
        (<Section-Doc> title: "Type"
          (<Method-Doc> name: type? parameters: "object")
          (<Method-Doc> name: new parameters: "class object ...")
          (<Method-Doc> name: new-in parameters: "context class object ...")
          (<Method-Doc> name: coerce parameters: "object type")
          (<Method-Doc> name: class-of parameters: "object")
          (<Method-Doc> name: is? parameters: "object type")
          (<Method-Doc> name: is-not? parameters: "object type")
          (<Method-Doc> name: typed? parameters: "object type-name")
          (<Method-Doc> name: subtype? parameters: "class type")
          (<Method-Doc> name: subtyped? parameters: "class type-name")
          (<Method-Doc> name: type-name parameters: "type")
          (<Method-Doc> name: type-ascendant parameters: "type")
          (<Method-Doc> name: type-descendants parameters: "type")
          (<Method-Doc> name: type-ancestors parameters: "type"))
        (<Section-Doc> title: "Unit"
          (<Method-Doc> name: unit? parameters: "object")
          (<Method-Doc> name: all-units parameters: ""))
        (<Section-Doc> title: "Values"
          (<Method-Doc> name: values parameters: "object ..."))
        (<Section-Doc> title: "Vector"
          (<Method-Doc> name: vector? parameters: "object"))))
  )
