;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.workbench.Workbench-Manager jazz


(import (jazz.builder)
        (jazz.builder.workbench)
        (jazz.designer)
        (jazz.groupware)
        (jazz.io)
        (jazz.jml)
        (jazz.language.c)
        (jazz.language.java)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.library.template)
        (jazz.literals)
        (jazz.platform)
        (jazz.runtime)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.utilities))


(class Workbench-Manager extends Editor-View implements Exit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        @convert
        (<Push-Combo>     name: configure
          (<!>            name: body               portfolio: :icons image-name: {Bitmap-Resource "Configure"} tooltip?: #t tooltip-text: "Configure" @wait action-handler: @wait {Event-Handler :form on-configure})
          (<!>            name: pick               action-handler: {Event-Handler :form on-configurations-menu}))
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" image-name: {Bitmap-Resource "Synchronize"} portfolio: :icons action-handler: {Event-Handler :form on-highlight-document}))
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           flat?: #t)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Project" width: 291 highlight-color: {Color name: Dark-Blue})))))
  
  
  (method meta (external-name . rest)
    'workbench-manager)

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta (host-icon)
    {Bitmap-Resource "Workbench"})
  
  
  (method meta (host-title)
    "Workbench")
  
  
  (method (install-in-host host)
    (setup-active-configuration)
    (setup-active-project))
  
  
  (method (setup-workbench-title configuration)
    @convert
    (let ((cell (get-child~ (user-data-row~ (get-tree) (get-workbench)) 0))
          (title
            (if (not configuration)
                "Workbench"
              (format "Workbench - {a}" (get-name~ configuration)))))
      (set-title~ cell title)))
  
  
  (method (setup-active-configuration)
    (let* ((pref (get-preferences 'build))
           (active (get-active-configuration~ pref))
           (configuration (essay active (child~ (child~ pref 'configurations) active))))
      (setup-workbench-title configuration)
      (set-active-configuration configuration)))
  
  
  (method (setup-active-project)
    (let* ((pref (get-preferences 'build))
           (project (get-active-project~ pref))
           (workbench (get-workbench)))
      (when (and project workbench)
        (activate-project (find-project~ workbench project)))))
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method (get-tools-view)
    (locate 'tools))
  
  
  (method (focus-default)
    (let ((tree (get-tree)))
      (acquire-focus~ tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (get-tree)
    (locate '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  (method (new-controller)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (install rest)
    (nextmethod rest)
    (set-shown?~ (locate-component '(descendants header)) #f)
    (set-editor~ (locate 'descendants) self)
    (add-exit-listener~ (get-application) self)
    (set-client (get-workbench)))
  
  
  (method (get-designer-class)
    Workbench-Designer)
  
  
  (method (prepare-exit)
    (when designer
      (save-designer~ designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (on-designer evt)
    (nextmethod evt)
    (case (get-kind~ evt)
      ((:child-add) (child-add (get-property~ evt child:) (get-property~ evt parent:)))
      ((:child-remove) (child-remove (get-property~ evt child:)))))
  
  
  (method (child-add child parent)
    (when (is? child Project)
      (project-add~ designer child)))
  
  
  (method (child-remove child)
    (when (is? child Project)
      (project-remove~ designer child)))

  
  ;;;
  ;;;; Events
  ;;;
    
  
  (method (key-press key)
    (case key
      ((#\return) (launch-selection))))
  
  
  (method (on-configurations-menu evt)
    (let* ((sender (get-sender~ evt))
           (combo (get-combo~ sender))
           (pos (new Point 0 (get-height~ (get-size~ sender)))))
      (track-popup-menu~ sender (new Configurations-Menu client: self) pos initiator: combo)))
  
  
  (method (on-highlight-document evt)
    (highlight-document))
  
  
  (method (on-add-project evt)
    (add-project))
  
  
  (method (on-add-file evt)
    (add-file))
  
  
  (method (on-add-group evt)
    (add-group))
  
  
  (method (on-install-project evt)
    (let* ((current-directory? (get-shift?~ evt))
           (parent (selected-object))
           (file (with-import-directory current-directory? parent
                   (function (directory)
                     (choose-file extensions: '(("Jazz Files" . "jazz")) directory: directory)))))
      (install-project file parent #f)))
  
  
  (method (on-import-files evt)
    (import-files (get-shift?~ evt)))
  
  
  (method (on-import-directory evt)
    (import-directory (get-shift?~ evt)))
  
  
  (method (on-synchronize-content evt)
    (synchronize-content))
  
  
  (method (on-update-catalog evt)
    (update-catalog))
  
  
  (method (on-edit evt)
    (edit-selection))
  
  
  (method (on-activate evt)
    (activate-selection))
  
  
  (method (on-launch evt)
    (launch-selection))
  
  
  (method (on-run evt)
    (run-selection))
  
  
  (method (on-distribute evt)
    (distribute-selection))
  
  
  (method (on-properties evt)
    (show-properties))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-controller~ guest))
               (moniker (get-moniker~ controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (project-file (find-source~ workbench moniker)))
              (if (not project-file)
                  (bell)
                (highlight-component project-file))))))))
  
  
  (method (highlight-component component)
    (let* ((tree (get-tree))
           (row (component-row~ tree component)))
      (if (not row)
          (bell)
        (ensure-expanded~ tree row)
        (set-single-selection~ tree (row-rank~ tree row)))))

  
  ;;;
  ;;;; Select
  ;;;
  
  
  (method public (select-current)
    (select-project))
  
  
  (method (select-project)
    (let ((project (get-modal Project-Selector)))
      (when project
        (activate-project project))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current)
    (edit-project (current-project)))
  
  
  (method (edit-selection)
    (let ((objects (selected-objects)))
      (for-each (function (object)
                  (typecase object
                    ((Workbench) (edit-workbench))
                    ((Project) (edit-project object))))
                objects)))
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method (edit-workbench)
    (let ((appl (get-application))
          (file Workbench-File))
      (edit-document~ appl file)))
  
  
  (method (edit-project project)
    (if (is-not? project Project)
        (bell)
      (let ((module-name (get-module-name~ project)))
        (if (not module-name)
            (bell)
          (let ((source (find-module-source module-name)))
            (if (not source)
                (bell)
              (edit-document~ (get-application) source)))))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (definition Project-Templates-Directory
    {Directory Jazz "lib" "jedi" "templates" "project"})
  
  (definition File-Templates-Directory
    {Directory Jazz "lib" "jedi" "templates" "file"})
  
  
  (method protected (add-project)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (receive (kind template repository package) (get-modal Add-Project-Dialog)
          (let* ((directory (new Directory (tokenise-filename (repository-directory repository))))
                 (package-name (string->symbol package))
                 (package-parts (map ->string (split-identifier package-name)))
                 (product (last package-parts))
                 (project (capitalize product))
                 (template (new-directory~ Project-Templates-Directory template))
                 (destination directory)
                 (associations (list (cons 'package package)
                                     (cons 'product product)
                                     (cons 'product-title (capitalize product))
                                     (cons 'product-module package)
                                     (cons 'product-directories package-parts)
                                     (cons 'project project)
                                     (cons 'project-title project)
                                     (cons 'project-module (format "project.{a}" package))
                                     (cons 'project-directories (cons "project" package-parts)))))
            (copy-template template destination associations)
            (unless (repository-find-package repository package-name)
              (let ((package-file (new-file~ destination (list package (format "{a}.pck" package)))))
                (repository-add-package repository (load-package repository package-name (parse~ package-file)))))
            (let ((project-file (new-file~ destination (append (list package "src" "project") package-parts (list (format "{a}-Manifest.jazz" project))))))
              (let ((project-component (install-project project-file parent #f)))
                (select-component~ (get-tree) project-component)
                (let ((src-directory (new-directory~ destination (list package "src"))))
                  (let ((src-component (import-pathname project-component src-directory project-component #f recursive?: #f)))
                    (iterate-directory~ src-directory
                      (function (dir)
                        (unless (member? (get-name~ dir) '("project") test: ci=?)
                          (import-pathname project-component dir src-component #f)))
                      files?: #f
                      directories?: #t
                      recursive?: #f)))
                (process-refresh~ designer project-component 'descendants))))))))
  
  
  (method protected (add-file)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (either (default-import-directory parent must-exist?: #f) {Directory Profile} @not-sure-this-is-best (get-current-directory))))
          (when (or (exists?~ default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list~ default-directory)) type: 'question) 'yes))
            (create-directories~ default-directory)
            (receive (kind template directory name) (get-modal Add-File-Dialog directory: default-directory)
              (let* ((extension (extract-extension template))
                     (template (new-file~ File-Templates-Directory (concatenate template ".template")))
                     (destination (new-file~ directory (format "{a}.{a}" name extension)))
                     (module (find-pathname-module (parse~ destination)))
                     (associations (list (cons 'name name) (cons 'module module))))
                (copy-template template destination associations)
                (let ((component (import-pathname (ascendant-project parent) destination parent #f)))
                  (select-component~ (get-tree) component)))))))))
  
  
  (method protected (add-group)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (add-component-class~ (get-tree) Project-Group parent: parent))))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method (install-project file parent descendant?)
    (let ((parent-project (ascendant-project parent)))
      (when (validate-pathnames parent-project (list file))
        (let ((name (string->symbol (get-base~ file)))
              (module (find-pathname-module (parse~ file))))
          (if (not module)
              (error "Unable to find module associated to project file: \"{a}\"" (get-name~ file))
            (let ((class (load-class name module))
                  (workbench (get-workbench)))
              (if (not (subtype? class Project))
                  (error "The file \"{a}\" does not contain a Project class" (get-name~ file))
                (let ((project (new class workbench: workbench parent: parent)))
                  (add-child~ designer project parent)
                  (set-tag-module~ designer project parent module)
                  (reorder-component~ (get-tree) project)
                  (load-catalog~ workbench project)
                  (user-message "{s} installed" (get-presentation~ project))
                  project))))))))

  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  
  (method (import-filter? project file)
    (let ((ext (get-extension~ file))
          (extensions (effective-include-extensions (get-include-extensions~ project))))
      (if extensions
          (or (member? ext extensions test: ci=?)
              ;; special case for those annoying extensionless files
              (member? (get-name~ file) '("README" "INSTALL")))
        (known-extension-frame-class~ (get-application) ext))))
  
  
  (method (import-directory current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (directory (with-import-directory current-directory? parent
                        (function (directory)
                          (choose-directory directory: directory))))
           (count (count-files~ directory filter: (function (file) (import-filter? project file)) max-count: MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) type: 'question) 'yes))
        (when (validate-pathnames project (list directory))
          (let ((component (import-pathname project directory parent #f)))
            (process-refresh~ designer component 'descendants))
          (user-message "{a} imported"
                        (parse~ directory))))))
  
  
  (method (import-files current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (files (with-import-directory current-directory? parent
                    (function (directory)
                      (choose-file multiple-selection?: #t directory: directory)))))
      (import-pathnames project files parent)))
  
  
  (method protected (import-pathnames project pathnames parent)
    (when (validate-pathnames project pathnames)
      (for-each (function (pathname)
                  (let ((component (import-pathname project pathname parent #f)))
                    (process-refresh~ designer component 'descendants)))
                (sort nu<? pathnames key: (function (pathname) (get-name~ pathname))))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (format-cardinality count)
                      (format-plural count)))))
  
  
  (method (import-pathname project pathname parent descendant? (recursive?: recursive? #t))
    (let ((name (get-name~ pathname)))
      (typecase pathname
        ((Directory)
         (let ((project-file (new-file~ pathname (format "{a}.jazz" name))))
           (if (and (exists?~ project-file) (determine-project-file? project-file))
               (install-project project-file parent #t)
             (let ((subgroup (new Project-Directory directory: pathname)))
               (add-child~ designer subgroup parent design-events?: (not descendant?) descendant?: descendant?)
               (set-property~ designer subgroup 'directory pathname design-events?: (not descendant?))
               (when recursive?
                 (iterate-directory~ pathname
                   (function (pathname)
                     (import-pathname project pathname subgroup #t))
                   files?: #f
                   directories?: #t
                   sort?: #t
                   recursive?: #f)
                 (iterate-directory~ pathname
                   (function (pathname)
                     (import-pathname project pathname subgroup #t))
                   files?: #t
                   directories?: #f
                   sort?: #t
                   recursive?: #f))
               subgroup))))
        ((File)
         (when (or (not descendant?) (import-filter? project pathname))
           (if (determine-project-file? pathname)
               (install-project pathname parent descendant?)
             (import-file pathname parent descendant?)))))))
  
  
  (method (import-file file parent descendant?)
    (let* ((model (extension-model (get-extension~ file)))
           (name (if (eq? model Jazz-File) (string->symbol (get-base~ file)) {}))
           (project-file (new model name: name source: file))
           (workbench (get-workbench)))
      (add-child~ designer project-file parent design-events?: (not descendant?) descendant?: descendant?)
      (set-property~ designer project-file 'source file design-events?: (not descendant?))
      (when (eq? model Jazz-File)
        (set-name~ designer project-file name design-events?: (not descendant?))
        (add-entry~ workbench name project-file))
      project-file))
  
  
  (method (determine-project-file? file)
    #f
    @convert-manifest
    (let ((ext (get-extension~ file)))
      (when (ci=? ext "jazz")
        (let ((info (extract-jazz-file-category file)))
          (when info
            (receive (package type name extends) info
              (when (in-manifest? extends)
                (subtype? (autoload extends) Project))))))))
  
  
  (method (default-import-directory object (must-exist?: must-exist? #t))
    (letrec ((default
               (function (object)
                 (typecase object
                   ((Project)
                    {})
                   ((Project-Directory)
                    (get-directory~ object))
                   (else
                    {})))))
      (let ((dir (default object)))
        (when dir
          (anchorize~ dir)))))
  
  
  (method (with-import-directory current-directory? object proc)
    (let ((default-directory (essay (not current-directory?) (default-import-directory object))))
      (if (and default-directory (exists?~ default-directory))
          (with-preserved-current-directory
            (function ()
              (proc default-directory)))
        (proc {}))))
  
  
  (method (extension-model ext)
    (cond ((member? ext '("jazz") test: ci=?) Jazz-File)
          ((member? ext '("java") test: ci=?) Java-File)
          ((member? ext '("c" "cpp") test: ci=?) C-File)
          ((member? ext '("bmp") test: ci=?) Bitmap-File)
          ((member? ext '("cur") test: ci=?) Cursor-File)
          ((member? ext '("ico") test: ci=?) Icon-File)
          ((member? ext '("wav") test: ci=?) Sound-File)
          (else Project-File)))
  
  
  (method protected (ascendant-project component)
    (if (is? component Project)
        component
      (ascendant-project (get-parent~ component))))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content)
    @wait-complete
    (let* ((object (selected-object))
           (project (ascendant-project object))
           (directory (default-import-directory object must-exist?: #f)))
      (if (not (exists?~ directory))
          (error "Directory {s} not found" directory)
        (let ((fact (new List-Factory))
              (component-name
               (function (component)
                 (->string (get-name~ component))))
              (pathname-name
               (function (pathname)
                 (get-name~ pathname))))
          (letrec ((fold
                    (function (component pathname path)
                      (let ((children (get-children~ component))
                            (content (get-content~ pathname)))
                        (merge-ordered (function (what key left right)
                                         (let ((path (cons key path)))
                                           (case what
                                             ((:left) (put~ fact (list what path)))
                                             ((:right) (put~ fact (list what path)))
                                             ((:same)
                                              (when (directory? right)
                                                (fold left right path))))))
                                       (sort ci<? children key: component-name)
                                       (sort ci<? content key: pathname-name)
                                       left-key: component-name
                                       right-key: pathname-name
                                       case-insensitive?: #t)))))
            (fold object directory '())
            (let ((out-of-synch (get-output~ fact)))
              (if (null? out-of-synch)
                  (message-box "Content is already synchronized")
                (let* ((border (new Synchronize-Border size: {Dimension 500 200}))
                       (tree (locate~ border 'tree))
                       (add
                        (function (what path)
                          (let ((c0 (new Tree-Node title: (join path "/") image: {Bitmap-Resource "OpenedFolder"})))
                            (add-row~ tree children: (list c0 {} {} {}))))))
                  (for-each (function (info)
                              (bind (what path) info
                                (add what (reverse path))))
                            out-of-synch)
                  (message-box "The following elements are out of synch. Synchronize?" class: Synchronize-Box type: 'confirmation content: border)))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames project pathnames)
    @convert-to-checking-conflicts-with-an-understanding-of-the-module-hierarchy
    (validate
      (function (report)
        (letrec ((workbench (get-workbench))
                 (iterate
                  (function (pathname)
                    (typecase pathname
                      ((Directory)
                       (iterate-directory~ pathname iterate
                         files?: #t
                         directories?: #t
                         sort?: #t
                         recursive?: #f))
                      ((File)
                       (when (import-filter? project pathname)
                         (let ((model (extension-model (get-extension~ pathname))))
                           (when (eq? model Jazz-File)
                             (let* ((name (string->symbol (get-base~ pathname)))
                                    (jazz-file (get-entry~ workbench name)))
                               (when jazz-file
                                 (report jazz-file)))))))))))
          (for-each iterate pathnames)))))
  
  
  (method (validate iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (function (jazz-file)
          (put~ already-defined jazz-file)))
      (let ((already-defined (get-output~ already-defined)))
        (if (null? already-defined)
            #t
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following categor{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-y/ies count)
                                 (format-is/are count)))
                 (text
                  `(,header
                    ()
                    ,@(map (function (jazz-file)
                             (let ((project (get-project~ jazz-file))
                                   (action
                                    (function ()
                                      (close-modal-dialog
                                        (function ()
                                          (highlight-component jazz-file))))))
                               (list :bulleted
                                     (list :hyperlink action
                                           (format "{a} defined in {a}"
                                                   (get-name~ jazz-file)
                                                   (get-presentation~ project))))))
                           (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                    ,@(when too-many?
                        (list (list :bulleted "..."))))))
            (message-box text)
            #f)))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection)
    (activate-object (selected-object)))
  
  
  (method (activate-object object)
    (if (and (is? object Project)
             (concrete?~ object))
        (activate-project object)
      (bell)))
  
  
  (method (activate-project project)
    (unless (eq? project (get-active-project))
      (let ((tree (get-tree)))
        (when (get-active-project)
          (unhighlight-component~ tree (get-active-project)))
        (set-active-project project)
        (when (get-active-project)
          (let ((row (user-data-row~ tree (get-active-project) visible?: #f)))
            (when row
              (ensure-expanded~ tree row)))
          (highlight-component~ tree (get-active-project))))
      (let ((appl (get-application)))
        (update-project-actions~ appl))))
    
  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (with-cursor :wait
      (function ()
        (let ((catalog (require-catalog~ (selected-project))))
          (load-content~ catalog)
          (update~ catalog)))))
    
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method public (test-current)
    (let ((project (current-project)))
      (project-test~ project)))

  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-current)
    (debug-project (current-project)))
  
  
  (method public (launch-selection)
    (let ((appl (get-application))
          (tree (get-tree)))
      (for-each (function (component)
                  (typecase component
                    ((Project)
                     (debug-project component))
                    ((Project-File)
                     (let* ((file (get-effective-source~ component))
                            (ext (get-extension~ file)))
                       (edit-document~ appl file)))))
                (selected-components~ tree))))
      
  
  (method (debug-project project)
    (debug-project~ (get-application) project
      configuration: (get-active-configuration)))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method public (run-current)
    (let ((project (current-project)))
      (run-project project)))


  (method public (run-selection)
    )

  
  (method (run-project project)
    (run-project~ (get-application) project))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let ((moniker (get-moniker~ (get-controller~ guest))))
          (compile-moniker moniker)))))
  
  
  (method public (compile-moniker moniker)
    (compile-file moniker #f)
    @temp
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file moniker project-file))))
  
  
  (method (compile-file moniker project-file)
    (let ((name (find-pathname-module (parse~ moniker))))
      (if (not name)
          (bell)
        (launch-runtime~ (get-application) arguments: (list "-compile" (->string name)) show-console?: #t))))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let* ((moniker (get-moniker~ (get-controller~ guest)))
               (workbench (get-workbench))
               (file (find-source~ workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  (method (preprocess-file moniker file)
    (let ((proc
           (function (thread)
             (let ((project (get-project~ file)))
               (prepare-maps~ project)
               (prepare-directories~ project)
               (user-message "Preprocessing {a}..." moniker)
               (let ((output (get-output-log))
                     (timer (new Timer)))
                 (clear-results~ output)
                 (select-results~ output)
                 (select-palette Output-Log)
                 (preprocess~ file project {} {} output force?: #t)
                 (user-message "Preprocessing done in {a}" (get-duration-in-seconds~ timer)))))))
      (proc {})))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current evt)
    (let ((project (current-project)))
      (if (not project)
          (bell)
        (build-project project))))
  
  
  (method public (build-current)
    ;; should be only the project's files...
    (save-all~ (get-application))
    (let ((project (current-project)))
      (build-project project)))
  
  
  (method (build-project project)
    (if (concrete?~ project)
        (let ((project-name (get-product~ project)))
          (launch-runtime~ (get-application) arguments: (list "-make" (->string project-name)) show-console?: #t))
      (bell)))
  
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current)
    (let ((project (current-project)))
      (clean-project project)))
  
  
  (method (clean-project project)
    (if (concrete?~ project)
        ;; to complete
        {}
      (bell)))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current evt)
    (let ((project (selected-project)))
      (if (not project)
          (bell)
        (distribute-project project))))
  
  
  (method public (distribute-current)
    (let ((project (current-project)))
      (distribute-project project)))
  
  
  (method (distribute-selection)
    (distribute-project (selected-project)))
  
  
  (method (distribute-project project)
    (let* ((mode         'backup)
           (left         (project-distribution~ project))
           (right        (project-distribution-directory~ project))
           (content      (project-distribution-list~ project))
           (ignored-dirs (list ".git" ".hg" "bin"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories left-moniker: left right-moniker: right left-content: content ignored-nodes: ignored-dirs ignored-leaves: files ignored-extensions: extensions host-visible?: #f)))
      (with-cursor :wait
        (function ()
          (compare-trees~ (get-guest~ frame))
          (bring-to-front~ frame)
          (set-visible?~ frame #t)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object)
    (let ((tree (get-tree)))
      (selected-component~ tree)))
  
  
  (method (selected-objects)
    (let ((tree (get-tree)))
      (selected-components~ tree)))
  
  
  (method (selected-project)
    (let ((object (selected-object)))
      (when (is? object Project)
        object)))
  
  
  (method (selected-concrete-project)
    (let ((object (selected-object)))
      (when (and (is? object Project)
                 (concrete?~ object))
        object)))
  
  
  (method (current-project)
    (if (not (get-active-project))
        (error "No active project")
      (get-active-project)))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu)
    (let ((object (selected-object)))
      (typecase object
        ((Project-Group) (new-group-menu object))
        ((Project)
         (if (concrete?~ object)
             (new-concrete-project-menu object)
           (new-project-menu object)))
        (else (new Element-Menu client: (get-tree))))))
  
  
  (method (new-group-menu object)
    (let ((menu (new Group-Menu client: (get-tree))))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-concrete-project-menu object)
    (let ((menu (new Concrete-Project-Menu client: (get-tree))))
      (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-project-menu object)
    (let ((menu (new Project-Menu client: (get-tree))))
      @wait-complete
      (when (is? object Workbench)
        (set-visible?~ (locate~ menu 'synchronize-content) #f))
      (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (update-group/project-menu menu)
    (let ((tree (get-tree)))
      (when (> (length (get-selection~ tree)) 1)
        (set-visible?~ (locate~ menu 'install-project) #f)
        (set-visible?~ (locate~ menu 'import-files) #f)
        (set-visible?~ (locate~ menu 'import-directory) #f))))
  
  
  (method (install-configuration configuration)
    (set-active-configuration configuration)
    (setup-workbench-title configuration))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-project = {s}" (get-active-project))
      (format :console "{%}project-designers =")
      (let* ((pairs (sort < (get-project-designers~ designer) key: (function (pair) (type-name (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (project . designer) pair
                      (format :console "{%}  {a} {a}" (type-name (class-of project)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}projects-table =")
      (let* ((pairs (sort < (table-keys/values (get-projects-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . project) pair
                      (format :console "{%}  {a} {a}" name project)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}categories-table =")
      (let* ((pairs (sort < (table-keys/values (get-categories-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . category) pair
                      (format :console "{%}  {a} {a}" name category)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}resources-table =")
      (let* ((pairs (sort < (table-keys/values (get-resources-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . resource) pair
                      (format :console "{%}  {a} {a}" name resource)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Controller
;;;


(class Workbench-Manager-Controller extends Editor-View-Controller
  
  
  (method (document-status)
    "Workbench"))


;;;
;;;; Synchronize-Border
;;;


(class Synchronize-Border extends Border-View
  
  
  (form
    (<install>                                     border-type: solid border-color: {Color name: Outline-Border}
      (<Scroller-View>                             flat?: #t hscroll?: #t vscroll?: #t
        (<!>                         name: content layout-type: fill
          (<Tree-Header>                           flat?: #t
            (<!>                     name: content
              (<Synchronize-Tree>    name: tree))))))))


;;;
;;;; Configurations-Menu
;;;


(class Configurations-Menu extends Context-Menu
  
  
  (method (finish rest)
    (nextmethod rest)
    (let ((configurations (get-children~ (get-preferences '(build configurations)))))
      (for-each (function (configuration)
                  (let* ((name (get-name~ configuration))
                         (title (either (get-title~ configuration) (->string name))))
                    (new Check-Item parent: self checked?: (eq? configuration (get-active-configuration)) title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list configuration: configuration)))))
                configurations)))
  
  
  (method (on-action evt)
    (let ((appl (get-application))
          (configuration (get-property~ evt configuration:)))
      (install-configuration~ client configuration))))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-project         title: "Add Project..." before: add-item action: {Action workbench-manager add-project})
      (<Label-Item>     name: add-file            title: "Add Document..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: install-project     title: "Install Project..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit                title: "Edit" before: add-item icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager edit})
      (<Separator-Item>                           before: add-item)
      (<Label-Item>     name: add-project         title: "Add Project..." before: add-item action: {Action workbench-manager add-project})
      (<Label-Item>     name: add-file            title: "Add Document..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: install-project     title: "Install Project..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut)
      (<Label-Item>     name: update-catalog      title: "Update Catalog" before: cut icon: {Bitmap-Resource "Catalog"} action: {Action workbench-manager update-catalog})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Concrete-Project-Menu
;;;


(class Concrete-Project-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "Select as Active Project" before: cut default?: #t action: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit title: "Edit" before: cut default?: #t icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager launch})
      (<Separator-Item>            before: cut)))))
