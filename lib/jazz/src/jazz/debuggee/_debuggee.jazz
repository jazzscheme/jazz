;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.stub)
        (jazz.jrm)
        (jazz.jrm.register.stub)
        (jazz.network))


;;;
;;;; Local
;;;


(definition local-process
  {})


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (new Debuggee-Process)))))


;;;
;;;; Controller
;;;


(definition controller-debugger
  {})


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller controller-register)
  (detach-from-controller)
  (set! controller-debugger (require-object~ controller-register 'debugger))
  (setup-local-process)
  (set-console-port-getter console-port-getter)
  (attach-process~ controller-debugger local-process)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    (set! local-process {})))


(definition public (detach-from-debugger)
  (when controller-debugger
    (when (live?~ controller-debugger)
      (detach-process~ controller-debugger local-process))
    (set! controller-debugger {})
    (detach-consoles)))


(definition (setup-debuggee)
  (let ((arg (command-argument "debugger")))
    (when arg
      (receive (host port) (parse-host/service arg)
        (if (not port)
            (error "Ill-formed debugger argument: {a}" arg)
          (start-remote-listener)
          (attach-to-controller (new-remote-register (either host #u8(127 0 0 1)) port)))))))


(definition (update-debuggee-process)
  (when controller-debugger
    (update-process~ controller-debugger local-process)))


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (function (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (append *stops* (list stop))))))


(definition (unregister-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (remove! stop *stops*)))))


(definition (get-thread-stops thread)
  (let ((queue (new-queue)))
    (for-each (function (stop)
                (when (eq? (get-thread~ stop) thread)
                  (enqueue queue (new Debuggee-Stop-Local-Proxy stop))))
              *stops*)
    (queue-list queue)))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  (slot remote    getter generate)
  (slot pump      getter generate)
  (slot tail      getter generate)
  (slot head      getter generate)
  (slot readtable accessors generate)
  (slot context   accessors generate)
  (slot history   accessors generate)
  
  
  (method (initialize remote pump tail head)
    (set! remote~self remote)
    (set! pump~self pump)
    (set! tail~self tail)
    (set! head~self head)
    (set! readtable~self {})
    (set! context~self (unspecified))
    (set! history~self {})))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (function (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition (thread-console thread)
  (if (not controller-debugger)
      {}
    (with-consoles-mutex
      (function ()
        (either (table-ref *consoles* thread #f)
                (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))))
                  (table-set! *consoles* thread console)
                  console))))))


(definition (thread-console-pump-port thread)
  (get-tail~ (thread-console thread)))

(definition (thread-console-port thread)
  (get-head~ (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))


(definition (make-debuggee-console thread-proxy)
  (receive (head tail) (open-string-pipe (list permanent-close: #f readtable: jazz-readtable))
    (let ((console (register-console~ controller-debugger local-process thread-proxy)))
      (let ((pump (start-debuggee-console-pump console tail)))
        (new Console console pump tail head)))))


(definition (console-port-getter)
  (if (not controller-debugger)
      (terminal-port)
    (get-head~ (current-console))))


(definition (detach-consoles)
  (define (detach-console thread console)
    (stop-debuggee-console-pump (get-pump~ console))
    (close-port (get-tail~ console))
    (close-port (get-head~ console))
    (table-clear *consoles* thread))
  
  (with-consoles-mutex
    (function ()
      (for-each (function (pair)
                  (bind (thread . console) pair
                    (detach-console thread console)))
                (table-keys/values *consoles*)))))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump console port)
  (thread-start!
    (new-system-thread
      (function ()
        (start-pump (new Permanent-Port port)
          (function (str)
            (when controller-debugger
              (console-output~ controller-debugger console str)))))
      'debuggee-console-pump)))


(definition (stop-debuggee-console-pump thread)
  (thread-interrupt! thread
    thread-exit))


;;;
;;;; Repl
;;;


(definition current-repl-level
  (make-parameter 0))

(definition current-repl-frame
  (make-parameter {}))


(definition (with-repl-thread thread reason port level thunk)
  (let ((thread (start-repl-thread thread reason port level)))
    (unwind-protect
        (thunk)
      (thread-interrupt! thread
        thread-exit))))


(definition (start-repl-thread thread reason port (level 0))
  (thread-start!
    (new-system-thread
      (function ()
        (when (= level 0)
          (display-banner port))
        (when reason
          (display reason port))
        (display-prompt port level)
        (read-eval-print-loop thread port level))
      'repl)))


(definition (display-banner port)
  (format port "{a} {a}{%}{%}"
          (current-process-title)
          (current-process-version))
  (force-output port))


(definition (display-prompt port level)
  (when (> level 0)
    (format port "{a}" level))
  (format port "> ")
  (force-output port))


(definition (read-eval-print-loop thread port level)
  (declare (proper-tail-calls))
  (let (iterate)
    (read-eval-print thread port level)
    (iterate)))


(definition (read-eval-print thread port level)
  (let ((console (thread-console thread)))
    (let ((expr (with-readtable (either (essay console (get-readtable~ console)) scheme-readtable)
                  (function ()
                    (read port)))))
      (if (eof-object? expr)
          (thread-post thread 'resume-loop
            (function ()
              (let ((restarts (find-restarts 'resume-loop)))
                (when (> (length restarts) 1)
                  (newline port)
                  ;; skip the current resume-loop restart
                  (let ((restart (second restarts)))
                    (invoke-restart restart))))))
        (let ((result
                (thread-call thread 'evaluate
                  (function ()
                    (evaluate expr)))))
          (when (and (thread-call-result? result)
                     (specified? result))
            (repl-result-history-add result)
            (format port "{s}" result)
            (format port "{%}"))
          (display-prompt port level)
          (force-output port))))))


(definition (evaluate expr)
  (define (context-init console)
    (let ((context (get-context~ console)))
      (if (unspecified? context)
          (let ((new-context
                  (let ((process (get-process)))
                    (if process
                        (context-alias (initial-console-context~ process))
                      {}))))
            (set-context~ console new-context)
            new-context)
        context)))
  
  (define (context-alias context)
    (when (and (enumerator? context) (get-process))
      (process-alias~ (get-process) context)))
  
  (define (parse-unquote-command expr)
    (if (and (pair? expr)
             (eq? (car expr) 'unquote)
             (pair? (cdr expr)))
        (let ((unquoted (cadr expr)))
          (cond ((symbol? unquoted)
                 (values unquoted '()))
                ((pair? unquoted)
                 (values (car unquoted) (cdr unquoted)))
                (else
                 (values {} {}))))
      (values {} {})))
  
  (let ((console (current-console)))
    (let ((context (if (not console) {} (context-init console)))
          (frame-box (current-repl-frame)))
      (receive (command arguments) (parse-unquote-command expr)
        (cond ((eq? command 'ctx)
               (if (null? arguments)
                   context
                 (let ((ctx (car arguments)))
                   (let ((new-context (either (context-alias ctx) (evaluate ctx))))
                     (when (symbol? new-context)
                       (load-module new-context))
                     (when console
                       (set-context~ console new-context)
                       (set-readtable~ console (if (not new-context) {} jazz-readtable)))
                     new-context))))
              (#f @convert frame-box
               (evaluate-in-frame (unbox frame-box) expr))
              (else
               (evaluate-in-context context expr)))))))


(definition (evaluate-in-frame frame expr)
  (let ((frame (unbox box)))
    (if (not frame)
        (eval expr)
      (let ((cont (serial->object (get-continuation~ frame))))
        (eval-within-no-winding expr cont)))))


(definition (evaluate-in-context context expr)
  (parameterize ((jazz.walk-for 'eval))
    (cond ((not context)
           (eval expr))
          ((symbol? context)
           (let ((module-name context))
             (load-module module-name)
             (locate-library-declaration module-name)
             (eval
               `(library ,module-name jazz
                ,expr))))
          (else
           (let ((class-identifier (type-name (class-of context))))
             (let ((module-name (identifier-module class-identifier))
                   (class-name (identifier-name class-identifier)))
               (load-module module-name)
               (locate-library-declaration module-name)
               (eval
                 `(library ,module-name jazz
                  (class ,class-name
                    (method (evaluate)
                      ,expr)))))
             ((dispatch context 'evaluate) context))))))


;;;
;;;; Exception
;;;


(definition (jazz-exception-debugger exc)
  (let ((debugger (get-controller-debugger)))
    (if (or (not debugger) (not (use-debugger?)))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (function ()
          (continuation-capture
            (function (continuation)
              (let ((reason (exception-reason exc))
                    (detail (exception-detail exc)))
                (invoke-debugger 'exception reason detail continuation)))))))))


(definition (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition (break (reason {}))
  (continuation-capture
    (function (continuation)
      (invoke-debugger 'break reason {} continuation))))


;;;
;;;; Debugger
;;;


(definition (invoke-debugger kind reason detail continuation)
  (release-load-mutex!)
  (let* ((thread (current-thread))
         (port (get-console-port))
         (level (+ (current-repl-level) 1))
         (restarts (compute-restarts thread))
         (stop (new Debuggee-Stop thread kind reason detail continuation restarts)))
    (dynamic-wind
      (function ()
        (register-stop stop))
      (function ()
        (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))
              (stop-proxy (new Debuggee-Stop-Local-Proxy stop)))
          (parameterize ((current-repl-level level))
            (with-repl-thread thread reason port level
              (function ()
                (parameterize ((current-repl-frame (box {})))
                  (debuggee-stop~ controller-debugger local-process thread-proxy stop-proxy kind reason)
                  (let ((process (get-process)))
                    (if (not process)
                        (debuggee-loop)
                      (process-debuggee-loop~ process)))))))))
      (function ()
        (unregister-stop stop)))))


;; this is a temporary solution to threads keeping the load-mutex locked
;; see the todo file for details on what needs to be done for a clean solution
(definition (release-load-mutex!)
  (let ((load-mutex (get-load-mutex)))
    ;; limit the scope of the patch by a heuristic that could turn out
    ;; to be wrong if a loading thread depends on a thread that errors
    ;; but this is very far fetched and will do until a clean solution
    (when (eq? (mutex-owner load-mutex) (current-thread))
      (mutex-unlock! load-mutex))))


(definition (compute-restarts thread)
  (let ((previous-stops (get-thread-stops thread))
        (all-restarts (current-restarts)))
    (map (function (restart)
           (new Debuggee-Restart-Local-Proxy (new Debuggee-Restart thread restart)))
         (if (null? previous-stops)
             all-restarts
           (let ((skip (apply max (map (function (stop) (length (get-restarts~ stop))) previous-stops))))
             (subseq all-restarts 0 (- (length all-restarts) skip)))))))


(definition (debuggee-loop)
  (let (loop)
    (with-restart-catcher 'resume-loop "Resume loop" {}
      (function ()
        (let ((thunk (thread-read)))
          (with-jazz-exception-debugger
            thunk))))
    (loop)))


;;;
;;;; View
;;;


(definition *current-view-debugger*
  #f)


(definition public (current-view-debugger)
  (when (not *current-view-debugger*)
    (set! *current-view-debugger* (new View-Debugger)))
  *current-view-debugger*))
