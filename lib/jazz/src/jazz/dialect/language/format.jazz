;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Format
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jazz.dialect.language.format jazz.dialect


(proclaim (warn optimizations))


(import (jazz.dialect.kernel)
        (jazz.dialect.language.functional))


(native jazz.error)


;;;
;;;; Lexicon
;;;


;; (format "{a width: 10 justify: :right} {l}" 5 lst)

;; In the preceding format :
;;   directives -> {a} and {l}
;;   parameters -> width: 10 justify: :right
;;   arguments  -> 5 and lst


;;;
;;;; Format
;;;


(definition public (format . rest)
  
  (define (process-format destination control-string arguments out control-reader arguments-scan)
    
    ;;;
    ;;;; Process
    ;;;
    
    (define (process reader (output? #t))
      (let ((done? #f))
        (while (not done?)
          (let ((c (read-char reader)))
            (if (eof-object? c)
                (set! done? #t)
              (case c
                ((#\~)
                 (let ((c (require-char reader)))
                   (when output?
                     (write-char c out))))
                ((#\{)
                 (let ((c (peek-char reader)))
                   (case c
                     ((#\?)
                      (if (not output?)
                          (error "Recursive conditional directive not yet supported")
                        (read-char reader)
                        (conditional-directive reader)))
                     (else
                      (let ((directive (read reader))
                            (parameters (read-parameters reader)))
                        (case directive
                          ((a) (ascii-directive parameters output?))
                          ((s) (sexpr-directive parameters output?))
                          ((t) (text-directive parameters output?))
                          ((p) (print-directive parameters output?))
                          ((c) (char-directive parameters output?))
                          ((u) (unsigned-directive parameters output?))
                          ((b) (binary-directive parameters output?))
                          ((x) (hexadecimal-directive parameters output?))
                          ((r) (real-directive parameters output?))
                          ((l) (list-directive parameters output?))
                          ((k) (properties-directive parameters output?))
                          ((_) (column-directive parameters output?))
                          ((&) (tab-directive parameters output?))
                          ((%) (newline-directive parameters output?))
                          (($) (freshline-directive parameters output?))
                          ((!) (force-directive parameters output?))
                          ((z) (localize-directive parameters output?))
                          (else (error "Unknown format directive ~{{t}}" directive))))))))
                (else
                 (when output?
                   (write-char c out))))))))
      (when (and (toplevel? reader) (not (arguments-empty?)))
        (error "Too many format arguments")))
    
    (define (read-parameters reader)
      (read-delimited reader "format parameter" #\}))
    
    (define (toplevel? reader)
      (eq? reader control-reader))
    
    (define (arguments-empty?)
      (null? arguments-scan))
    
    ;;;
    ;;;; Conditional
    ;;;
    
    (define (conditional-directive reader)
      (cond ((eqv? (peek-char reader) #\:)
             (read-char reader)
             (process-conditional reader #t))
            (else
             (process-conditional reader #f))))
    
    (define (read-control-string reader)
      (let ((printer (open-output-string))
            (done? #f))
        (while (not done?)
          (let ((c (require-char reader)))
            (if (and (eqv? c #\~) (eqv? (peek-char reader) #\}))
                (begin
                  (read-char reader)
                  (set! done? #t))
              (write-char c printer))))
        (get-output-string printer)))
    
    (define (process-conditional reader explicit?)
      (let ((subreader (open-input-string (read-control-string reader)))
            (output? (or (and explicit? (next-argument)) (and (not explicit?) (peek-argument)))))
        (process subreader output?)))
    
    ;;;
    ;;;; Directives
    ;;;
    
    (define (ascii-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (display argument printer))))))
    
    (define (sexpr-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (write argument printer))))))
    
    (define (text-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (textual argument printer))))))
    
    (define (print-directive parameters output?)
      (let ((argument (next-argument))
            (detail (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-expr argument detail printer))))))
    
    (define (char-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (write-char argument printer))))))
    
    (define (unsigned-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-unsigned argument printer))))))
    
    (define (binary-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-binary argument printer))))))
    
    (define (hexadecimal-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-hexadecimal argument printer))))))
    
    (define (real-directive parameters output?)
      (let ((argument (next-argument))
            (precision (get-precision parameters)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-real argument precision printer))))))
    
    (define (list-directive parameters output?)
      (let* ((argument (next-argument))
             (separator (get-separator parameters))
             (last-separator (get-last-separator parameters separator))
             (before (get-before parameters))
             (after (get-after parameters))
             (detail (get-detail parameters)))
        (when output?
          (with-justification parameters
            (function (printer)
              (print-list argument separator last-separator before after detail printer))))))
    
    (define (properties-directive parameters output?)
      (let ((argument (next-argument))
            (properties (get-properties parameters))
            (empty-value (get-empty-value parameters))
            (detail (get-detail parameters)))
        (when output?
          (with-justification parameters
            (function (printer)
              (let ((scan argument))
                (while (not-null? scan)
                  (let ((key (car scan))
                        (value (cadr scan)))
                    (when (and (or (null? properties) (memq key properties))
                               (or (not empty-value) (neq? value empty-value)))
                      (write-char #\space printer)
                      (print-expr key detail printer)
                      (write-char #\space printer)
                      (print-expr value detail printer)))
                  (set! scan (cddr scan)))))))))
    
    (define (column-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (write-char #\space out))))))
    
    (define (tab-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (write-char #\tab out))))))
    
    (define (newline-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (newline out))))))
    
    (define (freshline-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (fresh-line out)
          (loop (repeat (- count 1))
                (do (newline out))))))
    
    (define (force-directive parameters output?)
      (when output?
        (force-output out)))
    
    (define (localize-directive parameters output?)
      (unimplemented 'localize-directive)
      @unimpl
      (let ((argument (localize (next-argument))))
        (when output?
          (with-justification parameters
            (function (printer)
              (display argument printer))))))
    
    ;;;
    ;;;; Justification
    ;;;
    
    (define (with-justification parameters proc)
      (let ((width (get-width parameters)))
        (if (not width)
            (proc out)
          (let ((justification (get-justify parameters))
                (padding (get-padding parameters))
                (printer (open-output-string)))
            (proc printer)
            (let ((buffer (get-output-string printer)))
              (justify buffer width justification padding))))))
    
    (define (justify buffer width justification padding)
      (let ((size (cardinality buffer)))
        (if (>= size width)
            (display buffer out)
          (let ((n (- width size)))
            (case justification
              ((:left)
               (display buffer out)
               (loop (repeat n)
                     (do (write-char padding out))))
              ((:right)
               (loop (repeat n)
                     (do (write-char padding out)))
               (display buffer out)))))))
    
    ;;;
    ;;;; Parameters
    ;;;
    
    (define (optional-parameter parameters default)
      (if (null? parameters)
          default
        (let ((param (car parameters)))
          (if (eq? param :v)
              (next-argument)
            param))))
    
    (define (keyword-parameter parameters keyword default)
      (let ((param (getf parameters keyword not-found: default)))
        (if (eq? param :v)
            (next-argument)
          param)))
    
    (define (get-list? parameters)
      (keyword-parameter parameters list?: #f))
    
    (define (get-width parameters)
      (keyword-parameter parameters width: {}))
    
    (define (get-justify parameters)
      (let ((param (keyword-parameter parameters justify: :left)))
        (if (not (memq param '(:left :right)))
            (error "Unknown justification {t}" param)
          param)))
    
    (define (get-padding parameters)
      (keyword-parameter parameters padding: #\space))
    
    (define (get-separator parameters)
      (keyword-parameter parameters separator: " "))
    
    (define (get-last-separator parameters separator)
      (keyword-parameter parameters last-separator: separator))
    
    (define (get-before parameters)
      (keyword-parameter parameters before: {}))
    
    (define (get-after parameters)
      (keyword-parameter parameters after: {}))
    
    (define (get-precision parameters)
      (keyword-parameter parameters precision: 3))
    
    (define (get-properties parameters)
      (keyword-parameter parameters properties: '()))
    
    (define (get-empty-value parameters)
      (keyword-parameter parameters empty-value: {}))
    
    (define (get-detail parameters)
      (keyword-parameter parameters detail: :reader))
    
    ;;;
    ;;;; Arguments
    ;;;
    
    (define (peek-argument)
      (if (null? arguments-scan)
          (error "Not enough format arguments for {t}" control-string)
        (car arguments-scan)))
    
    (define (next-argument)
      (if (null? arguments-scan)
          (error "Not enough format arguments for {t}" control-string)
        (prog1 (car arguments-scan)
          (set! arguments-scan (cdr arguments-scan)))))
    
    (process control-reader))
  
  (define (parse-format proc)
    (if (string? (car rest))
        (proc ':string (car rest) (cdr rest))
      (proc (car rest) (cadr rest) (cddr rest))))
  
  (parse-format
    (function (destination control-string <string> arguments <list>)
      (with-printer destination
        (function (printer)
          (process-format destination control-string arguments printer (open-input-string control-string) arguments))))))


;;;
;;;; Formatting
;;;


(definition public (format-cardinality n <fx>)
  (if (= n 0)
      "No"
    (->string n)))


(definition public (format-plural n <fx> (plural "s"))
  (if (= n 1)
      ""
    plural))


(definition public (format-gender word)
  (if (vowel? (first word))
      "an"
    "a"))


(definition public (format-is/are n <fx>)
  (if (= n 1)
      "is"
    "are"))


(definition public (format-was/were n <fx>)
  (if (= n 1)
      "was"
    "were"))


(definition public (format-y/ies n <fx>)
  (if (= n 1)
      "y"
    "ies"))


(definition public (format-following name n <fx>)
  (if (= n 1)
      (format "{a} was" name)
    (format "{a} {a}s where" n name)))


;;;
;;;; Printing
;;;


(definition (print-expr expr detail (printer (current-output-port)))
  (print~ expr printer detail))


(definition (print-unsigned n (printer (current-output-port)))
  (unimplemented 'print-unsigned))


(definition (print-binary n (printer (current-output-port)))
  (display (number->string n 2) printer))


(definition (print-hexadecimal n (printer (current-output-port)))
  (display (number->string n 16) printer))


(definition (print-real r precision (printer (current-output-port)))
  (let* ((str (number->string (exact->inexact r)))
             (dot-index (find str #\.))
             (pre-str (substring str 0 dot-index))
             (frac-str (substring str (+ dot-index 1) (string-length str)))
             (frac-len (string-length frac-str)))
        (cond ((= precision frac-len)
               (display str printer))
              ((< frac-len precision)
               (display (string-append pre-str "." frac-str (make-string (- precision frac-len) #\0)) printer))
              (else
               (let* ((first-part (substring frac-str 0 precision))
                      (last-part  (substring frac-str precision frac-len))
                      (temp-str
                        (let* ((str (number->string
                                     (round (string->number
                                              (string-append first-part "." last-part)))))
                               ;; minus 1 to ignore the dot
                               (len (- (string-length str) 1)))
                          ;; if precision is 0 we don't need to do anything
                          (if (or (= precision len) (= precision 0))
                              str
                            (string-append (make-string (- precision len) #\0) str))))
                      (dot-pos (find temp-str #\.))
                      (carry?
                        (and (> dot-pos precision)
                             (> (round (string->number
                                         (string-append "0." frac-str)))
                                0)))
                      (new-frac
                        (substring temp-str 0 precision)))
                 (display (string-append
                            (if carry? (number->string (+ 1 (string->number pre-str))) pre-str)
                            "."
                            new-frac)
                          printer))))))
           


(definition (print-list list separator last-separator before after detail (printer (current-output-port)))
  (when (not-null? list)
    (when before
      (display before printer))
    (let (iter (scan list))
      (let ((expr (car scan)))
        (print~ expr printer detail)
        (let ((next (cdr scan)))
          (when (not-null? next)
            (if (pair? next)
                (display (if (null? (cdr next)) last-separator separator) printer)
              (display " . " printer)
              (print~ next printer detail))
            (iter (cdr scan))))))
    (when after
      (display after printer)))))
