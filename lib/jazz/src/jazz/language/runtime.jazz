;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Language Runtime
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.language.runtime jazz.dialect


(import (irregex)
        (scheme.kernel)
        (jazz.language.loop (phase syntax)))


(native private jazz:system-format)


;;;
;;;; Object
;;;


(proclaim (warn optimizations))


(class primitive Object metaclass Object-Class
  
  
  (method core chained (initialize self)
    )

  
  (method core chained (destroy self)
    )
  
  
  (method core public virtual (call-print self output detail)
    (print self output detail))
  
  
  (method core virtual (print-object self output detail)
    )
  
  
  (method core hidden virtual (tree-fold self down up here seed environment)
    )
  
  
  (method public virtual (print self output detail)
    (if (object? self)
        (print-unreadable self output
          (lambda (output)
            ))
      (print-detail self output detail)))
  
  
  (method package (print-detail self output detail)
    (if (eq? detail :human)
        (display self output)
      (write self output)))
  
  
  (method package virtual (assemble self)
    )
  
  
  (method public virtual (class-actions self)
    '())
  
  
  (method public virtual (focus-actions self)
    '())
  
  
  (method public virtual (guest-actions self)
    '())
  
  
  (method public virtual (hash-object self)
    (error "No hashing defined for {t}" self))
  
  
  (method package virtual (copy-object self deep?)
    (error "Unable to copy {t}" self))


  (method package virtual (compare-object self object)
    :incompatible)


  (method package virtual (ci-compare-object self object)
    :incompatible)


  (method package virtual (di-compare-object self object)
    :incompatible)


  (method protected virtual (describe-object self output)
    (print self output #t))


  (method public virtual (initialized? self)
    ;; todo
    #t)


  (method public virtual (close self)
    (destroy self))


  (method public virtual (destroying? self)
    ;; todo
    #f)


  (method public virtual (destroyed? self)
    ;; todo
    #f)
  
  
  (method public virtual (walk-references self proc)
    )
  
  
  (method public virtual (setup-context self context)
    )
  
  
  (method public virtual (get-sort-value self)
    #f)
  
  
  (method package virtual (coerce-string self)
    (error "{t} cannot be coerced into a string" self))
  
  
  (method package virtual (iterate-object self)
    (error "{t} is not an iterable type" self))


  ;;;
  ;;;; Marshall
  ;;;
  
  
  (method protected virtual (marshall-size self)
    )
  
  
  (method protected virtual (marshall-to self obj content)
    )
  
  
  (method protected virtual (unmarshall-from self obj content)
    )


  ;;;
  ;;;; Compare
  ;;;


  (method protected virtual (object-similar? self object)
    (eq? self object))


  (method package virtual (object-alphabetic? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-numeric? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-alphanumeric? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-whitespace? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-upper-case? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-lower-case? self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-upcase self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-downcase self)
    (error "{t} is not an alphabetic type" self))


  (method package virtual (object-capitalize self)
    (error "{t} is not an alphabetic type" self)))


(definition public inline (compare a <Object> b <Object>)
  (if (eqv? a b)
      :equal
    (compare-object a b)))


(definition public inline (ci-compare a <Object> b <Object>)
  (if (eqv? a b)
      :equal
    (ci-compare-object a b)))


(definition public inline (di-compare a <Object> b <Object>)
  (if (eqv? a b)
      :equal
    (di-compare-object a b)))


(definition public (copy obj <Object>)
  (subcopy obj #f))


(definition public (subcopy obj <Object> deep? <bool>)
  (copy-object obj deep?))


(definition public (print-unreadable object <Object> output proc)
  (let ((class-name (reference-name (get-name (class-of object))))
        (string (with-exception-catcher
                  (lambda (exc)
                    "@error@")
                  (lambda ()
                    (let ((output (open-output-string)))
                      (proc output)
                      (get-output-string output)))))
        (serial (object->serial object)))
    (display "{" output)
    (display class-name output)
    (unless (string=? string "")
      (display " " output)
      (display string output))
    (display " #" output)
    (display serial output)
    (display "}" output)))


(definition package (native-class name)
  (error "Scheme primitives must be used to create {a}" name))


(definition public (hash obj <Object>)
  (hash-object obj))


;;;
;;;; Leak detection
;;;


(definition public track-leaks?
  (global-setting 'track-leaks? #f))


(definition protected leak-stack?
  (global-setting 'leak-stack? #f))

(definition protected leak-backtrace?
  (global-setting 'leak-backtrace? #f))

(definition protected leak-identifiers?
  (global-setting 'leak-identifiers? #t))

(definition protected leak-depth
  (global-setting 'leak-depth 8))


(definition public *allocated* <table>
  (make-table weak-keys: #t test: eq?))

(definition public *double-freed* <table>
  (make-table test: eq?))


(definition public (leak-info)
  (cond (leak-stack?
         (execution-stack identifiers?: leak-identifiers? depth: leak-depth))
        (leak-backtrace?
         (execution-backtrace leak-depth))
        (else
         #t)))


(definition public (allocated obj)
  (when track-leaks?
    (let ((info (leak-info)))
      (table-set! *allocated* obj info)
      (make-will obj
        (lambda (obj)
          (let ((info (table-ref *allocated* obj #f)))
            (when info
              (leaked obj info))))))))

(definition public (freed obj)
  (when track-leaks?
    (if (table-ref *allocated* obj #f)
        (table-set! *allocated* obj)
      (let ((info (leak-info)))
        (table-set! *double-freed* obj info)))))


(definition *leaks-mutex*
  (make-mutex))

(definition *leaks*
  '())

(definition public (leaks)
  *leaks*)

(definition (leaked obj info)
  (mutex-lock! *leaks-mutex*)
  (set! *leaks* (cons (cons obj info) *leaks*))
  (mutex-unlock! *leaks-mutex*))


;;;
;;;; Functional
;;;


(proclaim (warn optimizations))


;;;
;;;; Module
;;;


(class Module extends Object
  
  
  (slot name    getter generate)
  (slot access  getter generate)
  (slot exports getter generate)
  (slot entries getter generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" name)))))


;;;
;;;; Field
;;;


(class Field extends Object
  
  
  (slot name getter generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" name))))
  
  
  (method package virtual abstract (field-locator self))
  (method package virtual abstract (field-ref self))
  (method package virtual abstract (field-set! self value)))


;;;
;;;; Native
;;;


(class Native extends Field
  
  
  (slot symbol getter generate)
  
  
  (method override (field-locator self)
    symbol)
  
  
  (method override (field-ref self)
    (and (global-bound? symbol)
         (global-ref symbol)))
  
  
  (method override (field-set! self value)
    (when (global-bound? symbol)
      (global-set! symbol value))))


;;;
;;;; Runtime-Reference
;;;


(class Runtime-Reference extends Object
  
  
  (slot resolver      getter generate)
  (slot serialization getter generate))


;;;
;;;; Define
;;;


(class Define extends Field
  
  
  (slot locator getter generate)
  
  
  (method override (field-locator self)
    locator)
  
  
  (method override (field-ref self)
    (global-ref locator))
  
  
  (method override (field-set! self value)
    (global-set! locator value)))


;;;
;;;; Definition
;;;


(class Definition extends Field
  
  
  (slot locator getter generate)
  
  
  (method override (field-locator self)
    locator)
  
  
  (method override (field-ref self)
    (global-ref locator))
  
  
  (method override (field-set! self value)
    (global-set! locator value)))


;;;
;;;; Type
;;;


(class Type extends Object
  
  
  (method core virtual (of-type? self object))
  (method core virtual (of-subtype? self subtype))
  (method core virtual (specifiable? self))
  (method core virtual (category-type? self))
  (method core virtual (resolve-type self))
  (method core virtual (emit-specifier self))
  (method core virtual (emit-type self source-declaration environment))
  (method core virtual (emit-test self value source-declaration environment))
  (method core virtual (emit-cast self value source-declaration environment)))


;;;
;;;; Category
;;;


(class Category extends Type
  
  
  (slot identifier   getter generate)
  (slot fields       getter generate)
  (slot virtual-size getter generate)
  (slot ancestors    getter generate)   ;; all the ancestors up to the root
  (slot descendants  getter generate)   ;; only the direct descendants
  
  
  (method core virtual (update-category self))
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" (get-name self)))))
  
  
  (method public (get-name self)
    identifier)
  
  
  (method public virtual (mop-category-field self field-name)
    (category-field self field-name))
  
  
  (method public virtual (mop-field-value self property)
    ))


(definition public (typed? obj category-identifier)
  (some? (lambda (category <Category>)
           (eq? (get-name category) category-identifier))
         (get-ancestors (class-of obj))))


;;;
;;;; Class
;;;


(class Class extends Category
  
  
  (slot ascendant       getter generate)
  (slot interfaces      getter generate)
  (slot slots           getter generate)
  (slot instance-slots  getter generate)
  (slot instance-size   getter generate)
  (slot level           getter generate)
  (slot virtual-names   getter generate)
  (slot class-table     getter generate)
  (slot interface-table getter generate)
  (slot user-data       getter generate)
  
  
  (method public virtual (coerce-object self obj)
    (error "Unable to coerce {t} into a {t}" obj (category-name self)))
  
  
  (method public virtual (external-name self (error?: error? #t))
    (and error? (error "{t} class does not define an external name" (category-name self))))
  
  
  (method public virtual (marshall-object self object)
    #f)
  
  
  (method public virtual (unmarshall-object self content)
    #f)
  
  
  (method public virtual (mop-instance-slots self object)
    (get-instance-slots self)))


(class Object-Class metaclass Class extends Class)


(definition public inline (class? obj)
  (is? obj Class))


(definition public inline (instance-of? obj class)
  (eq? (class-of obj) class))


(definition public inline (coerce object <Object> class <Class>)
  (if (is? object class)
      object
    (coerce-object class object)))


;;;
;;;; Interface
;;;


(class Interface extends Category
  
  
  (slot ascendants getter generate)
  (slot rank       getter generate))


;;;
;;;; Method
;;;


(class Method extends Field
  
  
  (slot dispatch-type       getter generate)
  (slot implementation      getter generate)
  (slot implementation-tree getter generate)
  (slot category-rank       getter generate)
  (slot implementation-rank getter generate))


;;;
;;;; Method Node
;;;


(class Method-Node extends Object
  
  
  (slot category            getter generate)
  (slot implementation      getter generate)
  (slot next-node           getter generate)
  (slot next-implementation getter generate)
  (slot children            getter generate))


;;;
;;;; Call-Site
;;;


(class Call-Site extends Object
  
  
  (slot name       accessors generate)
  (slot id         accessors generate)
  (slot properties accessors generate)
  (slot procedure  accessors generate)
  (slot monitor    accessors generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" name)))))


;;;
;;;; Queue
;;;


(class Queue extends Object
  
  
  (slot head   getter generate)
  (slot tail   getter generate)
  (slot shared getter generate))


;;;
;;;; Generic
;;;


(class Generic extends Object
  
  
  (slot locator              getter generate)
  (slot name                 getter generate)
  (slot root-specific        getter generate)
  (slot pending-specifics    getter generate))


(class Specific extends Object
  
  
  (slot dynamic-signature    getter generate)
  (slot implementation       getter generate)
  (slot ancestor-specifics   getter generate)
  (slot descendant-specifics getter generate))


;;;
;;;; Bool
;;;


(class Bool-Class extends Class)


(class primitive Bool metaclass Bool-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "bools")))


;;;
;;;; Boolean
;;;


(class Boolean-Class extends Class)


(class primitive Boolean metaclass Boolean-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "booleans")))


(definition public inline (/= x y)
  (not (= x y)))


(definition public inline (neq? x y)
  (not (eq? x y)))


(definition public inline (xor x y)
  (or (and x (not y))
      (and (not x) y)))


(definition public (nu=? n m . rest)
  (and (eq? (compare n m) :equal)
       (let ((first m))
         (let (iter (scan rest))
           (cond ((null? scan)
                  #t)
                 ((neq? (compare (car scan) first) :equal)
                  #f)
                 (else
                  (iter (cdr scan))))))))


(definition public (nu/=? n m . rest)
  (if (null? rest)
      (neq? (compare n m) :equal)
    (not (apply nu=? n m rest))))


(definition public (nu<? n m . rest)
  (and (case (compare n m)
         ((:less) #t)
         ((:greater :equal) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (max m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare max value)
               ((:less) (iter (cdr scan) value))
               ((:greater :equal) #f)
               (else (error "Cannot compare {t} and {t}" max value))))))))


(definition public (nu<=? n m . rest)
  (and (case (compare n m)
         ((:less :equal) #t)
         ((:greater) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (max m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare max value)
               ((:less :equal) (iter (cdr scan) value))
               ((:greater) #f)
               (else (error "Cannot compare {t} and {t}" max value))))))))


(definition public (nu>? n m . rest)
  (and (case (compare n m)
         ((:greater) #t)
         ((:less :equal) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (min m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare min value)
               ((:greater) (iter (cdr scan) value))
               ((:less :equal) #f)
               (else (error "Cannot compare {t} and {t}" min value))))))))


(definition public (nu>=? n m . rest)
  (and (case (compare n m)
         ((:greater :equal) #t)
         ((:less) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (min m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare min value)
               ((:greater :equal) (iter (cdr scan) value))
               ((:less) #f)
               (else (error "Cannot compare {t} and {t}" min value))))))))


(definition public (ci=? . rest)
  (if (null? rest)
      #t
    (let ((first (car rest)))
      (loop (for object in (cdr rest))
            (when (neq? (ci-compare object first) :equal)
              (return #f))
            (finally #t)))))


(definition public (ci/=? . rest)
  (not (apply ci=? rest)))


(definition public (ci<? n . rest)
  (let (iter (scan rest) (max n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare max value)
          ((:less) (iter (cdr scan) value))
          ((:greater :equal) #f)
          (else (error "Cannot ci-compare {t} and {t}" max value)))))))


(definition public (ci<=? n . rest)
  (let (iter (scan rest) (max n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare max value)
          ((:less :equal) (iter (cdr scan) value))
          ((:greater) #f)
          (else (error "Cannot ci-compare {t} and {t}" max value)))))))


(definition public (ci>? n . rest)
  (let (iter (scan rest) (min n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare min value)
          ((:greater) (iter (cdr scan) value))
          ((:less :equal) #f)
          (else (error "Cannot ci-compare {t} and {t}" min value)))))))


(definition public (ci>=? n . rest)
  (let (iter (scan rest) (min n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare min value)
          ((:greater :equal) (iter (cdr scan) value))
          ((:less) #f)
          (else (error "Cannot ci-compare {t} and {t}" min value)))))))


(definition public (di=? x y)
  (eq? (di-compare x y) :equal))

(definition public (di<? x y)
  (eq? (di-compare x y) :less))

(definition public (di<=? x y)
  (memq? (di-compare x y) '(:less :equal)))

(definition public (di>? x y)
  (eq? (di-compare x y) :greater))

(definition public (di>=? x y)
  (memq? (di-compare x y) '(:greater :equal)))


(definition public (di-sort-ascending seq (key: key #f))
  (sort (lambda (x y)
          (or (di<? x y)
              (and (di=? x y)
                   (nu<? x y))))
        seq
        key: key))


(definition public (di-sort-descending seq (key: key #f))
  (sort (lambda (x y)
          (or (di>? x y)
              (and (di=? x y)
                   (nu>? x y))))
        seq
        key: key))


(definition public inline (boolean->integer bool)
  (if bool 1 0))


(definition public inline (integer->boolean n <int>)
  (/= n 0))


;;;
;;;; Truth
;;;


(definition public false
  (list 'false))


(definition public inline (false? obj)
  (eq? obj false))


(definition public true
  (list 'true))


(definition public inline (true? obj)
  (eq? obj true))


(definition public (truth? obj)
  (or (false? obj)
      (true? obj)))


(definition public (boolean->truth bool)
  (if bool true false))


(definition public (truth->boolean data)
  (true? data))


;;;
;;;; Char
;;;


(definition public Whitespace-Chars
  '(#\space #\tab #\return #\newline #\page))

(definition public Uppercase-Chars
  '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))

(definition public Lowercase-Chars
  '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))

(definition public Alphabetic-Chars
  (append Uppercase-Chars Lowercase-Chars))

(definition public Numeric-Chars
  '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))


(definition Uppercase-Lowerbound <fx>
  (char->integer #\A))

(definition Uppercase-Upperbound <fx>
  (char->integer #\Z))

(definition Lowercase-Lowerbound <fx>
  (char->integer #\a))

(definition Lowercase-Upperbound <fx>
  (char->integer #\z))

(definition Numeric-Lowerbound <fx>
  (char->integer #\0))

(definition Numeric-Upperbound <fx>
  (char->integer #\9))


;; putting the uppercase chars here is a quick fix until
;; we add diacritic awareness to upcase and downcase
(definition Diacritic-Equivalences
  '((#\a #\à #\â #\A #\À #\Â)
    (#\c #\ç #\C #\Ç)
    (#\e #\é #\è #\ê #\ë #\E #\É #\È #\Ê #\Ë)
    (#\i #\î #\ï #\I #\Î #\Ï)
    (#\o #\ô #\O #\Ô)
    (#\u #\ù #\û #\U #\Ù #\Û)))


(definition (make-diacritic-table equivalences) <table>
  (let ((table (make-table test: eqv?)))
    (for-each (lambda (equivalences)
                (let ((equivalent (car equivalences)))
                  (for-each (lambda (char)
                              (table-set! table char equivalent))
                            equivalences)))
              equivalences)
    table))

(definition Diacritic-Table <table>
  (make-diacritic-table Diacritic-Equivalences))


(definition public (diacritic-equivalent c)
  (or (table-ref Diacritic-Table c #f)
      c))


(definition public (unicode->ascii str)
  (define (convert c)
    (if (or (control-character? c)
            (not (ascii? c)))
        #\¤
      c))
  
  (accumulate str convert String))
    


(class Char-Class extends Class)


(class primitive Char metaclass Char-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "chars"))
  
  
  (method override (coerce-string self)
    (let ((port (open-output-string)))
      (write-char self port)
      (get-output-string port)))
  
  
  (method override (compare-object self c)
    (if (is? c Char)
        (let ((v1 (char->integer self))
              (v2 (char->integer c)))
          (cond ((= v1 v2) :equal)
                ((> v1 v2) :greater)
                (else      :less)))
      :incompatible))
  
  
  (method override (ci-compare-object self c)
    (compare (downcase self)
             (downcase c)))
  
  
  (method override (di-compare-object self c)
    (ci-compare (diacritic-equivalent self)
                (diacritic-equivalent c)))
  
  
  (method override (object-similar? self object)
    (unimplemented 'object-similar?)
    @convert
    (and (char? object)
         (char-similar? self object)))


  (method override (object-alphabetic? self)
    (or (object-upper-case? self)
        (object-lower-case? self)))


  (method override (object-numeric? self)
    (let ((n (char->integer self)))
      (and (>= n Numeric-Lowerbound)
           (<= n Numeric-Upperbound))))


  (method override (object-alphanumeric? self)
    (or (object-alphabetic? self)
        (object-numeric? self)))


  (method override (object-whitespace? self)
    (or (eqv? self #\space)
        (eqv? self #\tab)
        (eqv? self #\return)
        (eqv? self #\newline)
        (eqv? self #\page)))


  (method override (object-upper-case? self)
    (let ((n (char->integer self)))
      (and (>= n Uppercase-Lowerbound)
           (<= n Uppercase-Upperbound))))


  (method override (object-lower-case? self)
    (let ((n (char->integer self)))
      (and (>= n Lowercase-Lowerbound)
           (<= n Lowercase-Upperbound))))


  (method override (object-upcase self)
    (if (lower-case? self)
        (integer->char (- (char->integer self) 32))
      self))


  (method override (object-downcase self)
    (if (upper-case? self)
        (integer->char (+ (char->integer self) 32))
      self))


  (method override (object-capitalize self)
    (object-upcase self)))


(definition whitechar?
  char-whitespace?)


(definition public (char-presentation char)
  (or (char-symbol char)
      (string char)))


(definition public inline (alphabetic? object <Object>)
  (object-alphabetic? object))


(definition public inline (numeric? object <Object>)
  (object-numeric? object))


(definition public inline (alphanumeric? object <Object>)
  (object-alphanumeric? object))


(definition public inline (whitespace? object <Object>)
  (object-whitespace? object))


(definition public inline (upper-case? object <Object>)
  (object-upper-case? object))


(definition public inline (lower-case? object <Object>)
  (object-lower-case? object))


(definition public inline (upcase object <Object>)
  (object-upcase object))


(definition public inline (downcase object <Object>)
  (object-downcase object))


(definition public inline (capitalize object <Object>)
  (object-capitalize object))


(definition public (upcase-capitalized str)
  (let ((len (string-length str)))
    (let (iter (from 0)
               (to 1)
               (upcased ""))
      (if (>= to len)
          (string-append upcased (upcase (substring str from to)))
        (let ((c (string-ref str to)))
          (if (upper-case? c)
              (iter to (+ to 1) (string-append upcased (upcase (substring str from to)) "_"))
            (iter from (+ to 1) upcased)))))))


(definition public (vowel? c)
  (memv? (downcase c) '(#\a #\e #\i #\o #\u #\y)))


(definition public (ascii? c)
  (let ((n (char->integer c)))
    (<= n 255)))


(definition public (control-character? c)
  (let ((n (char->integer c)))
    (or (and (>= n 0)
             (<= n 31))
        (= n 127))))


(definition character-types
  #(invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    backspace     whitespace    whitespace    invalid       invalid       whitespace    invalid       invalid
    invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    whitespace    constituent   string        sharp         constituent   constituent   constituent   quote        ;   ! " # $ % & '
    list          terminator    constituent   constituent   unquote       constituent   constituent   constituent  ; ( ) * + , - . /
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; 0 1 2 3 4 5 6 7
    constituent   constituent   constituent   comment       constituent   constituent   constituent   constituent  ; 8 9 : ; < = > ?
    exprcomment   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; @ A B C D E F G
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; H I J K L M N O
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; P Q R S T U V W
    constituent   constituent   constituent   reference     backslash     terminator    constituent   constituent  ; X Y Z [ \ ] ^ _
    quasiquote    constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; ` a b c d e f g
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; h i j k l m n o
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; p q r s t u v w
    constituent   constituent   constituent   literal       symbol        terminator    constituent   delete))     ; x y z { | } ~


(definition public (character-type ascii-c <char>) <symbol>
  (let ((num (char->integer ascii-c)))
    (if (> num 127)
        'constituent
      (vector-ref character-types (char->integer ascii-c)))))


(definition public (invalid-character? c <char>) <bool>
  (eq? (character-type c) 'invalid))


(definition public (word-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (memq? c '(#\_ #\- #\@))))


(definition public (scheme-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eq? (character-type c) 'constituent)
      (eqv? c #\#)
      (eqv? c #\@)))


(definition public (jazz-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eq? (character-type c) 'constituent)
      (eqv? c #\#)))


(definition public (c-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eqv? c #\_)))


(definition public (sql-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eqv? c #\_)
      (eqv? c #\@)
      (eqv? c #\[)
      (eqv? c #\])))


;;;
;;;; Port
;;;


(class Port-Class extends Class)


(class primitive Port metaclass Port-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "ports"))
  
  
  (method override (destroy self)
    (close-port self)
    (nextmethod self)))


;;;
;;;; Symbol
;;;


(class Symbol-Class extends Class)


(class primitive Symbol metaclass Symbol-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "symbols"))
  
  
  (method override (coerce-string self)
    (symbol->string self))
  
  
  (method override (compare-object self obj)
    (if (symbol? obj)
        (compare (symbol->string self) (symbol->string obj))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (if (symbol? obj)
        (ci-compare (symbol->string self) (symbol->string obj))
      :incompatible)))


(specialize inline (= s1 <symbol> s2 <symbol>) <bool>
  (eq? s1 s2))


(definition public (generated-symbol? symbol)
  (starts-with? (symbol->string symbol) "__"))


(definition public inline (symbol->keyword symbol)
  (string->keyword (symbol->string symbol)))


(definition public inline (keyword->symbol keyword)
  (string->symbol (keyword->string keyword)))


(definition public (find-symbol str)
  ;; convert : this is not really correct
  (string->symbol str))


(definition public (symbol-bound? name . rest)
  ;; convert : this is not really correct
  #t)
(definition public (symbol-unbound? name . rest)
  ;; convert : this is not really correct
  #f)


;;;
;;;; Keyword
;;;


(class Keyword-Class extends Class)


(class primitive Keyword metaclass Keyword-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "keywords")))


(definition public (find-keyword keyword box default (allow-other-keys? #f))
  (let (lp (ls (unbox-list box)) (before box))
    (cond ((null? ls)
           (default))
          ((or (not (pair? ls))
               (not (pair? (cdr ls)))
               (not (keyword? (car ls))))
           (if allow-other-keys?
               (default)
             (error "Bad keyword list: {s}" (unbox-list box))))
          ((eq? keyword (car ls))
           (set-cdr! before (cddr ls))
           (cadr ls))
          (else
           (lp (cddr ls) (cdr ls))))))


;; this is a specialized implementation of the box concept
;; to enable an optimisation in the find-keyword code above


(definition package (box-list lst)
  (cons '() lst))


(definition package (unbox-list box)
  (cdr box))


;;;
;;;; Continuation
;;;


(class Continuation-Class extends Class)


(class primitive Continuation metaclass Continuation-Class extends Object)


;;;
;;;; Procedure
;;;


(class Procedure-Class extends Class)


(class primitive Procedure metaclass Procedure-Class extends Object)


;;;
;;;; Foreign
;;;


(class Foreign-Class extends Class)


(class primitive Foreign metaclass Foreign-Class extends Object)


;;;
;;;; Numeric
;;;


(class Numeric-Class extends Class)


(class primitive Numeric metaclass Numeric-Class extends Object


  (method public virtual abstract (numeric-norm self))
  (method public virtual abstract (numeric-add self obj))
  (method public virtual abstract (numeric-negate self))
  (method public virtual abstract (numeric-multiply self n))
  (method public virtual abstract (numeric-inverse self)))


;;;
;;;; Number
;;;


(class Number-Class extends Numeric-Class)


(class primitive Number metaclass Number-Class extends Numeric
  
  
  (method override (initialize self . rest)
    (native-class "numbers"))
  
  
  (method override (compare-object self obj)
    (if (number? obj)
        (cond ((= self obj) :equal)
              ((< self obj) :less)
              (else :greater))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (compare-object self obj))
  
  
  (method override (di-compare-object self obj)
    (compare-object self obj))
  
  
  (method override (numeric-norm self)
    (abs self))
  
  
  (method override (numeric-add self obj)
    (if (number? obj)
        (+ self obj)
      (error "Unsupported nu+ : {t} {t}" self obj)))
  
  
  (method override (numeric-negate self)
    (- self))
  
  
  (method override (numeric-multiply self obj)
    (if (number? obj)
        (* self obj)
      (error "Unsupported nu* : {t} {t}" self obj)))
  
  
  (method override (numeric-inverse self)
    (/ self)))


;;;
;;;; Complex
;;;


(class Complex-Class extends Number-Class)


(class primitive Complex metaclass Complex-Class extends Number
  
  
  (method override (numeric-norm self)
    (sqrt (+ (expt (real-part self) 2) (expt (imag-part self) 2)))))


;;;
;;;; Real
;;;


(class Real-Class extends Complex-Class)


(class primitive Real metaclass Real-Class extends Complex)


;;;
;;;; Rational
;;;


(class Rational-Class extends Real-Class)


(class primitive Rational metaclass Rational-Class extends Real)


(definition public (rational->decimalstring fraction precision)
  (unless (and (rational? fraction)
               (exact? fraction))
    (error "Fraction must be a rational: {s}" fraction))
  
  (unless (and (integer? precision)
               (>= precision 0))
    (error "Precision must be an integer greater or equal than 0: {s}" precision))
  
  (let ((port (open-output-string))
        (num (abs (numerator fraction)))
        (denum (denominator fraction)))
    
    (when (< (numerator fraction) 0)
      (display "-" port))
    
    (display (quotient num denum) port)
    (display "." port)
    
    (let (iter (remain (* (remainder num denum) 10))
               (p precision))
      (when (and (> remain 0)
                 (> p 0))
        (let ((quo (quotient remain denum)))
          (display quo port)
          (iter (* (- remain (* quo denum)) 10)
                (- p 1))))
      ;; pad with zeros to match precision
      (when (and (<= remain 0)
                 (> p 0))
        (display "0" port)
        (iter (- 1) (- p 1))))
    
    (get-output-string port)))


;;;
;;;; Integer
;;;


(class Integer-Class extends Rational-Class)


(class primitive Integer metaclass Integer-Class extends Rational)


;;;
;;;; Fixnum
;;;


(class Fixnum-Class extends Integer-Class)


(class primitive Fixnum metaclass Fixnum-Class extends Integer)


;;;
;;;; Ratnum
;;;


(class Ratnum-Class extends Rational-Class)


(class primitive Ratnum metaclass Ratnum-Class extends Rational)


;;;
;;;; Flonum
;;;


(class Flonum-Class extends Real-Class)


(class primitive Flonum metaclass Flonum-Class extends Real)


(definition public (fl x) <fl>
  (cond ((flonum? x) x)
        ((fixnum? x) (cast <fl> x))
        (else (error "Unable to convert into a float: {s}" x))))


(definition public (flmodulo x <fl> y <fl>) <fl>
  (- x (* (floor (/ x y)) y)))


(definition public (flsign x <fv>) <fl>
  (cond ((< x 0.) -1.)
        ((> x 0.)  1.)
        (else      0.)))


;;;
;;;; Flovec
;;;


(class Flovec-Class extends Flonum-Class)


(class primitive Flovec metaclass Flovec-Class extends Flonum)


;;;
;;;; S64
;;;


(class S64-Class extends Integer-Class)


(class primitive S64 metaclass S64-Class extends Integer)


;;;
;;;; Numbers
;;;


(definition public (relate x y) <fx>
  (cond ((< x y) -1)
        ((> x y)  1)
        (else     0)))


(definition public (sign n) <fx>
  (relate n 0))


(definition public (nu+ . rest)
  (if (null? rest)
      0
    (let (iter (result <Numeric> (car rest)) (scan (cdr rest)))
      (if (null? scan)
          result
        (iter (numeric-add result (car scan)) (cdr scan))))))


(definition public (nu- n <Numeric> . rest)
  (if (null? rest)
      (numeric-negate n)
    (let ((r <Numeric> (apply nu+ rest)))
      (nu+ n (numeric-negate r)))))


(definition public (nu* . rest)
  (if (null? rest)
      1
    (let (iter (result <Numeric> (car rest)) (scan (cdr rest)))
      (if (null? scan)
          result
        (iter (numeric-multiply result (car scan)) (cdr scan))))))


(definition public (nu/ n <Numeric> . rest)
  (if (null? rest)
      (numeric-inverse n)
    (let ((r <Numeric> (apply nu* rest)))
      (nu* n (numeric-inverse r)))))


(definition public (minimum lst <pair> (key: key #f) (compare: compare compare))
  (let ((min (car lst)))
    (for-each (lambda (object)
                (when (eq? (compare (apply-key key object) (apply-key key min)) :less)
                  (set! min object)))
              (cdr lst))
    min))


(definition public (maximum lst <pair> (key: key #f) (compare: compare compare))
  (let ((max (car lst)))
    (for-each (lambda (object)
                (when (eq? (compare (apply-key key object) (apply-key key max)) :greater)
                  (set! max object)))
              (cdr lst))
    max))


(definition public inline (between? n lower upper)
  (and (>= n lower)
       (<= n upper)))


(definition public inline (between lower n upper)
  (cond ((< n lower) lower)
        ((> n upper) upper)
        (else n)))


(definition public inline (in-interval? n lower upper)
  (and (>= n lower)
       (< n upper)))


(definition public inline (between-interval lower n upper)
  (cond ((< n lower) lower)
        ((>= n upper) (- upper 1))
        (else n)))


(definition public inline (norm x <Numeric>)
  (numeric-norm x))


(definition public (distance start <Numeric> end <Numeric>)
  (norm (nu- end start)))


(definition public (near? x y distance) <bool>
  (<= (norm (nu- x y)) distance))


(definition public (contiguous-range lst)
  (and (not-null? lst)
       (continuation-capture
         (lambda (return)
           (let* ((first (car lst))
                  (second first))
             (for-each (lambda (n)
                         (if (= n (+ second 1))
                             (set! second n)
                           (continuation-return return #f)))
                       (cdr lst))
             (cons first second))))))


(definition public (naturals lower <int> upper <int>) <list>
  (loop (for n from lower below upper)
        (collect n)))


(definition public (interval lower <int> upper <int>) <list>
  (loop (for n from lower to upper)
        (collect n)))


(definition public (lobyte word <int>) <int>
  (bitwise-and #xFF word))


(definition public (hibyte word <int>) <int>
  (lobyte (arithmetic-shift word -8)))


(definition public (make-word lo <int> hi <int>) <int>
  (bitwise-ior (arithmetic-shift hi 8) lo))


(definition public (lochar word <int>) <int>
  (- (bitwise-and (+ word #x80) #xFF) #x80))


(definition public (hichar word <int>) <int>
  (lochar (arithmetic-shift word -8)))


(definition public (make-int lo <int> hi <int>) <int>
  (bitwise-ior (arithmetic-shift hi 16) lo))


(definition public (loword dword <int>) <int>
  (bitwise-and dword #xFFFF))


(definition public (hiword dword <int>) <int>
  (loword (arithmetic-shift dword -16)))


(definition public (signed-loword dword <int>) <int>
  (- (bitwise-and (+ dword #x8000) #xFFFF) #x8000))


(definition public (signed-hiword dword <int>) <int>
  (signed-loword (arithmetic-shift dword -16)))


(definition public (sign-word word <int>) <int>
  (if (bit-set? 15 word)
      (- word #x10000)
    word))


(definition public (separate int1 <int> int2 <int>)
  (let* ((q (quotient int1 int2))
         (r (- int1 (* q int2))))
    (values q r)))


(definition public (randomize)
  (random-source-randomize! default-random-source))

(definition public (random n)
  (random-integer n))


(definition public (bit-set num <int> pos <int> bit <bool>) <int>
  (let ((msk (arithmetic-shift 1 pos)))
    (if bit
        (bitwise-ior num msk)
      (bitwise-and num (bitwise-not msk)))))


(definition public (mask-bit-set num <int> msk <int> bit <bool>) <int>
  (if bit
      (bitwise-ior num msk)
    (bitwise-and num (bitwise-not msk))))


(definition public (mask-bit-set? num <int> msk <int>) <bool>
  (/= (bitwise-and num msk) 0))


(definition public (bit-mask hi <int> lo <int>)
  (- (arithmetic-shift 1 hi) (arithmetic-shift 1 lo)))


(definition public (random-seed (seed #f))
  (if seed
      (random-source-pseudo-randomize! default-random-source (first seed) (second seed))
    (randomize)
    (random 10000)
    (random 10000)))


(definition public inline (sqr num)
  (expt num 2))


(definition public inline (percentage part <real> total <real>) <real>
  (* (/ (cast <fl> part) total) 100))


(definition public inline (percent percent <real> n <real>) <real>
  (/ (cast <fl> (* n percent)) 100))


(definition public inline (fxfloor r <fl>) <fx>
  (flonum->fixnum (floor r)))

(definition public inline (fxceiling r <fl>) <fx>
  (flonum->fixnum (ceiling r)))

(definition public inline (fxtruncate r <fl>) <fx>
  (flonum->fixnum (truncate r)))

(definition public inline (fxround r <fl>) <fx>
  (flonum->fixnum (round r)))


;; these could potentialy optimize out the flonum operation

(definition public inline (fxfloor/ n <fx> d <fx>) <fx>
  (fxfloor (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxceiling/ n <fx> d <fx>) <fx>
  (fxceiling (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxtruncate/ n <fx> d <fx>) <fx>
  (fxtruncate (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxround/ n <fx> d <fx>) <fx>
  (fxround (/ (cast <fl> n) (cast <fl> d))))


;; fixnum optimized version of fxfloor/
(definition public inline (quotient/ x <fx> y <fx>) <fx>
  (proclaim (not check zero))
  (if (< x 0)
      (- (quotient (+ x 1) y) 1)
    (quotient x y)))


;;;
;;;; Iterator
;;;


(class package Iterator extends Object


  (definition Empty
    '(empty))


  (slot peeked initialize Empty)
  
  
  (method override (iterate-object self)
    self)


  (method public virtual (get-next self)
    (prog1 (peek self)
      (next self)))


  (method public virtual (peek self)
    (when (eq? peeked Empty)
      (set! peeked (next self)))
    peeked)
  
  
  (method public virtual (unget self object)
    (if (eq? peeked Empty)
        (set! peeked object)
      (error "Unable to unget {t}" object)))


  (method public virtual (next self)
    (cond ((eof-object? peeked)
           peeked)
          ((neq? peeked Empty)
           (prog1 peeked
             (set! peeked Empty)))
          (else
           (get-next! self))))


  (method public virtual (done? self) <bool>
    (eof-object? (peek self)))


  (method public virtual (get-next! self)
    )


  (method public virtual (put self object)
    (error "This iterator cannot put"))


  (method public virtual (get-position self)
    (error "This iterator cannot get position: {t}" self))


  (method public virtual (set-position self pos)
    (error "This iterator cannot set position: {t}" self))


  (method public virtual (get-state self)
    #f)


  (method public virtual (reset-state self old)
    ))


(definition public inline (iterator obj <Object>) <Iterator>
  (iterate-object obj))


;;;
;;;; Explorer
;;;


(class package Explorer extends Iterator


  (slot direction initialize 'forward setter generate)


  (method protected virtual (peek-forward self)
    (error "You need to implement peek-forward"))


  (method protected virtual (peek-backward self)
    (error "You need to implement peek-backward"))


  (method override (peek self)
    (if (done? self)
        (eof-object)
      (case direction
        ((forward)  (peek-forward self))
        ((backward) (peek-backward self)))))


  (method public virtual (goto-beginning self)
    (error "You need to implement goto-beginning"))


  (method public virtual (goto-end self)
    (error "You need to implement goto-end"))


  (method public virtual (forward self)
    (error "You need to implement forward"))


  (method public virtual (backward self)
    (error "You need to implement backward"))


  (method override (next self)
    (and (not (done? self))
         (case direction
           ((forward)  (forward self))
           ((backward) (backward self)))))


  (method protected virtual (done-forward? self)
    (error "You need to implement done-forward?"))


  (method protected virtual (done-backward? self)
    (error "You need to implement done-backward?"))


  (method override (done? self)
    (case direction
      ((forward)  (done-forward? self))
      ((backward) (done-backward? self))))


  (method protected virtual (put-forward self object)
    (error "This iterator cannot put forward"))


  (method protected virtual (put-backward self object)
    (error "This iterator cannot put backward"))


  (method override (put self object)
    (case direction
      ((forward)  (put-forward self object))
      ((backward) (put-backward self object)))))


(definition public (explore object <Object> . rest) <Explorer>
  ;; this will become specializers
  (apply new Sequence-Explorer object rest))


;;;
;;;; Sequence
;;;


(definition (coerce-sequence seq class)
  (let ((len (cardinality seq)))
    (let ((new-sequence (make-sequence class len)))
      (loop (for n from 0 below len)
            (for elem in-sequence seq)
            (set-element! new-sequence n elem))
      new-sequence)))


(class Sequence-Class extends Class
  
  
  (method public virtual abstract (make-sequence self len <int>))
  
  
  (method override (coerce-object self seq)
    (coerce-sequence seq self)))


(class primitive Sequence metaclass Sequence-Class extends Object
  
  
  (method override (coerce-string self)
    (coerce-sequence self String))

  
  (method override (compare-object self seq)
    (if (is? seq Sequence)
        (compare-sequence self seq compare)
      :incompatible))
  
  
  (method override (di-compare-object self seq)
    (compare-sequence self seq di-compare))
  
  
  (method override (copy-object self deep? <bool>)
    (let* ((subcopy (if deep? (lambda (x) (subcopy x deep?)) identity))
           (len (cardinality self))
           (new-seq (make-sequence (class-of self) len)))
      (let (iter (i <fx> 0))
        (if (= i len)
            new-seq
          (begin
            (set-element! new-seq i (subcopy (element self i)))
            (iter (+ i 1)))))))
  
  
  (method override (iterate-object self)
    (new Sequence-Explorer self))


  (method override (object-alphabetic? self)
    (every? alphabetic? self))


  (method override (object-numeric? self)
    (every? numeric? self))


  (method override (object-alphanumeric? self)
    (every? alphanumeric? self))


  (method override (object-whitespace? self)
    (every? whitespace? self))


  (method override (object-upper-case? self)
    (every? upper-case? self))


  (method override (object-lower-case? self)
    (every? lower-case? self))


  (method override (object-upcase self)
    (accumulate self upcase (class-of self)))


  (method override (object-downcase self)
    (accumulate self downcase (class-of self)))


  (method override (object-capitalize self)
    (let ((break? #t))
      (accumulate self
                  (lambda (object)
                    (if (alphanumeric? object)
                        (if (not break?)
                            object
                          (set! break? #f)
                          (upcase object))
                      (set! break? #t)
                      object))
                  (class-of self))))
  
  
  (method package virtual abstract (sequence-element self n <fx>) <any>)
  
  
  (method package virtual abstract (sequence-set-element! self n <fx> obj <any>) <void>)
  
  
  (method package virtual abstract (sequence-cardinality self) <fx>)
  
  
  (method package virtual abstract (sequence-tail self start))
  
  
  (method package virtual abstract (sequence-last self))
  
  
  (method package virtual abstract (sequence-butlast self))
  
  
  (method package virtual (sequence-subseq! self start <fx> end <fx>)
    (if (and (= start 0) (= end -1))
        self
      (new Subseq self start (- (if (= end -1) (cardinality self) end) start))))


  (method package virtual (sequence-replace-subseq! self start <fx> end <fx> replacement)
    (concatenate! (subseq self 0 start)
                  replacement
                  (subseq self end (cardinality self))))
  
  
  (method public (empty? self)
    (= 0 (cardinality self)))
  
  
  (method public (laden? self)
    (/= 0 (cardinality self))))


(definition public inline (sequence? obj)
  (is? obj Sequence))


(definition public inline (element seq <Sequence> n <int>) <any>
  (sequence-element seq n))


(definition public inline (set-element! seq <Sequence> n <int> obj <any>) <void>
  (sequence-set-element! seq n obj))


(definition public inline (cardinality seq <Sequence>) <int>
  (sequence-cardinality seq))


(definition public inline (tail seq <Sequence> start)
  (sequence-tail seq start))


(definition public inline (last seq <Sequence>)
  (sequence-last seq))


(definition public inline (butlast seq <Sequence>)
  (sequence-butlast seq))


(definition public (compare-sequence s1 s2 compare)
  (let ((l1 (cardinality s1))
        (l2 (cardinality s2)))
    (let (iter (i <fx> 0))
      (if (or (>= i l1) (>= i l2))
          (cond ((= l1 l2) :equal)
                ((> l1 l2) :greater)
                (else      :less))
        (let ((cmp (compare (element s1 i) (element s2 i))))
          (if (eq? cmp :equal)
              (iter (+ i 1))
            cmp))))))


(definition public (skip-whitespace seq <Sequence> (start: start #f))
  (let ((card (cardinality seq)))
    (let (iter (i <fx> (or start 0)))
      (cond ((= i card) i)
            ((memv? (element seq i) '(#\space #\tab)) (iter (+ i 1)))
            (else i)))))


(definition public (subseq seq start (end #f) (type #f))
  (declare (proper-tail-calls))
  (let* ((len (- (or end (cardinality seq)) start))
         (cls <Sequence-Class> (or type (class-of seq)))
         (sub (make-sequence cls len))
         (i 0)
         (j start))
    (while (< i len)
      (set-element! sub i (element seq j))
      (set! i (+ i 1))
      (set! j (+ j 1)))
    sub))


(definition public inline (replace-subseq! seq <Sequence> start end replacement)
  (sequence-replace-subseq! seq start end replacement))


(definition public (subseq! seq <Sequence> start (end (cardinality seq))) <Sequence>
  (sequence-subseq! seq start end))


(definition public (sort test seq (key: key #f))
  (if (null/pair? seq)
      (sort-list test seq key: key)
    ;; first draft to be optimized
    (coerce (sort test (coerce seq List) key: key) (class-of seq))))


;; simple insertion sort
(definition public (sort-vector! test vec)
  (let ((len (vector-length vec)))
    (let (outer (i 1))
      (when (< i len)
        (let (inner (j i))
          (when (> j 0)
            (let ((p (vector-ref vec (- j 1)))
                  (n (vector-ref vec j)))
              (unless (test p n)
                (vector-set! vec j p)
                (vector-set! vec (- j 1) n)
                (inner (- j 1))))))
        (outer (+ i 1)))))
  vec)


(definition public inline (first   seq) (element seq 0))
(definition public inline (second  seq) (element seq 1))
(definition public inline (third   seq) (element seq 2))
(definition public inline (fourth  seq) (element seq 3))
(definition public inline (fifth   seq) (element seq 4))
(definition public inline (sixth   seq) (element seq 5))
(definition public inline (seventh seq) (element seq 6))
(definition public inline (eighth  seq) (element seq 7))
(definition public inline (ninth   seq) (element seq 8))
(definition public inline (tenth   seq) (element seq 9))

(definition public inline (set-first!   seq value) (set-element! seq 0 value))
(definition public inline (set-second!  seq value) (set-element! seq 1 value))
(definition public inline (set-third!   seq value) (set-element! seq 2 value))
(definition public inline (set-fourth!  seq value) (set-element! seq 3 value))
(definition public inline (set-fifth!   seq value) (set-element! seq 4 value))
(definition public inline (set-sixth!   seq value) (set-element! seq 5 value))
(definition public inline (set-seventh! seq value) (set-element! seq 6 value))
(definition public inline (set-eighth!  seq value) (set-element! seq 7 value))
(definition public inline (set-ninth!   seq value) (set-element! seq 8 value))
(definition public inline (set-tenth!   seq value) (set-element! seq 9 value))


(definition public (element-reversed seq n)
  (element seq (- (cardinality seq) n 1)))


(definition public (iterate seq proc <procedure>)
  (loop (for obj in-sequence seq)
        (proc obj)))


(definition public (iterate-sequences proc <procedure> . seqs)
  (define (any? lst)
    (and (pair? lst)
         (or (car lst)
             (any? (cdr lst)))))
  
  (declare (proper-tail-calls))
  (let ((iterators (map iterator seqs)))
    (let (loop)
      (let ((done? (any? (map done? iterators))))
        (when (not done?)
          (apply proc (map get-next iterators))
          (loop)))))
  (unspecified))


(definition public (accumulate seq proc <procedure> (type #f))
  (let ((lst
          (loop (for obj in-sequence seq)
                (collect (proc obj)))))
    (if (not type)
        lst
      (coerce lst type))))


(definition protected inline (apply-key key <Object> object <Object>)
  (if (not key)
      object
    (key object)))


(definition protected inline (apply-test test <Object> x <Object> y <Object>)
  (if (not test)
      (eqv? x y)
    (test x y)))


(definition public (gather iterable <Object> (type: type List))
  (coerce (loop (for obj in-sequence iterable)
                (collect obj))
          type))


(definition public (collect proc <procedure> seq <Object> (key: key #f) (type: type #f))
  (coerce (loop (for obj in-sequence seq)
                (for val = (proc (apply-key key obj)))
                (when val
                  (collect val)))
          (or type (class-of seq))))


(definition public (collect-if predicate <procedure> seq <Object> (key: key #f))
  (if (and (null/pair? seq)
           (not key))
      (kernel-collect-if predicate seq)
    (coerce (loop (for obj in-sequence seq)
                  (when (predicate (apply-key key obj))
                    (collect obj)))
            (class-of seq))))


(definition public (collect-type type seq <Object> (key: key #f))
  (coerce (loop (for obj in-sequence seq)
                (when (is? (apply-key key obj) type)
                  (collect obj)))
          (class-of seq)))


(definition public (collect-sections lst (separator: separator #f) (test: test #f))
  (let ((sections (new List-Factory))
        (section (new List-Factory)))
    (for-each (lambda (value)
                (if (apply-test test separator value)
                    (begin
                      (put sections (get-output section))
                      (reset section))
                  (put section value)))
              lst)
    (put sections (get-output section))
    (get-output sections)))


(definition public (count target <Object> seq <Object> (key: key #f) (test: test #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (apply-test test target (apply-key key object))
            (increase! total)))
    total))


(definition public (count-if predicate <procedure> seq (key: key #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (predicate (apply-key key object))
            (increase! total)))
    total))


(definition public (count-type type seq <Object> (key: key #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (is? (apply-key key object) type)
            (increase! total)))
    total))


(definition public (sum proc <procedure> lst)
  (let ((sum 0))
    (for-each (lambda (elem)
                (increase! sum (proc elem)))
              lst)
    sum))


(definition public (average seq)
  (let ((total 0)
        (count 0))
    (loop (for value in-sequence seq)
          (increase! total value)
          (increase! count))
    (/ total count)))


(definition public (find seq target (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f) (return: return 'position))
  (if (and (null/pair? seq) (not reversed?))
      (list-find seq target key test (or start 0) return)
    (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
      (when start
        (set-position iterator start))
      (continuation-capture
        (lambda (exit)
          (iterate iterator
                   (lambda (object)
                     (when (apply-test test target (apply-key key object))
                       (continuation-return exit (case return
                                                   ((item) object)
                                                   ((position) (if reversed? (get-position iterator) (- (get-position iterator) 1)))
                                                   (else (error "Unknown return type: {t}" return)))))))
          #f)))))


(definition public (find-rank target <Object> seq <Object> (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f))
  (if (and (null/pair? seq) (not reversed?))
      (list-find seq target key test (or start 0) #f)
    (if (and (string? seq) (not start))
        (string-find seq target reversed?: reversed?)
      (continuation-capture
        (lambda (exit)
          (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
            (when start
              (set-position iterator start))
            (iterate iterator
                     (lambda (object)
                       (when (apply-test test target (apply-key key object))
                         (continuation-return exit (if reversed? (get-position iterator) (- (get-position iterator) 1))))))
            #f))))))


(definition (list-find list target key test start return)
  (let ((key (if (not key) (lambda (x) x) key))
        (test (if (not test) eqv? test)))
    (let (iter (rest (tail list start)) (rank <fx> start))
       (cond ((null? rest) #f)
             ((test target (key (car rest)))
              (case return
                ((item) (car rest))
                (else   rank)))
             (else
              (iter (cdr rest) (+ rank 1)))))))


(definition public (find-in seq target (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f))
  (define (find-in-list)
    (let ((list seq)
          (key (if (not key) (lambda (x) x) key))
          (test (if (not test) eqv? test))
          (start (or start 0)))
      (let (iter (rest (tail list start)) (rank <fx> start))
        (cond ((null? rest) #f)
              ((test target (key (car rest)))
               (car rest))
              (else
               (iter (cdr rest) (+ rank 1)))))))
  
  (if (and (null/pair? seq) (not reversed?))
      (find-in-list)
    (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
      (when start
        (set-position iterator start))
      (continuation-capture
        (lambda (exit)
          (iterate iterator
                   (lambda (object)
                     (when (apply-test test target (apply-key key object))
                       (continuation-return exit object))))
          #f)))))


(definition public (find-balanced open close seq (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f) (return: return 'item))
  (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq)))
        (count 0))
    (when start
      (set-position iterator start))
    (continuation-capture
      (lambda (exit)
        (iterate iterator
                 (lambda (object)
                   (cond ((apply-test test open (apply-key key object))
                          (increase! count))
                         ((apply-test test close (apply-key key object))
                          (decrease! count)
                          (when (< count 0)
                            (case return
                              ((item) (continuation-return exit object))
                              ((position) (continuation-return exit (if reversed? (get-position iterator) (- (get-position iterator) 1))))
                              (else (error "Unknown return type: {t}" return))))))))
        #f))))


(definition public (find-if predicate <procedure> seq <Object> (key: key #f) (start: start #f) (reversed?: reversed? #f) (return: return 'item))
  (if (and (null/pair? seq) (not reversed?))
      (find-if-list predicate seq key (or start 0) return)
    (continuation-capture
      (lambda (exit)
        (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
          (when start
            (set-position iterator start))
          (iterate iterator
                   (lambda (object)
                     (when (predicate (apply-key key object))
                       (continuation-return exit (case return
                                                   ((item) object)
                                                   ((position) (if reversed? (get-position iterator) (- (get-position iterator) 1)))
                                                   (else (error "Unknown return type: {t}" return))))))))
        #f))))


(definition public (skip predicate <procedure> seq <Object> (key: key #f) (start: start #f) (reversed?: reversed? #f))
  (continuation-capture
    (lambda (return)
      (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
        (when start
          (set-position iterator start))
        (iterate iterator
                 (lambda (object)
                   (when (not (predicate (apply-key key object)))
                     (continuation-return return (if reversed?
                                                     (+ (get-position iterator) 1)
                                                   (- (get-position iterator) 1))))))
        (get-position iterator)))))


(definition public (append-map proc <procedure> list1 . lists)
  (apply append (apply map proc list1 lists)))


(definition public (zip list1 . lists)
  (apply map list list1 lists))


(definition public (iota count (start 0) (step 1))
  (if (zero? count)
      '()
    (cons start (iota (- count 1) (+ start step) step))))


(definition public (fold-left kcons knil lst)
  (if (null? lst)
      knil
    (fold-left kcons (kcons knil (car lst)) (cdr lst))))


(definition public (fold-right kcons knil lst)
  (if (null? lst)
      knil
    (kcons (car lst) (fold-right kcons knil (cdr lst)))))


(definition public (unfold-right stop? <procedure> seed->elem <procedure> next <procedure> seed (tail '()))
  (let (loop (seed seed) (lis tail))
    (if (stop? seed)
        lis
      (loop (next seed)
            (cons (seed->elem seed) lis)))))


(definition public (some? predicate <procedure> (key: key #f) . seqs)
  (if (and (not key)
           (null/pair? (car seqs))
           (null? (cdr seqs)))
      (kernel-some? predicate (car seqs))
    (continuation-capture
      (lambda (return)
        (apply iterate-sequences
          (lambda objs
            (and (apply predicate (map (lambda (object)
                                         (apply-key key object))
                                       objs))
                 (continuation-return return #t)))
          seqs)
        #f))))


(definition public (every? predicate <procedure> (key: key #f) . seqs)
  (if (and (not key)
           (null/pair? (car seqs))
           (null? (cdr seqs)))
      (kernel-every? predicate (car seqs))
    (continuation-capture
      (lambda (return)
        (apply iterate-sequences
          (lambda objs
            (or (apply predicate (map (lambda (object)
                                        (apply-key key object))
                                      objs))
                (continuation-return return #f)))
          seqs)
        #t))))


(definition public (concatenate . rest)
  (if (null? rest)
      '()
    (let ((fact (new List-Factory)))
      (let* ((first (car rest))
             (list? (null/pair? first)))
        (for-each (lambda (sequence)
                    (put-sequence fact sequence))
                  rest)
        (let ((output (get-output fact)))
          (if (not list?)
              (coerce output (class-of first))
            output))))))


(definition public (concatenate! . rest)
  (apply concatenate rest))


(definition public (subset? set1 set2)
  (or (null? set1)
      (every? (lambda (element)
                (memv? element set2))
              set1)))


(definition public (union (key: key #f) (test: test #f) . lists)
  (if (null? lists)
      '()
    (let ((first (car lists))
          (dst (new List-Factory)))
      (put-sequence dst first)
      (for-each (lambda (set)
                  (iterate (iterator set)
                           (lambda (object)
                             (when (not (member? (apply-key key object) (get-output dst) key: key test: test))
                               (put dst object)))))
                (cdr lists))
      (coerce (get-output dst) (class-of first)))))


(definition public (intersection (key: key #f) (test: test #f) . lists)
  (if (null? lists)
      '()
    (let ((first (car lists))
          (lists (cdr lists))
          (dst (new List-Factory)))
      (iterate (iterator first)
               (lambda (object)
                 (when (every? (lambda (set)
                                 (member? (apply-key key object) set key: key test: test))
                               lists)
                   (put dst object))))
      (coerce (get-output dst) (class-of first)))))


(definition public (difference x <Object> y <Object> (key: key #f) (test: test eqv?))
  (if (null? y)
      x
    (let ((dst (new List-Factory)))
      (iterate (iterator x)
               (lambda (object)
                 (when (not (member? (apply-key key object) y key: key test: test))
                   (put dst object))))
      (coerce (get-output dst) (class-of x)))))


(definition public (set-xor x <Object> y <Object> (test: test eqv?))
  (union (difference x y test: test)
         (difference y x test: test)))


(definition public (remove target <Object> seq <Object> (key: key #f) (test: test eqv?))
  (let ((dst (new List-Factory)))
    (iterate (iterator seq)
             (lambda (object)
               (when (not (apply-test test (apply-key key object) target))
                 (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(specialize as string-remove (remove target <char> str <string>) <string>
  (let ((output (open-output-string)))
    (loop (for n from 0 below (cardinality str))
          (let ((c (element str n)))
            (when (not (eqv? c target))
              (write-char c output))))
    (get-output-string output)))


(definition public (extract-trailer seq <Object> predicate <procedure>)
  (let (iterate (n (- (cardinality seq) 1)) (trailer '()))
    (if (or (< n 0) (not (predicate (element seq n))))
        (coerce trailer (class-of seq))
      (let ((obj (element seq n)))
        (if (not (predicate obj))
            (coerce trailer (class-of seq))
          (iterate (- n 1) (cons obj trailer)))))))


(definition public (remove-leading target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (< head end) (apply-test test (element seq head) target))
      (increase! head))
    (subseq seq head tail)))


(definition public (remove-trailing target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (> tail head) (apply-test test (element seq (- tail 1)) target))
      (decrease! tail))
    (subseq seq head tail)))


(definition public (remove-enclosing target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (< head end) (apply-test test (element seq head) target))
      (increase! head))
    (while (and (> tail head) (apply-test test (element seq (- tail 1)) target))
      (decrease! tail))
    (subseq seq head tail)))


(definition public (remove-duplicates seq <Object> (key: key #f) (test: test eqv?))
  (let ((table (make-table test: test))
        (dst (new List-Factory)))
    (iterate (iterator seq)
             (lambda (object)
               (let ((k (apply-key key object)))
                 (when (not (table-ref table k #f))
                   (put dst object)
                   (table-set! table k #t)))))
    (coerce (get-output dst) (class-of seq))))


(definition public (collect-duplicates seq <Object> (key: key identity) (test: test eqv?))
  (let ((partition (partition seq key: key test: test)))
    (map car (collect-if (lambda (partition)
                           (> (length (cdr partition)) 1))
                         partition))))


(definition public (remove-false seq <Object>)
  (collect-if identity seq))


(definition public (remove-empty seq <Object>)
  (collect-if (lambda (obj)
                (not (empty? obj)))
              seq))


(definition public (trim-spaces seq)
  (remove-enclosing #\space seq))


(definition public (trim-whitespace seq)
  (remove-enclosing #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (trim-leading-whitespace seq)
  (remove-leading #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (trim-trailing-whitespace seq)
  (remove-trailing #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (trim-inner-whitespace str)
  (join-strings (remove-empty (split-string str #\space)) " "))


(definition public (mismatch target <Object> seq <Object> (test: test equal?))
  (continuation-capture
    (lambda (return)
      (let ((srce (iterator seq))
            (targ (iterator target))
            (pos 0))
        (while (not (done? srce))
          (when (or (done? targ) (not (test (get-next srce) (get-next targ))))
            (continuation-return return pos))
          (increase! pos))
        (if (done? targ)
            #f
          pos)))))


(definition public (prefix sequences <Object> (test: test equal?))
  (if (null? sequences)
      '()
    (let ((ref (car sequences))
          (min <Object> #f))
      (for-each (lambda (object)
                  (let ((n (mismatch object ref test: test)))
                    (when (and n (or (not min) (< n min)))
                      (set! min n))))
                (cdr sequences))
      (if (not min)
          ref
        (subseq ref 0 min)))))


(definition public (prefix? target <Object> seq <Object>)
  (continuation-capture
    (lambda (return)
      (let ((targ (iterator target))
            (iter (iterator seq)))
        (while (and (not (done? targ)) (not (done? iter)))
          (when (nu/=? (get-next targ) (get-next iter))
            (continuation-return return #f)))
        (done? targ)))))


(definition public (copy-into! seq1 seq2)
  (for-each (lambda (element rank)
              (set-element! seq2 rank element))
            seq1
            (naturals 0 (cardinality seq1))))


(class package Search-Context extends Object
  
  
  (slot target            <Sequence>   accessors generate)
  (slot whole-words?      <bool>       accessors generate)
  (slot ignore-case?      <bool>       accessors generate)
  (slot ignore-diacritic? <bool>       accessors generate)
  (slot regexp?           <bool>       accessors generate)
  (slot match-test        <procedure+> accessors generate)
  (slot constituent-test  <procedure+> accessors generate)
  (slot regexp            <any>        accessors generate)
  (slot user-data         <any>        accessors generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" target)))))


(class package Search-Set extends Object
  
  
  (slot regexp           <any>        accessors generate)
  (slot contexts         <list>       accessors generate))


(definition public (->search-context obj)
  (cond ((is? obj Search-Context) obj)
        ((is? obj Search-Set) (car (get-contexts obj)))
        ((string? obj) (make-search-context obj))
        (else (error "Unable to make a search context out of {s}" obj))))

(definition public (make-search-context target
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)
                     (user-data: user-data #f))
  (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test user-data))

(definition inline (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test user-data)
  (allocate Search-Context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test #f user-data))


(definition public (->search-set obj) <Search-Set>
  (cond ((is? obj Search-Set) obj)
        ((is? obj Search-Context) (allocate-search-set (search-context-regexp obj) (list obj)))
        ((string? obj) (->search-set (->search-context obj)))
        ((list? obj) (let ((contexts (map ->search-context obj)))
                       (allocate-search-set
                         (sre->irregex (cons 'or (map search-context->sre contexts)))
                         contexts)))
        (else (error "Unable to make a search set out of {s}" obj))))

(definition public (allocate-search-set regexp contexts)
  (allocate Search-Set regexp contexts))


(definition (->diacritic-ignoring-sre string)
  (let ((char-list (string->list string)))
    (cons 'seq (map (lambda (c)
                      (let ((equivalent (table-ref Diacritic-Table c #f)))
                        (if equivalent
                            (cons 'or (assq equivalent Diacritic-Equivalences))
                          c)))
                    char-list))))


(definition (search-context->sre context <Search-Context>)
  (let ((seq (let ((target (get-target context)))
               (cond ((get-regexp? context)
                      `(posix-string ,target))
                     ((get-ignore-diacritic? context)
                      (->diacritic-ignoring-sre target))
                     (else target)))))
    (if (get-ignore-case? context)
        (list 'w/nocase seq)
      seq)))

(definition public (search-context-regexp context <Search-Context>)
  (or (get-regexp context)
      (let ((rx (sre->irregex (search-context->sre context))))
        (set-regexp context rx)
        rx)))


(definition (regular-search-impl seq <Sequence> target <any> match-test <procedure+> constituent-test <procedure+> start <fx+> end <fx+> reversed? <bool>)
  (let* ((search-set (->search-set target))
         (first-context <Search-Context> (car (get-contexts search-set)))
         (whole-words? (get-whole-words? first-context))
         (match-test (or match-test (get-match-test first-context)))
         (constituent-test (or constituent-test (get-constituent-test first-context) word-constituent?))
         (regexp (get-regexp search-set))
         (card (cardinality seq))
         (start (or start (if reversed? card 0)))
         (end (or end (if reversed? 0 card))))
    (let (lp (i (if reversed? 0 start)) (best #f))
      (let ((match (irregex-search regexp seq i)))
        (if (not match)
            best
          (let ((from (irregex-match-start-index match 0))
                (to (irregex-match-end-index match 0)))
            (cond ((if reversed? (or (< from end) (> to start)) (> to end)) best)
                  ((if match-test
                       (match-test seq whole-words? constituent-test from to)
                     (or (not whole-words?)
                         (let ((before (and (> from 0) (element seq (- from 1))))
                               (after (and (< to card) (element seq to))))
                           (and (or (not before)
                                    (not (constituent-test before)))
                                (or (not after)
                                    (not (constituent-test after)))))))
                   (let ((res (cons from to)))
                     (if reversed? (lp (+ to 1) res) res)))
                  (else (lp to best)))))))))


(definition public (regular-search seq <Sequence> target <any>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f))
  (regular-search-impl seq target match-test constituent-test start end reversed?))


(definition public (regular-search-all seq <Sequence> target <any>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f))
  (let ((len (cardinality seq))
        (queue (new-queue))
        (search-set (->search-set target)))
    (let (iter (pos <fx> (or start (if reversed? len 0))))
      (let ((found (regular-search-impl seq search-set match-test constituent-test pos end reversed?)))
        (if found
            (begin
              (enqueue queue found)
              (iter (if reversed? (car found) (cdr found))))
          (queue-list queue))))))


(definition public (search seq <Sequence> target <Object>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)) <int+>
  (if (and (string? seq)
           (string? target)
           (not end)
           (not reversed?)
           (not whole-words?)
           (not ignore-case?)
           (not ignore-diacritic?)
           (not regexp?)
           (not match-test)
           (not constituent-test))
      (string-search seq target start: start)
    (let ((search-set (->search-set (if (string? target)
                                        (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? #f #f #f)
                                      target))))
      (let ((found (regular-search-impl seq search-set match-test constituent-test start end reversed?)))
        (if found
            (car found)
          #f)))))


(definition public (search-all seq <Sequence> target <Object>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)) <list>
  (let ((search-set (->search-set (if (string? target)
                                      (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? #f #f #f)
                                    target))))
    (map car (regular-search-all seq search-set
               start: start
               end: end
               reversed?: reversed?
               match-test: match-test
               constituent-test: constituent-test))))


(definition public (split seq <Object> separator <Object>) <list>
  (cond ((zero? (cardinality seq))
         (list seq))
        ((procedure? separator)
         (let ((previous 0)
               (result (new List-Factory))
               (done? #f))
           (while (not done?)
             (let ((pos (find-if separator seq start: previous return: 'position)))
               (if (not pos)
                   (set! done? #t)
                 (put result (subseq seq previous pos))
                 (set! previous (+ pos 1)))))
           (put result (subseq seq previous))
           (get-output result)))
        (else
         (let ((previous 0)
               (incr (cardinality separator))
               (result (new List-Factory)))
           (let (iterate)
             (let ((pos (search seq separator start: previous)))
               (when pos
                 (put result (subseq seq previous pos))
                 (set! previous (+ pos incr))
                 (iterate))))
           (put result (subseq seq previous))
           (get-output result)))))


(definition public (split-justified seq <Object> width separators <Object> (column: column <fx> 0))
  (let ((pos 0)
        (size (cardinality seq))
        (result (new List-Factory))
        (done? #f))
    (while (not done?)
      (let ((effective-width (- width column)))
        (if (<= (- size pos) effective-width)
            (begin
              (put result (subseq seq pos))
              (set! done? #t))
          (put result (subseq seq pos (+ pos effective-width)))
          (set! column 0)
          (increase! pos effective-width))))
    (get-output result)))


(definition public (join sequences <Object> separator <Object>)
  (cond ((null? sequences)
         '())
        ((null? (cdr sequences))
         (car sequences))
        (else
         (let ((first (car sequences)))
           ;; optimization
           (if (string? first)
               (join-strings sequences separator)
             (let ((dst (new List-Factory)))
               (put dst first)
               (for-each (lambda (seq)
                           (put dst separator)
                           (put dst seq))
                         (cdr sequences))
               (apply concatenate (get-output dst))))))))


(definition public (join-symbols symbols separator)
  (string->symbol (join (map symbol->string symbols) separator)))


(definition public (inject sequence inserted)
  (let ((fact (new List-Factory))
        (first? #t))
    (for-each (lambda (element)
                (if first?
                    (set! first? #f)
                  (put-sequence fact inserted))
                (put fact element))
              sequence)
    (get-output fact)))


(definition public (substitute old-value <Object> new-value <Object> seq <Object> (key: key #f) (test: test #f) (sequence?: sequence? #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (dst (new List-Factory)))
    (while (not (done? src))
      (let ((object (get-next src)))
        (if (apply-test test old-value (apply-key key object))
            (if (not sequence?)
                (put dst new-value)
              (put-sequence dst new-value))
          (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(definition public (substitute-alist replacements <Object> seq <Object> (key: key #f) (test: test #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (dst (new List-Factory)))
    (while (not (done? src))
      (let ((object (get-next src))
            (found? #f))
        (for-each (lambda (replacement)
                    (unless found?
                      (bind (old . new) replacement
                        (when (apply-test test old (apply-key key object))
                          (put-sequence dst new)
                          (set! found? #t)))))
                  replacements)
        (unless found?
          (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(definition public (substitute-string str old new)
  (let ((port (open-output-string)))
    (let (iter (start 0))
      (let ((pos (search str old start: start)))
        (if (not pos)
            (begin
              (write-string (substring str start (string-length str)) port)
              (get-output-string port))
          (write-string (substring str start pos) port)
          (write-string new port)
          (iter (+ pos (string-length old))))))))


(definition public (fill! seq object (start: start #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq)))
    (when start
      (set-position src start))
    (while (not (done? src))
      (put src object)
      (next src)))
  seq)


(definition public (replace! seq replacement (start: start #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (rep (iterator replacement)))
    (when start
      (set-position src start))
    (while (and (not (done? src)) (not (done? rep)))
      (put src (get-next rep))
      (next src)))
  seq)


(definition public (ordered-position object seq (key: key #f) (test: test <=))
  (find seq object key: key test: test))


(definition public (insert-ordered! object seq (key: key #f) (test: test <=))
  (let ((n (ordered-position (apply-key key object) seq key: key test: test)))
    (insert! seq (or n (cardinality seq)) object)))


(definition global-compare
  compare)

(definition global-ci-compare
  ci-compare)


(definition public (merge-ordered proc x y (key: key #f) (left-key: left-key key) (right-key: right-key key) (compare: compare #f) (case-insensitive?: case-insensitive? #f))
  (declare (proper-tail-calls))
  (let ((ix (iterator x))
        (iy (iterator y))
        (compare-proc (or compare (if case-insensitive? global-ci-compare global-compare))))
    (while (and (not (done? ix)) (not (done? iy)))
      (let* ((ex (peek ix))
             (ey (peek iy))
             (kx (apply-key left-key ex))
             (ky (apply-key right-key ey)))
        (case (compare-proc kx ky)
          ((:equal)   (proc :same kx ex ey)
           (next ix)
           (next iy))
          ((:less)    (proc :left kx ex #f)
           (next ix))
          ((:greater) (proc :right ky #f ey)
           (next iy))
          (else       (error "Unable to compare {t} and {t}" kx ky)))))
    (while (not (done? ix))
      (let ((expr (get-next ix)))
        (proc :left (apply-key left-key expr) expr #f)))
    (while (not (done? iy))
      (let ((expr (get-next iy)))
        (proc :right (apply-key right-key expr) #f expr)))))


(definition public (merge proc lists (key: key #f) (compare: compare compare))
  (declare (proper-tail-calls))
  (let ((scan (copy lists)))
    (while (some? not-null? scan)
      (let* ((min (minimum (map car (remove-empty scan)) key: key compare: compare))
             (min-key (apply-key key min))
             (res (new List-Factory)))
        (for-each-pair (lambda (pair)
                         (let* ((list (car pair))
                                (object (car list)))
                           (if (or (not object)
                                   (neq? (compare (apply-key key object) min-key) :equal))
                               (put res #f)
                             (put res object)
                             (set-car! pair (cdr list)))))
                       scan)
        (proc min-key (get-output res))))))


(definition public (next-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t))
  (let ((rank (find seq elem key: key test: test))
        (card (cardinality seq)))
    (let ((next-rank
            (if (not rank)
                0
              (let ((next (+ rank 1)))
                (if cycle?
                    (modulo next card)
                  (and (< next card)
                       next))))))
      (and next-rank
           (element seq next-rank)))))


(definition public (previous-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t))
  (let ((rank (find seq elem key: key test: test))
        (card (cardinality seq)))
    (let ((previous-rank
            (if (not rank)
                (- card 1)
              (let ((previous (- rank 1)))
                (if cycle?
                    (modulo previous card)
                  (and (>= previous 0)
                       previous))))))
      (and previous-rank
           (element seq previous-rank)))))


(definition public (cycle-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t) (reversed?: reversed? #f))
  (if reversed?
      (previous-element seq elem key: key test: test cycle?: cycle?)
    (next-element seq elem key: key test: test cycle?: cycle?)))


(definition public (random-element seq)
  (element seq (random (cardinality seq))))


(definition public (random-sequence seq)
  (let (iter (res '()) (seq seq))
    (if (null? seq)
        res
      (let ((elem (random-element seq)))
        (iter (cons elem res) (remove elem seq))))))


(definition public (partition sequence (key: key identity) (test: test #f))
  (let ((result '()))
    (for-each (lambda (element)
                (let* ((category (key element))
                       (pair (associate category result test: test)))
                  (if (not pair)
                      (set! result (cons (cons category (list element)) result))
                    (set-cdr! pair (cons element (cdr pair))))))
              sequence)
    (reverse! (map (lambda (partition)
                     (bind (key . elements) partition
                       (cons key (reverse! elements))))
                   result))))


(definition public (partition-binary lst predicate)
  (let ((yes '())
        (no '()))
    (for-each (lambda (elem)
                (if (predicate elem)
                    (set! yes (cons elem yes))
                  (set! no (cons elem no))))
              lst)
    (values yes no)))


(definition public (starts-with? seq target (test: test #f) (ignore-case?: ignore-case? #f)) <bool>
  (let ((sl (cardinality seq))
        (tl (cardinality target))
        (test (or test (if ignore-case? string-ci=? string=?))))
    (and (>= sl tl)
         ;; put nu=?
         ;; put subseq! (not sure)
         (test (subseq seq 0 tl) target))))


(definition public (ends-with? seq target (test: test #f) (ignore-case?: ignore-case? #f)) <bool>
  (let ((sl (cardinality seq))
        (tl (cardinality target))
        (test (or test (if ignore-case? string-ci=? string=?))))
    (and (>= sl tl)
         ;; put nu=?
         ;; put subseq! (not sure)
         (test (subseq seq (- sl tl)) target))))


(definition public (for-each-reversed proc lst)
  (declare (proper-tail-calls))
  (let (iterate (lst lst))
    (when (pair? lst)
      (iterate (cdr lst))
      (proc (car lst)))))


(definition (find-if-list predicate list key start returned)
  (let ((key (if (not key) (lambda (x) x) key)))
    (let (iter (rest (tail list start)) (rank <fx> start))
       (if (null? rest)
           #f
         (let ((result (predicate (key (car rest)))))
           (if result
               (cond ((eq? returned 'item) (car rest))
                     ((eq? returned 'position) rank)
                     ((eq? returned 'result) result)
                     (else (error "Unknown return type {t}" returned)))
             (iter (cdr rest) (+ rank 1))))))))


(definition public inline (insert-sequence! sequence pos seq)
  (replace-subseq! sequence pos pos seq))


;;;
;;;; Sequence-Explorer
;;;


(class package Sequence-Explorer extends Explorer


  (slot sequence             <Sequence>)
  (slot sequence-cardinality <fx>)
  (slot current              <fx>)


  (method override (initialize self seq (direction: direction 'forward) (start: start #f))
    (nextmethod self)
    (set! sequence seq)
    (set! sequence-cardinality (cardinality sequence))
    (set-direction self direction)
    (if (not start)
        (case direction
          ((forward)  (goto-beginning self))
          ((backward) (goto-end self)))
      (set! current start)))


  (method override (peek-forward self)
    (element sequence current))


  (method override (peek-backward self)
    (element sequence (- current 1)))


  (method override (goto-beginning self)
    (set! current 0))


  (method override (goto-end self)
    (set! current sequence-cardinality))


  (method override (forward self)
    (increase! current 1))


  (method override (backward self)
    (decrease! current 1))


  (method override (done-forward? self)
    (>= current sequence-cardinality))


  (method override (done-backward? self)
    (= current 0))


  (method override (put-forward self object <Object>)
    (set-element! sequence current object))


  (method override (put-backward self object <Object>)
    (set-element! sequence (- current 1) object))


  (method override (get-position self)
    current)


  (method override (set-position self pos <fx>)
    (set! current (between 0 pos sequence-cardinality)))


  (method override (get-state self)
    current)


  (method override (reset-state self state <fx>)
    (set! current state)))


;;;
;;;; List
;;;


(class List-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-list len))
  
  
  (method override (coerce-object self seq)
    (let ((queue (new-queue)))
      (iterate seq
               (lambda (object)
                 (enqueue queue object)))
      (queue-list queue))))


(class primitive List metaclass List-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "lists"))
  
  
  (method override (copy-object self deep?)
    (map (lambda (x)
           (if deep?
               (subcopy x deep?)
             x))
         self))
  
  
  (method override (iterate-object self)
    (new List-Iterator self))
  
  
  (method override (sequence-element self n) <any>
    (list-ref self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (list-set! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (length self))
  
  
  (method override (sequence-tail self n)
    (let (tail (lst self) (n n))
      (if (or (null? lst) (= n 0))
          lst
        (tail (cdr lst) (- n 1)))))
  
  
  (method override (sequence-last self)
    (if (null? (cdr self))
        (car self)
      (last (cdr self))))
  
  
  (method override (sequence-butlast self)
    (if (or (null? self) (null? (cdr self)))
        '()
      (cons (car self) (butlast (cdr self)))))
  
  
  (method override (sequence-subseq! self start end)
    (if (or (= start 0) (= end -1))
        self
      (subseq self start end)))
  
  
  (method hidden (replace-subseq! self start end seq)
    (if (= start 0)
        (begin
          (set-cdr! (last-tail seq) (tail self end))
          seq)
      (let* ((before (tail self (- start 1)))
             (after  (tail before (+ (- end start) 1))))
        (set-cdr! before seq)
        (set-cdr! (last-tail before) after)
        self))))


(class Null-Class extends List-Class)


(class primitive Null metaclass Null-Class extends List


  (method override (compare-object self obj)
    (if (null? obj)
        :equal
      :not-equal))
  
  
  (method override (di-compare-object self obj)
    (if (null? obj)
        :equal
      :not-equal)))


(class Pair-Class extends List-Class)


(class primitive Pair metaclass Pair-Class extends List


  (method override (compare-object self obj)
    (if (pair? obj)
        (case (compare (car self) (car obj))
          ((:less) :less)
          ((:greater) :greater)
          ((:equal)
           (let ((left (cdr self))
                 (right (cdr obj)))
             (cond ((and (null? left) (null? right))
                    :equal)
                   ((null? left)
                    :less)
                   ((null? right)
                    :greater)
                   (else
                    (compare left right)))))
          (else :not-equal))
      :not-equal))


  (method override (di-compare-object self obj)
    (if (pair? obj)
        (case (di-compare (car self) (car obj))
          ((:less) :less)
          ((:greater) :greater)
          ((:equal)
           (let ((left (cdr self))
                 (right (cdr obj)))
             (cond ((and (null? left) (null? right))
                    :equal)
                   ((null? left)
                    :less)
                   ((null? right)
                    :greater)
                   (else
                    (di-compare left right)))))
          (else :not-equal))
      :not-equal))
  
  
  (method override (walk-references self proc)
    (walk-references (car self) proc)
    (walk-references (cdr self) proc))
  
  
  (method override (setup-context self context)
    (setup-context (car self) context)
    (setup-context (cdr self) context)))


(specialize inline (element list <list> n) <any>
  (list-ref list (cast <int> n)))


(specialize inline (cardinality list <list>) <int>
  (length list))


(definition public (insert! seq pos obj)
  (insert-sequence! seq (or pos (cardinality seq)) (coerce (list obj) (class-of seq))))


(definition public (atom? value)
  (or (null? value)
      (boolean? value)
      (char? value)
      (string? value)
      (symbol? value)
      (keyword? value)
      (number? value)))


(definition public inline (null/pair? obj)
  (or (null? obj) (pair? obj)))


(definition public inline (one-element? obj)
  (and (pair? obj) (null? (cdr obj))))


(definition public (last-tail lst)
  (if (null? lst)
      lst
    (let (iter (cur lst))
      (if (pair? (cdr cur))
          (iter (cdr cur))
        cur))))


(definition public (make-list n . rest)
  (declare (proper-tail-calls))
  (let ((fill (if (null? rest) #f (car rest)))
        (list '()))
    (while (> n 0)
      (set! list (cons fill list))
      (set! n (- n 1)))
    list))


(definition public inline (list-set! list n value)
  (set-car! (list-tail list n) value))


(definition public inline (set-cadr! pair value)
  (set-car! (cdr pair) value))


(definition public (append! . rest)
  (let ((queue (new-queue)))
    (for-each (lambda (lst)
                (enqueue-list queue lst))
              rest)
    (queue-list queue)))


(definition public (position target lst (key: key #f) (test: test #f))
  (define (position lst pos)
    (cond ((null? lst)
           #f)
          ((apply-test test target (apply-key key (car lst)))
           pos)
          (else
           (position (cdr lst) (+ pos 1)))))
  
  (position lst 0))


(definition public (copy-tree tree)
  (if (pair? tree)
      (cons (copy-tree (car tree))
            (copy-tree (cdr tree)))
    tree))


(definition public (position-of obj lst)
  (let (iter (rst lst) (i <fx> 0))
    (if (null? rst)
        #f
      (if (eq? obj (car rst))
          i
        (iter (cdr rst) (+ i 1))))))

           
(definition public (proper-list? lst)
  (cond ((null? lst) #t)
        ((not (pair? lst)) #f)
        (else (proper-list? (cdr lst)))))


(definition public (proper-length l)
  (define (length l n)
    (if (pair? l)
        (length (cdr l) (+ n 1))
      n))
  
  (length l 0))


(definition public (split-list lst)
  (let (iter (scan lst) (proper '()))
    (if (null? scan)
        (values (reverse! proper) #f)
      (if (pair? scan)
          (iter (cdr scan) (cons (car scan) proper))
        (values (reverse! proper) scan)))))


(definition public (last-cdr lst)
  (if (pair? lst)
      (last-cdr (cdr lst))
    lst))


(definition public (butlast-cdr lst)
  (if (pair? lst)
      (cons (car lst) (butlast-cdr (cdr lst)))
    '()))


(definition public (add-ordered! obj lst (key: key #f))
  (declare (proper-tail-calls))
  (if (null? lst)
      (list obj)
    (let ((obj-key (apply-key key obj)))
      (if (< obj-key (apply-key key (car lst)))
          (cons obj lst)
        (let (loop (scan lst) (next (cdr lst)))
          (if (null? next)
              (set-cdr! scan (list obj))
            (if (< obj-key (apply-key key (car next)))
                (let ((pair (list obj)))
                  (set-cdr! scan pair)
                  (set-cdr! pair next))
              (loop next (cdr next)))))
        lst))))


(definition public (move-to-head! target lst)
  (if (or (null? lst) (eq? target (car lst)))
      lst
    (let (iter (previous lst) (scan (cdr lst)))
      (cond ((null? scan) lst)
            ((eq? (car scan) target)
             (set-cdr! previous (cdr scan))
             (cons target lst))
            (else (iter scan (cdr scan)))))))


(definition public (move-to-tail! target lst)
  (cond ((null? lst) lst)
        ((eq? (car lst) target)
         (set-cdr! (last-tail lst) (cons target '()))
         (cdr lst))
        (else
         (let (iter (previous lst) (scan (cdr lst)))
           (cond ((null? scan) lst)
                 ((eq? (car scan) target)
                  (if (null? (cdr scan))
                      lst
                    (begin
                      (set-cdr! previous (cdr scan))
                      (set-cdr! (last-tail scan) (cons target '()))
                      lst)))
                 (else
                  (iter scan (cdr scan))))))))


(definition public (augment . rest)
  (declare (proper-tail-calls))
  (let ((fact (new List-Factory))
        (scan rest))
    (while (not-null? scan)
      (if (null? (cdr scan))
          (put-sequence fact (car scan))
        (put fact (car scan)))
      (set! scan (cdr scan)))
    (get-output fact)))


(definition public inline (memq? target <Object> list <Object>)
  (boolean (memq target list)))


(definition public inline (memv? target <Object> list <Object>)
  (boolean (memv target list)))


(definition public (member? target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (cond ((null? scan)
           #f)
          ((apply-test test target (apply-key key (car scan)))
           #t)
          (else
           (iter (cdr scan))))))


(definition public (assq-value key list default-value)
  (let ((pair (assq key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (assv-value key list default-value)
  (let ((pair (assv key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (assoc-value key list default-value)
  (let ((pair (assoc key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (associate target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (if (null? scan)
        #f
      (let ((pair (car scan)))
        (if (apply-test test target (apply-key key (car pair)))
            pair
          (iter (cdr scan)))))))


(definition public (rassociate target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (if (null? scan)
        #f
      (let ((pair (car scan)))
        (if (apply-test test target (apply-key key (cdr pair)))
            pair
          (iter (cdr scan)))))))


(definition public (find-pair target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (cond ((null? scan)
           #f)
          ((apply-test test target (apply-key key (car scan)))
           scan)
          (else
           (iter (cdr scan))))))


(definition public (reverse! list <Object>)
  (declare (proper-tail-calls))
  (let ((res <Object> '())
        (ptr <Object> '()))
    (while (not-null? list)
      (set! ptr (cdr list))
      (set-cdr! list res)
      (set! res list)
      (set! list ptr))
    res))


(definition public (remove! target <Object> list <Object> (key: key #f) (test: test eqv?))
  (declare (proper-tail-calls))
  (while (and (not-null? list) (test target (apply-key key (car list))))
    (set! list (cdr list)))
  (if (null? list)
      '()
    (let ((previous list)
          (scan (cdr list)))
      (while (not-null? scan)
        (if (test target (apply-key key (car scan)))
            (begin
              (set! scan (cdr scan))
              (set-cdr! previous scan))
          (set! previous scan)
          (set! scan (cdr scan)))))
    list))


(definition public (subtract! target <Object> list <Object>)
  (cond ((null? list)
         '())
        ((eq? (car list) target)
         (cdr list))
        (else
         (let (iter (previous list) (scan (cdr list)))
           (cond ((null? scan)
                  list)
                 ((eq? (car scan) target)
                  (set-cdr! previous (cdr scan))
                  list)
                 (else
                  (iter scan (cdr scan))))))))


(definition public (getprop plist <Object> target <Object> (key: key #f) (test: test #f))
  (let (iter (scan plist))
    (cond ((null? scan)
           #f)
          ((apply-test test (apply-key key (car scan)) target)
           scan)
          (else
           (iter (cddr scan))))))


(definition public (plist-remove plist keyword)
  (cond ((null? plist)
         '())
        ((eq? (car plist) keyword)
         (cddr plist))
        (else
         (cons (car plist)
               (cons (cadr plist)
                     (plist-remove (cddr plist) keyword))))))


(definition public (plist-add plist keyword value)
  (cond ((null? plist)
         (list keyword value))
        ((eq? (car plist) keyword)
         (cons (car plist)
               (cons value (cddr plist))))
        (else
         (cons (car plist)
               (cons (cadr plist) (plist-add (cddr plist) keyword value))))))


(definition public (getf plist <Object> target <Object> (key: key #f) (test: test #f) (not-found: not-found #f))
  (let ((pair (getprop plist target key: key test: test)))
    (if (not pair)
        not-found
      (cadr pair))))


(definition public (setf plist <Object> target <Object> value <Object>)
  (set-second! (getprop plist target) value))


(definition public (addf plist <Object> target <Object> value <Object>)
  (let ((pair (getprop plist target)))
    (if (not pair)
        (append! plist (list target value))
      (set-second! pair value)
      plist)))


(definition public (for-each-pair proc lst)
  (let (iterate (lst lst))  
    (when (not-null? lst)
      (proc lst)
      (iterate (cdr lst)))))


(definition public (for-each-property proc lst)
  (let (iterate (lst lst))
    (when (not-null? lst)
      (proc (car lst) (cadr lst))
      (iterate (cddr lst)))))


(definition public (map-property proc lst)
  (let ((queue (new-queue)))
    (for-each-property (lambda (property value)
                         (enqueue queue (proc property value)))
                       lst)
    (queue-list queue)))


(definition public (flatten-lists llist)
  (apply append llist))


(definition public (uniform lst (key: key #f) (test: test #f))
  (if (null? lst)
      lst
    (continuation-capture
      (lambda (return)
        (let ((first (apply-key key (car lst))))
          (for-each (lambda (object)
                      (let ((value (apply-key key object)))
                        (unless (apply-test test first value)
                          (continuation-return return #f))))
                    (cdr lst))
          first)))))


(definition public (sort-property-list prop-list <Object>)
  (let* ((factory (new List-Factory))
         (proc    (lambda (property value)
                    (put factory (list property value))))
         (alist   (begin
                    (for-each-property proc prop-list)
                    (get-output factory)))
         (sorted  (sort < alist key: car)))
    (apply append sorted)))


(definition public (plist->alist ls)
  (let (lp (ls ls) (res '()))
    (if (null? ls)
        (reverse res)
      (lp (cddr ls) (cons (cons (car ls) (cadr ls)) res)))))


(definition public (alist->plist ls)
  (let (lp (ls ls) (res '()))
    (if (null? ls)
        (reverse res)
      (lp (cdr ls) (cons (cdar ls) (cons (caar ls) res))))))


;;;
;;;; List-Iterator
;;;


(class package List-Iterator extends Iterator


  (slot current)
  (slot position)


  (method override (initialize self list <list>)
    (nextmethod self)
    (set! current list)
    (set! position 0))


  (method override (get-next! self)
    (if (null? current)
        (eof-object)
      (prog1 (car current)
        (set! current (cdr current))
        (set! position (+ position 1)))))


  (method override (done? self)
    (and (null? current) (eq? peeked Empty)))


  (method override (put self object)
    (set-car! current object))


  (method override (get-position self)
    position)


  (method override (set-position self pos)
    (let ((delta (- pos position)))
      (cond ((< delta 0) (error "List iterators cannot move backward"))
            ((> delta 0)
             (set! position pos)
             (set! current (tail current delta))))))


  (method override (get-state self)
    (cons current position))


  (method override (reset-state self state)
    (set! current (car state))
    (set! position (cdr state)))
  
  
  (method public (get-list self)
    current))


;;;
;;;; List-Factory
;;;


(class List-Factory extends Object


  (slot list            initialize '() getter generate)
  (slot last-list       initialize #f)
  (slot last-anchor     initialize #f)
  (slot current         initialize '())
  (slot size       <fx> initialize 0   getter generate)


  (method package (put self object <Object>)
    (cond ((null? current)
           (set! current (cons object current))
           (set! list current))
          (else
           (when last-list
             (copy-last-list self))
           (set-cdr! current (cons object '()))
           (set! current (cdr current))))
    (prog1 size
      (increase! size)))


  (method (put-unique self object (test: test eqv?))
    (unless (member? object list test: test)
      (put self object)))


  (method package (put-sequence self seq <Object>)
    (when seq
      (if (not (pair? seq))
          (iterate seq (~ put self))
        (cond ((null? current)
               (set! current seq)
               (set! last-list seq)
               (set! list seq))
              (else
               (when last-list
                 (copy-last-list self))
               (set! last-list seq)
               (set! last-anchor current)
               (set-cdr! current seq))))
      (prog1 size
        (increase! size (cardinality seq)))))
  
  
  (method public (is-empty? self)
    (null? current))
  
  
  (method public (get-last-element self)
    (car current))


  (method package (get-output self)
    list)


  (method public (reset self)
    (set! list '())
    (set! last-list #f)
    (set! last-anchor #f)
    (set! current '())
    (set! size 0))


  (method private (copy-last-list self)
    (cond ((not last-anchor)
           (set! list (copy last-list))
           (set! current (last-tail list)))
          (else
           (set-cdr! last-anchor (copy last-list))
           (set! current (last-tail last-anchor))))
    (set! last-list #f)
    (set! last-anchor #f)))


;;;
;;;; Table
;;;


(class primitive Table extends Object
  
  
  (method override (initialize self . rest)
    (native-class "tables"))


  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a} entries"
          (table-length self))))))


(definition public (table-add table <table> key value)
  (let ((lst (cons value (table-ref table key '()))))
    (table-set! table key lst)))


(definition public (table-remove! table <table> key value)
  (let ((lst (remove! value (table-ref table key '()))))
    (if (null? lst)
        (table-clear table key)
      (table-set! table key lst))))


(definition public (table-subtract! table <table> key value)
  (let ((lst (subtract! value (table-ref table key '()))))
    (if (null? lst)
        (table-clear table key)
      (table-set! table key lst))))


(definition public (empty-table table <table>)
  (iterate-table table
    (lambda (k v)
      (table-clear table k))))


(definition public (table-keys table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons key list))))
    list))


(definition public (table-values table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons value list))))
    list))


(definition public (table-keys/values table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons (cons key value) list))))
    list))


(definition public (table-find table <table> value (test: test eqv?))
  (continuation-capture
    (lambda (return)
      (iterate-table table
        (lambda (k v)
          (when (test v value)
            (continuation-return return k))))
      #f)))


(definition public (table-load table <table> input (error-on-duplicates? #t))
  (declare (proper-tail-calls))
  (let (iterate)
    (let ((name (read input))
          (object (read input)))
      (when (and (not (eof-object? name))
                 (not (eof-object? object)))
        (if (and error-on-duplicates? (table-ref table name #f))
            (error "Duplicated table entries for {t}" name)
          (table-set! table name object))
        (iterate)))))


(definition public (table-save table <table> output)
  (iterate-table table
    (lambda (key value)
      (write key output)
      (write-char #\space output)
      (write value output)
      (newline output))))


;;;
;;;; Serialize
;;;


(definition public (serialize-reference reference)
  (let ((unit (reference-unit reference))
        (name (reference-name reference)))
    (let (iter (module-name unit))
      (let ((module (and (unit-loadable? module-name)
                         (require-module module-name))))
        (if (and module
                 (eq? (get-access module) 'public)
                 (table-ref (get-exports module) name #f))
            (list 'module-public module-name name)
          (let ((path (butlast (split-identifier module-name))))
            (if (null? path)
                (error "Unable to serialize: {s}" reference)
              (iter (apply compose-identifier path)))))))))


(definition *serialized-classes* <table>
  (make-table test: eq?))


(definition public (serialize-class class)
  (or (table-ref *serialized-classes* class #f)
      (let ((name (get-name class)))
        (let ((serialize
                ;; special case for presence interoperability
                (if (eq? name 'jazz.presence.remotable.IOR:IOR)
                    'ior
                  (serialize-reference name))))
          (table-set! *serialized-classes* class serialize)
          serialize))))


(definition public (serialize-object class content)
  (make-serialized (serialize-class class) content))


(definition *deserialized-classes* <table>
  (make-table test: eq?))


(definition public (deserialize-class reference)
  (or (table-ref *deserialized-classes* reference #f)
      ;; special case for presence interoperability
      (let ((effective-reference (if (eq? reference 'ior) '(module-public jazz.presence IOR) reference)))
        (let ((class (resolve-runtime-reference (deserialize-runtime-reference effective-reference))))
          (table-set! *deserialized-classes* reference class)
          class))))


(definition public (serialize obj)
  (or (marshall-object (class-of obj) obj)
      (if (object? obj)
          (error "Unable to serialize: {a}" obj)
        obj)))


(definition public (deserialize obj)
  (if (serialized? obj)
      (let ((class (deserialize-class (serialized-class obj)))
            (content (serialized-content obj)))
        (or (unmarshall-object class content)
            (error "Unable to deserialize: {a}" (category-name class))))
    obj))


;; simple literal serialization
(definition public (serialize-literal obj)
  (serialize-object (class-of obj)
                    (vector (->string obj :reader))))


;; simple literal deserialization
(definition public (deserialize-literal content)
  (parameterize ((walk-for #f))
    (with-jazz-readtable
      (lambda ()
        (read-string-element (vector-ref content 0))))))


;;;
;;;; Services
;;;


(definition *services*
  (make-table test: eq?))


(definition public (provide-service name proc)
  (table-set! *services* name proc))


(definition public (request-service name (not-provided #f))
  (lambda rest
    (let ((service (table-ref *services* name #f)))
      (cond (service
             (apply service rest))
            (not-provided
             (apply not-provided rest))
            (else
             (error "Service {s} not provided" name))))))


;;;
;;;; Slot
;;;


(class Slot extends Field
  
  
  (slot offset     getter generate)
  (slot initialize getter generate))


;;;
;;;; Property
;;;


(class Property extends Slot
  
  
  (slot getter getter generate)
  (slot setter getter generate))


(definition public inline (property? obj)
  (is? obj Property))


(definition public (symbolize-property property <Object>)
  (cond ((field? property) (get-name property))
        ((keyword? property) (keyword->symbol property))
        (else property)))


(definition public (symbolize-properties properties <Object>)
  (let ((fact (new List-Factory)))
    (for-each-property
      (lambda (property value)
        (put fact (symbolize-property property))
        (put fact value))
      properties)
    (get-output fact)))


(definition public (keywordize-property property <Object>)
  (cond ((field? property) (symbol->keyword (field-name property)))
        ((keyword? property) property)
        (else (symbol->keyword property))))


(definition public (keywordize-properties properties <Object>)
  (let ((fact (new List-Factory)))
    (for-each-property
      (lambda (property value)
        (put fact (keywordize-property property))
        (put fact value))
      properties)
    (get-output fact)))


(definition public (read-property object <Object> expr <Object>)
  (let ((getter (property-getter (property-field (class-of object) expr))))
    (if getter
        (getter object)
      (error "Property {s} has no getter" expr))))


(definition public (write-property object <Object> expr <Object> value <Object>)
  (let ((setter (property-setter (property-field (class-of object) expr))))
    (if setter
        (setter object value)
      (error "Property {s} has no setter" expr))))


(definition public (property-field class <Class> expr <Object>)
  (define (property->symbol expr)
    (cond ((keyword? expr) (keyword->symbol expr))
          ((enumerator? expr) (enumerator->symbol expr))
          (else expr)))
  
  (if (property? expr)
      expr
    (let ((field (category-field class (property->symbol expr))))
      (if (property? field)
          field
        (error "Unknown property: {t}" expr)))))


(definition public (property-field? class <Class> symbol <symbol>)
  (boolean (category-field class symbol)))


;;;
;;;; String
;;;


(class String-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-string len))
  
  
  (method override (coerce-object self obj <Object>)
    (coerce-string obj)))


(class primitive String metaclass String-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "strings"))
  
  
  (method override (coerce-string self)
    self)


  (method override (compare-object self obj)
    (if (string? obj)
        ;; kinda annoying to have to potentialy scan the list twice
        (cond ((string=? self obj)
               :equal)
              ((string<? self obj)
               :less)
              (else
               :greater))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (if (string? obj)
        ;; kinda annoying to have to potentialy scan the list twice
        (cond ((string-ci=? self obj)
               :equal)
              ((string-ci<? self obj)
               :less)
              (else
               :greater))
      :incompatible))
  
  
  (method override (sequence-element self n <fx>) <any>
    (string-ref self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (string-set! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (string-length self))
  
  
  (method override (sequence-tail self n)
    (let ((lgt (cardinality self)))
      (if (>= n lgt)
          ""
        (substring self n (cardinality self)))))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (substring self 0 (- (cardinality self) 1))))


(specialize inline (= s1 <string> s2 <string>) <bool>
  (string=? s1 s2))


(specialize inline (element string <string> n) <char>
  (string-ref string (cast <fx> n)))


(specialize inline (set-element! string <string> n c) <void>
  (string-set! string (cast <fx> n) (cast <char> c)))


(specialize inline (cardinality string <string>) <fx>
  (string-length string))


(specialize inline (subseq string <string> start end) <string>
  (substring string (cast <fx> start) (cast <fx> end)))


(specialize (replace-subseq! string <string> start end replacement) <string>
  ;; should become append! when append! is a specialized definition
  (string-append (subseq string 0 (cast <fx> start))
                 (cast <string> replacement)
                 (subseq string (cast <fx> end) (cardinality string))))


(instantiate-for-each string-for-each <string>)
(instantiate-butlast <string>)
(instantiate-find string-find <string>)
(instantiate-find-in string-find-in <string>)
(instantiate-starts-with? <string>)
(instantiate-ends-with? <string>)


(definition public (empty-string? object)
  (and (string? object)
       (zero? (string-length object))))


(definition public (->string expr (detail :human))
  (cond ((and (string? expr) (eq? detail :human))
         expr)
        ((symbol? expr)
         (symbol->string expr))
        (else
         (let ((output (open-output-string)))
           (print expr output detail)
           (get-output-string output)))))


(definition public (string-search str target (start: start #f))
  (let ((strlen (string-length str))
        (tarlen (string-length target)))
    (let (iter (pos (or start 0)))
      (let ((end (+ pos tarlen)))
        (cond ((> end strlen)
               #f)
              ((equal? (substring str pos end) target)
               pos)
              (else
               (iter (+ pos 1))))))))


(definition public (string-contains? str target (start: start #f))
  (boolean (string-search str target start: start)))


(definition public (string-trailer str <string> c) <string>
  (let ((pos (string-find-reversed str c)))
    (if (not pos)
        str
      (substring str (+ pos 1) (string-length str)))))


(definition public (remove-trailing-char string c)
  (let ((len (cardinality string)))
    (if (and (> len 0)
             (eqv? (element string (- len 1)) c))
        (subseq string 0 (- len 1))
      string)))


(definition public (value-string? object <Object>)
  (and (string? object)
       (not (empty-string? object))))


(definition public (wi=? s1 <Object> s2 <Object>)
  (declare (proper-tail-calls))
  (continuation-capture
    (lambda (return)
      (let* ((n1 <fx> 0)
             (n2 <fx> 0)
             (l1 <fx> (cardinality s1))
             (l2 <fx> (cardinality s2))
             (s? <bool> #t)
             (w1? <bool> #f)
             (w2? <bool> #f)
             (d1? <bool> (= l1 0))
             (d2? <bool> (= l2 0)))
        (while (or (not d1?) (not d2?))
          (set! w1? #f)
          (while (and (not d1?) (whitechar? (element s1 n1)))
            (set! w1? #t)
            (increase! n1)
            (set! d1? (>= n1 l1)))
          (set! w2? #f)
          (while (and (not d2?) (whitechar? (element s2 n2)))
            (set! w2? #t)
            (increase! n2)
            (set! d2? (>= n2 l2)))
          (when (and w1? (or s? d2?))
            (set! w1? #f))
          (when (and w2? (or s? d1?))
            (set! w2? #f))
          (set! s? #f)
          (cond ((and d1? d2?)
                 (continuation-return return #t))
                ((and (eq? w1? w2?) (not d1?) (not d2?) (eqv? (element s1 n1) (element s2 n2)))
                 (increase! n1)
                 (increase! n2)
                 (set! d1? (>= n1 l1))
                 (set! d2? (>= n2 l2)))
                (else
                 (continuation-return return #f))))
        (and d1? d2?)))))


(definition public (unique-domain-name name domain (separator: separator #f))
  (if (not (member? name domain))
      name
    (let* ((common-prefix (if (not separator) name (concatenate name separator)))
           (common-length (cardinality common-prefix))
           (suffixes (collect (lambda (string)
                                (when (starts-with? string common-prefix)
                                  (subseq string common-length)))
                              domain))
           (n 1)
           (suffix #f))
      ;; not 100% sure about the while converted code
      (let (iterate)
        (set! suffix (->string n))
        (when (member? suffix suffixes)
          (increase! n)
          (iterate)))
      (concatenate common-prefix suffix))))


(definition public (remove-numeric-suffix string)
  (let ((pos (find-if (lambda (c) (not (numeric? c))) string reversed?: #t return: 'position)))
    (if (not pos)
        ""
      (subseq string 0 (+ pos 1)))))


(definition public (compare-n x <string> y <string> max <fx> (test: test eqv?))
  (let ((xlen <fx> (string-length x))
        (ylen <fx> (string-length y)))
    (let (iter (n 0))
      (cond ((>= n max)
             #t)
            ((or (>= n xlen) (>= n ylen) (not (test (string-ref x n) (string-ref y n))))
             #f)
            (else
             (iter (+ n 1)))))))


(definition public (string-checksum str)
  (let ((sum 0)
        (len (string-length str)))
    (let (iter (n 0))
      (when (< n len)
        (increase! sum (char->integer (string-ref str n)))
        (iter (+ n 1))))
    sum))


(definition public (split-lines string)
  (call-with-input-string string
    read-lines))


(definition public (join-lines lines)
  (if (null? lines)
      ""
    (join lines "\n")))


(definition public (append-lines . args)
  (join-lines args))


;;;
;;;; Time
;;;


(definition public (seconds->milliseconds x)
  (fxround (* x 1000.)))

(definition public (milliseconds->seconds x)
  (/ x 1000.))


(definition public (seconds->microseconds x)
  (fxround (* x 1000000.)))

(definition public (microseconds->seconds x)
  (/ x 1000000.))


;;;
;;;; Waiter
;;;


(class Waiter extends Object
  
  
  (slot name             getter generate)
  (slot time             getter generate)
  (slot proc             getter generate)
  (slot mutex   <object> getter generate)
  (slot condvar <object> getter generate)
  (slot done?            getter generate)
  
  
  (method override (initialize self name)
    (nextmethod self)
    (set! self.name name)
    (set! self.time #f)
    (set! self.proc #f)
    (set! self.mutex (make-mutex name))
    (set! self.condvar (make-condition-variable name))
    (set! self.done? #f))
  
  
  (method public (done self)
    (mutex-lock! mutex)
    (set! done? #t)
    (condition-variable-signal! condvar)
    (mutex-unlock! mutex))
  
  
  (method public (in self delay proc)
    (mutex-lock! mutex)
    (let ((first-time? (not time)))
      (set! self.time (+ (current-seconds) delay))
      (set! self.proc proc)
      (if first-time?
          (thread-start!
            (new-thread
              (lambda ()
                (wait self))
              name))
        (condition-variable-signal! condvar)))
    (mutex-unlock! mutex))
  
  
  (method (wait self)
    (declare (proper-tail-calls))
    (let (loop-wait)
      (if done?
          #f
        (mutex-lock! mutex)
        (let ((now (current-seconds)))
          (let ((remaining (- time now)))
            (if (<= remaining 0.)
                (let ((again-delay #f))
                  (define (again delay)
                    (set! time (+ now delay))
                    (set! again-delay delay))
                 
                  (proc again)
                  (if again-delay
                      (begin
                        (mutex-unlock! mutex condvar again-delay)
                        (loop-wait))
                    (set! time #f)
                    (set! proc #f)
                    (mutex-unlock! mutex)))
              (mutex-unlock! mutex condvar remaining)
              (loop-wait))))))))


(definition public (make-waiter (name (unspecified)))
  (new Waiter name))


;;;
;;;; Box
;;;


;; mainly because Gambit doesn't have boxed literals
(class Box extends Object
  
  
  (slot boxed getter generate)
    
    
  (method override (initialize self (boxed #f))
    (nextmethod self)
    (set! self.boxed boxed))
  
  
  (method override (print self output readably)
    (if (not boxed)
        (system-format output "~{{a}}"
          (category-name (class-of self)))
      (system-format output "~{{a} {a}}"
        (category-name (class-of self))
        boxed))))


;;;
;;;; GC
;;;


(definition protected *Mega-Patch*
  '())


(definition public (gc-protect obj)
  (set! *Mega-Patch* (cons obj *Mega-Patch*)))


;;;
;;;; ReadWrite Gate
;;;


(class ReadWrite-Gate extends Object
  
  
  (slot reader-count initialize 0)
  (slot reader-mutex initialize (make-mutex 'reader))
  (slot work-mutex   initialize (make-mutex 'work))
  
  
  (method public (reader-lock! self)
    (mutex-lock! reader-mutex)
    (when (= reader-count 0)
      (mutex-lock! work-mutex +inf.0 #f))
    (increase! reader-count)
    (mutex-unlock! reader-mutex))
  
  
  (method public (reader-unlock! self)
    (mutex-lock! reader-mutex)
    (decrease! reader-count)
    (when (= reader-count 0)
      (mutex-unlock! work-mutex))
    (mutex-unlock! reader-mutex))
  
  
  (method public (writer-lock! self)
    (mutex-lock! work-mutex))
  
  
  (method public (writer-unlock! self)
    (mutex-unlock! work-mutex)))


(definition public (make-readwrite-gate)
  (new ReadWrite-Gate))


;;;
;;;; Priority Queue
;;;


(class Priority-Queue extends Object
  
  
  (slot priority-count  <fx>)
  (slot queue-vector    <vector>)
  (slot mutex                    initialize (make-mutex))
  (slot mutex-condition-variable initialize (make-condition-variable))
  
  
  (method override (initialize self count)
    (nextmethod self)
    (set! priority-count count)
    (set! queue-vector
          (list->vector (map (lambda (n) (new-queue))
                             (naturals 0 priority-count)))))
  
  
  (method public (empty? self)
    (mutex-lock! mutex)
    (prog1 (not (top-queue self))
      (mutex-unlock! mutex)))
  
  
  (method public (size self)
    (mutex-lock! mutex)
    (prog1 (let ((count 0))
             (loop (for queue in-vector queue-vector)
                   (increase! count (cast <fx> (length (queue-list queue)))))
             count)
      (mutex-unlock! mutex)))
  
  
  (method (top-queue self)
    (let (iter (priority (- priority-count 1)))
      (if (>= priority 0)
          (let ((queue (element queue-vector priority)))
            (if (null? (queue-list queue))
                (iter (- priority 1))
              queue))
        #f)))
  
  
  (method public (push self obj (priority 0))
    (assert (< priority priority-count))
    (mutex-lock! mutex)
    (enqueue (element queue-vector priority) obj)
    (mutex-unlock! mutex)
    (condition-variable-signal! mutex-condition-variable))
  
  
  (method public (pop self timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (let ((queue (top-queue self)))
        (if queue
            (prog1 (dequeue queue)
              (mutex-unlock! mutex))
          (if (eqv? timeout 0)
              (prog1 (eof-object)
                (mutex-unlock! mutex))
            (if (mutex-unlock! mutex mutex-condition-variable timeout)
                (iter)
              (eof-object))))))))


;;;
;;;; Thread
;;;


(definition primordial-thread-object
  (current-thread))


(definition public (primordial-thread)
  primordial-thread-object)


(definition public (primordial-thread?)
  (eq? (current-thread) (primordial-thread)))


(definition public (new-thread thunk name . rest)
  (apply make-root-thread
         thunk
         name
         rest))


(definition public (thread-group-all-threads thread-group)
  (apply append (thread-group->thread-list thread-group)
    (map thread-group-all-threads (thread-group->thread-group-list thread-group))))


(definition public (top-threads)
  (thread-group-all-threads (thread-thread-group (primordial-thread))))


(definition public (present-thread-name name)
  (cond ((or (not name) (unspecified? name)) "<unnamed>")
        ((pair? name) (system-format "{l}" name))
        (else (->string name))))


(definition public (present-thread-state state)
  (let ((port (open-output-string))
        (moment (current-monotonic)))
    (cond ((thread-state-uninitialized? state)
           (system-format port "Uninitialized"))
          ((thread-state-initialized? state)
           (system-format port "Initialized"))
          ((thread-state-normally-terminated? state)
           (system-format port "Normally terminated"))
          ((thread-state-abnormally-terminated? state)
           (system-format port "Abnormally terminated"))
          ((thread-state-running? state)
           (system-format port "Running"))
          ((thread-state-waiting? state)
           (let ((wf (thread-state-waiting-for state))
                 (to (thread-state-waiting-timeout state)))
             (cond (wf
                    (system-format port "Waiting ")
                    (write wf port)
                    (when (mutex? wf)
                      (write-string " " port)
                      (write (mutex-state wf) port))
                    (when to
                      (write-timeout (systime->seconds to) moment port)))
                   (to
                    (system-format port "Sleeping")
                    (write-timeout (systime->seconds to) moment port)))))
          (else
           (write state port)))
    
    (get-output-string port)))


(definition public (safe-present-object object (max-width #f))
  (with-exception-catcher
    (lambda (exc)
      ;; add the exception reason somehow!?
      (let ((class-string
              (with-exception-catcher
                (lambda (exc)
                  "")
                (lambda ()
                  (string-append " " (symbol->string (category-name (class-of object))))))))
        (string-append "#<unprintable" class-string " #" (number->string (object->serial object)) ">")))
    (lambda ()
      (if max-width
          (object->string object max-width)
        (object->string object)))))


(definition public (safe-present-property object slot)
  (with-exception-catcher
    (lambda (exc)
      "#<unprintable property>")
    (lambda ()
      (read-property object slot))))


(definition delayed-events
  (open-vector))


(definition package (write-delayed-event thunk)
  (write thunk delayed-events)
  (force-output delayed-events))


(definition package (read-delayed-event)
  (input-port-timeout-set! delayed-events 0)
  (read delayed-events))


(definition public (process-delayed-events)
  (declare (proper-tail-calls))
  (let ((thunk (read-delayed-event)))
    (when (not (eof-object? thunk))
      (thunk)
      (process-delayed-events))))


(definition package (thread-loop? thread)
  (thread-specific thread))

(definition package (thread-start-loop thread)
  (thread-specific-set! thread #t))

(definition package (thread-stop-loop thread)
  (thread-specific-set! thread #f))


(definition package (thread-loop)
  (declare (proper-tail-calls))
  (let (loop)
    (thread-process)
    (when (thread-loop? (current-thread))
      (loop))))


(definition public (start-loop-thread name . rest)
  (let ((thread (apply new-thread thread-loop name rest)))
    (thread-start-loop thread)
    (thread-start! thread)
    thread))


(definition thread-queues <table>
  (make-table test: eq? weak-keys: #t))

(definition thread-queues-mutex
  (make-mutex 'thread-queues))


(definition package (thread-has-port? thread)
  (boolean (table-ref thread-queues thread #f)))


(definition (get-thread-queue thread) <Priority-Queue>
  (mutex-lock! thread-queues-mutex)
  (prog1 (or (table-ref thread-queues thread #f)
             (let ((queue (new Priority-Queue (if (eq? thread (primordial-thread)) 3 1))))
               (table-set! thread-queues thread queue)
               queue))
    (mutex-unlock! thread-queues-mutex)))


(definition package (thread-write-message thread thunk priority)
  (let ((thread-queue (get-thread-queue thread)))
    (push thread-queue thunk priority)))


(definition package (thread-read-message (timeout: timeout +infinity))
  (let ((thread-queue (get-thread-queue (current-thread))))
    (pop thread-queue timeout)))


(definition package (thread-write thread thunk (priority 0))
  (thread-write-message thread thunk priority))


(definition package (thread-read (timeout: timeout +infinity))
  (thread-read-message timeout: timeout))


(definition public (thread-process (timeout: timeout +infinity))
  (let ((thunk (thread-read-message timeout: timeout)))
    ;; need to test if we are the event thread as this
    ;; function will be called by any thread being debugged
    (when (primordial-thread?)
      (process-delayed-events))
    (when (not (eof-object? thunk))
      (thunk))))


(definition public (thread-post thread name thunk (priority 0))
  ;; posts are never synchronous
  (thread-write thread thunk priority))


(definition public (thread-block thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (thread-write thread
        (lambda ()
          (mutex-unlock! mutex)
          (thunk))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex))))


(definition public (thread-execute thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (thread-write thread
        (lambda ()
          (unwind-protect
              (thunk)
            (mutex-unlock! mutex)))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex))))


(definition thread-call-noresult
  (list 'thread-call-noresult))


(definition package (thread-call-result? result)
  (neq? result thread-call-noresult))


(definition public (thread-call thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (mutex-specific-set! mutex thread-call-noresult)
      (thread-write thread
        (lambda ()
          (unwind-protect
              (mutex-specific-set! mutex (thunk))
            (mutex-unlock! mutex)))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex)
      (mutex-specific mutex))))


(definition public (thread-exit)
  (continuation-return pristine-thread-continuation #f))


(definition public (exit-thread thread)
  (thread-int! thread thread-exit))


(definition public (sleep delay)
  (thread-sleep! delay))


;;;
;;;; Type
;;;


(definition public inline (is-not? object type)
  (not (is? object type)))


(definition public category-identifier
  get-category-identifier)

(definition public category-descendants
  get-category-descendants)

(definition public class-ascendant
  get-class-ascendant)


(definition public inline (category-name category)
  (reference-name (category-identifier category)))


(definition public inline (category-unit category)
  (reference-unit (category-identifier category)))


;;;
;;;; Unspecified
;;;


;; should ideally be implemented as a macro
(definition public (either . rest)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (value)
                  (when (specified? value)
                    (continuation-return return value)))
                rest)
      (unspecified))))


;;;
;;;; Vector
;;;


(class Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-vector len)))


(class primitive Vector metaclass Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->vector (tail (vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->vector (butlast (vector->list self)))))


(specialize inline (element vector <vector> n) <object>
  (vector-ref vector (cast <fx> n)))


(specialize inline (set-element! vector <vector> n obj) <void>
  (vector-set! vector (cast <fx> n) obj))


(specialize inline (cardinality vector <vector>) <fx>
  (vector-length vector))


(definition public (vector-map proc vector <vector> . vectors)
  (declare (proper-tail-calls))
  (let* ((length (vector-length vector))
         (new-vector (make-vector length)))
    (if (null? vectors)
        (let (loop (i 0))
          (when (< i length)
            (vector-set! new-vector i (proc (vector-ref vector i)))
            (loop (+ i 1))))
      (let (loop (i 0))
        (when (< i length)
          (vector-set! new-vector i (apply proc (vector-ref vector i) (map (lambda (vector <vector>)
                                                                             (vector-ref vector i))
                                                                           vectors)))
          (loop (+ i 1)))))
    new-vector))


(definition public (vector-for-each proc vector <vector> . vectors)
  (declare (proper-tail-calls))
  (let ((size (vector-length vector)))
    (if (null? vectors)
        (let (loop (i 0))
          (when (< i size)
            (proc (vector-ref vector i))
            (loop (+ i 1))))
      (let (loop (i 0))
        (when (< i size)
          (apply proc (vector-ref vector i) (map (lambda (vector <vector>)
                                                   (vector-ref vector i))
                                                 vectors))
          (loop (+ i 1)))))))


(definition public inline (allocate-vector size) <vector>
  (make-vector size))


(definition public (subvector-shift! vector <vector> start <fx> end <fx> shift <fx>)
  (let ((last (- end 1)))
    (cond ((< shift 0)
           (loop (for i from start to last)
                 (vector-set! vector (+ i shift) (vector-ref vector i))))
          ((> shift 0)
           (loop (for i from last downto start)
                 (vector-set! vector (+ i shift) (vector-ref vector i)))))))


(definition public (subf64vector-shift! vector <f64vector> start <fx> end <fx> shift <fx>)
  (let ((last (- end 1)))
    (cond ((< shift 0)
           (loop (for i from start to last)
                 (f64vector-set! vector (+ i shift) (f64vector-ref vector i))))
          ((> shift 0)
           (loop (for i from last downto start)
                 (f64vector-set! vector (+ i shift) (f64vector-ref vector i)))))))


;;;
;;;; Homogeneous
;;;


(definition public inline (allocate-s8vector  size) <s8vector>  (make-s8vector  size))
(definition public inline (allocate-u8vector  size) <u8vector>  (make-u8vector  size))
(definition public inline (allocate-s16vector size) <s16vector> (make-s16vector size))
(definition public inline (allocate-u16vector size) <u16vector> (make-u16vector size))
(definition public inline (allocate-s32vector size) <s32vector> (make-s32vector size))
(definition public inline (allocate-u32vector size) <u32vector> (make-u32vector size))
(definition public inline (allocate-s64vector size) <s64vector> (make-s64vector size))
(definition public inline (allocate-u64vector size) <u64vector> (make-u64vector size))
(definition public inline (allocate-f32vector size) <f32vector> (make-f32vector size))
(definition public inline (allocate-f64vector size) <f64vector> (make-f64vector size))


;;;
;;;; Axis
;;;


(definition AXIS_MIN_SIZE <fx>
  8)

(definition AXIS_GOLDEN_RATIO <fl>
  1.6)


(class Axis-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (new Axis len)))


(class Axis metaclass Axis-Class extends Sequence
  
  
  (slot size    <fx>     accessors generate)
  (slot content <vector> accessors generate)
  
  
  (method override (initialize self (s <fx> 0))
    (set! size s)
    (set! content (make-vector s #f)))
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s} {s}" size content))))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (cardinality self))
  
  
  (method override (sequence-tail self n <fx>) <Axis>
    (tail self n))
  
  
  (method override (sequence-last self) <any>
    (last self)))


(definition public (axis . rest)
  (coerce rest Axis))


(specialize inline (element axis <Axis> n) <any>
  (vector-ref (get-content axis) (cast <fx> n)))


(specialize inline (set-element! axis <Axis> n obj) <void>
  (vector-set! (get-content axis) (cast <fx> n) obj))


(specialize inline (cardinality axis <Axis>) <fx>
  (get-size axis))


(specialize (tail axis <Axis> n) <Axis>
  (let ((n (cast <fx> n)))
    (let ((new-axis (new Axis n))
          (offset (- (get-size axis) n)))
      (let (iter (i 0))
        (if (>= i n)
            new-axis
          (set-element! new-axis i (element axis (+ i offset)))
          (iter (+ i 1)))))))


(specialize (last axis <Axis>) <any>
  (element axis (- (get-size axis) 1)))


(specialize (insert! axis <Axis> pos obj) <Axis>
  (let ((pos (cast <fx> pos)))
    (replace-subseq! axis pos pos (list obj))))


(specialize (replace-subseq! axis <Axis> start end replacement) <Axis>
  (let ((start (cast <fx> start))
        (end (cast <fx> end))
        (replacement (cast <list> replacement)))
    (let* ((before (- end start))
           (after (cardinality replacement))
           (delta (- after before))
           (old-size (get-size axis))
           (new-size (+ old-size delta)))
      (cond ((< after before)
             (let (iter (n (- old-size end))
                        (src end)
                        (dst (+ end delta)))
               (when (> n 0)
                 (set-element! axis dst (element axis src))
                 (set-element! axis src #f)
                 (iter (- n 1) (+ src 1) (+ dst 1))))
             (axis-adjust axis new-size))
            ((> after before)
             (axis-adjust axis new-size)
             (let (iter (n (- old-size end))
                        (src (- old-size 1))
                        (dst (+ (- old-size 1) delta)))
               (when (> n 0)
                 (set-element! axis dst (element axis src))
                 (iter (- n 1) (- src 1) (- dst 1))))))
      (let (iter (n 0) (dst start))
        (when (< n after)
          (set-element! axis dst (element replacement n))
          (iter (+ n 1) (+ dst 1))))
      axis)))


(definition public (axis-remove! axis <Axis> element <any>) <void>
  (let ((n (find axis element)))
    (and n
         (let* ((start <fx> n)
                (end (+ start 1)))
           (replace-subseq! axis start end '())))))


(definition public (axis-adjust axis <Axis> n <fx>)
  (cond ((<= n (cardinality (get-content axis)))
         (set-size axis n))
        ((= (get-size axis) 0)
         (set-size axis n)
         (set-content axis (make-vector AXIS_MIN_SIZE #f)))
        (else
         (let ((old-real-size (cardinality (get-content axis)))
               (old-content (get-content axis)))
           (set-size axis n)
           (set-content axis (make-vector (fxround (* n AXIS_GOLDEN_RATIO)) #f))
           (let (iter (i 0))
             (when (< i old-real-size)
               (set-element! (get-content axis) i (element old-content i))
               (iter (+ i 1))))))))


(definition public (axis-add axis <Axis> obj)
  (let ((size (cardinality axis)))
    (axis-adjust axis (+ size 1))
    (set-element! axis size obj)))


(definition public inline (allocate-axis size <fx>) <Axis>
  (allocate Axis size (make-vector size #f)))

(specialize inline (new class <category<Axis>> size) <Axis>
  (allocate-axis size))


(specialize inline as axis-ref (element axis <Axis> n) <object>
  (vector-ref (get-content axis) (cast <fx> n)))


(specialize inline as axis-set! (set-element! axis <Axis> n obj) <void>
  (vector-set! (get-content axis) (cast <fx> n) obj))


(specialize inline as axis-cardinality (cardinality axis <Axis>) <fx>
  (get-size axis))


(instantiate-for-each axis-for-each <Axis>)
(instantiate-find axis-find <Axis>)
(instantiate-find-in axis-find-in <Axis>)


;;;
;;;; Dispatch
;;;


(definition public (dispatch? expr)
  (and (symbol? expr)
       (dispatch-string? (symbol->string expr))))


(definition public (dispatch-string? str)
  (and (ends-with? str "~")
       (not (string=? str "~"))))


(definition public (dispatch->name dispatch)
  (define (extract str)
    (subseq str 0 (- (cardinality str) 1)))
  
  (if (string? dispatch)
      (extract dispatch)
    (string->symbol (extract (symbol->string dispatch)))))


;;;
;;;; Enumeration
;;;


(class Enumeration extends Class
  
  
  (slot members initialize '() accessors generate)
  
  
  (method package (add-member self member)
    (set! members (append! members (list member))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a}" members))))


  (method (name->member self name)
    (or (find-in members name key: get-name test: eq?)
        (error "Unknown enumeration name: {t} in {t}" name self)))


  (method (value->member self value)
    (or (find-in members value key: get-value test: eqv?)
        (error "Unknown enumeration value: {t} in {t}" value self)))


  (method public (name->value self name)
    (get-value (name->member self name)))


  (method public (value->name self value)
    (get-name (value->member self value)))
  
  
  (method public (bits->names self bits)
    (let ((fact (new List-Factory)))
      (for-each (lambda (member)
                  (when (mask-bit-set? bits (get-value member))
                    (put fact (get-name member))))
                members)
      (get-output fact))))


(class Enumeration-Member metaclass Enumeration extends Object
  
  
  (slot name getter generate)
  
  
  (method override (initialize self name)
    (nextmethod self)
    (set! self.name name)
    (add-member (class-of self) self))


  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a}" name))))
  
  
  (method package virtual (get-value self)
    ))


(definition public (enumeration? obj)
  (is? obj Enumeration))


;;;
;;;; Attributes
;;;


(definition public (parse-attributes list)
  (let ((properties #f)
        (content #f))
    (let (iterate (scan list))
      (if (null? scan)
          (values (if properties (queue-list properties) '())
                  (if content (queue-list content) '()))
        (let ((element (car scan)))
          (if (and (not content) (keyword? element))
              (begin
                (when (not properties)
                  (set! properties (new-queue)))
                (enqueue properties element)
                (enqueue properties (cadr scan))
                (iterate (cddr scan)))
            (when (not content)
              (set! content (new-queue)))
            (enqueue content element)
            (iterate (cdr scan))))))))


;;;
;;;; Reference
;;;


(definition public (reference-string? str)
  (and (string-find-reversed str #\:)
       (not (string-starts-with? str ":"))
       (not (string-ends-with? str ":"))))


(definition public (reference->name str)
  (let ((pos (string-find-reversed str #\:)))
    (if (not pos)
        str
      (substring str (+ pos 1) (string-length str)))))


;;;
;;;; Encoding
;;;


(definition public (32-bit-integer->bytes x proc)
  (proc (modulo (arithmetic-shift x -24) 256)
        (modulo (arithmetic-shift x -16) 256)
        (modulo (arithmetic-shift x -8) 256)
        (modulo x 256)))


(definition public (64-bit-integer->bytes x proc)
  (proc (modulo (arithmetic-shift x -56) 256)
        (modulo (arithmetic-shift x -48) 256)
        (modulo (arithmetic-shift x -40) 256)
        (modulo (arithmetic-shift x -32) 256)
        (modulo (arithmetic-shift x -24) 256)
        (modulo (arithmetic-shift x -16) 256)
        (modulo (arithmetic-shift x -8) 256)
        (modulo x 256)))


(definition public (bytes->32-bit-integer b1 b2 b3 b4)
  (+ (arithmetic-shift b1 24)
     (arithmetic-shift b2 16)
     (arithmetic-shift b3 8)
     b4))


(definition public (bytes->64-bit-integer b1 b2 b3 b4 b5 b6 b7 b8)
  (+ (arithmetic-shift b1 56)
     (arithmetic-shift b2 48)
     (arithmetic-shift b3 40)
     (arithmetic-shift b4 32)
     (arithmetic-shift b5 24)
     (arithmetic-shift b6 16)
     (arithmetic-shift b7 8)
     b8))


(definition public (code-string->32-bit-integer s)
  (bytes->32-bit-integer (char->integer (string-ref s 0))
                         (char->integer (string-ref s 1))
                         (char->integer (string-ref s 2))
                         (char->integer (string-ref s 3))))


(definition public (32-bit-integer->code-string x)
  (32-bit-integer->bytes x
    (lambda (b0 b1 b2 b3)
      (string (integer->char b0)
              (integer->char b1)
              (integer->char b2)
              (integer->char b3)))))


;;;
;;;; I/O
;;;


(definition public undocumented (make-u8-content size content)
  (cons size content))

(definition public undocumented (u8-content-size content)
  (car content))

(definition public undocumented (iterate-u8-content content proc)
  (for-each (lambda (chunk)
              (bind (u8vector . size) chunk
                (proc u8vector size)))
            (cdr content)))


(definition public undocumented (read-u8-content port)
  (define chunk-size
    1024)
  
  (declare (proper-tail-calls))
  (let ((size 0)
        (fact (new List-Factory)))
    (let (loop)
      (let ((u8vector (make-u8vector chunk-size)))
        (let ((read (read-subu8vector u8vector 0 chunk-size port)))
          (if (= read 0)
              (make-u8-content size (get-output fact))
            (increase! size read)
            (put fact (cons u8vector read))
            (loop)))))))


(definition public undocumented (write-u8-content content port)
  (iterate-u8-content content
    (lambda (u8vector size)
      (write-subu8vector u8vector 0 size port))))


(definition public undocumented (start-pump port proc)
  (declare (proper-tail-calls))
  (let ((size 1000))
    (let ((buffer (make-string size)))
      (let (iterate)
        (let ((n (read-substring buffer 0 size port 1)))
          (proc (if (> n 0)
                    (substring buffer 0 n)
                  ;; eof
                  #f))
          (iterate))))))


(definition public (write-32-bit-integer n port)
  (32-bit-integer->bytes n
    (lambda (b1 b2 b3 b4)
      (write-u8 b1 port)
      (write-u8 b2 port)
      (write-u8 b3 port)
      (write-u8 b4 port))))


(definition public (read-32-bit-integer port)
  (let* ((b1 (read-u8 port))
         (b2 (read-u8 port))
         (b3 (read-u8 port))
         (b4 (read-u8 port)))
    (if (eof-object? b4)
        b4
      (bytes->32-bit-integer b1 b2 b3 b4))))


(definition public (write-binary-content u8vect port)
  (let ((size (u8vector-length u8vect)))
    (write-32-bit-integer size port)
    (write-subu8vector u8vect 0 size port)
    (+ 4 size)))


(definition public (read-binary-content port)
  (let ((size (read-32-bit-integer port)))
    (if (eof-object? size)
        size
      (let ((u8vect (make-u8vector size)))
        (let ((read (read-subu8vector u8vect 0 size port)))
          (if (/= read size)
              (eof-object)
            u8vect))))))


(definition public (write-binary-object data port (encoder #f))
  (let ((u8vect (if encoder
                    (object->u8vector data encoder)
                  (object->u8vector data))))
    (let ((size (u8vector-length u8vect)))
      (write-32-bit-integer size port)
      (write-subu8vector u8vect 0 size port)
      (+ 4 size))))


(definition public (read-binary-object port (decoder #f))
  (let ((size (read-32-bit-integer port)))
    (if (eof-object? size)
        size
      (let ((u8vect (make-u8vector size)))
        (let ((read (read-subu8vector u8vect 0 size port)))
          (if (/= read size)
              (eof-object)
            (if decoder
                (u8vector->object u8vect decoder)
              (u8vector->object u8vect))))))))


(definition public (write-binary data port)
  (write-binary-object data port serialize))


(definition public (read-binary port)
  (read-binary-object port deserialize))


;;;
;;;; Input
;;;


(definition public (read-until test input)
  (declare (proper-tail-calls))
  (let ((queue (new-queue)))
    (let (iterate)
      (let ((expr (read input)))
        (if (test expr)
            (queue-list queue)
          (enqueue queue expr)
          (iterate))))))


(definition public (read-string-element string)
  (call-with-input-string string
    read))


(definition public (read-string-content string)
  (call-with-input-string string
    (lambda (input)
      (read-until eof-object? input))))


(definition public (readable-string? string)
  (with-exception-catcher
    (lambda (e) 
      #f)
    (lambda ()
      (with-readtable jazz-readtable 
        (lambda ()
          (read-string-element string)
          #t)))))


(definition public (read-string-safe string)
  (and (string? string) 
       (not (empty-string? string))
       (with-exception-catcher
         (lambda (e) 
           #f)
         (lambda ()
           (with-readtable jazz-readtable 
             (lambda () 
               (read-string-element string)))))))


(definition public (read-delimited-string string char)
  (declare (proper-tail-calls))
  (call-with-input-string string
    (lambda (input)
      (let ((fact (new List-Factory)))
        (let (iterate)
          (let ((lst (read-delimited input "delimited" char #t)))
            (put fact lst)
            (skip-whites input)
            (if (eof-object? (peek-char input))
                (get-output fact)
              (iterate))))))))


(definition public (require-char input)
  (let ((c (read-char input)))
    (if (eof-object? c)
        (error "Unexpected end of stream reached while reading")
      c)))


(definition public (skip-line input)
  (let (iterate)
    (let ((c (read-char input)))
      (if (and (not (eof-object? c))
               (not (eqv? c #\newline))
               (not (eqv? c #\return)))
          (iterate)
        (if (eqv? c #\return)
            (read-char input))))))


(definition public (skip-whites input)
  (let (iterate)
    (let ((c (peek-char input)))
      (unless (eof-object? c)
        (if (eqv? c #\;)
            (skip-line input)
          (when (whitespace? c)
            (read-char input)
            (iterate)))))))


(definition public (read-delimited input kind delimiter (allow-eof? #f))
  (let ((queue (new-queue))
        (delimiters (listify delimiter)))
    (let (iterate)
      (skip-whites input)
      (let ((c (peek-char input)))
        (cond ((eof-object? c)
               (if allow-eof?
                   (queue-list queue)
                 (error "Unexpected end of stream reached while reading {a}" kind)))
              ((memv? c delimiters)
               (read-char input)
               (queue-list queue))
              ((eqv? c #\.)
               (enqueue-list queue (read input))
               (iterate))
              (else
               (enqueue queue (read input))
               (iterate)))))))


(definition public inline (string-delimiter? c)
  (eqv? c #\double-quote))


(definition public (read-platform-line input)
  (let ((line (read-line input)))
    (if (eof-object? line)
        line
      (cond-expand
        (windows (remove-trailing #\return line))
        (else line)))))


(definition public (read-lines input)
  (declare (proper-tail-calls))
  (let ((queue (new-queue)))
    (let (iterate (last-proper? #t))
      (receive (line proper?) (read-proper-line input)
        (if line
            (begin
              (enqueue queue line)
              (iterate proper?))
          (when last-proper?
            (enqueue queue ""))
          (queue-list queue))))))


(definition public (read-lines-chunked input chunk-size proc)
  (declare (proper-tail-calls))
  (let (iterate (count 0) (queue (new-queue)) (last-proper? #t))
    (receive (line proper?) (read-proper-line input)
      (if line
          (begin
            (enqueue queue line)
            (let ((count (+ count 1)))
              (if (or (not chunk-size) (< count chunk-size))
                  (iterate count queue proper?)
                (proc (queue-list queue))
                (iterate 0 (new-queue) proper?))))
        (when last-proper?
          (enqueue queue ""))
        (when (or (> count 0) last-proper?)
          (proc (queue-list queue)))
        (unspecified)))))


(definition public (read-content-string input)
  ;; passing #f to gambit's read-line makes it never see an actual
  ;; end-of-line so that it will read the whole content as a string
  (let ((line (read-line input #f)))
    (if (eof-object? line)
        ""
      line)))


(definition public (pipe input output)
  (declare (proper-tail-calls))
  (let (iterate)
    (let ((c (read-char input)))
      (if (not (eof-object? c))
          (begin
            (write-char c output)
            (iterate))))))


;;;
;;;; Printer
;;;


(definition public (textual expr (output (current-output-port)))
  (write expr output)
  @wait-bug-fix-for-char-and-probably-others
  (print expr output :text))


(definition public (describe expr (output (current-output-port)))
  (print expr output :describe))


(definition public (fresh-line (output (current-output-port)))
  (unless (at-fresh-line? output)
    (newline output)))


(definition public (at-fresh-line? (output (current-output-port)))
  ;; todo
  #f)


;;;
;;;; Printers
;;;


(definition *printers* <table>
  (make-table test: eq?))


(definition package (register-printer name proc)
  (table-set! *printers* name proc))


(definition public (with-printer printer proc)
  (if (eq? printer :string)
      (let ((output (open-output-string)))
        (proc output)
        (get-output-string output))
    (proc
      (let ((printer-proc (table-ref *printers* printer #f)))
        (if printer-proc
            (printer-proc)
          printer)))))


(register-printer :terminal terminal-port)


;;;
;;;; Output
;;;


(definition public (present-reference reference)
  (define (present-identifier identifier)
    (let ((names (split (symbol->string identifier) ".")))
      (if (null? (cdr names))
          (car names)
        (let ((reversed (reverse! names)))
          (system-format "{a}.{a}" (element reversed 1) (element reversed 0))))))
  
  (receive (identifier referee) (break-reference reference)
    (if (not referee)
        (symbol->string identifier)
      (let ((referee-name (->string referee)))
        (if (string-find-reversed referee-name #\:)
            referee-name
          (system-format "{a}:{a}" (present-identifier identifier) referee-name))))))


(definition public (write-line line . rest)
  (let ((port (if (null? rest) #f (car rest))))
    (display line port)
    (newline port)))


(definition public (write-lines output lines)
  (loop (for line in lines remainder remain)
        (do (display line output)
            (unless (null? remain)
              (newline output)))))


;;;
;;;; Function
;;;


(definition public inline (do-nothing . rest)
  )


(definition public inline (identity x)
  x)


(definition public inline (const x)
  (lambda args x))


(definition public inline (compose f g)
  (lambda (x)
    (f (g x))))


(definition public (compose* . fns)
  (if (null? fns)
      identity
    (let ((f (car fns))
          (g (apply compose* (cdr fns))))
      (lambda (x)
        (f (g x))))))


;;;
;;;; Subseq
;;;


(class Subseq-Class extends Sequence-Class)


(class Subseq metaclass Subseq-Class extends Sequence
  
  
  (slot sequence      getter    generate)
  (slot start    <fx> accessors generate)
  (slot size     <fx> accessors generate)
  
  
  (method override (initialize self sequence start <fx> size <fx>)
    (nextmethod self)
    (set! self.sequence sequence)
    (set! self.start start)
    (set! self.size size))
  
  
  (method override (print self output detail)
    (if (string? sequence)
        ;; should take detail into account
        (loop (for n from start below (+ start size))
              (do (write-char (string-ref sequence n) output)))
      (print-unreadable self output
        (lambda (output)
          (system-format output "{s} {s} {s}" sequence start size)))))
  
  
  (method override (coerce-string self)
    (if (string? sequence)
        (substring sequence start (+ start size))
      (error "Cannot coerce sequence to string")))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element sequence (+ start n)))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! sequence (+ start n) obj))
  
  
  (method override (sequence-cardinality self) <int>
    size)
  
  
  (method override (sequence-subseq! self s <fx> e <fx>) <Subseq>
    (if (or (= s 0) (= e -1))
        self
      (new Subseq sequence (+ start s) (- (if (= e -1) (cardinality self) e) s)))))


(definition public inline (allocate-subseq sequence <string> start <fx> size <fx>) <Subseq>
  (allocate Subseq sequence start size))

(specialize inline (new class <category<Subseq>> sequence start size) <Subseq>
  (allocate-subseq sequence start size))


(definition public (offset-subseq! subseq <Subseq> offset <fx>) <void>
  (set-start subseq (+ (get-start subseq) offset)))


(definition public (grow-subseq! subseq <Subseq> n <fx>) <void>
  (set-size subseq (+ (get-size subseq) n)))


(specialize inline as subseq-ref (element subseq <Subseq> n) <object>
  (element (get-sequence subseq) (+ (get-start subseq) (cast <fx> n))))


(specialize inline as subseq-set! (set-element! subseq <Subseq> n obj) <void>
  (set-element! (get-sequence subseq) (+ (get-start subseq) (cast <fx> n)) obj))


(specialize inline as subseq-cardinality (cardinality subseq <Subseq>) <int>
  (get-size subseq))


;;;
;;;; Subseq$string$
;;;


(class Subseq$string$-Class extends Sequence-Class)


(class Subseq$string$ metaclass Subseq$string$-Class extends Sequence
  
  
  (slot sequence <string> getter    generate)
  (slot start    <fx>     accessors generate)
  (slot size     <fx>     accessors generate)
  
  
  (method override (initialize self sequence <string> start <fx> size <fx>)
    (nextmethod self)
    (set! self.sequence sequence)
    (set! self.start start)
    (set! self.size size))
  
  
  (method override (print self output detail)
    (let ((str (substring sequence start (+ start size))))
      (if (eq? detail :human)
          (print str output detail)
        (print-unreadable self output
          (lambda (output)
            (system-format output "{s}" str))))))
  
  
  (method public (print-content self output)
    (display (substring sequence start (+ start size)) output))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element sequence (+ start n)))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! sequence (+ start n) obj))
  
  
  (method override (sequence-cardinality self) <int>
    size)
  
  
  (method override (sequence-subseq! self s <fx> e <fx>) <Subseq$string$>
    (if (and (= s 0) (= e -1))
        self
      (new Subseq$string$ sequence (+ start s) (- (if (= e -1) (cardinality self) e) s)))))


(definition public inline (allocate-subseq$string$ sequence <string> start <fx> size <fx>) <Subseq$string$>
  (allocate Subseq$string$ sequence start size))

(specialize inline (new class <category<Subseq$string$>> sequence start size) <Subseq$string$>
  (allocate-subseq$string$ sequence start size))


(specialize inline (element subseq <Subseq$string$> n) <char>
  (element (get-sequence subseq) (+ (get-start subseq) (cast <fx> n))))


(specialize inline (set-element! subseq <Subseq$string$> n obj) <void>
  (set-element! (get-sequence subseq) (+ (get-start subseq) (cast <fx> n)) (cast <char> obj)))


(specialize inline (cardinality subseq <Subseq$string$>) <fx>
  (get-size subseq))


(specialize (subseq! seq <string> s e) <Subseq$string$>
  (let ((s (cast <fx> s))
        (e (cast <fx> e)))
    (new Subseq$string$ seq s (- e s))))


(specialize (subseq! subseq <Subseq$string$> s e) <Subseq$string$>
  (let ((s (cast <fx> s))
        (e (cast <fx> e)))
    (new Subseq$string$ (get-sequence subseq) (+ (get-start subseq) s) (- e s))))


(specialize (offset-subseq! subseq <Subseq$string$> offset) <void>
  (set-start subseq (+ (get-start subseq) (cast <fx> offset))))


(specialize (grow-subseq! subseq <Subseq$string$> n) <void>
  (set-size subseq (+ (get-size subseq) (cast <fx> n))))


;;;
;;;; Values
;;;


(definition public (values->list values)
  (call-with-values (lambda () values) list))


;;;
;;;; Capabilities
;;;


(definition protected capabilities
  (make-table test: eq?))


(definition public (get-capability capability (default-value #f))
  (table-ref capabilities capability default-value))

(definition public (set-capability capability value)
  (table-set! capabilities capability value))


;;;
;;;; Site
;;;


(definition protected siteids <vector>
  (make-vector 256 #f))


(definition public inline (id->site id <fx>) <Call-Site>
  (vector-ref siteids id))


(definition next-site-id <fx>
  0)

(definition (next-site-id!) <fx>
  (prog1 next-site-id
    (increase! next-site-id)))

(definition protected (site-id-count) <fx>
  next-site-id)


(definition call-sites <table>
  (make-table test: eq?))


(definition public (registered-sites)
  call-sites)

(definition public (registered-site name) <Call-Site>
  (table-ref call-sites name))

(definition public (find-site name) <Call-Site+>
  (table-ref call-sites name #f))

(definition public (register-site name properties)
  (or (table-ref call-sites name #f)
      (let ((id (next-site-id!)))
        (let ((site (new-call-site name id properties (lambda (site thunk) (thunk)))))
          (vector-set! siteids id site)
          (table-set! call-sites name site)
          (when site-callback
            (site-callback site))
          site))))


(definition site-callback
  #f)

(definition public (get-site-callback)
  site-callback)

(definition public (set-site-callback callback)
  (set! site-callback callback))


(definition public (call-site-ref name)
  (get-procedure (registered-site name)))

(definition public (call-site-set! name value)
  (set-procedure (registered-site name) value))


;;;
;;;; Format
;;;


(proclaim (warn optimizations))


;;;
;;;; Lexicon
;;;


;; (format "{a width: 10 justify: :right} {l}" 5 lst)

;; In the preceding format :
;;   directives -> {a} and {l}
;;   parameters -> width: 10 justify: :right
;;   arguments  -> 5 and lst


;;;
;;;; Format
;;;


(definition public (format . rest)
  
  (declare (proper-tail-calls))
  
  (define (process-format destination control-string arguments out control-reader arguments-scan)
    
    ;;;
    ;;;; Process
    ;;;
    
    (define (process input context output?)
      (let ((done? #f))
        (while (not done?)
          (let ((c (read-char input)))
            (if (eof-object? c)
                (set! done? #t)
              (case c
                ((#\~)
                 (let ((c (require-char input)))
                   (when output?
                     (write-char c out))))
                ((#\{)
                 (if context
                     (let ((parameters (read-parameters input)))
                       (assert (not-null? parameters)
                         (let ((name (car parameters)))
                           (cond ((noarg-letter->directive name)
                                  => (lambda (directive)
                                       (let ((parameters (cdr parameters)))
                                         (dispatch-directive directive parameters output?))))
                                 ((enumerator? name)
                                  (let ((name (enumerator->symbol name)))
                                    (let ((directive (name->directive name))
                                          (parameters (cdr parameters)))
                                      (dispatch-directive directive parameters output?))))
                                 (else
                                  (let ((binding (assv name context)))
                                    (if binding
                                        (let ((value (cdr binding))
                                              (parameters (cdr parameters)))
                                          (add-argument value)
                                          (if (null? parameters)
                                              (dispatch-directive #\a parameters output?)
                                            (let ((directive (name->directive (enumerator->symbol (car parameters))))
                                                  (parameters (cdr parameters)))
                                              (dispatch-directive directive parameters output?))))
                                      (error "Unable to find binding: {s}" name))))))))
                   (let ((c (peek-char input)))
                     (case c
                       ((#\?)
                        (if (not output?)
                            (error "Recursive conditional directive not yet supported")
                          (read-char input)
                          (conditional-directive input context)))
                       ((#\^)
                        (read-char input)
                        (context-directive input))
                       (else
                        (let ((directive (read-char input))
                              (parameters (read-parameters input)))
                          (if (eqv? directive #\:)
                              (assert (not-null? parameters)
                                (bind (name . parameters) parameters
                                  (dispatch-directive (name->directive name) parameters output?)))
                            (dispatch-directive directive parameters output?))))))))
                (else
                 (when output?
                   (write-char c out))))))))
      (when (and (toplevel? input) (not (arguments-empty?)))
        (error "Too many format arguments")))
    
    (define (dispatch-directive directive parameters output?)
      (case directive
        ((#\a) (display-directive parameters output?))
        ((#\s) (write-directive parameters output?))
        ((#\t) (text-directive parameters output?))
        ((#\p) (print-directive parameters output?))
        ((#\c) (char-directive parameters output?))
        ((#\u) (unsigned-directive parameters output?))
        ((#\b) (binary-directive parameters output?))
        ((#\x) (hexadecimal-directive parameters output?))
        ((#\r) (real-directive parameters output?))
        ((#\l) (list-directive parameters output?))
        ((#\k) (properties-directive parameters output?))
        ((#\_) (column-directive parameters output?))
        ((#\&) (tab-directive parameters output?))
        ((#\%) (newline-directive parameters output?))
        ((#\$) (freshline-directive parameters output?))
        ((#\!) (force-directive parameters output?))
        (else (error "Unknown format directive {a}" directive))))
    
    (define (noarg-letter->directive letter)
      (case letter
        ((_) #\_)
        ((&) #\&)
        ((%) #\%)
        (($) #\$)
        ((!) #\!)
        (else #f)))
    
    (define (name->directive name)
      (case name
        ((display)     #\a)
        ((write)       #\s)
        ((text)        #\t)
        ((print)       #\p)
        ((char)        #\c)
        ((unsigned)    #\u)
        ((binary)      #\b)
        ((hexadecimal) #\x)
        ((real)        #\r)
        ((list)        #\l)
        ((properties)  #\k)
        ((column)      #\_)
        ((tab)         #\&)
        ((newline)     #\%)
        ((freshline)   #\$)
        ((force)       #\!)))
    
    (define (read-parameters input)
      (read-delimited input "format parameter" #\}))
    
    (define (toplevel? input)
      (eq? input control-reader))
    
    (define (arguments-empty?)
      (null? arguments-scan))
    
    ;;;
    ;;;; Conditional
    ;;;
    
    (define (conditional-directive input context)
      (cond ((eqv? (peek-char input) #\:)
             (read-char input)
             (process-conditional input context #t))
            (else
             (process-conditional input context #f))))
    
    (define (process-conditional input context explicit?)
      (let ((subreader (open-input-string (read-control-string input)))
            (output? (or (and explicit? (next-argument)) (and (not explicit?) (peek-argument)))))
        (process subreader context output?)))
    
    ;;;
    ;;;; Context
    ;;;
    
    (define (context-directive input)
      (cond ((eqv? (peek-char input) #\:)
             (read-char input)
             (process-context input (next-argument))
             (read-char input)
             (read-char input))
            (else
             (process-context input (read-control-string input)))))
    
    (define (process-context input substr)
      (let ((subreader (open-input-string substr))
            (context (next-argument)))
        (process subreader context #t)))
    
    ;;;
    ;;;; Control
    ;;;
    
    (define (read-control-string input)
      (let ((output (open-output-string))
            (done? #f))
        (while (not done?)
          (let ((c (require-char input)))
            (if (and (eqv? c #\~) (eqv? (peek-char input) #\}))
                (begin
                  (read-char input)
                  (set! done? #t))
              (write-char c output))))
        (get-output-string output)))
    
    ;;;
    ;;;; Directives
    ;;;
    
    (define (display-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (display argument output))))))
    
    (define (write-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (write argument output))))))
    
    (define (text-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (textual argument output))))))
    
    (define (print-directive parameters output?)
      (let ((argument (next-argument))
            (detail (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-expr argument detail output))))))
    
    (define (char-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (write-char argument output))))))
    
    (define (unsigned-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-unsigned argument output))))))
    
    (define (binary-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-binary argument output))))))
    
    (define (hexadecimal-directive parameters output?)
      (let ((argument (next-argument)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-hexadecimal argument output))))))
    
    (define (real-directive parameters output?)
      (let ((argument (next-argument))
            (precision (get-precision parameters)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-real argument precision output))))))
    
    (define (list-directive parameters output?)
      (let* ((argument (next-argument))
             (separator (get-separator parameters))
             (last-separator (get-last-separator parameters separator))
             (before (get-before parameters))
             (after (get-after parameters))
             (detail (get-detail parameters)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (print-list argument separator last-separator before after detail output))))))
    
    (define (properties-directive parameters output?)
      (let ((argument (next-argument))
            (properties (get-properties parameters))
            (empty-value (get-empty-value parameters))
            (detail (get-detail parameters)))
        (when output?
          (with-justification parameters
            (lambda (output)
              (let ((scan argument))
                (while (not-null? scan)
                  (let ((key (car scan))
                        (value (cadr scan)))
                    (when (and (or (null? properties) (memq key properties))
                               (or (unspecified? empty-value) (neq? value empty-value)))
                      (write-char #\space output)
                      (print-expr key detail output)
                      (write-char #\space output)
                      (print-expr value detail output)))
                  (set! scan (cddr scan)))))))))
    
    (define (column-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (write-char #\space out))))))
    
    (define (tab-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (write-char #\tab out))))))
    
    (define (newline-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (loop (repeat count)
                (do (newline out))))))
    
    (define (freshline-directive parameters output?)
      (when output?
        (let ((count (optional-parameter parameters 1)))
          (fresh-line out)
          (loop (repeat (- count 1))
                (do (newline out))))))
    
    (define (force-directive parameters output?)
      (when output?
        (force-output out)))
    
    ;;;
    ;;;; Justification
    ;;;
    
    (define (with-justification parameters proc)
      (let ((width (get-width parameters)))
        (if (not width)
            (proc out)
          (let ((justification (get-justify parameters))
                (padding (get-padding parameters))
                (output (open-output-string)))
            (proc output)
            (let ((buffer (get-output-string output)))
              (justify buffer width justification padding))))))
    
    (define (justify buffer width justification padding)
      (let ((size (cardinality buffer)))
        (if (>= size width)
            (display buffer out)
          (let ((n (- width size)))
            (case justification
              ((:left)
               (display buffer out)
               (loop (repeat n)
                     (do (write-char padding out))))
              ((:right)
               (loop (repeat n)
                     (do (write-char padding out)))
               (display buffer out)))))))
    
    ;;;
    ;;;; Parameters
    ;;;
    
    (define (optional-parameter parameters default)
      (if (null? parameters)
          default
        (let ((param (car parameters)))
          (if (eq? param :v)
              (next-argument)
            param))))
    
    (define (keyword-parameter parameters keyword default)
      (let ((param (getf parameters keyword not-found: default)))
        (if (eq? param :v)
            (next-argument)
          param)))
    
    (define (get-list? parameters)
      (keyword-parameter parameters list?: #f))
    
    (define (get-width parameters)
      (keyword-parameter parameters width: #f))
    
    (define (get-justify parameters)
      (let ((param (keyword-parameter parameters justify: :left)))
        (if (not (memq param '(:left :right)))
            (error "Unknown justification {t}" param)
          param)))
    
    (define (get-padding parameters)
      (keyword-parameter parameters padding: #\space))
    
    (define (get-separator parameters)
      (keyword-parameter parameters separator: " "))
    
    (define (get-last-separator parameters separator)
      (keyword-parameter parameters last-separator: separator))
    
    (define (get-before parameters)
      (keyword-parameter parameters before: #f))
    
    (define (get-after parameters)
      (keyword-parameter parameters after: #f))
    
    (define (get-precision parameters)
      (keyword-parameter parameters precision: 3))
    
    (define (get-properties parameters)
      (keyword-parameter parameters properties: '()))
    
    (define (get-empty-value parameters)
      (keyword-parameter parameters empty-value: (unspecified)))
    
    (define (get-detail parameters)
      (keyword-parameter parameters detail: :reader))
    
    ;;;
    ;;;; Arguments
    ;;;
    
    (define (peek-argument)
      (if (null? arguments-scan)
          (error "Not enough format arguments for {t}" control-string)
        (car arguments-scan)))
    
    (define (next-argument)
      (if (null? arguments-scan)
          (error "Not enough format arguments for {t}" control-string)
        (prog1 (car arguments-scan)
          (set! arguments-scan (cdr arguments-scan)))))
    
    (define (add-argument arg)
      (set! arguments-scan (cons arg arguments-scan)))
    
    (process control-reader #f #t))
  
  (define (parse-format proc)
    (if (string? (car rest))
        (proc :string (car rest) (cdr rest))
      (proc (car rest) (cadr rest) (cddr rest))))
  
  (parse-format
    (lambda (destination control-string <string> arguments <list>)
      (with-printer destination
        (lambda (output)
          (process-format destination control-string arguments output (open-input-string control-string) arguments))))))


;;;
;;;; Formatting
;;;


(definition public (format-cardinality n <fx>)
  (if (= n 0)
      "no"
    (->string n)))


(definition public (format-plural n <fx> (plural "s"))
  (if (= n 1)
      ""
    plural))


(definition public (format-gender word)
  (if (vowel? (first word))
      "an"
    "a"))


(definition public (format-is/are n <fx>)
  (if (= n 1)
      "is"
    "are"))


(definition public (format-was/were n <fx>)
  (if (= n 1)
      "was"
    "were"))


(definition public (format-y/ies n <fx>)
  (if (= n 1)
      "y"
    "ies"))


(definition public (format-following name n <fx>)
  (if (= n 1)
      (format "{a} was" name)
    (format "{a} {a}s where" n name)))


;;;
;;;; Printing
;;;


(definition (print-expr expr detail (output (current-output-port)))
  (print-detail expr output detail))


(definition (print-unsigned n (output (current-output-port)))
  (unimplemented 'print-unsigned))


(definition (print-binary n (output (current-output-port)))
  (display (number->string n 2) output))


(definition (print-hexadecimal n (output (current-output-port)))
  (display (number->string n 16) output))


(definition (print-real r d (output (current-output-port)))
  (if (not (finite? r))
      (display r output)
    (let ((n (inexact->exact (round (* (abs r) (expt 10 d))))))
      (let ((i (quotient n (expt 10 d)))
            (f (modulo n (expt 10 d))))
        (let ((si (string-append
                    (if (< r 0) "-" "")
                    (if (and (= i 0) (> d 0)) "" (number->string i 10))))
              (sf (number->string (+ f (expt 10 d)) 10)))
          (if (> d 0)
              (string-set! sf 0 #\.)
            (set! sf ""))
          (let ((lsi (string-length si))
                (lsf (string-length sf)))
            (display si output)
            (display sf output)))))))


(definition (print-list list separator last-separator before after detail (output (current-output-port)))
  (when (not-null? list)
    (when before
      (display before output))
    (let (iter (scan list))
      (let ((expr (car scan)))
        (print-detail expr output detail)
        (let ((next (cdr scan)))
          (when (not-null? next)
            (if (pair? next)
                (begin
                  (display (if (null? (cdr next)) last-separator separator) output)
                  (iter next))
              (display " . " output)
              (print-detail next output detail))))))
    (when after
      (display after output))))


;;;
;;;; Geometry
;;;


(proclaim (warn optimizations))


;;;
;;;; Cell
;;;


(class Cell extends Numeric
  
  
  (state ()
    (slot line <fx> accessors generate)
    (slot col  <fx> accessors generate))
  
  
  (method override (initialize self l <fx> c <fx>)
    (set! line l)
    (set! col c))
  
  
  (method override (copy-object self deep?)
    (new Cell line col))


  (method override (compare-object self target)
    (if (is-not? target Cell)
        :incompatible
      (let ((compared (compare line (get-line target))))
        (if (not (eq? compared :equal))
            compared
          (compare col (get-col target))))))


  (method override (di-compare-object self target)
    (if (is-not? target Cell)
        :incompatible
      (let ((compared (di-compare line (get-line target))))
        (if (not (eq? compared :equal))
            compared
          (di-compare col (get-col target))))))
  
  
  (method override (print self output readably)
    (format output "~{{a} {a} {a}}"
            (category-name (class-of self))
            line
            col))


  (method override (numeric-norm self)
    (error "Cannot norm {t}" self))


  (method override (numeric-add self n)
    (cond ((is? n Cell) (new Cell (+ line (get-line n)) (+ col (get-col n))))
          ((integer? n) (new Cell line (+ col n)))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Cell (- line) (- col)))


  (method override (numeric-multiply self n)
    (if (integer? n)
        (new Cell (* line n) (* col n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self))
  
  
  (method public (increase-line self (delta <fx> 1))
    (set! line (+ line delta)))
  
  
  (method public (increase-col self (delta <fx> 1))
    (set! col (+ col delta))))


(definition public inline (allocate-cell line <fx> col <fx>) <Cell>
  (allocate Cell line col))

(specialize inline (new class <category<Cell>> line col) <Cell>
  (allocate-cell line col))


(specialize inline as copy-cell (copy c <Cell>) <Cell>
  (new Cell (get-line c) (get-col c)))


(specialize inline as cell=? (= c1 <Cell> c2 <Cell>) <bool>
  (and (= (get-line c1) (get-line c2))
       (= (get-col c1) (get-col c2))))


(specialize as cell<? (< c1 <Cell> c2 <Cell>) <bool>
  (let ((l1 (get-line c1))
        (l2 (get-line c2)))
    (or (< l1 l2)
        (and (= l1 l2)
             (< (get-col c1) (get-col c2))))))


(specialize as cell<=? (<= c1 <Cell> c2 <Cell>) <bool>
  (let ((l1 (get-line c1))
        (l2 (get-line c2)))
    (or (< l1 l2)
        (and (= l1 l2)
             (<= (get-col c1) (get-col c2))))))


(specialize as cell>? (> c1 <Cell> c2 <Cell>) <bool>
  (let ((l1 (get-line c1))
        (l2 (get-line c2)))
    (or (> l1 l2)
        (and (= l1 l2)
             (> (get-col c1) (get-col c2))))))


(specialize as cell>=? (>= c1 <Cell> c2 <Cell>) <bool>
  (let ((l1 (get-line c1))
        (l2 (get-line c2)))
    (or (> l1 l2)
        (and (= l1 l2)
             (>= (get-col c1) (get-col c2))))))


(specialize inline as cell+ (+ c1 <Cell> c2 <Cell>) <Cell>
  (new Cell
    (+ (get-line c1) (get-line c2))
    (+ (get-col c1) (get-col c2))))


(specialize inline (+ c <Cell> n <int>) <Cell>
  (new Cell
    (get-line c)
    (+ (get-col c) n)))


(specialize inline as cell- (- c1 <Cell> c2 <Cell>) <Cell>
  (new Cell
    (- (get-line c1) (get-line c2))
    (- (get-col c1) (get-col c2))))


(specialize inline (- c <Cell> n <int>) <Cell>
  (new Cell
    (get-line c)
    (- (get-col c) n)))


(definition public (cell-hash c <Cell>)
  (fxwrap+ (eqv?-hash (get-line c))
           (eqv?-hash (get-col c))))


;;;
;;;; Range
;;;


(class Range extends Object
  
  
  (state ()
    (slot start)
    (slot end))
    
    
  (method override (initialize self s e)
    (nextmethod self)
    (set! start s)
    (set! end e))
  
  
  (method override (copy-object self deep?)
    (new Range start end))


  (method override (compare-object self target)
    (cond ((is-not? target Range)
           :incompatible)
          ((and (= start (get-start target)) (= end (get-end target)))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{{a} {s} {s}}"
            (category-name (class-of self))
            start
            end))
  
  
  (method public inline (get-start self)
    start)
  
  
  (method public inline (get-end self)
    end)
  
  
  (method public virtual (extent self)
    (- end start))
  
  
  (method public virtual (extended? self)
    (not (= start end)))
  
  
  (method public virtual (empty? self)
    (= start end))
  
  
  (method public (inside? self n)
    (and (>= n start)
         (< n end)))


  (method public (before? self n)
    (< n start))


  (method public (after? self n)
    (> n end))
  
  
  (method public (intersect? self range)
    (and (< (get-start range) end)
         (>= (get-end range) start)))


  (method public (intersect self range)
    (when (intersect? self range)
      (new (class-of self) (max start (get-start range)) (min end (get-end range))))))


(definition public inline (allocate-range start end) <Range>
  (allocate Range start end))

(specialize inline (new class <category<Range>> start end) <Range>
  (allocate-range start end))


(specialize inline as range=? (= r1 <Range> r2 <Range>) <bool>
  (and (= (get-start r1) (get-start r2))
       (= (get-end r1) (get-end r2))))


;;;
;;;; Range$Cell$
;;;


(class Range$Cell$ extends Object
  
  
  (state ()
    (slot start <Cell> getter generate)
    (slot end   <Cell> getter generate))
  
  
  (method override (initialize self s <Cell> e <Cell>)
    (nextmethod self)
    (set! start s)
    (set! end e))
  
  
  (method override (copy-object self deep?)
    (new Range$Cell$ start end))


  (method override (compare-object self target)
    (cond ((is-not? target Range$Cell$)
           :incompatible)
          ((and (= start (get-start target)) (= end (get-end target)))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{{a} {s} {s}}"
            (category-name (class-of self))
            start
            end))
  
  
  (method public virtual (extent self) <Cell>
    (- end start))
  
  
  (method public virtual (extended? self)
    (not (= start end)))
  
  
  (method public virtual (empty? self)
    (= start end))
  
  
  (method public (inside? self n <Cell>) <bool>
    (and (>= n start)
         (< n end)))


  (method public (before? self n <Cell>) <bool>
    (< n start))


  (method public (after? self n <Cell>) <bool>
    (> n end))
  
  
  (method public (intersect? self range <Range$Cell$>) <bool>
    (and (< (get-start range) end)
         (>= (get-end range) start)))


  (method public (intersect self range <Range$Cell$>)
    (when (intersect? self range)
      (new (class-of self) (max start (get-start range)) (min end (get-end range))))))


(definition public inline (allocate-range$Cell$ start <Cell> end <Cell>) <Range$Cell$>
  (allocate Range$Cell$ start end))

(specialize inline (new class <category<Range$Cell$>> start end) <Range$Cell$>
  (allocate-range$Cell$ start end))


(specialize inline (= r1 <Range$Cell$> r2 <Range$Cell$>) <bool>
  (and (= (get-start r1) (get-start r2))
       (= (get-end r1) (get-end r2))))


;;;
;;;; Point
;;;


(class Point extends Numeric
  
  
  (state ()
    (slot h <fx> getter generate)
    (slot v <fx> getter generate))
  
  
  (method override (initialize self h <fx> v <fx>)
    (nextmethod self)
    (set! self.h h)
    (set! self.v v))
  
  
  (method override (copy-object self deep?)
    (new Point h v))


  (method override (compare-object self target)
    (cond ((is-not? target Point)
           :incompatible)
          ((let ((target-point <Point> target))
             (and (= h (get-h target-point)) (= v (get-v target-point))))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{Point {a} {a}}"
            h
            v))
  
  
  (method override (numeric-norm self)
    (sqrt (+ (expt h 2) (expt v 2))))


  (method override (numeric-add self n)
    (cond ((is? n Point) (new Point (+ h (get-h n)) (+ v (get-v n))))
          ((is? n Distance) (new Point (+ h (get-x n)) (+ v (get-y n))))
          ((is? n Dimension) (new Point (+ h (get-width n)) (+ v (get-height n))))
          ((integer? n) (new Point (+ h n) v))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Point (- h) (- v)))


  (method override (numeric-multiply self n)
    (if (integer? n)
        (new Point (* h n) (* v n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self)))


(definition public inline (allocate-point h <fx> v <fx>) <Point>
  (allocate Point h v))

(specialize inline (new class <category<Point>> h v) <Point>
  (allocate-point h v))


(specialize inline as point=? (= p1 <Point> p2 <Point>) <bool>
  (and (= (get-h p1) (get-h p2))
       (= (get-v p1) (get-v p2))))


(specialize inline as point+ (+ p1 <Point> p2 <Point>) <Point>
  (new Point
    (+ (get-h p1) (get-h p2))
    (+ (get-v p1) (get-v p2))))


(specialize inline (+ p <Point> n <int>) <Point>
  (new Point
    (+ (get-h p) n)
    (get-v p)))


(specialize inline as point- (- p1 <Point> p2 <Point>) <Point>
  (new Point
    (- (get-h p1) (get-h p2))
    (- (get-v p1) (get-v p2))))


(specialize inline (- p <Point> n <int>) <Point>
  (new Point
    (- (get-h p) n)
    (get-v p)))


(specialize inline (- p <Point>) <Point>
  (new Point
    (- (get-h p))
    (- (get-v p))))


(specialize inline as point* (* p <Point> n <int>) <Point>
  (new Point
    (* (get-h p) n)
    (* (get-v p) n)))


;;;
;;;; Point$fl$
;;;


(class Point$fl$ extends Numeric
  
  
  (state ()
    (slot h <fl> getter generate)
    (slot v <fl> getter generate))
  
  
  (method override (initialize self h <fl> v <fl>)
    (nextmethod self)
    (set! self.h h)
    (set! self.v v))
  
  
  (method override (copy-object self deep?)
    (new Point$fl$ h v))


  (method override (compare-object self target)
    (cond ((is-not? target Point$fl$)
           :incompatible)
          ((let ((target-point <Point$fl$> target))
             (and (= h (get-h target-point)) (= v (get-v target-point))))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{Point$fl$ {a} {a}}"
            h
            v))
  
  
  (method override (numeric-norm self)
    (sqrt (+ (expt h 2) (expt v 2))))


  (method override (numeric-add self n)
    (cond ((is? n Point$fl$) (new Point$fl$ (+ h (get-h n)) (+ v (get-v n))))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Point$fl$ (- h) (- v)))


  (method override (numeric-multiply self n)
    (if (real? n)
        (new Point$fl$ (* h n) (* v n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self)))


;;;
;;;; Distance
;;;


(class Distance extends Numeric
  
  
  (state ()
    (slot x <fx> getter generate)
    (slot y <fx> getter generate))
  
  
  (method override (initialize self x <fx> y <fx>)
    (nextmethod self)
    (set! self.x x)
    (set! self.y y))
  
  
  (method override (copy-object self deep?)
    (new Distance x y))


  (method override (compare-object self target)
    (if (is-not? target Distance)
        :incompatible
      (let ((compared (compare x (get-x target))))
        (if (neq? compared :equal)
            compared
          (compare y (get-y target))))))
  
  
  (method override (print self output readably)
    (format output "~{Distance {a} {a}}"
            x
            y))


  (method override (numeric-norm self)
    (error "Cannot norm {t}" self))


  (method override (numeric-add self n)
    (cond ((is? n Distance) (new Distance (+ x (get-x n)) (+ y (get-y n))))
          ((is? n Point) (new Distance (+ x (get-h n)) (+ y (get-v n))))
          ((integer? n) (new Distance (+ x n) y))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Distance (- x) (- y)))


  (method override (numeric-multiply self n)
    (if (integer? n)
        (new Distance (* x n) (* y n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self)))


(definition public inline (allocate-distance x <fx> y <fx>) <Distance>
  (allocate Distance x y))

(specialize inline (new class <category<Distance>> x y) <Distance>
  (allocate-distance x y))


(specialize inline as distance=? (= d1 <Distance> d2 <Distance>) <bool>
  (and (= (get-x d1) (get-x d2))
       (= (get-y d1) (get-y d2))))


(specialize inline as distance+ (+ d1 <Distance> d2 <Distance>) <Distance>
  (new Distance
    (+ (get-x d1) (get-x d2))
    (+ (get-y d1) (get-y d2))))


(specialize inline as distance- (- d1 <Distance> d2 <Distance>) <Distance>
  (new Distance
    (- (get-x d1) (get-x d2))
    (- (get-y d1) (get-y d2))))


(specialize inline (- d <Distance>) <Distance>
  (new Distance
    (- (get-x d))
    (- (get-y d))))


(specialize inline as distance* (* d <Distance> n <int>) <Distance>
  (new Distance
    (* (get-x d) n)
    (* (get-y d) n)))


(definition public (distance-min d1 <Distance> d2 <Distance>) <Distance>
  (new Distance
    (min (get-x d1) (get-x d2))
    (min (get-y d1) (get-y d2))))


(definition public (distance-max d1 <Distance> d2 <Distance>) <Distance>
  (new Distance
    (max (get-x d1) (get-x d2))
    (max (get-y d1) (get-y d2))))


;;;
;;;; Dimension
;;;


(class Dimension extends Numeric
  
  
  (state ()
    (slot width  <fx> getter generate)
    (slot height <fx> getter generate))
  
  
  (method override (initialize self w <fx> h <fx>)
    (nextmethod self)
    (set! width w)
    (set! height h))
  
  
  (method override (copy-object self deep?)
    (new Dimension width height))


  (method override (compare-object self target)
    (if (is-not? target Dimension)
        :incompatible
      (let ((compared (compare width (get-width target))))
        (if (neq? compared :equal)
            compared
          (compare height (get-height target))))))
  
  
  (method override (print self output readably)
    (format output "~{Dimension {a} {a}}"
            width
            height))


  (method override (numeric-norm self)
    (error "Cannot norm {t}" self))


  (method override (numeric-add self n)
    (cond ((is? n Dimension) (new Dimension (+ width (get-width n)) (+ height (get-height n))))
          ((is? n Point) (new Dimension (+ width (get-h n)) (+ height (get-v n))))
          ((integer? n) (new Dimension (+ width n) height))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Dimension (- width) (- height)))


  (method override (numeric-multiply self n)
    (if (integer? n)
        (new Dimension (* width n) (* height n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self)))


(definition public inline (allocate-dimension width <fx> height <fx>) <Dimension>
  (allocate Dimension width height))

(specialize inline (new class <category<Dimension>> width height) <Dimension>
  (allocate-dimension width height))


(specialize inline as dimension=? (= d1 <Dimension> d2 <Dimension>) <bool>
  (and (= (get-width d1) (get-width d2))
       (= (get-height d1) (get-height d2))))


(specialize inline as dimension+ (+ d1 <Dimension> d2 <Dimension>) <Dimension>
  (new Dimension
    (+ (get-width d1) (get-width d2))
    (+ (get-height d1) (get-height d2))))


(specialize inline as dimension- (- d1 <Dimension> d2 <Dimension>) <Dimension>
  (new Dimension
    (- (get-width d1) (get-width d2))
    (- (get-height d1) (get-height d2))))


(specialize inline as dimension* (* d <Dimension> n <int>) <Dimension>
  (new Dimension
    (* (get-width d) n)
    (* (get-height d) n)))


(definition public (dimension-min d1 <Dimension> d2 <Dimension>) <Dimension>
  (new Dimension
    (min (get-width d1) (get-width d2))
    (min (get-height d1) (get-height d2))))


(definition public (dimension-max d1 <Dimension> d2 <Dimension>) <Dimension>
  (new Dimension
    (max (get-width d1) (get-width d2))
    (max (get-height d1) (get-height d2))))


;;;
;;;; Dimension$fl$
;;;


(class Dimension$fl$ extends Numeric
  
  
  (state ()
    (slot width  <fl> getter generate)
    (slot height <fl> getter generate))
  
  
  (method override (initialize self w <fl> h <fl>)
    (nextmethod self)
    (set! width w)
    (set! height h))
  
  
  (method override (copy-object self deep?)
    (new Dimension$fl$ width height))


  (method override (compare-object self target)
    (if (is-not? target Dimension$fl$)
        :incompatible
      (let ((compared (compare width (get-width target))))
        (if (neq? compared :equal)
            compared
          (compare height (get-height target))))))
  
  
  (method override (print self output readably)
    (format output "~{Dimension$fl$ {a} {a}}"
            width
            height))


  (method override (numeric-norm self)
    (error "Cannot norm {t}" self))


  (method override (numeric-add self n)
    (cond ((is? n Dimension$fl$) (new Dimension$fl$ (+ width (get-width n)) (+ height (get-height n))))
          ((is? n Point$fl$) (new Dimension$fl$ (+ width (get-h n)) (+ height (get-v n))))
          ((flonum? n) (new Dimension$fl$ (+ width n) height))
          (else (error "Cannot add {t} to {t}" n self))))


  (method override (numeric-negate self)
    (new Dimension$fl$ (- width) (- height)))


  (method override (numeric-multiply self n)
    (if (flonum? n)
        (new Dimension$fl$ (* width n) (* height n))
      (error "Cannot multiply {t} to {t}" n self)))


  (method override (numeric-inverse self)
    (error "Cannot inverse {t}" self)))


;;;
;;;; Rect
;;;


(class Rect extends Object
  
  
  (state ()
    (slot left   <fx> accessors generate)
    (slot top    <fx> accessors generate)
    (slot right  <fx> accessors generate)
    (slot bottom <fx> accessors generate))
  
  
  (method meta override (coerce-object self object)
    (typecase object
      ((Point) (new Rect (get-h object) (get-v object) 0 0))
      (else (nextmethod self object))))
  
  
  (method override (initialize self l <fx> t <fx> r <fx> b <fx>)
    (nextmethod self)
    (set! left l)
    (set! top t)
    (set! right r)
    (set! bottom b))
  
  
  (method override (copy-object self deep?)
    (new Rect left top right bottom))


  (method override (compare-object self target)
    (cond ((is-not? target Rect)
           :incompatible)
          ((and (= left (get-left target)) (= top (get-top target)) (= right (get-right target)) (= bottom (get-bottom target)))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{{a} {a} {a} {a} {a}}"
            (category-name (class-of self))
            left
            top
            right
            bottom)))


(definition public inline (rect? obj)
  (is? obj Rect))


(definition public inline (allocate-rect left <fx> top <fx> right <fx> bottom <fx>) <Rect>
  (allocate Rect left top right bottom))

(specialize inline (new class <category<Rect>> left top right bottom) <Rect>
  (allocate-rect left top right bottom))


(specialize inline as rect=? (= r1 <Rect> r2 <Rect>) <bool>
  (and (= (get-left r1) (get-left r2))
       (= (get-top r1) (get-top r2))
       (= (get-right r1) (get-right r2))
       (= (get-bottom r1) (get-bottom r2))))


(definition public inline (empty-rect? rect)
  (and (= (get-left rect) 0)
       (= (get-top rect) 0)
       (= (get-right rect) 0)
       (= (get-bottom rect) 0)))


(definition public inline (empty-rect$fl$? rect)
  (and (= (get-left rect) 0.)
       (= (get-top rect) 0.)
       (= (get-right rect) 0.)
       (= (get-bottom rect) 0.)))


;;;
;;;; Rect$fl$
;;;


(class Rect$fl$ extends Object
  
  
  (state ()
    (slot left   <fl> accessors generate)
    (slot top    <fl> accessors generate)
    (slot right  <fl> accessors generate)
    (slot bottom <fl> accessors generate))
  
  
  (method meta override (coerce-object self object)
    (typecase object
      ((Point) (new Rect$fl$ (get-h object) (get-v object) 0 0))
      (else (nextmethod self object))))
  
  
  (method override (initialize self l <fl> t <fl> r <fl> b <fl>)
    (nextmethod self)
    (set! left l)
    (set! top t)
    (set! right r)
    (set! bottom b))
  
  
  (method override (copy-object self deep?)
    (new Rect$fl$ left top right bottom))


  (method override (compare-object self target)
    (cond ((is-not? target Rect$fl$)
           :incompatible)
          ((and (= left (get-left target)) (= top (get-top target)) (= right (get-right target)) (= bottom (get-bottom target)))
           :equal)
          (else
           :not-equal)))
  
  
  (method override (print self output readably)
    (format output "~{{a} {a} {a} {a} {a}}"
            (category-name (class-of self))
            left
            top
            right
            bottom)))


(definition public inline (rect$fl$? obj)
  (is? obj Rect$fl$))


(definition public inline (allocate-rect$fl$ left <fl> top <fl> right <fl> bottom <fl>) <Rect$fl$>
  (allocate Rect$fl$ left top right bottom))

(specialize inline (new class <category<Rect$fl$>> left top right bottom) <Rect$fl$>
  (allocate-rect$fl$ left top right bottom))


(specialize inline as rect$fl$=? (= r1 <Rect$fl$> r2 <Rect$fl$>) <bool>
  (and (= (get-left r1) (get-left r2))
       (= (get-top r1) (get-top r2))
       (= (get-right r1) (get-right r2))
       (= (get-bottom r1) (get-bottom r2))))


;;;
;;;; Conversion
;;;


(definition public (point->distance pt <Point>) <Distance>
  (new Distance (get-h pt) (get-v pt)))


(definition public (point->dimension pt <Point>) <Dimension>
  (new Dimension (get-h pt) (get-v pt)))


(definition public (distance->point dist <Distance>) <Point>
  (new Point (get-x dist) (get-y dist)))


(definition public (distance->dimension dist <Distance>) <Dimension>
  (new Dimension (get-x dist) (get-y dist)))


(definition public (dimension->point dim <Dimension>) <Point>
  (new Point (get-width dim) (get-height dim)))


(definition public (dimension->distance dim <Dimension>) <Distance>
  (new Distance (get-width dim) (get-height dim)))


;;;
;;;; Homogeneous
;;;


(proclaim (warn optimizations))


;;;
;;;; S8Vector
;;;


(class S8Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-s8vector len)))


(class primitive S8Vector metaclass S8Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "s8vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (s8vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (s8vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (s8vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->s8vector (tail (s8vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->s8vector (butlast (s8vector->list self)))))


(specialize inline (element vector <s8vector> n) <object>
  (s8vector-ref vector n))


(specialize inline (set-element! vector <s8vector> n obj) <void>
  (s8vector-set! vector n obj))


(specialize inline (cardinality vector <s8vector>) <int>
  (s8vector-length vector))


;;;
;;;; U8Vector
;;;


(class U8Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-u8vector len)))


(class primitive U8Vector metaclass U8Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "u8vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (u8vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (u8vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (u8vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->u8vector (tail (u8vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->u8vector (butlast (u8vector->list self)))))


(specialize inline (element vector <u8vector> n) <object>
  (u8vector-ref vector n))


(specialize inline (set-element! vector <u8vector> n obj) <void>
  (u8vector-set! vector n obj))


(specialize inline (cardinality vector <u8vector>) <int>
  (u8vector-length vector))


;;;
;;;; S16Vector
;;;


(class S16Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-s16vector len)))


(class primitive S16Vector metaclass S16Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "s16vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (s16vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (s16vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (s16vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->s16vector (tail (s16vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->s16vector (butlast (s16vector->list self)))))


(specialize inline (element vector <s16vector> n) <object>
  (s16vector-ref vector n))


(specialize inline (set-element! vector <s16vector> n obj) <void>
  (s16vector-set! vector n obj))


(specialize inline (cardinality vector <s16vector>) <int>
  (s16vector-length vector))


;;;
;;;; U16Vector
;;;


(class U16Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-u16vector len)))


(class primitive U16Vector metaclass U16Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "u16vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (u16vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (u16vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (u16vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->u16vector (tail (u16vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->u16vector (butlast (u16vector->list self)))))


(specialize inline (element vector <u16vector> n) <object>
  (u16vector-ref vector n))


(specialize inline (set-element! vector <u16vector> n obj) <void>
  (u16vector-set! vector n obj))


(specialize inline (cardinality vector <u16vector>) <int>
  (u16vector-length vector))


;;;
;;;; S32Vector
;;;


(class S32Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-s32vector len)))


(class primitive S32Vector metaclass S32Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "s32vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (s32vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (s32vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (s32vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->s32vector (tail (s32vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->s32vector (butlast (s32vector->list self)))))


(specialize inline (element vector <s32vector> n) <object>
  (s32vector-ref vector n))


(specialize inline (set-element! vector <s32vector> n obj) <void>
  (s32vector-set! vector n obj))


(specialize inline (cardinality vector <s32vector>) <int>
  (s32vector-length vector))


;;;
;;;; U32Vector
;;;


(class U32Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-u32vector len)))


(class primitive U32Vector metaclass U32Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "u32vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (u32vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (u32vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (u32vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->u32vector (tail (u32vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->u32vector (butlast (u32vector->list self)))))


(specialize inline (element vector <u32vector> n) <object>
  (u32vector-ref vector n))


(specialize inline (set-element! vector <u32vector> n obj) <void>
  (u32vector-set! vector n obj))


(specialize inline (cardinality vector <u32vector>) <int>
  (u32vector-length vector))


;;;
;;;; S64Vector
;;;


(class S64Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-s64vector len)))


(class primitive S64Vector metaclass S64Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "s64vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (s64vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (s64vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (s64vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->s64vector (tail (s64vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->s64vector (butlast (s64vector->list self)))))


(specialize inline (element vector <s64vector> n) <object>
  (s64vector-ref vector n))


(specialize inline (set-element! vector <s64vector> n obj) <void>
  (s64vector-set! vector n obj))


(specialize inline (cardinality vector <s64vector>) <int>
  (s64vector-length vector))


;;;
;;;; U64Vector
;;;


(class U64Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-u64vector len)))


(class primitive U64Vector metaclass U64Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "u64vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (u64vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (u64vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (u64vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->u64vector (tail (u64vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->u64vector (butlast (u64vector->list self)))))


(specialize inline (element vector <u64vector> n) <object>
  (u64vector-ref vector n))


(specialize inline (set-element! vector <u64vector> n obj) <void>
  (u64vector-set! vector n obj))


(specialize inline (cardinality vector <u64vector>) <int>
  (u64vector-length vector))


;;;
;;;; F32Vector
;;;


(class F32Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-f32vector len)))


(class primitive F32Vector metaclass F32Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "f32vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (f32vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (f32vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (f32vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->f32vector (tail (f32vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->f32vector (butlast (f32vector->list self)))))


(specialize inline (element vector <f32vector> n) <object>
  (f32vector-ref vector n))


(specialize inline (set-element! vector <f32vector> n obj) <void>
  (f32vector-set! vector n obj))


(specialize inline (cardinality vector <f32vector>) <int>
  (f32vector-length vector))


;;;
;;;; F64Vector
;;;


(class F64Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-f64vector len)))


(class primitive F64Vector metaclass F64Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "f64vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (f64vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (f64vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (f64vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->f64vector (tail (f64vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->f64vector (butlast (f64vector->list self)))))


(specialize inline (element vector <f64vector> n) <object>
  (f64vector-ref vector n))


(specialize inline (set-element! vector <f64vector> n obj) <void>
  (f64vector-set! vector n obj))


(specialize inline (cardinality vector <f64vector>) <int>
  (f64vector-length vector))


;;;
;;;; Fixed Types
;;;


(class FixedVector-Class    extends Vector-Class)
(class FixedS8Vector-Class  extends S8Vector-Class)
(class FixedU8Vector-Class  extends U8Vector-Class)
(class FixedS16Vector-Class extends S16Vector-Class)
(class FixedU16Vector-Class extends U16Vector-Class)
(class FixedS32Vector-Class extends S32Vector-Class)
(class FixedU32Vector-Class extends U32Vector-Class)
(class FixedS64Vector-Class extends S64Vector-Class)
(class FixedU64Vector-Class extends U64Vector-Class)
(class FixedF32Vector-Class extends F32Vector-Class)
(class FixedF64Vector-Class extends F64Vector-Class)


(class primitive FixedVector    metaclass FixedVector-Class    extends Vector)
(class primitive FixedS8Vector  metaclass FixedS8Vector-Class  extends S8Vector)
(class primitive FixedU8Vector  metaclass FixedU8Vector-Class  extends U8Vector)
(class primitive FixedS16Vector metaclass FixedS16Vector-Class extends S16Vector)
(class primitive FixedU16Vector metaclass FixedU16Vector-Class extends U16Vector)
(class primitive FixedS32Vector metaclass FixedS32Vector-Class extends S32Vector)
(class primitive FixedU32Vector metaclass FixedU32Vector-Class extends U32Vector)
(class primitive FixedS64Vector metaclass FixedS64Vector-Class extends S64Vector)
(class primitive FixedU64Vector metaclass FixedU64Vector-Class extends U64Vector)
(class primitive FixedF32Vector metaclass FixedF32Vector-Class extends F32Vector)
(class primitive FixedF64Vector metaclass FixedF64Vector-Class extends F64Vector)


;;;
;;;; Debug
;;;


(proclaim (warn optimizations))


(declare (proper-tail-calls))


;;;
;;;; Console
;;;


(definition *console-port-getter*
  #f)


(definition public (console-port-getter-set! getter)
  (set! *console-port-getter* getter))


(definition public (current-console-port)
  (if (not *console-port-getter*)
      (terminal-port)
    (*console-port-getter*)))


(definition public (attached-console-port)
  (if (not *console-port-getter*)
      (and (terminal-available?) (terminal-port))
    (*console-port-getter*)))


(definition public (console-input-port)
  (current-console-port))

(definition public (console-output-port)
  (current-console-port))


(definition public (force-console)
  (force-output (current-console-port)))


(register-printer :console current-console-port)


;;;
;;;; Log
;;;


(definition platform-log
  #f)

(definition package (set-platform-log log)
  (set! platform-log log))


;;;
;;;; Output
;;;


(definition *console-clear*
  #f)

(definition public (console-clear-set! clear)
  (set! *console-clear* clear))


(definition console-mutex
  (make-mutex 'console))

(definition (with-console-mutex thunk)
  (mutex-lock! console-mutex)
  (prog1 (thunk)
    (mutex-unlock! console-mutex)))


(definition public (console-string string (color: color #f))
  (with-console-mutex
    (lambda ()
      (let ((output (attached-console-port)))
        (if (not output)
            (when platform-log
              (platform-log string))
          (format output "{a}" string)
          @wait-new-console-completion (
                                        (format output #"\($\)\(color Debug {a}\)\(%\)"# string)
                                        (format output #"\(prompt\){%}"#)
                                        )
          (force-output output)))
      (unspecified))))


(definition public (console-line string (color: color #f))
  (with-console-mutex
    (lambda ()
      (let ((output (attached-console-port)))
        (if (not output)
            (when platform-log
              (platform-log string))
          (format output "{a}{%}" string)
          @wait-new-console-completion (
                                        (format output #"\($\)\(color Debug {a}\)\(%\){%}"# string)
                                        (format output #"\(prompt\){%}"#)
                                        )
          (force-output output)))
      (unspecified))))


(definition public (console . rest)
  (console-line (format "{l detail: :describe}" rest)))


(definition public (debug-line . rest)
  (apply console-line rest))


(definition public (debug-string . rest)
  (apply console-string rest))


(definition public (debug-thread . rest)
  (apply console rest))


(definition public (debug . rest)
  (if (primordial-thread?)
      (apply debug-thread rest)
    (thread-post (primordial-thread) 'post-event
      (lambda ()
        (apply debug-thread rest)))))


(definition public (clear-debug)
  (if (not *console-clear*)
      (clear-terminal)
    (*console-clear*)))


;;;
;;;; Stack
;;;


(definition procedure-name-cache <table>
  (make-table test: eq?))


(definition public (get-procedure-name procedure)
  (define (present-anonymous)
    (let ((output (open-output-string)))
      (write procedure output)
      (get-output-string output)))
  
  (if procedure
      (or (table-ref procedure-name-cache procedure #f)
          (let ((name (or (procedure-name procedure)
                          @wait-check-all-use-cases
                          (present-anonymous))))
            (table-set! procedure-name-cache procedure name)
            name))
    "(interaction)"))


(definition public (get-continuation-name cont)
  (get-procedure-name (continuation-creator cont)))


(definition public (continuation-stack cont (identifiers?: identifiers? #f) (locations?: locations? #f) (dynamic-environment?: dynamic-environment? #f) (lexical-environment?: lexical-environment? #f) (depth: depth #f))
  (define (package-name name)
    (if (and identifiers? (symbol? name))
        (reference-name name)
      name))
  
  (define (package-variable variable)
    (bind (name value mutable?) variable
      (list name value)))
  
  (define (package-variables variables)
    (map package-variable variables))
  
  (let ((stack (get-continuation-stack cont depth)))
    (define (->code-name name)
      (if (symbol? name)
          (let ((str (symbol->string name)))
            (if (starts-with? str "%%")
                (string->symbol (substring str 2 (string-length str)))
              name))
        name))
    
    (map (lambda (cont)
           (let ((name (->code-name (package-name (get-continuation-name cont))))
                 (location (and locations? (get-continuation-location cont)))
                 (dynamic-environment (if dynamic-environment? (package-variables (get-continuation-dynamic-environment cont)) '()))
                 (lexical-environment (if lexical-environment? (package-variables (get-continuation-lexical-environment cont)) '())))
             (let ((environment (append dynamic-environment lexical-environment)))
               (cond ((and (not locations?)
                           (not dynamic-environment?)
                           (not lexical-environment?))
                      name)
                     ((not locations?)
                      (list name environment))
                     (else
                      (cons name (cons location environment)))))))
         stack)))


(definition public (execution-stack (identifiers?: identifiers? #f) (locations?: locations? #f) (dynamic-environment?: dynamic-environment? #f) (lexical-environment?: lexical-environment? #f) (depth: depth #f))
  (continuation-capture
    (lambda (cont)
      (continuation-stack cont identifiers?: identifiers? locations?: locations? dynamic-environment?: dynamic-environment? lexical-environment?: lexical-environment? depth: depth))))


(definition public (execution-backtrace (depth #f))
  (continuation-capture
    (lambda (cont)
      (continuation-backtrace cont depth #f #f))))


;;;
;;;; Debuggee
;;;


(definition public (debugger-argument)
  (or (command-argument "d")
      (command-argument "debugger")))


(definition public (using-debugger?)
  (boolean (debugger-argument)))


(definition public (break . rest)
  (apply (module-ref 'jazz.debuggee 'break-internal) rest))


(definition public (inspect . rest)
  (apply (module-ref 'jazz.debuggee 'inspect-internal) rest))


(definition public (advise . rest)
  (apply (module-ref 'jazz.debuggee 'advise-internal) rest))

(definition public (unadvise . rest)
  (apply (module-ref 'jazz.debuggee 'unadvise-internal) rest))


(definition public (debug-advice . rest)
  (apply (module-ref 'jazz.debuggee 'debug-advice-internal) rest))


(definition public (count-advice . rest)
  (apply (module-ref 'jazz.debuggee 'count-advice-internal) rest))


(definition public (time-advice . rest)
  (apply (module-ref 'jazz.debuggee 'time-advice-internal) rest))


(definition public (trace . rest)
  (apply (module-ref 'jazz.debuggee 'trace-internal) rest))

(definition public (untrace . rest)
  (apply (module-ref 'jazz.debuggee 'untrace-internal) rest))


(definition public (start-repl . rest)
  (apply (module-ref 'jazz.debuggee 'start-repl-internal) rest))


(definition public (start-jazz-repl . rest)
  (apply (module-ref 'jazz.debuggee 'start-jazz-repl-internal) rest))


;;;
;;;; Exception
;;;


(proclaim (warn optimizations))


(declare (proper-tail-calls))


(definition *exception-debugger*
  #f)


(definition public (get-exception-debugger)
  *exception-debugger*)

(definition public (set-exception-debugger exception-debugger)
  (set! *exception-debugger* exception-debugger))


(definition public current-exception-debugger
  (make-parameter #f))


(definition package (exception-debugger-hook exc other)
  (let ((exception-debugger (active-exception-debugger)))
    (if exception-debugger
        (exception-debugger exc)
      (system-exception-hook exc other))))


(definition public (with-exception-debugger exception-debugger thunk)
  (parameterize ((current-exception-debugger exception-debugger))
    (thunk)))


(definition public (active-exception-debugger)
  (or (current-exception-debugger) *exception-debugger*))


(definition public (system-exception-debugger exc)
  (invoke-exception-hook system-exception-hook exc))


(definition public (with-system-exception-debugger thunk)
  (with-exception-debugger system-exception-debugger
    thunk))


(class Exception extends Object
  
  
  (method core virtual (present-exception self))
  (method core virtual (exception-message self))
  (method core virtual (get-detail self))
  
  
  (method public virtual (get-message self)
    #f)
  
  
  (method public virtual (present-message self . rest)
    (list (get-message self)))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{?{s}~}" (get-message self))))))


(definition public (exception? obj)
  (and (object? obj)
       (is? obj Exception)))


(class package Exception-Detail-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (get-icon object)
                              (get-title object)
                              (get-location object)
                              (get-children object))))
  
  
  (method override (unmarshall-object self content)
    (allocate Exception-Detail
              (vector-ref content 0)
              (vector-ref content 1)
              (vector-ref content 2)
              (vector-ref content 3))))


(class package Exception-Detail metaclass Exception-Detail-Class extends Object
  
  
  (slot icon     getter generate)
  (slot title    getter generate)
  (slot location getter generate)
  (slot children getter generate)
  
  
  (method override (initialize self icon title location children)
    (nextmethod self)
    (set! self.icon icon)
    (set! self.title title)
    (set! self.location location)
    (set! self.children children))
  
  
  (method override (print self output readably)
    (format output "~{{a} {s} {s} {s} {s}}"
            (category-name (class-of self))
            icon
            title
            location
            children)))


(class System-Exception extends Exception
  
  
  (slot exception getter generate)
  
  
  (method override (initialize self exception)
    (nextmethod self)
    (set! self.exception exception)))


(definition public (wrap-exception obj)
  (if (exception? obj)
      obj
    (new System-Exception obj)))


(class Break extends Exception
  
  
  (slot continue)
  
  
  (method override (initialize self continue)
    (nextmethod self)
    (set! self.continue continue)))


(class Continue extends Exception)


(class Error extends Exception
  
  
  (slot message setter generate getter (override generate))
  
  
  (method override (initialize self (message: message #f))
    (nextmethod self)
    (set-message self message)))


(definition public (error? obj)
  (and (object? obj)
       (is? obj Error)))


(class package Read-Error extends Error
  
  
  (slot source getter generate)
  (slot start  getter generate)
  (slot end    getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((source #f) (start #f) (end #f) . others) rest
      (apply nextmethod self others)
      (set! self.source source)
      (set! self.start start)
      (set! self.end end)))
  
  
  (method public (get-range self)
    (new Range start end)))


(class package Parse-Error extends Error
  
  
  (slot source getter generate)
  (slot start  getter generate)
  (slot end    getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((source #f) (start #f) (end #f) . others) rest
      (apply nextmethod self others)
      (set! self.source source)
      (set! self.start start)
      (set! self.end end))))


(class package Conversion-Error extends Parse-Error
  
  
  (slot object getter generate)
  (slot type   getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((object #f) (type #f) . others) rest
      (apply nextmethod self others)
      (set! self.object object)
      (set! self.type type)))
  
  
  (method override (get-message self)
    (let ((type (if (string? type) type (category-identifier type))))
      (format "Unable to convert \"{a}\" into {a} {a}"
              object
              (format-gender type)
              type))))


(class Source-Error extends Error
  
  
  (slot source getter generate)
  (slot start  getter generate)
  (slot end    getter generate)
  
  
  (method override (initialize self source . rest)
    (bind-keywords ((start #f) (end #f) . others) rest
      (apply nextmethod self others)
      (set! self.source source)
      (set! self.start start)
      (set! self.end end)))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-range self)
    (new Range$Cell$ start end)))


(class Signal extends Exception)


(class package Cancel-Signal extends Signal)


(definition public (call-with-catch predicate/type catcher thunk)
  (catch-exception-filter
    (lambda (obj)
      (if (procedure? predicate/type)
          (predicate/type obj)
        ;; we have to be very carefull as we can
        ;; potentially receive system exceptions
        (and (object? obj)
             (is? obj predicate/type))))
    catcher
    thunk))


;;;
;;;; Context
;;;


(definition exception-contexts
  (make-table test: eq? weak-keys: #t))


(definition public (get-exception-context exception)
  (table-ref exception-contexts exception #f))


(definition public (set-exception-context exception continuation)
  (table-set! exception-contexts exception continuation))


(definition public (capture-exception-context exception)
  (continuation-capture
    (lambda (cont)
      (set-exception-context exception cont))))


;;;
;;;; Control
;;;


(definition public (throw exception)
  (raise exception))


(definition public (error . rest)
  (throw (new Error message: (apply format rest))))


(definition public (disabled-functionality)
  (error "This functionality is temporarily disabled"))


(definition public (must-implement definition-name (what #f))
  (error "The {a} definition must be implemented for {a} to work correctly"
         definition-name
         (or what "this application")))


(definition public (warn string . rest)
  (format :console "{%}Warning: ")
  (apply format :console string rest))


(definition public (warn-unimplemented name)
  (format :console "{%}Warning: {a} is unimplemented" name))


(definition public (signal signal)
  (raise signal))


(definition public inline (signal-cancel)
  (signal (new Cancel-Signal)))


;;;
;;;; Restart
;;;


(class Restart extends Object
  
  
  (slot name    getter generate)
  (slot message getter generate)
  (slot handler getter generate)
  
  
  (method override (initialize self name message handler)
    (nextmethod self)
    (set! self.name name)
    (set! self.message message)
    (set! self.handler handler))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}"
                name)))))


(definition public current-restarts
  (make-parameter '()))


(definition public (with-restart-handler name message handler thunk)
  (parameterize ((current-restarts (cons (new Restart name message handler) (current-restarts))))
    (thunk)))


(definition public (with-restart-catcher name message thunk (restart-result #f))
  (continuation-capture
    (lambda (catcher-cont)
      (with-restart-handler name message
        (lambda rest
          (continuation-return catcher-cont
            (if (not-null? rest)
                (car rest)
              restart-result)))
        thunk))))


(definition public (find-restart name)
  (find-if (lambda (restart)
             (eq? (get-name restart) name))
           (current-restarts)))


(definition public (find-restarts name)
  (collect-if (lambda (restart)
                (eq? (get-name restart) name))
              (current-restarts)))


(definition public (invoke-restart restart . rest)
  (let ((handler (get-handler restart)))
    (apply handler rest)))


;;;
;;;; Thread
;;;


(definition public (new-system-thread thunk name . rest)
  (apply new-thread
         (lambda ()
           (with-system-exception-debugger
             thunk))
         name
         rest))


;;;
;;;; Output
;;;


;;;
;;;; Header
;;;


(definition public (output-header title printer (language: language 'jazz) (system: system #f) (license: license #f) (author: author #f) (copyright: copyright #f) (contributors: contributors '()) (end-proper?: end-proper? #t))
  (with-printer printer
    (lambda (output)
      (let* ((system (or system "JazzScheme"))
             (system-padding (make-string (string-length system) #\=))
             (comment (case language ((jazz) ";;;") ((c) "//")))
             (toplevel-comment (case language ((jazz) ";;;;") ((c) "///"))))
        (format output #"{a}=={a}=={%}"# comment system-padding)
        (format output #"{a}  {a}{%}"# comment system)
        (format output #"{a}=={a}=={%}"# comment system-padding)
        (format output #"{a}{%}"# comment)
        (format output #"{a} {a}{%}"# toplevel-comment title)
        (format output #"{a}"# comment)
        (case license
          ((jazzscheme)
           (format output "{%}")
           (format output #"{a}  The contents of this file are subject to the Mozilla Public License Version{%}"# comment)
           (format output #"{a}  1.1 (the "License"); you may not use this file except in compliance with{%}"# comment)
           (format output #"{a}  the License. You may obtain a copy of the License at{%}"# comment)
           (format output #"{a}  http://www.mozilla.org/MPL/{%}"# comment)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  Software distributed under the License is distributed on an "AS IS" basis,{%}"# comment)
           (format output #"{a}  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License{%}"# comment)
           (format output #"{a}  for the specific language governing rights and limitations under the{%}"# comment)
           (format output #"{a}  License.{%}"# comment)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  The Original Code is JazzScheme.{%}"# comment)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  The Initial Developer of the Original Code is {a}.{%}"# comment author)
           (format output #"{a}  Portions created by the Initial Developer are Copyright (C) {a}{%}"# comment copyright)
           (format output #"{a}  the Initial Developer. All Rights Reserved.{%}"# comment)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  Contributor(s):{%}"# comment)
           (for-each (lambda (contributor)
                       (format output #"{a}    {a}{%}"# comment contributor))
                     contributors)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  Alternatively, the contents of this file may be used under the terms of{%}"# comment)
           (format output #"{a}  the GNU General Public License Version 2 or later (the "GPL"), in which{%}"# comment)
           (format output #"{a}  case the provisions of the GPL are applicable instead of those above. If{%}"# comment)
           (format output #"{a}  you wish to allow use of your version of this file only under the terms of{%}"# comment)
           (format output #"{a}  the GPL, and not to allow others to use your version of this file under the{%}"# comment)
           (format output #"{a}  terms of the MPL, indicate your decision by deleting the provisions above{%}"# comment)
           (format output #"{a}  and replace them with the notice and other provisions required by the GPL.{%}"# comment)
           (format output #"{a}  If you do not delete the provisions above, a recipient may use your version{%}"# comment)
           (format output #"{a}  of this file under the terms of any one of the MPL or the GPL.{%}"# comment)
           (format output #"{a}{%}"# comment)
           (format output #"{a}  See www.jazzscheme.org for details."# comment)))
        (when end-proper?
          (format output "{%}"))))))


(definition public (output-section title output (language: language 'jazz) (level: level 0))
  (let ((comment (case language ((jazz) ";;;") ((c) "//")))
        (toplevel (case language ((jazz) ";;;;") ((c) "///")))
        (extra (case language ((jazz) "") ((c) (make-string (+ (string-length title) 4) #\-)))))
    (format output "{%}{%}")
    (format output "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format output "{_ :v}{a} {a}{%}" (* level 2) toplevel title)
    (format output "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format output "{%}{%}")))


;;;
;;;; Formatter
;;;


(class undocumented Formatter extends Object


  (method public virtual (format-directive self formatting output directive)
    ))


;;;
;;;; Print-Sequencer
;;;


(class undocumented Print-Sequencer extends Object)


@convert


(class undocumented Print-Sequencer extends Object
  
  
  (slot printer)
  (slot start)
  (slot sections initialize (new List-Factory))
  
  
  (method (initialize prt)
    (nextmethod)
    (set! printer prt)
    (start-section))
  
  
  (method public (start-section)
    (set! start (get-position)))
  
  
  (method public (end-section)
    (prog1 (cons start (get-position))
      (start-section)))
  
  
  (method (get-position)
    (get-position printer))
  
  
  ;;;
  ;;;; Sections
  ;;;
  
  
  (method public (put-section section)
    (put sections section))
  
  
  (method public (put-sections sections-list)
    (put-sequence sections sections-list))
  
  
  (method public (print-sections output)
    (for-each (lambda (section)
                (bind (start . end) section
                  (transfer start end output)))
              (get-output sections)))
  
  
  ;;;
  ;;;; Transfer
  ;;;
  
  
  (definition transfer-size
    1024)
  
  (definition transfer-buffer
    (new Heap-Block size: transfer-size))
  
  
  (method synchronized (transfer start end output)
    (let ((size (- end start)))
      (while (> size 0)
        (set-position printer start)
        (let ((subsize (min size transfer-size)))
          (ReadFile (get-handle printer) transfer-buffer subsize NULL)
          (WriteFile (get-handle output) transfer-buffer subsize NULL)
          (decrease! size subsize)
          (increase! start subsize))))))


;;;
;;;; Parse
;;;


(proclaim (warn optimizations))


(definition public (parse-integer string)
  (if (and (not (empty-string? string)) (numeric? string))
      (read-string-element string)
    (signal (new Conversion-Error object: string type: "integer"))))


(definition public (parse-hexadecimal string)
  (read-string-element (format "#x{a}" string)))


(definition public (parse-boolean string)
  (cond ((not string) #f)
        ((or (ci=? string "#f") (ci=? string "f") (ci=? string "false")) #f)
        ((or (ci=? string "#t") (ci=? string "t") (ci=? string "true")) #t)
        (else (signal (new Conversion-Error object: string type: "boolean")))))


(definition public (parse-strings string (separator: separator ","))
  (if (or (empty-string? string) (string=? string "{}"))
      #f
    (map (lambda (string)
           (trim-spaces string))
         (split string separator))))


(definition public (parse-delimited-string string (separator: separator ","))
  (map (lambda (string)
         (parse-strings string separator: " "))
       (parse-strings string separator: separator)))


;;;
;;;; Platform
;;;


(proclaim (warn optimizations))


(definition public (bell . rest)
  (apply (module-ref 'jazz.platform 'bell-internal) rest))


;;;
;;;; Tell
;;;


(proclaim (warn optimizations))


(definition public tell-precision
  3)

(definition public (set-tell-precision precision)
  (set! tell-precision precision))


(definition public (tell . rest)
  (define (tell-flonum obj)
    (if (not tell-precision)
        (format :terminal "{a}" obj)
      (format :terminal "{r precision: :v}" obj tell-precision)))
  
  (define (tell-pair pair)
    (format :terminal "(")
    (tell-subpair pair)
    (format :terminal ")"))
  
  (define (tell-subpair pair)
    (tell-object (car pair))
    (let ((rest (cdr pair)))
      (cond ((null? rest))
            ((pair? rest)
             (format :terminal " ")
             (tell-subpair rest))
            (else
             (format :terminal " . ")
             (tell-object rest)))))
  
  (define (tell-sequence prefix seq)
    (format :terminal "{a}" prefix)
    (format :terminal "(")
    (let ((first? #t))
      (iterate seq
        (lambda (obj)
          (if first?
              (set! first? #f)
            (format :terminal " "))
          (tell-object obj))))
    (format :terminal ")"))
  
  (define (tell-object obj)
    (cond ((flonum? obj)    (tell-flonum obj))
          ((pair? obj)      (tell-pair obj))
          ((vector? obj)    (tell-sequence "#" obj))
          ((u8vector? obj)  (tell-sequence "#u8" obj))
          ((s8vector? obj)  (tell-sequence "#s8" obj))
          ((u16vector? obj) (tell-sequence "#u16" obj))
          ((s16vector? obj) (tell-sequence "#s16" obj))
          ((u32vector? obj) (tell-sequence "#u32" obj))
          ((s32vector? obj) (tell-sequence "#s32" obj))
          ((u64vector? obj) (tell-sequence "#u64" obj))
          ((s64vector? obj) (tell-sequence "#s64" obj))
          ((f32vector? obj) (tell-sequence "#f32" obj))
          ((f64vector? obj) (tell-sequence "#f64" obj))
          (else (format :terminal "{a}" obj))))
  
  (let ((first? #t))
    (for-each (lambda (obj)
                (if first?
                    (set! first? #f)
                  (format :terminal " "))
                (tell-object obj))
              rest))
  (format :terminal "{%}"))


;;;
;;;; Walk-Binding
;;;


(class Walk-Binding extends Type
  
  
  (method core virtual (walk-binding-lookup self symbol source-declaration))
  (method core virtual (walk-binding-referenced self))
  (method core virtual (walk-binding-validate-call self walker resume source-declaration operator arguments form-src))
  (method core virtual (walk-binding-validate-assignment self walker resume source-declaration symbol-src))
  (method core virtual (walk-binding-assignable? self))
  (method core virtual (walk-binding-walkable? self))
  (method core virtual (walk-binding-walk-form self walker resume declaration environment form-src))
  (method core virtual (walk-binding-expandable? self))
  (method core virtual (walk-binding-expand-form self walker resume declaration environment form-src))
  (method core virtual (emit-binding-symbol self source-declaration environment))
  (method core virtual (emit-binding-reference self source-declaration walker resume environment))
  (method core virtual (emit-binding-call self binding-src arguments arguments-codes source-declaration environment))
  (method core virtual (emit-inlined-binding-call self arguments call source-declaration walker resume environment))
  (method core virtual (emit-binding-assignment self value source-declaration environment form-src)))


(native-syntax jazz:walk-binding-lookup)
(native-syntax jazz:walk-binding-referenced)
(native-syntax jazz:walk-binding-validate-call)
(native-syntax jazz:walk-binding-validate-assignment)
(native-syntax jazz:walk-binding-assignable?)
(native-syntax jazz:walk-binding-walkable?)
(native-syntax jazz:walk-binding-walk-form)
(native-syntax jazz:walk-binding-expandable?)
(native-syntax jazz:walk-binding-expand-form)
(native-syntax jazz:emit-binding-reference)
(native-syntax jazz:emit-binding-call)
(native-syntax jazz:emit-inlined-binding-call)
(native-syntax jazz:emit-binding-assignment)


;;;
;;;; Lexical-Binding
;;;


(class Lexical-Binding extends Walk-Binding
  
  
  (slot name getter generate)
  (slot type getter generate)
  (slot hits accessors generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((name #f) (type #f)) rest
      (set! self.name name)
      (set! self.type type)
      (set! self.hits #f)))
  
  
  (method core package virtual (resolve-binding self))
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}" (get-name self))))))


(native-syntax jazz:resolve-binding)


;;;
;;;; Declaration
;;;


(class Declaration extends Lexical-Binding
  
  
  (slot access        getter generate)
  (slot compatibility getter generate)
  (slot modifiers     getter generate)
  (slot attributes    getter generate)
  (slot toplevel      getter generate)
  (slot parent        getter generate)
  (slot locator       getter generate)
  (slot source        accessors generate)
  (slot name-source   accessors generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((access #f) (compatibility #f) (modifiers #f) (attributes #f) (parent #f) . others) rest
      (apply nextmethod self others)
      (set! self.access access)
      (set! self.compatibility compatibility)
      (set! self.modifiers modifiers)
      (set! self.attributes attributes)
      (set! self.toplevel #f)
      (set! self.parent parent)
      (set! self.locator #f)
      (set! self.source #f)
      (set! self.name-source #f)
      (setup-declaration self)))
  
  
  (method core virtual (compose-declaration-locator self))
  (method core package virtual (lookup-declaration self symbol access source-declaration))
  (method core virtual (get-declaration-inclusions self))
  (method core virtual (get-nextmethod-signature self))
  (method core virtual (emit-declaration self walker resume environment))
  (method core virtual (expand-referenced-declaration self))
  (method core virtual (outline-generate self output))
  (method core virtual (outline-extract self meta)))


(native-syntax jazz:lookup-declaration)
(native-syntax jazz:update-declaration)
(native-syntax jazz:get-declaration-inclusions)
(native-syntax jazz:emit-declaration)
(native-syntax jazz:expand-referenced-declaration)
(native-syntax jazz:private-access)
(native-syntax jazz:public-access)
(native-syntax jazz:protected-access)


;;;
;;;; Declaration-Reference
;;;


(class Declaration-Reference extends Object
  
  
  (slot name        getter generate)
  (slot declaration getter generate)
  
  
  (method core virtual (resolve-reference self module-declaration)))


(native-syntax jazz:resolve-reference)


;;;
;;;; Module-Reference
;;;


(class Module-Reference extends Declaration-Reference)


;;;
;;;; Export-Reference
;;;


(class Export-Reference extends Declaration-Reference
  
  
  (slot module-reference getter generate))


;;;
;;;; Autoload-Reference
;;;


(class Autoload-Reference extends Export-Reference
  
  
  (slot hubs? getter generate))


;;;
;;;; Unit-Declaration
;;;


(class Unit-Declaration extends Declaration
  
  
  (slot container getter generate)
  (slot requires  getter generate))


;;;
;;;; Namespace-Declaration
;;;


(class Namespace-Declaration extends Declaration
  
  
  (slot lookups  getter generate)
  (slot children accessors generate)
  (slot body     accessors generate))


(native-syntax jazz:get-access-lookup)


;;;
;;;; Module-Declaration
;;;


(class Module-Declaration extends Namespace-Declaration
  
  
  (slot walker          getter generate)
  (slot container       getter generate)
  (slot dialect-name    getter generate)
  (slot dialect-invoice getter generate)
  (slot requires        getter generate)
  (slot exports         getter generate)
  (slot imports         getter generate)
  (slot inclusions      accessors generate)
  (slot local-macros    getter generate))


;;;
;;;; Require-Invoice
;;;


(class Require-Invoice extends Object
  
  
  (slot name  getter generate)
  (slot phase getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "on {s}"
          name)))))


;;;
;;;; Module-Invoice
;;;


(class Module-Invoice extends Object
  
  
  (slot name            getter generate)
  (slot module          getter generate)
  (slot phase           getter generate)
  (slot transformations getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "on {s}"
          name)))))


;;;
;;;; Export-Invoice
;;;


(class Export-Invoice extends Module-Invoice
  
  
  (slot autoload getter generate)
  (slot symbols  getter generate))


;;;
;;;; Import-Invoice
;;;


(class Import-Invoice extends Module-Invoice
  
  
  (slot hit? getter generate))


;;;
;;;; Export
;;;


(class Export-Declaration extends Declaration
  
  
  (slot symbol getter generate))


;;;
;;;; Export Syntax
;;;


(class Export-Syntax-Declaration extends Declaration
  
  
  (slot symbol getter generate))


;;;
;;;; Autoload
;;;


(class Autoload-Declaration extends Declaration
  
  
  (slot module          getter generate)
  (slot exported-module getter generate)
  (slot declaration     getter generate))


;;;
;;;; Literal
;;;


(definition public *print-literal*
  (make-parameter #f))


(class Literal-Class extends Class
  
  
  (method override (marshall-object self obj)
    (serialize-object (class-of obj)
                      (vector
                        (serialize (get-name obj))
                        (serialize (get-arguments obj)))))
  
  
  (method override (unmarshall-object self content)
    (bind-vector (name arguments) content
      (new self
        (deserialize name)
        (deserialize arguments)))))


(class Literal metaclass Literal-Class extends Object
  
  
  (slot name      getter generate)
  (slot arguments getter generate)
  
  
  (method override (initialize self name arguments)
    (set! self.name name)
    (set! self.arguments arguments))
  
  
  (method override (print self output readably)
    (if (*print-literal*)
        (format output "~{{a}{?: {l detail: :v}~}}" name (not-null? arguments) arguments readably)
      (format output "~{Literal {s} {s}}" name arguments)))
  
  
  (method override (walk-references self proc)
    (walk-literal (source-code name) arguments proc)))


(native jazz:new-literal)


;;;
;;;; Any
;;;


(class Any extends Type)


;;;
;;;; Macro
;;;


(class Macro-Declaration extends Declaration
  
  
  (slot signature getter generate)
  (slot body      getter generate))


;;;
;;;; Syntax
;;;


(class Syntax-Declaration extends Declaration
  
  
  (slot signature getter generate)
  (slot body      getter generate))


;;;
;;;; Define-Syntax
;;;


(class Define-Syntax-Declaration extends Syntax-Declaration)


;;;
;;;; Define-Local-Syntax
;;;


(class Define-Local-Syntax-Declaration extends Syntax-Declaration)


;;;
;;;; Void
;;;


(class Void-Class extends Class)


(class Void metaclass Void-Class extends Type)


;;;
;;;; Opt Type
;;;


(class Opt-Type extends Type
  
  
  (slot type getter generate))


;;;
;;;; Key Type
;;;


(class Key-Type extends Type
  
  
  (slot key  getter generate)
  (slot type getter generate))


;;;
;;;; Rest Type
;;;


(class Rest-Type extends Type
  
  
  (slot type getter generate))


;;;
;;;; Function Type
;;;


(class Function-Type extends Type
  
  
  (slot mandatory  getter generate)
  (slot positional getter generate)
  (slot optional   getter generate)
  (slot named      getter generate)
  (slot rest       getter generate)
  (slot result     getter generate))


;;;
;;;; Category Type
;;;


(class Category-Type extends Type
  
  
  (slot declaration getter generate))


;;;
;;;; Values Type
;;;


(class Values-Type extends Type
  
  
  (slot types getter generate))


;;;
;;;; Restriction Type
;;;


(class Restriction-Type extends Type
  
  
  (slot base getter generate)
  (slot type getter generate))


;;;
;;;; Complement Type
;;;


(class Complement-Type extends Type
  
  
  (slot type getter generate))


;;;
;;;; Union Type
;;;


(class Union-Type extends Type
  
  
  (slot types getter generate))


;;;
;;;; Template Type
;;;


(class Template-Type extends Type
  
  
  (slot class getter generate)
  (slot types getter generate))


;;;
;;;; Nillable Type
;;;


(class Nillable-Type extends Type
  
  
  (slot type getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}"
          type)))))


;;;
;;;; Dialect
;;;


(class Dialect extends Object
  
  
  (method core virtual (dialect-walker self))
  
  
  (slot name         getter generate)
  (slot declarations getter generate)
  (slot bindings     getter generate))


;;;
;;;; Backend
;;;


(class Backend extends Object
  
  
  (slot name     getter generate)
  (slot bindings getter generate)
  (slot hook     accessors generate))


;;;
;;;; Walker
;;;


(class Walker extends Object
  
  
  (slot declarations getter generate)
  (slot bindings     getter generate)
  (slot warnings     getter generate)
  (slot errors       getter generate)
  (slot literals     getter generate)
  (slot variables    getter generate)
  (slot statics      getter generate)
  (slot exports      getter generate)
  (slot references   getter generate)
  (slot autoloads    getter generate)
  
  
  (method core virtual (walker-declarations self))
  (method core virtual (walker-bindings self))
  (method core virtual (walk-form self resume declaration environment form))
  (method core virtual (walk-symbol self resume declaration environment symbol-src))
  (method core virtual (walk-symbol-assignment self resume declaration environment symbol-src value form-src))
  (method core virtual (validate-proclaim self resume declaration environment form-src))
  (method core virtual (runtime-export self declaration))
  (method core virtual (lookup-environment self resume declaration environment symbol-src symbol))
  (method core virtual (lookup-analyse self declaration symbol-src referenced-declaration)))


(native-syntax jazz:validate-access)
(native-syntax jazz:walk-symbol-assignment)
(native-syntax jazz:walk-symbol)
(native-syntax jazz:walk-form)
(native-syntax jazz:validate-proclaim)


;;;
;;;; Walk Context
;;;


(class Walk-Context extends Object
  
  
  (slot policy    getter generate)
  (slot locator   getter generate)
  (slot pathname  getter generate)
  (slot proclaims getter generate))


;;;
;;;; Walk-Location
;;;


(class package Walk-Location-Class extends Class
  
  
  (method override (marshall-object self object)
    (serialize-object (class-of object)
                      (vector (get-unit-locator object)
                              (get-declaration-locator object)
                              (get-locat object)
                              (get-path object))))
  
  
  (method override (unmarshall-object self content)
    (allocate Walk-Location
              (vector-ref content 0)
              (vector-ref content 1)
              (vector-ref content 2)
              (vector-ref content 3))))


(class package Walk-Location extends Object
  
  
  (slot unit-locator        getter generate)
  (slot declaration-locator getter generate)
  (slot locat               getter generate)
  (slot path                getter generate)
  
  
  (method override (initialize self unit-locator declaration-locator locat path)
    (nextmethod self)
    (set! self.unit-locator unit-locator)
    (set! self.declaration-locator declaration-locator)
    (set! self.locat locat)
    (set! self.path path))
  
  
  (method override (print self output readably)
    (format output "~{{a} {s} {s} {s} {s}}"
            (category-name (class-of self))
            unit-locator
            declaration-locator
            locat
            path)))


;;;
;;;; Walk-Problem
;;;


(class package Walk-Problem extends Error
  
  
  (slot location getter generate))


;;;
;;;; Walk-Problems
;;;


(class package Walk-Problems extends Error
  
  
  (slot warnings getter generate)
  (slot errors   getter generate))


;;;
;;;; Walk-Warning
;;;


(class package Walk-Warning extends Walk-Problem)


;;;
;;;; Walk-Error
;;;


(class package Walk-Error extends Walk-Problem)


;;;
;;;; Unresolved-Error
;;;


(class package Unresolved-Error extends Walk-Error
  
  
  (slot symbol getter generate))


;;;
;;;; Walk-Frame
;;;


(class Walk-Frame extends Walk-Binding
  
  
  (slot bindings getter generate))


;;;
;;;; Signature
;;;


(class Signature extends Object
  
  
  (slot mandatory   getter generate)
  (slot positional  getter generate)
  (slot optional    getter generate)
  (slot named       getter generate)
  (slot rest        getter generate)
  (slot expressions getter generate))


;;;
;;;; Symbol-Binding
;;;


(class Symbol-Binding extends Lexical-Binding
  
  
  (slot gensym getter generate))


;;;
;;;; Variable
;;;


(class Variable extends Symbol-Binding
  
  
  (slot source           getter generate)
  (slot specifier-source getter generate)
  (slot reference-count  getter generate)
  
  
  (method override (initialize self name type source specifier-source)
    (set! self.name name)
    (set! self.type type)
    (set! self.source source)
    (set! self.specifier-source specifier-source)
    (set! self.reference-count 0)))


;;;
;;;; NextMethod-Variable
;;;


(class NextMethod-Variable extends Variable)


;;;
;;;; Parameter
;;;


(class Parameter extends Variable
  
  
  (method core virtual (emit-parameter self declaration walker resume environment)))


;;;
;;;; Dynamic-Parameter
;;;


(class Dynamic-Parameter extends Parameter
  
  
  (slot class getter generate))


;;;
;;;; Optional-Parameter
;;;


(class Optional-Parameter extends Parameter
  
  
  (slot default getter generate))


;;;
;;;; Named-Parameter
;;;


(class Named-Parameter extends Parameter
  
  
  (slot default getter generate))


;;;
;;;; Rest-Parameter
;;;


(class Rest-Parameter extends Parameter)


;;;
;;;; Dynamic Self Binding
;;;


(class Dynamic-Self-Binding extends Lexical-Binding
  
  
  (slot code getter generate))


;;;
;;;; Local Variable Binding
;;;


(class Local-Variable-Binding extends Lexical-Binding
  
  
  (slot variable getter generate))


;;;
;;;; Macro Symbol
;;;


(class Macro-Symbol extends Symbol-Binding
  
  
  (slot getter getter generate)
  (slot setter getter generate))


;;;
;;;; Form Binding
;;;


(class Form-Binding extends Lexical-Binding)


;;;
;;;; Special Form
;;;


(class Special-Form extends Form-Binding
  
  
  (slot walk getter generate))


;;;
;;;; Macro Form
;;;


(class Macro-Form extends Form-Binding
  
  
  (slot expander getter generate))


;;;
;;;; Syntax Form
;;;


(class Syntax-Form extends Form-Binding
  
  
  (slot expander getter generate))


;;;
;;;; Define-Syntax Form
;;;


(class Define-Syntax-Form extends Syntax-Form
  
  
  (slot environment getter generate))


;;;
;;;; Define-Local-Syntax Form
;;;


(class Define-Local-Syntax-Form extends Syntax-Form
  
  
  (slot environment getter generate))


;;;
;;;; Syntactic Closures
;;;


(class Syntactic-Closure extends Object
  
  
  (slot environment getter generate)
  (slot variables   getter generate)
  (slot expression  getter generate)
  (slot form        getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}"
          form)))))


;;;
;;;; Annotated Variable
;;;


(class Annotated-Variable extends Object
  
  
  (slot variable      getter generate)
  (slot declared-type getter generate)
  (slot type          getter generate)
  
  
  (method override (initialize self variable declared-type type)
    (set! self.variable variable)
    (set! self.declared-type declared-type)
    (set! self.type type))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}"
          (get-name variable))))))


;;;
;;;; Restricted Binding
;;;


(class Restricted-Binding extends Object
  
  
  (slot binding getter generate)
  (slot type    getter generate))


;;;
;;;; Annotated Frame
;;;


(class Annotated-Frame extends Object
  
  
  (slot variables getter generate)
  (slot reset     getter generate))


;;;
;;;; Code
;;;


(class Code extends Object
  
  
  (slot form   getter generate)
  (slot type   getter generate)
  (slot source getter generate))


;;;
;;;; Expression
;;;


(class Expression extends Object
  
  
  (slot type   getter generate)
  (slot source getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((type #f) (source #f)) rest
      (nextmethod self)
      (set! self.type type)
      (set! self.source source)))
  
  
  (method core package virtual (emit-expression self declaration walker resume environment))
  (method core package virtual (emit-call self arguments arguments-codes declaration environment)))


(native-syntax jazz:emit-expression)
(native-syntax jazz:emit-call)


;;;
;;;; Proclaim
;;;


(class Proclaim extends Expression
  
  
  (slot clauses getter generate))


;;;
;;;; Constant
;;;


(class Constant extends Expression
  
  
  (slot expansion getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}"
          expansion)))))


;;;
;;;; Delay
;;;


(class Delay extends Expression
  
  
  (slot expression getter generate))


;;;
;;;; Quasiquote
;;;


(class Quasiquote extends Expression
  
  
  (slot form        getter generate)
  (slot expressions getter generate))


;;;
;;;; Reference
;;;


(class Binding-Reference extends Expression
  
  
  (slot binding getter generate)
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{s}"
          binding)))))


;;;
;;;; Assignment
;;;


(class Assignment extends Expression
  
  
  (slot binding       getter generate)
  (slot value         getter generate)
  (slot symbol-source getter generate))


;;;
;;;; Lambda
;;;


(class Lambda extends Expression
  
  
  (slot signature getter generate)
  (slot body      getter generate))


;;;
;;;; Let
;;;


(class Let extends Expression
  
  
  (slot bindings getter generate)
  (slot body     getter generate)
  
  
  (method override (initialize self bindings body)
    (set! self.bindings bindings)
    (set! self.body body)))


;;;
;;;; Named Let
;;;


(class Named-Let extends Let
  
  
  (slot variable getter generate))


;;;
;;;; Letstar
;;;


(class Letstar extends Expression
  
  
  (slot bindings getter generate)
  (slot body     getter generate))


;;;
;;;; Letrec
;;;


(class Letrec extends Expression
  
  
  (slot bindings getter generate)
  (slot body     getter generate))


;;;
;;;; Receive
;;;


(class Receive extends Expression
  
  
  (slot variables  getter generate)
  (slot expression getter generate)
  (slot body       getter generate))


;;;
;;;; Body
;;;


(class Body extends Expression
  
  
  (slot internal-proclaims getter generate)
  (slot internal-defines   getter generate)
  (slot expressions        getter generate))


;;;
;;;; Internal Define
;;;


(class Internal-Define extends Expression
  
  
  (slot variable getter generate)
  (slot value    getter generate))



;;;
;;;; Internal-Define-Variable
;;;


(class Internal-Define-Variable extends Variable
  
  
  (slot signature getter generate))


;;;
;;;; Begin
;;;


(class Begin extends Expression
  
  
  (slot expressions getter generate)
  
  
  (method override (initialize self expressions)
    (set! self.expressions expressions)))


;;;
;;;; Do
;;;


(class Do extends Expression
  
  
  (slot bindings getter generate)
  (slot test     getter generate)
  (slot result   getter generate)
  (slot body     getter generate))


;;;
;;;; Call
;;;


(class Call extends Expression
  
  
  (slot operator  getter generate)
  (slot arguments getter generate))


;;;
;;;; If
;;;


(class If extends Expression
  
  
  (slot test getter generate)
  (slot yes  getter generate)
  (slot no   getter generate))


;;;
;;;; Cond
;;;


(class Cond extends Expression
  
  
  (slot clauses getter generate))


;;;
;;;; Case
;;;


(class Case extends Expression
  
  
  (slot target  getter generate)
  (slot clauses getter generate))


;;;
;;;; And
;;;


(class And extends Expression
  
  
  (slot expressions getter generate))


;;;
;;;; Or
;;;


(class Or extends Expression
  
  
  (slot expressions getter generate))


;;;
;;;; Declare
;;;


(class Declare extends Expression
  
  
  (slot declarations getter generate))


;;;
;;;; Parameterize
;;;


(class Parameterize extends Expression
  
  
  (slot bindings getter generate)
  (slot body     getter generate))


;;;
;;;; Unspecific
;;;


(class Unspecific extends Expression
  
  
  (slot expressions getter generate))


;;;
;;;; Analysis Data
;;;


(class Analysis-Data extends Object
  
  
  (slot autoload-reference     getter generate)
  (slot declaration-references getter generate))


;;;
;;;; Foundation Dialect
;;;


(class Foundation-Dialect extends Dialect)


;;;
;;;; Foundation Walker
;;;


(class Foundation-Walker extends Walker)


;;;
;;;; Define
;;;


(class Define-Declaration extends Declaration
  
  
  (slot signature        getter generate)
  (slot specifier-source getter generate)
  (slot value            getter generate))


;;;
;;;; Define Special Form
;;;


(class Define-Special-Form-Declaration extends Declaration
  
  
  (slot signature getter generate)
  (slot body      getter generate))


;;;
;;;; Define Macro
;;;


(class Define-Macro-Declaration extends Declaration
  
  
  (slot signature getter generate)
  (slot body      getter generate))


;;;
;;;; Dialect
;;;


(class Scheme-Dialect extends Dialect)


;;;
;;;; Walker
;;;


(class Scheme-Walker extends Walker)


;;;
;;;; Definition
;;;


(class Definition-Declaration extends Declaration
  
  
  (slot expansion        getter generate)
  (slot signature        getter generate)
  (slot specifier-source getter generate)
  (slot value            getter generate)
  
  
  (method override (initialize self . rest)
    (bind-keywords ((expansion #f) (signature #f) (specifier-source #f) . others) rest
      (apply nextmethod self others)
      (set! self.expansion expansion)
      (set! self.signature signature)
      (set! self.specifier-source specifier-source))))


;;;
;;;; Specialize
;;;


(class Specialize extends Expression)


;;;
;;;; Generic
;;;


(class Generic-Declaration extends Declaration
  
  
  (slot dispatch-types getter generate)
  (slot signature      getter generate)
  (slot body           getter generate))


;;;
;;;; Specific
;;;


(class Specific-Declaration extends Declaration
  
  
  (slot generic   getter generate)
  (slot signature getter generate)
  (slot body      getter generate)
  (slot root?     getter generate))


;;;
;;;; Category
;;;


(class Category-Declaration extends Namespace-Declaration
  
  
  (slot implementor         getter generate)
  (slot metaclass           getter generate)
  (slot metaclass-explicit? getter generate))


;;;
;;;; Class
;;;


(class Class-Declaration extends Category-Declaration
  
  
  (slot ascendant          getter generate)
  (slot ascendant-relation getter generate)
  (slot ascendant-base     getter generate)
  (slot interfaces         getter generate))


;;;
;;;; Interface
;;;


(class Interface-Declaration extends Category-Declaration
  
  
  (slot ascendants getter generate))


;;;
;;;; Field
;;;


(class Field-Declaration extends Declaration)


;;;
;;;; Slot
;;;


(class Slot-Declaration extends Field-Declaration
  
  
  (slot specifier-source  getter generate)
  (slot initialize        getter generate)
  (slot getter-name       getter generate)
  (slot setter-name       getter generate)
  (slot getter-generation getter generate)
  (slot setter-generation getter generate)
  (slot dynamic?          getter generate))


;;;
;;;; Property
;;;


(class Property-Declaration extends Slot-Declaration
  
  
  (slot getter getter generate)
  (slot setter getter generate))


;;;
;;;; Method
;;;


(class Method-Declaration extends Field-Declaration
  
  
  (slot root             getter generate)
  (slot propagation      getter generate)
  (slot abstraction      getter generate)
  (slot expansion        getter generate)
  (slot remote           getter generate)
  (slot synchronized     getter generate)
  (slot signature        getter generate)
  (slot specifier-source getter generate)
  (slot body             getter generate))


;;;
;;;; Hub
;;;


(class Hub-Declaration extends Declaration
  
  
  (slot hubs  getter generate)
  (slot nodes getter generate))


;;;
;;;; With Self
;;;


(class With-Self extends Expression
  
  
  (slot body getter generate))


;;;
;;;; With Dynamic Self
;;;


(class With-Dynamic-Self extends Expression
  
  
  (slot code getter generate)
  (slot body getter generate))


;;;
;;;; Cast
;;;


(class Cast extends Expression
  
  
  (slot expression getter generate))


;;;
;;;; Allocate
;;;


(class Allocate extends Expression
  
  
  (slot class  getter generate)
  (slot values getter generate))


;;;
;;;; Dialect
;;;


(class Jazz-Dialect extends Dialect)


;;;
;;;; Walker
;;;


(class Jazz-Walker extends Scheme-Walker))
