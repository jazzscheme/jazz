;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Functional
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.language.runtime.functional jazz.dialect


(proclaim (warn optimizations))


(import (jazz.language.runtime.hubs)
        (jazz.language.runtime.kernel)
        (jazz.language.runtime.object)
        (irregex))


(native private jazz:error)
(native private jazz:system-format)


;;;
;;;; Module
;;;


(class Module extends Object
  
  
  (slot name    getter generate)
  (slot access  getter generate)
  (slot exports getter generate)
  (slot entries getter generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" name)))))


;;;
;;;; Field
;;;


(class Field extends Object
  
  
  (slot name getter generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" name))))
  
  
  (method package virtual abstract (field-locator self))
  (method package virtual abstract (field-ref self))
  (method package virtual abstract (field-set! self value)))


;;;
;;;; Native
;;;


(class Native extends Field
  
  
  (slot symbol getter generate)
  
  
  (method override (field-locator self)
    symbol)
  
  
  (method override (field-ref self)
    (and (global-bound? symbol)
         (global-ref symbol)))
  
  
  (method override (field-set! self value)
    (when (global-bound? symbol)
      (global-set! symbol value))))


;;;
;;;; Runtime-Reference
;;;


(class Runtime-Reference extends Object
  
  
  (slot resolver      getter generate)
  (slot serialization getter generate))


;;;
;;;; Define
;;;


(class Define extends Field
  
  
  (slot locator getter generate)
  
  
  (method override (field-locator self)
    locator)
  
  
  (method override (field-ref self)
    (global-ref locator))
  
  
  (method override (field-set! self value)
    (global-set! locator value)))


;;;
;;;; Definition
;;;


(class Definition extends Field
  
  
  (slot locator getter generate)
  
  
  (method override (field-locator self)
    locator)
  
  
  (method override (field-ref self)
    (global-ref locator))
  
  
  (method override (field-set! self value)
    (global-set! locator value)))


;;;
;;;; Type
;;;


(class Type extends Object
  
  
  (method core virtual (of-type? self object))
  (method core virtual (of-subtype? self subtype))
  (method core virtual (specifiable? self))
  (method core virtual (category-type? self))
  (method core virtual (resolve-type self))
  (method core virtual (emit-specifier self))
  (method core virtual (emit-type self source-declaration environment backend))
  (method core virtual (emit-test self value source-declaration environment backend))
  (method core virtual (emit-cast self value source-declaration environment backend)))


;;;
;;;; Category
;;;


(class Category extends Type
  
  
  (slot identifier   getter generate)
  (slot fields       getter generate)
  (slot virtual-size getter generate)
  (slot ancestors    getter generate)   ;; all the ancestors up to the root
  (slot descendants  getter generate)   ;; only the direct descendants
  
  
  (method core virtual (update-category self))
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" (get-name self)))))
  
  
  (method public (get-name self)
    identifier)
  
  
  (method public virtual (mop-category-field self field-name)
    (category-field self field-name))
  
  
  (method public virtual (mop-field-value self property)
    ))


(definition public (typed? obj category-identifier)
  (some? (lambda (category <Category>)
           (eq? (get-name category) category-identifier))
         (get-ancestors (class-of obj))))


;;;
;;;; Class
;;;


(class Class extends Category
  
  
  (slot ascendant       getter generate)
  (slot interfaces      getter generate)
  (slot slots           getter generate)
  (slot instance-slots  getter generate)
  (slot instance-size   getter generate)
  (slot level           getter generate)
  (slot virtual-names   getter generate)
  (slot class-table     getter generate)
  (slot interface-table getter generate)
  (slot user-data       getter generate)
  
  
  (method public virtual (coerce-object self obj)
    (error "Unable to coerce {t} into a {t}" obj (category-name self)))
  
  
  (method public virtual (external-name self (error?: error? #t))
    (and error? (error "{t} class does not define an external name" (category-name self))))
  
  
  (method public virtual (marshall-object self object)
    #f)
  
  
  (method public virtual (unmarshall-object self content)
    #f)
  
  
  (method public virtual (mop-instance-slots self object)
    (get-instance-slots self)))


(class Object-Class metaclass Class extends Class)


(definition public inline (class? obj)
  (is? obj Class))


(definition public inline (instance-of? obj class)
  (eq? (class-of obj) class))


(definition public inline (coerce object <Object> class <Class>)
  (if (is? object class)
      object
    (coerce-object class object)))


;;;
;;;; Interface
;;;


(class Interface extends Category
  
  
  (slot ascendants getter generate)
  (slot rank       getter generate))


;;;
;;;; Method
;;;


(class Method extends Field
  
  
  (slot dispatch-type       getter generate)
  (slot implementation      getter generate)
  (slot implementation-tree getter generate)
  (slot category-rank       getter generate)
  (slot implementation-rank getter generate))


;;;
;;;; Method Node
;;;


(class Method-Node extends Object
  
  
  (slot category            getter generate)
  (slot implementation      getter generate)
  (slot next-node           getter generate)
  (slot next-implementation getter generate)
  (slot children            getter generate))


;;;
;;;; Call-Site
;;;


(class Call-Site extends Object
  
  
  (slot name       accessors generate)
  (slot identifier accessors generate)
  (slot id         accessors generate)
  (slot parent     accessors generate)
  (slot properties accessors generate)
  (slot procedure  accessors generate)
  (slot monitor    accessors generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" identifier)))))


;;;
;;;; Queue
;;;


(class Queue extends Object
  
  
  (slot head   getter generate)
  (slot tail   getter generate)
  (slot shared getter generate))


;;;
;;;; Generic
;;;


(class Generic extends Object
  
  
  (slot locator              getter generate)
  (slot name                 getter generate)
  (slot root-specific        getter generate)
  (slot pending-specifics    getter generate))


(class Specific extends Object
  
  
  (slot dynamic-signature    getter generate)
  (slot implementation       getter generate)
  (slot ancestor-specifics   getter generate)
  (slot descendant-specifics getter generate))


;;;
;;;; Bool
;;;


(class Bool-Class extends Class)


(class primitive Bool metaclass Bool-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "bools")))


;;;
;;;; Boolean
;;;


(class Boolean-Class extends Class)


(class primitive Boolean metaclass Boolean-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "booleans")))


(definition public inline (/= x y)
  (not (= x y)))


(definition public inline (neq? x y)
  (not (eq? x y)))


(definition public inline (xor x y)
  (or (and x (not y))
      (and (not x) y)))


(definition public (nu=? n m . rest)
  (and (eq? (compare n m) :equal)
       (let ((first m))
         (let (iter (scan rest))
           (cond ((null? scan)
                  #t)
                 ((neq? (compare (car scan) first) :equal)
                  #f)
                 (else
                  (iter (cdr scan))))))))


(definition public (nu/=? n m . rest)
  (if (null? rest)
      (neq? (compare n m) :equal)
    (not (apply nu=? n m rest))))


(definition public (nu<? n m . rest)
  (and (case (compare n m)
         ((:less) #t)
         ((:greater :equal) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (max m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare max value)
               ((:less) (iter (cdr scan) value))
               ((:greater :equal) #f)
               (else (error "Cannot compare {t} and {t}" max value))))))))


(definition public (nu<=? n m . rest)
  (and (case (compare n m)
         ((:less :equal) #t)
         ((:greater) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (max m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare max value)
               ((:less :equal) (iter (cdr scan) value))
               ((:greater) #f)
               (else (error "Cannot compare {t} and {t}" max value))))))))


(definition public (nu>? n m . rest)
  (and (case (compare n m)
         ((:greater) #t)
         ((:less :equal) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (min m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare min value)
               ((:greater) (iter (cdr scan) value))
               ((:less :equal) #f)
               (else (error "Cannot compare {t} and {t}" min value))))))))


(definition public (nu>=? n m . rest)
  (and (case (compare n m)
         ((:greater :equal) #t)
         ((:less) #f)
         (else (error "Cannot compare {t} and {t}" n m)))
       (let (iter (scan rest) (min m))
         (if (null? scan)
             #t
           (let ((value (car scan)))
             (case (compare min value)
               ((:greater :equal) (iter (cdr scan) value))
               ((:less) #f)
               (else (error "Cannot compare {t} and {t}" min value))))))))


(definition public (ci=? . rest)
  (if (null? rest)
      #t
    (let ((first (car rest)))
      (loop (for object in (cdr rest))
            (when (neq? (ci-compare object first) :equal)
              (return #f))
            (finally #t)))))


(definition public (ci/=? . rest)
  (not (apply ci=? rest)))


(definition public (ci<? n . rest)
  (let (iter (scan rest) (max n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare max value)
          ((:less) (iter (cdr scan) value))
          ((:greater :equal) #f)
          (else (error "Cannot ci-compare {t} and {t}" max value)))))))


(definition public (ci<=? n . rest)
  (let (iter (scan rest) (max n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare max value)
          ((:less :equal) (iter (cdr scan) value))
          ((:greater) #f)
          (else (error "Cannot ci-compare {t} and {t}" max value)))))))


(definition public (ci>? n . rest)
  (let (iter (scan rest) (min n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare min value)
          ((:greater) (iter (cdr scan) value))
          ((:less :equal) #f)
          (else (error "Cannot ci-compare {t} and {t}" min value)))))))


(definition public (ci>=? n . rest)
  (let (iter (scan rest) (min n))
    (if (null? scan)
        #t
      (let ((value (car scan)))
        (case (ci-compare min value)
          ((:greater :equal) (iter (cdr scan) value))
          ((:less) #f)
          (else (error "Cannot ci-compare {t} and {t}" min value)))))))


(definition public (di=? x y)
  (eq? (di-compare x y) :equal))

(definition public (di<? x y)
  (eq? (di-compare x y) :less))

(definition public (di<=? x y)
  (memq? (di-compare x y) '(:less :equal)))

(definition public (di>? x y)
  (eq? (di-compare x y) :greater))

(definition public (di>=? x y)
  (memq? (di-compare x y) '(:greater :equal)))


(definition public (di-sort-ascending seq (key: key #f))
  (sort (lambda (x y)
          (or (di<? x y)
              (and (di=? x y)
                   (nu<? x y))))
        seq
        key: key))


(definition public (di-sort-descending seq (key: key #f))
  (sort (lambda (x y)
          (or (di>? x y)
              (and (di=? x y)
                   (nu>? x y))))
        seq
        key: key))


(definition public inline (boolean->integer bool)
  (if bool 1 0))


(definition public inline (integer->boolean n <int>)
  (/= n 0))


;;;
;;;; Truth
;;;


(definition public false
  (list 'false))


(definition public inline (false? obj)
  (eq? obj false))


(definition public true
  (list 'true))


(definition public inline (true? obj)
  (eq? obj true))


(definition public (truth? obj)
  (or (false? obj)
      (true? obj)))


(definition public (boolean->truth bool)
  (if bool true false))


(definition public (truth->boolean data)
  (true? data))


;;;
;;;; Char
;;;


(definition public Whitespace-Chars
  '(#\space #\tab #\return #\newline #\page))

(definition public Uppercase-Chars
  '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))

(definition public Lowercase-Chars
  '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))

(definition public Alphabetic-Chars
  (append Uppercase-Chars Lowercase-Chars))

(definition public Numeric-Chars
  '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))


(definition Uppercase-Lowerbound <fx>
  (char->integer #\A))

(definition Uppercase-Upperbound <fx>
  (char->integer #\Z))

(definition Lowercase-Lowerbound <fx>
  (char->integer #\a))

(definition Lowercase-Upperbound <fx>
  (char->integer #\z))

(definition Numeric-Lowerbound <fx>
  (char->integer #\0))

(definition Numeric-Upperbound <fx>
  (char->integer #\9))


;; putting the uppercase chars here is a quick fix until
;; we add diacritic awareness to upcase and downcase
(definition Diacritic-Equivalences
  '((#\a #\à #\â #\A #\À #\Â)
    (#\c #\ç #\C #\Ç)
    (#\e #\é #\è #\ê #\ë #\E #\É #\È #\Ê #\Ë)
    (#\i #\î #\ï #\I #\Î #\Ï)
    (#\o #\ô #\O #\Ô)
    (#\u #\ù #\û #\U #\Ù #\Û)))


(definition (make-diacritic-table equivalences) <table>
  (let ((table (make-table test: eqv?)))
    (for-each (lambda (equivalences)
                (let ((equivalent (car equivalences)))
                  (for-each (lambda (char)
                              (table-set! table char equivalent))
                            equivalences)))
              equivalences)
    table))

(definition Diacritic-Table <table>
  (make-diacritic-table Diacritic-Equivalences))


(definition public (diacritic-equivalent c)
  (or (table-ref Diacritic-Table c #f)
      c))


(class Char-Class extends Class)


(class primitive Char metaclass Char-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "chars"))
  
  
  (method override (coerce-string self)
    (let ((port (open-output-string)))
      (write-char self port)
      (get-output-string port)))
  
  
  (method override (compare-object self c)
    (if (is? c Char)
        (let ((v1 (char->integer self))
              (v2 (char->integer c)))
          (cond ((= v1 v2) :equal)
                ((> v1 v2) :greater)
                (else      :less)))
      :incompatible))
  
  
  (method override (ci-compare-object self c)
    (compare (downcase self)
             (downcase c)))
  
  
  (method override (di-compare-object self c)
    (ci-compare (diacritic-equivalent self)
                (diacritic-equivalent c)))
  
  
  (method override (object-similar? self object)
    (unimplemented 'object-similar?)
    @convert
    (and (char? object)
         (char-similar? self object)))


  (method override (object-alphabetic? self)
    (or (object-upper-case? self)
        (object-lower-case? self)))


  (method override (object-numeric? self)
    (let ((n (char->integer self)))
      (and (>= n Numeric-Lowerbound)
           (<= n Numeric-Upperbound))))


  (method override (object-alphanumeric? self)
    (or (object-alphabetic? self)
        (object-numeric? self)))


  (method override (object-whitespace? self)
    (or (eqv? self #\space)
        (eqv? self #\tab)
        (eqv? self #\return)
        (eqv? self #\newline)
        (eqv? self #\page)))


  (method override (object-upper-case? self)
    (let ((n (char->integer self)))
      (and (>= n Uppercase-Lowerbound)
           (<= n Uppercase-Upperbound))))


  (method override (object-lower-case? self)
    (let ((n (char->integer self)))
      (and (>= n Lowercase-Lowerbound)
           (<= n Lowercase-Upperbound))))


  (method override (object-upcase self)
    (if (lower-case? self)
        (integer->char (- (char->integer self) 32))
      self))


  (method override (object-downcase self)
    (if (upper-case? self)
        (integer->char (+ (char->integer self) 32))
      self))


  (method override (object-capitalize self)
    (object-upcase self)))


(definition whitechar?
  char-whitespace?)


(definition public (char-presentation char)
  (or (char-symbol char)
      (string char)))


(definition public inline (alphabetic? object <Object>)
  (object-alphabetic? object))


(definition public inline (numeric? object <Object>)
  (object-numeric? object))


(definition public inline (alphanumeric? object <Object>)
  (object-alphanumeric? object))


(definition public inline (whitespace? object <Object>)
  (object-whitespace? object))


(definition public inline (upper-case? object <Object>)
  (object-upper-case? object))


(definition public inline (lower-case? object <Object>)
  (object-lower-case? object))


(definition public inline (upcase object <Object>)
  (object-upcase object))


(definition public inline (downcase object <Object>)
  (object-downcase object))


(definition public inline (capitalize object <Object>)
  (object-capitalize object))


(definition public (upcase-capitalized str)
  (let ((len (string-length str)))
    (let (iter (from 0)
               (to 1)
               (upcased ""))
      (if (>= to len)
          (string-append upcased (upcase (substring str from to)))
        (let ((c (string-ref str to)))
          (if (upper-case? c)
              (iter to (+ to 1) (string-append upcased (upcase (substring str from to)) "_"))
            (iter from (+ to 1) upcased)))))))


(definition public (vowel? c)
  (memv? (downcase c) '(#\a #\e #\i #\o #\u #\y)))


(definition character-types
  #(invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    backspace     whitespace    whitespace    invalid       invalid       whitespace    invalid       invalid
    invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    invalid       invalid       invalid       invalid       invalid       invalid       invalid       invalid
    whitespace    constituent   string        sharp         constituent   constituent   constituent   quote        ;   ! " # $ % & '
    list          terminator    constituent   constituent   unquote       constituent   constituent   constituent  ; ( ) * + , - . /
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; 0 1 2 3 4 5 6 7
    constituent   constituent   constituent   comment       constituent   constituent   constituent   constituent  ; 8 9 : ; < = > ?
    exprcomment   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; @ A B C D E F G
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; H I J K L M N O
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; P Q R S T U V W
    constituent   constituent   constituent   reference     backslash     terminator    constituent   constituent  ; X Y Z [ \ ] ^ _
    quasiquote    constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; ` a b c d e f g
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; h i j k l m n o
    constituent   constituent   constituent   constituent   constituent   constituent   constituent   constituent  ; p q r s t u v w
    constituent   constituent   constituent   literal       symbol        terminator    constituent   delete))     ; x y z { | } ~


(definition public (character-type ascii-c <char>) <symbol>
  (let ((num (char->integer ascii-c)))
    (if (> num 127)
        'constituent
      (vector-ref character-types (char->integer ascii-c)))))


(definition public (invalid-character? c <char>) <bool>
  (eq? (character-type c) 'invalid))


(definition public (word-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (memq? c '(#\_ #\- #\@))))


(definition public (scheme-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eq? (character-type c) 'constituent)
      (eqv? c #\#)
      (eqv? c #\@)))


(definition public (jazz-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eq? (character-type c) 'constituent)
      (eqv? c #\#)))


(definition public (c-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eqv? c #\_)))


(definition public (sql-constituent? c <char>) <bool>
  (or (alphanumeric? c)
      (eqv? c #\_)
      (eqv? c #\@)
      (eqv? c #\[)
      (eqv? c #\])))


;;;
;;;; Port
;;;


(class Port-Class extends Class)


(class primitive Port metaclass Port-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "ports"))
  
  
  (method override (destroy self)
    (close-port self)
    (nextmethod self)))


;;;
;;;; Symbol
;;;


(class Symbol-Class extends Class)


(class primitive Symbol metaclass Symbol-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "symbols"))
  
  
  (method override (coerce-string self)
    (symbol->string self))
  
  
  (method override (compare-object self obj)
    (if (symbol? obj)
        (compare (symbol->string self) (symbol->string obj))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (if (symbol? obj)
        (ci-compare (symbol->string self) (symbol->string obj))
      :incompatible)))


(specialize inline (= s1 <symbol> s2 <symbol>) <bool>
  (eq? s1 s2))


(definition public (generated-symbol? symbol)
  (starts-with? (symbol->string symbol) "__"))


(definition public inline (symbol->keyword symbol)
  (string->keyword (symbol->string symbol)))


(definition public inline (keyword->symbol keyword)
  (string->symbol (keyword->string keyword)))


(definition public (find-symbol str)
  ;; convert : this is not really correct
  (string->symbol str))


(definition public (symbol-bound? name . rest)
  ;; convert : this is not really correct
  #t)
(definition public (symbol-unbound? name . rest)
  ;; convert : this is not really correct
  #f)


;;;
;;;; Keyword
;;;


(class Keyword-Class extends Class)


(class primitive Keyword metaclass Keyword-Class extends Object
  
  
  (method override (initialize self . rest)
    (native-class "keywords")))


(definition public (find-keyword keyword box default (allow-other-keys? #f))
  (let (lp (ls (unbox-list box)) (before box))
    (cond ((null? ls)
           (default))
          ((or (not (pair? ls))
               (not (pair? (cdr ls)))
               (not (keyword? (car ls))))
           (if allow-other-keys?
               (default)
             (error "Bad keyword list: {s}" (unbox-list box))))
          ((eq? keyword (car ls))
           (set-cdr! before (cddr ls))
           (cadr ls))
          (else
           (lp (cddr ls) (cdr ls))))))


;; this is a specialized implementation of the box concept
;; to enable an optimisation in the find-keyword code above


(definition package (box-list lst)
  (cons '() lst))


(definition package (unbox-list box)
  (cdr box))


;;;
;;;; Continuation
;;;


(class Continuation-Class extends Class)


(class primitive Continuation metaclass Continuation-Class extends Object)


;;;
;;;; Procedure
;;;


(class Procedure-Class extends Class)


(class primitive Procedure metaclass Procedure-Class extends Object)


;;;
;;;; Foreign
;;;


(class Foreign-Class extends Class)


(class primitive Foreign metaclass Foreign-Class extends Object)


;;;
;;;; Numeric
;;;


(class Numeric-Class extends Class)


(class primitive Numeric metaclass Numeric-Class extends Object


  (method public virtual abstract (numeric-norm self))
  (method public virtual abstract (numeric-add self obj))
  (method public virtual abstract (numeric-negate self))
  (method public virtual abstract (numeric-multiply self n))
  (method public virtual abstract (numeric-inverse self)))


;;;
;;;; Number
;;;


(class Number-Class extends Numeric-Class)


(class primitive Number metaclass Number-Class extends Numeric
  
  
  (method override (initialize self . rest)
    (native-class "numbers"))
  
  
  (method override (compare-object self obj)
    (if (number? obj)
        (cond ((= self obj) :equal)
              ((< self obj) :less)
              (else :greater))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (compare-object self obj))
  
  
  (method override (di-compare-object self obj)
    (compare-object self obj))
  
  
  (method override (numeric-norm self)
    (abs self))
  
  
  (method override (numeric-add self obj)
    (if (number? obj)
        (+ self obj)
      (error "Unsupported nu+ : {t} {t}" self obj)))
  
  
  (method override (numeric-negate self)
    (- self))
  
  
  (method override (numeric-multiply self obj)
    (if (number? obj)
        (* self obj)
      (error "Unsupported nu* : {t} {t}" self obj)))
  
  
  (method override (numeric-inverse self)
    (/ self)))


;;;
;;;; Complex
;;;


(class Complex-Class extends Number-Class)


(class primitive Complex metaclass Complex-Class extends Number
  
  
  (method override (numeric-norm self)
    (sqrt (+ (expt (real-part self) 2) (expt (imag-part self) 2)))))


;;;
;;;; Real
;;;


(class Real-Class extends Complex-Class)


(class primitive Real metaclass Real-Class extends Complex)


;;;
;;;; Rational
;;;


(class Rational-Class extends Real-Class)


(class primitive Rational metaclass Rational-Class extends Real)


(definition public (rational->decimalstring fraction precision)
  (unless (and (rational? fraction)
               (exact? fraction))
    (error "Fraction must be a rational: {s}" fraction))
  
  (unless (and (integer? precision)
               (>= precision 0))
    (error "Precision must be an integer greater or equal than 0: {s}" precision))
  
  (let ((port (open-output-string))
        (num (abs (numerator fraction)))
        (denum (denominator fraction)))
    
    (when (< (numerator fraction) 0)
      (display "-" port))
    
    (display (quotient num denum) port)
    (display "." port)
    
    (let (iter (remain (* (remainder num denum) 10))
               (p precision))
      (when (and (> remain 0)
                 (> p 0))
        (let ((quo (quotient remain denum)))
          (display quo port)
          (iter (* (- remain (* quo denum)) 10)
                (- p 1))))
      ;; pad with zeros to match precision
      (when (and (<= remain 0)
                 (> p 0))
        (display "0" port)
        (iter (- 1) (- p 1))))
    
    (get-output-string port)))


;;;
;;;; Integer
;;;


(class Integer-Class extends Rational-Class)


(class primitive Integer metaclass Integer-Class extends Rational)


;;;
;;;; Fixnum
;;;


(class Fixnum-Class extends Integer-Class)


(class primitive Fixnum metaclass Fixnum-Class extends Integer)


;;;
;;;; Ratnum
;;;


(class Ratnum-Class extends Rational-Class)


(class primitive Ratnum metaclass Ratnum-Class extends Rational)


;;;
;;;; Flonum
;;;


(class Flonum-Class extends Real-Class)


(class primitive Flonum metaclass Flonum-Class extends Real)


(definition public (fl x) <fl>
  (cond ((flonum? x) x)
        ((fixnum? x) (cast <fl> x))
        (else (error "Unable to convert into a float: {s}" x))))


(definition public (flmodulo x <fl> y <fl>) <fl>
  (- x (* (floor (/ x y)) y)))


(definition public (flsign x <fv>) <fl>
  (cond ((< x 0.) -1.)
        ((> x 0.)  1.)
        (else      0.)))


;;;
;;;; Flovec
;;;


(class Flovec-Class extends Flonum-Class)


(class primitive Flovec metaclass Flovec-Class extends Flonum)


;;;
;;;; S64
;;;


(class S64-Class extends Integer-Class)


(class primitive S64 metaclass S64-Class extends Integer)


;;;
;;;; Numbers
;;;


(definition public (relate x y) <fx>
  (cond ((< x y) -1)
        ((> x y)  1)
        (else     0)))


(definition public (sign n) <fx>
  (relate n 0))


(definition public (nu+ . rest)
  (if (null? rest)
      0
    (let (iter (result <Numeric> (car rest)) (scan (cdr rest)))
      (if (null? scan)
          result
        (iter (numeric-add result (car scan)) (cdr scan))))))


(definition public (nu- n <Numeric> . rest)
  (if (null? rest)
      (numeric-negate n)
    (let ((r <Numeric> (apply nu+ rest)))
      (nu+ n (numeric-negate r)))))


(definition public (nu* . rest)
  (if (null? rest)
      1
    (let (iter (result <Numeric> (car rest)) (scan (cdr rest)))
      (if (null? scan)
          result
        (iter (numeric-multiply result (car scan)) (cdr scan))))))


(definition public (nu/ n <Numeric> . rest)
  (if (null? rest)
      (numeric-inverse n)
    (let ((r <Numeric> (apply nu* rest)))
      (nu* n (numeric-inverse r)))))


(definition public (minimum lst <pair> (key: key #f) (compare: compare compare))
  (let ((min (car lst)))
    (for-each (lambda (object)
                (when (eq? (compare (apply-key key object) (apply-key key min)) :less)
                  (set! min object)))
              (cdr lst))
    min))


(definition public (maximum lst <pair> (key: key #f) (compare: compare compare))
  (let ((max (car lst)))
    (for-each (lambda (object)
                (when (eq? (compare (apply-key key object) (apply-key key max)) :greater)
                  (set! max object)))
              (cdr lst))
    max))


(definition public inline (between? n lower upper)
  (and (>= n lower)
       (<= n upper)))


(definition public inline (between lower n upper)
  (cond ((< n lower) lower)
        ((> n upper) upper)
        (else n)))


(definition public inline (in-interval? n lower upper)
  (and (>= n lower)
       (< n upper)))


(definition public inline (between-interval lower n upper)
  (cond ((< n lower) lower)
        ((>= n upper) (- upper 1))
        (else n)))


(definition public inline (norm x <Numeric>)
  (numeric-norm x))


(definition public (distance start <Numeric> end <Numeric>)
  (norm (nu- end start)))


(definition public (near? x y distance) <bool>
  (<= (norm (nu- x y)) distance))


(definition public (contiguous-range lst)
  (and (not-null? lst)
       (continuation-capture
         (lambda (return)
           (let* ((first (car lst))
                  (second first))
             (for-each (lambda (n)
                         (if (= n (+ second 1))
                             (set! second n)
                           (continuation-return return #f)))
                       (cdr lst))
             (cons first second))))))


(definition public (naturals lower <int> upper <int>) <list>
  (loop (for n from lower below upper)
        (collect n)))


(definition public (lobyte word <int>) <int>
  (bitwise-and #xFF word))


(definition public (hibyte word <int>) <int>
  (lobyte (arithmetic-shift word -8)))


(definition public (make-word lo <int> hi <int>) <int>
  (bitwise-ior (arithmetic-shift hi 8) lo))


(definition public (lochar word <int>) <int>
  (- (bitwise-and (+ word #x80) #xFF) #x80))


(definition public (hichar word <int>) <int>
  (lochar (arithmetic-shift word -8)))


(definition public (make-int lo <int> hi <int>) <int>
  (bitwise-ior (arithmetic-shift hi 16) lo))


(definition public (loword dword <int>) <int>
  (bitwise-and dword #xFFFF))


(definition public (hiword dword <int>) <int>
  (loword (arithmetic-shift dword -16)))


(definition public (signed-loword dword <int>) <int>
  (- (bitwise-and (+ dword #x8000) #xFFFF) #x8000))


(definition public (signed-hiword dword <int>) <int>
  (signed-loword (arithmetic-shift dword -16)))


(definition public (sign-word word <int>) <int>
  (if (bit-set? 15 word)
      (- word #x10000)
    word))


(definition public (separate int1 <int> int2 <int>)
  (let* ((q (quotient int1 int2))
         (r (- int1 (* q int2))))
    (values q r)))


(definition public (randomize)
  (random-source-randomize! default-random-source))

(definition public (random n)
  (random-integer n))


(definition public (bit-set num <int> pos <int> bit <bool>) <int>
  (let ((msk (arithmetic-shift 1 pos)))
    (if bit
        (bitwise-ior num msk)
      (bitwise-and num (bitwise-not msk)))))


(definition public (mask-bit-set num <int> msk <int> bit <bool>) <int>
  (if bit
      (bitwise-ior num msk)
    (bitwise-and num (bitwise-not msk))))


(definition public (mask-bit-set? num <int> msk <int>) <bool>
  (/= (bitwise-and num msk) 0))


(definition public (bit-mask hi <int> lo <int>)
  (- (arithmetic-shift 1 hi) (arithmetic-shift 1 lo)))


(definition public (random-seed (seed #f))
  (if seed
      (random-source-pseudo-randomize! default-random-source (first seed) (second seed))
    (randomize)
    (random 10000)
    (random 10000)))


(definition public inline (sqr num)
  (expt num 2))


(definition public inline (percentage part <real> total <real>) <real>
  (* (/ (cast <fl> part) total) 100))


(definition public inline (percent percent <real> n <real>) <real>
  (/ (cast <fl> (* n percent)) 100))


(definition public inline (fxfloor r <fl>) <fx>
  (flonum->fixnum (floor r)))

(definition public inline (fxceiling r <fl>) <fx>
  (flonum->fixnum (ceiling r)))

(definition public inline (fxtruncate r <fl>) <fx>
  (flonum->fixnum (truncate r)))

(definition public inline (fxround r <fl>) <fx>
  (flonum->fixnum (round r)))


;; these could potentialy optimize out the flonum operation

(definition public inline (fxfloor/ n <fx> d <fx>) <fx>
  (fxfloor (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxceiling/ n <fx> d <fx>) <fx>
  (fxceiling (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxtruncate/ n <fx> d <fx>) <fx>
  (fxtruncate (/ (cast <fl> n) (cast <fl> d))))

(definition public inline (fxround/ n <fx> d <fx>) <fx>
  (fxround (/ (cast <fl> n) (cast <fl> d))))


;;;
;;;; Iterator
;;;


(class package Iterator extends Object


  (definition Empty
    '(empty))


  (slot peeked initialize Empty)
  
  
  (method override (iterate-object self)
    self)


  (method public virtual (get-next self)
    (prog1 (peek self)
      (next self)))


  (method public virtual (peek self)
    (when (eq? peeked Empty)
      (set! peeked (next self)))
    peeked)
  
  
  (method public virtual (unget self object)
    (if (eq? peeked Empty)
        (set! peeked object)
      (error "Unable to unget {t}" object)))


  (method public virtual (next self)
    (cond ((eof-object? peeked)
           peeked)
          ((neq? peeked Empty)
           (prog1 peeked
             (set! peeked Empty)))
          (else
           (get-next! self))))


  (method public virtual (done? self) <bool>
    (eof-object? (peek self)))


  (method public virtual (get-next! self)
    )


  (method public virtual (put self object)
    (error "This iterator cannot put"))


  (method public virtual (get-position self)
    (error "This iterator cannot get position: {t}" self))


  (method public virtual (set-position self pos)
    (error "This iterator cannot set position: {t}" self))


  (method public virtual (get-state self)
    #f)


  (method public virtual (reset-state self old)
    ))


(definition public inline (iterator obj <Object>) <Iterator>
  (iterate-object obj))


;;;
;;;; Explorer
;;;


(class package Explorer extends Iterator


  (slot direction initialize 'forward setter generate)


  (method protected virtual (peek-forward self)
    (error "You need to implement peek-forward"))


  (method protected virtual (peek-backward self)
    (error "You need to implement peek-backward"))


  (method override (peek self)
    (if (done? self)
        (eof-object)
      (case direction
        ((forward)  (peek-forward self))
        ((backward) (peek-backward self)))))


  (method public virtual (goto-beginning self)
    (error "You need to implement goto-beginning"))


  (method public virtual (goto-end self)
    (error "You need to implement goto-end"))


  (method public virtual (forward self)
    (error "You need to implement forward"))


  (method public virtual (backward self)
    (error "You need to implement backward"))


  (method override (next self)
    (and (not (done? self))
         (case direction
           ((forward)  (forward self))
           ((backward) (backward self)))))


  (method protected virtual (done-forward? self)
    (error "You need to implement done-forward?"))


  (method protected virtual (done-backward? self)
    (error "You need to implement done-backward?"))


  (method override (done? self)
    (case direction
      ((forward)  (done-forward? self))
      ((backward) (done-backward? self))))


  (method protected virtual (put-forward self object)
    (error "This iterator cannot put forward"))


  (method protected virtual (put-backward self object)
    (error "This iterator cannot put backward"))


  (method override (put self object)
    (case direction
      ((forward)  (put-forward self object))
      ((backward) (put-backward self object)))))


(definition public (explore object <Object> . rest) <Explorer>
  ;; this will become specializers
  (apply new Sequence-Explorer object rest))


;;;
;;;; Sequence
;;;


(definition (coerce-sequence seq class)
  (let ((len (cardinality seq)))
    (let ((new-sequence (make-sequence class len)))
      (loop (for n from 0 below len)
            (for elem in-sequence seq)
            (set-element! new-sequence n elem))
      new-sequence)))


(class Sequence-Class extends Class
  
  
  (method public virtual abstract (make-sequence self len <int>))
  
  
  (method override (coerce-object self seq)
    (coerce-sequence seq self)))


(class primitive Sequence metaclass Sequence-Class extends Object
  
  
  (method override (coerce-string self)
    (coerce-sequence self String))

  
  (method override (compare-object self seq)
    (if (is? seq Sequence)
        (compare-sequence self seq compare)
      :incompatible))
  
  
  (method override (di-compare-object self seq)
    (compare-sequence self seq di-compare))
  
  
  (method override (copy-object self deep? <bool>)
    (let* ((subcopy (if deep? (lambda (x) (subcopy x deep?)) identity))
           (len (cardinality self))
           (new-seq (make-sequence (class-of self) len)))
      (let (iter (i <fx> 0))
        (if (= i len)
            new-seq
          (begin
            (set-element! new-seq i (subcopy (element self i)))
            (iter (+ i 1)))))))
  
  
  (method override (iterate-object self)
    (new Sequence-Explorer self))


  (method override (object-alphabetic? self)
    (every? alphabetic? self))


  (method override (object-numeric? self)
    (every? numeric? self))


  (method override (object-alphanumeric? self)
    (every? alphanumeric? self))


  (method override (object-whitespace? self)
    (every? whitespace? self))


  (method override (object-upper-case? self)
    (every? upper-case? self))


  (method override (object-lower-case? self)
    (every? lower-case? self))


  (method override (object-upcase self)
    (accumulate self upcase (class-of self)))


  (method override (object-downcase self)
    (accumulate self downcase (class-of self)))


  (method override (object-capitalize self)
    (let ((break? #t))
      (accumulate self
                  (lambda (object)
                    (if (alphanumeric? object)
                        (if (not break?)
                            object
                          (set! break? #f)
                          (upcase object))
                      (set! break? #t)
                      object))
                  (class-of self))))
  
  
  (method package virtual abstract (sequence-element self n <fx>) <any>)
  
  
  (method package virtual abstract (sequence-set-element! self n <fx> obj <any>) <void>)
  
  
  (method package virtual abstract (sequence-cardinality self) <fx>)
  
  
  (method package virtual abstract (sequence-tail self start))
  
  
  (method package virtual abstract (sequence-last self))
  
  
  (method package virtual abstract (sequence-butlast self))
  
  
  (method package virtual (sequence-subseq! self start <fx> end <fx>)
    (if (and (= start 0) (= end -1))
        self
      (new Subseq self start (- (if (= end -1) (cardinality self) end) start))))


  (method package virtual (sequence-replace-subseq! self start <fx> end <fx> replacement)
    (concatenate! (subseq self 0 start)
                  replacement
                  (subseq self end (cardinality self))))
  
  
  (method public (empty? self)
    (= 0 (cardinality self)))
  
  
  (method public (laden? self)
    (/= 0 (cardinality self))))


(definition public inline (sequence? obj)
  (is? obj Sequence))


(definition public inline (element seq <Sequence> n <int>) <any>
  (sequence-element seq n))


(definition public inline (set-element! seq <Sequence> n <int> obj <any>) <void>
  (sequence-set-element! seq n obj))


(definition public inline (cardinality seq <Sequence>) <int>
  (sequence-cardinality seq))


(definition public inline (tail seq <Sequence> start)
  (sequence-tail seq start))


(definition public inline (last seq <Sequence>)
  (sequence-last seq))


(definition public inline (butlast seq <Sequence>)
  (sequence-butlast seq))


(definition public (compare-sequence s1 s2 compare)
  (let ((l1 (cardinality s1))
        (l2 (cardinality s2)))
    (let (iter (i <fx> 0))
      (if (or (>= i l1) (>= i l2))
          (cond ((= l1 l2) :equal)
                ((> l1 l2) :greater)
                (else      :less))
        (let ((cmp (compare (element s1 i) (element s2 i))))
          (if (eq? cmp :equal)
              (iter (+ i 1))
            cmp))))))


(definition public (skip-whitespace seq <Sequence> (start: start #f))
  (let ((card (cardinality seq)))
    (let (iter (i <fx> (or start 0)))
      (cond ((= i card) i)
            ((memv? (element seq i) '(#\space #\tab)) (iter (+ i 1)))
            (else i)))))


(definition public (subseq seq start (end #f) (type #f))
  (declare (proper-tail-calls))
  (let* ((len (- (or end (cardinality seq)) start))
         (cls <Sequence-Class> (or type (class-of seq)))
         (sub (make-sequence cls len))
         (i 0)
         (j start))
    (while (< i len)
      (set-element! sub i (element seq j))
      (set! i (+ i 1))
      (set! j (+ j 1)))
    sub))


(definition public inline (replace-subseq! seq <Sequence> start end replacement)
  (sequence-replace-subseq! seq start end replacement))


(definition public (subseq! seq <Sequence> start (end (cardinality seq))) <Sequence>
  (sequence-subseq! seq start end))


(definition public (sort test seq (key: key #f))
  (if (null/pair? seq)
      (sort-list test seq key: key)
    ;; first draft to be optimized
    (coerce (sort test (coerce seq List) key: key) (class-of seq))))


;; simple insertion sort
(definition public (sort-vector! test vec)
  (let ((len (vector-length vec)))
    (let (outer (i 1))
      (when (< i len)
        (let (inner (j i))
          (when (> j 0)
            (let ((p (vector-ref vec (- j 1)))
                  (n (vector-ref vec j)))
              (unless (test p n)
                (vector-set! vec j p)
                (vector-set! vec (- j 1) n)
                (inner (- j 1))))))
        (outer (+ i 1)))))
  vec)


(definition public inline (first   seq) (element seq 0))
(definition public inline (second  seq) (element seq 1))
(definition public inline (third   seq) (element seq 2))
(definition public inline (fourth  seq) (element seq 3))
(definition public inline (fifth   seq) (element seq 4))
(definition public inline (sixth   seq) (element seq 5))
(definition public inline (seventh seq) (element seq 6))
(definition public inline (eighth  seq) (element seq 7))
(definition public inline (ninth   seq) (element seq 8))
(definition public inline (tenth   seq) (element seq 9))

(definition public inline (set-first!   seq value) (set-element! seq 0 value))
(definition public inline (set-second!  seq value) (set-element! seq 1 value))
(definition public inline (set-third!   seq value) (set-element! seq 2 value))
(definition public inline (set-fourth!  seq value) (set-element! seq 3 value))
(definition public inline (set-fifth!   seq value) (set-element! seq 4 value))
(definition public inline (set-sixth!   seq value) (set-element! seq 5 value))
(definition public inline (set-seventh! seq value) (set-element! seq 6 value))
(definition public inline (set-eighth!  seq value) (set-element! seq 7 value))
(definition public inline (set-ninth!   seq value) (set-element! seq 8 value))
(definition public inline (set-tenth!   seq value) (set-element! seq 9 value))


(definition public (element-reversed seq n)
  (element seq (- (cardinality seq) n 1)))


(definition public (iterate seq proc <procedure>)
  (loop (for obj in-sequence seq)
        (proc obj)))


(definition public (iterate-sequences proc <procedure> . seqs)
  (define (any? lst)
    (and (pair? lst)
         (or (car lst)
             (any? (cdr lst)))))
  
  (declare (proper-tail-calls))
  (let ((iterators (map iterator seqs)))
    (let (loop)
      (let ((done? (any? (map done? iterators))))
        (when (not done?)
          (apply proc (map get-next iterators))
          (loop)))))
  (unspecified))


(definition public (accumulate seq proc <procedure> (type #f))
  (let ((lst
          (loop (for obj in-sequence seq)
                (collect (proc obj)))))
    (if (not type)
        lst
      (coerce lst type))))


(definition protected inline (apply-key key <Object> object <Object>)
  (if (not key)
      object
    (key object)))


(definition protected inline (apply-test test <Object> x <Object> y <Object>)
  (if (not test)
      (eqv? x y)
    (test x y)))


(definition public (gather iterable <Object> (type: type List))
  (coerce (loop (for obj in-sequence iterable)
                (collect obj))
          type))


(definition public (collect proc <procedure> seq <Object> (key: key #f) (type: type #f))
  (coerce (loop (for obj in-sequence seq)
                (for val = (proc (apply-key key obj)))
                (when val
                  (collect val)))
          (or type (class-of seq))))


(definition public (collect-if predicate <procedure> seq <Object> (key: key #f))
  (if (and (null/pair? seq)
           (not key))
      (kernel-collect-if predicate seq)
    (coerce (loop (for obj in-sequence seq)
                  (when (predicate (apply-key key obj))
                    (collect obj)))
            (class-of seq))))


(definition public (collect-type type seq <Object> (key: key #f))
  (coerce (loop (for obj in-sequence seq)
                (when (is? (apply-key key obj) type)
                  (collect obj)))
          (class-of seq)))


(definition public (collect-sections lst (separator: separator #f) (test: test #f))
  (let ((sections (new List-Factory))
        (section (new List-Factory)))
    (for-each (lambda (value)
                (if (apply-test test separator value)
                    (begin
                      (put sections (get-output section))
                      (reset section))
                  (put section value)))
              lst)
    (put sections (get-output section))
    (get-output sections)))


(definition public (count target <Object> seq <Object> (key: key #f) (test: test #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (apply-test test target (apply-key key object))
            (increase! total)))
    total))


(definition public (count-if predicate <procedure> seq (key: key #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (predicate (apply-key key object))
            (increase! total)))
    total))


(definition public (count-type type seq <Object> (key: key #f))
  (let ((total 0))
    (loop (for object in-sequence seq)
          (when (is? (apply-key key object) type)
            (increase! total)))
    total))


(definition public (average seq)
  (let ((total 0)
        (count 0))
    (loop (for value in-sequence seq)
          (increase! total value)
          (increase! count))
    (/ total count)))


(definition public (find seq target (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f) (return: return 'position))
  (if (and (null/pair? seq) (not reversed?))
      (list-find seq target key test (or start 0) return)
    (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
      (when start
        (set-position iterator start))
      (continuation-capture
        (lambda (exit)
          (iterate iterator
                   (lambda (object)
                     (when (apply-test test target (apply-key key object))
                       (continuation-return exit (case return
                                                   ((item) object)
                                                   ((position) (if reversed? (get-position iterator) (- (get-position iterator) 1)))
                                                   (else (error "Unknown return type: {t}" return)))))))
          #f)))))


(definition public (find-rank target <Object> seq <Object> (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f))
  (if (and (null/pair? seq) (not reversed?))
      (list-find seq target key test (or start 0) #f)
    (if (and (string? seq) (not start))
        (string-find seq target reversed?: reversed?)
      (continuation-capture
        (lambda (exit)
          (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
            (when start
              (set-position iterator start))
            (iterate iterator
                     (lambda (object)
                       (when (apply-test test target (apply-key key object))
                         (continuation-return exit (if reversed? (get-position iterator) (- (get-position iterator) 1))))))
            #f))))))


(definition (list-find list target key test start return)
  (let ((key (if (not key) (lambda (x) x) key))
        (test (if (not test) eqv? test)))
    (let (iter (rest (tail list start)) (rank <fx> start))
       (cond ((null? rest) #f)
             ((test target (key (car rest)))
              (case return
                ((item) (car rest))
                (else   rank)))
             (else
              (iter (cdr rest) (+ rank 1)))))))


(definition public (find-in seq target (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f))
  (define (find-in-list)
    (let ((list seq)
          (key (if (not key) (lambda (x) x) key))
          (test (if (not test) eqv? test))
          (start (or start 0)))
      (let (iter (rest (tail list start)) (rank <fx> start))
        (cond ((null? rest) #f)
              ((test target (key (car rest)))
               (car rest))
              (else
               (iter (cdr rest) (+ rank 1)))))))
  
  (if (and (null/pair? seq) (not reversed?))
      (find-in-list)
    (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
      (when start
        (set-position iterator start))
      (continuation-capture
        (lambda (exit)
          (iterate iterator
                   (lambda (object)
                     (when (apply-test test target (apply-key key object))
                       (continuation-return exit object))))
          #f)))))


(definition public (find-balanced open close seq (key: key #f) (test: test #f) (start: start #f) (reversed?: reversed? #f) (return: return 'item))
  (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq)))
        (count 0))
    (when start
      (set-position iterator start))
    (continuation-capture
      (lambda (exit)
        (iterate iterator
                 (lambda (object)
                   (cond ((apply-test test open (apply-key key object))
                          (increase! count))
                         ((apply-test test close (apply-key key object))
                          (decrease! count)
                          (when (< count 0)
                            (case return
                              ((item) (continuation-return exit object))
                              ((position) (continuation-return exit (if reversed? (get-position iterator) (- (get-position iterator) 1))))
                              (else (error "Unknown return type: {t}" return))))))))
        #f))))


(definition public (find-if predicate <procedure> seq <Object> (key: key #f) (start: start #f) (reversed?: reversed? #f) (return: return 'item))
  (if (and (null/pair? seq) (not reversed?))
      (find-if-list predicate seq key (or start 0) return)
    (continuation-capture
      (lambda (exit)
        (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
          (when start
            (set-position iterator start))
          (iterate iterator
                   (lambda (object)
                     (when (predicate (apply-key key object))
                       (continuation-return exit (case return
                                                   ((item) object)
                                                   ((position) (if reversed? (get-position iterator) (- (get-position iterator) 1)))
                                                   (else (error "Unknown return type: {t}" return))))))))
        #f))))


(definition public (skip predicate <procedure> seq <Object> (key: key #f) (start: start #f) (reversed?: reversed? #f))
  (continuation-capture
    (lambda (return)
      (let ((iterator <Iterator> (if reversed? (explore seq direction: 'backward) (iterator seq))))
        (when start
          (set-position iterator start))
        (iterate iterator
                 (lambda (object)
                   (when (not (predicate (apply-key key object)))
                     (continuation-return return (if reversed?
                                                     (+ (get-position iterator) 1)
                                                   (- (get-position iterator) 1))))))
        (get-position iterator)))))


(definition public (append-map proc <procedure> list1 . lists)
  (apply append (apply map proc list1 lists)))


(definition public (zip list1 . lists)
  (apply map list list1 lists))


(definition public (iota count (start 0) (step 1))
  (if (zero? count)
      '()
    (cons start (iota (- count 1) (+ start step) step))))


(definition public (fold-left kcons knil lst)
  (if (null? lst)
      knil
    (fold-left kcons (kcons knil (car lst)) (cdr lst))))


(definition public (fold-right kcons knil lst)
  (if (null? lst)
      knil
    (kcons (car lst) (fold-right kcons knil (cdr lst)))))


(definition public (unfold-right stop? <procedure> seed->elem <procedure> next <procedure> seed (tail '()))
  (let (loop (seed seed) (lis tail))
    (if (stop? seed)
        lis
      (loop (next seed)
            (cons (seed->elem seed) lis)))))


(definition public (some? predicate <procedure> (key: key #f) . seqs)
  (if (and (not key)
           (null/pair? (car seqs))
           (null? (cdr seqs)))
      (kernel-some? predicate (car seqs))
    (continuation-capture
      (lambda (return)
        (apply iterate-sequences
          (lambda objs
            (and (apply predicate (map (lambda (object)
                                         (apply-key key object))
                                       objs))
                 (continuation-return return #t)))
          seqs)
        #f))))


(definition public (every? predicate <procedure> (key: key #f) . seqs)
  (if (and (not key)
           (null/pair? (car seqs))
           (null? (cdr seqs)))
      (kernel-every? predicate (car seqs))
    (continuation-capture
      (lambda (return)
        (apply iterate-sequences
          (lambda objs
            (or (apply predicate (map (lambda (object)
                                        (apply-key key object))
                                      objs))
                (continuation-return return #f)))
          seqs)
        #t))))


(definition public (concatenate . rest)
  (if (null? rest)
      '()
    (let ((fact (new List-Factory)))
      (let* ((first (car rest))
             (list? (null/pair? first)))
        (for-each (lambda (sequence)
                    (put-sequence fact sequence))
                  rest)
        (let ((output (get-output fact)))
          (if (not list?)
              (coerce output (class-of first))
            output))))))


(definition public (concatenate! . rest)
  (apply concatenate rest))


(definition public (subset? set1 set2)
  (or (null? set1)
      (every? (lambda (element)
                (memv? element set2))
              set1)))


(definition public (union (key: key #f) (test: test #f) . lists)
  (if (null? lists)
      '()
    (let ((first (car lists))
          (dst (new List-Factory)))
      (put-sequence dst first)
      (for-each (lambda (set)
                  (iterate (iterator set)
                           (lambda (object)
                             (when (not (member? (apply-key key object) (get-output dst) key: key test: test))
                               (put dst object)))))
                (cdr lists))
      (coerce (get-output dst) (class-of first)))))


(definition public (intersection (key: key #f) (test: test #f) . lists)
  (if (null? lists)
      '()
    (let ((first (car lists))
          (lists (cdr lists))
          (dst (new List-Factory)))
      (iterate (iterator first)
               (lambda (object)
                 (when (every? (lambda (set)
                                 (member? (apply-key key object) set key: key test: test))
                               lists)
                   (put dst object))))
      (coerce (get-output dst) (class-of first)))))


(definition public (difference x <Object> y <Object> (key: key #f) (test: test eqv?))
  (if (null? y)
      x
    (let ((dst (new List-Factory)))
      (iterate (iterator x)
               (lambda (object)
                 (when (not (member? (apply-key key object) y key: key test: test))
                   (put dst object))))
      (coerce (get-output dst) (class-of x)))))


(definition public (set-xor x <Object> y <Object> (test: test eqv?))
  (union (difference x y test: test)
         (difference y x test: test)))


(definition public (remove target <Object> seq <Object> (key: key #f) (test: test eqv?))
  (let ((dst (new List-Factory)))
    (iterate (iterator seq)
             (lambda (object)
               (when (not (apply-test test (apply-key key object) target))
                 (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(specialize as string-remove (remove target <char> str <string>) <string>
  (let ((output (open-output-string)))
    (loop (for n from 0 below (cardinality str))
          (let ((c (element str n)))
            (when (not (eqv? c target))
              (write-char c output))))
    (get-output-string output)))


(definition public (extract-trailer seq <Object> predicate <procedure>)
  (let (iterate (n (- (cardinality seq) 1)) (trailer '()))
    (if (or (< n 0) (not (predicate (element seq n))))
        (coerce trailer (class-of seq))
      (let ((obj (element seq n)))
        (if (not (predicate obj))
            (coerce trailer (class-of seq))
          (iterate (- n 1) (cons obj trailer)))))))


(definition public (remove-leading target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (< head end) (apply-test test (element seq head) target))
      (increase! head))
    (subseq seq head tail)))


(definition public (remove-trailing target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (> tail head) (apply-test test (element seq (- tail 1)) target))
      (decrease! tail))
    (subseq seq head tail)))


(definition public (remove-enclosing target <Object> seq <Object> (test: test eqv?))
  (let* ((start 0)
         (end (cardinality seq))
         (head start)
         (tail end))
    (while (and (< head end) (apply-test test (element seq head) target))
      (increase! head))
    (while (and (> tail head) (apply-test test (element seq (- tail 1)) target))
      (decrease! tail))
    (subseq seq head tail)))


(definition public (remove-duplicates seq <Object> (key: key #f) (test: test eqv?))
  (let ((table (make-table test: test))
        (dst (new List-Factory)))
    (iterate (iterator seq)
             (lambda (object)
               (let ((k (apply-key key object)))
                 (when (not (table-ref table k #f))
                   (put dst object)
                   (table-set! table k #t)))))
    (coerce (get-output dst) (class-of seq))))


(definition public (collect-duplicates seq <Object> (key: key identity) (test: test eqv?))
  (let ((partition (partition seq key: key test: test)))
    (map car (collect-if (lambda (partition)
                           (> (length (cdr partition)) 1))
                         partition))))


(definition public (remove-false seq <Object>)
  (collect-if identity seq))


(definition public (remove-empty seq <Object>)
  (collect-if (lambda (obj)
                (not (empty? obj)))
              seq))


(definition public (trim-spaces seq)
  (remove-enclosing #\space seq))


(definition public (trim-whitespace seq)
  (remove-enclosing #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (trim-leading-whitespace seq)
  (remove-leading #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (trim-trailing-whitespace seq)
  (remove-trailing #f seq
    test: (lambda (c ignore)
            (whitespace? c))))


(definition public (mismatch target <Object> seq <Object> (test: test equal?))
  (continuation-capture
    (lambda (return)
      (let ((srce (iterator seq))
            (targ (iterator target))
            (pos 0))
        (while (not (done? srce))
          (when (or (done? targ) (not (test (get-next srce) (get-next targ))))
            (continuation-return return pos))
          (increase! pos))
        (if (done? targ)
            #f
          pos)))))


(definition public (prefix sequences <Object> (test: test equal?))
  (if (null? sequences)
      '()
    (let ((ref (car sequences))
          (min <Object> #f))
      (for-each (lambda (object)
                  (let ((n (mismatch object ref test: test)))
                    (when (and n (or (not min) (< n min)))
                      (set! min n))))
                (cdr sequences))
      (if (not min)
          ref
        (subseq ref 0 min)))))


(definition public (prefix? target <Object> seq <Object>)
  (continuation-capture
    (lambda (return)
      (let ((targ (iterator target))
            (iter (iterator seq)))
        (while (and (not (done? targ)) (not (done? iter)))
          (when (nu/=? (get-next targ) (get-next iter))
            (continuation-return return #f)))
        (done? targ)))))


(definition public (copy-into! seq1 seq2)
  (for-each (lambda (element rank)
              (set-element! seq2 rank element))
            seq1
            (naturals 0 (cardinality seq1))))


(class package Search-Context extends Object
  
  
  (slot target            <Sequence>   accessors generate)
  (slot whole-words?      <bool>       accessors generate)
  (slot ignore-case?      <bool>       accessors generate)
  (slot ignore-diacritic? <bool>       accessors generate)
  (slot regexp?           <bool>       accessors generate)
  (slot match-test        <procedure+> accessors generate)
  (slot constituent-test  <procedure+> accessors generate)
  (slot regexp            <any>        accessors generate)
  (slot user-data         <any>        accessors generate)
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s}" target)))))


(class package Search-Set extends Object
  
  
  (slot regexp           <any>        accessors generate)
  (slot contexts         <list>       accessors generate))


(definition public (->search-context obj)
  (cond ((is? obj Search-Context) obj)
        ((is? obj Search-Set) (car (get-contexts obj)))
        ((string? obj) (make-search-context obj))
        (else (error "Unable to make a search context out of {s}" obj))))

(definition public (make-search-context target
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)
                     (user-data: user-data #f))
  (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test user-data))

(definition inline (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test user-data)
  (allocate Search-Context target whole-words? ignore-case? ignore-diacritic? regexp? match-test constituent-test #f user-data))


(definition public (->search-set obj) <Search-Set>
  (cond ((is? obj Search-Set) obj)
        ((is? obj Search-Context) (allocate-search-set (search-context-regexp obj) (list obj)))
        ((string? obj) (->search-set (->search-context obj)))
        ((list? obj) (let ((contexts (map ->search-context obj)))
                       (allocate-search-set
                         (sre->irregex (cons 'or (map search-context->sre contexts)))
                         contexts)))
        (else (error "Unable to make a search set out of {s}" obj))))

(definition public (allocate-search-set regexp contexts)
  (allocate Search-Set regexp contexts))


(definition (->diacritic-ignoring-sre string)
  (let ((char-list (string->list string)))
    (cons 'seq (map (lambda (c)
                      (let ((equivalent (table-ref Diacritic-Table c #f)))
                        (if equivalent
                            (cons 'or (assq equivalent Diacritic-Equivalences))
                          c)))
                    char-list))))


(definition (search-context->sre context <Search-Context>)
  (let ((seq (let ((target (get-target context)))
               (cond ((get-regexp? context)
                      `(posix-string ,target))
                     ((get-ignore-diacritic? context)
                      (->diacritic-ignoring-sre target))
                     (else target)))))
    (if (get-ignore-case? context)
        (list 'w/nocase seq)
      seq)))

(definition public (search-context-regexp context <Search-Context>)
  (or (get-regexp context)
      (let ((rx (sre->irregex (search-context->sre context))))
        (set-regexp context rx)
        rx)))


(definition (regular-search-impl seq <Sequence> target <any> match-test <procedure+> constituent-test <procedure+> start <fx+> end <fx+> reversed? <bool>)
  (let* ((search-set (->search-set target))
         (first-context <Search-Context> (car (get-contexts search-set)))
         (whole-words? (get-whole-words? first-context))
         (match-test (or match-test (get-match-test first-context)))
         (constituent-test (or constituent-test (get-constituent-test first-context) word-constituent?))
         (regexp (get-regexp search-set))
         (card (cardinality seq))
         (start (or start (if reversed? card 0)))
         (end (or end (if reversed? 0 card))))
    (let (lp (i (if reversed? 0 start)) (best #f))
      (let ((match (irregex-search regexp seq i)))
        (if (not match)
            best
          (let ((from (irregex-match-start-index match 0))
                (to (irregex-match-end-index match 0)))
            (cond ((if reversed? (or (< from end) (> to start)) (> to end)) best)
                  ((if match-test
                       (match-test seq whole-words? constituent-test from to)
                     (or (not whole-words?)
                         (let ((before (and (> from 0) (element seq (- from 1))))
                               (after (and (< to card) (element seq to))))
                           (and (or (not before)
                                    (not (constituent-test before)))
                                (or (not after)
                                    (not (constituent-test after)))))))
                   (let ((res (cons from to)))
                     (if reversed? (lp (+ to 1) res) res)))
                  (else (lp to best)))))))))


(definition public (regular-search seq <Sequence> target <any>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f))
  (regular-search-impl seq target match-test constituent-test start end reversed?))


(definition public (regular-search-all seq <Sequence> target <any>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f))
  (let ((len (cardinality seq))
        (queue (new-queue))
        (search-set (->search-set target)))
    (let (iter (pos <fx> (or start (if reversed? len 0))))
      (let ((found (regular-search-impl seq search-set match-test constituent-test pos end reversed?)))
        (if found
            (begin
              (enqueue queue found)
              (iter (if reversed? (car found) (cdr found))))
          (queue-list queue))))))


(definition public (search seq <Sequence> target <Object>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)) <int+>
  (if (and (string? seq)
           (string? target)
           (not end)
           (not reversed?)
           (not whole-words?)
           (not ignore-case?)
           (not ignore-diacritic?)
           (not regexp?)
           (not match-test)
           (not constituent-test))
      (string-search seq target start: start)
    (let ((search-set (->search-set (if (string? target)
                                        (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? #f #f #f)
                                      target))))
      (let ((found (regular-search-impl seq search-set match-test constituent-test start end reversed?)))
        (if found
            (car found)
          #f)))))


(definition public (search-all seq <Sequence> target <Object>
                     (start: start #f)
                     (end: end #f)
                     (reversed?: reversed? #f)
                     (whole-words?: whole-words? #f)
                     (ignore-case?: ignore-case? #f)
                     (ignore-diacritic?: ignore-diacritic? #f)
                     (regexp?: regexp? #f)
                     (match-test: match-test #f)
                     (constituent-test: constituent-test #f)) <list>
  (let ((search-set (->search-set (if (string? target)
                                      (allocate-search-context target whole-words? ignore-case? ignore-diacritic? regexp? #f #f #f)
                                    target))))
    (map car (regular-search-all seq search-set
               start: start
               end: end
               reversed?: reversed?
               match-test: match-test
               constituent-test: constituent-test))))


(definition public (split seq <Object> separator <Object>) <list>
  (cond ((zero? (cardinality seq))
         (list seq))
        ((procedure? separator)
         (let ((previous 0)
               (result (new List-Factory))
               (done? #f))
           (while (not done?)
             (let ((pos (find-if separator seq start: previous return: 'position)))
               (if (not pos)
                   (set! done? #t)
                 (put result (subseq seq previous pos))
                 (set! previous (+ pos 1)))))
           (put result (subseq seq previous))
           (get-output result)))
        (else
         (let ((previous 0)
               (incr (cardinality separator))
               (result (new List-Factory)))
           (let (iterate)
             (let ((pos (search seq separator start: previous)))
               (when pos
                 (put result (subseq seq previous pos))
                 (set! previous (+ pos incr))
                 (iterate))))
           (put result (subseq seq previous))
           (get-output result)))))


(definition public (split-justified seq <Object> width separators <Object> (column: column <fx> 0))
  (let ((pos 0)
        (size (cardinality seq))
        (result (new List-Factory))
        (done? #f))
    (while (not done?)
      (let ((effective-width (- width column)))
        (if (<= (- size pos) effective-width)
            (begin
              (put result (subseq seq pos))
              (set! done? #t))
          (put result (subseq seq pos (+ pos effective-width)))
          (set! column 0)
          (increase! pos effective-width))))
    (get-output result)))


(definition public (join sequences <Object> separator <Object>)
  (cond ((null? sequences)
         '())
        ((null? (cdr sequences))
         (car sequences))
        (else
         (let ((first (car sequences)))
           ;; optimization
           (if (string? first)
               (join-strings sequences separator)
             (let ((dst (new List-Factory)))
               (put dst first)
               (for-each (lambda (seq)
                           (put dst separator)
                           (put dst seq))
                         (cdr sequences))
               (apply concatenate (get-output dst))))))))


(definition public (join-symbols symbols separator)
  (string->symbol (join (map symbol->string symbols) separator)))


(definition public (inject sequence inserted)
  (let ((fact (new List-Factory))
        (first? #t))
    (for-each (lambda (element)
                (if first?
                    (set! first? #f)
                  (put-sequence fact inserted))
                (put fact element))
              sequence)
    (get-output fact)))


(definition public (substitute old-value <Object> new-value <Object> seq <Object> (key: key #f) (test: test #f) (sequence?: sequence? #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (dst (new List-Factory)))
    (while (not (done? src))
      (let ((object (get-next src)))
        (if (apply-test test old-value (apply-key key object))
            (if (not sequence?)
                (put dst new-value)
              (put-sequence dst new-value))
          (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(definition public (substitute-alist replacements <Object> seq <Object> (key: key #f) (test: test #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (dst (new List-Factory)))
    (while (not (done? src))
      (let ((object (get-next src))
            (found? #f))
        (for-each (lambda (replacement)
                    (unless found?
                      (bind (old . new) replacement
                        (when (apply-test test old (apply-key key object))
                          (put-sequence dst new)
                          (set! found? #t)))))
                  replacements)
        (unless found?
          (put dst object))))
    (coerce (get-output dst) (class-of seq))))


(definition public (fill! seq object (start: start #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq)))
    (when start
      (set-position src start))
    (while (not (done? src))
      (put src object)
      (next src)))
  seq)


(definition public (replace! seq replacement (start: start #f))
  (declare (proper-tail-calls))
  (let ((src (iterator seq))
        (rep (iterator replacement)))
    (when start
      (set-position src start))
    (while (and (not (done? src)) (not (done? rep)))
      (put src (get-next rep))
      (next src)))
  seq)


(definition public (ordered-position object seq (key: key #f) (test: test <=))
  (find seq object key: key test: test))


(definition public (insert-ordered! object seq (key: key #f) (test: test <=))
  (let ((n (ordered-position (apply-key key object) seq key: key test: test)))
    (insert! seq (or n (cardinality seq)) object)))


(definition global-compare
  compare)

(definition global-ci-compare
  ci-compare)


(definition public (merge-ordered proc x y (key: key #f) (left-key: left-key key) (right-key: right-key key) (compare: compare #f) (case-insensitive?: case-insensitive? #f))
  (declare (proper-tail-calls))
  (let ((ix (iterator x))
        (iy (iterator y))
        (compare-proc (or compare (if case-insensitive? global-ci-compare global-compare))))
    (while (and (not (done? ix)) (not (done? iy)))
      (let* ((ex (peek ix))
             (ey (peek iy))
             (kx (apply-key left-key ex))
             (ky (apply-key right-key ey)))
        (case (compare-proc kx ky)
          ((:equal)   (proc :same kx ex ey)
           (next ix)
           (next iy))
          ((:less)    (proc :left kx ex #f)
           (next ix))
          ((:greater) (proc :right ky #f ey)
           (next iy))
          (else       (error "Unable to compare {t} and {t}" kx ky)))))
    (while (not (done? ix))
      (let ((expr (get-next ix)))
        (proc :left (apply-key left-key expr) expr #f)))
    (while (not (done? iy))
      (let ((expr (get-next iy)))
        (proc :right (apply-key right-key expr) #f expr)))))


(definition public (merge proc lists (key: key #f) (compare: compare compare))
  (declare (proper-tail-calls))
  (let ((scan (copy lists)))
    (while (some? not-null? scan)
      (let* ((min (minimum (map car (remove-empty scan)) key: key compare: compare))
             (min-key (apply-key key min))
             (res (new List-Factory)))
        (for-each-pair (lambda (pair)
                         (let* ((list (car pair))
                                (object (car list)))
                           (if (or (not object)
                                   (neq? (compare (apply-key key object) min-key) :equal))
                               (put res #f)
                             (put res object)
                             (set-car! pair (cdr list)))))
                       scan)
        (proc min-key (get-output res))))))


(definition public (next-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t))
  (let ((rank (find seq elem key: key test: test))
        (card (cardinality seq)))
    (let ((next-rank
            (if (not rank)
                0
              (let ((next (+ rank 1)))
                (if cycle?
                    (modulo next card)
                  (and (< next card)
                       next))))))
      (and next-rank
           (element seq next-rank)))))


(definition public (previous-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t))
  (let ((rank (find seq elem key: key test: test))
        (card (cardinality seq)))
    (let ((previous-rank
            (if (not rank)
                (- card 1)
              (let ((previous (- rank 1)))
                (if cycle?
                    (modulo previous card)
                  (and (>= previous 0)
                       previous))))))
      (and previous-rank
           (element seq previous-rank)))))


(definition public (cycle-element seq elem (key: key #f) (test: test #f) (cycle?: cycle? #t) (reversed?: reversed? #f))
  (if reversed?
      (previous-element seq elem key: key test: test cycle?: cycle?)
    (next-element seq elem key: key test: test cycle?: cycle?)))


(definition public (random-element seq)
  (element seq (random (cardinality seq))))


(definition public (random-sequence seq)
  (let (iter (res '()) (seq seq))
    (if (null? seq)
        res
      (let ((elem (random-element seq)))
        (iter (cons elem res) (remove elem seq))))))


(definition public (partition sequence (key: key identity) (test: test #f))
  (let ((result '()))
    (for-each (lambda (element)
                (let* ((category (key element))
                       (pair (associate category result test: test)))
                  (if (not pair)
                      (set! result (cons (cons category (list element)) result))
                    (set-cdr! pair (cons element (cdr pair))))))
              sequence)
    (reverse! (map (lambda (partition)
                     (bind (key . elements) partition
                       (cons key (reverse! elements))))
                   result))))


(definition public (partition-binary lst predicate)
  (let ((yes '())
        (no '()))
    (for-each (lambda (elem)
                (if (predicate elem)
                    (set! yes (cons elem yes))
                  (set! no (cons elem no))))
              lst)
    (values yes no)))


(definition public (starts-with? seq target (test: test #f) (ignore-case?: ignore-case? #f)) <bool>
  (let ((sl (cardinality seq))
        (tl (cardinality target))
        (test (or test (if ignore-case? string-ci=? string=?))))
    (and (>= sl tl)
         ;; put nu=?
         ;; put subseq! (not sure)
         (test (subseq seq 0 tl) target))))


(definition public (ends-with? seq target (test: test #f) (ignore-case?: ignore-case? #f)) <bool>
  (let ((sl (cardinality seq))
        (tl (cardinality target))
        (test (or test (if ignore-case? string-ci=? string=?))))
    (and (>= sl tl)
         ;; put nu=?
         ;; put subseq! (not sure)
         (test (subseq seq (- sl tl)) target))))


(definition public (for-each-reversed proc lst)
  (let (iterate (lst lst))
    (when (pair? lst)
      (iterate (cdr lst))
      (proc (car lst)))))


(definition (find-if-list predicate list key start returned)
  (let ((key (if (not key) (lambda (x) x) key)))
    (let (iter (rest (tail list start)) (rank <fx> start))
       (if (null? rest)
           #f
         (let ((result (predicate (key (car rest)))))
           (if result
               (cond ((eq? returned 'item) (car rest))
                     ((eq? returned 'position) rank)
                     ((eq? returned 'result) result)
                     (else (error "Unknown return type {t}" returned)))
             (iter (cdr rest) (+ rank 1))))))))


(definition public inline (insert-sequence! sequence pos seq)
  (replace-subseq! sequence pos pos seq))


;;;
;;;; Sequence-Explorer
;;;


(class package Sequence-Explorer extends Explorer


  (slot sequence             <Sequence>)
  (slot sequence-cardinality <fx>)
  (slot current              <fx>)


  (method override (initialize self seq (direction: direction 'forward) (start: start #f))
    (nextmethod self)
    (set! sequence seq)
    (set! sequence-cardinality (cardinality sequence))
    (set-direction self direction)
    (if (not start)
        (case direction
          ((forward)  (goto-beginning self))
          ((backward) (goto-end self)))
      (set! current start)))


  (method override (peek-forward self)
    (element sequence current))


  (method override (peek-backward self)
    (element sequence (- current 1)))


  (method override (goto-beginning self)
    (set! current 0))


  (method override (goto-end self)
    (set! current sequence-cardinality))


  (method override (forward self)
    (increase! current 1))


  (method override (backward self)
    (decrease! current 1))


  (method override (done-forward? self)
    (>= current sequence-cardinality))


  (method override (done-backward? self)
    (= current 0))


  (method override (put-forward self object <Object>)
    (set-element! sequence current object))


  (method override (put-backward self object <Object>)
    (set-element! sequence (- current 1) object))


  (method override (get-position self)
    current)


  (method override (set-position self pos <fx>)
    (set! current (between 0 pos sequence-cardinality)))


  (method override (get-state self)
    current)


  (method override (reset-state self state <fx>)
    (set! current state)))


;;;
;;;; List
;;;


(class List-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-list len))
  
  
  (method override (coerce-object self seq)
    (let ((queue (new-queue)))
      (iterate seq
               (lambda (object)
                 (enqueue queue object)))
      (queue-list queue))))


(class primitive List metaclass List-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "lists"))
  
  
  (method override (copy-object self deep?)
    (map (lambda (x)
           (if deep?
               (subcopy x deep?)
             x))
         self))
  
  
  (method override (iterate-object self)
    (new List-Iterator self))
  
  
  (method override (sequence-element self n) <any>
    (list-ref self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (list-set! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (length self))
  
  
  (method override (sequence-tail self n)
    (let (tail (lst self) (n n))
      (if (or (null? lst) (= n 0))
          lst
        (tail (cdr lst) (- n 1)))))
  
  
  (method override (sequence-last self)
    (if (null? (cdr self))
        (car self)
      (last (cdr self))))
  
  
  (method override (sequence-butlast self)
    (if (or (null? self) (null? (cdr self)))
        '()
      (cons (car self) (butlast (cdr self)))))
  
  
  (method override (sequence-subseq! self start end)
    (if (or (= start 0) (= end -1))
        self
      (subseq self start end)))
  
  
  (method (replace-subseq! self start end seq)
    (if (= start 0)
        (begin
          (set-cdr! (last-tail seq) (tail self end))
          seq)
      (let* ((before (tail self (- start 1)))
             (after  (tail before (+ (- end start) 1))))
        (set-cdr! before seq)
        (set-cdr! (last-tail before) after)
        self))))


(class Null-Class extends List-Class)


(class primitive Null metaclass Null-Class extends List


  (method override (compare-object self obj)
    (if (null? obj)
        :equal
      :not-equal))
  
  
  (method override (di-compare-object self obj)
    (if (null? obj)
        :equal
      :not-equal)))


(class Pair-Class extends List-Class)


(class primitive Pair metaclass Pair-Class extends List


  (method override (compare-object self obj)
    (if (pair? obj)
        (case (compare (car self) (car obj))
          ((:less) :less)
          ((:greater) :greater)
          ((:equal)
           (let ((left (cdr self))
                 (right (cdr obj)))
             (cond ((and (null? left) (null? right))
                    :equal)
                   ((null? left)
                    :less)
                   ((null? right)
                    :greater)
                   (else
                    (compare left right)))))
          (else :not-equal))
      :not-equal))


  (method override (di-compare-object self obj)
    (if (pair? obj)
        (case (di-compare (car self) (car obj))
          ((:less) :less)
          ((:greater) :greater)
          ((:equal)
           (let ((left (cdr self))
                 (right (cdr obj)))
             (cond ((and (null? left) (null? right))
                    :equal)
                   ((null? left)
                    :less)
                   ((null? right)
                    :greater)
                   (else
                    (di-compare left right)))))
          (else :not-equal))
      :not-equal))
  
  
  (method override (walk-references self proc)
    (walk-references (car self) proc)
    (walk-references (cdr self) proc))
  
  
  (method override (setup-context self context)
    (setup-context (car self) context)
    (setup-context (cdr self) context)))


(specialize inline (element list <list> n) <any>
  (list-ref list (cast <int> n)))


(specialize inline (cardinality list <list>) <int>
  (length list))


(definition public (insert! seq pos obj)
  (insert-sequence! seq (or pos (cardinality seq)) (coerce (list obj) (class-of seq))))


(definition public (atom? value)
  (or (null? value)
      (boolean? value)
      (char? value)
      (string? value)
      (symbol? value)
      (keyword? value)
      (number? value)))


(definition public inline (null/pair? obj)
  (or (null? obj) (pair? obj)))


(definition public inline (one-element? obj)
  (and (pair? obj) (null? (cdr obj))))


(definition public (last-tail lst)
  (if (null? lst)
      lst
    (let (iter (cur lst))
      (if (pair? (cdr cur))
          (iter (cdr cur))
        cur))))


(definition public (make-list n . rest)
  (declare (proper-tail-calls))
  (let ((fill (if (null? rest) #f (car rest)))
        (list '()))
    (while (> n 0)
      (set! list (cons fill list))
      (set! n (- n 1)))
    list))


(definition public inline (list-set! list n value)
  (set-car! (list-tail list n) value))


(definition public inline (set-cadr! pair value)
  (set-car! (cdr pair) value))


(definition public (append! . rest)
  (let ((queue (new-queue)))
    (for-each (lambda (lst)
                (enqueue-list queue lst))
              rest)
    (queue-list queue)))


(definition public (position target lst (key: key #f) (test: test #f))
  (define (position lst pos)
    (cond ((null? lst)
           #f)
          ((apply-test test target (apply-key key (car lst)))
           pos)
          (else
           (position (cdr lst) (+ pos 1)))))
  
  (position lst 0))


(definition public (copy-tree tree)
  (if (pair? tree)
      (cons (copy-tree (car tree))
            (copy-tree (cdr tree)))
    tree))


(definition public (position-of obj lst)
  (let (iter (rst lst) (i <fx> 0))
    (if (null? rst)
        #f
      (if (eq? obj (car rst))
          i
        (iter (cdr rst) (+ i 1))))))

           
(definition public (proper-list? lst)
  (cond ((null? lst) #t)
        ((not (pair? lst)) #f)
        (else (proper-list? (cdr lst)))))


(definition public (proper-length l)
  (define (length l n)
    (if (pair? l)
        (length (cdr l) (+ n 1))
      n))
  
  (length l 0))


(definition public (split-list lst)
  (let (iter (scan lst) (proper '()))
    (if (null? scan)
        (values (reverse! proper) #f)
      (if (pair? scan)
          (iter (cdr scan) (cons (car scan) proper))
        (values (reverse! proper) scan)))))


(definition public (last-cdr lst)
  (if (pair? lst)
      (last-cdr (cdr lst))
    lst))


(definition public (butlast-cdr lst)
  (if (pair? lst)
      (cons (car lst) (butlast-cdr (cdr lst)))
    '()))


(definition public (move-to-head! target lst)
  (if (or (null? lst) (eq? target (car lst)))
      lst
    (let (iter (previous lst) (scan (cdr lst)))
      (cond ((null? scan) lst)
            ((eq? (car scan) target)
             (set-cdr! previous (cdr scan))
             (cons target lst))
            (else (iter scan (cdr scan)))))))


(definition public (move-to-tail! target lst)
  (cond ((null? lst) lst)
        ((eq? (car lst) target)
         (set-cdr! (last-tail lst) (cons target '()))
         (cdr lst))
        (else
         (let (iter (previous lst) (scan (cdr lst)))
           (cond ((null? scan) lst)
                 ((eq? (car scan) target)
                  (if (null? (cdr scan))
                      lst
                    (begin
                      (set-cdr! previous (cdr scan))
                      (set-cdr! (last-tail scan) (cons target '()))
                      lst)))
                 (else
                  (iter scan (cdr scan))))))))


(definition public (augment . rest)
  (declare (proper-tail-calls))
  (let ((fact (new List-Factory))
        (scan rest))
    (while (not-null? scan)
      (if (null? (cdr scan))
          (put-sequence fact (car scan))
        (put fact (car scan)))
      (set! scan (cdr scan)))
    (get-output fact)))


(definition public inline (memq? target <Object> list <Object>)
  (boolean (memq target list)))


(definition public inline (memv? target <Object> list <Object>)
  (boolean (memv target list)))


(definition public (member? target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (cond ((null? scan)
           #f)
          ((apply-test test target (apply-key key (car scan)))
           #t)
          (else
           (iter (cdr scan))))))


(definition public (assq-value key list default-value)
  (let ((pair (assq key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (assv-value key list default-value)
  (let ((pair (assv key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (assoc-value key list default-value)
  (let ((pair (assoc key list)))
    (if pair
        (cdr pair)
      default-value)))


(definition public (associate target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (if (null? scan)
        #f
      (let ((pair (car scan)))
        (if (apply-test test target (apply-key key (car pair)))
            pair
          (iter (cdr scan)))))))


(definition public (rassociate target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (if (null? scan)
        #f
      (let ((pair (car scan)))
        (if (apply-test test target (apply-key key (cdr pair)))
            pair
          (iter (cdr scan)))))))


(definition public (find-pair target <Object> list <Object> (key: key #f) (test: test equal?))
  (let (iter (scan list))
    (cond ((null? scan)
           #f)
          ((apply-test test target (apply-key key (car scan)))
           scan)
          (else
           (iter (cdr scan))))))


(definition public (reverse! list <Object>)
  (declare (proper-tail-calls))
  (let ((res <Object> '())
        (ptr <Object> '()))
    (while (not-null? list)
      (set! ptr (cdr list))
      (set-cdr! list res)
      (set! res list)
      (set! list ptr))
    res))


(definition public (remove! target <Object> list <Object> (key: key #f) (test: test eqv?))
  (declare (proper-tail-calls))
  (while (and (not-null? list) (test target (apply-key key (car list))))
    (set! list (cdr list)))
  (if (null? list)
      '()
    (let ((previous list)
          (scan (cdr list)))
      (while (not-null? scan)
        (if (test target (apply-key key (car scan)))
            (begin
              (set! scan (cdr scan))
              (set-cdr! previous scan))
          (set! previous scan)
          (set! scan (cdr scan)))))
    list))


(definition public (subtract! target <Object> list <Object>)
  (cond ((null? list)
         '())
        ((eq? (car list) target)
         (cdr list))
        (else
         (let (iter (previous list) (scan (cdr list)))
           (cond ((null? scan)
                  list)
                 ((eq? (car scan) target)
                  (set-cdr! previous (cdr scan))
                  list)
                 (else
                  (iter scan (cdr scan))))))))


(definition public (getprop plist <Object> target <Object> (key: key #f) (test: test #f))
  (let (iter (scan plist))
    (cond ((null? scan)
           #f)
          ((apply-test test (apply-key key (car scan)) target)
           scan)
          (else
           (iter (cddr scan))))))


(definition public (plist-remove plist keyword)
  (cond ((null? plist)
         '())
        ((eq? (car plist) keyword)
         (cddr plist))
        (else
         (cons (car plist)
               (cons (cadr plist)
                     (plist-remove (cddr plist) keyword))))))


(definition public (plist-add plist keyword value)
  (cond ((null? plist)
         (list keyword value))
        ((eq? (car plist) keyword)
         (cons (car plist)
               (cons value (cddr plist))))
        (else
         (cons (car plist)
               (cons (cadr plist) (plist-add (cddr plist) keyword value))))))


(definition public (getf plist <Object> target <Object> (key: key #f) (test: test #f) (not-found: not-found #f))
  (let ((pair (getprop plist target key: key test: test)))
    (if (not pair)
        not-found
      (cadr pair))))


(definition public (setf plist <Object> target <Object> value <Object>)
  (set-second! (getprop plist target) value))


(definition public (addf plist <Object> target <Object> value <Object>)
  (let ((pair (getprop plist target)))
    (if (not pair)
        (append! plist (list target value))
      (set-second! pair value)
      plist)))


(definition public (for-each-pair proc lst)
  (let (iterate (lst lst))  
    (when (not-null? lst)
      (proc lst)
      (iterate (cdr lst)))))


(definition public (for-each-property proc lst)
  (let (iterate (lst lst))
    (when (not-null? lst)
      (proc (car lst) (cadr lst))
      (iterate (cddr lst)))))


(definition public (map-property proc lst)
  (let ((queue (new-queue)))
    (for-each-property (lambda (property value)
                         (enqueue queue (proc property value)))
                       lst)
    (queue-list queue)))


(definition public (flatten-lists llist)
  (apply append llist))


(definition public (uniform lst (key: key #f) (test: test #f))
  (if (null? lst)
      lst
    (continuation-capture
      (lambda (return)
        (let ((first (apply-key key (car lst))))
          (for-each (lambda (object)
                      (let ((value (apply-key key object)))
                        (unless (apply-test test first value)
                          (continuation-return return #f))))
                    (cdr lst))
          first)))))


(definition public (sort-property-list prop-list <Object>)
  (let* ((factory (new List-Factory))
         (proc    (lambda (property value)
                    (put factory (list property value))))
         (alist   (begin
                    (for-each-property proc prop-list)
                    (get-output factory)))
         (sorted  (sort < alist key: car)))
    (apply append sorted)))


(definition public (plist->alist ls)
  (let (lp (ls ls) (res '()))
    (if (null? ls)
        (reverse res)
      (lp (cddr ls) (cons (cons (car ls) (cadr ls)) res)))))


(definition public (alist->plist ls)
  (let (lp (ls ls) (res '()))
    (if (null? ls)
        (reverse res)
      (lp (cdr ls) (cons (cdar ls) (cons (caar ls) res))))))


;;;
;;;; List-Iterator
;;;


(class package List-Iterator extends Iterator


  (slot current)
  (slot position)


  (method override (initialize self list <list>)
    (nextmethod self)
    (set! current list)
    (set! position 0))


  (method override (get-next! self)
    (if (null? current)
        (eof-object)
      (prog1 (car current)
        (set! current (cdr current))
        (set! position (+ position 1)))))


  (method override (done? self)
    (and (null? current) (eq? peeked Empty)))


  (method override (put self object)
    (set-car! current object))


  (method override (get-position self)
    position)


  (method override (set-position self pos)
    (let ((delta (- pos position)))
      (cond ((< delta 0) (error "List iterators cannot move backward"))
            ((> delta 0)
             (set! position pos)
             (set! current (tail current delta))))))


  (method override (get-state self)
    (cons current position))


  (method override (reset-state self state)
    (set! current (car state))
    (set! position (cdr state)))
  
  
  (method public (get-list self)
    current))


;;;
;;;; List-Factory
;;;


(class List-Factory extends Object


  (slot list            initialize '() getter generate)
  (slot last-list       initialize #f)
  (slot last-anchor     initialize #f)
  (slot current         initialize '())
  (slot size       <fx> initialize 0   getter generate)


  (method package (put self object <Object>)
    (cond ((null? current)
           (set! current (cons object current))
           (set! list current))
          (else
           (when last-list
             (copy-last-list self))
           (set-cdr! current (cons object '()))
           (set! current (cdr current))))
    (prog1 size
      (increase! size)))


  (method (put-unique self object (test: test eqv?))
    (unless (member? object list test: test)
      (put self object)))


  (method package (put-sequence self seq <Object>)
    (when seq
      (if (not (pair? seq))
          (iterate seq (~ put self))
        (cond ((null? current)
               (set! current seq)
               (set! last-list seq)
               (set! list seq))
              (else
               (when last-list
                 (copy-last-list self))
               (set! last-list seq)
               (set! last-anchor current)
               (set-cdr! current seq))))
      (prog1 size
        (increase! size (cardinality seq)))))
  
  
  (method public (is-empty? self)
    (null? current))
  
  
  (method public (get-last-element self)
    (car current))


  (method package (get-output self)
    list)


  (method public (reset self)
    (set! list '())
    (set! last-list #f)
    (set! last-anchor #f)
    (set! current '())
    (set! size 0))


  (method private (copy-last-list self)
    (cond ((not last-anchor)
           (set! list (copy last-list))
           (set! current (last-tail list)))
          (else
           (set-cdr! last-anchor (copy last-list))
           (set! current (last-tail last-anchor))))
    (set! last-list #f)
    (set! last-anchor #f)))


;;;
;;;; Table
;;;


(class primitive Table extends Object
  
  
  (method override (initialize self . rest)
    (native-class "tables"))


  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a} entries"
          (table-length self))))))


(definition public (table-add table <table> key value)
  (let ((lst (cons value (table-ref table key '()))))
    (table-set! table key lst)))


(definition public (table-remove! table <table> key value)
  (let ((lst (remove! value (table-ref table key '()))))
    (if (null? lst)
        (table-clear table key)
      (table-set! table key lst))))


(definition public (table-subtract! table <table> key value)
  (let ((lst (subtract! value (table-ref table key '()))))
    (if (null? lst)
        (table-clear table key)
      (table-set! table key lst))))


(definition public (empty-table table <table>)
  (iterate-table-safe table
    (lambda (k v)
      (table-clear table k))))


(definition public (table-keys table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons key list))))
    list))


(definition public (table-values table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons value list))))
    list))


(definition public (table-keys/values table <table>)
  (let ((list '()))
    (iterate-table table
      (lambda (key value)
        (set! list (cons (cons key value) list))))
    list))


(definition public (table-find table <table> value (test: test eqv?))
  (continuation-capture
    (lambda (return)
      (iterate-table table
        (lambda (k v)
          (when (test v value)
            (continuation-return return k))))
      #f)))


(definition public (table-load table <table> input error-on-duplicates?)
  (declare (proper-tail-calls))
  (let (iterate)
    (let ((name (read input))
          (object (read input)))
      (when (and (not (eof-object? name))
                 (not (eof-object? object)))
        (if (and error-on-duplicates? (table-ref table name #f))
            (error "Duplicated table entries for {t}" name)
          (table-set! table name object))
        (iterate)))))


;;;
;;;; Serialize
;;;


(definition public (serialize-reference reference)
  (let ((unit (reference-unit reference))
        (name (reference-name reference)))
    (let (iter (module-name unit))
      (let ((module (and (unit-loadable? module-name)
                         (require-module module-name))))
        (if (and module
                 (eq? (get-access module) 'public)
                 (table-ref (get-exports module) name #f))
            (list 'module-public module-name name)
          (let ((path (butlast (split-identifier module-name))))
            (if (null? path)
                (error "Unable to serialize: {s}" reference)
              (iter (apply compose-identifier path)))))))))


(definition *serialized-classes* <table>
  (make-table test: eq?))


(definition public (serialize-class class)
  (or (table-ref *serialized-classes* class #f)
      (let ((serialize (serialize-reference (get-name class))))
        (table-set! *serialized-classes* class serialize)
        serialize)))


(definition public (serialize-object class content)
  (make-serialized (serialize-class class) content))


(definition *deserialized-classes* <table>
  (make-table test: eq?))


(definition public (deserialize-class reference)
  (or (table-ref *deserialized-classes* reference #f)
      (let ((class (resolve-runtime-reference (deserialize-runtime-reference reference))))
        (table-set! *deserialized-classes* reference class)
        class)))


(definition public (serialize obj)
  (or (marshall-object (class-of obj) obj)
      (if (object? obj)
          (error "Unable to serialize: {a}" obj)
        obj)))


(definition public (deserialize obj)
  (if (serialized? obj)
      (let ((class (deserialize-class (serialized-class obj)))
            (content (serialized-content obj)))
        (or (unmarshall-object class content)
            (error "Unable to deserialize: {a}" (category-name class))))
    obj))


;; simple literal serialization
(definition public (serialize-literal obj)
  (serialize-object (class-of obj)
                    (vector (->string obj :reader))))


;; simple literal deserialization
(definition public (deserialize-literal content)
  (parameterize ((walk-for #f))
    (with-jazz-readtable
      (lambda ()
        (read-string-element (vector-ref content 0))))))


;;;
;;;; Services
;;;


(definition *services*
  (make-table test: eq?))


(definition public (provide-service name proc)
  (table-set! *services* name proc))


(definition public (request-service name (not-provided #f))
  (lambda rest
    (let ((service (table-ref *services* name #f)))
      (cond (service
             (apply service rest))
            (not-provided
             (apply not-provided rest))
            (else
             (error "Service {s} not provided" name))))))


;;;
;;;; Slot
;;;


(class Slot extends Field
  
  
  (slot offset     getter generate)
  (slot initialize getter generate))


;;;
;;;; Property
;;;


(class Property extends Slot
  
  
  (slot getter getter generate)
  (slot setter getter generate))


(definition public inline (property? obj)
  (is? obj Property))


(definition public (symbolize-property property <Object>)
  (cond ((field? property) (get-name property))
        ((keyword? property) (keyword->symbol property))
        (else property)))


(definition public (symbolize-properties properties <Object>)
  (let ((fact (new List-Factory)))
    (for-each-property
      (lambda (property value)
        (put fact (symbolize-property property))
        (put fact value))
      properties)
    (get-output fact)))


(definition public (keywordize-property property <Object>)
  (cond ((field? property) (symbol->keyword (field-name property)))
        ((keyword? property) property)
        (else (symbol->keyword property))))


(definition public (keywordize-properties properties <Object>)
  (let ((fact (new List-Factory)))
    (for-each-property
      (lambda (property value)
        (put fact (keywordize-property property))
        (put fact value))
      properties)
    (get-output fact)))


(definition public (read-property object <Object> expr <Object>)
  (let ((getter (property-getter (property-field (class-of object) expr))))
    (if getter
        (getter object)
      (error "Property {s} has no getter" expr))))


(definition public (write-property object <Object> expr <Object> value <Object>)
  (let ((setter (property-setter (property-field (class-of object) expr))))
    (if setter
        (setter object value)
      (error "Property {s} has no setter" expr))))


(definition public (property-field class <Class> expr <Object>)
  (define (property->symbol expr)
    (cond ((keyword? expr) (keyword->symbol expr))
          ((enumerator? expr) (enumerator->symbol expr))
          (else expr)))
  
  (if (property? expr)
      expr
    (let ((field (category-field class (property->symbol expr))))
      (if (property? field)
          field
        (error "Unknown property: {t}" expr)))))


(definition public (property-field? class <Class> symbol <symbol>)
  (boolean (category-field class symbol)))


;;;
;;;; String
;;;


(class String-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-string len))
  
  
  (method override (coerce-object self obj <Object>)
    (coerce-string obj)))


(class primitive String metaclass String-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "strings"))
  
  
  (method override (coerce-string self)
    self)


  (method override (compare-object self obj)
    (if (string? obj)
        ;; kinda annoying to have to potentialy scan the list twice
        (cond ((string=? self obj)
               :equal)
              ((string<? self obj)
               :less)
              (else
               :greater))
      :incompatible))
  
  
  (method override (ci-compare-object self obj)
    (if (string? obj)
        ;; kinda annoying to have to potentialy scan the list twice
        (cond ((string-ci=? self obj)
               :equal)
              ((string-ci<? self obj)
               :less)
              (else
               :greater))
      :incompatible))
  
  
  (method override (sequence-element self n <fx>) <any>
    (string-ref self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (string-set! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (string-length self))
  
  
  (method override (sequence-tail self n)
    (let ((lgt (cardinality self)))
      (if (>= n lgt)
          ""
        (substring self n (cardinality self)))))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (substring self 0 (- (cardinality self) 1))))


(specialize inline (= s1 <string> s2 <string>) <bool>
  (string=? s1 s2))


(specialize inline (element string <string> n) <char>
  (string-ref string (cast <fx> n)))


(specialize inline (set-element! string <string> n c) <void>
  (string-set! string (cast <fx> n) (cast <char> c)))


(specialize inline (cardinality string <string>) <fx>
  (string-length string))


(specialize inline (subseq string <string> start end) <string>
  (substring string (cast <fx> start) (cast <fx> end)))


(specialize (replace-subseq! string <string> start end replacement) <string>
  ;; should become append! when append! is a specialized definition
  (string-append (subseq string 0 (cast <fx> start))
                 (cast <string> replacement)
                 (subseq string (cast <fx> end) (cardinality string))))


(instantiate-for-each string-for-each <string>)
(instantiate-butlast <string>)
(instantiate-find string-find <string>)
(instantiate-find-in string-find-in <string>)
(instantiate-starts-with? <string>)
(instantiate-ends-with? <string>)


(definition public (empty-string? object)
  (and (string? object)
       (zero? (string-length object))))


(definition public (->string expr (detail :human))
  (cond ((and (string? expr) (eq? detail :human))
         expr)
        ((symbol? expr)
         (symbol->string expr))
        (else
         (let ((output (open-output-string)))
           (print expr output detail)
           (get-output-string output)))))


(definition public (string-search str target (start: start #f))
  (let ((strlen (string-length str))
        (tarlen (string-length target)))
    (let (iter (pos (or start 0)))
      (let ((end (+ pos tarlen)))
        (cond ((> end strlen)
               #f)
              ((equal? (substring str pos end) target)
               pos)
              (else
               (iter (+ pos 1))))))))


(definition public (string-contains? str target (start: start #f))
  (boolean (string-search str target start: start)))


(definition public (string-trailer str <string> c) <string>
  (let ((pos (string-find-reversed str c)))
    (if (not pos)
        str
      (substring str (+ pos 1) (string-length str)))))


(definition public (remove-trailing-char string c)
  (let ((len (cardinality string)))
    (if (and (> len 0)
             (eqv? (element string (- len 1)) c))
        (subseq string 0 (- len 1))
      string)))


(definition public (value-string? object <Object>)
  (and (string? object)
       (not (empty-string? object))))


(definition public (wi=? s1 <Object> s2 <Object>)
  (declare (proper-tail-calls))
  (continuation-capture
    (lambda (return)
      (let* ((n1 <fx> 0)
             (n2 <fx> 0)
             (l1 <fx> (cardinality s1))
             (l2 <fx> (cardinality s2))
             (s? <bool> #t)
             (w1? <bool> #f)
             (w2? <bool> #f)
             (d1? <bool> (= l1 0))
             (d2? <bool> (= l2 0)))
        (while (or (not d1?) (not d2?))
          (set! w1? #f)
          (while (and (not d1?) (whitechar? (element s1 n1)))
            (set! w1? #t)
            (increase! n1)
            (set! d1? (>= n1 l1)))
          (set! w2? #f)
          (while (and (not d2?) (whitechar? (element s2 n2)))
            (set! w2? #t)
            (increase! n2)
            (set! d2? (>= n2 l2)))
          (when (and w1? (or s? d2?))
            (set! w1? #f))
          (when (and w2? (or s? d1?))
            (set! w2? #f))
          (set! s? #f)
          (cond ((and d1? d2?)
                 (continuation-return return #t))
                ((and (eq? w1? w2?) (not d1?) (not d2?) (eqv? (element s1 n1) (element s2 n2)))
                 (increase! n1)
                 (increase! n2)
                 (set! d1? (>= n1 l1))
                 (set! d2? (>= n2 l2)))
                (else
                 (continuation-return return #f))))
        (and d1? d2?)))))


(definition public (unique-domain-name name domain (separator: separator #f))
  (if (not (member? name domain))
      name
    (let* ((common-prefix (if (not separator) name (concatenate name separator)))
           (common-length (cardinality common-prefix))
           (suffixes (collect (lambda (string)
                                (when (starts-with? string common-prefix)
                                  (subseq string common-length)))
                              domain))
           (n 1)
           (suffix #f))
      ;; not 100% sure about the while converted code
      (let (iterate)
        (set! suffix (->string n))
        (when (member? suffix suffixes)
          (increase! n)
          (iterate)))
      (concatenate common-prefix suffix))))


(definition public (remove-numeric-suffix string)
  (let ((pos (find-if (lambda (c) (not (numeric? c))) string reversed?: #t return: 'position)))
    (if (not pos)
        ""
      (subseq string 0 (+ pos 1)))))


(definition public (compare-n x <string> y <string> max <fx> (test: test eqv?))
  (let ((xlen <fx> (string-length x))
        (ylen <fx> (string-length y)))
    (let (iter (n 0))
      (cond ((>= n max)
             #t)
            ((or (>= n xlen) (>= n ylen) (not (test (string-ref x n) (string-ref y n))))
             #f)
            (else
             (iter (+ n 1)))))))


(definition public (string-checksum str)
  (let ((sum 0)
        (len (string-length str)))
    (let (iter (n 0))
      (when (< n len)
        (increase! sum (char->integer (string-ref str n)))
        (iter (+ n 1))))
    sum))


(definition public (split-lines string)
  (call-with-input-string string
    read-lines))


(definition public (join-lines lines)
  (if (null? lines)
      ""
    (join lines "\n")))


(definition public (append-lines . args)
  (join-lines args))


;;;
;;;; Time
;;;


(definition public (seconds->milliseconds x)
  (fxround (* x 1000.)))

(definition public (milliseconds->seconds x)
  (/ x 1000.))


(definition public (seconds->microseconds x)
  (fxround (* x 1000000.)))

(definition public (microseconds->seconds x)
  (/ x 1000000.))


;;;
;;;; Box
;;;


;; mainly because Gambit doesn't have boxed literals
(class Box extends Object
  
  
  (slot boxed getter generate)
    
    
  (method override (initialize self (boxed #f))
    (nextmethod self)
    (set! self.boxed boxed))
  
  
  (method override (print self output readably)
    (if (not boxed)
        (system-format output "~{{a}}"
          (category-name (class-of self)))
      (system-format output "~{{a} {a}}"
        (category-name (class-of self))
        boxed))))


;;;
;;;; Priority Queue
;;;


(class Priority-Queue extends Object
  
  
  (slot priority-count  <fx>)
  (slot queue-vector    <vector>)
  (slot mutex                    initialize (make-mutex))
  (slot mutex-condition-variable initialize (make-condition-variable))
  
  
  (method override (initialize self count)
    (nextmethod self)
    (set! priority-count count)
    (set! queue-vector
          (list->vector (map (lambda (n) (new-queue))
                             (naturals 0 priority-count)))))
  
  
  (method public (empty? self)
    (mutex-lock! mutex)
    (prog1 (not (top-queue self))
      (mutex-unlock! mutex)))
  
  
  (method public (size self)
    (mutex-lock! mutex)
    (prog1 (let ((count 0))
             (loop (for queue in-vector queue-vector)
                   (increase! count (cast <fx> (length (queue-list queue)))))
             count)
      (mutex-unlock! mutex)))
  
  
  (method (top-queue self)
    (let (iter (priority (- priority-count 1)))
      (if (>= priority 0)
          (let ((queue (element queue-vector priority)))
            (if (null? (queue-list queue))
                (iter (- priority 1))
              queue))
        #f)))
  
  
  (method public (push self obj (priority 0))
    (assert (< priority priority-count))
    (mutex-lock! mutex)
    (enqueue (element queue-vector priority) obj)
    (mutex-unlock! mutex)
    (condition-variable-signal! mutex-condition-variable))
  
  
  (method public (pop self timeout)
    (declare (proper-tail-calls))
    (let (iter)
      (mutex-lock! mutex)
      (let ((queue (top-queue self)))
        (if queue
            (prog1 (dequeue queue)
              (mutex-unlock! mutex))
          (if (eqv? timeout 0)
              (prog1 (eof-object)
                (mutex-unlock! mutex))
            (if (mutex-unlock! mutex mutex-condition-variable timeout)
                (iter)
              (eof-object))))))))


;;;
;;;; Thread
;;;


(definition primordial-thread-object
  (current-thread))


(definition public (primordial-thread)
  primordial-thread-object)


(definition public (primordial-thread?)
  (eq? (current-thread) (primordial-thread)))


(definition public (new-thread thunk . rest)
  (apply make-root-thread
         thunk
         rest))


(definition public (thread-group-all-threads thread-group)
  (apply append (thread-group->thread-list thread-group)
    (map thread-group-all-threads (thread-group->thread-group-list thread-group))))


(definition public (top-threads)
  (thread-group-all-threads (thread-thread-group (primordial-thread))))


(definition public (present-thread-name name)
  (cond ((or (not name) (unspecified? name)) "thread")
        ((pair? name) (system-format "{l}" name))
        (else (->string name))))


(definition public (present-thread-state state)
  (let ((port (open-output-string))
        (moment (current-monotonic)))
    (cond ((thread-state-uninitialized? state)
           (system-format port "Uninitialized"))
          ((thread-state-initialized? state)
           (system-format port "Initialized"))
          ((thread-state-normally-terminated? state)
           (system-format port "Normally terminated"))
          ((thread-state-abnormally-terminated? state)
           (system-format port "Abnormally terminated"))
          ((thread-state-running? state)
           (system-format port "Running"))
          ((thread-state-waiting? state)
           (let ((wf (thread-state-waiting-for state))
                 (to (thread-state-waiting-timeout state)))
             (cond (wf
                    (system-format port "Waiting ")
                    (write wf port)
                    (when to
                      (write-timeout (systime->seconds to) moment port)))
                   (to
                    (system-format port "Sleeping")
                    (write-timeout (systime->seconds to) moment port)))))
          (else
           (write state port)))
    
    (get-output-string port)))


(definition public (safe-present-object object (max-width #f))
  (with-exception-catcher
    (lambda (exc)
      ;; add the exception reason somehow!?
      (let ((class-string
              (with-exception-catcher
                (lambda (exc)
                  "")
                (lambda ()
                  (string-append " " (symbol->string (category-name (class-of object))))))))
        (string-append "#<unprintable" class-string " #" (number->string (object->serial object)) ">")))
    (lambda ()
      (if max-width
          (object->string object max-width)
        (object->string object)))))


(definition public (safe-present-property object slot)
  (with-exception-catcher
    (lambda (exc)
      "#<unprintable property>")
    (lambda ()
      (read-property object slot))))


(definition delayed-events
  (open-vector))


(definition package (write-delayed-event thunk)
  (write thunk delayed-events)
  (force-output delayed-events))


(definition package (read-delayed-event)
  (input-port-timeout-set! delayed-events 0)
  (read delayed-events))


(definition public (process-delayed-events)
  (declare (proper-tail-calls))
  (let ((thunk (read-delayed-event)))
    (when (not (eof-object? thunk))
      (thunk)
      (process-delayed-events))))


(definition package (thread-loop? thread)
  (thread-specific thread))

(definition package (thread-start-loop thread)
  (thread-specific-set! thread #t))

(definition package (thread-stop-loop thread)
  (thread-specific-set! thread #f))


(definition package (thread-loop)
  (declare (proper-tail-calls))
  (let (loop)
    (thread-process)
    (when (thread-loop? (current-thread))
      (loop))))


(definition public (start-loop-thread . rest)
  (let ((thread (apply new-thread thread-loop rest)))
    (thread-start-loop thread)
    (thread-start! thread)
    thread))


(definition thread-queues <table>
  (make-table test: eq? weak-keys: #t))

(definition thread-queues-mutex
  (make-mutex 'thread-queues))


(definition package (thread-has-port? thread)
  (boolean (table-ref thread-queues thread #f)))


(definition (get-thread-queue thread) <Priority-Queue>
  (mutex-lock! thread-queues-mutex)
  (prog1 (or (table-ref thread-queues thread #f)
             (let ((queue (new Priority-Queue (if (eq? thread (primordial-thread)) 3 1))))
               (table-set! thread-queues thread queue)
               queue))
    (mutex-unlock! thread-queues-mutex)))


(definition package (thread-write-message thread thunk priority)
  (let ((thread-queue (get-thread-queue thread)))
    (push thread-queue thunk priority)))


(definition package (thread-read-message (timeout: timeout +infinity))
  (let ((thread-queue (get-thread-queue (current-thread))))
    (pop thread-queue timeout)))


(definition package (thread-write thread thunk (priority 0))
  (thread-write-message thread thunk priority))


(definition package (thread-read (timeout: timeout +infinity))
  (thread-read-message timeout: timeout))


(definition public (thread-process (timeout: timeout +infinity))
  (let ((thunk (thread-read-message timeout: timeout)))
    (process-delayed-events)
    (when (not (eof-object? thunk))
      (thunk))))


(definition public (thread-post thread name thunk (priority 0))
  ;; posts are never synchronous
  (thread-write thread thunk priority))


(definition public (thread-block thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (thread-write thread
        (lambda ()
          (mutex-unlock! mutex)
          (thunk))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex))))


(definition public (thread-execute thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (thread-write thread
        (lambda ()
          (unwind-protect
              (thunk)
            (mutex-unlock! mutex)))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex))))


(definition thread-call-noresult
  (list 'thread-call-noresult))


(definition package (thread-call-result? result)
  (neq? result thread-call-noresult))


(definition public (thread-call thread name thunk (priority 0))
  (if (eq? thread (current-thread))
      (thunk)
    (let ((mutex (make-mutex name)))
      (mutex-lock! mutex)
      (mutex-specific-set! mutex thread-call-noresult)
      (thread-write thread
        (lambda ()
          (unwind-protect
              (mutex-specific-set! mutex (thunk))
            (mutex-unlock! mutex)))
        priority)
      (mutex-lock! mutex)
      (mutex-unlock! mutex)
      (mutex-specific mutex))))


(definition public (thread-exit)
  (continuation-return pristine-thread-continuation #f))


(definition public (exit-thread thread)
  (thread-interrupt! thread thread-exit))


(definition public (sleep delay)
  (thread-sleep! delay))


;;;
;;;; Type
;;;


(definition public inline (is-not? object type)
  (not (is? object type)))


(definition public category-identifier
  get-category-identifier)

(definition public category-descendants
  get-category-descendants)

(definition public class-ascendant
  get-class-ascendant)


(definition public inline (category-name category)
  (reference-name (category-identifier category)))


(definition public inline (category-unit category)
  (reference-unit (category-identifier category)))


;;;
;;;; Unspecified
;;;


;; should ideally be implemented as a macro
(definition public (either . rest)
  (continuation-capture
    (lambda (return)
      (for-each (lambda (value)
                  (when (specified? value)
                    (continuation-return return value)))
                rest)
      (unspecified))))


;;;
;;;; Vector
;;;


(class Vector-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (make-vector len)))


(class primitive Vector metaclass Vector-Class extends Sequence
  
  
  (method override (initialize self . rest)
    (native-class "vectors"))


  @convert
  (method (object-similar? object)
    (and (vector? object)
         (zero? (cardinality self))
         (zero? (cardinality object))))
  
  
  (method override (sequence-element self n)
    (vector-ref self n))
  
  
  (method override (sequence-set-element! self n obj)
    (vector-set! self n obj))
  
  
  (method override (sequence-cardinality self)
    (vector-length self))
  
  
  (method override (sequence-tail self n)
    (list->vector (tail (vector->list self) n)))
  
  
  (method override (sequence-last self)
    (element self (- (cardinality self) 1)))
  
  
  (method override (sequence-butlast self)
    (list->vector (butlast (vector->list self)))))


(specialize inline (element vector <vector> n) <object>
  (vector-ref vector (cast <fx> n)))


(specialize inline (set-element! vector <vector> n obj) <void>
  (vector-set! vector (cast <fx> n) obj))


(specialize inline (cardinality vector <vector>) <fx>
  (vector-length vector))


(definition public (vector-map proc vector <vector> . vectors)
  (declare (proper-tail-calls))
  (let* ((length (vector-length vector))
         (new-vector (make-vector length)))
    (if (null? vectors)
        (let (loop (i 0))
          (when (< i length)
            (vector-set! new-vector i (proc (vector-ref vector i)))
            (loop (+ i 1))))
      (let (loop (i 0))
        (when (< i length)
          (vector-set! new-vector i (apply proc (vector-ref vector i) (map (lambda (vector <vector>)
                                                                             (vector-ref vector i))
                                                                           vectors)))
          (loop (+ i 1)))))
    new-vector))


(definition public (vector-for-each proc vector <vector> . vectors)
  (declare (proper-tail-calls))
  (let ((size (vector-length vector)))
    (if (null? vectors)
        (let (loop (i 0))
          (when (< i size)
            (proc (vector-ref vector i))
            (loop (+ i 1))))
      (let (loop (i 0))
        (when (< i size)
          (apply proc (vector-ref vector i) (map (lambda (vector <vector>)
                                                   (vector-ref vector i))
                                                 vectors))
          (loop (+ i 1)))))))


(definition public inline (allocate-vector size) <vector>
  (make-vector size))


(definition public (subvector-shift! vector <vector> start <fx> end <fx> shift <fx>)
  (let ((last (- end 1)))
    (cond ((< shift 0)
           (loop (for i from start to last)
                 (vector-set! vector (+ i shift) (vector-ref vector i))))
          ((> shift 0)
           (loop (for i from last downto start)
                 (vector-set! vector (+ i shift) (vector-ref vector i)))))))


(definition public (subf64vector-shift! vector <f64vector> start <fx> end <fx> shift <fx>)
  (let ((last (- end 1)))
    (cond ((< shift 0)
           (loop (for i from start to last)
                 (f64vector-set! vector (+ i shift) (f64vector-ref vector i))))
          ((> shift 0)
           (loop (for i from last downto start)
                 (f64vector-set! vector (+ i shift) (f64vector-ref vector i)))))))


;;;
;;;; Homogeneous
;;;


(definition public inline (allocate-s8vector  size) <s8vector>  (make-s8vector  size))
(definition public inline (allocate-u8vector  size) <u8vector>  (make-u8vector  size))
(definition public inline (allocate-s16vector size) <s16vector> (make-s16vector size))
(definition public inline (allocate-u16vector size) <u16vector> (make-u16vector size))
(definition public inline (allocate-s32vector size) <s32vector> (make-s32vector size))
(definition public inline (allocate-u32vector size) <u32vector> (make-u32vector size))
(definition public inline (allocate-s64vector size) <s64vector> (make-s64vector size))
(definition public inline (allocate-u64vector size) <u64vector> (make-u64vector size))
(definition public inline (allocate-f32vector size) <f32vector> (make-f32vector size))
(definition public inline (allocate-f64vector size) <f64vector> (make-f64vector size))


;;;
;;;; Axis
;;;


(definition AXIS_MIN_SIZE <fx>
  8)

(definition AXIS_GOLDEN_RATIO <fl>
  1.6)


(class Axis-Class extends Sequence-Class
  
  
  (method override (make-sequence self len)
    (new Axis len)))


(class Axis metaclass Axis-Class extends Sequence
  
  
  (slot size    <fx>     accessors generate)
  (slot content <vector> accessors generate)
  
  
  (method override (initialize self (s <fx> 0))
    (set! size s)
    (set! content (make-vector s #f)))
  
  
  (method override (print self output detail)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{s} {s}" size content))))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element self n))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! self n obj))
  
  
  (method override (sequence-cardinality self) <fx>
    (cardinality self))
  
  
  (method override (sequence-tail self n <fx>) <Axis>
    (tail self n))
  
  
  (method override (sequence-last self) <any>
    (last self)))


(definition public (axis . rest)
  (coerce rest Axis))


(specialize inline (element axis <Axis> n) <any>
  (vector-ref (get-content axis) (cast <fx> n)))


(specialize inline (set-element! axis <Axis> n obj) <void>
  (vector-set! (get-content axis) (cast <fx> n) obj))


(specialize inline (cardinality axis <Axis>) <fx>
  (get-size axis))


(specialize (tail axis <Axis> n) <Axis>
  (let ((n (cast <fx> n)))
    (let ((new-axis (new Axis n))
          (offset (- (get-size axis) n)))
      (let (iter (i 0))
        (if (>= i n)
            new-axis
          (set-element! new-axis i (element axis (+ i offset)))
          (iter (+ i 1)))))))


(specialize (last axis <Axis>) <any>
  (element axis (- (get-size axis) 1)))


(specialize (insert! axis <Axis> pos obj) <Axis>
  (let ((pos (cast <fx> pos)))
    (replace-subseq! axis pos pos (list obj))))


(specialize (replace-subseq! axis <Axis> start end replacement) <Axis>
  (let ((start (cast <fx> start))
        (end (cast <fx> end))
        (replacement (cast <list> replacement)))
    (let* ((before (- end start))
           (after (cardinality replacement))
           (delta (- after before))
           (old-size (get-size axis))
           (new-size (+ old-size delta)))
      (cond ((< after before)
             (let (iter (n (- old-size end))
                        (src end)
                        (dst (+ end delta)))
               (when (> n 0)
                 (set-element! axis dst (element axis src))
                 (set-element! axis src #f)
                 (iter (- n 1) (+ src 1) (+ dst 1))))
             (axis-adjust axis new-size))
            ((> after before)
             (axis-adjust axis new-size)
             (let (iter (n (- old-size end))
                        (src (- old-size 1))
                        (dst (+ (- old-size 1) delta)))
               (when (> n 0)
                 (set-element! axis dst (element axis src))
                 (iter (- n 1) (- src 1) (- dst 1))))))
      (let (iter (n 0) (dst start))
        (when (< n after)
          (set-element! axis dst (element replacement n))
          (iter (+ n 1) (+ dst 1))))
      axis)))


(definition public (axis-remove! axis <Axis> element <any>) <void>
  (let ((n (find axis element)))
    (and n
         (let* ((start <fx> n)
                (end (+ start 1)))
           (replace-subseq! axis start end '())))))


(definition public (axis-adjust axis <Axis> n <fx>)
  (cond ((<= n (cardinality (get-content axis)))
         (set-size axis n))
        ((= (get-size axis) 0)
         (set-size axis n)
         (set-content axis (make-vector AXIS_MIN_SIZE #f)))
        (else
         (let ((old-real-size (cardinality (get-content axis)))
               (old-content (get-content axis)))
           (set-size axis n)
           (set-content axis (make-vector (fxround (* n AXIS_GOLDEN_RATIO)) #f))
           (let (iter (i 0))
             (when (< i old-real-size)
               (set-element! (get-content axis) i (element old-content i))
               (iter (+ i 1))))))))


(definition public (axis-add axis <Axis> obj)
  (let ((size (cardinality axis)))
    (axis-adjust axis (+ size 1))
    (set-element! axis size obj)))


(definition public inline (allocate-axis size <fx>) <Axis>
  (allocate Axis size (make-vector size #f)))

(specialize inline (new class <category<Axis>> size) <Axis>
  (allocate-axis size))


(specialize inline as axis-ref (element axis <Axis> n) <object>
  (vector-ref (get-content axis) (cast <fx> n)))


(specialize inline as axis-set! (set-element! axis <Axis> n obj) <void>
  (vector-set! (get-content axis) (cast <fx> n) obj))


(specialize inline as axis-cardinality (cardinality axis <Axis>) <fx>
  (get-size axis))


(instantiate-for-each axis-for-each <Axis>)
(instantiate-find axis-find <Axis>)
(instantiate-find-in axis-find-in <Axis>)


;;;
;;;; Dispatch
;;;


(definition public (dispatch? expr)
  (and (symbol? expr)
       (dispatch-string? (symbol->string expr))))


(definition public (dispatch-string? str)
  (and (ends-with? str "~")
       (not (string=? str "~"))))


(definition public (dispatch->name dispatch)
  (define (extract str)
    (subseq str 0 (- (cardinality str) 1)))
  
  (if (string? dispatch)
      (extract dispatch)
    (string->symbol (extract (symbol->string dispatch)))))


;;;
;;;; Enumeration
;;;


(class Enumeration extends Class
  
  
  (slot members initialize '() accessors generate)
  
  
  (method package (add-member self member)
    (set! members (append! members (list member))))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a}" members))))


  (method (name->member self name)
    (or (find-in members name key: get-name test: eq?)
        (error "Unknown enumeration name: {t} in {t}" name self)))


  (method (value->member self value)
    (or (find-in members value key: get-value test: eqv?)
        (error "Unknown enumeration value: {t} in {t}" value self)))


  (method public (name->value self name)
    (get-value (name->member self name)))


  (method public (value->name self value)
    (get-name (value->member self value)))
  
  
  (method public (bits->names self bits)
    (let ((fact (new List-Factory)))
      (for-each (lambda (member)
                  (when (mask-bit-set? bits (get-value member))
                    (put fact (get-name member))))
                members)
      (get-output fact))))


(class Enumeration-Member metaclass Enumeration extends Object
  
  
  (slot name getter generate)
  
  
  (method override (initialize self name)
    (nextmethod self)
    (set! self.name name)
    (add-member (class-of self) self))


  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (system-format output "{a}" name))))
  
  
  (method package virtual (get-value self)
    ))


(definition public (enumeration? obj)
  (is? obj Enumeration))


;;;
;;;; Attributes
;;;


(definition public (parse-attributes list)
  (let ((properties #f)
        (content #f))
    (let (iterate (scan list))
      (if (null? scan)
          (values (if properties (queue-list properties) '())
                  (if content (queue-list content) '()))
        (let ((element (car scan)))
          (if (and (not content) (keyword? element))
              (begin
                (when (not properties)
                  (set! properties (new-queue)))
                (enqueue properties element)
                (enqueue properties (cadr scan))
                (iterate (cddr scan)))
            (when (not content)
              (set! content (new-queue)))
            (enqueue content element)
            (iterate (cdr scan))))))))


;;;
;;;; Nicknames
;;;


;; quick solution
(hub find-component)


(definition *nicknames*
  (make-table test: eq?))


(definition public (registered-nicknames)
  *nicknames*)

(definition public (register-nickname name object)
  (table-set! *nicknames* name object))

(definition public (resolve-nickname name)
  (if (pair? name)
      (let ((component (resolve-nickname (car name))))
        (and component
             (let ((path (cdr name)))
               (if (null? path)
                   component
                 (find-component component path)))))
    (let ((resolver (table-ref *nicknames* name #f)))
      (and resolver (resolver)))))


;;;
;;;; Reference
;;;


(definition public (reference-string? str)
  (and (string-find-reversed str #\:)
       (not (string-starts-with? str ":"))
       (not (string-ends-with? str ":"))))


(definition public (reference->name str)
  (let ((pos (string-find-reversed str #\:)))
    (if (not pos)
        str
      (substring str (+ pos 1) (string-length str)))))


;;;
;;;; Encoding
;;;


(definition public (32-bit-integer->bytes x proc)
  (proc (modulo (arithmetic-shift x -24) 256)
        (modulo (arithmetic-shift x -16) 256)
        (modulo (arithmetic-shift x -8) 256)
        (modulo x 256)))


(definition public (64-bit-integer->bytes x proc)
  (proc (modulo (arithmetic-shift x -56) 256)
        (modulo (arithmetic-shift x -48) 256)
        (modulo (arithmetic-shift x -40) 256)
        (modulo (arithmetic-shift x -32) 256)
        (modulo (arithmetic-shift x -24) 256)
        (modulo (arithmetic-shift x -16) 256)
        (modulo (arithmetic-shift x -8) 256)
        (modulo x 256)))


(definition public (bytes->32-bit-integer b1 b2 b3 b4)
  (+ (arithmetic-shift b1 24)
     (arithmetic-shift b2 16)
     (arithmetic-shift b3 8)
     b4))


(definition public (bytes->64-bit-integer b1 b2 b3 b4 b5 b6 b7 b8)
  (+ (arithmetic-shift b1 56)
     (arithmetic-shift b2 48)
     (arithmetic-shift b3 40)
     (arithmetic-shift b4 32)
     (arithmetic-shift b5 24)
     (arithmetic-shift b6 16)
     (arithmetic-shift b7 8)
     b8))


(definition public (code-string->32-bit-integer s)
  (bytes->32-bit-integer (char->integer (string-ref s 0))
                         (char->integer (string-ref s 1))
                         (char->integer (string-ref s 2))
                         (char->integer (string-ref s 3))))


(definition public (32-bit-integer->code-string x)
  (32-bit-integer->bytes x
    (lambda (b0 b1 b2 b3)
      (string (integer->char b0)
              (integer->char b1)
              (integer->char b2)
              (integer->char b3)))))


;;;
;;;; I/O
;;;


(definition public undocumented (make-u8-content size content)
  (cons size content))

(definition public undocumented (u8-content-size content)
  (car content))

(definition public undocumented (iterate-u8-content content proc)
  (for-each (lambda (chunk)
              (bind (u8vector . size) chunk
                (proc u8vector size)))
            (cdr content)))


(definition public undocumented (read-u8-content port)
  (define chunk-size
    1024)
  
  (declare (proper-tail-calls))
  (let ((size 0)
        (fact (new List-Factory)))
    (let (loop)
      (let ((u8vector (make-u8vector chunk-size)))
        (let ((read (read-subu8vector u8vector 0 chunk-size port)))
          (if (= read 0)
              (make-u8-content size (get-output fact))
            (increase! size read)
            (put fact (cons u8vector read))
            (loop)))))))


(definition public undocumented (write-u8-content content port)
  (iterate-u8-content content
    (lambda (u8vector size)
      (write-subu8vector u8vector 0 size port))))


(definition public undocumented (start-pump port proc)
  (declare (proper-tail-calls))
  (let ((size 1000))
    (let ((buffer (make-string size)))
      (let (iterate)
        (let ((n (read-substring buffer 0 size port 1)))
          (proc (if (> n 0)
                    (substring buffer 0 n)
                  ;; eof
                  #f))
          (iterate))))))


(definition public (write-32-bit-integer n port)
  (32-bit-integer->bytes n
    (lambda (b1 b2 b3 b4)
      (write-u8 b1 port)
      (write-u8 b2 port)
      (write-u8 b3 port)
      (write-u8 b4 port))))


(definition public (read-32-bit-integer port)
  (let* ((b1 (read-u8 port))
         (b2 (read-u8 port))
         (b3 (read-u8 port))
         (b4 (read-u8 port)))
    (if (eof-object? b4)
        b4
      (bytes->32-bit-integer b1 b2 b3 b4))))


(definition public (write-binary-content data port (encoder #f))
  (let ((u8vect (if encoder
                    (object->u8vector data encoder)
                  (object->u8vector data))))
    (let ((size (u8vector-length u8vect)))
      (write-32-bit-integer size port)
      (write-subu8vector u8vect 0 size port)
      (force-output port)
      (+ 4 size))))


(definition public (read-binary-content port (decoder #f))
  (let ((size (read-32-bit-integer port)))
    (if (eof-object? size)
        size
      (let ((u8vect (make-u8vector size)))
        (let ((read (read-subu8vector u8vect 0 size port)))
          (if (/= read size)
              (eof-object)
            (if decoder
                (u8vector->object u8vect decoder)
              (u8vector->object u8vect))))))))


(definition public (write-binary data port)
  (write-binary-content data port serialize))


(definition public (read-binary port)
  (read-binary-content port deserialize))


;;;
;;;; Input
;;;


(definition public (read-until test input)
  (declare (proper-tail-calls))
  (let ((queue (new-queue)))
    (let (iterate)
      (let ((expr (read input)))
        (if (test expr)
            (queue-list queue)
          (enqueue queue expr)
          (iterate))))))


(definition public (read-string-element string)
  (call-with-input-string string
    read))


(definition public (read-string-content string)
  (call-with-input-string string
    (lambda (input)
      (read-until eof-object? input))))


(definition public (readable-string? string)
  (with-exception-catcher
    (lambda (e) 
      #f)
    (lambda ()
      (with-readtable jazz-readtable 
        (lambda ()
          (read-string-element string)
          #t)))))


(definition public (read-string-safe string)
  (and (string? string) 
       (not (empty-string? string))
       (with-exception-catcher
         (lambda (e) 
           #f)
         (lambda ()
           (with-readtable jazz-readtable 
             (lambda () 
               (read-string-element string)))))))


(definition public (read-delimited-string string char)
  (declare (proper-tail-calls))
  (call-with-input-string string
    (lambda (input)
      (let ((fact (new List-Factory)))
        (let (iterate)
          (let ((lst (read-delimited input "delimited" char #t)))
            (put fact lst)
            (skip-whites input)
            (if (eof-object? (peek-char input))
                (get-output fact)
              (iterate))))))))


(definition public (require-char input)
  (let ((c (read-char input)))
    (if (eof-object? c)
        (error "Unexpected end of stream reached while reading")
      c)))


(definition public (skip-line input)
  (let (iterate)
    (let ((c (read-char input)))
      (if (and (not (eof-object? c))
               (not (eqv? c #\newline))
               (not (eqv? c #\return)))
          (iterate)
        (if (eqv? c #\return)
            (read-char input))))))


(definition public (skip-whites input)
  (let (iterate)
    (let ((c (peek-char input)))
      (unless (eof-object? c)
        (if (eqv? c #\;)
            (skip-line input)
          (when (whitespace? c)
            (read-char input)
            (iterate)))))))


(definition public (read-delimited input kind delimiter (allow-eof? #f))
  (let ((queue (new-queue))
        (delimiters (listify delimiter)))
    (let (iterate)
      (skip-whites input)
      (let ((c (peek-char input)))
        (cond ((eof-object? c)
               (if allow-eof?
                   (queue-list queue)
                 (error "Unexpected end of stream reached while reading {a}" kind)))
              ((memv? c delimiters)
               (read-char input)
               (queue-list queue))
              ((eqv? c #\.)
               (enqueue-list queue (read input))
               (iterate))
              (else
               (enqueue queue (read input))
               (iterate)))))))


(definition public inline (string-delimiter? c)
  (eqv? c #\double-quote))


(definition public (read-lines input)
  (declare (proper-tail-calls))
  (let ((queue (new-queue)))
    (let (iterate (last-proper? #t))
      (receive (line proper?) (read-proper-line input)
        (if line
            (begin
              (enqueue queue line)
              (iterate proper?))
          (when last-proper?
            (enqueue queue ""))
          (queue-list queue))))))


(definition public (read-lines-chunked input chunk-size proc)
  (declare (proper-tail-calls))
  (let (iterate (count 0) (queue (new-queue)) (last-proper? #t))
    (receive (line proper?) (read-proper-line input)
      (if line
          (begin
            (enqueue queue line)
            (let ((count (+ count 1)))
              (if (or (not chunk-size) (< count chunk-size))
                  (iterate count queue proper?)
                (proc (queue-list queue))
                (iterate 0 (new-queue) proper?))))
        (when last-proper?
          (enqueue queue ""))
        (when (or (> count 0) last-proper?)
          (proc (queue-list queue)))
        (unspecified)))))


(definition public (read-content-string input)
  ;; passing #f to gambit's read-line makes it never see an actual
  ;; end-of-line so that it will read the whole content as a string
  (let ((line (read-line input #f)))
    (if (eof-object? line)
        ""
      line)))


(definition public (pipe input output)
  (declare (proper-tail-calls))
  (let (iterate)
    (let ((c (read-char input)))
      (if (not (eof-object? c))
          (begin
            (write-char c output)
            (iterate))))))


;;;
;;;; Printer
;;;


(definition public (textual expr (output (current-output-port)))
  (write expr output)
  @wait-bug-fix-for-char-and-probably-others
  (print expr output :text))


(definition public (describe expr (output (current-output-port)))
  (print expr output :describe))


(definition public (fresh-line (output (current-output-port)))
  (unless (at-fresh-line? output)
    (newline output)))


(definition public (at-fresh-line? (output (current-output-port)))
  ;; todo
  #f)


;;;
;;;; Printers
;;;


(definition *printers* <table>
  (make-table test: eq?))


(definition package (register-printer name proc)
  (table-set! *printers* name proc))


(definition public (with-printer printer proc)
  (if (eq? printer :string)
      (let ((output (open-output-string)))
        (proc output)
        (get-output-string output))
    (proc
      (let ((printer-proc (table-ref *printers* printer #f)))
        (if printer-proc
            (printer-proc)
          printer)))))


(register-printer :terminal terminal-port)


;;;
;;;; Output
;;;


(definition public (present-reference reference)
  (define (present-identifier identifier)
    (let ((names (split (symbol->string identifier) ".")))
      (if (null? (cdr names))
          (car names)
        (let ((reversed (reverse! names)))
          (system-format "{a}.{a}" (element reversed 1) (element reversed 0))))))
  
  (receive (identifier referee) (break-reference reference)
    (if (not referee)
        (symbol->string identifier)
      (let ((referee-name (->string referee)))
        (if (string-find-reversed referee-name #\:)
            referee-name
          (system-format "{a}:{a}" (present-identifier identifier) referee-name))))))


(definition public (write-line line . rest)
  (let ((port (if (null? rest) #f (car rest))))
    (display line port)
    (newline port)))


(definition public (write-lines output lines)
  (loop (for line in lines remainder remain)
        (do (display line output)
            (unless (null? remain)
              (newline output)))))


;;;
;;;; Function
;;;


(definition public inline (do-nothing . rest)
  )


(definition public inline (identity x)
  x)


(definition public inline (const x)
  (lambda args x))


(definition public inline (compose f g)
  (lambda (x)
    (f (g x))))


(definition public (compose* . fns)
  (if (null? fns)
      identity
    (let ((f (car fns))
          (g (apply compose* (cdr fns))))
      (lambda (x)
        (f (g x))))))


;;;
;;;; Subseq
;;;


(class Subseq-Class extends Sequence-Class)


(class Subseq metaclass Subseq-Class extends Sequence
  
  
  (slot sequence      getter    generate)
  (slot start    <fx> accessors generate)
  (slot size     <fx> accessors generate)
  
  
  (method override (initialize self sequence start <fx> size <fx>)
    (nextmethod self)
    (set! self.sequence sequence)
    (set! self.start start)
    (set! self.size size))
  
  
  (method override (print self output detail)
    (if (string? sequence)
        ;; should take detail into account
        (loop (for n from start below (+ start size))
              (do (write-char (string-ref sequence n) output)))
      (print-unreadable self output
        (lambda (output)
          (system-format output "{s} {s} {s}" sequence start size)))))
  
  
  (method override (coerce-string self)
    (if (string? sequence)
        (substring sequence start (+ start size))
      (error "Cannot coerce sequence to string")))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element sequence (+ start n)))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! sequence (+ start n) obj))
  
  
  (method override (sequence-cardinality self) <int>
    size)
  
  
  (method override (sequence-subseq! self s <fx> e <fx>) <Subseq>
    (if (or (= s 0) (= e -1))
        self
      (new Subseq sequence (+ start s) (- (if (= e -1) (cardinality self) e) s)))))


(definition public inline (allocate-subseq sequence <string> start <fx> size <fx>) <Subseq>
  (allocate Subseq sequence start size))

(specialize inline (new class <category<Subseq>> sequence start size) <Subseq>
  (allocate-subseq sequence start size))


(definition public (offset-subseq! subseq <Subseq> offset <fx>) <void>
  (set-start subseq (+ (get-start subseq) offset)))


(definition public (grow-subseq! subseq <Subseq> n <fx>) <void>
  (set-size subseq (+ (get-size subseq) n)))


(specialize inline as subseq-ref (element subseq <Subseq> n) <object>
  (element (get-sequence subseq) (+ (get-start subseq) (cast <fx> n))))


(specialize inline as subseq-set! (set-element! subseq <Subseq> n obj) <void>
  (set-element! (get-sequence subseq) (+ (get-start subseq) (cast <fx> n)) obj))


(specialize inline as subseq-cardinality (cardinality subseq <Subseq>) <int>
  (get-size subseq))


;;;
;;;; Subseq$string$
;;;


(class Subseq$string$-Class extends Sequence-Class)


(class Subseq$string$ metaclass Subseq$string$-Class extends Sequence
  
  
  (slot sequence <string> getter    generate)
  (slot start    <fx>     accessors generate)
  (slot size     <fx>     accessors generate)
  
  
  (method override (initialize self sequence <string> start <fx> size <fx>)
    (nextmethod self)
    (set! self.sequence sequence)
    (set! self.start start)
    (set! self.size size))
  
  
  (method override (print self output detail)
    (let ((str (substring sequence start (+ start size))))
      (if (eq? detail :human)
          (print str output detail)
        (print-unreadable self output
          (lambda (output)
            (system-format output "{s}" str))))))
  
  
  (method public (print-content self output)
    (display (substring sequence start (+ start size)) output))
  
  
  (method override (sequence-element self n <fx>) <any>
    (element sequence (+ start n)))
  
  
  (method override (sequence-set-element! self n <fx> obj <any>) <void>
    (set-element! sequence (+ start n) obj))
  
  
  (method override (sequence-cardinality self) <int>
    size)
  
  
  (method override (sequence-subseq! self s <fx> e <fx>) <Subseq$string$>
    (if (and (= s 0) (= e -1))
        self
      (new Subseq$string$ sequence (+ start s) (- (if (= e -1) (cardinality self) e) s)))))


(definition public inline (allocate-subseq$string$ sequence <string> start <fx> size <fx>) <Subseq$string$>
  (allocate Subseq$string$ sequence start size))

(specialize inline (new class <category<Subseq$string$>> sequence start size) <Subseq$string$>
  (allocate-subseq$string$ sequence start size))


(specialize inline (element subseq <Subseq$string$> n) <char>
  (element (get-sequence subseq) (+ (get-start subseq) (cast <fx> n))))


(specialize inline (set-element! subseq <Subseq$string$> n obj) <void>
  (set-element! (get-sequence subseq) (+ (get-start subseq) (cast <fx> n)) (cast <char> obj)))


(specialize inline (cardinality subseq <Subseq$string$>) <fx>
  (get-size subseq))


(specialize (subseq! seq <string> s e) <Subseq$string$>
  (let ((s (cast <fx> s))
        (e (cast <fx> e)))
    (new Subseq$string$ seq s (- e s))))


(specialize (subseq! subseq <Subseq$string$> s e) <Subseq$string$>
  (let ((s (cast <fx> s))
        (e (cast <fx> e)))
    (new Subseq$string$ (get-sequence subseq) (+ (get-start subseq) s) (- e s))))


(specialize (offset-subseq! subseq <Subseq$string$> offset) <void>
  (set-start subseq (+ (get-start subseq) (cast <fx> offset))))


(specialize (grow-subseq! subseq <Subseq$string$> n) <void>
  (set-size subseq (+ (get-size subseq) (cast <fx> n))))


;;;
;;;; Values
;;;


(definition public (values->list values)
  (call-with-values (lambda () values) list))


;;;
;;;; Capabilities
;;;


(definition protected capabilities
  (make-table test: eq?))


(definition public (get-capability capability (default-value #f))
  (table-ref capabilities capability default-value))

(definition public (set-capability capability value)
  (table-set! capabilities capability value))


;;;
;;;; Site
;;;


(definition protected siteids <vector>
  (make-vector 256 #f))


(definition public inline (id->site id <fx>) <Call-Site>
  (vector-ref siteids id))


(definition next-site-id <fx>
  0)

(definition (next-site-id!) <fx>
  (prog1 next-site-id
    (increase! next-site-id)))

(definition protected (site-id-count) <fx>
  next-site-id)


(definition call-sites <table>
  (make-table test: eq?))


(definition public (registered-sites)
  call-sites)

(definition public (registered-site name) <Call-Site>
  (table-ref call-sites name))

(definition public (find-site name) <Call-Site+>
  (table-ref call-sites name #f))

(definition public (register-site pathname parent-pathname properties)
  (let ((name (car pathname))
        (identifier (apply compose-identifier pathname)))
    (or (table-ref call-sites identifier #f)
        (let ((id (next-site-id!))
              (parent (and (not-null? parent-pathname) (apply compose-identifier parent-pathname))))
          (let ((site (new-call-site name identifier id parent properties (lambda (site thunk) (thunk)))))
            (vector-set! siteids id site)
            (table-set! call-sites identifier site)
            (when site-callback
              (site-callback site))
            site)))))


(definition site-callback
  #f)

(definition public (get-site-callback)
  site-callback)

(definition public (set-site-callback callback)
  (set! site-callback callback))


(definition public (call-site-ref name)
  (get-procedure (registered-site name)))

(definition public (call-site-set! name value)
  (set-procedure (registered-site name) value)))
