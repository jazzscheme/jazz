;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Syntax Tests
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2015
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jazz.validate.suite.Syntax-Tester jazz


(import (jazz.jml)
        (jazz.validation))


(class Syntax-Tester extends Tester
  
  
  (form
    (<install> title: "Syntax"))


  (method override (test self)
    (invoke self "Quote" test-quote)
    (invoke self "If" test-if)
    (invoke self "When" test-when)
    (invoke self "Unless" test-unless)
    (invoke self "While" test-while)
    (invoke self "Until" test-until)
    (invoke self "For" test-for)
    (invoke self "Begin" test-begin)
    (invoke self "Prog1" test-prog1)
    (invoke self "Cond" test-cond)
    (invoke self "Case" test-case)
    (invoke self "ECase" test-ecase)
    (invoke self "Typecase" test-typecase)
    (invoke self "And" test-and)
    (invoke self "Or" test-or)
    (invoke self "Set!" test-set!)
    (invoke self "Increase!" test-increase!)
    (invoke self "Decrease!" test-decrease!))
  
  
  ;;;
  ;;;; Quote
  ;;;


  (method (test-quote self)
    (check (equal? '(a b c) (list 'a 'b 'c)))
    
    @Interpreted
    (begin
      (check (error? (code-walk '(quote) self '())))
      (check (error? (code-walk '(quote a b c) self '())))))
  
  
  ;;;
  ;;;; If
  ;;;


  (method (test-if self)
    @Interpreted
    (begin
      (check (error? (code-walk '(if) self '())))
      (check (error? (code-walk '(if #f) self '())))))
  
  
  ;;;
  ;;;; When
  ;;;


  (method (test-when self)
    @Interpreted
    (begin
      (check (error? (code-walk '(when) self '())))))
  
  
  ;;;
  ;;;; Unless
  ;;;
  

  (method (test-unless self)
    (check (= (foo self) 50))
    @convert
    (check (equal? (unless (= 2 2) 5) #f))
    @convert
    (check (equal? (unless (= 2 3) 5) 5)))
  
  
  ;;;
  ;;;; While
  ;;;


  (method (test-while self)
    )
  
  
  ;;;
  ;;;; Until
  ;;;


  (method (test-until self)
    )
  
  
  ;;;
  ;;;; For
  ;;;


  (method (test-for self)
    )
  
  
  ;;;
  ;;;; Begin
  ;;;


  (method (test-begin self)
    )
  
  
  ;;;
  ;;;; Prog1
  ;;;


  (method (test-prog1 self)
    )
  
  
  ;;;
  ;;;; Cond
  ;;;


  (method (test-cond self)
    @bad-scheme-syntax
    (let ((v (cond)))
      (check (not v)))
    (let ((x 2)
          (y 3))
      (check (= (cond ((= x 5) 7)
                         ((= y 3) 8)
                         (else 9))
                   8))))
  
  
  ;;;
  ;;;; Case
  ;;;


  (method (test-case self)
    @bad-scheme-syntax
    (let ((v (case 2)))
      (check (not v)))
    (check (= (case 3
                   ((5) 7)
                   ((3) 8)
                   (else 9))
                 8)))
  
  
  ;;;
  ;;;; ECase
  ;;;


  (method (test-ecase self)
    @bad-scheme-syntax
    (let ((v (ecase 2)))
      (check (not v)))
    (let ((x 2)
          (y 3))
      (check (= (ecase 3
                     ((x) 7)
                     ((y) 8)
                     (else 9))
                   8))))
  
  
  ;;;
  ;;;; Typecase
  ;;;


  (method (test-typecase self)
    @bad-scheme-syntax
    (let ((v (typecase 2)))
      (check (not v)))
    (check (= (typecase 3
                   ((Symbol) 7)
                   ((Number) 8)
                   (else 9))
                 8)))
  
  
  ;;;
  ;;;; And
  ;;;


  (method (test-and self)
    (check (equal? (and) #t))
    (check (equal? (and #t #f #t) #f))
    (check (equal? (and #t #t) #t))
    (check (equal? (and #f 2) #f))
    (check (equal? (and 2 3 5) 5)))
  
  
  ;;;
  ;;;; Or
  ;;;


  (method (test-or self)
    (check (equal? (or) #f))
    (check (equal? (or #f #t #f) #t))
    (check (equal? (or #f #f) #f))
    (check (equal? (or #f #f (+ 2 3) #f) 5))
    (check (equal? (or #f #f) #f)))
  
  
  ;;;
  ;;;; Set!
  ;;;


  (method (test-set! self)
    )
  
  
  ;;;
  ;;;; Increase!
  ;;;
  
  
  (method (foo self)
    (let ((total 0))
      (loop (for n from 0 below 10)
            (increase! total 5))
      total))


  (method (test-increase! self)
    (check (= (foo self) 50)))
  
  
  ;;;
  ;;;; Decrease!
  ;;;


  (method (goo self n)
    (let ((total 100))
      (loop (for i from 1 to 10)
            (decrease! total 5))
      total))


  (method (test-decrease! self)
    (check (= (goo self 5) 50))))


;;;
;;;; X
;;;


(class X extends Object
  
  
  (slot counter initialize 4)))
