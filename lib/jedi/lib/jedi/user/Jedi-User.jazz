;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jedi User
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jedi.user.Jedi-User jazz


(import (jazz.designer)
        (jazz.ide)
        (jazz.io)
        (jazz.jml)
        (jazz.language.jazz)
        (jazz.language.jazz.debuggee)
        (jazz.library)
        (jazz.network)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.activity)
        (jazz.ui.view)
        (jazz.utilities)
        (jazz.user)
        (jazz.website)
        (jedi))


(class Jedi-User extends IDE-User

  
  ;;;
  ;;;; Catalogs
  ;;;
  
  
  (method (load-catalog name)
    (load-catalog-synchronized name)
    @temp-commented-because-of-an-intermitent-bug-where-the-thread-will-allocate-memory-while-garbage-collecting
    (new Thread
      name: "Catalog Loader"
      context: self
      execute:
      (function (thread)
        (load-catalog-synchronized name))))
  
  
  (method synchronized (load-catalog-synchronized name)
    (let* ((appl (get-application))
           (cataloguer (get-cataloguer~ appl))
           (catalog (get-catalog~ cataloguer name error?: #f)))
      (when catalog
        (set-active?~ catalog #t))))

  
  ;;;
  ;;;; Console
  ;;;
  
  
  (method (console-command command arguments)
    (case command
      ;; Documentation
      ((:doc) (edit-documentation (car arguments)))
      ;; Macro
      ((:expand) (expand (car arguments)))
      ((:expand-scheme) (expand-scheme (car arguments)))
      ;; Various
      ((:touch) (touch arguments))
      ((:touch-descendants) (touch-descendants arguments))
      ((:compile) (compile arguments))
      ((:edit) (edit arguments))
      ((:exit) (exit) #t)
      (else (nextmethod command arguments))))
  
  
  (method (edit-documentation name)
    (let ((appl (get-application)))
      (edit-documentation~ appl name)))

  
  (method (expand form)
    (unimplemented)
    @convert
    (bind (name . arguments) form
      (let* ((try (function (object) (category-field (class-of object) name)))
             (definition (either (try Language) (try Java) (essay Interactive-Object (try Interactive-Object)))))
        (if (null? definition)
            (begin
              (debug form)
              #t)
          (let ((macro (definition-value definition)))
            (cond ((syntax-macro? macro) (debug (apply macro arguments)))
                  ((macro? macro) (debug (macro arguments)))
                  (else (debug (apply macro arguments))))
            #t)))))
  
  
  (method (expand-scheme form)
    (unimplemented)
    @convert
    (bind (name . arguments) form
      (let* ((try (function (package) (category-field (class-of package) name)))
             (macro (definition-value (either (try Kernel)))))
        (cond ((syntax-macro? macro) (debug (apply macro arguments)))
              ((macro? macro) (debug (macro arguments))))
        #t)))
  
  
  (method (touch classes)
    (touch-classes #f classes))
  
  
  (method (touch-descendants classes)
    (touch-classes #t classes))


  (method (touch-classes descendants? classes)
    (unimplemented)
    @convert
    (let ((touched (new List-Factory)))
      (letrec ((process
                (function (model)
                  (let* ((name (type-name model))
                         (source (get-manifest-source name)))
                    ;; because source can be {} for inner classes
                    (when (and source (category-compiled? model))
                      (touch~ source)
                      (put~ touched name)
                      (user-message "{s} touched" name))
                    (when descendants?
                      (for-each process (type-descendants model)))))))
        (for-each (function (name)
                    (process (autoload name)))
                  classes)
        (let* ((all (get-output~ touched))
               (count (length all)))
          (user-message "Touched {a} class{a}{a}"
                        count
                        (format-plural count "es")
                        (if (null? all)
                            ""
                          (format ": {a}" (join (map ->string all) ", "))))))))
  
  
  (method (compile classes)
    (unimplemented)
    @convert
    (compile-classes classes))
  
  
  (method (edit location)
    (edit~ (new Jazz-Code-Location location)))

  
  ;;;
  ;;;; Website
  ;;;
  
  
  (definition JazzWebsite-Directory
    {Directory Jazz "packages" "org.jazz.website"})
  
  (definition JazzWebsite-Content
    {Directory Jazz "packages" "org.jazz.website" "content"})
  
  
  (method (test0)
    (let ((frame (current-frame)))
      (when (and frame (is? frame View-Host))
        (let ((guest (get-guest~ frame)))
          (when (is? guest Jazz-Text-View)
            (save~ guest)))))
    (regenerate-jazzwebsite))
  
  
  (method (regenerate-jazzwebsite)
    @convert
    (reload-documentation~ (get-application))
    (generate-jazzwebsite))
  
  
  (method (generate-jazzwebsite)
    (let* ((file (new-file~ JazzWebsite-Directory '("site" "JazzWebsite.jml")))
           (node (load-jml file))
           (site (transform-jml node (new JazzWebsite-Transformation)))
           (pages (get-children~ site)))
      (for-each (function (page)
                  (user-message "Rendering {a}..." (get-property~ page 'path))
                  (render-jazzwebsite-page page))
                pages)
      (user-message "Website generated")))
  
  
  (method (render-jazzwebsite-page page)
    (let* ((content JazzWebsite-Content)
           (file (new-file~ content (format "{a}.htm" (get-property~ page 'path))))
           (preferences (new JML-Preferences))
           (renderer (new XHTML-Renderer preferences))
           (html (first-child~ page)))
      (call-with-output-file (parse~ file)
        (function (printer)
          (render~ renderer html printer)))))
    
  
  ;;;
  ;;;; Mandelbrot
  ;;;
  
  
  @wait
  (method (test)
    (new-mandelbrot))
  
  
  @wait
  (method (new-mandelbrot)
    (new-frame Mandelbrot host-title: "Mandelbrot" host-position: {Point 50 50} host-size: {Dimension 800 800} host-workspace: 'home))

  
  ;;;
  ;;;; Jazz
  ;;;
  
  
  (method (gambit (expr: expr {}) (maximum-heapsize: maximum-heapsize 102400) (exception-handler: exception-handler :repl))
    (unimplemented)
    @convert
    (let* ((exception (case exception-handler ((:repl) "r") ((:exit) "q")))
           (command (format "gsc -:da{a},h{a}{a} -" exception maximum-heapsize (if expr (format " -e \"{a}\"" expr) ""))))
      (create-process command directory: {Directory jazz} capture-input?: #f capture-output?: #f capture-error?: #f wait?: #f size: {Dimension 900 500} visible?: #t)))
  
  
  ;;;
  ;;;; Templates
  ;;;
  
  
  @wait
  (definition Template-AList
    '((title   . "Planner")
      (package . "planner")
      (source  . "{File Planner-Project \"Foo.jazz\"}")))
  
  
  @wait
  (method (test8)
    (let ((expander (new Template-Expander))
          (template {File Builder-Module "Templates" "Project.jazz"}))
      (call-with-output-file (parse~ {File Builder-Module "Templates" "Test.jazz"})
        (function (output)
          (expand~ expander template Template-AList output))))
    (user-message "Done"))
  
  
  ;;;
  ;;;; Taskbar
  ;;;
  
  
  @wait
  (method (test)
    (test-taskbar))
  
  
  @wait
  (method (test-shift)
    (test-remove-taskbar))
  
  
  @wait
  (method (test-taskbar)
    (let ((record (new NOTIFYICONDATA))
          (icon (load-image~ Image 'icon {Icon-Resource "Jazz"} width: 16 height: 16)))
      (set record 'cbSize (size-of NOTIFYICONDATA))
      (set record 'hWnd (get-toplevel-hwnd))
      (set record 'uID 10)
      (set record 'uFlags (bitwise-ior NIF_MESSAGE NIF_ICON))
      (set record 'uCallbackMessage JZ_TASKICON)
      (set record 'hIcon icon)
      (Shell_NotifyIcon NIM_ADD record)))
  
  
  @wait
  (method (test-remove-taskbar)
    (let ((record (new NOTIFYICONDATA)))
      (set record 'cbSize (size-of NOTIFYICONDATA))
      (set record 'hWnd (get-toplevel-hwnd))
      (set record 'uID 10)
      (Shell_NotifyIcon NIM_DELETE record)))
  
  
  ;;;
  ;;;; Tie
  ;;;
  
  
  @wait
  (method (test)
    (let ((x 1))
      (debug (tie "{x}~~Hello~{{self}"))))
  
  
  ;;;
  ;;;; Language
  ;;;
  
  
  @wait
  (method (test1)
    (format :console "{%}xxx{?abc~}yyy" {}))
  
  
  @wait
  (method (test2)
    (format :console "{%}xxx{?ab{a}c~}yyy" 10))
  
  
  ;;;
  ;;;; Generic
  ;;;
    
  
  @wait
  (method (test)
    (debug (definition-value (category-field org.apache.bcel.classfile.JavaClass '<init>))))

  
  @wait
  (method (test)
    (debug (foo~ (new X) {})))
  
  
  @wait
  (method (test-shift)
    (debug (get-foo~ (new X))))
  
  
  @wait
  (method (test1)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list X Y))
      (insert-node~ dispatcher {} (list Y X))
      (insert-node~ dispatcher {} (list A A A))
      (insert-node~ dispatcher {} (list A A B))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test X X)
        (test X Y)
        (test Y Y)
        (test Window Window)
        (test A A A)
        (test A A B)
        (test X Y B))))
  
  
  @wait
  (method (test2)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list Rect))
      (insert-node~ dispatcher {} (list Point))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test Object)
        (test Point)
        (test Rect)
        (test Integer))))
  
  
  @wait
  (method (test2)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list))
      (insert-node~ dispatcher {} (list <javaint>))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test )
        (test Integer)
        (test Integer Integer)
        (test Integer Integer Integer))))
  
  
  ;;;
  ;;;; Exemplar
  ;;;
  
  
  @wait
  (definition ed
    {})
  
  @wait
  (definition xa
    {})
  
  @wait
  (definition xb
    {})
  
  @wait
  (definition x1
    {})
  
  @wait
  (definition x2
    {})
  
  
  @wait
  (method (setup-exemplar)
    (set! ed (new Exemplar-Domain))
    (set! xa (new X :domain ed name: 'a :a 1 :b 2 :c 3))
    (set! xb (new X :domain ed name: 'b base: 'a :b 5))
    (set! x1 (new X :domain ed base: 'a :a 10))
    (set! x2 (new X :domain ed base: 'b :a 20))
    (user-message "Setup done"))
  
  
  @wait
  (method (test-exemplar)
    (init~ xa)
    (init~ xb)
    (init~ x1)
    (init~ x2)
    (user-message "Test done"))


  ;;;
  ;;;; Tabulate
  ;;;
  
  
  (method (test9)
    (let ((text (get-focus)))
      (if (is-not? text Jazz-Text-View)
          (bell)
        (internal-tabulate text))))
  
  
  (method (internal-tabulate text)
    (let* ((pos (get-start~ text))
           (range (new Range$Cell$ pos pos))
           (explorer (new Jazz-Explorer text range: range))
           (maxes (collect-maxes explorer)))
      (set-range~ explorer range)
      (tabulate-columns text explorer maxes)))
  
  
  (method (collect-maxes explorer)
    (let* ((maxes '())
           (update-maxes
            (function (sizes)
              (set! maxes (if (null? maxes)
                              sizes
                            (map max maxes sizes))))))
      (while (enter-composite~ explorer)
        (let ((sizes (new List-Factory)))
          (while (forward-expr~ explorer)
            (let ((size (- (get-col~ (get-end~ explorer)) (get-col~ (get-start~ explorer)))))
              (put~ sizes size)))
          (update-maxes (get-output~ sizes)))
        (exit-composite~ explorer))
      maxes))
  
  
  (method (tabulate-columns text explorer maxes)
    (let ((undoer (get-undoer~ text)))
      (with-atomic-undo~ undoer
        (function ()
          (while (enter-composite~ explorer)
            (let ((maxes maxes))
              (while (forward-expr~ explorer)
                (let* ((max (car maxes))
                       (size (- (get-col~ (get-end~ explorer)) (get-col~ (get-start~ explorer))))
                       (diff (- max size)))
                  (when (> diff 0)
                    (let ((end (get-end~ explorer)))
                      (replace-text~ text (new Range$Cell$ end end)
                        (list (make-string diff #\space)))))
                  (set! maxes (cdr maxes)))))
            (exit-composite~ explorer))))))

  
  ;;;
  ;;;; Text
  ;;;
  
  
  @wait
  (method (text-macro text)
    (let* ((start (get-row~ (get-start~ text)))
           (end (get-row~ (get-end~ text)))
           (col (get-column~ text start))
           (char (get-char~ text (new Cell start col))))
      (if (/= char #\-)
          (bell)
        (with-locked-update
          (function ()
            (replace~ text (new Range$Cell$ (new Cell start 0) (new Cell start (+ col 2))) (list ""))
            (for-each (function (row)
                        (remove-spaces~ text (new Range$Cell$
                                               (new Cell row (paragraph-length~ text row))
                                               (new Cell row (paragraph-length~ text row)))
                          keep: 'one))
                      (naturals start end))
            (let ((paragraph (get-paragraph~ (get-paragraph~ text start))))
              (unless (get-bulleted?~ (get-format~ paragraph))
                (toggle-bulleted~ text start))))))))
  
  
  @wait
  (method (test)
    (test-for-each-page))
  
  
  @wait
  (method (test-for-each-page)
    (for-each-page~ % 0 (+ (get-limit~ %) 1) 360
     (function (page top bottom)
       (let ((t (get-bottom~ (get-row~ % top)))
              (b (get-top~ (get-row~ % bottom))))
         (debug (- b t))))))
  
  
  @wait
  (method (test-message-box)
    (message-box
      (list "Hello World"
            (list :bulleted "This message-box")
            (list :bulleted :indent 2 "really" " " (list :hyperlink (function () (close-modal-dialog (function () (debug 'yo)))) "really") " " (list image: {Bitmap-Resource "BlueRed"}) " " (list highlight: 'Light-Red "really"))
            (list :bulleted :indent 1 "rocks!"))
      sound: {}))
  
  
  @wait
  (method (hide-paragraphs)
    (let ((text (get-focus)))
      (for-each-selected-paragraph~ text
       (function (row paragraph)
         (hide~ paragraph)))))

  
  ;;;
  ;;;; Java
  ;;;

  
  @wait
  (method (test2)
    (let* ((java (new Java-Runtime))
           (output (execute~ java "com/metascoop/Test" classpath: Java-Classpath :arguments "JazzStandaloneRelease.exe")))
      (message-box (join output (cn)))))
  
  
  @wait
  (method (test3)
    (let ((obj1 (new org.jazzscheme.test.Test))
           (obj2 (new org.jazzscheme.test.Test 8)))
      (debug (cj~ obj1 2))
      (debug (test~ obj1 4 5) (test~ obj2 2 3 4))))

  
  ;;;
  ;;;; Thread
  ;;;
  
  
  @wait
  (method (test)
    (new Thread
      context: self
      execute: (function (thread)
                 (debug
                   (foo)))))
  
  
  @wait
  (method (test)
    (new Thread
      context: self
      execute: (function (thread)
                 (car 1))))
  
  
  @wait
  (method (test-shift)
    (let ((impulse (new Impulse)))
      (new Thread
        context: self
        execute: (function (thread)
                   (sleep 5)
                   (car 1)
                   (set-event~ impulse)
                   (debug 'thread-done)))
      (wait-for impulse timeout: 10 error?: #f)
      (debug 'done)))
  
  
  @wait
  (method (test1)
    (let ((t1 (new Thread
                 context: self
                 execute: (function (thread)
                            (sleep 1))))
           (t2 (new Thread
                 context: self
                 execute: (function (thread)
                            (sleep 2)))))
      (debug (wait-for (list t1 t2) timeout: 3000 error?: #f))))

  
  ;;;
  ;;;; Context
  ;;;
  
  
  @wait
  (method (test-context)
    (with-execution-context
      (function ()
        (with-progress
          (function (reporter)
            @wait
            (with-restart
              (function ()
                (to-fix)))
            (for-each (function (n)
                        (with-continue
                          (function ()
                            (foo n))))
                      (naturals 0 10))
            (car 'a))
          threaded?: #f
          context: self))
      title: "test"))
  
  
  @wait
  (method (to-fix)
    (debug (symbol->string {})))
  
  
  @wait
  (method (foo n)
    (with-execution-node
      (function ()
        (goo n))
      title: "hello we are doing..."
      details: '("a" "b" "c")))
  
  
  @wait
  (method (goo n)
    (with-execution-node
      (function ()
        (hoo n))
      title: "goo"
      details: '("x" "y")))
  
  
  @wait
  (method (hoo n)
    (with-execution-node
      (function ()
        (car n))
      title: "hoo"))

  
  ;;;
  ;;;; Parameters
  ;;;
  
  
  @wait
  (method (test-parameters)
    (set-parameter 'test 2)
    (new Thread
      context: self
      execute: (function (thread)
                 (debug 'thread (get-parameter 'test))
                 (set-parameter 'test 3)
                 (debug 'thread (get-parameter 'test))))
    (sleep .5)
    (debug 'main (get-parameter 'test)))
  
  
  ;;;
  ;;;; Logging
  ;;;
  
  
  @wait
  (method (test)
    (with-log (new Log name: 'test file: {File Boot "Logs" "Test.jml"})
      (function ()
        (log-entry name: "hello")
        (log-entry name: "world"))))
  
  
  @wait
  (method (test-shift)
    (foo 2))
  
  
  @wait
  (method (foo x)
    (log-entry name: "foo" message: (format "received {a}" x))
    (bar x))
  
  
  @wait
  (method (bar x)
    (let ((y (+ x x x)))
      (log-entry name: "bar" message: "some stack" data: (new Stack-Snapshot))))
  
  
  @wait
  (method (test)
    (with-log (new Log name: 'test file: {File Boot "Logs" "Test.jml"})
      (function ()
        (log-entry name: "hello")
        (log-entry name: "world")
        (log-properties (list :a 2 :b 3 :c 5) name: "test")
        (with-profile
          (function (node)
            (+ 2 3))
          name: "resources"))))

  
  ;;;
  ;;;; Resources
  ;;;
  
  
  @wait
  (method (test3)
    (gc)
    (test-resources))
  
  
  @wait
  (method (test-resources)
    (with-log (new Log name: "Resources" file: {File Boot "Logs" "Resources.jml"})
      (function ()
        (test-bitmap)
        (test-dc)
        (test-file-printer)
        (test-file-reader)
        (test-font)
        (test-image)
        (test-pen)
        (test-picture)
        (test-portfolio)
        (test-pseudo-handle)
        (test-reader)
        (test-region)
        (test-registry-key)
        (test-socket)
        (test-stack)
        (test-synchronizer)
        (test-thread)
        (test-user-name))))
  
  
  @wait
  (method (test-bitmap)
    (with-profile
      (function (node)
        (new Bitmap :dc (desktop-dc) width: 16 height: 16))
      name: "Bitmap"))
  
  
  @wait
  (method (test-font)
    (with-profile
      (function (node)
        (new Font font-name: "Tahoma" point-size: 8))
      name: "Font"))
  
  
  @wait
  (method (test-image)
    (with-profile
      (function (node)
        (load-image~ Image 'bitmap {Bitmap-Resource "Break"})
        (load-image~ Image 'icon {Icon-Resource "Jazz"} width: 16 height: 16)
        (load-image~ Image 'cursor {Cursor-Resource "Move"}))
      name: "Image"))
  
  
  @wait
  (method (test-pen)
    (with-profile
      (function (node)
        (new Pen color: {Color red: 142 green: 142 blue: 142}))
      name: "Pen"))
  
  
  @wait
  (method (test-picture)
    (with-profile
      (function (node)
        (new Picture))
      name: "Picture"))
  
  
  @wait
  (method (test-portfolio)
    (with-profile
      (function (node)
        (new Portfolio))
      name: "Portfolio"))
  
  
  @wait
  (method (test-pseudo-handle)
    (with-profile
      (function (node)
        (GetCurrentProcess))
      name: "Pseudo Handle"))
  
  
  @wait
  (method (test-region)
    (with-profile
      (function (node)
        (new Region rect: {Rect 0 0 100 100}))
      name: "Region"))
  
  
  @wait
  (method (test-registry-key)
    (with-profile
      (function (node)
        (let ((key1 (new Registry-Key key: HKEY_CLASSES_ROOT))
              (key2 (new Registry-Key key: HKEY_CURRENT_USER)))
          (open-key~ key1 "TypeLib")
          (open-key~ key1 "TypeLib")
          (open-key~ key1 "TypeLib"))
        (with-closed ((key (new Registry-Key key: HKEY_CLASSES_ROOT)))
          (with-profile
            (function (node)
              (with-closed ((subkey (open-key~ key "TypeLib")))
                ))
            name: "open-key")))
      name: "Registry-Key"))
  
  
  @wait
  (method (test-socket)
    (with-profile
      (function (node)
        (new Socket))
      name: "Socket"))
  
  
  @wait
  (method (test-stack)
    (with-node
      (function (node)
        (log-profile name: 'before)
        (letrec ((proc
                  (function (n)
                    (if (= n 0)
                        (log-profile name: 'after)
                      (proc (- n 1))))))
          (proc 5000)))
      node: (new-log-node name: "Stack")))
  
  
  @wait
  (method (test-synchronizer)
    (with-profile
      (function (node)
        (new Impulse)
        (new Mutex)
        (new Semaphore))
      name: "Synchronizer"))
  
  
  @wait
  (method (test-thread)
    (with-profile
      (function (node)
        (new Thread
          context: self
          execute: (function (thread)
                     (sleep .5))))
      name: "Thread"))

  
  @wait
  (method (test-user-name)
    (with-profile
      (function (node)
        (get-system-user-name))
      name: "User Name"))
  
  
  @wait
  (method (test9)
    (gc-clear-undestroyed))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  @wait
  (method (test)
    (new-frame Scaling-Scroller host-title: "Scaling Scroller" host-position: {Point 50 50} host-size: {Dimension 300 500} guest-context: self))

  
  @wait
  (class Scaling-Scroller extends Scroller-View
    
    
    (form
      (<install>                        vscroll?: #t hscroll?: #t
        (<!>              name: content
          (<Scaling-View> name: view    position: {Point 0 0} size: {Dimension 600 800}))))
    
    
    (class Scaling-View extends View
      
      
      (definition flag
        #t)
      
      
      (method (draw surface context update lh lv)
        (let ((update-rect (get-update-rect surface update lh lv))
              (color (if flag {Color name: Dark-Red} {Color name: Dark-Blue})))
          (set! flag (not flag))
          (fill-rect~ surface @w (get-bounds) (inflate-rect update-rect 1 1) color)))
      
      
      (method (mouse-down h v)
        (debug 'mouse-down))))


  ;;;
  ;;;; Dialog
  ;;;
  
  
  @wait
  (method (test)
    (receive (a b) (my-dialog)
      (message-box (format "a: {a}, b: {a}" a b))))
  
  
  @wait
  (method (my-dialog)
    (get-modal My-Dialog guest-context: self))
  
  
  @wait
  (class My-Dialog extends View
    
    
    (form
      (<install>       size: {Dimension 400 206}
        (<Push-Button> title: "Source" position: {Point 70 122} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :guest on-update :source? #t})
        (<Push-Button> title: "Databases" position: {Point 160 122} size: {Dimension 80 24} action-handler: {Event-Handler :guest on-update :source? #f})
        (<Push-Button> title: "Cancel" position: {Point 250 122} size: {Dimension 80 24} action-handler: {Event-Handler :host on-cancel})))
    
    
    (method (on-update evt)
      (my-dialog)
      (let ((dialog (get-host))
             (source? (get-property~ evt source?:))
             (update
              (function ()
                (update-database))))
        (if source?
            (end-modal~ dialog (update))
          (catch Stop-Signal
            (update-database)))))
    
    
    (method (update-database)
      (with-progress
        (function (reporter)
          (something reporter))))
    
    
    (method (something reporter)
      (with-execution-context
        (function ()
          (for-each (function (n)
                      (test-cancelled~ reporter)
                      (with-continue
                        (function ()
                          (if (= n 7)
                              (car 1)
                            (user-message~ reporter "{a}" n))
                          (sleep .2))))
                    (naturals 0 10))
          (values 2 3)))))
  
  
  ;;;
  ;;;; Picker
  ;;;
  
  
  @wait
  (method (test1)
    (blend 255))
  
  
  @wait
  (method (test2)
    (blend 100))
  
  
  @wait
  (method (test3)
    (blend 30))
  
  
  @wait
  (method (blend x)
    (pick-figure
      (function (window position view pos)
        (set-alpha-blending~ (get-player~ view) x))))
  
  
  ;;;
  ;;;; Reprint Form
  ;;;
  
  
  (method (reprint-toplevel-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (range (toplevel-expr~ text (get-end~ text)))
           (string (get-string~ text range))
           (form (jml->form (read-string-element string))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #f 0 space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))
  
  
  (method (reprint-current-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (classes (current-classes~ text (get-selection~ text)))
           (range (definition-range~ text (get-end~ text)))
           (string (get-string~ text range))
           (form (jml->form (second (read-string-element string)))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #t (+ 1 (length classes)) space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))
  
  
  (method (reprint-selected-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (range (get-selection~ text))
           (string (get-string~ text range))
           (form (jml->form (read-string-element string))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #f 0 space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))

  
  ;;;
  ;;;; Activities
  ;;;
  
  
  (method (clear-activities)
    (let* ((manager (get-activity-manager))
           (reporters (get-reporters~ manager)))
      (for-each (function (reporter)
                  (unregister-activity~ manager reporter))
                reporters)))

  
  ;;;
  ;;;; Location
  ;;;
  
  
  @wait
  (class Foo extends Object

  
    (definition holder
      {})
    
    
    (method (bar)
      (set! holder {})
      (let* ((x 2)
             (z self)
             (proc
              (function (n flag)
                (let* ((y (+ x x))
                       (p
                        (function ()
                          (let ((v y))
                            (break)
                            (message-box n)))))
                  (if flag p (holder))))))
        (set! holder (proc 5 #t))
        (proc 7 #f)))
    
    
    (method (baz)
      (let ((x 2))
        (car x))))
  
  
  @wait
  (method (test)
    (bar~ (new Foo)))
  
  
  @wait
  (method (test-shift)
    (baz~ (new Foo)))

  
  @wait
  (method (test-location)
    (let ((x 2)
          (y (break))
          (z 3))
      (list x y z)))

  
  @wait
  (method (test-location-aux)
    (let ((z (new [Z Y X])))
      (foo~ z '(10 20 30))))
    
  
  @wait
  (class X extends Object
    
    
    (class Y extends Object
      
      
      (class Z extends Object
        
        
        (method (foo list)
          (for-each (function (x)
                      (map (function (y)
                             (car y))
                           (naturals 0 x)))
                    list))
        
        
        (method (bar)
          (car 1)))))
  
  
  ;;;
  ;;;; XML
  ;;;
  

  @wait
  (method (xml-viewer)
    (let ((document (new XML-Document))
          (file {File Root "Books.xml"}))
      (load~ document file)
      (let* ((frame (new-frame XML-Viewer host-visible?: #f))
             (viewer (get-guest~ frame)))
        (set-document~ viewer document)
        (bring-to-front~ frame)
        (set-visible?~ frame #t))))

  
  @wait
  (method (test)
    (let* ((text "<TABLE colspan=2> aaaa </TABLE>")
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))))
  
  
  @wait
  (method (test1)
    (log-entry name: "Test1")
    (let* ((text "start <A> blabla <B> </B> yoyo <C> </C> gousigousi </A> end")
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))))
  
  
  @wait
  (method (test2)
    (let* ((file {File Jazz "Doc.jazz"})
           (text (with-closed ((reader (new File-Reader file))) (read-content-string reader)))
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))
      (debug (length text))))
  
  
  ;;;
  ;;;; XSL
  ;;;

  
  @wait
  (class My-Transfo extends XML-Transformer
    
    
    (method public (machin node x y)
      (xsl-rules node
        ((a)
         (f ((mode "1") (title (<-xml x)))
            (xml>>
             (for-each (function (n)
                         (>>xml
                          (p (<-xml n))))
                       (cdr node)))))))
    
    
    (method public (chouette node a b)
      (xsl-rules node
        ((b)
         (xml>>
          (apply-transformation machin (children~ node)))))))

  
  @wait
  (method (test)
    (let ((transfo (new My-Transfo handler: (new XML-Formatter))))
      (machin~ transfo '(a "B" "C") 1 2)))
  
  
  @test
  (method (test1)
    (format :console "{t}"
     (expand-xsl-ruleset
       '(x y)
       (list
        '((a) 
          (f
           (xml>>
            (for-each
             (function (n)
               (>>xml
                (p (<-xml n))))
             (children~ node)))))))))
  
  
  @wait
  (method (test0)
    (let ((f (new XML-Formatter :pretty #t indentation: 2)))
      (begin-element~ f "body")
      (begin-element~ f "h1")
        (add-attribute~ f "align" "center")
      (end-element~ f "h1")
      (begin-element~ f "p")
        (text~ f "Bonjour les petits amis")
      (end-element~ f "p")
      (end-element~ f "body")))
  

  @test  
  (method (test1)
    (let ((processor (new XML-Formatter :pretty #f))
          (converter process-sxml))
       (converter
        '(body 
          (h1 ((align "center"))
              "allo"
              (b "le monde")
              "de toto"))
        processor)))
  
  
  @wait
  (method (test0)
    (car 1))
  
  
  @wait
  (method (setup-compiler)
    (initialize-user-passes~ Compiler)
    (add-user-pass~ Compiler (new Type-Annotator))
    (add-user-pass~ Compiler (new Mutation-Annotator)))
  
  
  ;;;
  ;;;; Scheme
  ;;;
  
  
  @wait
  (method (test1)
    (cond (2 => debug)))
  
  
  @wait
  (method (test)
    (debug (lalr-parser (ID +))))
  
  
  @wait
  (method (test)
    (test~ CPS identity))

  
  ;;;
  ;;;; Various
  ;;;
  
  
  (method (speedup old new)
    (percentage (- old new) new))
  
  
  @wait
  (definition activity-no
    0)


  @wait
  (method (test-activities)
    (new Activity
      context: self
      execute: (function (activity)
                 (let ((max (+ 5 (random 50)))
                       (wait (+ .3 (/ (random 500) 1000.)))
                       (keep? (zero? (random 2)))
                       (no activity-no)
                       (n 0))
                   (increase! activity-no)
                   (set-range~ activity (new Range 0 max))
                   (while (and (< n max) (not (cancel-requested?~ activity)))
                     (sleep wait)
                     (increase! n)
                     (user-message~ activity "Test {s} : Step {s}" no n)
                     (delta-pos~ activity 1))
                   (unless (cancel-requested?~ activity)
                     (user-message~ activity "Test {s} : Done" no)
                     (set-done~ activity)
                     (sleep .5))))
      :unregister? #t))


  @wait
  (method (test-styles)
    (let ((stage (locate~ (find-guest~ (get-stage) Showcase) 'stage)))
      (send-message~ (locate~ stage 'pb) BM_SETIMAGE IMAGE_BITMAP (load-image~ Image 'bitmap {Bitmap-Resource "Break"}))))


  ;;;
  ;;;; Directory
  ;;;
  
  
  (method (collect-extensions dir)
    (let ((extensions '()))
      (iterate-directory~ dir
        (function (file)
          (let ((ext (get-extension~ file)))
            (when (not (member? ext extensions test: ci=?))
              (set! extensions (cons (downcase ext) extensions))))))
      (sort < extensions)))


  ;;;
  ;;;; Java Parser
  ;;;


  @wait
  (method (test-ast (describe? #t))
    (let ((file {File org.jazz "Jazz" "Samples" "Java" "org" "jazz" "project" "Z.java"}))
      (let ((ast (parse-java file Java-AST)))
        (when describe?
          (describe~ ast)
          (fresh-prompt~ (get-application)))
        ast)))


  @wait
  (method (test-java)
    (let ((file {File org.jazz "Jazz" "Samples" "Java" "org" "jazz" "project" "Z.java"}))
      (let ((ast (parse-java file Java-AST)))
        (java-definitions ast))))

  
  ;;;
  ;;;; Reports
  ;;;
  
  
  (method (report-aliases)
    (let* ((table (get-aliases))
           (aliases (table-keys/values table)))
      (newline)
      (for-each (function (info)
                  (bind (key . value) info
                    (format :console "{s} : {l}{%}" key value)))
                (sort < aliases key: car)))
    (fresh-prompt~ (get-application)))))
