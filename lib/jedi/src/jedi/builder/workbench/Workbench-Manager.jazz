;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module protected jedi.builder.workbench.Workbench-Manager jazz


(import (jazz.catalog)
        (jazz.designer)
        (jazz.designer.menu)
        (jazz.editor.c)
  @wait (jazz.editor.java)
        (jazz.editor.jazz)
        (jazz.graphic)
        (jazz.groupware)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.library.template)
        (jazz.platform)
        (jazz.runtime)
        (jazz.system)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jedi)
        (jedi.builder)
        (jedi.builder.workbench))


(class Workbench-Manager extends Editor-View implements Exit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" resource: {Image-Resource "Synchronize"} portfolio: :images action-handler: {Event-Handler :form on-highlight-document}))
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           flat?: #t)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Project" width: 291 highlight-color: {Color name: Dark-Blue})))))
  
  
  (method meta override (external-name . rest)
    'workbench-manager)

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta override (host-icon)
    {Image-Resource "Workbench"})
  
  
  (method meta override (host-title)
    "Workbench")
  
  
  (method override (install-in-host host)
    (define (setup-active-project)
      (let* ((pref (get-preferences 'workbench))
             (project (get-active-project~ pref))
             (workbench (get-workbench)))
        (when (and project workbench)
          (activate-project (find-project~ workbench project)))))
    
    (setup-active-project))
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method override (get-tools-view)
    (locate 'tools))
  
  
  (method override (focus-default)
    (let ((tree (get-tree)))
      (acquire-focus~ tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (get-tree)
    (locate '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  (method override (new-controller)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method override (install rest)
    (nextmethod rest)
    (set-shown?~ (locate-component '(descendants header)) #f)
    (set-editor~ (locate 'descendants) self)
    (set-client (get-workbench))
    (add-exit-listener~ (get-application) self))
  
  
  (method override (get-designer-class)
    Workbench-Designer)
  
  
  (method override (prepare-exit)
    (when (and designer (file? (get-origin~ (get-form~ designer))))
      (save-designer~ designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method override (on-designer evt)
    (nextmethod evt)
    (case (get-kind~ evt)
      ((:child-add) (child-add (get-property~ evt child:) (get-property~ evt parent:)))
      ((:child-remove) (child-remove (get-property~ evt child:)))))
  
  
  (method (child-add child parent)
    (when (is? child Project)
      (project-add~ designer child)))
  
  
  (method (child-remove child)
    (when (is? child Project)
      (project-remove~ designer child)))

  
  ;;;
  ;;;; Events
  ;;;
    
  
  (method override (key-press key)
    (case key
      ((#\return) (launch-selection))))
  
  
  (method (on-highlight-document evt)
    (highlight-document))
  
  
  (method (on-add-project evt)
    (add-project))
  
  
  (method (on-add-file evt)
    (add-file))
  
  
  (method (on-add-group evt)
    (add-group))
  
  
  (method (on-install-project evt)
    (let* ((current-directory? (get-shift?~ evt))
           (parent (selected-object))
           (file (with-import-directory current-directory? parent
                   (lambda (directory)
                     (choose-file extensions: '(("Jazz Files" . "jazz")) directory: directory)))))
      (install-project file parent #f)))
  
  
  (method (on-import-files evt)
    (import-files (get-shift?~ evt)))
  
  
  (method (on-import-directory evt)
    (import-directory (get-shift?~ evt)))
  
  
  (method (on-synchronize-content evt)
    (synchronize-content))
  
  
  (method (on-set-current-directory evt)
    (let ((group (selected-object)))
      (let ((dir (get-directory~ group)))
        (set-current-directory dir)
        (user-message "Current directory set to {a}" (parse~ dir)))))
  
  
  (method (on-update-catalog evt)
    (update-catalog))
  
  
  (method (on-edit evt)
    (edit-selection))
  
  
  (method (on-activate evt)
    (activate-selection))
  
  
  (method (on-run evt)
    (run-selection))
  
  
  (method (on-debug evt)
    (debug-selection))
  
  
  (method (on-launch evt)
    (launch-selection))
  
  
  (method (on-distribute evt)
    (distribute-selection))
  
  
  (method (on-properties evt)
    (show-properties))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-controller~ guest))
               (moniker (get-moniker~ controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (project-file (find-source~ workbench moniker)))
              (if (not project-file)
                  (bell)
                (acquire-focus~ (get-tree))
                (highlight-document-component project-file))))))))
  
  
  (method (highlight-document-component component)
    (let* ((tree (get-tree))
           (row (component-row~ tree component)))
      (if (not row)
          (bell)
        (ensure-expanded~ tree row)
        (set-single-selection~ tree (row->line~ tree row)))))

  
  ;;;
  ;;;; Select
  ;;;
  
  
  (method public (select-current)
    (select-project))
  
  
  (method (select-project)
    (let ((project (get-modal Project-Selector)))
      (when project
        (activate-project project))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current)
    (edit-project (current-project)))
  
  
  (method (edit-selection)
    (let ((objects (selected-objects)))
      (for-each (lambda (object)
                  (typecase object
                    ((Workbench) (edit-workbench))
                    ((Project) (edit-project object))))
                objects)))
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method (edit-workbench)
    (let ((appl (get-application))
          (file Workbench-File))
      (edit-document~ appl file)))
  
  
  (method (edit-project project)
    (if (is-not? project Project)
        (bell)
      (let ((unit-name (get-unit-name~ project)))
        (if (not unit-name)
            (bell)
          (let ((source (find-unit-source unit-name)))
            (if (not source)
                (bell)
              (edit-document~ (get-application) source)))))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (definition Project-Templates-Directory
    {Directory Jazz "lib" "jedi" "templates" "project"})
  
  (definition File-Templates-Directory
    {Directory Jazz "lib" "jedi" "templates" "file"})
  
  
  (method protected (add-project)
    (add-project-to (or (selected-object) (get-workbench))))
  
  
  (method protected (add-project-to parent)
    (let ((tree (get-tree)))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (receive (kind template repository package) (get-modal New-Project-Dialog)
          (let* ((directory (new Directory (tokenise-filename (repository-library-directory repository))))
                 (package-name (string->symbol package))
                 (package-parts (map ->string (split-identifier package-name)))
                 (product (last package-parts))
                 (project (capitalize product))
                 (template (new-directory~ Project-Templates-Directory template))
                 (destination directory)
                 (associations (list (cons 'package package)
                                     (cons 'product product)
                                     (cons 'product-title (capitalize product))
                                     (cons 'product-unit package)
                                     (cons 'product-directories package-parts)
                                     (cons 'project project)
                                     (cons 'project-title project)
                                     (cons 'project-unit (format "project.{a}" package))
                                     (cons 'project-directories (cons "project" package-parts)))))
            (copy-template template destination associations)
            (unless (repository-find-package repository package-name)
              (let ((package-file (new-file~ destination (list package ".package"))))
                (repository-add-package repository (load-package repository #f package-name (parse~ package-file)))))
            (with-update-locked~ tree
              (lambda ()
                (let ((project-file (new-file~ destination (append (list package "src" "project") package-parts (list (format "{a}-Manifest.jazz" project))))))
                  (let ((project-component (install-project project-file parent #f)))
                    (let ((src-directory (new-directory~ destination (list package "src"))))
                      (let ((src-content (collect-if (lambda (dir)
                                                       (not (member? (get-name~ dir) '("project") test: ci=?)))
                                                     (get-content~ src-directory nodes?: #t leaves?: #f))))
                        (when (not-null? src-content)
                          (let ((src-component (import-pathname project-component src-directory project-component #t recursive?: #f)))
                            (for-each (lambda (dir)
                                        (import-pathname project-component dir src-component #t))
                                      src-content)))))
                    (save~ (get-project-designer~ designer project-component))
                    (update-project-catalog project-component)
                    (acquire-focus~ tree)
                    (process-refresh~ designer project-component 'descendants)
                    (select-component~ tree project-component)
                    (let ((projects (collect-projects project-component)))
                      (when (not-null? projects)
                        (activate-project (car projects))))
                    (user-message "Project {a} created" package))))))))))
  
  
  (method protected (add-file)
    (let ((parent (or (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (or (default-import-directory parent must-exist?: #f) {Directory Profile} @not-sure-this-is-best (get-current-directory))))
          (when (or (exists?~ default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list~ default-directory)) type: 'question) 'yes))
            (create-directories~ default-directory)
            (receive (kind template directory name) (get-modal New-File-Dialog directory: default-directory)
              (let* ((extension (extract-extension template))
                     (template (new-file~ File-Templates-Directory (concatenate template ".template")))
                     (destination (new-file~ directory (format "{a}.{a}" name extension)))
                     (unit (find-pathname-unit (parse~ destination)))
                     (associations (list (cons 'name name) (cons 'unit unit))))
                (copy-template template destination associations)
                (let ((component (import-pathname (ascendant-project parent) destination parent #f)))
                  (select-component~ (get-tree) component)))))))))
  
  
  (method protected (add-group)
    (let ((parent (or (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (add-component-class~ (get-tree) Project-Group parent: parent))))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method (install-project file parent descendant?)
    (let ((parent-project (ascendant-project parent)))
      (when (validate-pathnames parent-project (list file))
        (let ((name (string->symbol (get-base~ file)))
              (unit (find-pathname-unit (parse~ file))))
          (if (not unit)
              (error "Unable to find unit associated to project file: \"{a}\"" (get-name~ file))
            (let ((class (module-ref unit name))
                  (workbench (get-workbench)))
              (if (not (subtype? class Project))
                  (error "The file \"{a}\" does not contain a Project class" (get-name~ file))
                (let ((project (new class workbench: workbench parent: parent)))
                  (add-child~ designer project parent)
                  (set-tag-unit~ designer project parent unit)
                  (reorder-component~ (get-tree) project)
                  (load-catalog~ workbench project)
                  (user-message "{s} installed" (get-presentation-property~ project))
                  project))))))))

  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  
  (definition (import-filter? project file)
    (let ((ext (get-extension~ file))
          (extensions (effective-include-extensions (get-include-extensions~ project))))
      (if extensions
          (or (member? ext extensions test: ci=?)
              ;; special case for those annoying extensionless files
              (member? (get-name~ file) '("README" "INSTALL")))
        (known-extension-frame-class~ (get-application) ext))))
  
  
  (method (import-directory current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (directory (with-import-directory current-directory? parent
                        (lambda (directory)
                          (choose-directory directory: directory))))
           (count (count-files~ directory filter: (lambda (file) (import-filter? project file)) max-count: MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) type: 'question) 'yes))
        (when (validate-pathnames project (list directory))
          (let ((component (import-pathname project directory parent #f)))
            (process-refresh~ designer component 'descendants))
          (user-message "{a} imported"
                        (parse~ directory))))))
  
  
  (method (import-files current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (files (with-import-directory current-directory? parent
                    (lambda (directory)
                      (choose-file multiple-selection?: #t directory: directory)))))
      (import-pathnames project files parent)))
  
  
  (method protected (import-pathnames project pathnames parent)
    (when (validate-pathnames project pathnames)
      (for-each (lambda (pathname)
                  (let ((component (import-pathname project pathname parent #f)))
                    (process-refresh~ designer component 'descendants)))
                (sort nu<? pathnames key: get-name~))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (capitalize (format-cardinality count))
                      (format-plural count)))))
  
  
  (method (import-pathname project pathname parent descendant? (recursive?: recursive? #t))
    (define (determine-project-file? file)
      #f
      @convert-manifest
      (let ((ext (get-extension~ file)))
        (when (ci=? ext "jazz")
          (let ((info (extract-jazz-file-category file)))
            (when info
              (receive (package type name extends) info
                (when (in-manifest? extends)
                  (subtype? (autoload extends) Project))))))))
    
    @convert-manifest
    (define (extract-jazz-file-category file)
      (define (extract-jazz-file-toplevel file)
        (call-with-input-file (list path: (parse~ file) eol-encoding: 'cr-lf)
          (lambda (reader)
            (catch (Read-Error err #f)
              (let ((in/toplevel (read reader)))
                (if (and (pair? in/toplevel) (eq? (car in/toplevel) 'in))
                    (values in/toplevel (read reader))
                  (values #f in/toplevel)))))))
      
      (define (extract-package in)
        (when (pair? (cdr in))
          (let ((package (cadr in)))
            (when (symbol? package)
              package))))
      
      (define (extract-category toplevel)
        (when (pair? toplevel)
          (let ((type (car toplevel)))
            (when (memq? type '(class interface package))
              (let ((scan (cdr toplevel)))
                (when (pair? scan)
                  (let ((name (car scan)))
                    (when (symbol? name)
                      (if (or (and (eq? type 'class) (eq? name 'Object))
                              (and (eq? type 'interface) (eq? name 'Unknown))
                              (and (eq? type 'package) (eq? name 'Common)))
                          (values type name #f)
                        (let ((scan (cdr scan)))
                          (when (and (pair? scan) (eq? (car scan) 'extends))
                            (let ((scan (cdr scan)))
                              (when (pair? scan)
                                (let ((extends (car scan)))
                                  (when (symbol? extends)
                                    (values type name extends))))))))))))))))
      
      (let ((in/toplevel (extract-jazz-file-toplevel file)))
        (when in/toplevel
          (receive (in toplevel) in/toplevel
            (let ((package (extract-package in))
                  (type/name/extends (extract-category toplevel)))
              (when type/name/extends
                (receive (type name extends) type/name/extends
                  (values package type name extends))))))))
    
    (let ((name (get-name~ pathname)))
      (typecase pathname
        ((Directory)
         (let ((project-file (new-file~ pathname (format "{a}.jazz" name))))
           (if (and (exists?~ project-file) (determine-project-file? project-file))
               (install-project project-file parent #t)
             (let ((subgroup (new Project-Directory directory: pathname)))
               (add-child~ designer subgroup parent design-events?: (not descendant?) descendant?: descendant?)
               (set-property~ designer subgroup 'directory pathname design-events?: (not descendant?))
               (when recursive?
                 (iterate-directory~ pathname
                   (lambda (pathname)
                     ;; not the cleanest test but good enough for now
                     (unless (and (not descendant?) (string=? (get-name~ pathname) "project"))
                       (import-pathname project pathname subgroup #t)))
                   files?: #f
                   directories?: #t
                   sort?: #t
                   recursive?: #f)
                 (iterate-directory~ pathname
                   (lambda (pathname)
                     (import-pathname project pathname subgroup #t))
                   files?: #t
                   directories?: #f
                   sort?: #t
                   recursive?: #f))
               subgroup))))
        ((File)
         (when (or (not descendant?) (import-filter? project pathname))
           (if (determine-project-file? pathname)
               (install-project pathname parent descendant?)
             (import-file pathname parent descendant?)))))))
  
  
  (method (import-file file parent descendant?)
    (let* ((model (extension-model (get-extension~ file)))
           (name (if (eq? model Jazz-File) (string->symbol (get-base~ file)) #f))
           (project-file (new model name: name source: file))
           (workbench (get-workbench)))
      (add-child~ designer project-file parent design-events?: (not descendant?) descendant?: descendant?)
      (set-property~ designer project-file 'source file design-events?: (not descendant?))
      (when (eq? model Jazz-File)
        (set-name~ designer project-file name design-events?: (not descendant?))
        (add-entry~ workbench name project-file))
      project-file))
  
  
  (definition (default-import-directory object (must-exist?: must-exist? #t))
    (letrec ((default
               (lambda (object)
                 (typecase object
                   ((Project)
                    #f)
                   ((Project-Directory)
                    (get-directory~ object))
                   (else
                    #f)))))
      (let ((dir (default object)))
        (when dir
          (anchorize~ dir)))))
  
  
  (method (with-import-directory current-directory? object proc)
    (let ((default-directory (and (not current-directory?) (default-import-directory object))))
      (if (and default-directory (exists?~ default-directory))
          (with-preserved-current-directory
            (lambda ()
              (proc default-directory)))
        (proc #f))))
  
  
  (definition (extension-model ext)
    (cond ((member? ext '("jazz") test: ci=?) Jazz-File)
    @wait ((member? ext '("java") test: ci=?) Java-File)
          ((member? ext '("c" "cpp") test: ci=?) C-File)
          ((member? ext '("bmp") test: ci=?) Bitmap-File)
          ((member? ext '("cur") test: ci=?) Cursor-File)
          ((member? ext '("ico") test: ci=?) Icon-File)
          ((member? ext '("wav") test: ci=?) Sound-File)
          (else Project-File)))
  
  
  (method protected (ascendant-project component)
    (if (is? component Project)
        component
      (ascendant-project (get-parent~ component))))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content)
    @wait-complete
    (let* ((object (selected-object))
           (project (ascendant-project object))
           (directory (default-import-directory object must-exist?: #f)))
      (if (not (exists?~ directory))
          (error "Directory {s} not found" directory)
        (let ((fact (new List-Factory))
              (component-name
               (lambda (component)
                 (->string (get-name~ component))))
              (pathname-name
               (lambda (pathname)
                 (get-name~ pathname))))
          (letrec ((fold
                    (lambda (component pathname path)
                      (let ((children (get-children~ component))
                            (content (get-content~ pathname)))
                        (merge-ordered (lambda (what key left right)
                                         (let ((path (cons key path)))
                                           (case what
                                             ((:left) (put~ fact (list what path)))
                                             ((:right) (put~ fact (list what path)))
                                             ((:same)
                                              (when (directory? right)
                                                (fold left right path))))))
                                       (sort ci<? children key: component-name)
                                       (sort ci<? content key: pathname-name)
                                       left-key: component-name
                                       right-key: pathname-name
                                       case-insensitive?: #t)))))
            (fold object directory '())
            (let ((out-of-synch (get-output~ fact)))
              (if (null? out-of-synch)
                  (message-box "Content is already synchronized")
                (let* ((border (new Synchronize-Border size: {Dimension 500 200}))
                       (tree (locate~ border 'tree))
                       (add
                        (lambda (what path)
                          (let ((c0 (new Tree-Node title: (join path "/") image: {Image-Resource "OpenedFolder"})))
                            (add-row~ tree children: (list c0 #f #f #f))))))
                  (for-each (lambda (info)
                              (bind (what path) info
                                (add what (reverse path))))
                            out-of-synch)
                  (message-box "The following elements are out of synch. Synchronize?" class: Synchronize-Box type: 'confirmation content: border)))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames project pathnames)
    @convert-to-checking-conflicts-with-an-understanding-of-the-unit-hierarchy
    (validate
      (lambda (report)
        (letrec ((workbench (get-workbench))
                 (iterate
                  (lambda (pathname)
                    (typecase pathname
                      ((Directory)
                       (iterate-directory~ pathname iterate
                         files?: #t
                         directories?: #t
                         sort?: #t
                         recursive?: #f))
                      ((File)
                       (when (import-filter? project pathname)
                         (let ((model (extension-model (get-extension~ pathname))))
                           (when (eq? model Jazz-File)
                             (let* ((name (string->symbol (get-base~ pathname)))
                                    (jazz-file (get-entry~ workbench name)))
                               (when jazz-file
                                 (report jazz-file)))))))))))
          (for-each iterate pathnames)))))
  
  
  (method (validate iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (lambda (jazz-file)
          (put~ already-defined jazz-file)))
      (let ((already-defined (get-output~ already-defined)))
        (if (null? already-defined)
            #t
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following categor{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-y/ies count)
                                 (format-is/are count)))
                 (text
                  `(,header
                    ()
                    ,@(map (lambda (jazz-file)
                             (let ((project (get-project~ jazz-file))
                                   (action
                                    (lambda ()
                                      (close-modal-dialog
                                        (lambda ()
                                          (highlight-document-component jazz-file))))))
                               (list :bulleted
                                     (list :hyperlink action
                                           (format "{a} defined in {a}"
                                                   (get-name~ jazz-file)
                                                   (get-presentation-property~ project))))))
                           (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                    ,@(when too-many?
                        (list (list :bulleted "..."))))))
            (message-box text)
            #f)))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection)
    (activate-object (selected-object)))
  
  
  (method (activate-object object)
    (define (find-concrete-descendant)
      (continuation-capture
        (lambda (return)
          (for-each-descendant~ object
            (lambda (descendant level)
              (when (and (is? descendant Project)
                         (concrete?~ descendant))
                (continuation-return return descendant)))
            include-self?: #f)
          #f)))
    
    (if (is? object Project)
        (if (concrete?~ object)
            (activate-project object)
          (let ((concrete-descendant (find-concrete-descendant)))
            (if concrete-descendant
                (activate-project concrete-descendant)
              (bell))))
      (bell)))
  
  
  (method (activate-project project)
    (unless (eq? project (get-active-project))
      (let ((tree (get-tree)))
        (when (get-active-project)
          (unhighlight-component~ tree (get-active-project)))
        (set-active-project project)
        (when (get-active-project)
          (let ((row (user-data-row~ tree (get-active-project) visible?: #f)))
            (when row
              (ensure-expanded~ tree row)))
          (highlight-component~ tree (get-active-project))))
      (let ((appl (get-application)))
        (update-project-actions~ appl))))
  
  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (define (update object)
      (typecase object
        ((Project)
         (update-project-catalog object))
        ((Project-Group)
         (for-each update (get-children~ object)))))
    
    (with-cursor :wait
      (lambda ()
        (let ((objects (selected-objects)))
          (for-each update objects)))))
  
  
  (method (update-project-catalog project)
    (let ((catalog (require-catalog~ project)))
      (post-catalog
        (lambda ()
          (activate~ catalog report?: #f)
          (update~ catalog)))))
    
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method public (test-current)
    (let ((project (current-project)))
      (project-test~ project)))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method public (run-current)
    (let ((project (current-project)))
      (run-project project)))


  (method public (run-selection)
    )

  
  (method (run-project project)
    (run-project~ (get-application) project))

  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method public (debug-current (executable: executable #f))
    (debug-project (current-project) executable: executable))
  
  
  (method public (debug-selection)
    (let ((project (current-project)))
      (debug-project project)))
      
  
  (method (debug-project project (executable: executable #f))
    (debug-project~ (get-application) project executable: executable debugger-interactive?: #t))

  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-selection)
    (let ((appl (get-application))
          (tree (get-tree)))
      (for-each (lambda (component)
                  (typecase component
                    ((Project)
                     (debug-project component))
                    ((Project-File)
                     (let* ((file (get-effective-source~ component))
                            (ext (get-extension~ file)))
                       (edit-document~ appl file)))))
                (selected-components~ tree))))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current evt)
    (let ((project (current-project)))
      (if (not project)
          (bell)
        (build-project project))))
  
  
  (method public (build-current)
    (let ((project (current-project)))
      (build-project project)))
  
  
  (method (build-project project)
    (project-build~ project))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let ((moniker (get-moniker~ (get-controller~ guest))))
          (compile-moniker moniker)))))
  
  
  (method public (compile-moniker moniker)
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file moniker project-file))))
  
  
  (method (compile-file moniker project-file)
    (let ((name (find-pathname-unit (parse~ moniker))))
      (if (not name)
          (bell)
        (let ((kernel (project-kernel~ (get-project~ project-file))))
          (launch-executable kernel arguments: (list "-compile" (->string name)) show-console?: #t)))))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current)
    (define (preprocess-file moniker file)
      (let ((proc
              (lambda (thread)
                (let ((project (get-project~ file)))
                  (prepare-maps~ project)
                  (prepare-directories~ project)
                  (user-message "Preprocessing {a}..." moniker)
                  (let ((output (get-output-log))
                        (timer (new Timer)))
                    (clear-results~ output)
                    (select-results~ output)
                    (select-docked Output-Log)
                    (preprocess~ file project #f #f output force?: #t)
                    (user-message "Preprocessing done in {a}" (cpu-duration~ timer)))))))
        (proc #f)))
    
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let* ((moniker (get-moniker~ (get-controller~ guest)))
               (workbench (get-workbench))
               (file (find-source~ workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current)
    (let ((project (current-project)))
      (clean-project project)))
  
  
  (method (clean-project project)
    (if (concrete?~ project)
        ;; to complete
        #f
      (bell)))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current evt)
    (let ((project (selected-project)))
      (if (not project)
          (bell)
        (distribute-project project))))
  
  
  (method public (distribute-current)
    (let ((project (current-project)))
      (distribute-project project)))
  
  
  (method (distribute-selection)
    (distribute-project (selected-project)))
  
  
  (method (distribute-project project)
    (let* ((mode         'backup)
           (left         (project-distribution~ project))
           (right        (project-distribution-directory~ project))
           (content      (project-distribution-list~ project))
           (ignored-dirs (list ".git" ".hg" "bin" "build"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories left-moniker: left right-moniker: right left-content: content ignored-nodes: ignored-dirs ignored-leaves: files ignored-extensions: extensions host-visible?: #f)))
      (with-cursor :wait
        (lambda ()
          (compare-trees~ (get-guest~ frame))
          (focus-host~ frame)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object)
    (let ((tree (get-tree)))
      (selected-component~ tree)))
  
  
  (method (selected-objects)
    (let ((tree (get-tree)))
      (selected-components~ tree)))
  
  
  (method (selected-project)
    (let ((object (selected-object)))
      (when (is? object Project)
        object)))
  
  
  (method (selected-concrete-project)
    (let ((object (selected-object)))
      (when (and (is? object Project)
                 (concrete?~ object))
        object)))
  
  
  (method (current-project)
    (if (not (get-active-project))
        (error "No active project")
      (get-active-project)))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu)
    (let ((tree (get-tree)))
      (define (new-group-menu object)
        (let ((menu (new Group-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-workbench-menu object)
        (let ((menu (new Workbench-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-concrete-project-menu object)
        (let ((menu (new Concrete-Project-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-project-menu object)
        (let ((menu (new Project-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
          (update-group/project-menu menu)
          (cleanup-separators~ menu)
          (layout-menu~ menu)
          menu))
      
      (define (new-element-menu object)
        (let ((menu (new Element-Menu client: (get-tree))))
          (update-component-menu menu (selected-components~ tree) '() #f)
          menu))
      
      (define (update-group/project-menu menu)
        (define (hide-item name)
          (let ((item (locate-component~ menu name)))
            (when item
              (set-visible?~ item #f))))
        
        (when (> (length (get-selection~ tree)) 1)
          (hide-item 'add-project)
          (hide-item 'add-file)
          (hide-item 'install-project)
          (hide-item 'import-files)
          (hide-item 'import-directory)))
      
      (let ((object (selected-object)))
        (typecase object
          ((Workbench) (new-workbench-menu object))
          ((Project-Group) (new-group-menu object))
          ((Project)
           (if (concrete?~ object)
               (new-concrete-project-menu object)
             (new-project-menu object)))
          (else
           (when object
             (new-element-menu object)))))))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-project = {s}" (get-active-project))
      (format :console "{%}project-designers =")
      (let* ((pairs (sort < (get-project-designers~ designer) key: (lambda (pair) (category-identifier (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (project . designer) pair
                      (format :console "{%}  {a} {a}" (category-identifier (class-of project)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}projects-table =")
      (let* ((pairs (sort < (table-keys/values (get-projects-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . project) pair
                      (format :console "{%}  {a} {a}" name project)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}categories-table =")
      (let* ((pairs (sort < (table-keys/values (get-categories-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . category) pair
                      (format :console "{%}  {a} {a}" name category)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}resources-table =")
      (let* ((pairs (sort < (table-keys/values (get-resources-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (lambda (pair)
                    (bind (name . resource) pair
                      (format :console "{%}  {a} {a}" name resource)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Controller
;;;


(class Workbench-Manager-Controller extends Editor-View-Controller
  
  
  (method override (document-status)
    "Workbench"))


;;;
;;;; Synchronize-Border
;;;


(class Synchronize-Border extends Border-View
  
  
  (form
    (<install>                                     border-type: solid border-color: {Color name: Outline-Border}
      (<Scroller-View>                             flat?: #t hscroll?: #t vscroll?: #t
        (<!>                         name: content layout-type: fill
          (<Tree-Header>                           flat?: #t
            (<!>                     name: content
              (<Synchronize-Tree>    name: tree))))))))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-file              title: "New Document..." before: add-item icon: {Image-Resource "Add"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: import-files          title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory      title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content   title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                             before: cut)
      (<Label-Item>     name: update-catalog        title: "Update Catalog" before: cut icon: {Image-Resource "Catalog"} action: {Action workbench-manager update-catalog})
      (<Separator-Item>                             before: cut)
      (<Label-Item>     name: set-current-directory title: "Set as Current Directory" before: cut action: {Action workbench-manager set-current-directory})
      (<Separator-Item>                             before: cut)
      (<!>              name: delete-selection      title: "Remove"))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit                title: "Edit" before: add-item icon: {Image-Resource "Edit"} action: {Action workbench-manager edit})
      (<Separator-Item>                           before: add-item)
      (<Label-Item>     name: add-file            title: "New Document..." before: add-item icon: {Image-Resource "Add"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut)
      (<Label-Item>     name: update-catalog      title: "Update Catalog" before: cut icon: {Image-Resource "Catalog"} action: {Action workbench-manager update-catalog})
      (<Separator-Item>                           before: cut)
      (<!>              name: delete-selection    title: "Remove"))))


;;;
;;;; Concrete-Project-Menu
;;;


(class Concrete-Project-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "Select as Active Project" before: cut default?: #t action: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Workbench-Menu
;;;


(class Workbench-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-project         title: "New Project..." before: add-file action: {Action workbench-manager add-project})
      (<Label-Item>     name: install-project     title: "Install Project..." before: import-files icon: {Image-Resource "Import"} action: {Action workbench-manager install-project})
      @wait-complete
      (<!>              name: synchronize-content visible?: #f))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit             title: "Edit" before: cut default?: #t icon: {Image-Resource "Edit"} action: {Action workbench-manager launch})
      (<Separator-Item>                        before: cut)
      (<!>              name: delete-selection title: "Remove")))))
