;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jedi Development
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jedi.development jazz


(import (jazz.debuggee)
        (jazz.editor.jazz)
        (jazz.editor.jazz.inspector)
        (jazz.editor.sql)
        (jazz.editor.sql.view)
        (jazz.graphic)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.locale)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.workspace)
        (jazz.utilities))


;;;
;;;; Fold
;;;


;; fun and experimental


(definition (iter-list lst proc)
  (when lst
    (proc (car lst))
    (iter-list (cdr lst) proc)))


(definition (iter-node node proc)
  (letrec ((iter
             (function (node)
               (proc node)
               (for-each iter (get-children~ node)))))
    (iter node)))


(definition (iter obj proc)
  (cond ((null/pair? obj) (iter-list obj proc))
        ((is? obj JML-Node) (iter-node obj proc))))


(definition (foldl-list x f s)
  (if (not x)
      s
    (foldl-list (cdr x) f (f (car x) s))))


(definition (foldr-list x f s)
  (if (not x)
      s
    (f (car x) (foldr-list (cdr x) f s))))


(definition (foldl-node x f s)
  (foldl (get-children~ x)
         (function (c s)
           (foldl-node c f s))
         (f x s)))


(definition (foldr-node x f s)
  )


(definition (foldl-component x f s)
  (foldl (get-children~ x)
         (function (c s)
           (foldl-component c f s))
         (f x s)))


(definition (foldr-component x f s)
  )


(definition (foldl x f s)
  (cond ((null/pair? x) (foldl-list x f s))
        ((is? x JML-Node) (foldl-node x f s))
        ((is? x Component) (foldl-component x f s))))


(definition (foldr x f s)
  (cond ((null/pair? x) (foldr-list x f s))
        ((is? x JML-Node) (foldr-node x f s))
        ((is? x Component) (foldr-component x f s))))


(definition (iter-map proc obj)
  (let ((fact (new List-Factory)))
    (iter obj
          (function (x)
            (put~ fact (proc x))))
    (get-output~ fact)))


(definition (iter-linearize obj)
  (iter-map identity obj))


(definition (fold-map proc obj)
  (foldr obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (foldl-map proc obj)
  (foldl obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (fold-linearize obj)
  (fold-map identity obj))


(definition public (fold x f s)
  (cond ((null/pair? x) (foldl-list x f s))
        ((is? x JML-Node) (fold-node x f s))
        ((is? x Component) (fold-component x f s))))


(definition (fold-node x f s)
  (let ((ps (f x s)))
    (for-each (function (c)
                (fold-node c f ps))
              (get-children~ x))
    ps))


(definition (fold-component x f s)
  (let ((ps (f x s)))
    (for-each (function (c)
                (fold-component c f ps))
              (get-children~ x))
    ps))


(definition public (component->jml x)
  (fold x
        component-self->jml
        {}))


(definition (component-self->jml c p)
  (new JML-Element p (identifier-name (type-name (class-of c)))
       properties:
       (list
         'name (get-name~ c)
         'position (essay (is? c Figure) (get-position~ c))
         'size (essay (is? c Figure) (get-size~ c))
         'serial (object->serial c))))


(definition (component-ascendants->jml c)
  (define (component->jml c)
    (component-self->jml c (let ((parent (get-parent~ c)))
                             (if parent
                                 (component->jml parent)
                               {}))))
  
  (define (find-toplevel c)
    (let ((parent (get-parent~ c)))
      (if parent
          (find-toplevel parent)
        c)))
  
  (find-toplevel (component->jml c)))


(definition public (pprint-component x)
  (pretty-print~
    (component->jml x)
    :console))


(definition public (pprint-component-ascendants x)
  (pretty-print~
    (component-ascendants->jml x)
    :console))


;;;
;;;; Hierarchy
;;;


(definition public (ppd c)
  (pprint-component c)
  (unspecified))


(definition public (ppa c)
  (pprint-component-ascendants c)
  (unspecified))


;;;
;;;; Inspect
;;;


(definition public (i object)
  (inspect-object object))


(definition public (inspect-form form/component)
  @need-to-convert
  (with-text-inspector
    (function (output)
      (let ((form (if (is? form/component Form) form/component (get-form~ form/component)))
            (printer (new Form-Printer)))
        (print-form~ printer form 0 output)))))


(definition public (inspect-branches component)
  @need-to-convert
  (with-text-inspector
    (function (output)
      (let ((first? #t))
        (for-each-branch~ component
          (function (branch)
            (if first?
                (set! first? #f)
              (format output "{%}{%}"))
            (format output "{a}{%}" (get-name~ branch))
            (let ((form (get-restore-form~ branch)))
              (if (not form)
                  (format output " {}{%}")
                (let ((printer (new Form-Printer)))
                  (print-form~ printer form 0 output))))))))))


(definition (with-text-inspector proc)
  (let ((file (create-temporary-file)))
    (call-with-output-file (parse~ file)
      proc)
    (let* ((workspace (get-name~ (selected-workspace)))
           (frame (new-frame Jazz-Text-View host-visible?: #f host-workspace: workspace))
           (text (get-guest~ frame)))
      (set-moniker~ (get-controller~ text) file)
      (set-caret~ text (text-beginning~ text))
      (set-modified?~ text #f)
      (bring-to-front~ frame)
      (set-visible?~ frame #t))))


@wait-to-slow
(definition (with-text-inspector proc)
  @convert-text-printer
  (let* ((workspace (get-name~ (selected-workspace)))
         (frame (new-frame Jazz-Text-View host-visible?: #f host-workspace: workspace))
         (text (get-guest~ frame))
         (output (new Text-Printer text)))
    (proc output)
    (set-caret~ text (text-beginning~ text))
    (set-modified?~ text #f)
    (bring-to-front~ frame)
    (set-visible?~ frame #t)))


(definition public (methods class/obj)
  (let ((class (if (class? class/obj) class/obj (class-of class/obj))))
    (map field-name (collect-type Method (table-values (get-fields~ class))))))


;;;
;;;; Design
;;;


(definition public (design class/component)
  (let ((component (if (class? class/component) (new class/component) class/component)))
    (let ((editor (typecase component
                    ((View) (autoload 'View-Editor))
                    ((Component) (autoload 'Manager-View))
                    (else (error "Only components can be designed: {s}" component)))))
      (new-frame editor client: component))))


;;;
;;;; Reset
;;;


(definition public (rsw name)
  )


(definition public (rsp name)
  (table-set! Palettes name {}))


;;;
;;;; Choose
;;;


(definition public (cc (color-or-name {}))
  (let ((color (if (or (not color-or-name) (is? color-or-name Color)) color-or-name (dispatch Color color-or-name))))
    (get-modal Color-Request initial-color: color)))


(definition public (cf)
  (choose-file))


(definition public (cmf)
  (choose-file multiple-selection?: #t))


(definition public (cnf)
  (choose-new-file))


(definition public (cd)
  (choose-directory))


(definition public (cp)
  (let ((path (format "{l}" (get-list~ (cd)))))
    (set-clipboard-text path)
    (user-message "Clipboard set to {a}" path)
    {}))


(definition public (md class)
  (get-modal~ class))


;;;
;;;; Files
;;;


(definition public (find-files pattern directory)
  (let ((regexp (new Regular-Expression pattern)))
    (iterate-directory~ directory
      (function (file)
        (let ((name (get-name~ file)))
          (when (match~ regexp name)
            (debug file)))))))


(definition public (rename-files find replacement)
  (let ((directory (choose-directory title: "Rename"))
        (find-regexp (new Regular-Expression find))
        (replacement-regexp (new Regular-Expression replacement))
        (succeeded 0)
        (failed (new List-Factory)))
    (iterate-directory~ directory
      (function (file)
        (let* ((name (get-name~ file))
               (match (match~ find-regexp name)))
          (when match
            (let* ((new-name (replace~ replacement-regexp match))
                   (new-file (new-file~ (get-directory~ file) new-name)))
              (move-pathname~ file new-file)
              (increase! succeeded)))))
      files?: #t
      directories?: #f)
    (message-box (format "{a} file{a} renamed" succeeded (format-plural succeeded)))))


;;;
;;;; Receive Files
;;;


(class Receiver-View extends View
  
  
  (property invite   initialize {} getter get-invite setter set-invite)
  (property receiver initialize {} accessors generate)
  
  
  (form
    (<install> background: {Color name: Dark}))
  
  
  (method public (get-invite)
    invite)
  
  
  (method public (set-invite value)
    (set! invite value)
    (invalidate-view))
  
  
  (method (receive-files pos files)
    (receiver pos files self))
  
  
  (definition Background-Font
    {Font name: Heading1})
  
  
  (method (draw surface context lh lv)
    (set-font~ surface Background-Font)
    (let* ((title (localize (either invite "Drop Files Here")))
           (extent (get-text-extent~ surface title))
           (pos (center extent (get-display-size))))
      ;; shadow
      (set-text-color~ surface {Color name: Black})
      (draw-text~ surface (+ (get-h~ pos) 2) (+ (get-v~ pos) 2) title)
      ;; text
      (set-text-color~ surface {Color name: Gray})
      (draw-text~ surface (get-h~ pos) (get-v~ pos) title #t))))


(definition (setup-receiver receiver (title: title {}) (position: position {}) (size: size {}) (invite: invite {}))
  (new-palette Receiver-View
               host-title: (either title "Receive Files")
               host-position: (either position {Point 219 169})
               host-size: (either size {Dimension 434 224})
               ;; convert guest-context: self
               invite: invite
               receiver: receiver))


;;;
;;;; Regular Expressions
;;;


(definition public (rer from to string)
  (replace~ (new Regular-Expression to) (match~ (new Regular-Expression from) string)))


;;;
;;;; Data
;;;


(definition public (debug-table table (name: name {}) (max-display: max-display 250))
  (let ((text (get-sql-console-text)))
    @convert (set-current-request~ text name)
    (display-table~ text table max-display 0)
    table))


;;;
;;;; Utility
;;;


(definition public (hex n)
  (format "#x{x}" n)))
