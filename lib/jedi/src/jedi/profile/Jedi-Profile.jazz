;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jedi Profile
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library protected jedi.profile.Jedi-Profile jazz


(import (jazz.designer)
        (jazz.editor.jazz)
        (jazz.ide)
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.platform)
        (jazz.runtime)
        (jazz.system)
        (jazz.ui.activity)
        (jazz.ui.clipboard)
        (jazz.ui.view)
        (jazz.utilities)
        (jazz.website)
        (jedi)
        (time))


(class Jedi-Profile extends IDE-Profile
  
  
  (method (apropos target catalog-name)
    (let ((catalog (find-catalog~ (get-cataloguer~ (get-application)) catalog-name)))
      (let ((definitions (get-definitions-index~ catalog))
            (fact (new List-Factory)))
        (iterate-table definitions
          (function (name definitions)
            (when (search name target)
              (put~ fact name))))
        (sort ci<? (get-output~ fact)))))
  
  
  (method (recent-files . rest)
    (bind-keywords ((directory {Directory Jazz}) (elapse {})) rest
      (let ((results (get-search-results~ (get-application)))
            (queue (new-queue))
            (from (subtract-duration (current-time) (either elapse (make-time time-duration 0 3600))))
            (ignored-directories '("Crashes" "Debug" "Release" "Work" "bin" "build" ".git"))
            (ignored-extensions '("obj" "o" "o1" "o2" "o3" "o4" "o5" "o6" "o7" "o8" "o9" "a" "dll" "exe" "mnf"))
            (directory-feedback (make-directory-feedback)))
        (iterate-directory~ directory
          (function (file)
            (directory-feedback file)
            (when (and (not (member? (get-extension~ file) ignored-extensions test: ci=?))
                       (time>? (get-modification-time~ file) from))
              (enqueue queue (list file #f #f))))
          ignored-directories: ignored-directories)
        (let ((files (queue-list queue)))
          (let ((count (length files)))
            (user-message "Found {a} file{a}" count (format-plural count))
            (set-mode~ results 'text)
            (add-results~ results (queue-list queue) #f)
            (select-results~ results))))))
  
  
  (method (search-licenseless-files)
    (let ((results (get-search-results~ (get-application)))
          (queue (new-queue))
          (directory-feedback (make-directory-feedback)))
      (iterate-directory~ {Directory Jazz}
        (function (file)
          (let ((ext (get-extension~ file)))
            (when (member? ext '("jazz") test: ci=?)
              (directory-feedback file)
              (call-with-input-file (list path: (parse~ file) eol-encoding: 'cr-lf readtable: jazz-readtable)
                (function (port)
                  (let ((line (read-line port)))
                    (when (and (not (eof-object? line))
                               (not (equal? line ";;;==============")))
                      (enqueue queue (list file #f #f))))))))))
      (let ((files (queue-list queue)))
        (let ((count (length files)))
          (user-message "Found {a} file{a}" count (format-plural count))
          (set-mode~ results 'text)
          (add-results~ results (queue-list queue) #f)
          (select-results~ results)))))
  
  
  (method (search-trailing-whitespace . rest)
    (bind-keywords ((directory {Directory Jazz})) rest
      (let ((results (get-search-results~ (get-application)))
            (queue (new-queue))
            (ignored-directories '("Crashes" "Debug" "Release" "Work" "bin" "build" ".git"))
            (ignored-extensions '("obj" "o" "o1" "o2" "o3" "o4" "o5" "o6" "o7" "o8" "o9" "a" "dll" "exe" "cxx" "swg" "mnf" "jpg" "png" "ppt" "ttf" "wav"))
            (directory-feedback (make-directory-feedback)))
        (iterate-directory~ directory
          (function (file)
            (directory-feedback file)
            (when (not (member? (get-extension~ file) ignored-extensions test: ci=?))
              (let ((lines (load-lines~ file char-encoding-errors: #f)))
                (for-each (function (line rank)
                            (continuation-capture
                              (function (done)
                                (let ((trailing-whitespace #f))
                                  (loop (for n from (- (cardinality line) 1) downto 0)
                                        (do (let ((c (element line n)))
                                              (if (whitespace? c)
                                                  (set! trailing-whitespace #t)
                                                (when trailing-whitespace
                                                  (enqueue queue (list file rank (+ n 1))))
                                                (continuation-return done {})))))))))
                          lines
                          (naturals 0 (length lines))))))
          ignored-directories: ignored-directories)
        (let ((files (queue-list queue)))
          (let ((count (length files)))
            (user-message "Found {a} file{a}" count (format-plural count))
            (set-mode~ results 'text)
            (add-results~ results (queue-list queue) #f)
            (select-results~ results))))))
  
  
  (method (inspect-binary file)
    (call-with-input-file (parse~ file)
      (function (port)
        (debug (read-all port read-u8)))))

  
  ;;;
  ;;;; Catalogs
  ;;;
  
  
  (method (load-catalog name)
    (load-catalog-synchronized name)
    @temp-commented-because-of-an-intermitent-bug-where-the-thread-will-allocate-memory-while-garbage-collecting
    (new Thread
      name: "Catalog Loader"
      context: self
      execute:
      (function (thread)
        (load-catalog-synchronized name))))
  
  
  (method synchronized (load-catalog-synchronized name)
    (let* ((appl (get-application))
           (cataloguer (get-cataloguer~ appl))
           (catalog (get-catalog~ cataloguer name error?: #f)))
      (when catalog
        (set-active?~ catalog #t))))

  
  ;;;
  ;;;; Console
  ;;;
  
  
  (method (console-command command arguments)
    (case command
      ;; Documentation
      ((:doc) (edit-documentation (car arguments)))
      ;; Macro
      ((:expand) (expand (car arguments)))
      ((:expand-scheme) (expand-scheme (car arguments)))
      ;; Various
      ((:compile) (compile arguments))
      ((:edit) (edit arguments))
      ((:exit) (exit) #t)
      (else (nextmethod command arguments))))
  
  
  (method (edit-documentation name)
    (let ((appl (get-application)))
      (edit-documentation~ appl name)))

  
  (method (expand form)
    (unimplemented)
    @convert
    (bind (name . arguments) form
      (let* ((try (function (object) (category-field (class-of object) name)))
             (definition (either (try Language) (try Java))))
        (if (null? definition)
            (begin
              (debug form)
              #t)
          (let ((macro (definition-value definition)))
            (cond ((syntax-macro? macro) (debug (apply macro arguments)))
                  ((macro? macro) (debug (macro arguments)))
                  (else (debug (apply macro arguments))))
            #t)))))
  
  
  (method (expand-scheme form)
    (unimplemented)
    @convert
    (bind (name . arguments) form
      (let* ((try (function (package) (category-field (class-of package) name)))
             (macro (definition-value (either (try Kernel)))))
        (cond ((syntax-macro? macro) (debug (apply macro arguments)))
              ((macro? macro) (debug (macro arguments))))
        #t)))
  
  
  (method (compile classes)
    (unimplemented)
    @convert
    (compile-classes classes))
  
  
  (method (edit location)
    (edit~ (new Jazz-Code-Location location)))
    
  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method (utf8 text)
    (let ((count 1))
      (for-each (function (line)
                  (when (some? (function (char)
                                 (>= (char->integer char) 128))
                               line)
                    (debug count line (map char->integer (coerce line List))))
                  (increase! count))
                (get-content~ text))))
    
  
  ;;;
  ;;;; Modules
  ;;;
  
  
  (method (package-modules package)
    (let ((fact (new List-Factory)))
      (let ((product (package-product package)))
        (if product
            (let ((pair (assq 'update (cdr product))))
              (if (not pair)
                  '()
                (cdr pair)))
          (debug "Unable to find package product for" (package-name package))
          '()))))
  
  
  (method (package-product package)
    (assq (package-name package) (package-products package)))
  
  
  (method (module-submodules module-name)
    (load-module 'core.module.builder)
    (let ((submodules '()))
      (for-each-submodule module-name
        (function (submodule-name declaration phase)
          (set! submodules (cons submodule-name submodules))))
      submodules))
    
  
  ;;;
  ;;;; Doc
  ;;;
  
  
  (definition Documented-Modules
    '((irregex)
      (statprof)
      (scheme)
      (kernel jazz.dialect.kernel)
      (jazz jazz.dialect.language)
      (jazz.catalog)
      (jazz.console)
      (jazz.database)
      (jazz.database.sqlserver)
      ;(jazz.debuggee)
      ;(jazz.debugger)
      ;(jazz.designer)
      (jazz.graphic)
      (jazz.io)
      (jazz.jml)
      (jazz.jrm)
      (jazz.library)
      ;(jazz.library.component)
      ;(jazz.library.exemplar)
      ;(jazz.library.listener)
      ;(jazz.library.node)
      ;(jazz.library.template)
      (jazz.media)
      (jazz.network)
      ;(jazz.platform)
      (jazz.runtime)
      (jazz.schema)
      (jazz.system)
      (jazz.system.application)
      (jazz.system.process)
      (jazz.ui)
      ;(jazz.ui.activity)
      (jazz.ui.clipboard)
      (jazz.ui.dialog)
      ;(jazz.ui.history)
      ;(jazz.ui.image)
      ;(jazz.ui.look)
      ;(jazz.ui.offscreen)
      ;(jazz.ui.picker)
      ;(jazz.ui.print)
      ;(jazz.ui.resizer)
      (jazz.ui.view)
      (jazz.ui.window)
      ;(jazz.ui.workspace)
      (jazz.utilities)
      (time)))
  
  
  (method (extract-doc)
    (for-each extract-toplevel-doc Documented-Modules)
    (user-message "Done"))
  
  
  (method (extract-toplevel-doc info)
    (bind (name . modules) info
      (user-message "Extracting {a}..." name)
      (let ((reference-dir {Directory jazz.website "reference"}))
        (create-directories~ reference-dir)
        (call-with-output-file (list path: (parse~ (new-file~ reference-dir (format "{a}.jml" name))) eol-encoding: (get-eol-encoding))
          (function (port)
            (let ((node (parse-jml (extract-module/library-doc name modules))))
              (pretty-print~ node port)
              (newline port)))))))
  
  
  (method (extract-module/library-doc name modules)
    (load-module 'core.module.builder)
    (let ((module (outline-module (if (null? modules) name (car modules)))))
      (typecase module
        ((Module-Declaration) (extract-module-doc name module))
        ((Library-Declaration) (extract-library-doc name module)))))
  
  
  (method (extract-module-doc name declaration)
    `(<Module-Doc> name: ,name title: ,(symbol->string name)))
  
  
  (method (extract-library-doc name declaration)
    (let ((declarations (filter-access/compatibility-declarations (resolve-declarations (table-values (get-public-lookup declaration))))))
      (let ((sorted (sort string<? declarations key: (function (decl) (symbol->string (get-name~ decl))))))
        `(<Library-Doc> name: ,name title: ,(symbol->string name)
           ,@(collect extract-declaration-doc sorted)))))
  
  
  (method (extract-declaration-doc declaration)
    (typecase declaration
      ((Export-Declaration) (extract-export-doc declaration))
      ((Define-Declaration) (extract-define-doc declaration))
      ((Define-Macro-Declaration) (extract-define-macro-doc declaration))
      ((Definition-Declaration) (extract-definition-doc declaration))
      ((Generic-Declaration) (extract-generic-doc declaration))
      ((Macro-Declaration) (extract-macro-doc declaration))
      ((Syntax-Declaration) (extract-syntax-doc declaration))
      ((Class-Declaration) (extract-class-doc declaration))
      ((Interface-Declaration) (extract-interface-doc declaration))
      ((Property-Declaration) (extract-property-doc declaration))
      ((Slot-Declaration) (extract-slot-doc declaration))
      ((Method-Declaration) (extract-method-doc declaration))
      ((C-Type-Declaration) (extract-c-type-doc declaration))
      ((C-Definition-Declaration) (extract-c-definition-doc declaration))
      ((C-Named-Declare-Declaration) {})
      (else (debug 'Unknown (type-name (class-of declaration))) `(<Doc> name: ,(get-name~ declaration)))))
  
  
  (method (extract-export-doc declaration)
    `(<Export-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))))
  
  
  (method (extract-define-doc declaration)
    `(<Definition-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-define-macro-doc declaration)
    `(<Syntax-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-definition-doc declaration)
    `(<Definition-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-generic-doc declaration)
    `(<Generic-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-macro-doc declaration)
    `(<Syntax-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-syntax-doc declaration)
    `(<Syntax-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-class-doc declaration)
    (let ((name (symbol->string (get-name~ declaration)))
          (ascendant (get-ascendant~ declaration))
          (interfaces (get-interfaces~ declaration)))
      (unless (or (ends-with? name "-Class")
                  (ends-with? name "~Class"))
        `(<Class-Doc> name: ,(extract-locator declaration) title: ,name
           ascendant: ,(if ascendant (extract-locator (resolve-binding ascendant)) {})
           interfaces: ,(map extract-locator (resolve-declarations interfaces))
           ,@(map extract-declaration-doc (filter-access/compatibility-declarations (queue-list (get-children~ declaration))))))))
  
  
  (method (extract-interface-doc declaration)
    (let ((ascendants (get-ascendants~ declaration)))
      `(<Interface-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
         ascendants: ,(map extract-locator (resolve-declarations ascendants))
         ,@(map extract-declaration-doc (filter-access/compatibility-declarations (queue-list (get-children~ declaration)))))))
  
  
  (method (extract-slot-doc declaration)
    `(<Slot-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))))
  
  
  (method (extract-property-doc declaration)
    `(<Property-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))))
  
  
  (method (extract-method-doc declaration)
    (define (extract-propagation-list)
      (let ((propagation (get-propagation~ declaration)))
        (if (eq? propagation 'inherited)
            '()
          (list propagation: propagation))))
    
    `(<Method-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))
       access: ,(get-access~ declaration)
       ,@(extract-propagation-list)
       parameters: ,(extract-signature (get-signature~ declaration))))
  
  
  (method (extract-c-type-doc declaration)
    `(<C-Type-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))))
  
  
  (method (extract-c-definition-doc declaration)
    `(<C-Definition-Doc> name: ,(extract-locator declaration) title: ,(symbol->string (get-name~ declaration))))
  
  
  (definition (extract-signature signature)
    (define (extract-name parameter)
      (get-name~ parameter))
    
    (if (not signature)
        {}
      (let ((positional (get-positional~ signature))
            (optional (get-optional~ signature))
            (named (get-named~ signature))
            (rest (get-rest~ signature)))
        `(,@(if (null? positional) '() (list positional: (map extract-name positional)))
          ,@(if (null? optional) '() (list optional: (map extract-name optional)))
          ,@(if (null? named) '() (list named: (map extract-name named)))
          ,@(if (not rest) '() (list rest: (extract-name rest)))))))
  
  
  ;; temp hack to obtain the same format as when sub-libraries are well integrated
  (definition (extract-locator declaration)
    (let ((locator (get-locator~ declaration)))
      (let ((names (reverse! (split-identifier locator))))
        (let ((len (length names)))
          (cond ((and (>= len 2) (eq? (first names) (second names)))
                 (apply compose-name (reverse! (cons (first names) (cddr names)))))
                ((and (>= len 3) (eq? (second names) (third names)))
                 (apply compose-name (reverse! (cons (first names) (cons (second names) (cdddr names))))))
                (else
                 locator))))))
  
  
  (definition (resolve-declarations declarations)
    (map (function (decl)
           (resolve-binding decl))
         declarations))
  
  
  (definition (filter-access/compatibility-declarations declarations)
    (collect-if (function (decl)
                  (and (let ((access (get-access~ decl)))
                         (or (eq? access 'public)
                             (and (eq? access 'protected) (memq? (get-propagation~ decl) '(virtual chained)))))
                       (eq? (get-compatibility~ decl) 'uptodate)))
                declarations))

  
  ;;;
  ;;;; Website
  ;;;
  
  
  (definition JazzWebsite-Site
    {File jazz.website "site" "JazzWebsite.jml"})
  
  (definition JazzWebsite-Content
    {Directory jazz.website "content"})
  
  
  (method (regenerate-jazzwebsite)
    (reload-documentation~ (get-application))
    (generate-jazzwebsite))
  
  
  (method (generate-jazzwebsite)
    (let* ((site (load-jml JazzWebsite-Site))
           (site (transform-jml site (new JazzWebsite-Transformation)))
           (pages (get-children~ site)))
      (for-each (function (page)
                  (user-message "Rendering {a}..." (get-property~ page 'path))
                  (render-jazzwebsite-page page))
                pages)
      (user-message "Website generated")))
  
  
  (method (render-jazzwebsite-page page)
    (let* ((content JazzWebsite-Content)
           (file (new-file~ content (format "{a}.htm" (get-property~ page 'path))))
           (preferences (new JML-Preferences))
           (renderer (new XHTML-Renderer preferences))
           (html (first-child~ page)))
      ;; why does using UTF-8 char-encoding not work with accents in the generated HTML page
      (call-with-output-file (list path: (parse~ file) char-encoding: 'ISO-8859-1 eol-encoding: (get-eol-encoding))
        (function (printer)
          (render~ renderer html printer)))))
  
  
  (method (export-latest-news)
    (let* ((site (load-jml JazzWebsite-Site))
           (news (second (get-children~ (find-name~ site 'news))))
           (latest (first (get-children~ news))))
      (let ((output (open-output-string))
            (left-margin 0)
            (right-margin 70)
            (column 0))
        (define (render node)
          (typecase node
            ((JML-Text)
             (render-text (get-text~ node)))
            (else
             (let ((tag (get-tag~ node)))
               (case tag
                 ((division) (render-division node))
                 ((p) (render-paragraph node))
                 ((b) (render-bold node))
                 ((br) (render-break node))
                 ((node) (render-node node))
                 ((span) (render-span node))
                 ((cite) (render-cite node))
                 ((a) (render-anchor node))
                 (else (error "Unable to render tag: {s}" tag)))))))
        
        (define (render-children node)
          (for-each render (get-children~ node)))
        
        (define (render-text text)
          (let ((words (remove-empty-strings (split text " "))))
            (for-each (function (word)
                        (let ((right (+ column (cardinality word))))
                          (cond ((>= right right-margin)
                                 (break))
                                ((> column 0)
                                 (print " ")))
                          (print word)))
                      words)))
        
        (define (render-division node)
          (let ((title (get-property~ node 'title)))
            (paragraph)
            (print (upcase title))
            (paragraph)
            (with-margins left-margin #f
              (function ()
                (render-children node)))))
        
        (define (render-paragraph node)
          (paragraph))
        
        (define (render-bold node)
          (render-text (upcase (get-text~ (first-child~ node)))))
        
        (define (render-break node)
          (break))
        
        (define (render-node node)
          (for-each (function (subnode)
                      (print "-")
                      (with-margins (+ left-margin 2) #f
                        (function ()
                          (render subnode)
                          (break))))
                    (get-children~ node)))
        
        (define (render-span node)
          (render-children node))
        
        (define (render-cite node)
          (render-children node))
        
        (define (render-anchor node)
          (let ((href (get-property~ node 'href))
                (text (get-text~ (first-child~ node))))
            (if (equal? href text)
                (print href)
              (print (format "{a}: {a}" text href)))))
        
        (define (with-margins left right thunk)
          (let ((old-left left-margin)
                (old-right right-margin))
            (when left
              (set! left-margin left))
            (when right
              (set! right-margin left))
            (thunk)
            (set! left-margin old-left)
            (set! right-margin old-right)))
        
        (define (print str)
          (when (and (= column 0) (> left-margin 0))
            (format output "{a}" (make-string left-margin #\space)))
          (display str output)
          (increase! column (cardinality str)))
        
        (define (break)
          (format output "{%}")
          (set! column 0))
        
        (define (paragraph)
          (when (> column 0)
            (break))
          (break))
        
        (render-children latest)
        (set-clipboard-text (get-output-string output))
        (user-message "Latest news rendered to clipboard"))))
    
  
  ;;;
  ;;;; Mandelbrot
  ;;;
  
  
  @wait
  (method (test)
    (new-mandelbrot))
  
  
  @wait
  (method (new-mandelbrot)
    (new-frame Mandelbrot host-title: "Mandelbrot" host-position: {Point 50 50} host-size: {Dimension 800 800} host-workspace: 'home))

  
  ;;;
  ;;;; Jazz
  ;;;
  
  
  (method (gambit (expr: expr {}) (maximum-heapsize: maximum-heapsize 102400) (exception-handler: exception-handler :repl))
    (unimplemented)
    @convert
    (let* ((exception (case exception-handler ((:repl) "r") ((:exit) "q")))
           (command (format "gsc -:da{a},h{a}{a} -" exception maximum-heapsize (if expr (format " -e \"{a}\"" expr) ""))))
      (create-process command directory: {Directory jazz} capture-input?: #f capture-output?: #f capture-error?: #f wait?: #f size: {Dimension 900 500} visible?: #t)))
  
  
  ;;;
  ;;;; Image Magick
  ;;;
  
  
  (definition (image-convert cmd)
    (let ((status (shell-command (format "convert {a}" cmd))))
      (when (/= status 0)
        (error "Shell command returned ({a})" status))))
  
  
  (definition (image-composite cmd)
    (let ((status (shell-command (format "composite {a}" cmd))))
      (when (/= status 0)
        (error "Shell command returned ({a})" status))))
    
  
  ;;;
  ;;;; Bitmaps
  ;;;
  
  
  (method (extract-bitmaps)
    (let ((src {Directory Jazz "lib" "jazz" "resources" "bitmaps"})
          (dst {Directory "C:" "Bitmaps"}))
      (create-directories~ dst)
      (let ((digests '()))
        (iterate-directory~ {Directory Jazz "lib" "jazz" "resources" "bitmaps"}
          (function (file)
            (let ((name (get-name~ file))
                  (digest (digest-file (parse~ file) 'sha-1)))
              (user-message "Processing {a}..." name)
              (unless (or (ends-with? (get-base~ file) "_")
                          (member? digest digests test: equal?))
                (set! digests (cons digest digests))
                (copy-file~ file (new-file~ dst name))))))
        (let ((count (length digests)))
          (user-message "Copied {a} file{a}" count (format-plural count))))))
    
  
  ;;;
  ;;;; Disabled
  ;;;
  
  
  (method (generate-disabled image)
    (let ((directory (get-parent~ image))
          (name (get-name~ image))
          (base (get-base~ image))
          (extension (get-extension~ image)))
      (let ((grayscale (format "_grayscale_.{a}" extension))
            (disabled (format "{a}_.{a}" base extension)))
        (with-current-directory (parse~ directory)
          (function ()
            (unwind-protect
                (begin
                  (image-convert (format "-fx G {a} {a}" name grayscale))
                  (image-convert (format "-channel alpha -fx u-0.6 {a} {a}" grayscale disabled)))
              (let ((grayscale (new-brother~ image grayscale)))
                (when (exists?~ grayscale)
                  (delete-file~ grayscale)))))))))
  
  
  (method (generate-all-disabled directory extensions)
    (iterate-directory~ directory
      (function (file)
        (when (member? (get-extension~ file) extensions test: ci=?)
          (user-message "Generating disabled for {a}..." (get-name~ file))
          (generate-disabled file))))
    (user-message "Done"))
  
  
  (method (delete-all-disabled directory extensions)
    (iterate-directory~ directory
      (function (file)
        (when (and (member? (get-extension~ file) extensions test: ci=?)
                   (ends-with? (get-base~ file) "_"))
          (user-message "Deleting disabled {a}..." (get-name~ file))
          (delete-file~ file))))
    (user-message "Done"))

  
  ;;;
  ;;;; Templates
  ;;;
  
  
  @wait
  (definition Template-AList
    '((title   . "Planner")
      (package . "planner")
      (source  . "{File Planner-Project \"Foo.jazz\"}")))
  
  
  @wait
  (method (test8)
    (let ((expander (new Template-Expander))
          (template {File Builder-Module "Templates" "Project.jazz"}))
      (call-with-output-file (parse~ {File Builder-Module "Templates" "Test.jazz"})
        (function (output)
          (expand~ expander template Template-AList output))))
    (user-message "Done"))
  
  
  ;;;
  ;;;; Taskbar
  ;;;
  
  
  @wait
  (method (test)
    (test-taskbar))
  
  
  @wait
  (method (test-shift)
    (test-remove-taskbar))
  
  
  @wait
  (method (test-taskbar)
    (let ((record (new NOTIFYICONDATA))
          (icon (load-image~ Image 'icon {Icon-Resource "Jazz"} width: 16 height: 16)))
      (set record 'cbSize (size-of NOTIFYICONDATA))
      (set record 'hWnd (get-toplevel-hwnd))
      (set record 'uID 10)
      (set record 'uFlags (bitwise-ior NIF_MESSAGE NIF_ICON))
      (set record 'uCallbackMessage JZ_TASKICON)
      (set record 'hIcon icon)
      (Shell_NotifyIcon NIM_ADD record)))
  
  
  @wait
  (method (test-remove-taskbar)
    (let ((record (new NOTIFYICONDATA)))
      (set record 'cbSize (size-of NOTIFYICONDATA))
      (set record 'hWnd (get-toplevel-hwnd))
      (set record 'uID 10)
      (Shell_NotifyIcon NIM_DELETE record)))
  
  
  ;;;
  ;;;; Tie
  ;;;
  
  
  @wait
  (method (test)
    (let ((x 1))
      (debug (tie "{x}~~Hello~{{self}"))))
  
  
  ;;;
  ;;;; Language
  ;;;
  
  
  @wait
  (method (test1)
    (format :console "{%}xxx{?abc~}yyy" {}))
  
  
  @wait
  (method (test2)
    (format :console "{%}xxx{?ab{a}c~}yyy" 10))
  
  
  ;;;
  ;;;; Generic
  ;;;
    
  
  @wait
  (method (test)
    (debug (definition-value (category-field org.apache.bcel.classfile.JavaClass '<init>))))

  
  @wait
  (method (test)
    (debug (foo~ (new X) {})))
  
  
  @wait
  (method (test-shift)
    (debug (get-foo~ (new X))))
  
  
  @wait
  (method (test1)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list X Y))
      (insert-node~ dispatcher {} (list Y X))
      (insert-node~ dispatcher {} (list A A A))
      (insert-node~ dispatcher {} (list A A B))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test X X)
        (test X Y)
        (test Y Y)
        (test Window Window)
        (test A A A)
        (test A A B)
        (test X Y B))))
  
  
  @wait
  (method (test2)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list Rect))
      (insert-node~ dispatcher {} (list Point))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test Object)
        (test Point)
        (test Rect)
        (test Integer))))
  
  
  @wait
  (method (test2)
    (let* ((dispatcher (new Dispatcher))
           (dag-root (get-dag-root~ dispatcher)))
      (insert-node~ dispatcher {} (list))
      (insert-node~ dispatcher {} (list <javaint>))
      (let ((test
             (function signature
               (let ((generics (find-generics~ dispatcher signature)))
                 (debug (map type-name signature) generics)))))
        (test )
        (test Integer)
        (test Integer Integer)
        (test Integer Integer Integer))))
  
  
  ;;;
  ;;;; Exemplar
  ;;;
  
  
  @wait
  (definition ed
    {})
  
  @wait
  (definition xa
    {})
  
  @wait
  (definition xb
    {})
  
  @wait
  (definition x1
    {})
  
  @wait
  (definition x2
    {})
  
  
  @wait
  (method (setup-exemplar)
    (set! ed (new Exemplar-Domain))
    (set! xa (new X :domain ed name: 'a :a 1 :b 2 :c 3))
    (set! xb (new X :domain ed name: 'b base: 'a :b 5))
    (set! x1 (new X :domain ed base: 'a :a 10))
    (set! x2 (new X :domain ed base: 'b :a 20))
    (user-message "Setup done"))
  
  
  @wait
  (method (test-exemplar)
    (init~ xa)
    (init~ xb)
    (init~ x1)
    (init~ x2)
    (user-message "Test done"))


  ;;;
  ;;;; Tabulate
  ;;;
  
  
  (method (test9)
    (let ((text (get-focus)))
      (if (is-not? text Jazz-Text-View)
          (bell)
        (internal-tabulate text))))
  
  
  (method (internal-tabulate text)
    (let* ((pos (get-start~ text))
           (range (new Range$Cell$ pos pos))
           (explorer (new Jazz-Explorer text range: range))
           (maxes (collect-maxes explorer)))
      (set-range~ explorer range)
      (tabulate-columns text explorer maxes)))
  
  
  (method (collect-maxes explorer)
    (let* ((maxes '())
           (update-maxes
            (function (sizes)
              (set! maxes (if (null? maxes)
                              sizes
                            (map max maxes sizes))))))
      (while (enter-composite~ explorer)
        (let ((sizes (new List-Factory)))
          (while (forward-expr~ explorer)
            (let ((size (- (get-col~ (get-end~ explorer)) (get-col~ (get-start~ explorer)))))
              (put~ sizes size)))
          (update-maxes (get-output~ sizes)))
        (exit-composite~ explorer))
      maxes))
  
  
  (method (tabulate-columns text explorer maxes)
    (let ((undoer (get-undoer~ text)))
      (with-atomic-undo~ undoer
        (function ()
          (while (enter-composite~ explorer)
            (let ((maxes maxes))
              (while (forward-expr~ explorer)
                (let* ((max (car maxes))
                       (size (- (get-col~ (get-end~ explorer)) (get-col~ (get-start~ explorer))))
                       (diff (- max size)))
                  (when (> diff 0)
                    (let ((end (get-end~ explorer)))
                      (replace-text~ text (new Range$Cell$ end end)
                        (list (make-string diff #\space)))))
                  (set! maxes (cdr maxes)))))
            (exit-composite~ explorer))))))

  
  ;;;
  ;;;; Text
  ;;;
  
  
  @wait
  (method (text-macro text)
    (let* ((start (get-row~ (get-start~ text)))
           (end (get-row~ (get-end~ text)))
           (col (get-column~ text start))
           (char (get-char~ text (new Cell start col))))
      (if (/= char #\-)
          (bell)
        (with-locked-update
          (function ()
            (replace~ text (new Range$Cell$ (new Cell start 0) (new Cell start (+ col 2))) (list ""))
            (for-each (function (row)
                        (remove-spaces~ text (new Cell row (paragraph-length~ text row))
                          keep: 'one))
                      (naturals start end))
            (let ((paragraph (get-paragraph~ (get-paragraph~ text start))))
              (unless (get-bulleted?~ (get-format~ paragraph))
                (toggle-bulleted~ text start))))))))
  
  
  @wait
  (method (test)
    (test-for-each-page))
  
  
  @wait
  (method (test-for-each-page)
    (for-each-page~ % 0 (+ (get-limit~ %) 1) 360
     (function (page top bottom)
       (let ((t (get-bottom~ (get-row~ % top)))
              (b (get-top~ (get-row~ % bottom))))
         (debug (- b t))))))
  
  
  @wait
  (method (test-message-box)
    (message-box
      (list "Hello World"
            (list :bulleted "This message-box")
            (list :bulleted indent: 2 "really" " " (list :hyperlink (function () (close-modal-dialog (function () (debug 'yo)))) "really") " " (list image: {Bitmap-Resource "BlueRed"}) " " (list highlight: 'Light-Red "really"))
            (list :bulleted indent: 1 "rocks!"))
      sound: {}))
  
  
  @wait
  (method (hide-paragraphs)
    (let ((text (get-focus)))
      (for-each-selected-paragraph~ text
       (function (row paragraph)
         (hide~ paragraph)))))

  
  ;;;
  ;;;; Java
  ;;;

  
  @wait
  (method (test2)
    (let* ((java (new Java-Runtime))
           (output (execute~ java "com/metascoop/Test" classpath: Java-Classpath :arguments "JazzStandaloneRelease.exe")))
      (message-box (join-lines output))))
  
  
  @wait
  (method (test3)
    (let ((obj1 (new org.jazzscheme.test.Test))
           (obj2 (new org.jazzscheme.test.Test 8)))
      (debug (cj~ obj1 2))
      (debug (test~ obj1 4 5) (test~ obj2 2 3 4))))

  
  ;;;
  ;;;; Thread
  ;;;
  
  
  @wait
  (method (test)
    (new Thread
      context: self
      execute: (function (thread)
                 (debug
                   (foo)))))
  
  
  @wait
  (method (test)
    (new Thread
      context: self
      execute: (function (thread)
                 (car 1))))
  
  
  @wait
  (method (test-shift)
    (let ((impulse (new Impulse)))
      (new Thread
        context: self
        execute: (function (thread)
                   (sleep 5)
                   (car 1)
                   (set-event~ impulse)
                   (debug 'thread-done)))
      (wait-for impulse timeout: 10 error?: #f)
      (debug 'done)))
  
  
  @wait
  (method (test1)
    (let ((t1 (new Thread
                 context: self
                 execute: (function (thread)
                            (sleep 1))))
           (t2 (new Thread
                 context: self
                 execute: (function (thread)
                            (sleep 2)))))
      (debug (wait-for (list t1 t2) timeout: 3000 error?: #f))))

  
  ;;;
  ;;;; Context
  ;;;
  
  
  @wait
  (method (test-context)
    (with-execution-context
      (function ()
        (with-progress
          (function (reporter)
            @wait
            (with-restart
              (function ()
                (to-fix)))
            (for-each (function (n)
                        (with-continue
                          (function ()
                            (foo n))))
                      (naturals 0 10))
            (car 'a))
          threaded?: #f
          context: self))
      title: "test"))
  
  
  @wait
  (method (to-fix)
    (debug (symbol->string {})))
  
  
  @wait
  (method (foo n)
    (with-execution-node
      (function ()
        (goo n))
      title: "hello we are doing..."
      details: '("a" "b" "c")))
  
  
  @wait
  (method (goo n)
    (with-execution-node
      (function ()
        (hoo n))
      title: "goo"
      details: '("x" "y")))
  
  
  @wait
  (method (hoo n)
    (with-execution-node
      (function ()
        (car n))
      title: "hoo"))

  
  ;;;
  ;;;; Parameters
  ;;;
  
  
  @wait
  (method (test-parameters)
    (set-parameter 'test 2)
    (new Thread
      context: self
      execute: (function (thread)
                 (debug 'thread (get-parameter 'test))
                 (set-parameter 'test 3)
                 (debug 'thread (get-parameter 'test))))
    (sleep .5)
    (debug 'main (get-parameter 'test)))
  
  
  ;;;
  ;;;; Logging
  ;;;
  
  
  @wait
  (method (test)
    (with-log (new Log name: 'test file: {File Bin "Logs" "Test.jml"})
      (function ()
        (log-entry name: "hello")
        (log-entry name: "world"))))
  
  
  @wait
  (method (test-shift)
    (foo 2))
  
  
  @wait
  (method (foo x)
    (log-entry name: "foo" message: (format "received {a}" x))
    (bar x))
  
  
  @wait
  (method (bar x)
    (let ((y (+ x x x)))
      (log-entry name: "bar" message: "some stack" data: (new Stack-Snapshot))))
  
  
  @wait
  (method (test)
    (with-log (new Log name: 'test file: {File Bin "Logs" "Test.jml"})
      (function ()
        (log-entry name: "hello")
        (log-entry name: "world")
        (log-properties (list :a 2 :b 3 :c 5) name: "test")
        (with-profile
          (function (node)
            (+ 2 3))
          name: "resources"))))

  
  ;;;
  ;;;; Resources
  ;;;
  
  
  @wait
  (method (test3)
    (gc)
    (test-resources))
  
  
  @wait
  (method (test-resources)
    (with-log (new Log name: "Resources" file: {File Bin "Logs" "Resources.jml"})
      (function ()
        (test-bitmap)
        (test-dc)
        (test-file-printer)
        (test-file-reader)
        (test-image)
        (test-picture)
        (test-portfolio)
        (test-pseudo-handle)
        (test-reader)
        (test-region)
        (test-registry-key)
        (test-socket)
        (test-stack)
        (test-synchronizer)
        (test-thread)
        (test-user-name))))
  
  
  @wait
  (method (test-bitmap)
    (with-profile
      (function (node)
        (new Bitmap :dc (desktop-dc) width: 16 height: 16))
      name: "Bitmap"))
  
  
  @wait
  (method (test-image)
    (with-profile
      (function (node)
        (load-image~ Image 'bitmap {Bitmap-Resource "Break"})
        (load-image~ Image 'icon {Icon-Resource "Jazz"} width: 16 height: 16)
        (load-image~ Image 'cursor {Cursor-Resource "Move"}))
      name: "Image"))
  
  
  @wait
  (method (test-picture)
    (with-profile
      (function (node)
        (new Picture))
      name: "Picture"))
  
  
  @wait
  (method (test-portfolio)
    (with-profile
      (function (node)
        (new Portfolio))
      name: "Portfolio"))
  
  
  @wait
  (method (test-pseudo-handle)
    (with-profile
      (function (node)
        (GetCurrentProcess))
      name: "Pseudo Handle"))
  
  
  @wait
  (method (test-region)
    (with-profile
      (function (node)
        (new Region rect: {Rect 0 0 100 100}))
      name: "Region"))
  
  
  @wait
  (method (test-registry-key)
    (with-profile
      (function (node)
        (let ((key1 (new Registry-Key key: HKEY_CLASSES_ROOT))
              (key2 (new Registry-Key key: HKEY_CURRENT_USER)))
          (open-key~ key1 "TypeLib")
          (open-key~ key1 "TypeLib")
          (open-key~ key1 "TypeLib"))
        (with-closed ((key (new Registry-Key key: HKEY_CLASSES_ROOT)))
          (with-profile
            (function (node)
              (with-closed ((subkey (open-key~ key "TypeLib")))
                ))
            name: "open-key")))
      name: "Registry-Key"))
  
  
  @wait
  (method (test-socket)
    (with-profile
      (function (node)
        (new Socket))
      name: "Socket"))
  
  
  @wait
  (method (test-stack)
    (with-node
      (function (node)
        (log-profile name: 'before)
        (letrec ((proc
                  (function (n)
                    (if (= n 0)
                        (log-profile name: 'after)
                      (proc (- n 1))))))
          (proc 5000)))
      node: (new-log-node name: "Stack")))
  
  
  @wait
  (method (test-synchronizer)
    (with-profile
      (function (node)
        (new Impulse)
        (new Mutex)
        (new Semaphore))
      name: "Synchronizer"))
  
  
  @wait
  (method (test-thread)
    (with-profile
      (function (node)
        (new Thread
          context: self
          execute: (function (thread)
                     (sleep .5))))
      name: "Thread"))

  
  @wait
  (method (test-user-name)
    (with-profile
      (function (node)
        (get-system-user-name))
      name: "User Name"))
  
  
  @wait
  (method (test9)
    (gc-clear-undestroyed))
  
  
  ;;;
  ;;;; Picker
  ;;;
  
  
  @wait
  (method (test1)
    (blend 255))
  
  
  @wait
  (method (test2)
    (blend 100))
  
  
  @wait
  (method (test3)
    (blend 30))
  
  
  @wait
  (method (blend x)
    (pick-figure
      click:
      (function (view pos)
        (set-alpha-blending~ (get-player~ view) x))))
  
  
  ;;;
  ;;;; Reprint Form
  ;;;
  
  
  (method (reprint-toplevel-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (range (toplevel-expr~ text (get-end~ text)))
           (string (get-string~ text range))
           (form (jml->form (read-string-element string))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #f 0 space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))
  
  
  (method (reprint-current-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (classes (current-classes~ text (get-selection~ text)))
           (range (declaration-range~ text (get-end~ text)))
           (string (get-string~ text range))
           (form (jml->form (second (read-string-element string)))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #t (+ 1 (length classes)) space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))
  
  
  (method (reprint-selected-form (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let* ((text (get-focus))
           (range (get-selection~ text))
           (string (get-string~ text range))
           (form (jml->form (read-string-element string))))
      (if (is-not? form Form)
          (bell)
        (let* ((designer (new Designer form: form))
               (output (saved-form~ designer #f 0 space-properties?: space-properties? align-name?: align-name?)))
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (insert-string~ text output)))))))

  
  ;;;
  ;;;; Activities
  ;;;
  
  
  (method (clear-activities)
    (let* ((manager (get-activity-manager))
           (reporters (get-reporters~ manager)))
      (for-each (function (reporter)
                  (unregister-activity~ manager reporter))
                reporters)))

  
  ;;;
  ;;;; Location
  ;;;
  
  
  @wait
  (class Foo extends Object

  
    (definition holder
      {})
    
    
    (method (bar)
      (set! holder {})
      (let* ((x 2)
             (z self)
             (proc
              (function (n flag)
                (let* ((y (+ x x))
                       (p
                        (function ()
                          (let ((v y))
                            (break)
                            (message-box n)))))
                  (if flag p (holder))))))
        (set! holder (proc 5 #t))
        (proc 7 #f)))
    
    
    (method (baz)
      (let ((x 2))
        (car x))))
  
  
  @wait
  (method (test)
    (bar~ (new Foo)))
  
  
  @wait
  (method (test-shift)
    (baz~ (new Foo)))

  
  @wait
  (method (test-location)
    (let ((x 2)
          (y (break))
          (z 3))
      (list x y z)))

  
  @wait
  (method (test-location-aux)
    (let ((z (new [Z Y X])))
      (foo~ z '(10 20 30))))
    
  
  @wait
  (class X extends Object
    
    
    (class Y extends Object
      
      
      (class Z extends Object
        
        
        (method (foo list)
          (for-each (function (x)
                      (map (function (y)
                             (car y))
                           (naturals 0 x)))
                    list))
        
        
        (method (bar)
          (car 1)))))
  
  
  ;;;
  ;;;; XML
  ;;;
  

  @wait
  (method (xml-viewer)
    (let ((document (new XML-Document))
          (file {File "C:" "Books.xml"}))
      (load~ document file)
      (let* ((frame (new-frame XML-Viewer host-visible?: #f))
             (viewer (get-guest~ frame)))
        (set-document~ viewer document)
        (bring-to-front~ frame)
        (set-visible?~ frame #t))))

  
  @wait
  (method (test)
    (let* ((text "<TABLE colspan=2> aaaa </TABLE>")
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))))
  
  
  @wait
  (method (test1)
    (log-entry name: "Test1")
    (let* ((text "start <A> blabla <B> </B> yoyo <C> </C> gousigousi </A> end")
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))))
  
  
  @wait
  (method (test2)
    (let* ((file {File Jazz "Doc.jazz"})
           (text (with-closed ((reader (new File-Reader file))) (read-content-string reader)))
           (parser (new XML-Parser text: text)))
      (debug (parse-text~ parser))
      (debug (length text))))
  
  
  ;;;
  ;;;; XSL
  ;;;

  
  @wait
  (class My-Transfo extends XML-Transformer
    
    
    (method public (machin node x y)
      (xsl-rules node
        ((a)
         (f ((mode "1") (title (<-xml x)))
            (xml>>
             (for-each (function (n)
                         (>>xml
                          (p (<-xml n))))
                       (cdr node)))))))
    
    
    (method public (chouette node a b)
      (xsl-rules node
        ((b)
         (xml>>
          (apply-transformation machin (children~ node)))))))

  
  @wait
  (method (test)
    (let ((transfo (new My-Transfo handler: (new XML-Formatter))))
      (machin~ transfo '(a "B" "C") 1 2)))
  
  
  @test
  (method (test1)
    (format :console "{t}"
     (expand-xsl-ruleset
       '(x y)
       (list
        '((a)
          (f
           (xml>>
            (for-each
             (function (n)
               (>>xml
                (p (<-xml n))))
             (children~ node)))))))))
  
  
  @wait
  (method (test0)
    (let ((f (new XML-Formatter :pretty #t indentation: 2)))
      (begin-element~ f "body")
      (begin-element~ f "h1")
        (add-attribute~ f "align" "center")
      (end-element~ f "h1")
      (begin-element~ f "p")
        (text~ f "Bonjour les petits amis")
      (end-element~ f "p")
      (end-element~ f "body")))
  

  @test
  (method (test1)
    (let ((processor (new XML-Formatter :pretty #f))
          (converter process-sxml))
       (converter
        '(body
          (h1 ((align "center"))
              "allo"
              (b "le monde")
              "de toto"))
        processor)))
  
  
  @wait
  (method (test0)
    (car 1))
  
  
  @wait
  (method (setup-compiler)
    (initialize-user-passes~ Compiler)
    (add-user-pass~ Compiler (new Type-Annotator))
    (add-user-pass~ Compiler (new Mutation-Annotator)))
  
  
  ;;;
  ;;;; Scheme
  ;;;
  
  
  @wait
  (method (test1)
    (cond (2 => debug)))
  
  
  @wait
  (method (test)
    (debug (lalr-parser (ID +))))
  
  
  @wait
  (method (test)
    (test~ CPS identity))

  
  ;;;
  ;;;; Various
  ;;;
  
  
  (method (speedup old new)
    (percentage (- old new) new))
  
  
  @wait
  (definition activity-no
    0)


  @wait
  (method (test-activities)
    (new Activity
      context: self
      execute: (function (activity)
                 (let ((max (+ 5 (random 50)))
                       (wait (+ .3 (/ (random 500) 1000.)))
                       (keep? (zero? (random 2)))
                       (no activity-no)
                       (n 0))
                   (increase! activity-no)
                   (set-range~ activity (new Range 0 max))
                   (while (and (< n max) (not (cancel-requested?~ activity)))
                     (sleep wait)
                     (increase! n)
                     (user-message~ activity "Test {s} : Step {s}" no n)
                     (delta-pos~ activity 1))
                   (unless (cancel-requested?~ activity)
                     (user-message~ activity "Test {s} : Done" no)
                     (set-done~ activity)
                     (sleep .5))))
      :unregister? #t))


  @wait
  (method (test-styles)
    (let ((stage (locate~ (find-guest~ (get-stage) Showcase) 'stage)))
      (send-message~ (locate~ stage 'pb) BM_SETIMAGE IMAGE_BITMAP (load-image~ Image 'bitmap {Bitmap-Resource "Break"}))))


  ;;;
  ;;;; Directory
  ;;;
  
  
  (method (collect-extensions dir)
    (let ((extensions '()))
      (iterate-directory~ dir
        (function (file)
          (let ((ext (get-extension~ file)))
            (when (and ext (not (member? ext extensions test: ci=?)))
              (set! extensions (cons (downcase ext) extensions))))))
      (sort string<? extensions)))


  ;;;
  ;;;; Java Parser
  ;;;


  @wait
  (method (test-ast (describe? #t))
    (let ((file {File Jazz "lib" "jazz.sample.files" "Java" "org" "jazz" "project" "Z.java"}))
      (let ((ast (parse-java file Java-AST)))
        (when describe?
          (describe~ ast)
          (fresh-prompt~ (get-application)))
        ast)))


  @wait
  (method (test-java)
    (let ((file {File Jazz "lib" "jazz.sample.files" "Java" "org" "jazz" "project" "Z.java"}))
      (let ((ast (parse-java file Java-AST)))
        (java-definitions ast))))

  
  ;;;
  ;;;; Reports
  ;;;
  
  
  (method (report-aliases)
    (let* ((table (get-aliases))
           (aliases (table-keys/values table)))
      (newline)
      (for-each (function (info)
                  (bind (key . value) info
                    (format :console "{s} : {l}{%}" key value)))
                (sort < aliases key: car)))
    (fresh-prompt~ (get-application)))))
