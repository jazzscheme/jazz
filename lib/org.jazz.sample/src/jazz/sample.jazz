;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Sample
;;;


(library jazz.sample jazz


;;;
;;;; Syntax
;;;


@w
(macro (m form)
  v)


@w
(syntax (y expr)
  v)


;;;
;;;; Definition
;;;


(define (d)
  v)


(definition package final (e)
  v)


@w
(constant c
  (function ()
    v))


@w
(enumeration E
  (A #x01)
  (B #x02))


;;;
;;;; Foreign
;;;


@needs-to-be-compiled
(c-type UINT (native unsigned-int))


@needs-to-be-compiled
(c-structure S
  (UINT x))


@needs-to-be-compiled
(c-external Jazz bool (e) "JzE")


@needs-to-be-compiled
(definition WindowFromPoint
  (c-function (LPPOINT) HWND
    "___result_voidstar = WindowFromPoint(*___arg1);"))


@needs-to-be-compiled
(c-definition (call-process-hwnd-message hWnd uMsg wParam lParam) (HWND UINT WPARAM LPARAM) LRESULT "windowproc" "static"
  (process-hwnd-message hWnd uMsg wParam lParam))


;;;
;;;; Reader
;;;


@w
(define (literals)
  '(2
     2.3
     +2
     -3
     5L
     #b1101
     #x0A
     #f
     #t
     #\a
     #(a b c)
     (a b c)
     x
     :x
     x:
     "x"
     #"x"#
     {Point 2 3}))


@w
(define (comments)
  v ;; x
  @comment x v)


@w
(define (functional-syntax)
  v
  (v v))


@w
(define (object-syntax)
  self
  (x~ v v))


@w
(define (specifier-syntax x <fx>)
  (let ((y <fx> v))
    v))


;;;
;;;; Specials
;;;


@w
(define (binding-specials)
  (let ((x v))
    (let* ((x v))
      (with-closed ((x v))
        v)))
  (bind (x) v
    (bind-optionals ((x v)) v
      (bind-keywords ((x v)) v
        (receive (x) v
          v)))))


@w
(define (functional-specials)
  (function (x)
    v))


@w
(define (quotation-specials)
  'x
  (quote x))


@w
(define (logical-specials)
  (and v)
  (or v))


@w
(define (control-specials)
  (if v
      v
    v)
  (while v
    v))


@w
(define (assignment-specials)
  (set! v v))


@w
(define (other-specials)
  (optimize (:frame? #f)
    (profile (:on? #t name: other-specials)
    (synchronize v
      v)
    (cast v v))))


;;;
;;;; Macros
;;;


@w
(define (binding-macros)
  (letrec ((x v))
    (with ((x v))
      v)))


@w
(define (quotation-macros)
  `(x ,v ,@v)
  (quasiquote (x (unquote v) (unquote-splicing v))))


@w
(define (logical-macros)
  (essay v)
  (either v))


@w
(define (control-macros)
  (begin
    v)
  (prog1 v
    v)
  (when v
    v)
  (unless v
    v)
  (cond (v v)
        (else v))
  (case v
    ((x) v)
    (else v))
  (ecase v
    ((v) v)
    (else v))
  (typecase v
    ((v) v)
    (else v))
  (catch v
    v)
  (unwind-protect
      v
    v))


@w
(define (assertion-macros)
  (assert v)
  (assert-type v v)
  (error? v))


@w
(define (iteration-macros)
  (loop (for x from v to v by v)
        (collect v)
        (do v)))


@w
(define (assignment-macros)
  (increase! v v)
  (decrease! v v))


;;;
;;;; Runtime
;;;


@w
(define (runtime-errors)
  (let ((obj (new Object)))
    (x~ obj)))


;;;
;;;; Interface
;;;


(interface I
  
  
  (method public virtual abstract (i)))


;;;
;;;; Class
;;;


(class C extends Object implements I
  
  
  (method meta (cls)
    v)
  
  
  (slot private s initialize v)
  
  
  (property protected p initialize v accessors generate)
  
  
  (form
    (<install>))
  
  
  (define d
    v)
  
  
  (definition e
    v)
  
  
  (method (initialize)
    (nextmethod v)
    v)
  
  
  @w
  (method public inline (f)
    v)
  
  
  @w
  (method chained (g)
    v)
  
  
  @w
  (method synchronized (h)
    v)
  
  
  (method (i)
    v))


;;;
;;;; Generic
;;;


(class X extends Object)
(class Y extends X)


(generic (g (<X> x) p))

(specific (g (<X> x) p)
  v)

(specific (g (<Y> y) p)
  v)


(generic (h (<X> x) p)
  v)

(specific (h (<Y> y) p)
  v))
