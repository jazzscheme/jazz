;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Gomoku AI
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Joel Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.tutorials.gomoku.Gomoku-AI jazz


(import (jazz.tutorials.gomoku)
        (time))


(proclaim (optimize))


(class Gomoku-AI extends Gomoku-Computer
  
  
  (slot game)
  (slot me)
  (slot opponent)
  
  (slot current-eval <fx>           initialize 0  accessors generate)
  (slot last-eval                   initialize #f accessors generate)
  (slot last-evaluations            initialize #f accessors generate)
  (slot last-evaluations-count <fx> initialize 0  accessors generate)
  (slot last-time                   initialize #f accessors generate)
  (slot all-lines                   initialize #f accessors generate)
  (slot search-depth <fx>           initialize 1  accessors generate)

  
  (method (initialize game color)
    (nextmethod)
    (set! game~self game)
    (setup-colors color)
    (setup-lines))
  
  
  (method (setup-colors color)
    (set! me color)
    (set! opponent (* color -1)))
  
  
  (method (played move square token)
    (set! current-eval (+ current-eval (evaluate-move-delta square token))))

  
  (method (computer-move)
    (best-move me 1))
  
  
  (method (best-move token depth)
    (set! last-evaluations-count 0)
    (let ((best '())
          (best-eval #f)
          (best-test (if (= token me) > <))
          (evals '()))
      (loop (for move in (get-available-moves~ game))
            (let ((eval (evaluate-move move token current-eval depth)))
              (set! evals (cons eval evals))
              (when eval
                (cond ;; as good
                  ((and best-eval (= eval best-eval))
                   (set! best (cons move best)))
                  ;; better
                  ((or (not best-eval) (best-test eval best-eval))
                   (set! best (list move))
                   (set! best-eval eval))))))
      (set! last-eval best-eval)
      (set! last-evaluations (reverse evals))
      (random-element best)))
  
  
  (method (evaluate-move move <Square> token <fx> eval <fx> depth <fx>) <fx>
    (play~ game move token)
    (increase! last-evaluations-count)
    (let ((delta (evaluate-move-delta move token)))
      (let ((new-eval (+ eval delta)))
        @sanity-check
        (if (/= new-eval (evaluate-board))
            (error "Invalid incremental eval: new={a}, board={a}" new-eval board-eval))
        (let ((best-eval
                (if (> (* new-eval token) 900000)
                    new-eval
                  (evaluate token new-eval depth))))
          (unplay~ game move move)
          best-eval))))
  
  
  (method (evaluate token <fx> eval <fx> depth <fx>) <fx>
    (if (= depth search-depth)
        eval
      (evaluate-best token eval depth)))
  
  
  (method (evaluate-best token <fx> eval <fx> depth <fx>) <fx>
    (let ((best-eval 10000000))
      (loop (for square in (get-available-moves~ game))
            (let ((eval (evaluate-move square (* token -1) eval (+ depth 1))))
              (when eval
                (let ((normalized-eval (* (cast <fx> eval) token)))
                  (when (< normalized-eval best-eval)
                    (set! best-eval normalized-eval))))))
      (* best-eval token)))
  
  
  (method (evaluate-board) <fx>
    (let ((total 0))
      (loop (for line in all-lines)
            (increase! total (evaluate-line line)))
      total))
  
  
  (method (evaluate-line line <Line>) <fx>
    (let ((me-count (count-token~ line me))
          (opponent-count (count-token~ line opponent)))
      (if (and (> me-count 0)
               (> opponent-count 0))
          0
        (+ (evaluate-count me-count me)
           (evaluate-count opponent-count opponent)))))
  
  
  (definition (evaluate-count count <fx> token <fx>) <fx>
    (* (cast <fx> (case count
                    ((5) 1000000)
                    ((4) 10000)
                    ((3) 1000)
                    ((2) 100)
                    ((1) 10)
                    ((0) 0)))
       token))
  
  
  (definition (evaluate-move-delta square <Square> token <fx>) <fx>
    (let ((total 0))
      (loop (for line in (get-lines~ square))
            (let ((who-count (count-token~ line token))
                  (other-count (count-token~ line (* token -1))))
              (let ((delta <fx>
                      (cond ((and (> who-count 1) (> other-count 0))
                             0)
                            ((= other-count 0)
                             (evaluate-line-delta who-count token))
                            (else
                             (evaluate-count other-count token)))))
                (set! total (+ total delta)))))
      total))
  
  
  (definition (evaluate-line-delta count <fx> token <fx>) <fx>
    (* (cast <fx> (case count
                    ((5) 999000)
                    ((4) 9000)
                    ((3) 900)
                    ((2) 90)
                    ((1) 10)))
       token))
  
  
  ;;;
  ;;;; Lines
  ;;;
  
  
  (method (setup-lines)
    (set! all-lines '())
    (loop (for rank from 0 below (get-board-size~ game))
          (let ((square (board-ref~ game rank)))
            (for-each (lambda (line)
                        (when (not (member? line all-lines test: line=?))
                          (set! all-lines (cons line all-lines))))
                      (get-lines~ square))))))
  
  
(proclaim (not optimize)))
