;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Gomoku
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Joel Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.tutorials.gomoku jazz


(import (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.platform)
        (jazz.platform.literals)
        (jazz.system)
        (jazz.system.application)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities)
        (time))


(definition EMPTY <fx>
  0)

(definition COMPUTER <fx>
  1)

(definition HUMAN <fx>
  -1)


;;;
;;;; Square
;;;


(class Square extends Object
  
  
  (slot row   <fx>   getter generate)
  (slot col   <fx>   getter generate)
  (slot token <fx>   accessors generate)
  (slot lines <list> accessors generate)
  
  
  (method (initialize row col)
    (nextmethod)
    (set! row~self row)
    (set! col~self col)
    (set! token~self EMPTY))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function (printer)
        (format printer "{a} {a} {a}" row col token)))))


;;;
;;;; Line
;;;


(class Line extends Object
  
  
  (slot first  <Square> getter generate)
  (slot second <Square> getter generate)
  (slot third  <Square> getter generate)
  (slot fourth <Square> getter generate)
  (slot fifth  <Square> getter generate)
  
  
  (method (initialize first second third fourth fifth)
    (nextmethod)
    (set! first~self first)
    (set! second~self second)
    (set! third~self third)
    (set! fourth~self fourth)
    (set! fifth~self fifth)))


;;;
;;;; Gomoku
;;;


(class Gomoku extends Object


  (slot board-rows                  initialize 9  accessors generate)
  (slot board-columns               initialize 9  accessors generate)
  (slot board-size                  initialize #f accessors generate)
  (slot board                       initialize #f accessors generate)
  (slot board-moves                 initialize #f accessors generate)
  (slot board-lines                 initialize #f accessors generate)
  
  (slot who-starts                  initialize #f accessors generate)
  (slot current-status              initialize #f accessors generate)
  (slot current-next                initialize #f accessors generate)
  (slot current-eval                initialize #f accessors generate)
  (slot moves                       initialize #f accessors generate)

  (slot display-evaluations?        initialize #f accessors generate)
  (slot last-eval                   initialize #f accessors generate)
  (slot last-evaluations            initialize #f accessors generate)
  (slot last-evaluations-count <fx> initialize 0  accessors generate)
  (slot last-time                   initialize #f accessors generate)
  (slot last-move                   initialize #f accessors generate)
  
  (slot search-depth <fx>           initialize 1  accessors generate)

  
  ;;;
  ;;;; Initialize
  ;;;
  
  
  (method (initialize who)
    (nextmethod)
    (set! board-size (* board-rows board-columns))
    (set! board (make-board))
    (set! board-moves (make-moves))
    (set! who-starts who)
    (set! current-status 'play)
    (set! current-next who)
    (set! current-eval 0)
    (set! moves '())
    (set! last-eval #f)
    (set! last-evaluations #f)
    (set! last-move #f)
    (setup-lines)
    (close-ambiance)
    (play-intro)
    (play-ambiance))
  
  
  (method (make-board)
    (let ((board (make-vector board-size #f)))
      (loop (for row from 0 below board-rows)
            (loop (for col from 0 below board-columns)
                  (let ((rank (square-rank row col)))
                    (vector-set! board rank (new Square row col)))))
      board))
  
  
  (method (make-moves)
    (coerce board List))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method inline (board-unplay sqr)
    (set! board-moves (cons sqr board-moves)))
  
  (method inline (board-play sqr)
    (set! board-moves (remove! sqr board-moves)))
  
  
  (method inline (board-ref rank) <Square>
    (vector-ref board rank))
  
  
  (method inline (square-rank row col) <fx>
    (+ (* row board-columns) col))
  
  
  (method inline (square row col) <Square>
    (board-ref (square-rank row col)))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method (play-at board who sqr)
    (let ((move current-next))
      (set! last-move sqr)
      (set-token~ sqr move)
      (board-play sqr)
      (set! current-next (* current-next -1))
      (set! current-eval (+ current-eval (evaluate-move-delta sqr who)))
      (check-victory who sqr)
      (invalidate-view~ board)))
  
  
  (method (check-victory who sqr)
    (define (victory?)
      (some? line? (get-lines~ sqr)))
    
    (define (line? line)
      (= (count-tokens who line) 5))
    
    (when (victory?)
      (set! current-status who)
      (cond ((eq? who HUMAN) (play-victory))
            ((eq? who COMPUTER) (play-defeat)))))
  
  
  ;;;
  ;;;; Computer
  ;;;
  
  
  (proclaim (optimize))
  
  
  (method (computer-move)
    (let ((before (time->seconds (current-time))))
      (let ((move (best-move COMPUTER 1)))
        (let ((after (time->seconds (current-time))))
          (set! last-time (- after before)))
        move)))
  
  
  (method (best-move who depth)
    (set! last-evaluations-count 0)
    (let ((best '())
          (best-eval #f)
          (best-test (if (= who COMPUTER) > <))
          (evals '()))
      (loop (for sqr in board-moves)
            (let ((eval (and sqr (evaluate-move sqr who current-eval depth))))
              (set! evals (cons eval evals))
              (when eval
                (cond ;; as good
                  ((and best-eval (= eval best-eval))
                   (set! best (cons sqr best)))
                  ;; better
                  ((or (not best-eval) (best-test eval best-eval))
                   (set! best (list sqr))
                   (set! best-eval eval))))))
      (set! last-eval best-eval)
      (set! last-evaluations (reverse evals))
      (random-element best)))
  
  
  (method (evaluate-move sqr <Square> who <fx> eval <fx> depth <fx>) <fx>
    (set-token~ sqr who)
    (board-play sqr)
    (increase! last-evaluations-count)
    (let ((delta (evaluate-move-delta sqr who)))
      (let ((new-eval (+ eval delta)))
        @sanity-check
        (if (/= new-eval (evaluate-board))
            (error "Invalid incremental eval: new={a}, board={a}" new-eval board-eval))
        (let ((best-eval
                (if (> (* new-eval who) 900000)
                    new-eval
                  (evaluate who new-eval depth))))
          (board-unplay sqr)
          (set-token~ sqr EMPTY)
          best-eval))))
  
  
  (method (evaluate who <fx> eval <fx> depth <fx>) <fx>
    (if (= depth search-depth)
        eval
      (evaluate-best who eval depth)))
  
  
  (method (evaluate-best who <fx> eval <fx> depth <fx>) <fx>
    (let ((best-eval 10000000))
      (loop (for sqr in board-moves)
            (let ((eval (evaluate-move sqr (* who -1) eval (+ depth 1))))
              (when eval
                (let ((normalized-eval (* (cast <fx> eval) who)))
                  (when (< normalized-eval best-eval)
                    (set! best-eval normalized-eval))))))
      (* best-eval who)))
  
  
  (method (evaluate-board) <fx>
    (let ((total 0))
      (loop (for line in board-lines)
            (increase! total (evaluate-line line)))
      total))
  
  
  (method (evaluate-line line <Line>) <fx>
    (let ((computer-count (count-tokens COMPUTER line))
          (human-count (count-tokens HUMAN line)))
      (if (and (> computer-count 0)
               (> human-count 0))
          0
        (+ (evaluate-count computer-count COMPUTER)
           (evaluate-count human-count HUMAN)))))
  
  
  (definition (evaluate-count count <fx> who <fx>) <fx>
    (* (cast <fx> (case count
                    ((5) 1000000)
                    ((4) 10000)
                    ((3) 1000)
                    ((2) 100)
                    ((1) 10)
                    ((0) 0)))
       who))
  
  
  (definition (evaluate-move-delta sqr <Square> who <fx>) <fx>
    (let ((total 0))
      (loop (for line in (get-lines~ sqr))
            (let ((who-count (count-tokens who line))
                  (other-count (count-tokens (* who -1) line)))
              (let ((delta <fx>
                      (cond ((and (> who-count 1) (> other-count 0))
                             0)
                            ((= other-count 0)
                             (evaluate-line-delta who-count who))
                            (else
                             (evaluate-count other-count who)))))
                (set! total (+ total delta)))))
      total))
  
  
  (definition (evaluate-line-delta count <fx> who <fx>) <fx>
    (* (cast <fx> (case count
                    ((5) 999000)
                    ((4) 9000)
                    ((3) 900)
                    ((2) 90)
                    ((1) 10)))
       who))
  
  
  (definition (count-tokens who <fx> line <Line>) <fx>
    (+ (if (= (get-token~ (get-first~  line)) who) 1 0)
       (if (= (get-token~ (get-second~ line)) who) 1 0)
       (if (= (get-token~ (get-third~  line)) who) 1 0)
       (if (= (get-token~ (get-fourth~ line)) who) 1 0)
       (if (= (get-token~ (get-fifth~  line)) who) 1 0)))
  
  
  (proclaim (not optimize))
  
  
  ;;;
  ;;;; Lines
  ;;;
  
  
  (definition directions
    '((0 . 1)
      (1 . 1)
      (1 . 0)
      (1 . -1)))
  
  
  (method (line=? l1 l2)
    (and (eq? (get-first~ l1) (get-first~ l2))
         (eq? (get-second~ l1) (get-second~ l2))
         (eq? (get-third~ l1) (get-third~ l2))
         (eq? (get-fourth~ l1) (get-fourth~ l2))
         (eq? (get-fifth~ l1) (get-fifth~ l2))))
  
  
  (method (setup-lines)
    (set! board-lines '())
    (loop (for rank from 0 below board-size)
          (let ((sqr (board-ref rank)))
            (let ((square-lines (compute-square-lines sqr)))
              (set-lines~ sqr square-lines)
              (for-each (lambda (line)
                          (when (not (member? line board-lines test: line=?))
                            (set! board-lines (cons line board-lines))))
                        square-lines)))))
  
  
  (method (compute-square-lines sqr)
    (let ((row (get-row~ sqr))
          (col (get-col~ sqr))
          (lines '()))
      (loop (for dir in directions)
            (loop (for n from -4 to 0)
                  (let ((a (find-next dir row col (+ n 0)))
                        (b (find-next dir row col (+ n 1)))
                        (c (find-next dir row col (+ n 2)))
                        (d (find-next dir row col (+ n 3)))
                        (e (find-next dir row col (+ n 4))))
                    (if (and a b c d e)
                        (set! lines (cons (new Line a b c d e) lines))))))
      lines))
  
  
  (method (find-next dir row col n)
    (legal-square (+ row (* n (car dir)))
                  (+ col (* n (cdr dir)))))
  
  
  (method (legal-square row col)
    (if (and (>= row 0) (< row board-rows)
          (>= col 0) (< col board-columns))
        (square row col)
      #f)))


;;;
;;;; Board
;;;


(definition square-offset
  100)

(definition square-width
  50)

(definition square-spacing
  20)

(definition line-pen
  {Pen name: Black})

(definition human-color
  {Color name: Black})

(definition computer-color
  {Color name: White})

    
(class Gomoku-Board extends View
  
  
  (slot game)
    
  
  (method meta (host-icon)
    {Bitmap-Resource "MsgUser"})
  
  
  (method meta (host-title)
    "Gomoku")
  
  
  (method meta (host-position)
    {Point 90 70})
  
  
  (method meta (host-size)
    {Dimension 884 624})
  
  
  (method (focus-default)
    (acquire-focus~ self))
  
  
  (method (finish rest)
    (nextmethod rest)
    (set! game (new Gomoku HUMAN @w (or who-starts HUMAN)))
    (initialize-board game HUMAN))
  
  
  (method (destroy)
    (close-ambiance)
    (nextmethod))
  
  
  (method (initialize-board game who)
    (cond ((eq? who HUMAN)
           (invalidate-view))
          ((eq? who COMPUTER)
           (let ((move (computer-move~ game)))
             (play-at~ game self COMPUTER move)))))
  
  
  (method (draw surface context update lh lv)
    (let ((bounds (get-bounds)))
      (fill-rect~ surface bounds {Color name: Dark-Blue}))
    (set-text-color~ surface {Color name: Yellow})
    (set-font~ surface {Font name: Heading0})
    (draw-text~ surface square-offset 30 "Bienvenue sur Gomoku")
    (when (get-current-status~ game)
      (let* ((total-width (+ square-width square-spacing))
             (half-width (fxfloor/ square-width 2))
             (total-board (- (* total-width (get-board-rows~ game)) half-width square-spacing)))
        (set-pen~ surface line-pen)
        (loop (for n from 0 below (get-board-rows~ game))
              (line~ surface (+ square-offset (* n total-width) half-width) (+ square-offset half-width) (+ square-offset (* n total-width) half-width) (+ square-offset total-board))
              (line~ surface (+ square-offset half-width) (+ square-offset (* n total-width) half-width) (+ square-offset total-board) (+ square-offset (* n total-width) half-width)))
        (loop (for row from 0 below (get-board-rows~ game))
              (loop (for col from 0 below (get-board-columns~ game))
                    (let ((token (get-token~ (square~ game row col)))
                          (rect (new Rect (+ square-offset (* col total-width)) (+ square-offset (* row total-width)) (+ square-offset (* col total-width) square-width) (+ square-offset (* row total-width) square-width))))
                      (cond ((eq? token HUMAN)
                             (ellipse~ surface rect human-color human-color))
                            ((eq? token COMPUTER)
                             (ellipse~ surface rect computer-color computer-color)))))))
      (cond ((eq? (get-current-status~ game) HUMAN)
             (victory surface "Humain" human-color))
            ((eq? (get-current-status~ game) COMPUTER)
             (victory surface "Ordinateur" computer-color)))
      (set-text-color~ surface {Color name: Ochre})
      (set-font~ surface {Font name: Heading2})
      (draw-text~ surface 650 square-offset (format "depth: {a}" (get-search-depth~ game)))
      (when (and (get-display-evaluations?~ game) (get-last-eval~ game))
        (draw-text~ surface 650 (+ square-offset 50) (format "count: {a}" (get-last-evaluations-count~ game)))
        (draw-text~ surface 650 (+ square-offset 75) (format "in: {a}s" (get-last-time~ game)))
        (set-font~ surface (new Font font-name: "Arial" point-size: 12))
        (let ((c 0)
              (v 225))
          (for-each (lambda (eval)
                      (set-text-color~ surface (if (= c (get-col~ (get-last-move~ game))) computer-color {Color name: Ochre}))
                      (draw-text~ surface 650 v (format "{a}" eval))
                      (increase! c)
                      (increase! v 24))
                    (get-last-evaluations~ game))))))
  
  
  (method (victory surface who color)
    (set-text-color~ surface color)
    (set-font~ surface {Font name: Heading0})
    (draw-text~ surface square-offset 525 (format "Victoire de l'{a}!!!" who)))
  
  
  (method (play-move move place?)
    (play-at~ game self (get-current-next~ game) move)
    (when (and (eq? (get-current-status~ game) 'play) (not place?))
      (let ((move (computer-move~ game)))
        (play-at~ game self (get-current-next~ game) move))))
  
  
  (method (cursor-update pos)
    (let ((sqr (legal-sqr pos)))
      (set-cursor (if sqr :finger :arrow))))
  
  
  (method (mouse-down pos)
    (let ((sqr (legal-sqr pos)))
      (when sqr
        (let ((place? (control-down?)))
          (play-move sqr place?)))))
  
  
  (method (legal-sqr pos)
    (if (eq? (get-current-status~ game) 'play)
        (let ((h (get-h~ pos))
              (v (get-v~ pos))
              (total-width (+ square-width square-spacing)))
          (if (and (>= h square-offset)
                   (< h (+ square-offset (* (get-board-columns~ game) total-width) (- square-spacing)))
                   (>= v square-offset)
                   (< v (+ square-offset (* (get-board-rows~ game) total-width) (- square-spacing))))
              (let ((row (truncate (/ (- v 90) total-width)))
                    (col (truncate (/ (- h 90) total-width))))
                (let ((sqr (square~ game row col)))
                  (if sqr
                      (if (eq? (get-token~ sqr) EMPTY)
                          sqr
                        #f)
                    #f)))
            #f))
      #f))
  
  
  @wait
  (method (restart-game who)
    (initialize-game self who))
  
  
  (method (toggle-evaluations)
    (set-display-evaluations?~ game (not (get-display-evaluations?~ game)))
    (invalidate-view))
  
  
  (method (set-search-depth depth)
    (set-search-depth~ game depth)
    (when (get-last-move~ game)
      (let ((who (* (get-current-next~ game) -1)))
        (let ((delta (evaluate-move-delta~ game (get-last-move~ game) who)))
          (set-token~ (get-last-move~ game) EMPTY)
          (board-play~ game (get-last-move~ game))
          (set-current-eval~ game (- (get-current-eval~ game) delta))
          (computer-move~ game)
          (board-unplay~ game (get-last-move~ game))
          (set-token~ (get-last-move~ game) who)
          (set-current-eval~ game (+ (get-current-eval~ game) delta)))))
    (invalidate-view))
  
  
  (method (play-computer)
    (when (eq? (get-current-status~ game) 'play)
      (let ((move (computer-move~ game)))
        (play-at~ game self (get-current-next~ game) move))))
  
  
  (method (key-press c)
    (case c
      @wait
      ((#\p) (restart-game (or (get-who-starts~ game) HUMAN)))
      @wait
      ((#\h) (restart-game HUMAN))
      @wait
      ((#\c) (restart-game COMPUTER))
      ((#\e) (toggle-evaluations))
      @wait
      ((#\l) (load-board self))
      ((#\q) (exit))
      ((#\1) (set-search-depth 1))
      ((#\2) (set-search-depth 2))
      ((#\3) (set-search-depth 3))
      ((#\4) (set-search-depth 4))
      ((#\5) (set-search-depth 5))
      ((#\6) (set-search-depth 6))
      ((#\7) (set-search-depth 7))
      ((#\8) (set-search-depth 8))
      ((#\9) (set-search-depth 9))
      ((#\space) (play-computer)))))


;;;
;;;; Media
;;;


(definition play-intro?
  #f)

(definition play-ambiance?
  #t)


(definition intro-directory
  {Directory Home "jazz" "app" "gomoku" "media" "intro"})

(definition ambiance-directory
  {Directory Home "jazz" "app" "gomoku" "media" "ambiance"})

(definition victory-directory
  {Directory Home "jazz" "app" "gomoku" "media" "victory"})

(definition defeat-directory
  {Directory Home "jazz" "app" "gomoku" "media" "defeat"})


(definition (play-intro)
  (when play-intro?
    (let ((sound (random-file intro-directory "wav")))
      (when sound
        (play-sound sound asynchronous?: #f)))))


(definition (play-ambiance)
  (when play-ambiance?
    (let ((music (random-file ambiance-directory "mp3")))
      (when music
        (open-music music "ambiance")
        (play-music "ambiance")))))

(definition (close-ambiance)
  (close-music "ambiance"))


(definition (play-victory)
  (let ((sound (random-file victory-directory "wav")))
    (when sound
      (play-sound sound))))

(definition (play-defeat)
  (let ((sound (random-file defeat-directory "wav")))
    (when sound
      (play-sound sound))))


(definition (random-file directory extension)
  (if (exists?~ directory)
      (let ((files
              (collect-files~ directory
                (lambda (file)
                  (ci=? (get-extension~ file) extension)))))
        (if (not-null? files)
            (random-element files)
          #f))
    #f))


;;;
;;;; App
;;;


(class Gomoku-Toplevel extends Toplevel


  (form
    (<install> caption-base: "Gomoku" position: {Point 100 100} size: {Dimension 800 625})))


(class Gomoku-Application extends Application


  (method (new-toplevel)
    (new Gomoku-Toplevel))
  
  
  (method (finish-process rest)
    (nextmethod rest)
    (maximize~ (get-stage))
    (new-frame Gomoku-Board)))


(register-app 'gomoku
  (lambda ()
    (boot-environment~ (new Gomoku-Application) '())))


;;;
;;;; I/O
;;;


@wait
(definition saved-board
  '())


@wait
(definition (load-board game)
  (initialize-game game HUMAN)
  (loop (for tokens in saved-board)
        (for col from 0 below (get-board-columns~ game))
        (loop (for token in tokens)
              (for row from (- (get-board-rows~ game) 1) downto 0)
              (let ((sqr (square row col)))
                (set-token~ sqr
                  (case token
                    ((X) HUMAN)
                    ((O) COMPUTER)))))
        (let ((move (- (get-board-rows~ game) (length tokens) 1)))
          (set-column-move col (if (>= move 0) (square move col) #f))))
  (invalidate-view~ game))


;;;
;;;; Debug
;;;


@wait
(definition (inspect-board)
  (loop (for row from 0 below (get-board-rows~ game))
        (loop (for col from 0 below (get-board-columns~ game))
              (let ((token (get-token~ (square row col))))
                (display (cond ((eq? token EMPTY) ".")
                               ((eq? token HUMAN) "X")
                               ((eq? token COMPUTER) "O")))
                (display " ")))
        (newline))))
