;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Puissance 4
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Joel Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.tutorials.p4.P4-Board jazz


(import (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.platform)
        (jazz.platform.literals)
        (jazz.system)
        (jazz.system.application)
        (jazz.tutorials.p4)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities)
        (time))


;;;
;;;; Board
;;;


(class P4-Board extends View
  
  
  (slot game)
    
  
  (method meta (host-icon)
    {Bitmap-Resource "MsgUser"})
  
  
  (method meta (host-title)
    "P4")
  
  
  (method meta (host-position)
    {Point 90 70})
  
  
  (method meta (host-size)
    {Dimension 884 624})
  
  
  (method (focus-default)
    (acquire-focus~ self))
  
  
  (method (finish rest)
    (nextmethod rest)
    (set! game (new P4 HUMAN @w (or who-starts HUMAN)))
    (initialize-board game HUMAN))
  
  
  (method (destroy)
    (close-ambiance)
    (nextmethod))
  
  
  (method (initialize-board game who)
    (cond ((eq? who HUMAN)
           (invalidate-view))
          ((eq? who COMPUTER)
           (let ((move (computer-move~ game)))
             (play-at~ game COMPUTER move)))))
  
  
  (method (draw surface context update lh lv)
    (let ((bounds (get-bounds)))
      (fill-rect~ surface bounds {Color name: Dark-Blue}))
    (set-text-color~ surface {Color name: Yellow})
    (set-font~ surface {Font name: Heading0})
    (draw-text~ surface 100 30 "Bienvenue sur puissance 4")
    (when (get-current-status~ game)
      (loop (for row from 0 below (get-board-rows~ game))
            (loop (for col from 0 below (get-board-columns~ game))
                  (let ((token (get-token~ (square~ game row col)))
                        (rect (new Rect (+ 100 (* col 70)) (+ 100 (* row 70)) (+ 100 (* col 70) 50) (+ 100 (* row 70) 50))))
                    (cond ((eq? token EMPTY)
                           (ellipse~ surface rect {Color name: Dark-Blue} {Color name: White}))
                          ((eq? token HUMAN)
                           (ellipse~ surface rect {Color name: Red} {Color name: Red}))
                          (else
                           (ellipse~ surface rect {Color name: Green} {Color name: Green}))))))
      (when (get-last-v~ game)
        (let ((col (get-col~ (get-last-move~ game))))
          (let ((rect (new Rect (+ 100 (* col 70)) (get-last-v~ game) (+ 100 (* col 70) 50) (+ (get-last-v~ game) 50))))
            (cond ((eq? (get-current-next~ game) HUMAN)
                   (ellipse~ surface rect {Color name: Red} {Color name: Red}))
                  (else
                   (ellipse~ surface rect {Color name: Green} {Color name: Green}))))))
      (cond ((eq? (get-current-status~ game) HUMAN)
             (victory surface "Humain" {Color name: Red}))
            ((eq? (get-current-status~ game) COMPUTER)
             (victory surface "Ordinateur" {Color name: Green})))
      (set-text-color~ surface {Color name: Ochre})
      (set-font~ surface {Font name: Heading2})
      (draw-text~ surface 650 100 (format "depth: {a}" (get-search-depth~ game)))
      (when (and (get-display-evaluations?~ game) (get-last-eval~ game))
        (draw-text~ surface 650 150 (format "count: {a}" (get-last-evaluations-count~ game)))
        (draw-text~ surface 650 175 (format "in: {a}s" (get-last-time~ game)))
        (set-font~ surface (new Font font-name: "Arial" point-size: 12))
        (let ((c 0)
              (v 225))
          (for-each (lambda (eval)
                      (set-text-color~ surface (if (= c (get-col~ (get-last-move~ game))) {Color name: Dark-Green} {Color name: Ochre}))
                      (draw-text~ surface 650 v (format "{a}" eval))
                      (increase! c)
                      (increase! v 24))
                    (get-last-evaluations~ game))))))
  
  
  (method (victory surface who color)
    (set-text-color~ surface color)
    (set-font~ surface {Font name: Heading0})
    (draw-text~ surface 100 525 (format "Victoire de l'{a}!!!" who)))
  
  
  (method (play-move move place?)
    (play-at~ game (get-current-next~ game) move)
    (when (and (eq? (get-current-status~ game) 'play) (not place?))
      (let ((move (computer-move~ game)))
        (play-at~ game (get-current-next~ game) move))))
  
  
  (method (cursor-update pos)
    (let ((col (legal-column pos)))
      (set-cursor (if col :finger :arrow))))
  
  
  (method (mouse-down pos)
    (let ((col (legal-column pos)))
      (when col
        (let ((place? (control-down?)))
          (play-move col place?)))))
  
  
  (method (legal-column pos)
    (if (eq? (get-current-status~ game) 'play)
        (let ((h (get-h~ pos))
              (v (get-v~ pos)))
          (if (and (>= h 100)
                   (< h (+ 100 (* (get-board-columns~ game) 70) -20))
                   (>= v 100)
                   (< v (+ 100 (* (get-board-rows~ game) 70) -20)))
              (let ((col (truncate (/ (- h 90) 70))))
                (if (and (>= col 0)
                         (< col (get-board-columns~ game)))
                    col
                  #f))
            #f))
      #f))
  
  
  @wait
  (method (restart-game who)
    (initialize-game self who))
  
  
  (method (toggle-evaluations)
    (set-display-evaluations?~ game (not (get-display-evaluations?~ game)))
    (invalidate-view))
  
  
  (method (set-search-depth depth)
    (set-search-depth~ game depth)
    (when (get-last-move~ game)
      (let ((who (* (get-current-next~ game) -1)))
        (let ((delta (evaluate-move-delta~ game (get-last-move~ game) who)))
          (set-token~ (get-last-move~ game) EMPTY)
          (set-column-move~ game (get-col~ (get-last-move~ game)) (get-last-move~ game))
          (set-current-eval~ game (- (get-current-eval~ game) delta))
          (computer-move~ game)
          (set-column-move~ game (get-col~ (get-last-move~ game)) (get-up~ (get-last-move~ game)))
          (set-token~ (get-last-move~ game) who)
          (set-current-eval~ game (+ (get-current-eval~ game) delta)))))
    (invalidate-view))
  
  
  (method (play-computer)
    (when (eq? (get-current-status~ game) 'play)
      (let ((move (computer-move~ game)))
        (play-at~ game (get-current-next~ game) move))))
  
  
  (method (key-press c)
    (case c
      @wait
      ((#\p) (restart-game (or (get-who-starts~ game) HUMAN)))
      @wait
      ((#\h) (restart-game HUMAN))
      @wait
      ((#\c) (restart-game COMPUTER))
      ((#\e) (toggle-evaluations))
      @wait
      ((#\l) (load-board self))
      ((#\q) (exit))
      ((#\1) (set-search-depth 1))
      ((#\2) (set-search-depth 2))
      ((#\3) (set-search-depth 3))
      ((#\4) (set-search-depth 4))
      ((#\5) (set-search-depth 5))
      ((#\6) (set-search-depth 6))
      ((#\7) (set-search-depth 7))
      ((#\8) (set-search-depth 8))
      ((#\9) (set-search-depth 9))
      @wait
      ((#\space) (play-computer)))))


;;;
;;;; Media
;;;


(definition play-intro?
  #t)

(definition play-ambiance?
  #t)


(definition intro-directory
  {Directory Home "jazz" "app" "p4" "media" "intro"})

(definition ambiance-directory
  {Directory Home "jazz" "app" "p4" "media" "ambiance"})

(definition victory-directory
  {Directory Home "jazz" "app" "p4" "media" "victory"})

(definition defeat-directory
  {Directory Home "jazz" "app" "p4" "media" "defeat"})


(definition (play-intro)
  (when play-intro?
    (let ((sound (random-file intro-directory "wav")))
      (when sound
        (play-sound sound asynchronous?: #f)))))


(definition (play-ambiance)
  (when play-ambiance?
    (let ((music (random-file ambiance-directory "mp3")))
      (when music
        (open-music music "ambiance")
        (play-music "ambiance")))))

(definition (close-ambiance)
  (close-music "ambiance"))


(definition (play-victory)
  (let ((sound (random-file victory-directory "wav")))
    (when sound
      (play-sound sound))))

(definition (play-defeat)
  (let ((sound (random-file defeat-directory "wav")))
    (when sound
      (play-sound sound))))


(definition (random-file directory extension)
  (if (exists?~ directory)
      (let ((files
              (collect-files~ directory
                (lambda (file)
                  (ci=? (get-extension~ file) extension)))))
        (if (not-null? files)
            (random-element files)
          #f))
    #f))


;;;
;;;; Debug
;;;


(definition (inspect-board game)
  (loop (for row from 0 below (get-board-rows~ game))
        (loop (for col from 0 below (get-board-columns~ game))
              (let ((token (get-token~ (square~ game row col))))
                (display (cond ((eq? token EMPTY) ".")
                               ((eq? token HUMAN) "X")
                               ((eq? token COMPUTER) "O")))
                (display " ")))
        (newline))))
