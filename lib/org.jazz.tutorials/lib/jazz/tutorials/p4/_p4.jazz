;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Puissance 4
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Joel Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.tutorials.p4 jazz


(import (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.media)
        (jazz.platform)
        (jazz.platform.literals)
        (jazz.system)
        (jazz.system.application)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities)
        (time))


(definition EMPTY <fx>
  0)

(definition COMPUTER <fx>
  1)

(definition HUMAN <fx>
  -1)


;;;
;;;; Square
;;;


(class Square extends Object
  
  
  (slot row   <fx>      getter generate)
  (slot col   <fx>      getter generate)
  (slot token <fx>      accessors generate)
  (slot up    <Square+> accessors generate)
  (slot down  <Square+> accessors generate)
  (slot lines <list>    accessors generate)
  
  
  (method (initialize row col)
    (nextmethod)
    (set! row~self row)
    (set! col~self col)
    (set! token~self EMPTY))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function (printer)
        (format printer "{a} {a} {a}" row col token)))))


;;;
;;;; Line
;;;


(class Line extends Object
  
  
  (slot first  <Square> getter generate)
  (slot second <Square> getter generate)
  (slot third  <Square> getter generate)
  (slot fourth <Square> getter generate)
  
  
  (method (initialize first second third fourth)
    (nextmethod)
    (set! first~self first)
    (set! second~self second)
    (set! third~self third)
    (set! fourth~self fourth)))


;;;
;;;; Game
;;;

hello
(class P4 extends Object
  
  
  (slot board-rows                  initialize #f accessors generate)
  (slot board-columns               initialize #f accessors generate)
  (slot board-size                  initialize #f accessors generate)
  (slot board                       initialize #f accessors generate)
  (slot board-moves                 initialize #f accessors generate)
  (slot board-lines                 initialize #f accessors generate)
  
  (slot who-starts                  initialize #f accessors generate)
  (slot current-status              initialize #f accessors generate)
  (slot current-next                initialize #f accessors generate)
  (slot current-eval                initialize #f accessors generate)
  (slot moves                       initialize #f accessors generate)
  
  (slot display-evaluations?        initialize #f accessors generate)
  (slot last-eval                   initialize #f accessors generate)
  (slot last-evaluations            initialize #f accessors generate)
  (slot last-evaluations-count <fx> initialize 0  accessors generate)
  (slot last-time                   initialize #f accessors generate)
  (slot last-move                   initialize #f accessors generate)
  (slot last-v                      initialize #f accessors generate)
    
  (slot search-depth <fx>           initialize 4  accessors generate)

  
  (method (initialize who . rest)
    (bind-keywords ((rows 6) (columns 7)) rest
      (nextmethod)
      (set! board-rows rows)
      (set! board-columns columns)
      (set! board-size (* board-rows board-columns))
      (set! board (make-board))
      (set! board-moves (make-moves))
      (set! who-starts who)
      (set! current-status 'play)
      (set! current-next who)
      (set! current-eval 0)
      (set! moves '())
      (set! last-eval #f)
      (set! last-evaluations #f)
      (set! last-move #f)
      (setup-squares)
      (setup-lines)
      @move-to-board
      (close-ambiance)
      @move-to-board
      (play-intro)
      @move-to-board
      (play-ambiance)
      @move-to-board
      (cond ((eq? who HUMAN)
             (invalidate-view~ game))
            ((eq? who COMPUTER)
             (let ((move (computer-move)))
               (play-at game COMPUTER move))))))
  
  
  (method (make-board)
    (let ((board (make-vector board-size #f)))
      (loop (for row from 0 below board-rows)
            (loop (for col from 0 below board-columns)
                  (let ((rank (square-rank row col)))
                    (vector-set! board rank (new Square row col)))))
      board))
  
  
  (method (make-moves)
    (let ((moves (make-vector board-columns #f))
          (bottom-row (- board-rows 1)))
      (loop (for col from 0 below board-columns)
            (vector-set! moves col (square bottom-row col)))
      moves))
  
  
  (method (setup-squares)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (let ((sqr (square row col)))
                  (set-up~ sqr (legal-square (- row 1) col))
                  (set-down~ sqr (legal-square (+ row 1) col))))))
  
  
  ;;;
  ;;;; Board
  ;;;
  
  
  (method public (iterate-board proc)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (do (proc (square row col))))))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method inline (column-move col) <Square>
    (vector-ref board-moves col))
  
  (method inline (set-column-move col sqr)
    (vector-set! board-moves col sqr))
  
  
  (method inline (board-ref rank) <Square>
    (vector-ref board rank))
  
  
  (method inline (square-rank row col) <fx>
    (+ (* row board-columns) col))
  
  
  (method inline (square row col) <Square>
    (board-ref (square-rank row col)))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (definition fall-speed
    25)
  
  
  (method (play-at @bad game who col)
    (let ((sqr (column-move col))
          (move current-next))
      (set! last-move sqr)
      @move-to-board
      (last-move-animation game)
      (set-token~ sqr move)
      (set-column-move col (get-up~ sqr))
      (set! current-next (* current-next -1))
      (set! current-eval (+ current-eval (evaluate-move-delta sqr who)))
      (check-victory who sqr)
      @w
      (invalidate-view~ game)))
  
  
  @move-to-board
  (method (last-move-animation game)
    (let ((end-v (+ 100 (* (get-row~ last-move) 70))))
      (set! last-v 60)
      (let (loop)
        (when (< last-v end-v)
          (redraw-view~ game)
          (increase! last-v fall-speed)
          (loop)))
      (set! last-v end-v)
      (redraw-view~ game)
      (set! last-v #f)))
  
  
  (method (check-victory who sqr)
    (define (victory?)
      (some? line? (get-lines~ sqr)))
    
    (define (line? line)
      (= (count-tokens who line) 4))
    
    (when (victory?)
      (set! current-status who)
      @move-to-board
      (cond ((eq? who HUMAN) (play-victory))
            ((eq? who COMPUTER) (play-defeat)))))
  
  
  ;;;
  ;;;; Computer
  ;;;
  
  
  (proclaim (optimize))
  
  
  (method (computer-move)
    (let ((before (time->seconds (current-time))))
      (let ((move (best-move COMPUTER 1)))
        (let ((after (time->seconds (current-time))))
          (set! last-time (- after before)))
        move)))
  
  
  (method (best-move who depth)
    (set! last-evaluations-count 0)
    (let ((best '())
          (best-eval #f)
          (best-test (if (= who COMPUTER) > <))
          (evals '()))
      (loop (for col from 0 below board-columns)
            (let ((sqr (column-move col)))
              (let ((eval (and sqr (evaluate-move col sqr who current-eval depth))))
                (set! evals (cons eval evals))
                (when eval
                  (cond ;; as good
                    ((and best-eval (= eval best-eval))
                     (set! best (cons col best)))
                    ;; better
                    ((or (not best-eval) (best-test eval best-eval))
                     (set! best (list col))
                     (set! best-eval eval)))))))
      (set! last-eval best-eval)
      (set! last-evaluations (reverse evals))
      (random-element best)))
  
  
  (method (evaluate-move col <fx> sqr <Square> who <fx> eval <fx> depth <fx>) <fx>
    (set-token~ sqr who)
    (set-column-move col (get-up~ sqr))
    (increase! last-evaluations-count)
    (let ((delta (evaluate-move-delta sqr who)))
      (let ((new-eval (+ eval delta)))
        @sanity-check
        (if (/= new-eval (evaluate-board))
            (error "Invalid incremental eval: new={a}, board={a}" new-eval board-eval))
        (let ((best-eval
                (if (> (* new-eval who) 900000)
                    new-eval
                  (evaluate who new-eval depth))))
          (set-column-move col sqr)
          (set-token~ sqr EMPTY)
          best-eval))))
  
  
  (method (evaluate who <fx> eval <fx> depth <fx>) <fx>
    (if (= depth search-depth)
        eval
      (evaluate-best who eval depth)))
  
  
  (method (evaluate-best who <fx> eval <fx> depth <fx>) <fx>
    (let ((best-eval 10000000))
      (loop (for col from 0 below board-columns)
            (let ((sqr (column-move col)))
              (when sqr
                (let ((eval (evaluate-move col sqr (* who -1) eval (+ depth 1))))
                  (when eval
                    (let ((normalized-eval (* (cast <fx> eval) who)))
                      (when (< normalized-eval best-eval)
                        (set! best-eval normalized-eval))))))))
      (* best-eval who)))
  
  
  (method (evaluate-board) <fx>
    (let ((total 0))
      (loop (for line in board-lines)
            (increase! total (evaluate-line line)))
      total))
  
  
  (method (evaluate-line line <Line>) <fx>
    (let ((computer-count (count-tokens COMPUTER line))
          (human-count (count-tokens HUMAN line)))
      (if (and (> computer-count 0)
               (> human-count 0))
          0
        (+ (evaluate-count computer-count COMPUTER)
           (evaluate-count human-count HUMAN)))))
  
  
  (method (evaluate-count count <fx> who <fx>) <fx>
    (* (cast <fx> (case count
                    ((4) 1000000)
                    ((3) 1000)
                    ((2) 100)
                    ((1) 10)
                    ((0) 0)))
       who))
  
  
  (method (evaluate-move-delta sqr <Square> who <fx>) <fx>
    (let ((total 0))
      (loop (for line in (get-lines~ sqr))
            (let ((who-count (count-tokens who line))
                  (other-count (count-tokens (* who -1) line)))
              (let ((delta <fx>
                      (cond ((and (> who-count 1) (> other-count 0))
                             0)
                            ((= other-count 0)
                             (evaluate-line-delta who-count who))
                            (else
                             (evaluate-count other-count who)))))
                (set! total (+ total delta)))))
      total))
  
  
  (method (evaluate-line-delta count <fx> who <fx>) <fx>
    (* (cast <fx> (case count
                    ((4) 999000)
                    ((3) 900)
                    ((2) 90)
                    ((1) 10)))
       who))
  
  
  (method (count-tokens who <fx> line <Line>) <fx>
    (+ (if (= (get-token~ (get-first~  line)) who) 1 0)
       (if (= (get-token~ (get-second~ line)) who) 1 0)
       (if (= (get-token~ (get-third~  line)) who) 1 0)
       (if (= (get-token~ (get-fourth~ line)) who) 1 0)))
  
  
  (proclaim (not optimize))
  
  
  ;;;
  ;;;; Lines
  ;;;
  
  
  (definition directions
    '((0 . 1)
      (1 . 1)
      (1 . 0)
      (1 . -1)))
  
  
  (method (line=? l1 l2)
    (and (eq? (get-first~ l1) (get-first~ l2))
         (eq? (get-second~ l1) (get-second~ l2))
         (eq? (get-third~ l1) (get-third~ l2))
         (eq? (get-fourth~ l1) (get-fourth~ l2))))
  
  
  (method (setup-lines)
    (set! board-lines '())
    (loop (for rank from 0 below board-size)
          (let ((sqr (board-ref rank)))
            (let ((square-lines (compute-square-lines sqr)))
              (set-lines~ sqr square-lines)
              (for-each (lambda (line)
                          (when (not (member? line board-lines test: line=?))
                            (set! board-lines (cons line board-lines))))
                        square-lines)))))
  
  
  (method (compute-square-lines sqr)
    (let ((row (get-row~ sqr))
          (col (get-col~ sqr))
          (lines '()))
      (loop (for dir in directions)
            (loop (for n from -3 to 0)
                  (let ((a (find-next dir row col (+ n 0)))
                        (b (find-next dir row col (+ n 1)))
                        (c (find-next dir row col (+ n 2)))
                        (d (find-next dir row col (+ n 3))))
                    (if (and a b c d)
                        (set! lines (cons (new Line a b c d) lines))))))
      lines))
  
  
  (method (find-next dir row col n)
    (legal-square (+ row (* n (car dir)))
                  (+ col (* n (cdr dir)))))
  
  
  (method (legal-square row col)
    (if (and (>= row 0) (< row board-rows)
          (>= col 0) (< col board-columns))
        (square row col)
      #f)))


;;;
;;;; I/O
;;;


@wait
(definition saved-board
  '((O O X)
    (O X O O)
    (O X O X X)
    (X O X O X X)
    ()
    (X X O)
    (O)))


@wait
(definition (load-board game)
  (initialize-game game HUMAN)
  (loop (for tokens in saved-board)
        (for col from 0 below board-columns)
        (loop (for token in tokens)
              (for row from (- board-rows 1) downto 0)
              (let ((sqr (square row col)))
                (set-token~ sqr
                  (case token
                    ((X) HUMAN)
                    ((O) COMPUTER)))))
        (let ((move (- board-rows (length tokens) 1)))
          (set-column-move col (if (>= move 0) (square move col) #f))))
  (invalidate-view~ game))


;;;
;;;; Debug
;;;


@wait
(definition (inspect-board)
  (loop (for row from 0 below board-rows)
        (loop (for col from 0 below board-columns)
              (let ((token (get-token~ (square row col))))
                (display (cond ((eq? token EMPTY) ".")
                               ((eq? token HUMAN) "X")
                               ((eq? token COMPUTER) "O")))
                (display " ")))
        (newline))))
