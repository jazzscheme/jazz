;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Puissance 4
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Joel Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.tutorials.p4 jazz


(import (jazz.io)
        (jazz.tutorials.game))


(definition EMPTY <fx>
  0)

(definition GREEN <fx>
  -1)

(definition RED <fx>
  1)


;;;
;;;; Square
;;;


(class Square extends Object
  
  
  (slot row   <fx>      getter generate)
  (slot col   <fx>      getter generate)
  (slot token <fx>      accessors generate)
  (slot up    <Square+> accessors generate)
  (slot down  <Square+> accessors generate)
  (slot lines <list>    accessors generate)
  
  
  (method (initialize row col)
    (nextmethod)
    (set! row~self row)
    (set! col~self col)
    (set! token~self EMPTY))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function (printer)
        (format printer "{a} {a} {a}" row col token)))))


;;;
;;;; Line
;;;


(class Line extends Object
  
  
  (slot first  <Square> getter generate)
  (slot second <Square> getter generate)
  (slot third  <Square> getter generate)
  (slot fourth <Square> getter generate)
  
  
  (method (initialize first second third fourth)
    (nextmethod)
    (set! first~self first)
    (set! second~self second)
    (set! third~self third)
    (set! fourth~self fourth))
  
  
  (method (count-token token <fx>) <fx>
    (+ (if (= (get-token~ first) token) 1 0)
       (if (= (get-token~ second) token) 1 0)
       (if (= (get-token~ third) token) 1 0)
       (if (= (get-token~ fourth) token) 1 0))))


(definition (line=? l1 l2)
  (and (eq? (get-first~ l1) (get-first~ l2))
       (eq? (get-second~ l1) (get-second~ l2))
       (eq? (get-third~ l1) (get-third~ l2))
       (eq? (get-fourth~ l1) (get-fourth~ l2))))


;;;
;;;; Human
;;;


(class P4-Human extends Human-Player)


;;;
;;;; Computer
;;;


(class P4-Computer extends Computer-Player)


;;;
;;;; Game
;;;


(class P4-Game extends Game
  
  
  ;; board
  (slot board-rows       initialize #f accessors generate)
  (slot board-columns    initialize #f accessors generate)
  (slot board-size       initialize #f accessors generate)
  (slot board            initialize #f accessors generate)
  
  ;; play
  (slot next-token       initialize #f accessors generate)
  (slot available-moves  initialize #f accessors generate)

  
  (method (initialize . rest)
    (bind-keywords ((rows 6) (columns 7)) rest
      (nextmethod)
      (set! board-rows rows)
      (set! board-columns columns)
      (set! board-size (* board-rows board-columns))
      (set! board (make-board))
      (set! next-token GREEN)
      (set! available-moves (make-availables))
      (setup-squares)
      (setup-lines)))
  
  
  (method (make-board)
    (let ((board (make-vector board-size #f)))
      (loop (for row from 0 below board-rows)
            (loop (for col from 0 below board-columns)
                  (let ((rank (square-rank row col)))
                    (vector-set! board rank (new Square row col)))))
      board))
  
  
  (method (make-availables)
    (let ((moves (make-vector board-columns #f))
          (bottom-row (- board-rows 1)))
      (loop (for col from 0 below board-columns)
            (vector-set! moves col (get-square bottom-row col)))
      moves))
  
  
  (method (setup-squares)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (let ((square (get-square row col)))
                  (set-up~ square (find-square (- row 1) col))
                  (set-down~ square (find-square (+ row 1) col))))))
  
  
  ;;;
  ;;;; Lines
  ;;;
  
  
  (definition directions
    '((0 . 1)
      (1 . 1)
      (1 . 0)
      (1 . -1)))
  
  
  (method (setup-lines)
    (loop (for rank from 0 below board-size)
          (let ((square (board-ref rank)))
            (set-lines~ square (compute-lines square)))))
  
  
  (method (compute-lines square)
    (let ((row (get-row~ square))
          (col (get-col~ square))
          (lines '()))
      (loop (for dir in directions)
            (loop (for n from -3 to 0)
                  (let ((a (find-next dir row col (+ n 0)))
                        (b (find-next dir row col (+ n 1)))
                        (c (find-next dir row col (+ n 2)))
                        (d (find-next dir row col (+ n 3))))
                    (if (and a b c d)
                        (set! lines (cons (new Line a b c d) lines))))))
      lines))
  
  
  (method (find-next dir row col n)
    (find-square
      (+ row (* n (car dir)))
      (+ col (* n (cdr dir)))))
  
  
  ;;;
  ;;;; Board
  ;;;
  
  
  (method public (iterate-board proc)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (do (proc (get-square row col))))))
  
  
  (method inline (board-ref rank) <Square>
    (vector-ref board rank))
  
  
  (method inline (square-rank row col) <fx>
    (+ (* row board-columns) col))
  
  
  (method inline (get-square row col) <Square>
    (board-ref (square-rank row col)))
  
  
  (method (find-square row col) <Square+>
    (if (and (>= row 0) (< row board-rows)
             (>= col 0) (< col board-columns))
        (get-square row col)
      #f))
  
  
  ;;;
  ;;;; Move
  ;;;
  
  
  (method inline (available-move col) <Square>
    (vector-ref available-moves col))
  
  
  (method inline (set-available-move col square) <void>
    (vector-set! available-moves col square))
  
  
  (method (play move token)
    (let ((square (available-move move)))
      (set-token~ square token)
      (set-available-move move (get-up~ square))
      square))
  
  
  (method (unplay move square)
    (set-available-move move square)
    (set-token~ square EMPTY))
  
  
  (method (next-token!)
    (set! next-token (* next-token -1)))
  
  
  ;;;
  ;;;; Play
  ;;;
  
  
  (method (play-move move)
    (let ((player (next-player!))
          (token next-token))
      (let ((square (play move token)))
        (add-move move)
        (next-token!)
        (inform-players move square token)
        (check-status square player token))))
  
  
  (method (win? square token)
    (define (line? line)
      (= (count-token~ line token) 4))
    
    (some? line? (get-lines~ square)))
  
  
  (method (draw? square token)
    (not (loop (for col from 0 below board-columns)
               (some (available-move col)))))
  
  
  ;;;
  ;;;; I/O
  ;;;
  
  
  @wait
  (method (load-board game)
    (initialize-game game HUMAN)
    (loop (for tokens in saved-board)
          (for col from 0 below board-columns)
          (loop (for token in tokens)
                (for row from (- board-rows 1) downto 0)
                (let ((square (get-square row col)))
                  (set-token~ square
                    (case token
                      ((X) HUMAN)
                      ((O) COMPUTER)))))
          (let ((move (- board-rows (length tokens) 1)))
            (set-available-move col (if (>= move 0) (get-square move col) #f))))
    (invalidate-view~ game))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  @wait
  (method (inspect-board)
    (loop (for row from 0 below board-rows)
          (loop (for col from 0 below board-columns)
                (let ((token (get-token~ (get-square row col))))
                  (display (cond ((eq? token EMPTY) ".")
                                 ((eq? token HUMAN) "X")
                                 ((eq? token COMPUTER) "O")))
                  (display " ")))
          (newline)))))
