;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; org.jazz Documentation
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(<Product-Doc> name: org.jazz title: "Jazz"
  (<Section-Doc> name: overview title: "Overview"
    (<description>
      (<p> "A language that doesn't affect the way you think about programming, is not worth knowing.")
      (<p> "--Alan J. Perlis")
      (<p>)
      (<p> "Jazz was born on December 9 1996."))
    (<Concept-Doc> name: lexical title: "Lexical Syntax"
      (<description>
        (<definition> name: identifiers title: "Identifiers"
          (<p> "Identifiers in Jazz are case sensitive. A common usage of this is to have a class named X and a variable containing an instance of X named x.")
          (<p>)
          (<p> "The following characters are considered alphabetic and can thus be used in identifiers:")
          (<p> "! $ % & * + - . / : < = > ? ^ _ ~"))
        (<p>)
        (<p>)
        (<definition> name: whitespace title: "Whitespace"
          (<p> "Spaces, tabs, carriage returns and line feeds are considered whitespace and can be freely inserted in Jazz code without changing the meaning of the code."))
        (<p>)
        (<p>)
        (<definition> name: comments title: "Comments"
          (<p> "Jazz offers two types of comments:")
          (<node>
            (<span> "; starts a line based comment and")
            (<span> "@name starts an sexpr based comment where name can be any symbol. "
              "It is completely ignored and can be used for documentation purposes.")))))
    (<Concept-Doc> name: syntax title: "Language Syntax"
      (<description>
        (<definition> title: "Variable value"
          (<p> (<code> "x")))
        (<p>)
        (<definition> title: "Function invocation"
          (<p> (<code> "(f x y)")))
        (<p>)
        (<definition> title: "Field access"
          (<p> (<code> "[name obj]")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> " [h my-point]")
          (<code> " [h size my-view]"))
        (<p>)
        (<definition> title: "Method invocation"
          (<p> (<xmp> "(f~ obj x y)")))
        (<p>)
        (<p> "Examples:")
        (<node>
          (<code> "(get-size~ window)")
          (<code> "(invalidate-view~ (get-parent~ view))")))
      (<Section-Doc> title: "Constants"
        (<description>
          (<definition> name: numeric_constants title: "Numeric"
            (<p> "Numeric constants can be integer or real values.")
            (<p> "Examples:")
            (<node>
              (<code> "2")
              (<code> "-5")
              (<code> "6.75")))
          (<definition> name: string_constants title: "String"
            (<p> "String constants can be delimited by either \" or #\" \"# where the second form is usefull to enclose large text without having to escape special characters.")
            (<p> "Examples:")
            (<node>
              (<code> "\"Hello World!\"")
              (<code> "#\"This is a more complex string containing special characters like # \\ \" without escaping\"#")))
          (<definition> name: symbol_constants title: "Symbol"
            (<p> "Examples:")
            (<node>
              (<code> "'x")
              (<code> "(quote y)"))
            (<p> "Note that the quote is necessary to distinguish from taking a variable's value"))
          (<definition> name: list_constants title: "List"
            (<p> "Examples:")
            (<node>
              (<code> "'(a b c)")
              (<code> "(quote (1 2))"))
            (<p> "Note that the quote is necessary to distinguish from invoking as a function call"))
          (<definition> name: user_constants title: "User" title: "User defined"
            (<p> "Jazz supports a very powerfull concept where any class can define it's own literal constants using the following syntax: {class-name ...}. "
              "This integrates classes fully with the Jazz reader and printer.")
            (<p> "Examples:")
            (<node>
              (<code> "{Point 2 3}")
              (<code> "{Dimension 100 100}")
              (<code> "{Color name: Red}")
              (<code> "{Font name: Code}"))))))
    (<Concept-Doc> name: toplevel_forms title: "Toplevel Forms"
      (<Form-Doc> name: in parameters: "package"
        (<description>
          (<p> "The following toplevel unit will become part of " (<parameter> "package") ". "
            "Note that the package concept is only partialy implemented in Jazz. Fusion will support full fledged hierarchical namespaces.")))
      (<Form-Doc> name: using parameters: "package ..."
        (<description>
          (<p> "Using " (<parameter> "package") " enables the defined unit to use a lighter syntax when referencing fields defined in " (<parameter> "package") " :")
          (<p> "The compiler will automatically replace " (<code> "(f a b)") " with " (<code> "(f~ package a b)") " when " (<code> "f") " is a field of " (<parameter> "package") ". "
            "When multiple using directives are present, packages are searched in the appearance order in the file.")))
      (<Form-Doc> name: class parameters: "extends implements uses ..."
        (<description>
          (<p> "Jazz uses a single inheritance model where a class can extend only one superclass. "
            "A class can implement any number of interfaces.")
          (<p>)
          (<p> "Jazz also supports inner classes. "
            "Inner classes can refer directly to outer class fields. "
            "This is done by having an invisible slot that point to the outer class and transforming automatically an outer call (f x) into (f~ outer x). "
            "This implies that for the system to remember this information, inner class creation must always be done inside an instance of its outer class.")))
      (<Form-Doc> name: interface parameters: "extends uses ..."
        (<description>
          (<p> "An interface defines a new type but cannot contain code.")))
      (<Form-Doc> name: package  parameters: "extends uses ..."
        (<description>
          (<p> "Inside a package, all definitions are automatically meta. "
            "This implements a sort of dynamic namespace concept as no package instances are ever created and all package access is done through the package itself.")))
      (<Form-Doc> name: constant parameters: "name value"
        (<description>
          (<p> "A definition that cannot be modified. Note that currently, a constant definition is simply a definition.")
          (<p>)
          (<p> "Constant definitions are currently used mainly to access the Windows API.")))
      (<Form-Doc> name: enumeration parameters: "enumeration-name (name1 value1) (name2 value2) ..."
        (<description>
          (<p> "An enumeration definition. "
            "This enumeration will create a definition enumeration-name containing an Enumeration object that can be queried at runtime and create constant definitions name1 : value1, name2 : value2, ...")
          (<p>)
          (<p> "Enumeration definitions are currently used mainly to access the Windows API.")))
      (<Form-Doc> name: structure parameters: "structure-name (type1 field1 <n1>) (type2 field2 <n2>) ..."
        (<description>
          (<p> "A structure is a template that can be used to create records containing primitive types. Here, type is any primitive type and field is a symbol that can be used to access this field is records of type structure-name. If the optional n is specified, then an array of n elements of type will be inserted.")
          (<p>)
          (<p> "Structure definitions are currently used mainly to access the Windows API.")))
      (<Form-Doc> name: intrinsic parameters: "intrinsic module-name return-type (name param1 param2 ...) <entry-name> <intrinsic-name>"
        (<description>
          (<p> "An intrinsic is basically an external that will be treated specially by the compiler. "
            "The compiler instead of generation a 'safe' call to entry-name will inline a call to intrinsic-name.")))
      (<Form-Doc> name: external parameters: "module-name return-type (name param1 param2 ...) <entry-name>"
        (<description>
          (<p> "An external entry point into a Windows module, i.e. a dynamic-link library or an executable.")
          (<p>)
          (<p> "External definitions are currently used mainly to access the Jazz runtime and the Windows API.")))
      (<Form-Doc> name: coexternal parameters: "coexternal {modifiers} return-type (name . parameters)"
        (<description>
          (<p> "An entry point into a COM class. Note that coexternal definitions do not have entry-names. Their entry position into the COM class is determined by their rank in the class.")
          (<p>)
          (<p> "(external void (f out x)) -> (values x) (external long (f)) -> result (external long (f out x)) -> (values result x) Because coexternals almost always return an hresult, it is very common to have only one out parameter which is really the function result. So Jazz treats coexternals a bit differently from externals... (coexternal void (f out x)) -> x (coexternal hresult (f out x)) -> x or throw a CoError (coexternal long (f out x)) -> (values result x) (coexternal long (f)) -> result (coexternal void (f out x out y)) -> (values x y) ")))
      (<Form-Doc> name: definition parameters: "name value"
        (<description>
          (<p> "A definition associates name to value inside the defining unit. A definition is as field and as such is stored in the class and doesn't take any space in instances. At class instantiation, value is evaluated in an empty lexical environment and in an empty object environment.")))
      (<Form-Doc> name: method parameters: "{modifiers} (name . parameters) {return-type} . body"
        (<description>
          (<p> "A method is where code resides.")))
      (<Form-Doc> name: comethod parameters: "return-type (name . parameters)"
        (<description>
          (<p> "A comethod is used to create an COM entry point into a Jazz defined COM class.")))
      (<Form-Doc> name: slot parameters: "name <initialize> <initial-value>"
        (<description>
          (<p> "A slot is a field that defines the structure of the instances of a class.")))
      (<Form-Doc> name: property parameters: "name <initialize> <initial-value> <getter> <getter-name> <setter> <setter-name>"
        (<description>
          (<p> "A property is a slot that can specify a getter and a setter.")))
      (<Form-Doc> name: properties parameters: "key1 value1 key2 value2 ..."
        (<description>
          (<p> "Enables associating a property list to any unit. Unit properties are currently used to specify COM interfaces GUID."))))
    (<Concept-Doc> name: reference_desambiguation title: "Reference Desambiguation"
      (<description>
        (<p> "References inside units are resolved in the following order: ")
        (<node>
          (<span> "syntax")
          (<span> "local variable")
          (<span> "unit definition")
          (<span> "metaclass definition")
          (<span> "outer definition")
          (<span> "imported definition")
          (<span> "global definition"))
        (<p>)
        (<p> "Note that outside references [x f] are only allowed to access public unit definitions (and not metaclass, outer or imported definitions) for scope security reasons.")))
    (<Concept-Doc> name: naming title: "Naming Conventions"
      (<description>
        (<definition> name: naming_comments title: "Comments"
          (<node>
            (<span> "; Code comment : put at the end of a line of code to document it.")
            (<span> ";; Method comment : documents a method and many lines may be used.")
            (<span> ";;; Section comment : documents a section.")
            (<span> ";;;; Chapter comment : specifies a section title naming and will be gathered in a chapter.")))
        (<p>)
        (<p>)
        (<definition> name: naming_classes title: "Classes"
          (<p> "Class names are capitalized")
          (<node>
            (<span> (<code> "View"))
            (<span> (<code> "Java-Text"))))
        (<p>)
        (<p>)
        (<definition> name: naming_methods title: "Methods"
          (<p> "Methods are in lowercase separated by -")
          (<node>
            (<span> (<code> "get-application"))))
        (<p>)
        (<p>)
        (<definition> name: naming_predicates title: "Predicates"
          (<p> "Predicates end with ?")
          (<node>
            (<span> (<code> "eq?"))
            (<span> (<code> "string?"))))
        (<p>)
        (<p>)
        (<definition> name: naming_mutators title: "Mutators"
          (<p> "Destructive functions end with !")
          (<node>
            (<span> (<code> "set-cdr!"))
            (<span> (<code> "append!"))))
        (<p>)
        (<p>)
        (<definition> name: naming_convertors title: "Convertors"
          (<p> "Type conversion functions have -> in their name")
          (<node>
            (<span> (<code> "symbol->string"))
            (<span> (<code> "symbol->keyword"))))))
    (<Concept-Doc> name: functions title: "Functions"
      (<description>
        (<p> "In Jazz, functions are first order objects and can be freely manipulated as any other objects. "
          "They can be passed as parameters, stored in variables, ..."
          "Anyone who says functions are not object-oriented is just showing they have'nt really went far enough in their understanding of the problem!")
        (<p>)
        (<definition> name: function_parameters title: "Parameters"
          (<p> "On top of the standard positional parameter passing scheme, Jazz offers the following:")
          (<node>
            (<span> "Variable number of parameters")
            (<span> "Optional parameters")
            (<span> "Keyword parameters")))
        (<p>)
        (<p>)
        (<definition> name: function_arguments title: "Arguments"
          (<p> "Arguments are passed by pointer value, i.e. only a copy of the pointer to the argument is passed as opposed to copying the entire content of the object."))))
    (<Concept-Doc> name: lists title: "Lists"
      (<description>
        (<p> "Lists are the most flexible data structure available in Jazz. They can grow to accommodate any number of elements and this very efficiently. As they are sequences, they are supported by a huge number of manipulation functions")))
    (<Concept-Doc> name: symbols title: "Symbols"
      (<description>
        (<p> "Jazz is symbolic language where symbols are used extensively. Symbols can be used as a very efficient higher level abstraction replacement for integer enumerations")))
    (<Concept-Doc> name: objects title: "Objects"
      (<description>
        (<p> "Jazz is a fully object-oriented language that offers :")
        (<node>
          (<span> "Classes with single inheritance and multiple interfaces implemented")
          (<span> "Packages that can be imported into classes")
          (<span> "Inner classes")
          (<span> "Metaclasses"))
        (<p>)
        (<p>)
        (<definition> name: classes title: "Classes")
        (<p>)
        (<p>)
        (<definition> name: interfaces title: "Interfaces")
        (<p>)
        (<p>)
        (<definition> name: packages title: "Packages")
        (<p>)
        (<p>)
        (<definition> name: metaclasses title: "Metaclasses")
        (<p>)
        (<p> (<xmp> "(class X
  (field meta f ...)"))
        (<p> "has exactly the same semantics as")
        (<p>)
        (<p> (<xmp> "(class MX
  (field f ...)"))
        (<p> "where MX is the class of the class X.")
        (<p>)
        (<p> "In Jazz, as a design decision, a class and it metaclass are both defined in the same file. "
          "This simplifies metaclass design and ensures that the following always holds true for every class X :")
        (<p> (<code> "(type-ascendant (class-of X)) = (class-of (type-ascendant X))"))
        (<p>)
        (<p> "i.e. the inheritance hierarchy of metaclasses follows the inheritance hierarchy of regular classes.")
        (<p>)
        (<p>)
        (<definition> title: "Notes"
          (<p> "One difference between a constant and a meta constant, is that to access the first one, you have to be able to create an instance of the class (it is more private than the second one). "
            "Note that the previous comment applies to any definition. ")
          (<p>)
          (<p>)
          (<p> "One big difference between having a meta slot and a meta definition is that every derived class will have its own space allocated for the meta slot, but every meta definition that is not overwritten will be shared. Ex: ")
          (<p>)
          (<p> (<code> "(slot meta public mouse-in initialize {})"))
          (<p>
            "will not work because accessing mouse-in from an instance of "
            (<code> "Window")
            " or from an instance of a "
            (<code> "Text")
            " will not access the same slot space. ")
          (<p> (<code> "(definition meta public mouse-in nil)"))
          (<p> "should be used instead. "))))
    (<Concept-Doc> name: components title: "Components"
      (<description>
        (<p> "One of the biggest strength of components is the full integration of the programming metaphor with the visual design metaphor they enable. "
          "By seamlessly intermixing programming code and designer data, components brings all the power of programming tools to the design part.")))
    (<Concept-Doc> name: modifiers title: "Modifiers"
      (<description>
        (<definition> name: meta
          (<p> "Defines a field of the meta class. Because a class is an object, meta methods can use self to refer to themselves (i.e. the class)."))
        (<p>)
        (<p>)
        (<definition> name: private
          (<p> "Access is restricted to classes that reside in the same file."))
        (<p>)
        (<p>)
        (<definition> name: protected
          (<p> "Access is restricted to sub-classes and classes in the same package."))
        (<p>)
        (<p>)
        (<definition> name: public
          (<p> "Access is unrestricted."))
        (<p>)
        (<p>)
        (<definition> name: final
          (<p> "A final definition cannot be overridden."))
        (<p>)
        (<p>)
        (<definition> name: virtual
          (<p> "A virtual definition can be overridden in sub-classes."))
        (<p>)
        (<p>)
        (<definition> name: chained
          (<p> "A chained method can be overridden in sub-classes and the override must call the overridden method."))
        (<p>)
        (<p>)
        (<definition> name: abstract
          (<p> "A abstract definition must overridden in some sub-class. This modifier is currently unimplemented."))
        (<p>)
        (<p>)
        (<definition> name: inline
          (<p> "An inline method permits the compiler to inline its code."))
        (<p>)
        (<p>)
        (<definition> name: synchronized
          (<p> "A synchronized method is guarantied to always be executing in at most one thread at a time."))
        (<p>)
        (<p>)
        (<definition> name: remote
          (<p> "A remote method can be used remotely (see the JRM package)."))
        (<p>)))
    (<Concept-Doc> name: types title: "Types"
      (<description>
        (<p> "Jazz is a dynamically typed language. Types are associated with objects as opposed to statically typed languages where types are associated with variables. With a dynamically typed language, type information is always available at runtime contrary to statically typed languages where only the compiler has access to type information")
        (<p>)
        (<p> "Types in Jazz are always optional.")
        (<p>)
        (<p> "Jazz classes are objects that can be manipulated like any other. "
          "This enables powerful runtime flexibility that is very difficult to obtain in languages like C++.")
        (<p>)
        (<p> "In Jazz, even compiled code in entirely dynamic. One big consequence is that modifying a source file will never force recompilation of any other file than itself. ")
        (<p>)
        (<p> "Types are denoted by :")
        (<xmp> "<primitive> (ex: <int> <bool>)")
        (<xmp> "<class> (ex: <View> <Window>)")
        (<p> "denote the type of all objects of type class, the null not included")
        (<xmp> "<class+> (ex: <Point+> <Rect+>)")
        (<p> "denote the type of all objects of type class, the null included")
        (<p>)
        (<p> "Using a &lt;class&gt; type specifier instead of the more generic &lt;class+&gt; specifier will enable the compiler to enforce non null.")))
    (<Concept-Doc> name: threads title: "Threads"
      (<description>
        (<p> "Jazz offers a multi-threaded programming model. The Thread class represents a thread")))
    (<Concept-Doc> name: formatted_output title: "Formatted Output"
      (<description>
        (<p> "Implements formatted output.")
        (<p>)
        (<definition> name: format_directives title: "Directives"
          (<format-directives>
            (<directive> "ASCII" "a" "human readable")
            (<directive> "SEXPR" "s" "reader readable")
            (<directive> "TEXT" "t" "textual representation")
            (<directive> "PRINT" "p" "ascii or sexpr or text")
            (<directive> "REAL" "r" "real number")
            (<directive> "CHAR" "h" "character")
            (<directive> "LIST" "l" "remove parenthesis")
            (<directive> "PROPERTIES" "k" "properties list")
            (<directive> "UNSIGNED" "u" "unsigned integer")
            (<directive> "HEXADECIMAL" "x" "hexadecimal integer")
            (<directive> "COLUMN" "c" "column")
            (<directive> "TAB" "&" "insert tab character")
            (<directive> "NEW_LINE" "%" "insert new line")
            (<directive> "LOCALIZE" "z" "localized string")
            (<directive> "FORMATTED" "f" "formatted control")))
        (<p>)
        (<definition> name: format_parameters title: "Parameters"
          (<p> "{x :a value :b value ?}")
          (<p> ":v -> takes the info from the parameters")
          (<p>)
          (<p> "Examples:")
          (<node>
            (<code> "(format :string \"{_ 5}\")")
            (<code> "(format :string \"{a :width :v :justify right}\" bonjour 20)"))
          (<p>)
          (<p> "Parameters can be optional and can be keyword based.")
          (<node>
            (<span> "list?")
            (<span> "width")
            (<span> "justify -> :left :right")
            (<span> "padding")
            (<span> "separator")
            (<span> "last-separator")
            (<span> "precision")
            (<span> "properties")
            (<span> "empty-value")
            (<span> "detail")))))
    (<Concept-Doc> name: collector title: "Garbage Collector"
      (<description>
        (<p> "Jazz is a garbage collected language where memory management is entirely managed by the language freeing the programmer from these complexities. ")
        (<p> "When a more precise control of memory and object lifespan is needed, Jazz offers structures similar to C++ scopes where a programmer can specify exactly where an object lifespan should end. The system is then able to immediately recycle the object thus freeing the garbage collector from first having to prove that the object was not used anymore before being able to recycle it. "
          "With these structures, very efficient systems can be built where memory allocation is kept at a minimum.")
        (<p> "The Jazz garbage collector is a fully incremental garbage collector, meaning that no discernable pauses should be experienced by the user caused by the garbage collector.")))
    (<Concept-Doc> name: launch title: "Launch Parameters"
      (<description>
        (<p> "Every Jazz application supports the following launch parameters:")
        (<properties>
          (<prop> "/app" "name of the application to launch")
          (<prop> "/controllerhost" "host address of the debugger")
          (<prop> "/controllerport" "host port of the debugger")
          (<prop> "/debug" "do we debug the process")
          (<prop> "/homedir" "home directory of the application")
          (<prop> "/jazzdir" "directory where to find the jazz executables")
          (<prop> "/user" "login name of the user")
          (<prop> "/userdir" "user directory"))
        (<p>)
        (<p> "Example:")
        (<p> (<xmp> #"Launcher.exe
  /app State
  /debug true
  /controllerhost 16777343
  /controllerport 32000
  /jazzdir "C:\Jedi\Bin"
  /jazzuser Guillaume
  /jazzuserdir "C:\Jedi\Guillaume"
  /homedir "C:\Jedi\Products\org.jazz.samples\Projects\State\Distribution"
  /user Guillaume"#))
        (<p>)
        (<definition> name: directories title: "Directories"
          (<p> "There are two main root directories: Home and Jazz. "
            "In a standalone application, the Home directory will point to the same directory as the Jazz one. "
            "The Jazz development environment uses this to point Jazz to its root and Home to the root of a project (in general the Jedi project as this will load the IDE). "
            "Note that by pointing Home to another project than Jedi by using the /app command line argument, other projects can be loaded in the environment. "
            "Also note that on a client site, starting the application with /jazz to point to a Jazz environment (typically on a CD-ROM) can be use to debug the application in interpreted mode.")
          (<p> "Note that in Jazz, the Jazz root directory can be viewed as the root of the Jazz Development System, where as the Jedi directory is one part of the system, the IDE."))))
    (<Concept-Doc> name: grammar title: "Formal Grammar"
      (<description>
        (<xmp> style: "font-size: small;"
        #";;;
;;;; Formal Syntax
;;;


;; ? -> 0 or 1
;; * -> 0, 1, 2, ...
;; + -> 1, 2, ...
;; { ... } -> group


;;;
;;;; Lexical Structure
;;;


<content> ::= <read>+
<read> ::= <ws> <expr>

<expr> ::= <token> | <sequence> | <quote> | <string>

<sequence> ::=
    "(" <read>* { <ws> "." <read> }? ")"
    | "" <read>+ ""
    | "{" <symbol> <read>* "}"

<quote> ::= "'" <read>
<string> ::= """ { <string-char> | <escape> }* """

<token> ::=
    <type-specifier>
    | <symbol>
    | <hexadecimal>
    | <binary>
    | <integer>
    | <long>
    | <double>

<type-specifier> ::= "<" <symbol> ">" "+"?
<symbol> ::= <symbol-first> <symbol-subsequent>*

<hexadecimal> ::= #x <hexdigit>+
<binary> ::= #b <binarydigit>+
<integer> ::= <sign>? <digit>+
<long> ::= <sign>? <digit>+ L
<double> ::= <sign>? <digit>+ "." <digit>+
<escape> ::= "\" <any>
<comment> ::= ";" <comment-char> {cr | lf}
<expression-comment> ::= "@" <read> <read>
<ws> ::= <whitespace>*
<whitespace> ::=
    <comment>
    | <expression-comment>
    | tab
    | cr
    | lf
    | space

<symbol-first> ::= <letter> | <digit> | <special>
<symbol-subsequent> ::= <symbol-first> | <sign> | "."

<letter> ::= A-Za-z
<digit> ::= 0-9
<special> ::= !#$%&*/:<=>?^_|~
<hexdigit> ::= 0-9A-Fa-f
<binarydigit> ::= "0" | "1"
<sign> ::= "+" | "-"
<string-char> ::= <any> except """ | "\"
<comment-char> ::= <any> except cr | lf


;;;
;;;; Program Structure
;;;


<jazz-source-file> ::=
    <in>? <using>* <toplevel-unit>

<in> ::=
    "(" "in" <package-identifier> ")"

<using> ::=
    "(" "using" <package-identifier> ")"

;; toplevel units

<toplevel-unit> ::=
    "(" "class" "Object" <class-body> ")"
    | "(" "interface" "Unknown" ")"
    | "(" "package" "Common" ")"
    | <toplevel-class>
    | <toplevel-interface>
    | <toplevel-package>

<toplevel-class> ::=
    "(" "class" <toplevel-unit-modifiers> <class-identifier>
    "extends" <class-identifier>
    { "implements" <interface-list> }?
    <properties>?
    <class-body> ")"

<toplevel-interface> ::=
    "(" "interface" <toplevel-unit-modifiers> <interface-identifier>
    "extends" <interface-identifier>
    <properties>?
    <interface-body> ")"

<toplevel-package> ::=
    "(" "package" <toplevel-unit-modifiers> <package-identifier>
    "extends" <package-identifier>
    <properties>?
    <package-body> ")"

;; inner units

<inner-unit> ::=
    <inner-class> | <inner-interface> | <inner-package>

<inner-class> ::=
    "(" "class" <inner-unit-modifiers> <class-identifier>
    "extends" <class-identifier>
    { "implements" <interface-list> }?
    <properties>?
    <class-body> ")"

<inner-interface> ::=
    "(" "interface" <inner-unit-modifiers> <interface-identifier>
    { "extends" <interface-identifier> }?
    <properties>?
    <interface-body> ")"

<inner-package> ::=
    "(" "package" <inner-unit-modifiers> <package-identifier>
    { "extends" <package-identifier> }?
    <properties>?
    <package-body> ")"

;; unit definition

<interface-list> ::=
    <interface-identifier>
    | "(" <interface-identifier>+ ")"

<properties> ::=
    "(" "properties" { <identifier> <literal> }* ")"

<class-body> ::=
    <class-member>*

<interface-body> ::=
    <interface-member>*

<package-body> ::=
    <package-member>*

;; members

<class-member> ::=
    <slot>
    | <property>
    | <macro>
    | <method>
    | <unit-member>

<interface-member> ::=
    <method-signature>
    | <coexternal>
    | <unit-member>

<package-member> ::=
    <macro>
    | <method>
    | <unit-member>

<unit-member> ::=
    <unit>
    | <constant>
    | <structure>
    | <definition>
    | <comethod>
    | <external>

<slot> ::=
    "(" "slot" <member-modifiers> <slot-identifier> { "initialize" <expression> }? ")"

<property> ::=
    "(" "property" <member-modifiers> <property-identifier> { "initialize" <expression> }?
                { "getter" <method-identifier> }? { "setter" <method-identifier> }? ")"

<constant> ::=
    "(" "constant" <member-modifiers> <constant-identifier> <expression> ")"

<structure> ::=
    "(" "structure" <member-modifiers> <structure-identifier> <expression> ")"

<definition> ::=
    "(" "definition" <definition-modifiers> <definition-identifier> <expression> ")"

<macro> ::=
    "(" "macro" <macro-modifiers> "(" <macro-identifier> <parameter-list> ")" <body> ")"

<method-signature> ::=
    "(" <method-signature-body> ")"

<method-signature-body> ::=
    "method" <method-modifiers> "(" <method-identifier> <parameter-list> ")"

<method> ::=
    "(" <method-signature-body> <body> ")"

<comethod> ::=
    "(" "comethod" <member-modifiers> "(" <comethod-identifier> <typed-parameter-list> ")" <body> ")"

<external> ::=
    "(" "external" <library-identifier> <member-modifiers> "(" <external-identifier> <typed-parameter-list> ")" <body> ")"

<coexternal> ::=
    "(" "coexternal" <member-modifiers> "(" <coexternal-identifier> <typed-parameter-list> ")" <body> ")"

;; parameters

<parameter-list> ::=
    <parameter>* { "." <parameter-identifier> }?

<parameter> ::=
    <parameter-identifier> <type-specifier>?

<typed-parameter-list> ::=
    <typed-parameter>* { "." <parameter-identifier> }?

<typed-parameter> ::=
    <direction>? <parameter-identifier> <type-specifier>

<direction> ::=
    <in>
    | <out>
    | <in-out>

;; modifiers

<toplevel-unit-modifiers> ::= <toplevel-modifier>*
<inner-unit-modifiers> ::= <member-modifier>*
<definition-modifiers> ::= { <member-modifier> | <definition-modifier-extra> }*
<macro-modifiers> ::= <member-modifier>*
<method-modifiers> ::= { <definition-modifier> | <method-modifier-extra> }*
<member-modifiers> ::= <member-modifier>*

<member-modifier> ::= <toplevel-modifier> | "private"
<toplevel-modifier> ::= "meta" | "protected" | "public"
<definition-modifier-extra> ::= "final" | "virtual"
<method-modifier-extra> ::= "chained" | "abstract" | "inline" | "synchronized" | "remote"


;;;
;;;; External Representations
;;;


<datum> ::=
    <boolean> | <number> | <character> | <string> | <symbol> | <list>

<symbol> ::= <identifier>
<list> ::= "(" <datum>* ")" | "(" <datum>+ "." <datum> ")"


;;;
;;;; Expressions
;;;


<expression> ::=
    <literal>
    | <self>
    | <variable>
    | <function-call>
    | <object-invocation>

<literal> ::=
    <quotation> | <self-evaluating>

<variable> ::=
    <identifier>

<generalized-variable> ::=
    <variable>
    | <slot-access>

<quotation> ::=
    "'" <datum> | <quote>

<function-call> ::=
    "(" ")"

<object-invocation> ::=
    "" ""

<self> ::=
    "self"

<super> ::=
    "super"

<body> ::=
    <expression>*

;; derived expressions

<derived-expression> ::=
    <enumeration>
    | <quote> | <if> | <when> | <unless> | <while> | <begin> | <prog1> | <loop>
    | <cond> | <case> | <ecase> | <typecase> | <and> | <or> | <essay> | <either>
    | <set!> | <increase> | <decrease> | <cast> | <synchronize>
    | <function> | <let> | <letrec> | <with> | <with-closed>
    | <bind> | <bind-keywords> | <bind-optionals> | <bind-values> | <bind-properties> | <tie>
    | <cotry> | <block> | <return-from> | <return> | <catch> | <unwind-protect>
    | <error?> | <assert> | <assert-type> | <optimize> | <profile>

<quote> ::=
    "(" "quote" <expression> ")"

<if> ::=
    "(" "if" <test> <consequent> <alternate>+ ")"
<test> ::= <expression>
<consequent> ::= <expression>
<alternate> ::= <expression>

<while> ::=
    "(" "while" <test> <body> ")"

<and> ::=
    "(" "and" <expression>* ")"

<or> ::=
    "(" "or" <expression>* ")"

<set!> ::=
    "(" "set!" <generalized-variable> <expression> ")"

<cast> ::=
    "(" "cast" <expression> <type-specifier> ")"

<synchronize> ::=
    "(" "synchronize" <expression>* ")"

<function> ::=
    "(" "function"  ")"

<let> ::=
    "(" "let" <bindings> <body> ")"

<with> ::=
    "(" "with" <bindings> <body> ")"

<with-closed> ::=
    "(" "with-closed" <bindings> <body> ")"

<bind> ::=
    "(" "bind" <tree-bindings> <expression> <body> ")"

<bind-keywords> ::=
    "(" "bind-keywords" <keyword-bindings> <expression> <body> ")"

<bind-optionals> ::=
    "(" "bind-optionals" <optional-bindings> <expression> <body> ")"

<bind-values> ::=
    "(" "bind-values" <value-bindings> <expression> <body> ")"

<bind-properties> ::=
    "(" "bind-properties" <property-bindings> <expression> <body> ")"

<block> ::=
    "(" "block" <identifier> <body> ")"

<return-from> ::=
    "(" "return-from" <identifier> <expression> ")"

<return> ::=
    "(" "return" <expression> ")"

<catch> ::=
    "(" "catch"  ")"

<optimize> ::=
    "(" "optimize" <optimize-settings> <expression>* ")"
<optimize-settings> ::= "(" <optimize-setting>* ")"
<optimize-setting> ::=
    ":frame?" <boolean>

<profile> ::=
    "(" "profile" <boolean> <profile-body> ")"
    | "(" "profile" <profile-body> ")"
<profile-body> ::= <profile-name> <profile-condition> <body>
<profile-name> ::= <identifier>
<profile-condition> ::= <identifier>

;; macros

<enumeration> ::=
    "(" "enumeration" <member-modifiers> <enumeration-identifier> <expression> ")"

<when> ::=
    "(" "when" <test> <consequent>+ ")"

<unless> ::=
    "(" "unless" <test> <consequent>+ ")"

<begin> ::=
    "(" "begin" <body> ")"

<prog1> ::=
    "(" "prog1" <expression> <body> ")"

<loop> ::=
    "(" "loop" <loop-clause>* ")"
<loop-clause> ::=
    "(" "for" <loop-for-clause> ")"
    | "(" "repeat" <loop-repeat-clause> ")"
    | "(" "do" <loop-do-clause> ")"
    | "(" "sum" <loop-sum-clause> ")"
    | "(" "collect" <loop-collect-clause> ")"
    | <expression>
<loop-for-clause> ::=
    <variable> "in" <expression>
    | "(" <variable> <variable> ")" "in-properties" <expression>
    | <variable> "iterate" <expression>
    | <variable> "from" <loop-for-from-clause>?
<loop-for-from-clause> ::=
    "to" <expression>
    | "below" <expression>
    | "downto" <expression>
<loop-repeat-clause> ::= <expression>
<loop-do-clause> ::= <expression>*
<loop-sum-clause> ::= <expression>
<loop-collect-clause> ::= <expression>

<cond> ::=
    "(" "cond" <cond-clause>* ")"

<case> ::= "(" "case" <target> <case-clause>+ ")"
<case> ::= "(" "case" <target> <case-clause>* "(" "else" <expression>* ")" ")"

<ecase> ::=
    "(" "ecase" <ecase-clause>* ")"

<typecase> ::=
    "(" "typecase" <typecase-clause>* ")"

<essay> ::=
    "(" "essay" <expression>+ ")"

<either> ::=
    "(" "either" <expression>+ ")"

<increase> ::=
    "(" "increase" <generalized-variable> <expression>? ")"

<decrease> ::=
    "(" "decrease" <generalized-variable> <expression>? ")"

<letrec> ::=
    "(" "letrec" <bindings> <body> ")"

<tie> ::=
    "(" "tie" <string> ")"

<cotry> ::=
    "(" "cotry" <expression> <cotry-clauses> ")"
<cotry-clauses> ::= <cotry-clause>*
<cotry-clause> ::= <ecase-clause>

<unwind-protect> ::=
    "(" "unwind-protect" <protected-expression> <protection-expressions> ")"
<protected-expression> ::= <expression>
<protection-expressions> ::= <expression>*

<error?> ::=
    "(" "error?" <expression>* ")"

<assert> ::=
    "(" "assert" <expression> ")"
    | "(" "assert" <function> <expression> ")"

<assert-type> ::=
    "(" "assert-type" <expression> <type-specifier> ")"

;; identifiers

<class-identifier> ::= <identifier>
<interface-identifier> ::= <identifier>
<package-identifier> ::= <identifier>
<constant-identifier> ::= <identifier>
<enumeration-identifier> ::= <identifier>
<structure-identifier> ::= <identifier>
<definition-identifier> ::= <identifier>
<slot-identifier> ::= <identifier>
<property-identifier> ::= <identifier>
<macro-identifier> ::= <identifier>
<method-identifier> ::= <identifier>
<comethod-identifier> ::= <identifier>
<external-identifier> ::= <identifier>
<coexternal-identifier> ::= <identifier>
<parameter-identifier> ::= <identifier>

<library-identifier> ::=
    "Jazz"
    | "Kernel"
    | "GDI"
    | ...

<primitive-identifier> ::=
    "void" |
    "bool" |
    "byte" | "ubyte" | "short" | "int" | "long" | "float" | "double" |
    "string" | "ansistring" |
    "hresult" | "variant" | "guid"
"#)))
    )
  (<Section-Doc> name: syntax_forms title: "Syntax"
    (<description>
      (<p> "Syntax forms in Jazz can be of two kinds :")
      (<node>
        (<p> "Special form"
          (<p> "A special form is a fundamental syntactic element of the Jazz language. "
            "It is explicitly recognized by both the interpreter and the compiler."))
        (<p> "Macro"
          (<p> "A macro works by rewriting a lisp expression into another valid lisp expression, often by using more fundamental special forms. "
            "Because the code generated stays within the language, macros don't need explicit support in either the interpreter and the compiler."))))
    (<Syntax-Doc> name: bind parameters: "variables-tree values-tree expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-optionals parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-keywords parameters: "((variable default) ...) values-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: bind-values parameters: "(variable ...) values expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: quote parameters: "expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: if parameters: "test yes-expr no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: when parameters: "test yes-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unless parameters: "test no-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: while parameters: "test expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: begin parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: prog1 parameters: "result-expr1 expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: loop parameters: "..."
      (<description>
        (<code> "for")
        (<code> "in")
        (<code> "in-properties")
        (<code> "iterate")
        (<code> "from")
        (<code> "repeat")
        (<code> "do")
        (<code> "sum")
        (<code> "collect")))
    (<Syntax-Doc> name: tie
      (<description>
        (<p>)))
    (<Syntax-Doc> name: cond parameters: "(test expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: case parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: ecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: typecase parameters: "target (try expr ...) ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: set! parameters: "variable expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: increase! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: decrease! parameters: "variable expr {value}"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: let parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: letrec parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: catch parameters: "name expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: unwind-protect parameters: "protected-expr protection-expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: function parameters: "parameters-list expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: with parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: with-closed parameters: "((variable value) ...) expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: and parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if and only if all expr... are true. Note that and will stop as soon as it encounters a false value."))
      (<examples>
        (<example> "(and true (= 2 (+ 1 1))) returns true.")
        (<example> "(and (symbol-bound? 'not-a-bound-variable) not-a-bound-variable) will not signal an error because the first test will fail.")))
    (<Syntax-Doc> name: or parameters: "expr ..."
      (<description>
        (<p> "This syntactic form will return true if one of the expr... is true. Note that or will stop as soon as it encounters a true value."))
      (<examples>
        (<example>
          (<p> "One simple application of the fact that or stops as soon as it encounters a true value is in very clean code for managing simple lazy structures.")
          (<p>)
          (<p> "(define a-big-structure-only-on-demand nil)")
          (<p> "(define (get-structure)")
          (<p> "  (or a-big-structure-only-on-demand")
          (<p> "      (set! a-big-structure-only-on-demand (new-structure))))"))))
    (<Syntax-Doc> name: essay parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: either parameters: "expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: error? parameters: "expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert parameters: "asserted-expr"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: assert-type parameters: "asserted-type"
      (<description>
        (<p>)))
    (<Syntax-Doc> name: optimize parameters: "settings expr ..."
      (<description>
        (<p>)))
    (<Syntax-Doc> name: profile parameters: "..."
      (<description>
        (<p>))))
  (<Section-Doc> name: "constants" title: "Constants"
    (<Constant-Doc> name: c_false title: "false"
      (<description>
        "Represents the boolean value false."))
    (<Constant-Doc> name: c_true title: "true"
      (<description>
        "Represents the boolean value true."))
    (<Constant-Doc> name: c_nil title: "nil"
      (<description>
        "Represents the empty list.")))
  (<Section-Doc> name: primitives title: "Primitive Types"
    (<description>
      (<p>))
    (<Primitive-Doc> name: void
      (<description>
        (<p> "")))
    (<Primitive-Doc> name: bool
      (<description>
        (<p> "A primitive boolean value.")))
    (<Primitive-Doc> name: byte
      (<description>
        (<p> "An integer of size 1.")))
    (<Primitive-Doc> name: ubyte
      (<description>
        (<p> "An unsigned integer of size 1.")))
    (<Primitive-Doc> name: short
      (<description>
        (<p> "An integer of size 2.")))
    (<Primitive-Doc> name: int
      (<description>
        (<p> "An integer of size 4.")))
    (<Primitive-Doc> name: long
      (<description>
        (<p> "An integer of size 8.")))
    (<Primitive-Doc> name: float
      (<description>
        (<p> "A small real.")))
    (<Primitive-Doc> name: double
      (<description>
        (<p> "A large real.")))
    (<Primitive-Doc> name: string
      (<description>
        (<p> "A unicode string.")))
    (<Primitive-Doc> name: ansistring
      (<description>
        (<p> "An ansi string."))))
  (<Section-Doc> title: "Packages"
      (<Package-Doc> name: jazz title: "Jazz"
        (<Section-Doc> title: "Boolean"
          (<Method-Doc> name: eq? parameters: "x y"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "x")
                " is physicaly equal to "
                (<parameter> "y")
                ". In other words, if both memory pointers are the same.")))
          (<Method-Doc> name: neq? parameters: "x y"
            (<description>
              (<p> "The inverse test of eq?.")))
          (<Method-Doc> name: eqv? parameters: "x y"
            (<description>
              (<p> "eqv? will succed if the two objects are eq? or if they can be simply compared without going into their structures. For example, (eq? 2.3 2.3) migth return false whereas (eqv? 2.3 2.3) will always return true.")))
          (<Method-Doc> name: equal? parameters: "x y"
            (<description>
              (<p> "The most general equivalence predicate of all.")
              (<p> "equal? will succed if the two objects are eqv? but will also try to determine if the two objets structures are identical. For example, (eq? (list 1 2 3) (list 1 2 3)) returns false but (equal? (list 1 2 3) (list 1 2 3)) returns true.")))
          (<Method-Doc> name: not parameters: "obj"
            (<description>
              (<p>
                "Returns the logical negation of "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: boolean? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is of "
                (<code> "Boolean")
                " type."))
            (<examples>
              (<example>
                (<code> "(boolean? true)")
                " returns true.")
              (<example>
                (<code> "(boolean? false)")
                " returns true.")
              (<example>
                (<code> "(boolean? nil)")
                " return false.")))
          (<Method-Doc> name: xor parameters: "x y")
          (<Method-Doc> name: = parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: /= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: < parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: <= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: > parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: >= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci/= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci< parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci<= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci> parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: ci>= parameters: "obj1 obj2 obj3 ...")
          (<Method-Doc> name: boolean parameters: "obj")
          (<Method-Doc> name: boolean->integer parameters: "bool")
          (<Method-Doc> name: integer->boolean parameters: "z"))
        (<Section-Doc> title: "Char"
          (<Method-Doc> name: char? parameters: "obj")
          (<Method-Doc> name: jazz-constituent? parameters: "obj")
          (<Method-Doc> name: cpp/java-constituent? parameters: "obj")
          (<Method-Doc> name: alphabetic? parameters: "obj"
            (<description>
              (<p>
                "Tests if "
                (<parameter> "obj")
                " is alphabetic. An object is alphabetic if it is an alphabetic character or a sequence composed only of alphabetic parts.")))
          (<Method-Doc> name: numeric? parameters: "obj"
            (<description>
              (<p> "Tests if obj is numeric. An object is numeric if it is a numeric character or a sequence composed only of numeric parts.")))
          (<Method-Doc> name: alphanumeric? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: whitespace? parameters: "obj"
            (<description>
              (<p> "Tests if obj is whitespace. An object is whitespace if it is a whitespace character or a sequence composed only of whitespace parts.")))
          (<Method-Doc> name: upper-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is upper-case. An object is upper-case if it is an upper-case character or a sequence composed only of upper-case parts.")))
          (<Method-Doc> name: lower-case? parameters: "obj"
            (<description>
              (<p> "Tests if obj is lower-case. An object is lower-case if it is a lower-case character or a sequence composed only of lower-case parts.")))
          (<Method-Doc> name: upcase parameters: "obj"
            (<description>
              (<p> "Converts obj to upper-case. If obj is a sequence, every part of obj with be converted to upper-case.")))
          (<Method-Doc> name: downcase parameters: "obj"
            (<description>
              (<p> "Converts obj to lower-case. If obj is a sequence, every part of obj with be converted to lower-case.")))
          (<Method-Doc> name: capitalize parameters: "obj"
            (<description>
              (<p> "Converts obj to capitalized form where every word starts with a capital letter and the rest is in lower-case. If obj is a sequence, every part of obj with be converted to capitalized form."))))
        (<Section-Doc> title: "Class"
          (<description>
            (<p> "The Class type is the supertype of every class. It enables a class to be inspected and manipulated as any other object."))
          (<Method-Doc> name: class? parameters: "obj"
            (<description>
              (<p> "")))
          (<Method-Doc> name: class-members parameters: "class"
            (<description>
              (<p> "Returns a list of all members of class.")))
          (<Method-Doc> name: class-fields parameters: "class"
            (<description>
              (<p> "Returns a list of all fields of class.")))
          (<Method-Doc> name: class-slots parameters: "class"
            (<description>
              (<p> "Returns a list of all slots of class."))))
        (<Section-Doc> title: "Closure"
          (<Method-Doc> name: closure? parameters: "obj"))
        (<Section-Doc> title: "Collector"
          (<Method-Doc> name: gc parameters: ""))
        (<Section-Doc> title: "Control"
          (<Method-Doc> name: catched? parameters: "name")
          (<Method-Doc> name: throw parameters: "name")
          (<Method-Doc> name: exit parameters: ""))
        (<Section-Doc> title: "Debugger"
          (<Method-Doc> name: signal parameters: "exception")
          (<Method-Doc> name: error parameters: "format-string obj ..."))
        (<Section-Doc> title: "Enumeration"
          (<Method-Doc> name: enumeration? parameters: "obj"))
        (<Section-Doc> title: "Eval"
          (<Method-Doc> name: eval parameters: "expr")
          (<Method-Doc> name: identity parameters: "obj"))
        (<Section-Doc> title: "Format"
          (<Method-Doc> name: format parameters: "format-string obj ..."))
        (<Section-Doc> title: "Function"
          (<Method-Doc> name: function? parameters: "obj"))
        (<Section-Doc> title: "Hashtable"
          (<Method-Doc> name: hash-ref parameters: "hashtable key" package-name: Language
            (<description>
              (<p>
                "Gets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                ".")))
          (<Method-Doc> name: hash-set! parameters: "hashtable key value" package-name: Language
            (<description>
              (<p>
                "Sets the value associated with "
                (<parameter> "key")
                " inside "
                (<parameter> "hashtable")
                " to "
                (<parameter> "value")
                ".")))
          (<Method-Doc> name: hash-clear parameters: "hashtable key")
          (<Method-Doc> name: empty-hashtable parameters: "hashtable")
          (<Method-Doc> name: load-hashtable parameters: "hashtable file")
          (<Method-Doc> name: hash-remove! parameters: "hashtable key value")
          (<Method-Doc> name: for-each-hash parameters: "proc hashtable"))
        (<Section-Doc> title: "Integer"
          (<Method-Doc> name: integer? parameters: "obj")
          (<Method-Doc> name: even? parameters: "z")
          (<Method-Doc> name: odd? parameters: "z")
          (<Method-Doc> name: quotient parameters: "z1 z2")
          (<Method-Doc> name: modulo parameters: "z1 z2")
          (<Method-Doc> name: separate parameters: "z1 z2")
          (<Method-Doc> name: randomize parameters: "")
          (<Method-Doc> name: random parameters: "n")
          (<Method-Doc> name: bit-not parameters: "n")
          (<Method-Doc> name: bit-and parameters: "n ...")
          (<Method-Doc> name: bit-or parameters: "n ...")
          (<Method-Doc> name: bit-xor parameters: "n ...")
          (<Method-Doc> name: bit-set parameters: "n1 n2 n3")
          (<Method-Doc> name: bit-set? parameters: "n1 n2")
          (<Method-Doc> name: shift-left parameters: "n1 n2")
          (<Method-Doc> name: shift-right parameters: "n1 n2"))
        (<Section-Doc> title: "Interface"
          (<Method-Doc> name: interface? parameters: "obj"))
        (<Section-Doc> title: "List"
          (<Method-Doc> name: car parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: set-car! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the car field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: set-cdr! parameters: "pair obj"
            (<description>
              (<p>
                "Sets the cdr field of "
                (<parameter> "pair")
                " to "
                (<parameter> "obj")
                ".")))
          (<Method-Doc> name: cons parameters: "x y"
            (<description>
              (<p>
                "Returns a newly allocated pair whose car is "
                (<parameter> "x")
                " and whose cdr is "
                (<parameter> "y")
                ".")))
          (<Method-Doc> name: reverse parameters: "seq"
            (<description>
              (<p> "Reverses a sequence.")))
          (<Method-Doc> name: list? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a list, false otherwise."))
            (<examples>
              (<example> "(list? nil) -> true")
              (<example> "(list? '(a b c)) -> true")
              (<example> "(list? 2) -> false")))
          (<Method-Doc> name: nil? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is the empty list, false otherwise.")))
          (<Method-Doc> name: not-nil?)
          (<Method-Doc> name: pair? parameters: "obj"
            (<description>
              (<p> "Returns true if obj is a pair and otherwise returns false."))
            (<examples>
              (<example> "(pair? 2) -> false")
              (<example> "(pair? nil) -> false")
              (<example> "(pair? (cons 1 2)) -> true")
              (<example> "(pair? '(a b c)) -> true")))
          (<Method-Doc> name: atom? parameters: "obj")
          (<Method-Doc> name: caar parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cadr parameters: "pair"
            (<description>
              (<p>
                "Returns the car field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cdar parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the car field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: cddr parameters: "pair"
            (<description>
              (<p>
                "Returns the cdr field of the cdr field of "
                (<parameter> "pair")
                ".")))
          (<Method-Doc> name: list parameters: "obj ..."
            (<description>
              (<p> "Returns a list constructed of all its arguments.")))
          (<Method-Doc> name: memq? parameters: "obj list")
          (<Method-Doc> name: memv? parameters: "obj list")
          (<Method-Doc> name: member? parameters: "obj list &key key test")
          (<Method-Doc> name: assq parameters: "obj list")
          (<Method-Doc> name: assv parameters: "obj list")
          (<Method-Doc> name: assoc parameters: "obj list &key key test")
          (<Method-Doc> name: rassoc parameters: "obj list &key key test")
          (<Method-Doc> name: reverse! parameters: "list")
          (<Method-Doc> name: remove! parameters: "obj list")
          (<Method-Doc> name: getprop parameters: "plist key")
          (<Method-Doc> name: getf parameters: "plist key")
          (<Method-Doc> name: setf parameters: "plist key value")
          (<Method-Doc> name: for-each-pair parameters: "proc list")
          (<Method-Doc> name: for-each-property parameters: "proc list"))
        (<Section-Doc> title: "Manifest"
          (<Method-Doc> name: load parameters: "unit-name")
          (<Method-Doc> name: unit-loaded? parameters: "unit-name")
          (<Method-Doc> name: in-manifest? parameters: "unit-name"))
        (<Section-Doc> title: "Map"
          (<Method-Doc> name: map-ref parameters: "map key")
          (<Method-Doc> name: map-set! parameters: "map key value")
          (<Method-Doc> name: map-clear parameters: "map key")
          (<Method-Doc> name: empty-map parameters: "map")
          (<Method-Doc> name: load-map parameters: "map file")
          (<Method-Doc> name: for-each-map parameters: "proc map"))
        (<Section-Doc> title: "Metaclass"
          (<Method-Doc> name: metaclass? parameters: "obj")
          (<Method-Doc> name: metaclass-instance parameters: "metaclass"))
        (<Section-Doc> title: "Number"
          (<Method-Doc> name: + parameters: "obj ...")
          (<Method-Doc> name: - parameters: "obj1 obj2 ...")
          (<Method-Doc> name: * parameters: "obj ...")
          (<Method-Doc> name: number? parameters: "obj")
          (<Method-Doc> name: zero? parameters: "obj")
          (<Method-Doc> name: positive? parameters: "obj")
          (<Method-Doc> name: negative? parameters: "obj")
          (<Method-Doc> name: / parameters: "obj1 obj2 ...")
          (<Method-Doc> name: relate parameters: "x y")
          (<Method-Doc> name: sign parameters: "z")
          (<Method-Doc> name: floor parameters: "r")
          (<Method-Doc> name: round parameters: "r")
          (<Method-Doc> name: ceil parameters: "r")
          (<Method-Doc> name: abs parameters: "z")
          (<Method-Doc> name: min parameters: "obj ...")
          (<Method-Doc> name: max parameters: "obj ...")
          (<Method-Doc> name: between? parameters: "n lower upper")
          (<Method-Doc> name: between parameters: "lower n upper")
          (<Method-Doc> name: in-interval? parameters: "n lower upper")
          (<Method-Doc> name: norm parameters: "x")
          (<Method-Doc> name: near? parameters: "x y distance"))
        (<Section-Doc> title: "Object"
          (<Method-Doc> name: object? parameters: "obj")
          (<Method-Doc> name: copy parameters: "obj"))
        (<Section-Doc> title: "Package"
          (<Method-Doc> name: package? parameters: "obj"))
        (<Section-Doc> title: "Printer"
          (<Method-Doc> name: display parameters: "obj &optional printer")
          (<Method-Doc> name: write parameters: "obj &optional printer")
          (<Method-Doc> name: describe parameters: "obj &optional printer")
          (<Method-Doc> name: new-line parameters: "&optional printer")
          (<Method-Doc> name: print-unreadable parameters: "obj printer proc"))
        (<Section-Doc> title: "Procedure"
          (<Method-Doc> name: procedure? parameters: "obj"))
        (<Section-Doc> title: "Reader"
          (<Method-Doc> name: read parameters: "&optional reader")
          (<Method-Doc> name: get-char parameters: "&optional reader")
          (<Method-Doc> name: unget-char parameters: "char &optional reader")
          (<Method-Doc> name: peek-char parameters: "&optional reader")
          (<Method-Doc> name: end-of-stream? parameters: "&optional reader"))
        (<Section-Doc> title: "Real"
          (<Method-Doc> name: real? parameters: "obj")
          (<Method-Doc> name: sin parameters: "r")
          (<Method-Doc> name: cos parameters: "r")
          (<Method-Doc> name: tan parameters: "r")
          (<Method-Doc> name: asin parameters: "r")
          (<Method-Doc> name: acos parameters: "r")
          (<Method-Doc> name: atan parameters: "r1 r2")
          (<Method-Doc> name: sqrt parameters: "r")
          (<Method-Doc> name: exp parameters: "r")
          (<Method-Doc> name: log parameters: "r")
          (<Method-Doc> name: expt parameters: "r1 r2")
          (<Method-Doc> name: percentage parameters: "part total")
          (<Method-Doc> name: percent parameters: "percent n"))
        (<Section-Doc> title: "Sequence"
          (<description>
            "Sequences are an abstract data type representing objects capable of storing sequences of objects. Some examples of sequences are lists, strings and vectors. The Jazz language possesses a important number of sequence manipulation functions")
          (<Method-Doc> name: sequence? parameters: "obj"
            (<description>
              (<p> "Tests if obj is of Sequence type.")))
          (<Method-Doc> name: length parameters: "sequence"
            (<description>
              (<p>
                "Returns the number of elements in "
                (<parameter> "seq")
                ".")))
          (<Method-Doc> name: element parameters: "sequence n"
            (<description>
              (<p> "Returns the nth element of sequence.")))
          (<Method-Doc> name: set-element! parameters: "sequence n value"
            (<description>
              (<p> "Destructively sets the nth element of sequence to value.")))
          (<Method-Doc> name: empty? parameters: "sequence")
          (<Method-Doc> name: tail parameters: "sequence n"
            (<description>
              (<p> "Returns the elements of sequence that range from n to the end. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: last parameters: "sequence"
            (<description>
              (<p> "Returns the last element of sequence.")))
          (<Method-Doc> name: last-tail parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made-up of only the last element of sequence. Note that this operation can be done very efficiently for lists.")))
          (<Method-Doc> name: butlast parameters: "sequence"
            (<description>
              (<p> "Returns a sequence made up of every element of sequence except the last.")))
          (<Method-Doc> name: subseq parameters: "sequence start &optional end"
            (<description>
              (<p> "Returns a sequence made up of the elements of sequence that range from start to end exclusively. If end is omited, the elements are taken till the end of sequence.")))
          (<Method-Doc> name: subseq! parameters: "sequence start &optional end")
          (<Method-Doc> name: sort parameters: "predicate sequence &key key test")
          (<Method-Doc> name: for-each-reversed parameters: "sequence")
          (<Method-Doc> name: append parameters: "sequence"
            (<description>
              (<p>
                "Returns a sequence composed of all the elements of "
                (<parameter> "seq")
                "."))
            (<examples>
              (<example> "(append) -> nil")
              (<example> "(append '(a b c) nil '(1 2) '(1 2 3)) -> (a b c 1 2 1 2 3)")
              (<example> "(append \\\"Hello\\\" \\\" \\\" \\\"there\\\") -> \\\"Hello there\\\"")
              (<example> "(append 2 3) -> <error>\"")))
          (<Method-Doc> name: append! parameters: "sequence ...")
          (<Method-Doc> name: insert! parameters: "obj sequence pos")
          (<Method-Doc> name: insert-sequence! parameters: "sequence inserted pos")
          (<Method-Doc> name: replace-subseq! parameters: "sequence start end replacement")
          (<Method-Doc> name: element-reversed parameters: "sequence n")
          (<Method-Doc> name: for-each parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2")))
          (<Method-Doc> name: map parameters: "procedure sequence1 &optional sequence2"
            (<description>
              (<p> "Applies procedure to every element of sequence1 and optionaly sequence2 and collects the results in a list that it returns.")))
          (<Method-Doc> name: map-to parameters: "type proc sequence")
          (<Method-Doc> name: gather parameters: "sequence")
          (<Method-Doc> name: collect parameters: "proc sequence")
          (<Method-Doc> name: collect-if parameters: "predicate sequence")
          (<Method-Doc> name: collect-type parameters: "type sequence")
          (<Method-Doc> name: count parameters: "obj sequence"
            (<description>
              (<p> "Finds the number of occurrences of obj in sequence.")))
          (<Method-Doc> name: count-if parameters: "predicate sequence")
          (<Method-Doc> name: count-type parameters: "type sequence")
          (<Method-Doc> name: find parameters: "object sequence")
          (<Method-Doc> name: find-if parameters: "predicate sequence")
          (<Method-Doc> name: skip parameters: "predicate sequence")
          (<Method-Doc> name: some? parameters: "predicate sequence")
          (<Method-Doc> name: every? parameters: "predicate sequence")
          (<Method-Doc> name: union parameters: "sequence ...")
          (<Method-Doc> name: intersection parameters: "sequence ...")
          (<Method-Doc> name: difference parameters: "sequence1 sequence2"
            (<description>
              (<p> "Returns the set difference sequence1 \\ sequence2.")))
          (<Method-Doc> name: remove parameters: "target sequence")
          (<Method-Doc> name: remove-trailing parameters: "target list")
          (<Method-Doc> name: remove-duplicates parameters: "sequence"
            (<description>
              (<p> "Returns a sequence that has exactly the same elements as sequence and in the same order but with no duplicates.")))
          (<Method-Doc> name: remove-nils parameters: "sequence")
          (<Method-Doc> name: mismatch parameters: "target sequence")
          (<Method-Doc> name: prefix parameters: "sequences")
          (<Method-Doc> name: prefix? parameters: "target sequence")
          (<Method-Doc> name: search parameters: "target sequence")
          (<Method-Doc> name: split parameters: "sequence separator")
          (<Method-Doc> name: split-justified parameters: "sequence width separators")
          (<Method-Doc> name: join parameters: "sequences separator")
          (<Method-Doc> name: substitute parameters: "old new sequence")
          (<Method-Doc> name: substitute-alist parameters: "replacements sequence")
          (<Method-Doc> name: fill! parameters: "sequence object")
          (<Method-Doc> name: replace! parameters: "sequence replacement")
          (<Method-Doc> name: insert-ordered! parameters: "object sequence")
          (<Method-Doc> name: merge-ordered parameters: "proc x y")
          (<Method-Doc> name: random-element parameters: "sequence")
          (<Method-Doc> name: partition parameters: "sequence &key key test")
          (<Method-Doc> name: starts-with? parameters: "string target")
          (<Method-Doc> name: ends-with? parameters: "string target")
          (<Method-Doc> name: first parameters: "sequence")
          (<Method-Doc> name: second parameters: "sequence")
          (<Method-Doc> name: third parameters: "sequence")
          (<Method-Doc> name: fourth parameters: "sequence")
          (<Method-Doc> name: fifth parameters: "sequence")
          (<Method-Doc> name: sixth parameters: "sequence")
          (<Method-Doc> name: seventh parameters: "sequence")
          (<Method-Doc> name: eighth parameters: "sequence")
          (<Method-Doc> name: ninth parameters: "sequence")
          (<Method-Doc> name: tenth parameters: "sequence")
          (<Method-Doc> name: set-first! parameters: "sequence object")
          (<Method-Doc> name: set-second! parameters: "sequence object")
          (<Method-Doc> name: set-third! parameters: "sequence object")
          (<Method-Doc> name: set-fourth! parameters: "sequence object")
          (<Method-Doc> name: set-fifth! parameters: "sequence object")
          (<Method-Doc> name: set-sixth! parameters: "sequence object")
          (<Method-Doc> name: set-seventh! parameters: "sequence object")
          (<Method-Doc> name: set-eighth! parameters: "sequence object")
          (<Method-Doc> name: set-ninth! parameters: "sequence object")
          (<Method-Doc> name: set-tenth! parameters: "sequence object"))
        (<Section-Doc> title: "String"
          (<Method-Doc> name: string? parameters: "object")
          (<Method-Doc> name: empty-string? parameters: "object"))
        (<Section-Doc> title: "Symbol"
          (<Method-Doc> name: symbol? parameters: "object")
          (<Method-Doc> name: keyword? parameters: "object")
          (<Method-Doc> name: symbol->keyword parameters: "symbol")
          (<Method-Doc> name: keyword->symbol parameters: "keyword")
          (<Method-Doc> name: string->symbol parameters: "string")
          (<Method-Doc> name: symbol->string parameters: "symbol")
          (<Method-Doc> name: find-symbol parameters: "string")
          (<Method-Doc> name: generate-symbol parameters: "&optional prefix")
          (<Method-Doc> name: symbol-bound? parameters: "symbol")
          (<Method-Doc> name: symbol-unbound? parameters: "symbol"))
        (<Section-Doc> title: "Thread"
          (<Method-Doc> name: primary-thread parameters: "")
          (<Method-Doc> name: active-thread parameters: ""))
        (<Section-Doc> title: "Time"
          (<Method-Doc> name: clock parameters: ""))
        (<Section-Doc> title: "Type"
          (<Method-Doc> name: type? parameters: "object")
          (<Method-Doc> name: new parameters: "class object ...")
          (<Method-Doc> name: new-in parameters: "context class object ...")
          (<Method-Doc> name: coerce parameters: "object type")
          (<Method-Doc> name: class-of parameters: "object")
          (<Method-Doc> name: is? parameters: "object type")
          (<Method-Doc> name: is-not? parameters: "object type")
          (<Method-Doc> name: typed? parameters: "object type-name")
          (<Method-Doc> name: subtype? parameters: "class type")
          (<Method-Doc> name: subtyped? parameters: "class type-name")
          (<Method-Doc> name: type-name parameters: "type")
          (<Method-Doc> name: type-ascendant parameters: "type")
          (<Method-Doc> name: type-descendants parameters: "type")
          (<Method-Doc> name: type-ancestors parameters: "type"))
        (<Section-Doc> title: "Unit"
          (<Method-Doc> name: unit? parameters: "object")
          (<Method-Doc> name: all-units parameters: ""))
        (<Section-Doc> title: "Values"
          (<Method-Doc> name: values parameters: "object ..."))
        (<Section-Doc> title: "Vector"
          (<Method-Doc> name: vector? parameters: "object"))))
  (<Section-Doc> title: "Classes"
    (<Class-Doc> name: Object
      (<description>
        (<p> "The base class of every other class."))
      (<Method-Doc> name: initialize parameters: "object ...")
      (<Method-Doc> name: destroy parameters: "")
      (<Method-Doc> name: close parameters: "")
      (<Method-Doc> name: print parameters: "printer detail"))
    (<Class-Doc> name: Boolean extends: Object implements: ()
      (<description>
        (<p>
          "The "
          (<code> "Boolean")
          " class is used to represent truth values. Two boolean objects, "
          (<code> "true")
          " and "
          (<code> "false")
          " exist to represent truthness and falseness respectively. In general, every time a method expects a boolean value, you can use either "
          (<code> "false")
          " or "
          (<code> "nil")
          " to specify falseness and any other object to specify truthness.")))
    (<Class-Doc> name: Char
      (<description>
        (<p>
          "The Char type is used to represent characters. "
          "The external representation of a character x is #\\x. "
          "Certain special characters can also be represented by a symbolic name as in #\\symbolic-name.")
        (<p>)
        (<p> "Symbolic Names")
        (<node>
          "Home"
          "Enter"
          "End"
          "Info"
          "Backspace"
          "Tab"
          "Line-Feed"
          "Page-Up"
          "Page-Down"
          "Return"
          "Escape"
          "Left-Arrow"
          "Right-Arrow"
          "Up-Arrow"
          "Down-Arrow"
          "Space"
          "Exclamation-Mark"
          "Quotation-Mark"
          "Ampersand"
          "Quote"
          "Open-Parenthesis"
          "Close-Parenthesis"
          "Times"
          "Plus"
          "Comma"
          "Minus"
          "Period"
          "Slash"
          "Colon"
          "Semi-Colon"
          "Question-Mark"
          "Open-Bracket"
          "Backslash"
          "Close-Bracket"
          "Exponential"
          "Underscore"
          "Backquote"
          "Open-Brace"
          "Close-Brace"
          "Delete"
          "Ellipsis"
          "Diamond"
          "Lower-Equal"
          "Greater-Equal"
          "Not-Equal"
          "Check-Mark"
          "Triangle"
          "Angle"
          "F1"
          "F2"
          "F3"
          "F4"
          "F5"
          "F6"
          "F7"
          "F8"
          "F9"
          "F10"
          "F11"
          "F12"
          "F13"
          "F14"
          "F15"))))
  (<Section-Doc> title: "Modules"
    (<Doc-Insert> path: (org.jazz *))))
