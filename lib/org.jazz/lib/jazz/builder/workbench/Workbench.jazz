;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.workbench.Workbench jazz


(import (jazz.builder)
        (jazz.io)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.utilities))


(class Workbench extends Product
  
  
  (slot products-table   initialize (make-table test: eq?))
  (slot categories-table initialize (make-table test: eq?))
  (slot resources-table  initialize (make-table test: equal?))
  ;; this is clearly not maintained up to date perfectly but it'll do for now
  (slot sources-table    initialize (make-table test: equal?))


  ;;;
  ;;;; Products
  ;;;
  
  
  (method public (get-products-table)
    products-table)
  
  
  (method public (find-product type-name)
    (table-ref products-table type-name #f))
  
  
  (method public (find-project type-name)
    {}
    @obsolete
    (let ((product (find-product type-name)))
      (if (is? product Project)
          product
        {})))
  
  
  (method public (require-project type-name)
    (either (find-project type-name)
            (error "Unable to find project: {s}" type-name)))


  ;;;
  ;;;; Files
  ;;;
  
  
  (method public (find-source source)
    (get-source-entry source))
  
  
  (method public (find-filename filename)
    (call/ec
      (function (return)
        (for-each-product-file
          (function (descendant)
            (when (ci=? (get-name~ (get-effective-source~ descendant)) filename)
              (return descendant))))
        {})))


  ;;;
  ;;;; Catalogs
  ;;;
  
  
  (method (catalog-output)
    {File Profile "settings" "Workbench.jcat"})
  
  
  (method public (load-catalogs)
    (with-cursor :wait
      (function ()
        (user-message "Loading catalogs...")
        (for-each-product
          (function (product)
            (when (get-catalog?~ product)
              (load-content~ (require-catalog~ product))))
          include-self?: #t)
        (user-message "Done"))))


  ;;;
  ;;;; Editable
  ;;;
  
  
  (method (get-effective-editable?)
    #t)


  ;;;
  ;;;; Add/Remove
  ;;;
  
  
  (method protected (add-to-product product name component)
    (typecase component
      ((Product-File)
       (when (is? component Product)
         (set-workbench~ component self)
         (set-parent-product~ component product)
         (table-set! products-table (type-name (class-of component)) component))
       (set-product~ component product)
       (let ((source (get-source~ component)))
         (add-source source component)
         (typecase component
           ((Resource-File)
            (let ((type (resource-type~ (resource-class~ component))))
              (add-resource type source)))
           ((Jazz-File)
            (add-entry name component)))))))
  
  
  (method protected (remove-from-product product name component)
    (typecase component
      ((Product-File)
       (when (is? component Product)
         (table-clear products-table (type-name (class-of component))))
       (let ((source (get-source~ component)))
         (remove-source source component)
         (typecase component
           ((Resource-File)
            (let ((type (resource-type~ (resource-class~ component))))
              (remove-resource type source)))
           ((Jazz-File)
            (remove-entry name)))))))


  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (for-each-product proc (include-self?: include-self? #f))
    (for-each-descendant
      (function (descendant level)
        (when (is? descendant Product)
          (proc descendant)))
      include-self?: include-self?))
  
  
  (method public (for-each-product-file proc (include-self?: include-self? #f))
    (for-each-descendant
      (function (descendant level)
        (when (is? descendant Product-File)
          (proc descendant)))
      include-self?: include-self?))
  
  
  (method public (for-each-jazz-file proc (include-self?: include-self? #f))
    (for-each-descendant
      (function (descendant level)
        (when (is? descendant Jazz-File)
          (proc descendant)))
      include-self?: include-self?))
  
  
  (method public (add-entry category-name entry)
    (table-set! categories-table category-name entry))
  
  
  (method public (remove-entry category-name)
    (table-clear categories-table category-name))
  
  
  (method public (get-entry category-name)
    (table-ref categories-table category-name #f))
  
  
  (method public (get-entry-source category-name)
    (let ((file (get-entry category-name)))
      (when file
        (get-source~ file))))
  
  
  (method (add-resource type source)
    (let* ((name (get-base~ source))
           (key (cons type name)))
      (table-set! resources-table key source)))
  
  
  (method (remove-resource type source)
    (let* ((name (get-base~ source))
           (key (cons type name)))
      (table-clear resources-table key)))
  
  
  (method public (get-resource type name)
    (let ((key (cons type name)))
      (table-ref resources-table key #f)))
  
  
  (method public (get-bitmap resource)
    (get-resource 'bitmap (get-name~ resource)))
  
  
  (method public (get-icon name)
    (get-resource 'icon name))
  
  
  (method public (add-source source entry)
    (when source
      (let ((name (get-name~ source)))
        (table-set! sources-table name (cons entry (table-ref sources-table name #f))))))
  
  
  (method public (remove-source source entry)
    (when source
      (let ((name (get-name~ source)))
        (table-set! sources-table name (remove! entry (table-ref sources-table name #f))))))
  
  
  (method public (get-source-entry source)
    #f
    @convert-this-uses-find-if-on-a-table
    (let* ((name (get-name~ source))
           (entries (table-ref sources-table name #f)))
      (find-if (function (entry)
                 (pathname=? (get-effective-source~ entry) source))
               entries)))


  ;;;
  ;;;; Index
  ;;;
  
  
  (method (find-workbench)
    self)


  ;;;
  ;;;; Update
  ;;;
  
  
  (method public (update)
    (empty-table products-table)
    (empty-table sources-table)
    (empty-table categories-table)
    (empty-table resources-table))


  ;;;
  ;;;; Designer
  ;;;
  
  
  @convert-descriptor
  (method meta (get-class-image)
    {Bitmap-Resource "ProjectsManager"})
    
  
  (method (get-presentation)
    "Workbench"
    @convert
    (format "Workbench - {a}"
            Current-Policy))
  
  
  @convert
  (method (can-cut-component?)
    #f)
  
  
  @convert
  (method (can-copy-component?)
    #f)
  
  
  @convert
  (method (can-rename-component?)
    #f)
  
  
  @convert
  (method (can-delete-component?)
    #f)
  
  
  @convert
  (method (can-move-component?)
    #f)
  
  
  @convert
  (method (get-addable-classes)
    (list
      Product-Group))))
