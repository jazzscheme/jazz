;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debugger
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debugger jazz


(export (jazz.debugger.autoload))
(import (jazz.debugger.autoload)
        (jazz.console)
        (jazz.debuggee)
        (jazz.jrm)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.library.listener)
        (jazz.literals)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities))


;;;
;;;; Debugger
;;;


(definition *debuggers*
  '())

(definition *current-debugger*
  {})


(definition with-debuggers-mutex
  (let ((mutex (make-mutex 'debuggers)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-debugger debugger)
  (with-debuggers-mutex
    (function ()
      (set! *debuggers* (append *debuggers* (list debugger))))))


(definition (unregister-debugger debugger)
  (with-debuggers-mutex
    (function ()
      (set! *debuggers* (remove! debugger *debuggers*)))))


(definition public (get-debuggers)
  *debuggers*)


(definition public (current-debugger)
  (when (not *current-debugger*)
    (set! *current-debugger* (new Debugger)))
  *current-debugger*)


;;;
;;;; Debugged
;;;


(definition public (debugged=? x y)
  (or (and (not x) (not y))
      (and x
           y
           (let ((dx (get-debugger~ x))
                 (dy (get-debugger~ y)))
             (and (eq? dx dy)
                  (same?~ x y))))))


;;;
;;;; State
;;;


(definition *debugged-states*
  (make-table test: debugged=?))


(definition (get-debugged-state debugged)
  (either (table-ref *debugged-states* debugged {})
          (let ((state (cons #f #f)))
            (table-set! *debugged-states* debugged state)
            state)))


(definition public (get-debugged-visit? debugged)
  (car (get-debugged-state debugged)))

(definition public (set-debugged-visit? debugged flag)
  (set-car! (get-debugged-state debugged) flag))


(definition public (get-debugged-problem? debugged)
  (cdr (get-debugged-state debugged)))

(definition public (set-debugged-problem? debugged flag)
  (set-cdr! (get-debugged-state debugged) flag))


;;;
;;;; Focus
;;;


(definition *focused-process*
  {})


(definition public (get-focused-process)
  *focused-process*)

(definition public (set-focused-process process)
  (set! *focused-process* process))


(definition public (focus-process process)
  (when (not (debugged=? process *focused-process*))
    (set! *focused-process* process)
    (let ((view (get-processes-view)))
      (when view
        (update~ view)))))


;;;
;;;; Break
;;;


(definition Once-Breaks
  (make-table test: eq?))


(definition public (add-break-once name)
  (table-set! Once-Breaks name #t))


(definition public (break-once name)
  (when (table-ref Once-Breaks name #f)
    (table-set! Once-Breaks name {})
    (break)))


(definition Once-Executes
  (make-table test: eq?))


(definition public (add-execute-once name)
  (table-set! Once-Executes name #t))


(definition public (execute-once name proc)
  (when (table-ref Once-Executes name #f)
    (table-set! Once-Executes name {})
    (proc)))


;;;
;;;; Console
;;;


(definition public (register-debugger-console process-proxy thread-proxy)
  (define (present)
    (let ((process-title (get-title~ process-proxy)))
      (if (not thread-proxy)
          process-title
        (format "{a} {a}" process-title (present-thread-name (get-name~ thread-proxy))))))
  
  (let ((manager (if (not thread-proxy) (get-console-manager) (get-repl-manager))))
    (let ((console (register-console~ manager (present))))
      (setup-debugger-console-ports console process-proxy thread-proxy)
      (object->serial console))))


(definition public (unregister-debugger-console console)
  (let ((text (serial->object console)))
    (let ((pump (get-console-pump~ text)))
      (when pump
        (thread-interrupt! pump
          thread-exit)))
    (unregister-console~ (get-console-text-manager text) text)))


(definition public (debugger-console-output console line)
  (let ((text (serial->object console)))
    (send-event
      (function ()
        (insert-formatted-line~ text line))))
  {})


(definition (setup-debugger-console-ports console process-proxy thread-proxy)
  (receive (head tail) (open-string-pipe)
    (set-console-port~ console head)
    (set-console-pump~ console (start-debugger-console-pump tail process-proxy thread-proxy))))


(definition (start-debugger-console-pump port process-proxy thread-proxy)
  (thread-start!
    (new-thread
      (function ()
        (let (iterate)
          (let ((line (read-line port)))
            (console-input~ process-proxy thread-proxy line)
            (iterate))))
      "Debugger Console Pump")))


;;;
;;;; Exception
;;;


(definition public (break-exception process exception frame accountable)
  @convert
  (let* ((message       (get-message~ exception))
         (closure-frame (essay frame (frame-toplevel-closure-frame frame)))
         (closure       (essay closure-frame (frame-procedure closure-frame)))
         (location      (essay closure (object-location accountable (closure-function closure)))))
    (let* ((process (get-process))
           (controller-debugger (get-controller-debugger))
           (controller-toplevel-hwnd (get-toplevel-hwnd~ controller-debugger)))
      (focus-process~ controller-debugger process)
      (select-foreground-window controller-toplevel-hwnd))
    (break-action type: 'error message: message location: location frame: frame)))


;;;
;;;; Calls
;;;


(definition public (on-call-step-over evt)
  (on-step-over evt))


(definition public (on-call-step-into evt)
  (if (get-shift?~ evt)
      (on-step-into-function evt)
    (on-step-into evt)))


(definition public (on-call-step-out evt)
  (if (get-shift?~ evt)
      (on-step-outside-function evt)
    (on-step-out evt)))


(definition public (on-call-run-to evt)
  (if (get-shift?~ evt)
      (on-run-to-result evt)
    (on-run-to-cursor evt)))


;;;
;;;; Events
;;;


(definition public (on-restart evt)
  (restart))


(definition public (on-break evt)
  @convert
  (break-next))


(definition public (on-continue evt)
  (if (not (debugging?))
      (bell)
    (continue)))


(definition public (on-step-over evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-over)))


(definition public (on-step-into evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into)))


(definition public (on-step-into-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into-function)))


(definition public (on-step-out evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-out)))


(definition public (on-step-outside-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-outside-function)))


(definition public (on-run-to-cursor evt)
  )


(definition public (on-run-to-result evt)
  )


(definition public (restart)
  (restart~ (get-loop~ (get-application))))


(definition public (continue)
  (continue~ (get-loop~ (get-application))))


(definition public (debugging?)
  (/= (get-level~ (get-loop~ (get-application))) 0))


;;;
;;;; View
;;;


(definition public (get-processes-view)
  (get-guest~ (singleton-docked Processes-View {})))


(definition public (get-threads-view)
  (get-guest~ (singleton-docked Threads-View {})))


(definition public (get-frames-view)
  (get-guest~ (singleton-docked Frames-View {})))


(definition public (get-details-view)
  (get-guest~ (singleton-docked Details-View {})))


;;;
;;;; Highlight
;;;


(definition public (get-visit-highlight)
  {Color red: 255 green: 205 blue: 205})


;;;
;;;; Thread
;;;


(definition public (present-thread-name name)
  (cond ((or (not name) (unspecified? name)) "Thread")
        ((eq? name 'primordial) "Primordial")
        (else (->string name))))


;;;
;;;; Frame
;;;


(definition public (active-frame)
  (let ((appl (get-application)))
    (let ((view (find-palette Processes-View)))
      (either (essay view (selected-frame~ view))
              (get-frame~ (get-loop~ (get-application)))))))


;;;
;;;; Break
;;;


(definition break-indicator
  {})


(definition Break-Color
  {Color name: Yellow})


(definition public (call-break message edit? location frame)
  (break-action message: message edit?: edit? location: location frame: frame))


(definition public (break-action (type: type 'break) (message: message {}) (edit?: edit? #t) (location: location {}) (frame: frame {}))
  (let* ((appl (get-application))
         (debugger (get-controller-debugger))
         (location (essay edit? location))
         (frame (essay edit? frame)))
    (if (is? debugger Remote-Proxy)
        (break-loop~ (get-loop~ (get-application)) type: type message: message frame: frame)
      (let ((code-location (essay location (new Jazz-Code-Location location))))
        (unwind-protect
            (break-loop~ (get-loop~ (get-application)) type: type message: message frame: frame proc: (function () (install-break edit? frame code-location)))
          (when edit?
            (uninstall-break)))))))


(definition (install-break edit? frame code-location)
  (catch (Location-Error err
                         (message-box (get-message~ err)))
    (when edit?
      (when code-location
        (let ((location (find-location~ code-location)))
          (receive (frame text range) location
            (fill~ text Break-Color (get-start~ range)))
          (set! break-indicator location)))
      (with-locked-update
        (function ()
          (let ((view (select-palette Processes-View workspace: 'debugger)))
            (when view
              (select-first-frame~ view frame))))))))


(definition (uninstall-break)
  (when break-indicator
    (catch (Location-Error err
                           (message-box (get-message~ err)))
      (receive (frame text range) break-indicator
        (unfill~ text (get-start~ range)))
      (set! break-indicator {}))))


;;;
;;;; Listeners
;;;


(definition listeners
  '())


(definition public (add-debugger-listener listener)
  (set! listeners (add-listener listener listeners)))


(definition public (remove-debugger-listener listener)
  (set! listeners (remove-listener listener listeners)))


(definition public (process-frame-change frame)
  (when listeners
    (let ((evt (new Event :frame-change (current-debugger) frame: frame)))
      (for-each (function (listener)
                  (invoke~ listener (current-debugger) evt))
                listeners)))))
