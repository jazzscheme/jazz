;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debugger
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debugger jazz


(export (jazz.debugger.autoload))
(import (jazz.debugger.autoload)
        (jazz.debuggee)
        (jazz.jrm)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.library.listener)
        (jazz.literals)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities))


;;;
;;;; Debugger
;;;


(definition *debuggers*
  '())

(definition *current-debugger*
  {})


(definition with-debuggers-mutex
  (let ((mutex (make-mutex 'debuggers)))
    (lambda (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-debugger debugger)
  (with-debuggers-mutex
    (function ()
      (set! *debuggers* (append *debuggers* (list debugger))))))


(definition (unregister-debugger debugger)
  (with-debuggers-mutex
    (function ()
      (set! *debuggers* (remove! debugger *debuggers*)))))


(definition public (get-debuggers)
  *debuggers*)


(definition public (current-debugger)
  (when (not *current-debugger*)
    (set! *current-debugger* (new Debugger)))
  *current-debugger*)


;;;
;;;; Process
;;;


(definition public (debugger-process=? x y)
  (let ((dx (essay x (get-debugger~ x)))
        (dy (essay y (get-debugger~ y))))
    (and (eq? dx dy)
         (process=?~ dx x y))))


(definition public (collect-debugger-processes (validate-liveness?: validate-liveness? #f))
  (let ((queue (new-queue)))
    (for-each (function (debugger)
                (enqueue-list queue (get-processes~ debugger validate-liveness?: validate-liveness?)))
              (get-debuggers))
    (queue-list queue)))


;;;
;;;; Selected
;;;


(definition *selected-debugger-process*
  {})


(definition public (get-selected-debugger-process)
  *selected-debugger-process*)


(definition public (set-selected-debugger-process process)
  (set! *selected-debugger-process* process)
  {})


(definition public (select-debugger-process process)
  (when (not (debugger-process=? process *selected-debugger-process*))
    (set! *selected-debugger-process* process)
    (let* ((appl (get-application))
           (icon (essay process (get-icon~ process)))
           (status (get-status-bar~ appl)))
      (when status
        (let ((item (locate-component~ status 'debugger)))
          (when item
            (set-icon~ item icon))))
      (let ((presented (essay process (present~ process))))
        (user-message (format "{a} selected" (if (not process) "None" presented)))))
    {}))


(definition public (select-next-debugger-process)
  @convert
  (let* ((rank (find processes *selected-debugger-process* test: debugger-process=?))
         (process (element processes (modulo (+ rank 1) (length processes)))))
    (select-debugger-process process)
    {}))


;;;
;;;; Break
;;;


(definition Once-Breaks
  (make-table test: eq?))


(definition public (add-break-once name)
  (table-set! Once-Breaks name #t))


(definition public (break-once name)
  (when (table-ref Once-Breaks name #f)
    (table-set! Once-Breaks name {})
    (break)))


(definition Once-Executes
  (make-table test: eq?))


(definition public (add-execute-once name)
  (table-set! Once-Executes name #t))


(definition public (execute-once name proc)
  (when (table-ref Once-Executes name #f)
    (table-set! Once-Executes name {})
    (proc)))


;;;
;;;; Exception
;;;


(definition public (break-exception process exception frame accountable)
  @convert
  (let* ((message       (get-message~ exception))
         (closure-frame (essay frame (frame-toplevel-closure-frame frame)))
         (closure       (essay closure-frame (frame-procedure closure-frame)))
         (location      (essay closure (object-location accountable (closure-function closure)))))
    (let* ((process (get-process))
           (controller-debugger (get-controller-debugger))
           (controller-toplevel-hwnd (get-toplevel-hwnd~ controller-debugger)))
      (select-debugger-process~ controller-debugger process)
      (select-foreground-window controller-toplevel-hwnd))
    (break-action type: 'error message: message location: location frame: frame)))


;;;
;;;; Calls
;;;


(definition public (on-call-step-over evt)
  (on-step-over evt))


(definition public (on-call-step-into evt)
  (if (get-shift?~ evt)
      (on-step-into-function evt)
    (on-step-into evt)))


(definition public (on-call-step-out evt)
  (if (get-shift?~ evt)
      (on-step-outside-function evt)
    (on-step-out evt)))


(definition public (on-call-run-to evt)
  (if (get-shift?~ evt)
      (on-run-to-result evt)
    (on-run-to-cursor evt)))


;;;
;;;; Events
;;;


(definition public (on-break evt)
  @convert
  (break-next))


(definition public (on-stop evt)
  (stop))


(definition public (on-toplevel evt)
  (toplevel))


(definition public (on-continue evt)
  (if (not (debugging?))
      (bell)
    (continue)))


(definition public (on-step-over evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-over)))


(definition public (on-step-into evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into)))


(definition public (on-step-into-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-into-function)))


(definition public (on-step-out evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-out)))


(definition public (on-step-outside-function evt)
  @convert
  (if (not (debugging?))
      (bell)
    (continue)
    (step-outside-function)))


(definition public (on-run-to-cursor evt)
  )


(definition public (on-run-to-result evt)
  )


(definition public (on-debuggers evt)
  (select-palette Debuggers-View workspace: 'debugger focus?: #t))


(definition public (on-variables evt)
  (select-palette Variables-View workspace: 'debugger focus?: #t))


(definition public (stop)
  (stop~ (get-loop~ (get-application))))


(definition public (toplevel)
  (toplevel~ (get-loop~ (get-application))))


(definition public (continue)
  (continue~ (get-loop~ (get-application))))


(definition public (debugging?)
  (/= (get-level~ (get-loop~ (get-application))) 0))


;;;
;;;; Debuggee
;;;


(definition public (on-next-process evt)
  (select-next-debugger-process))


;;;
;;;; View
;;;


(definition public (get-debuggers-view)
  (get-guest~ (singleton-docked Debuggers-View {})))


;;;
;;;; Frame
;;;


(definition public (active-frame)
  (let ((appl (get-application)))
    (let ((view (find-palette Debuggers-View)))
      (either (essay view (selected-frame~ view))
              (get-frame~ (get-loop~ (get-application)))))))


;;;
;;;; Break
;;;


(definition break-indicator
  {})


(definition Break-Color
  {Color name: Yellow})


(definition public (call-break message edit? location frame)
  (break-action message: message edit?: edit? location: location frame: frame))


(definition public (break-action (type: type 'break) (message: message {}) (edit?: edit? #t) (location: location {}) (frame: frame {}))
  (let* ((appl (get-application))
         (debugger (get-controller-debugger))
         (location (essay edit? location))
         (frame (essay edit? frame)))
    (if (is? debugger Remote-Proxy)
        (break-loop~ (get-loop~ (get-application)) type: type message: message frame: frame)
      (let ((code-location (essay location (new Jazz-Code-Location location))))
        (unwind-protect
            (break-loop~ (get-loop~ (get-application)) type: type message: message frame: frame proc: (function () (install-break edit? frame code-location)))
          (when edit?
            (uninstall-break)))))))


(definition (install-break edit? frame code-location)
  (catch (Location-Error err
                         (message-box (get-message~ err)))
    (when edit?
      (when code-location
        (let ((location (find-location~ code-location)))
          (receive (frame text range) location
            (fill~ text Break-Color (get-start~ range)))
          (set! break-indicator location)))
      (with-locked-update
        (function ()
          (let ((view (select-palette Debuggers-View workspace: 'debugger)))
            (when view
              (select-first-frame~ view frame))))))))


(definition (uninstall-break)
  (when break-indicator
    (catch (Location-Error err
                           (message-box (get-message~ err)))
      (receive (frame text range) break-indicator
        (unfill~ text (get-start~ range)))
      (set! break-indicator {}))))


;;;
;;;; Listeners
;;;


(definition listeners
  '())


(definition public (add-debugger-listener listener)
  (set! listeners (add-listener listener listeners)))


(definition public (remove-debugger-listener listener)
  (set! listeners (remove-listener listener listeners)))


(definition public (process-frame-change frame)
  (when listeners
    (let ((evt (new Event :frame-change (current-debugger) frame: frame)))
      (for-each (function (listener)
                  (invoke~ listener (current-debugger) evt))
                listeners)))))
