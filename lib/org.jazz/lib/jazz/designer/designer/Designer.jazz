;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Designer
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.designer.designer.Designer jazz


(import (jazz.designer)
        (jazz.io)
        (jazz.jml)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.utilities))


(class Designer extends Object
  
  
  (slot form      initialize {})
  (slot reference initialize {})
  (slot listeners initialize '())
  (slot modified? initialize #f)

  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method (initialize (form: form {}) (reference: reference {}))
    (nextmethod)
    (set! reference~self reference)
    (setup-form form))
  
  
  (method (setup-form frm)
    (if (not frm)
        (set! form (new Form textual?: #f origin: (class-of reference) action: 'new model-name: 'install))
      (let ((origin (get-origin~ frm)))
        (if (file? origin)
            (setup-file-form frm)
          (setup-class-form frm)))))
  
  
  ;; Setting form to a copy until saving is a tempting approach,
  ;; but fails because we absolutly need pointer equality as a test
  ;; for embed-form to work correctly with anonymous forms.
  ;; So the approach taken will be more like relational databases
  ;; where we modify the database directly but keep a log of
  ;; transactions in order to be able to rollback changes (and it
  ;; makes lots of sense to, because a designer is really the interface
  ;; by which Jazz's object-oriented databases are updated!).
  ;;
  ;; Or maybe simply take a copy before the first modification is made
  ;; (lazy approach) and if we need to rollback, set the original form
  ;; to the copy.
  (method (setup-class-form frm)
    (set! form frm))
  
  
  (method (setup-file-form frm)
    (set! form frm))
  
  
  ;;;
  ;;;; Access
  ;;;
  

  (method public (get-form)
    form)
  

  (method public (set-form value)
    (set! form value))
  

  (method public (get-reference)
    reference)


  (method public (get-modified?)
    modified?)


  (method public (set-modified? state)
    (set! modified? state))
  
  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method public virtual (save (default-extension: default-extension {}) (extensions: extensions '()))
    (with-cursor :wait
      (function ()
        (let ((origin (get-origin~ form)))
          (if (not origin)
              (save-as default-extension: default-extension extensions: extensions)
            (save-content))))))
  
  
  (method public (save-to file)
    (if (not file)
        (save-as)
      (set-origin~ form file)
      (save-to-file file)
      (set-modified? #f)))
  
  
  (definition Default-Extension
    "jml")
  
  (definition Default-Extensions
    '(("JML Files" . "jml")))
  
  
  (method (save-as (default-extension: default-extension {}) (extensions: extensions '()))
    (set-origin~ form (choose-new-file default-extension: (either default-extension Default-Extension) extensions: (either extensions Default-Extensions)))
    (save-content))
  
  
  (method (save-content)
    (let ((origin (get-origin~ form)))
      (if (file? origin)
          (save-to-file origin)
        (save-to-class origin)))
    ;;@quicky-to-test
    (set-modified? #f))
  
  
  (method (save-to-class class)
    ;;(debug 'saving self 'to class)
    (let* ((appl (get-application))
           (class-name (type-name class))
           (where (if (eq? form (get-self-form~ class)) :form :new-form))
           (location (list class-name where))
           (code-location (new Jazz-Code-Location location))
           (code-source (find-source~ code-location))
           (being-edited? (find-document~ appl code-source))
           (output (saved-form #t 2)))
      ;; Invoking the Interpreter is the simplest way of creating
      ;; the new definition that did not already exist in the class...
      @convert
      (when (eq? where :new-form)
        (evaluate~ Interpreter (list '(form (<install>))) {} class (list Language)))
      @convert
      (set-class-form~ class form)
      #f
      @convert
      (catch (Location-Error err
               (error (get-message~ err)))
        (receive (frame text range) (find-location~ code-location)
          (with-update-locked~ text
            (function ()
              (set-selection~ text range)
              (when (eq? where :new-form)
                (insert-string~ text (format "{%}{%}{%}  ")))
              (insert-string~ text output)))
          (if (not being-edited?)
              (begin
                (save~ text)
                (close~ frame))
            (set-visible?~ frame #t)
            (bring-to-front~ frame)
            (acquire-focus~ frame))))))
  
  
  (method (save-to-file file)
    (if (and (exists?~ file) (read-only?~ file))
        (message-box (format "Sorry, unable to save to read-only file: {s}" file))
      (call-with-output-file (list path: (parse~ file) char-encoding: 'UTF-8)
        (function (printer)
          (output-header (get-model-name~ form) printer)
          (format printer "{%}{%}")
          (print-to #f 0 printer)))))


  (method public (saved-form class-form? level (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (let ((printer (open-output-string)))
      (print-to class-form? level printer space-properties?: space-properties? align-name?: align-name?)
      (get-output-string printer)))
  
  
  (method public (print-to class-form? level printer (space-properties?: space-properties? #t) (align-name?: align-name? #t))
    (when class-form?
      (format printer "(form{%}"))
    (let ((node (form->node form))
          (base (if class-form? level level)))
      (pretty-print~ node printer form?: class-form? base: base space-properties?: space-properties? align-name?: align-name?))
    (if class-form?
        (format printer ")")
      (format printer "{%}")))
  
  
  ;;;
  ;;;; Design
  ;;;
  
  
  (method public virtual (set-name component name (branch: branch #t) (design-events?: design-events? #t) (undoable?: undoable? #t))
    (let* ((branch (target-branch branch))
           (form (find-form component branch))
           (old-name (get-name~ component))
           (old-presentation (get-presentation~ component)))
      (for-each-branch~ (either branch reference)
        (function (branch)
          (let ((form (get-client-form~ branch)))
            (when form
              (let* ((ancestry (component-ancestry component))
                     (component-form (owned-form form ancestry)))
                (when (and component-form (neq? (get-action~ component-form) 'install))
                  (set-name~ component-form name)))))))
      (set-name~ component name)
      (set-name~ form name)
      (when design-events?
        (fire-name-change component name old-name undoable?)
        (let ((presentation (get-presentation~ component)))
          (fire-presentation-change component presentation old-presentation undoable?))
        (let ((property (property-field component 'name-info)))
          (fire-property-change branch component property name undoable?)))
      (set-modified? #t)))
  
  
  (method public (set-tag-module component tag-module)
    (let ((form (find-form component {})))
      (set-tag-module~ form tag-module)
      (set-modified? #t)))
  
  
  (method public virtual (set-property component/path property value (branch: branch #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let ((branch (target-branch branch)))
      ;; Quick fix for the special case of setting a property of the active branch
      (if (eq? component/path branch)
          (set-property component/path property value branch: {} design-events?: design-events? undoable?: undoable?)
        (let ((installed? (or (not branch) (installed?~ branch)))
              (path? (is? component/path Path)))
          (if (and path? (not installed?))
              (let ((form (follow-form~ component/path (if branch (get-client-form~ branch) form))))
                (set-property~ form property value))
            (let* ((component (if path? (follow-component~ component/path reference) component/path))
                   (property (if component (property-field component property) property)))
              (assert property)
              ;; This validation should probably also be done in other operations...
              (when (and component (not installed?))
                (let ((creator-branch (get-creator-branch~ component)))
                  ;; This test is not 100% correct as the creator-branch can be any parent branch of branch
                  (when (and creator-branch (neq? branch (get-creator-branch~ component)))
                    (error "Unable to modify an explicit branch using a component having a different branch creator"))))
              (receive (form restore) (find-form component branch restore?: #t)
                (receive (next-form next-restore) (find-next-branch branch component property)
                  (set-property~ form property value)
                  (when installed?
                    (if (not next-form)
                        (let ((old-value (read-property component property)))
                          (when (and restore (not (has-property?~ restore property)))
                            (set-property~ restore property old-value))
                          (let* ((fire-presentation? (essay design-events? (presentation-property?~ component property)))
                                 (old-presentation (essay fire-presentation? (get-presentation~ component))))
                            (write-property component property value)
                            (when design-events?
                              (when fire-presentation?
                                (let ((presentation (get-presentation~ component)))
                                  (fire-presentation-change component presentation old-presentation undoable?)))
                              (fire-property-change branch component property value undoable?))))
                      (when (and restore (not (has-property?~ restore property)))
                        (set-property~ restore property (get-property~ next-restore property)))
                      (set-property~ next-restore property value)))))))
          (set-modified? #t)))))
  
  
  ;; This works well really only with branches because else we don't have restore information
  (method public virtual (remove-property component/path property default-value (branch: branch #t) (design-events?: design-events? #t) (undoable?: undoable? #f))
    (let* ((branch (target-branch branch))
           (installed? (or (not branch) (installed?~ branch)))
           (path? (is? component/path Path))
           (component (if path? (follow-component~ component/path reference) component/path))
           (property (property-field component property)))
      (assert property)
      (receive (form restore) (find-form component branch restore?: #t)
        (receive (next-form next-restore) (find-next-branch branch component property)
          (when (has-property?~ form property)
            (let ((value (if (not restore) default-value (get-property~ restore property))))
              (when installed?
                (if (not next-form)
                    (begin
                      (write-property component property value)
                      (when design-events?
                        (fire-property-change branch component property value undoable?)))
                  (set-property~ next-restore property value))))
            (remove-property~ form property)
            (when restore
              (remove-property~ restore property))
            (set-modified? #t))))))
  
  
  (method public virtual (add-child child parent (branch: branch #t) (name: name {}) (properties: properties '()) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (let ((branch (target-branch branch)))
      (set-parent~ child parent)
      (receive (form restore) (find-form parent branch restore?: #t)
        (let ((child-form (new Form textual?: #f context: (get-context~ form) action: 'new model-name: (identifier-name (type-name (class-of child))))))
          (set-form~ child child-form)
          (add-form~ parent form child-form))
        (when restore
          (remember-creation~ restore self child))
        (when name
          (set-name child name branch: branch design-events?: #f))
        (set-creator~ child reference)
        (add-to-index~ reference (get-name~ child) child)
        (when properties
          (for-each-property (function (property value)
                               (set-property child property value branch: branch design-events?: design-events?))
            properties))
        ;; the two sexpr where toggled so that the event occurs
        ;; after the properties are set (check that this doesn't
        ;; break the MetaModeler who calls this at 3 places)
        (when design-events?
          (fire-child-add child parent descendant?))
        (set-modified? #t)))
    child)

  
  (method public virtual (remove-child child (branch: branch #t) (design-events?: design-events? #t))
    (let ((branch (target-branch branch)))
      (if (eq? child reference)
          (error "The reference component cannot be removed")
        (let ((effective (either branch reference))
              (owner (find-owner child)))
          ;; the (and owner) part is a try
          (if (and owner (neq? owner effective))
              (error "Component cannot be removed from non owner {a} {a}" (if branch "branch" "root") (get-presentation~ effective))
            (let* ((name (get-name~ child))
                   (parent (get-parent~ child))
                   (parent-form (find-form parent branch))
                   (form (find-form child branch))
                   (purge-references
                     (function (form)
                       (when form
                         (let* ((parent-ancestry (component-ancestry parent))
                                (parent-form (owned-form form parent-ancestry)))
                           (when parent-form
                             (let ((child-form (find-child~ parent-form name)))
                               (when child-form
                                 (remove-child~ parent-form child-form)))))))))
              (for-each-branch~ effective
                (function (branch)
                  (purge-references (get-client-form~ branch))
                  (purge-references (get-restore-form~ branch))))
              (close~ child)
              (remove-child~ parent-form form)
              (when design-events?
                (fire-child-remove child parent))
              (set-modified? #t)))))))
  
  
  (method public (remove-children parent (branch: branch #t) (design-events?: design-events? #t))
    (for-each (function (child)
                (remove-child child branch: branch design-events?: design-events?))
              (get-children~ parent)))
  
  
  ;; This is not a 100% complete solution as this for instance will
  ;; not restore the correct property values as remove-property would...
  (method public virtual (purge-branch component (branch: branch #t) (design-events?: design-events? #t))
    (let* ((branch (target-branch branch))
           (parent (get-parent~ component))
           (parent-form (find-form parent branch)))
      (receive (form restore-form) (find-form component branch restore?: #t)
        (install-form~ component restore-form component {} {})
        (remove-child~ parent-form form))))
  
  
  (method public virtual (move-components components destination (branch: branch #t))
    (let* ((components (remove-redundant-descendants components))
           (parcels (package-components components))
           (name-resolution (verify-name-conflicts parcels destination)))
      (delete-components components branch: branch)
      (prog1 (instantiate-parcels parcels destination branch: branch name-resolution: name-resolution design-events?: #t descendant?: #f)
        (set-modified? #t))))
  
  
  (method public virtual (send-before child target (branch: branch #t))
    (let* ((branch (target-branch branch))
           (parent (get-parent~ child))
           (parent-form (find-form parent branch))
           (child-form (find-form child branch))
           (target-form (essay target (find-form target branch))))
      (send-before~ child target)
      (send-child-before~ parent-form child-form target-form)
      (fire-send-before child parent target)
      (set-modified? #t)))
  
  
  (method public (send-to-back child (branch: branch #t))
    (send-before child (first-child~ (get-parent~ child)) branch: branch))
  
  
  (method public (bring-to-front child (branch: branch #t))
    (send-before child {} branch: branch))
  
  
  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (cut-components components)
    (let ((components (remove-redundant-descendants components)))
      (copy-components components)
      (delete-components components)))
  
  
  (method public virtual (copy-components components)
    (let ((components (remove-redundant-descendants components)))
      (let ((text (copy-components-text components)))
        (set-jazz-clipboard :jazz-parcels text))))
  
  
  (method public (copy-components-text components (branch: branch {}))
    @convert-printer
    (let ((printer (new (get-printer-class)))
          (output (open-output-string))
          (parcels (package-components components branch: branch)))
      (format output "(")
      (for-each (function (parcel)
                  (format output "~{{a} " (type-name (class-of parcel)))
                  (format output "{a} " (get-process-id~ parcel))
                  (format output "{a} " (get-object-id~ parcel))
                  (format output "(")
                  (for-each (function (form)
                              (print-form~ printer form 0 output))
                            (get-content~ parcel))
                  (format output ")")
                  (format output "}"))
                parcels)
      (format output ")")
      (get-output-string output)))
  
  
  (method public virtual (paste-clipboard parent (branch: branch #t) (design-events?: design-events? #t))
    (let ((parcels (get-jazz-parcels)))
      (paste-parcels parcels parent branch: branch design-events?: design-events?)))
  
  
  (method public virtual (paste-parcels parcels parent (branch: branch #t) (design-events?: design-events? #t) (reporter: reporter {}))
    (let* ((parent (determine-paster~ parent))
           (name-resolution (verify-name-conflicts parcels parent)))
      (prog1 (instantiate-parcels parcels parent branch: branch name-resolution: name-resolution design-events?: design-events? descendant?: #f reporter: reporter)
        (set-modified? #t))))
  
  
  (method public virtual (paste-properties components (branch: branch #t) (design-events?: design-events? #t))
    (let ((parcel (car (get-jazz-parcels))))
      (paste-parcel-properties parcel components branch: branch design-events?: design-events?)))
  
  
  (method public (paste-parcel-properties parcel components (branch: branch #t) (design-events?: design-events? #t))
    (let ((forms (get-content~ parcel)))
      (for-each (function (component)
                  (for-each (function (form)
                              (instantiate-properties component (get-properties~ form) branch design-events?))
                            forms))
                components)
      (set-modified? #t)))
  
  
  (method public virtual (delete-components components (branch: branch #t) (design-events?: design-events? #t))
    (let ((components (remove-redundant-descendants components)))
      (for-each (function (component)
                  (delete-component component branch: branch design-events?: design-events?))
                components)))
  
  
  (method public virtual (delete-component component (branch: branch #t) (design-events?: design-events? #t))
    (remove-child component branch: branch design-events?: design-events?))
  
  
  ;; For some operations like cut, copy, delete and move, having a component that
  ;; is a descendant of another one doesn't make sense and can lead to problems...
  (method (remove-redundant-descendants components)
    components
    ;; waiting for a bug fix in the tree selection update that this have uncovered
    @wait
    (collect-if (function (component)
                  (not (some? (function (target)
                                (and (neq? component target)
                                     (has-parent?~ component target)))
                              components)))
                components))
  
  
  ;;;
  ;;;; Package
  ;;;
  
  
  (method (package-components components (branch: branch {}))
    (map (function (component)
           (package-component component branch: branch))
         components))
  
  
  (method (package-component component (branch: branch {}))
    (unimplemented 'package-component)
    @convert
    (let ((ancestry (component-ancestry component))
          (forms '()))
      (iterate-branch-spine~ reference
        (function (owner form)
          (let ((form (owned-form form ancestry)))
            (when form
              (set! forms (cons form forms)))))
        branch: branch)
      (if (and forms (memq? (get-action~ (car forms)) '(new install)))
          (new Component-Parcel (GetCurrentProcessId) (object->serial component) forms)
        (error "Unable to find owner for {t}" component))))
  
  
  ;;;
  ;;;; Instantiate
  ;;;
  
  
  (method public virtual (instantiate-parcels parcels parent (branch: branch #t) (name-resolution: name-resolution {}) (design-events?: design-events? #t) (descendant?: descendant? #f) (reporter: reporter {}))
    (map (function (parcel)
           (when reporter
             (user-message~ reporter "Pasting {a}..." (get-master-name~ parcel)))
           (prog1 (instantiate-parcel parcel parent branch: branch name-resolution: name-resolution design-events?: design-events? descendant?: descendant?)
             (when reporter
               (step-it~ reporter))))
         parcels))
  
  
  (method public virtual (instantiate-parcel parcel parent (branch: branch #t) (name-resolution: name-resolution {}) (design-events?: design-events? #t) (descendant?: descendant? #f))
    (let* ((forms (get-content~ parcel))
           (master (car forms))
           (name (get-name~ master)))
      (let* ((brothers (get-children~ parent))
             (domain (map component-name brothers))
             (equal (sort-predicate 'equal))
             (conflict? (and name (member? name domain test: equal))))
        (when conflict?
          (case name-resolution
            ((rename) (set! name (unique-name name domain))
             (for-each (function (form)
                         (set-name~ form name))
                       forms))
            ((override) (let ((conflicts (name-conflicts (list name) brothers)))
                          (delete-components conflicts branch: branch))))))
      (let ((component (instantiate-form name name-resolution master parent branch design-events? descendant?)))
        (for-each (function (form)
                    (instantiate-form name {} form parent branch design-events? descendant?))
                  (cdr forms))
        component)))
  
  
  (method public virtual (instantiate-form name name-resolution form parent branch design-events? descendant?)
    (let ((component (instantiate-component name name-resolution form parent branch design-events? descendant?)))
      (when component
        (instantiate-properties component (get-properties~ form) branch design-events?)
        (instantiate-children component (get-children~ form) branch design-events?)
        component)))

  
  (method public virtual (instantiate-component name name-resolution form parent branch design-events? descendant?)
    (let ((action (get-action~ form)))
      (case action
        ((new) (instantiate-new-component name form parent branch design-events? descendant?))
        ((modify locate) (find-to-modify~ parent (get-name~ form) (sort-predicate 'equal)))
        (else (error "Unsupported form action: {t}" action)))))
  
  
  (method public virtual (instantiate-new-component name form parent branch design-events? descendant?)
    (let ((component (instantiate-component~ form parent: parent)))
      (add-child component parent branch: branch name: name design-events?: design-events? descendant?: descendant?)
      component))
  
  
  (method public virtual (instantiate-properties component properties branch design-events?)
    (for-each-property (function (property value)
                         (set-property component property value branch: branch design-events?: design-events? undoable?: #f))
                       properties))

  
  (method public virtual (instantiate-children component children branch design-events?)
    (for-each (function (form)
                (instantiate-form (get-name~ form) {} form component branch design-events? #t))
              children))
  
  
  ;;;
  ;;;; Unique
  ;;;
  
  
  (method protected virtual (unique-name name domain)
    (let ((unique-name (unique-domain-name (->string name) (map ->string domain) separator: (unique-separator))))
      (if (symbol? name)
          (string->symbol unique-name)
        unique-name)))
  
  
  (method protected virtual (unique-separator)
    "_")
  
  
  ;;;
  ;;;; Conflicts
  ;;;
  
  
  (method public (verify-name-conflicts parcels destination)
    (let* ((names (map (function (parcel) (get-master-name~ parcel)) parcels))
           (children (get-children~ destination))
           (conflicts (name-conflicts names children)))
      (when conflicts
        (confirm-name-resolution parcels children conflicts))))
  
  
  (method (name-conflicts names children)
    (let ((equal (sort-predicate 'equal)))
      (collect-if (function (child)
                    (some? (function (name)
                             (equal (get-name~ child) name))
                           names))
                  children)))
  
  
  (method protected virtual (confirm-name-resolution parcels children conflicts)
    (unimplemented 'confirm-name-resolution)
    @convert
    (if (every? (function (parcel)
                  (let ((equal (sort-predicate 'equal))
                        (process-id (get-process-id~ parcel))
                        (component-id (get-object-id~ parcel))
                        (name (get-master-name~ parcel)))
                    (and (= process-id (GetCurrentProcessId))
                         (some? (function (child)
                                  (and (= component-id (object->serial child))
                                       (equal name (get-name~ child))))
                                children))))
                parcels)
        'rename
      (let* ((header "The following conflicts where detected. Override destination?")
             (text (present-conflicts header conflicts))
             (code (message-box text type: 'question)))
        (case code
          ((yes) 'override)
          ((no) (throw-cancel))))))
  
  
  (method (present-conflicts header conflicts)
    (let ((fact (new List-Factory)))
      (put~ fact header)
      (for-each (function (conflict)
                  (put~ fact (list :bulleted (->string (get-name~ conflict)))))
                conflicts)
      (get-output~ fact)))
  
  
  ;;;
  ;;;; View
  ;;;
    
  
  ;; This special support for views is not clean, but it is better
  ;; than having it directly inside add-child where it was before!
  (method public virtual (add-view child parent (position: position {}) (centered?: centered? #f) (visible?: visible? #t) . others)
    (apply add-child child parent others)
    (when position
      (set-property child 'position position))
    (when centered?
      (let ((size (get-size~ child)))
        (move-figure~ child (- (quotient (get-width~ size) 2)) (- (quotient (get-height~ size) 2)))))
    (when visible?
      (set-visible?~ child #t))
    (set-modified? #t))
  
  
  ;;;
  ;;;; Find
  ;;;
  
  
  (method (find-form component branch (restore?: restore? #f) (error?: error? #t))
    (let* ((ancestry (component-ancestry component))
           (branch-form (if branch (get-client-form~ branch) form))
           (restore-form (essay restore? branch (get-restore-form~ branch)))
           (form (embed-form branch-form ancestry))
           (restore (essay restore-form (embed-form restore-form ancestry))))
      (if (and error? (not form))
          (error "Unable to locate target form")
        (if restore?
            (values form restore)
          form))))
  

  (method (embed-form form ancestry)
    (for-each (function (cpn)
                (let ((children (get-children~ form))
                      (cpn-form (get-form~ cpn)))
                  (if (not cpn-form)
                      (embed-new-form form {} #f)
                    (if (memq? cpn-form children)
                        (set! form cpn-form)
                      (let ((restore-form (find-in children cpn key: (function (form) (essay (is? form Restore-Form) (get-component~ form))))))
                        (if restore-form
                            (set! form restore-form)
                          (let ((name (get-name~ cpn)))
                            (if (not name)
                                (error "Component {t} must be named to allow modification" cpn)
                              (let ((subform (find-in children name key: form-name test: equal?)))
                                (if (not subform)
                                    (set! form (embed-new-form form name))
                                  (set! form subform)))))))))))
              ancestry)
    form)
  
  
  (method (embed-new-form form name)
    (let ((subform (new Form action: 'modify name: name)))
      (add-child~ form subform)
      subform))
  
  
  (method (target-branch branch)
    (cond ((eq? branch #t) (get-active-branch~ reference))
          ((is? branch Path) (follow-component~ branch reference))
          (else branch)))
  
  
  (method (component-ancestry component)
    (let ((ancestry '())
          (scan component))
      (while (neq? scan reference)
        (set! ancestry (cons scan ancestry))
        (set! scan (get-parent-component~ scan))
        (when (not scan)
          (error "{t} is not a descendant of the reference component {t}" component reference)))
      ancestry))
  
  
  ;;;
  ;;;; Owner
  ;;;
  
  
  (method public (find-owner component (property {}))
    (let ((ancestry (component-ancestry component)))
      (continuation-capture
        (function (return)
          (iterate-branch-spine~ reference
            (function (owner form)
              (when form
                (let ((form (owned-form form ancestry)))
                  (when (and form
                             (or (and (not property) (eq? (get-action~ form) 'new))
                                 (and property (has-property?~ form property))))
                    (continuation-return return owner))))))
          {}))))
  
  
  (method (find-next-branch branch component property)
    (if (and branch (not (installed?~ branch)))
        (values {} {})
      (let ((lower (get-installed-branches~ (either branch reference)))
            (ancestry (component-ancestry component)))
        (continuation-capture
          (function (return)
            (for-each (function (branch)
                        (let ((client-form (get-client-form~ branch)))
                          (when client-form
                            (let ((form (owned-form client-form ancestry)))
                              (when (and form (has-property?~ form property))
                                (continuation-return return (values form (owned-form (get-restore-form~ branch) ancestry))))))))
                      lower)
            (values {} {}))))))
  
  
  (method (owned-form form ancestry)
    (continuation-capture
      (function (return)
        (for-each (function (cpn)
                    (let ((children (get-children~ form))
                          (cpn-form (get-form~ cpn)))
                      (if (not cpn-form)
                          (continuation-return return {})
                        (if (memq? cpn-form children)
                            (set! form cpn-form)
                          (let ((name (get-name~ cpn)))
                            (if (not name)
                                (continuation-return return {})
                              (let ((subform (find-in children name key: form-name test: equal?)))
                                (if (not subform)
                                    (continuation-return return {})
                                  (set! form subform)))))))))
                  ancestry)
        form)))
  
  
  ;;;
  ;;;; Value
  ;;;
  
  
  ;; Until a fully generic solution, these methods implement the following special case:
  ;; - the branch must be the owner of the property (i.e. have set it)
  
  
  (method public (get-name path (branch: branch #t))
    (let* ((branch (target-branch branch))
           (form (if branch (get-client-form~ branch) form)))
      (get-name~ (follow-form~ path form))))
  
  
  (method public (get-property path property (branch: branch #t))
    (let* ((branch (target-branch branch))
           (form (if branch (get-client-form~ branch) form)))
      (get-property~ (follow-form~ path form) property)))
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method public (edit-form)
    (let ((appl (get-application))
          (origin (get-origin~ form)))
      (if (file? origin)
          (edit-document~ appl origin)
        (let ((location (new Jazz-Code-Location (append (form-location) (list 2)))))
          (edit~ location)))))
  
  
  (method public (form-location)
    @convert
    (let ((origin (get-origin~ form)))
      (if (file? origin)
          (unimplemented 'form-location)
        (append (get-category-location origin)
                (list 'class-form)))))
  
  
  ;;;
  ;;;; Fire
  ;;;
  
  
  (method (fire-name-change component name old-name undoable?)
    (for-each (function (designer)
                (process-name-change~ designer component name old-name undoable?))
              (get-designers~ component)))
  
  
  (method (fire-presentation-change component presentation old-presentation undoable?)
    (for-each (function (designer)
                (process-presentation-change~ designer component presentation old-presentation undoable?))
              (get-designers~ component)))
  
  
  (method (fire-property-change branch component property value undoable?)
    (for-each (function (designer)
                (process-property-change~ designer branch component property value undoable?))
              (get-designers~ component)))
  
  
  (method (fire-child-add child parent descendant?)
    (for-each (function (designer)
                (process-child-add~ designer child parent descendant?))
              (get-designers~ parent)))
  
  
  (method (fire-child-remove child parent)
    (for-each (function (designer)
                (process-child-remove~ designer child parent))
              (get-designers~ child)))
  
  
  (method (fire-send-before child parent target)
    (for-each (function (designer)
                (process-send-before~ designer child parent target))
              (get-designers~ child)))
  
  
  ;;;
  ;;;; Listeners
  ;;;
  
  
  (method public (add-designer-listener listener)
    (set! listeners (add-listener listener listeners)))
  
  
  (method public (remove-designer-listener listener)
    (set! listeners (remove-listener listener listeners)))

  
  (method (process-name-change component name old-name undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :name-change self component: component name: name old-name: old-name undoable?: undoable?)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-presentation-change component presentation old-presentation undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :presentation-change self component: component presentation: presentation old-presentation: old-presentation undoable?: undoable?)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-property-change branch component property value undoable?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :property-change self branch: branch component: component property: property value: value undoable?: undoable?)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-add child parent descendant?)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-add self child: child parent: parent descendant?: descendant?)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-child-remove child parent)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :child-remove self child: child parent: parent)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method (process-send-before child parent target)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :send-before self child: child parent: parent target: target)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-refresh component what)
    (when (not-null? listeners)
      (let ((evt (new Designer-Event :refresh self component: component what: what)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  listeners))))

  
  (method public (process-user-event event)
    (when (not-null? listeners)
      (for-each (function (listener)
                  (invoke~ listener self event))
                listeners)))))
