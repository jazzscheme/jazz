;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Development
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.development jazz


(import (jazz.development.syntax (phase syntax))
        (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.language.jazz)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.workspace)
        (jazz.utilities)
        (jazz.literals))


;;;
;;;; Console
;;;


(definition public Interactive-Object
  {})


(definition public (in (object {}))
  (set! Interactive-Object object))


(definition public (hex n)
  (format "#x{x}" n))


;;;
;;;; Inspect
;;;


(definition public (inspect object (kind :value))
  (let ((appl (get-application))
        (title (format "Inspector - {a}" object)))
    (new-frame Inspector-View host-title: title debuggee: (get-local-debuggee~ appl) client: (cons object kind))))


(definition public (inspect-form form/component)
  @need-to-convert
  (with-text-inspector
    (function (output)
      (let ((form (if (is? form/component Form) form/component (get-form~ form/component)))
            (printer (new Form-Printer)))
        (print-form~ printer form 0 output)))))


(definition public (inspect-branches component)
  @need-to-convert
  (with-text-inspector
    (function (output)
      (let ((first? #t))
        (for-each-branch~ component
          (function (branch)
            (if first?
                (set! first? #f)
              (format output "{%}{%}"))
            (format output "{a}{%}" (get-name~ branch))
            (let ((form (get-restore-form~ branch)))
              (if (not form)
                  (format output " {}{%}")
                (let ((printer (new Form-Printer)))
                  (print-form~ printer form 0 output))))))))))


(definition (with-text-inspector proc)
  (let ((file (create-temporary-file)))
    (call-with-output-file (parse~ file)
      proc)
    (let* ((workspace (get-name~ (selected-workspace)))
           (frame (new-frame Jazz-Text-View host-visible?: #f host-workspace: workspace))
           (text (get-guest~ frame)))
      (set-moniker~ (get-controller~ text) file)
      (set-caret~ text (text-beginning~ text))
      (set-modified?~ text #f)
      (bring-to-front~ frame)
      (set-visible?~ frame #t))))


@wait-to-slow
(definition (with-text-inspector proc)
  @convert-text-printer
  (let* ((workspace (get-name~ (selected-workspace)))
         (frame (new-frame Jazz-Text-View host-visible?: #f host-workspace: workspace))
         (text (get-guest~ frame))
         (output (new Text-Printer text)))
    (proc output)
    (set-caret~ text (text-beginning~ text))
    (set-modified?~ text #f)
    (bring-to-front~ frame)
    (set-visible?~ frame #t)))


;;;
;;;; Edition
;;;


(definition public (edit-component class/component)
  (let ((component (if (class? class/component) (new class/component) class/component)))
    (new-frame (autoload 'Manager-View) client: component)))


(definition public (edit-view class/view)
  (let ((view (if (class? class/view) (new class/view background: {Color name: Medium}) class/view)))
    (new-frame (autoload 'View-Editor) client: view)))


;;;
;;;; Reset
;;;


(definition public (rsw name)
  )


(definition public (rsp name)
  (table-set! Palettes name {}))


;;;
;;;; Choose
;;;


(definition public (cc (color-or-name {}))
  (let ((color (if (or (not color-or-name) (is? color-or-name Color)) color-or-name (dispatch Color color-or-name))))
    (get-modal Color-Request initial-color: color)))


(definition public (cf)
  (choose-file))


(definition public (cmf)
  (choose-file multiple-selection?: #t))


(definition public (cnf)
  (choose-new-file))


(definition public (cd)
  (choose-directory))


(definition public (cp)
  (let ((path (format "{l}" (get-list~ (cd)))))
    (set-clipboard-text path)
    (user-message "Clipboard set to {a}" path)
    {}))


(definition public (md class)
  (get-modal~ class))


;;;
;;;; Projects
;;;


(definition public (compile-classes class-names . rest)
  (unimplemented 'compile-classes)
  @convert
  (let* ((compiled 0)
         (appl (get-application))
         (workbench-manager (get-workbench-manager~ appl)))
    (for-each (function (class-name)
                (let ((file (get-manifest-source class-name)))
                  (compile-moniker~ workbench-manager file)
                  (increase! compiled)))
              class-names)
    (message-box (format "{a} file{a} compiled"
                   compiled
                   (format-plural compiled)))))


;;;
;;;; Files
;;;


(definition public (find-files pattern directory)
  (let ((regexp (new Regular-Expression pattern)))
    (iterate-directory~ directory
      (function (file)
        (let ((name (get-name~ file)))
          (when (match~ regexp name)
            (debug file)))))))


(definition public (rename-files find replacement)
  (let ((directory (choose-directory title: "Rename"))
        (find-regexp (new Regular-Expression find))
        (replacement-regexp (new Regular-Expression replacement))
        (succeeded 0)
        (failed (new List-Factory)))
    (iterate-directory~ directory
      (function (file)
        (let* ((name (get-name~ file))
               (match (match~ find-regexp name)))
          (if (null? match)
              (put~ failed file)
            (let* ((new-name (replace~ replacement-regexp match))
                   (new-file (new-file~ (get-directory~ file) new-name)))
              (move-pathname~ file new-file)
              (increase! succeeded)))))
      files?: #t
      directories?: #f)
    (let ((failed (get-output~ failed)))
      (message-box
        (cons (format "{a} file{a} renamed" succeeded (format-plural succeeded))
              (when failed
                (augment '() "Could not rename the following:"
                  (map (function (file)
                         (list :bulleted (format "{a}" file)))
                       failed))))))))


;;;
;;;; Receive Files
;;;


(class Receiver-View extends View
  
  
  (property invite   initialize {} getter get-invite setter set-invite)
  (property receiver initialize {} accessors generate)
  
  
  (form
    (<install> background: {Color name: Dark}))
  
  
  (method public (get-invite)
    invite)
  
  
  (method public (set-invite value)
    (set! invite value)
    (invalidate-view))
  
  
  (method (receive-files pos files)
    (receiver pos files self))
  
  
  (definition Background-Font
    {Font name: Heading1})
  
  
  (method (draw surface context update lh lv)
    (set-font~ surface Background-Font)
    (let* ((title (localize (either invite "Drop Files Here")))
           (extent (get-text-extent~ surface title))
           (pos (center extent (get-display-size))))
      ;; shadow
      (set-text-color~ surface {Color name: Black})
      (draw-text~ surface (+ (get-h~ pos) 2) (+ (get-v~ pos) 2) title)
      ;; text
      (set-text-color~ surface {Color name: Gray})
      (draw-text~ surface (get-h~ pos) (get-v~ pos) title #t))))


(definition (setup-receiver receiver (title: title {}) (position: position {}) (size: size {}) (invite: invite {}))
  (new-palette Receiver-View
               host-title: (either title "Receive Files")
               host-position: (either position {Point 219 169})
               host-size: (either size {Dimension 434 224})
               ;; convert guest-context: self
               invite: invite
               receiver: receiver))


;;;
;;;; Regular Expressions
;;;


(definition public (rer from to string)
  (replace~ (new Regular-Expression to) (match~ (new Regular-Expression from) string)))


;;;
;;;; Allocations
;;;


@convert
(definition public (class-instances class)
  (list all: (class-all-instances class) live: (class-live-instances class)))


@convert
(definition public (reporting-allocations zone result-proc proc (return: return 'name))
  (let* ((classes (map car (zone-statistics zone)))
         (before (map class-all-instances classes)))
    (proc)
    (let* ((after (map class-all-instances classes))
           (all (map list (map (case return ((name) type-name) ((class) identity)) classes) (map - after before))))
      (result-proc
        (collect-if (function (info)
                      (bind (class all) info
                        (/= all 0)))
                    all)))))


;;;
;;;; Frames
;;;


@convert
(definition public (icf frame)
  (let* ((thread (get-thread~ frame))
         (address (get-address~ frame))
         (last-eval (binder-last-eval address))
         (last-call (binder-last-call address))
         (last-break (binder-last-break address))
         (object (either last-call last-break))
         (closure (frame-procedure address))
         (function (closure-function closure))
         (container (function-container function))
         (toplevel (tlf function))
         (location (object-location object toplevel)))
    (list last-eval: last-eval last-call: last-call last-break: last-break location: location)))


@convert
(definition (tlf function)
  (let ((container (function-container function)))
    (if (null? container)
        function
      (tlf container))))


;;;
;;;; Data
;;;


@convert
(definition public (debug-table table (name: name {}) (max-display: max-display 250))
  (let ((text (get-sql-console-text)))
    (set-current-request~ text name)
    (display-table~ text table max-display 0)
    table))


;;;
;;;; ? and %
;;;


(global ?)
(global %)


(global ?a)
(global ?b)
(global ?c)
(global ?d)
(global ?e)
(global ?f)
(global ?g)
(global ?h)
(global ?i)
(global ?j)
(global ?k)
(global ?l)
(global ?m)
(global ?n)
(global ?o)
(global ?p)
(global ?q)
(global ?r)
(global ?s)
(global ?t)
(global ?u)
(global ?v)
(global ?w)
(global ?x)
(global ?y)
(global ?z)


(global %a)
(global %b)
(global %c)
(global %d)
(global %e)
(global %f)
(global %g)
(global %h)
(global %i)
(global %j)
(global %k)
(global %l)
(global %m)
(global %n)
(global %o)
(global %p)
(global %q)
(global %r)
(global %s)
(global %t)
(global %u)
(global %v)
(global %w)
(global %x)
(global %y)
(global %z))
