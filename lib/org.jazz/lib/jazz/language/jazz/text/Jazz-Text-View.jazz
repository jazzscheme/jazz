;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Jazz Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.language.jazz.text.Jazz-Text-View jazz


(import (jazz.console)
        (jazz.debugger)
        (jazz.designer)
        (jazz.io)
        (jazz.jml)
        (jazz.language.jazz)
        (jazz.language.lisp)
        (jazz.library)
        (jazz.literals)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.clipboard)
        (jazz.ui.window)
        (jazz.ui.view)
        (jazz.utilities))


(class Jazz-Text-View extends Lisp-Text-View

  
  (form
    (<install> tooltip?: #t))

  
  (method (install rest)
    (nextmethod rest)
    (let ((pref (preferences)))
      (add-style (new Text-Style name: 'Title                    base: 'Default color: (get-title-color~ pref)))
      (add-style (new Text-Style name: 'Comment                  base: 'Default color: (get-comment-color~ pref)))
      (add-style (new Text-Style name: 'Expr-Comment             base: 'Default color: (get-expr-comment-color~ pref)))
      (add-style (new Text-Style name: 'Declaration-Keyword      base: 'Default color: (get-declaration-keyword-color~ pref)))
      (add-style (new Text-Style name: 'Documented-Declaration   base: 'Default color: (get-documented-declaration-color~ pref)))
      (add-style (new Text-Style name: 'Undocumented-Declaration base: 'Default color: (get-undocumented-declaration-color~ pref)))
      (add-style (new Text-Style name: 'Keyword                  base: 'Default color: (get-keyword-color~ pref)))
      (add-style (new Text-Style name: 'Tag                      base: 'Default color: (get-tag-color~ pref)))
      (add-style (new Text-Style name: 'Specifier                base: 'Default color: (get-specifier-color~ pref)))
      (add-style (new Text-Style name: 'Char                     base: 'Default color: (get-char-color~ pref)))
      (add-style (new Text-Style name: 'Number                   base: 'Default color: (get-number-color~ pref)))
      (add-style (new Text-Style name: 'Boolean                  base: 'Default color: (get-boolean-color~ pref)))
      (add-style (new Text-Style name: 'String                   base: 'Default color: (get-string-color~ pref)))
      (add-style (new Text-Style name: 'Delimited-String         base: 'Default color: (get-delimited-string-color~ pref)))
      (add-style (new Text-Style name: 'Named-String             base: 'Default color: (get-named-string-color~ pref)))
      (add-style (new Text-Style name: 'Quotation                base: 'Default color: (get-quotation-color~ pref)))
      (add-style (new Text-Style name: 'Literal                  base: 'Default color: (get-literal-color~ pref)))
      (add-style (new Text-Style name: 'Feature                  base: 'Default color: (get-feature-color~ pref)))
      (add-style (new Text-Style name: 'Reference                base: 'Default frame: {Color name: Red}))
      (add-style (new Text-Style name: 'Walk-Warning             base: 'Default frame: {Color name: Orange}))
      (add-style (new Text-Style name: 'Walk-Fatal               base: 'Default frame: {Color name: Red}))
      (add-style (new Text-Style name: 'Break                    base: 'Default highlight: {Color name: Red}))))
  
  
  (method meta (external-name . rest)
    'jazz-text)
  
  
  (method (default-extension)
    "jazz")
  
  
  (method (extensions)
    '(("Jazz Texts" . "jazz")))
    
  
  (method (new-syntax)
    (new Jazz-Syntax))


  ;;;
  ;;;; Actions
  ;;;
  

  (method (focus-actions)
    (cons (find-actions 'jazz-text)
          (nextmethod)))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (get-context-menu)
    (let* ((menu (new Jazz-Text-Menu))
           (controller (get-controller))
           (moniker (get-moniker~ controller)))
      (when (or (not moniker) (read/write?~ moniker))
        (set-visible?~ (locate~ menu 'set-read/write) #f))
      (layout-menu~ menu)
      menu))
    
  
  ;;;
  ;;;; Design
  ;;;

  
  (method (on-design-form evt)
    (unimplemented 'on-design-form)
    @convert
    (let* ((name (current-category-name))
           (class (autoload name)))
      (if (not (subtype? class Component))
          (error "Only Component classes can be designed")
        (let* ((form (get-self-form~ class))
               (frame (essay form (find-editor form))))
            (if frame
                (begin
                  (bring-to-front~ frame)
                  (set-visible?~ frame #t))
              (let* ((component (new class))
                     (editor-class (if (is? component View) View-Editor Manager-View)))
                (new-frame editor-class client: component)))))))
  
  
  (method (find-editor form)
    (let ((stage (get-stage)))
      (continuation-capture
        (function (return)
          (for-each (function (frame)
                      (when (is? frame View-Host)
                        (let ((guest (get-guest~ frame)))
                          (when (is? guest Editor-View)
                            (let ((designer (get-designer~ guest)))
                              (when (and designer (eq? form (get-form~ designer)))
                                (continuation-return return frame)))))))
                    (get-children~ stage))
          {}))))
  
  
  (method (on-copy-list evt)
    (let ((appl (get-application))
          (list (map (function (object) (->string object :reader)) (read-string-content (get-selected-string)))))
      (push-clipboard-list~ appl list)
      (user-message "Pushed {a} elements onto the clipboard stack" (length list))))

  
  ;;;
  ;;;; Tooltip
  ;;;
  

  (method (get-tooltip-context view)
    {}
    @convert-manifest
    (when (and (in-manifest? 'Debugger) (debugging?~ Debugger))
      (let* ((pos (view->text view))
             (expl (new Jazz-Explorer self start: pos end: pos)))
        (catch (Explore-Error err {})
          (when (outer-expr~ expl composite?: #f outer-composite?: #f)
            (let ((kind (get-kind~ expl)))
              (when (eq? kind 'symbol)
                (let* ((range (get-range~ expl))
                       (location (range-location range))
                       (text (essay location (present-location location))))
                  (when text
                    (let ((bounds (row-range-rect (get-row~ (get-start~ range)) (get-col~ (get-start~ range)) (get-col~ (get-end~ range)))))
                      (when (in-rect? view bounds)
                        (new Tooltip-Context
                          view: self
                          text: text
                          position: (+ (rect-position bounds) (new Point -10 (rect-height bounds)))
                          bounds: bounds
                          font: {Font name: Ansi-Var}))))))))))))
  
  
  ;;;
  ;;;; Coloring
  ;;;
    
  
  (definition default-preferences
    (form>>
      (<Jazz-Text-Preferences> title-color: {Color name: Dark-Red} comment-color: {Color name: Purple} expr-comment-color: {Color name: Dark-Orange} documented-declaration-color: {Color name: Purple} undocumented-declaration-color: {Color name: Dark-Green} keyword-color: {Color name: Dark-Blue} completions: ())))

  
  (method (preferences)
    (get-preferences '(documents jazz-text)))
  
  
  (method (declaration-style documented?)
    (if documented?
        'Documented-Declaration
      'Undocumented-Declaration))
  
  
  (method (colorize-tag colorizer start end)
    (apply-coloring colorizer start end 'Tag))
  
  
  (method (colorize-specifier colorizer start end)
    (apply-coloring colorizer start end 'Specifier))

  
  ;;;
  ;;;; Tabulation
  ;;;


  (constant Specials
    '((annotate                 #f 1)
      (assert                   #f 1)
      (attribute                #f 1)
      (attributes               #f 1)
      (begin                    #f 0)
      (bind                     #f 2)
      (block                    #f 1)
      (call-with-catch          #f 3)
      (case                     #f 1)
      (catch                    #f 1)
      (class                    #t 0)
      (cointerface              #t 0)
      (comethod                 #t 1)
      (comment                  #f -1)
      (constant                 #t 1)
      (cotry                    #f 1)
      (c-definition             #f 5)
      (c-structure              #f 1)
      (datacontainer            #f 1)
      (define                   #f 1)
      (definition               #t 1)
      (dialect                  #f -1)
      (ecase                    #f 1)
      (enumeration              #t 1)
      (form                     #f 0)
      (form>>                   #f 0)
      (function                 #t 1)
      (generic                  #t 1)
      (if                       #f 2)
      (in                       #f -1)
      (inline                   #t 1)
      (interface                #t 0)
      (jml                      #f 0)
      (jml>>                    #f 0)
      (lambda                   #t 1)
      (let                      #f 1)
      (let*                     #f 1)
      (letrec                   #f 1)
      (library                  #f -1)
      (macro                    #t 1)
      (method                   #t 1)
      (module                   #f -1)
      (new                      #f 1)
      (optimize                 #f 1)
      (package                  #t 0)
      (parameterize             #f 1)
      (pattern                  #t 1)
      (profile                  #f -1)
      (prog1                    #f 1)
      (receive                  #f 0)
      (remotable-stub           #t 0)
      (specific                 #t 1)
      (structure                #f 1)
      (substitution             #f 1)
      (synchronize              #f 1)
      (syntax                   #t 1)
      (template                 #f 1)
      (typecase                 #f 1)
      (unless                   #f 1)
      (unwind-protect           #f 1)
      (when                     #f 1)
      (while                    #f 1)
      (with                     #f 1)
      (with-closed              #f 1)
      (xsl-transformation       #f 1)
      (xml>>                    #f 0)))
  
  
  (method (get-specials)
    Specials)
  
  
  ;;;
  ;;;; Eval
  ;;;
  
  
  (method protected virtual (on-evaluate evt)
    (with-safe-explore
      (function ()
        (let ((range (current-definition-range)))
          (when range
            (with-cursor :wait
              (function ()
                (sleep .1)
                (receive (module-name header footer) (fusion-declarations range)
                  (load-module module-name)
                  (fusion-evaluate-forms module-name (read-text-forms range) header footer)))))))))
  
  
  (method (fusion-evaluate-forms module-name forms header footer)
    (let ((console-text (get-console-text))
          (expl <Text-Explorer> (new (explorer-class) self)))
      (let ((names (map (function (form) (->string (form-name~ expl form))) forms)))
        (evaluation-break~ console-text)
        (let ((debugged (get-debugged-process))
              (expressions (map (function (form)
                                  (read-string-element (format "{a}{s}{a}" header form footer)))
                                forms)))
          @w
          (debug module-name expressions)
          (if debugged
              (evaluate-expressions~ debugged expressions)
            (locate-library-declaration module-name)
            (let ((results (map (function (expr)
                                  (parameterize ((requested-module-name module-name))
                                    (->string (eval expr) :reader)))
                                expressions)))
              ;; do nothing with results for now. only side effect
              #f)))
        ;; until we have fresh-line
        (insert-newline~ console-text)
        (display-evaluation~ console-text names #f)
        (fresh-prompt~ console-text)
        (user-message "Evaluated: {l detail: :human}"
                      (map (function (name)
                             (either name '<expr>))
                           names)))))
  
  
  (method (fusion-declarations range)
    (let ((module-name {})
          (header "")
          (footer "")
          (expl (new Jazz-Explorer self range: range)))
      (while (outer-expr~ expl)
        (when (fusion-declaration?~ expl)
          (let* ((declaration (fusion-declaration~ expl))
                 (declaration-header (join declaration " ")))
            ;; all this needs some cleanup
            (when (member (car declaration) '("module" "library"))
              (set! module-name (string->symbol (cadr declaration))))
            (set! header (format "({a}{%}{a}" declaration-header header))
            (set! footer (format "{a})" footer)))))
      (values module-name header footer)))
  
  
  @convert
  (method protected virtual (on-evaluate evt)
    (with-safe-explore
      (function ()
        (let ((range (current-definition-range)))
          (when range
            (with-cursor :wait
              (function ()
                (remove-highlights range)
                (sleep .1)
                (let ((info (current-toplevel-info))
                      (forms (read-text-forms range)))
                  (when forms
                    (let ((classes (current-classes range)))
                      (when classes
                        (let ((toplevel (car classes)))
                          (if (and (get-modified?) (not (category-loaded? toplevel)))
                              (let ((code (message-box (format "Do you want to save {s}?{%}{%}Because this category has not yet been loaded in memory, it needs to be saved to disk for correct evaluation." toplevel)
                                                       type: 'confirmation)))
                                (case code
                                  ((yes)
                                   (save)
                                   (autoload toplevel))
                                  ((no))
                                  ((cancel)
                                   (throw-cancel))))
                            (receive (in category-info) info
                              (bind (category kind meta? name keywords) category-info
                                (let ((appl (get-application))
                                      (class (location-class classes load?: #t))
                                      (imports (getf keywords 'uses)))
                                  (evaluate-forms range forms class (if (pair? imports) imports (list imports)))))))))))))))))))
  
  
  @convert
  (method (evaluate-forms range forms class packages)
    (let ((names (evaluate-code range forms class packages)))
      (user-message "Evaluated: {l detail: :human}" names)
      (let ((console (get-console-text)))
        (when console
          (evaluation-break~ console)
          (display-evaluation~ console names #f)
          (fresh-prompt~ console)))))


  ;;;
  ;;;; Breaks
  ;;;
  
  
  (method public (on-add-break evt)
    @convert
    (let* ((range (current-expr-range))
           (loc (range-location range)))
      (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter loc)
        (if (not resolved?)
            (error "Unable to resolve location: {t}" loc)
          (add-break~ Interpreter object)
          (apply-style 'Break (get-start~ range) (+ (get-start~ range) 1))))))
  
  
  (method public (on-remove-break evt)
    @convert
    (let* ((range (current-expr-range))
           (loc (range-location range)))
      (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter loc)
        (if (not resolved?)
            (bell)
          (remove-break~ Interpreter object)
          (let ((run (get-run-at (+ (get-start~ range) 1))))
            (when run
              (set-style~ run default-style)
              (invalidate-paragraph (get-paragraph (get-row~ (get-start~ range))))))))))

  
  ;;;
  ;;;; Presentation
  ;;;
  
  
  (method (present-location location)
    @convert
    (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter location)
      (when (and resolved? in-context?)
        (let ((frame (active-frame~ (current-debugger))))
          (present-expr frame object)))))


  (method (present-expr frame object)
    @convert (
    @to-debug-field-logic
    (format "{s} : {s}" (class-of object) object)
    (typecase object
      ((Global-Reference)   (present-global   frame object))
      ((Manifest-Reference) (present-global   frame object))
      ((Self)               (present-self     frame object))
      ((Variable)           (present-variable frame object))
      ((Field-Reference)    (present-field    frame object))
      ((Symbol)             (present-constant frame object))
      (else               (present-unknown  frame object)))))
  
  
  (method (present-global frame object)
    (format "{s}" (dispatch self object)))
  
  
  (method (present-self frame object)
    @convert
    (when frame
      ;; todo temp patch until converted to the new remote debugger
      (let* ((binder (frame-closure-frame~ Interpreter (get-address~ frame)))
             (context (frame-context binder)))
        (format "self = {a}"
                (present-value context)))))
  
  
  (method (present-variable frame var)
    @convert
    (when frame
      ;; todo temp patch until converted to the new remote debugger
      (set! frame (get-address~ frame))
      (let* ((binder (frame-closure-frame~ Interpreter frame))
             (variables (frame-variables binder))
             ;; it is important to take the variable from the frame-variables list
             ;; because it is the one that has its level member set correctly
             (variable-base (~ variable-base Interpreter))
             (variable (find-in variables (variable-base var) key: variable-base test: eq?)))
        (when variable
          (let ((value (variable-value~ Interpreter variable binder)))
            (format "{s} = {a}"
                    (variable-symbol~ Interpreter variable)
                    (present-value value)))))))
  
  
  (method (present-field frame reference)
    @convert
    (when frame
      ;; todo temp patch until converted to the new remote debugger
      (set! frame (get-address~ frame))
      (let* ((binder (frame-closure-frame~ Interpreter frame))
             (context (frame-context binder))
             (field (field-reference-form~ Interpreter reference)))
        (when (is? context (field-creator field))
          (unless (and (definition? field) (definition-method? field))
            (let ((value (get-value context field)))
              (format "{s} = {a}"
                      (field-name field)
                      (present-value value))))))))
  
  
  (method (present-constant frame object)
    (format "{s}" object))
  
  
  (method (present-unknown frame object)
    {})
  
  
  (method (present-value value)
    (cond ((procedure? value) "<procedure>")
          (else (format "{s}" value))))

  ;;;
  ;;;; Location
  ;;;
  
  
  (method (current-location)
    (position->location (get-start)))
  
  
  (method (position->location pos)
    (let ((expl (new Jazz-Explorer self start: pos end: pos)))
      (when (outer-expr~ expl outer-composite?: #f)
        (let ((range (get-range~ expl)))
          (range-location range)))))
  
  
  (method (location-class loc (load?: load? #f))
    @convert
    (let* ((class-name (car loc))
           (class (global-value~ class-name load?)))
      (if (not class)
          (error "Unable to find class: {t}" class-name)
        (let ((meta? #f))
          (for-each (function (name)
                      (if (eq? name 'meta)
                          (set! meta? #t)
                        (set! class (definition-value (category-field (if meta? (class-of class) class) name)))
                        (set! meta? #f)))
                    (cdr loc)))
        class)))
  
  
  (method (split-location location)
    (let ((scan location)
          (definition (new List-Factory)))
      (while (symbol? (car scan))
        (put~ definition (car scan))
        (set! scan (cdr scan)))
      (values (get-output~ definition) scan)))
  
  
  (method (definition-name-info object)
    (unimplemented 'definition-name-info)
    @convert
    (cond ((category? object)
           (values 1 #f))
          ((slot? object)
           (values (+ 1 (field-modifiers-count object)) #f))
          ((field? object)
           (let ((value (definition-value object)))
             (cond ((procedure? value) (values (+ 1 (field-modifiers-count object)) #t))
                   ((external? value) (values (+ 2 (field-modifiers-count object) 1) #t))
                   (else {}))))
          (else
           {})))
  
  
  (method (definition-name-location? object internal-location)
    (let ((info (definition-name-info object)))
      (when info
        (receive (skip inside-allowed?) info
          (or (= internal-location (list skip))
              (and inside-allowed? (= internal-location (list skip 0))))))))


  (method (range-location range)
    (let ((expl (new Jazz-Explorer self start: (get-start~ range) end: (get-end~ range)))
          (location {})
          (previous-def? #f)
          (done? #f))
      (while (not done?)
        (let ((rank (outer-expr~ expl)))
          (if (not rank)
              (set! done? #t)
            (let ((def? (definition-expr?~ expl)))
              (if def?
                  (receive (package? meta? name) (definition-name~ expl)
                    (let ((loc (if previous-def? location (cons rank location))))
                      (cond (package?
                              (set! location (cons name (cons 'meta loc))))
                            (meta?
                              (set! location (cons 'meta (cons name loc))))
                            (else
                             (set! location (cons name loc))))))
                (set! location (cons rank location)))
              (set! previous-def? def?)))))
      location))


  (method public (location-range location (toplevel-location: toplevel-location {}))
    (let ((expl (new Jazz-Explorer self end: (text-beginning))))
      (forward-location~ expl location toplevel-location: toplevel-location)
      (get-range~ expl)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method (on-edit-documentation evt)
    (let ((symbol (current-symbol)))
      (if (not symbol)
          (bell)
        (let ((appl (get-application)))
          (edit-documentation~ appl symbol)))))
  
  
  @old-doc-editor
  (method (on-edit-documentation evt)
    (edit-documentation (current-location)))
  
  
  @old-doc-editor
  (method (edit-documentation location)
    (if (null? location)
        (bell)
      (autoload (car location))
      (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter location)
        (if (and resolved? in-context? object (is? object Field-Reference))
            (edit-field-reference-documentation (field-reference-form~ Interpreter object))
          (edit-field-documentation location)))))
  
  
  @old-doc-editor
  (method (edit-field-reference-documentation field)
    (let ((appl (get-application))
          (location (list (type-name (field-creator field)) (field-name field))))
      (edit-documentation~ appl location field {} {})))
  
  
  @old-doc-editor
  (method (edit-field-documentation location)
    (let ((appl (get-application)))
      (receive (field-location internal-location) (split-location location)
        (receive (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter field-location)
          (if (and resolved? in-context? (definition-name-location? object internal-location))
              (edit-documentation~ appl field-location object self location)
            (bell))))))
  
  
  (method (on-present-documentation evt)
    (present-documentation (current-symbol)))

  
  (method (present-documentation symbol)
    (unimplemented 'present-documentation)
    @convert
    (if (not symbol)
        (bell)
      (let* ((appl (get-application))
             (doc (get-documentation~ appl symbol)))
        (if (not doc)
            (let ((classname (symbol->string symbol)))
              (if #f @wait (class-exists?~ JVM classname)
                  (open-java-documentation classname)
                (bell)))
          (let ((jml (present-text~ doc)))
            (if (not jml)
                (bell)
              (let* ((view (new Documentation-View size: {Dimension 600 300}))
                     (text (locate~ view 'text))
                     (pos {Point 100 100})
                     (alternate {Point 100 100})
                     (border (new Border-View border-insets: {Rect 5 5 5 5} border-type: 'solid) @w (new Border-View border-type: 'edge style: 'entry))
                     (display (get-display)))
                (set-text~ text (transform-jml (parse-jml jml) (new DocToText-Transformation)))
                (popup~ display view pos alternate-position: alternate border: border))))))))
  
  
  (method (open-java-documentation classname)
    (unimplemented 'open-java-documentation)
    @convert
    (let* ((appl (get-application))
           (profile (get-profile~ appl))
           (apidocs (java-apidocs~ profile)))
      (receive (package name) (parse-classname~ Java classname)
        (for-each (function (dir)
                    (let ((file (new-file~ dir (append package (list (format "{a}.html" name))))))
                      (when (exists?~ file)
                        (shell-execute file)
                        (return))))
                  apidocs)
        (bell))))
  
  
  ;;;
  ;;;; Arguments
  ;;;
  
  
  ;; todo
  ;;   make work in console
  ;;   support for { [ ...

  
  (method (show-arguments)
    @wait-fucking-intermitent-bug-fix
    (when (empty-selection?)
      (let ((expl (new Jazz-Explorer self start: (get-start) end: (get-end))))
        (when (and (backward-expr~ expl)
                   (= (get-kind~ expl) 'symbol))
          (case (char-backward~ expl 0)
            ((#\open-parenthesis) (show-method-arguments expl))
            ((#\open-bracket) (show-category-fields)))))))
  
  
  (method (show-method-arguments expl)
    (let ((name (get-marked~ expl))
          (info (current-toplevel-info)))
      (when info
        (receive (in category-info) info
          (bind (category kind meta? name keywords) category-info
            (when category
              (let ((symbol (find-symbol name)))
                (when symbol
                  (let ((imports (getf keywords 'uses)))
                    (show-symbol-arguments symbol category imports))))))))))


  (method (show-symbol-arguments symbol class packages)
    (unimplemented 'show-symbol-arguments)
    @convert
    (let ((field (find-in symbol class packages)))
      (when field
        (let ((value (definition-value field)))
          (typecase value
            ((External)
             (show-external-arguments symbol value))
            ((%function)
             (show-function-arguments symbol value))
            ((Closure)
             (show-function-arguments symbol (closure-function~ Interpreter value))))))))


  (method (show-external-arguments symbol external)
    @convert
    (user-message "({s} {l}{a}) {s}"
                  symbol
                  (map type-name (accumulate (proxy-parameters~ Interpreter external) (function (param) (get-type~ param)) List))
                  (if (proxy-rest?~ Interpreter external) " . rest" "")
                  (type-name (get-type~ (proxy-result~ Interpreter external)))))

  
  (method (show-function-arguments symbol function)
    @convert
    (let* ((parameters (function-parameters~ Interpreter function))
           (printer (open-output-string))
           ;; convert
           (rest 'rest))
      (present-parameters parameters rest printer)
      (user-message "({a} {a})" symbol (get-output-string printer))))
  
  
  (method (present-parameters parameters bind printer)
    (when parameters
      (cond ((pair? parameters)
             (present-parameter (car parameters) printer)
             (format printer " ")
             (present-parameters (cdr parameters) bind printer))
            (bind
             (format printer "{a}" bind))
            (else
             (format printer ". {a}" parameters)))))
  
  
  (method (present-parameter parameter printer)
    @convert
    (typecase parameter
      ((Variable) (format printer "{s}" (variable-symbol~ Interpreter parameter)))
      (else (format printer "{s}" parameter))))

  
  @convert
  (method (find-in symbol class packages)
    (continuation-capture
      (function (return)
        (for-each (function (package)
                    (let* ((name (type-name package))
                           (package (either (get-interpreted-category~ Interpreter-Services name) package))
                           (field (category-field (class-of package) symbol)))
                      (when field
                        (continuation-return return field))))
                  packages)
        {})))
  
  
  (method (show-category-fields)
    @wait
    (let ((popup (new Completion-Popup owner-text: self position: {Point 500 500})))
      (show~ popup)))
   

  ;;;
  ;;;; Explorer
  ;;;


  (method (explorer-class)
    Jazz-Explorer)

  
  ;;;
  ;;;; Form
  ;;;
  
  
  (method public (current-class-form)
    (let ((range (with-safe-explore (function () (current-definition-range)))))
      (when range
        (let ((info (current-toplevel-info))
              (forms (read-text-forms range)))
          (when (= (length forms) 1)
            (let ((form (car forms)))
              (when (and (= (length form) 4)
                         (eq? (first form) 'definition)
                         (eq? (second form) 'meta)
                         (eq? (third form) 'class-form)
                         (is? (fourth form) Form))
                (values range (fourth form)))))))))

  
  ;;;
  ;;;; Category
  ;;;
  

  (method protected virtual (current-toplevel-info)
    (let* ((expl (new Jazz-Explorer self end: (text-beginning)))
           (in (forward-in~ expl))
           (category (forward-category~ expl)))
      (values in category)))
  
  
  (method (current-classes range)
    (let ((expl (new Jazz-Explorer self range: range))
          (classes '()))
      (while (outer-expr~ expl)
        (when (category-expr?~ expl)
          (receive (package? meta? name) (definition-name~ expl)
            (set! classes (cons name classes))
            (when meta?
              (set! classes (cons 'meta classes))))))
      classes))
  
  
  (method (current-category-name)
    (receive (in category-info) (current-toplevel-info)
      (bind (category kind meta? name keywords) category-info
        name)))
  
  
  (method (toplevel-expr pos)
    (let ((expl (new Jazz-Explorer self start: pos end: pos))
          (range {}))
      (while (outer-expr~ expl)
        (set! range (get-range~ expl)))
      range))
  
  
  ;;;
  ;;;; Edit
  ;;;
    
  
  (method (edit-symbol-class symbol)
    @convert
    (when (in-manifest? symbol)
      (edit-class~ (get-application) symbol)
      #t)))


;;;
;;;; Documentation-View
;;;


(class Documentation-View extends Layout-View
  
  
  (form
    (<install>                                     layout-type: fill
      (<Scroller-View>                             hscroll?: #f vscroll?: #t flat?: #t
        (<!>                         name: content layout-type: fill
          (<Documentation-Text-View> name: text    background: {Color name: Tooltip} editable?: #f))))))


;;;
;;;; Jazz-Text-Menu
;;;


(class Jazz-Text-Menu extends Context-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: evaluate             title: "&Evaluate" icon: {Bitmap-Resource "Execute"} action: {Action jazz-text evaluate})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: design-form          title: "Design &Form" icon: {Bitmap-Resource "Designer"} action: {Action jazz-text design-form})
      (<Separator-Item>)
      (<Label-Item>     name: edit-definition      title: "Edit &Definition" icon: {Bitmap-Resource "Edit"} action: {Action code-text edit-definition})
      (<Label-Item>     name: edit-references      title: "Edit &References" action: {Action code-text edit-references})
      @waiting
      (<Label-Item>     name: edit-documentation   title: "Edit Do&cumentation" action: {Action jazz-text edit-documentation})
      @waiting
      (<Label-Item>     name: add-to-favorites     title: "&Add To Favorites..." icon: {Bitmap-Resource "Favorites"} action: {Action jazz-text add-to-favorites})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: add-break            title: "&Add Break" icon: {Bitmap-Resource "AddBreak"} action: {Action jazz-text add-break})
      @waiting
      (<Label-Item>     name: remove-break         title: "&Remove Break" icon: {Bitmap-Resource "RemoveBreak"} action: {Action jazz-text remove-break})
      @waiting
      (<Separator-Item>)
      @waiting
      (<Label-Item>     name: show-history         title: "Show &History..." icon: {Bitmap-Resource "ShowHistory"} action: {Action text show-history})
      @waiting
      (<Label-Item>     name: show-changes         title: "Show &Changes..." icon: {Bitmap-Resource "ShowChanges"} action: {Action text show-changes})
      (<Separator-Item>)
      (<Label-Item>     name: set-read/write       title: "&Set Read/Write" action: {Action jazz-text set-read/write})
      (<Label-Item>     name: update-catalog       title: "&Update Catalog" icon: {Bitmap-Resource "Repository"} action: {Action code-text update-catalog})
      (<Label-Item>     name: recolorize-syntax    title: "&Recolorize Syntax" icon: {Bitmap-Resource "Refresh"} action: {Action code-text recolorize-syntax})
      (<Separator-Item>)
      (<Label-Item>                                title: "&Column"
        (<Column-Menu>))
      (<Label-Item>                                title: "&Format"
        (<Format-Menu>))))))
