;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Break Loop
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.library.loop.Break-Loop jazz


(import (jazz.debuggee)
        (jazz.debugger)
        (jazz.library)
        (jazz.library.listener)
        (jazz.platform)
        (jazz.utilities))


(class Break-Loop extends Object


  (slot level   initialize 0)
  (slot type    initialize {})
  (slot message initialize :empty)
  (slot frame   initialize {})
  (slot stack   initialize {})
  (slot command initialize {})
  
  
  (method public (get-level)
    level)
  
  
  (method (set-level l)
    (set! level l)
    (call-on-level-change))
  
  
  (method public (get-type)
    type)
  
  
  (method (set-type t)
    (set! type t))
  
  
  (method public (get-message)
    message)
  
  
  (method (set-message msg)
    (set! message msg)
    (when message
      (if (= message :empty)
          (clear-user-message)
        (user-message "<{a}> {a}" level message))))
  
  
  (method public (get-frame)
    frame)
  
  
  (method (set-frame f)
    (set! frame f))
  
  
  (method public (get-frame-address)
    frame)
  
  
  (method (set-frame-address address)
    (if (not address)
        (set! frame {})
      (let ((thread (get-primordial-thread~ (get-local-debuggee))))
        (set! frame (new-frame~ thread address)))))
  
  
  (method public (get-stack)
    stack)
  
  
  (method (set-stack s)
    (set! stack s))
  
  
  (method (get-command)
    command)
  
  
  (method (set-command cmd)
    (set! command cmd))
  
  
  (method (continuable-loop)
    @convert-process-one-message
    (let ((process (get-process))
          (continue? #f)
          (primordial? (primordial-thread?)))
      (while (not continue?)
        (if primordial
            (catch Stop-Signal
              (process-one-message~ process))
          (relinquish-process))
        (let ((cmd command))
          (set-command {})
          (case cmd
            ((stop)     (throw-stop))
            ((toplevel) (throw-toplevel))
            ((continue) (set! continue? #t)))))))
    

  (method public (break-loop (type: type 'break) (message: message {}) (frame: frame {}) (proc: proc {}))
    (let ((old-type    type~self)
          (old-message message~self)
          (old-frame   frame~self)
          (old-stack   stack~self)
          (old-level   level~self))
      (unwind-protect
          (begin
            (set-type          type)
            (set-frame-address frame)
            (set-stack         '() @convert (runtime-stack frame))
            (set-message       message)
            (set-level         (+ level 1))
            (set-command       {})
            (when proc
              (proc))
            (continuable-loop))
        (set-type    old-type)
        (set-frame   old-frame)
        (set-stack   old-stack)
        (set-level   old-level)
        (set-message old-message))))
  
  
  (method public (stop)
    (set-command 'stop))


  (method public (toplevel)
    (set-command 'toplevel))


  (method public (continue)
    (set-command 'continue))


  ;;;
  ;;;; Events
  ;;;
  

  (slot level-change-listeners initialize '())
  
  
  (method public (add-level-change-listener listener)
    (set! level-change-listeners (add-listener listener level-change-listeners)))
  
  
  (method public (remove-level-change-listener listener)
    (set! level-change-listeners (remove-listener listener level-change-listeners)))

  
  (method (call-on-level-change)
    (when level-change-listeners
      (let ((evt (new Break-Event :level-change self)))
        (for-each (function (listener)
                    (invoke~ listener self evt))
                  level-change-listeners))))))
