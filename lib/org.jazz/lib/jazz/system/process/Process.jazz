;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Processes
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.system.process.Process jazz


(import (jazz.debugger)
        (jazz.designer)
        (jazz.development)
        (jazz.io)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.library.shell)
        (jazz.network)
        (jazz.platform)
        (jazz.system)
        (jazz.system.process)
        (jazz.utilities))


(class Process extends Object


  (slot loop                        initialize {})
  (slot loop-running?               initialize #f)
  (slot loop-exit                   initialize #f)
  (slot stub-listener               initialize {})
  (slot proxy-dispatcher            initialize {})
  (slot local-process-server        initialize {})
  (slot local-directory-server      initialize {})
  (slot local-debuggee              initialize {})
  (slot controller-process-server   initialize {})
  (slot controller-directory-server initialize {})
  (slot controller-debugger-server  initialize {})
  (slot router-server               initialize {})
  (slot standard-input              initialize {})
  (slot standard-output             initialize {})
  (slot standard-error              initialize {})
  (slot preferences-root            initialize {})
  (slot preferences-designer        initialize {})
  (slot context                     initialize {})
  (slot logger                      initialize {})

  
  ;;;
  ;;;; Access
  ;;;


  (method public (get-loop)
    loop)
  
  
  (method public (get-loop-running?)
    loop-running?)
  
  
  (method public (set-loop-running? flag)
    (set! loop-running? flag))
  
  
  (method public (get-preferences-root)
    preferences-root)
  
  
  (method public (get-preferences-designer)
    preferences-designer)
  
  
  (method public virtual (process-name)
    "")
  
  
  (method public virtual (process-owner)
    {})
  
  
  (method public virtual (process-copyright)
    {})
  
  
  (method public virtual (process-licensee)
    {})
  
  
  (method public virtual (process-icon)
    {Bitmap-Resource "Jazz"})
  

  (method public virtual (process-version)
    {Version 1 0 0})
  
  
  (method public virtual (process-email)
    {})
  
  
  (method public virtual (process-actions)
    '())
  
  
  (method public virtual (process-event-source)
    (either (argument/property "event-source" 'EventSource)
            (process-name)))
  
  
  ;;;
  ;;;; Startup
  ;;;
  
  
  (method public virtual (boot-environment rest)
    (initialize-aliases)
    @unimplemented
    (register-versions)
    (prepare-phase rest)
    (start-phase rest)
    (finalize-phase rest)
    (finish-phase rest)
    (conclude-phase rest)
    (activate-process)
    (when run-loop?
      (run-loop)))
  
  
  (method (register-versions)
    (unimplemented 'register-versions)
    @unimplemented
    (register-crash-info windows-version: {} (present~ (get-windows-version))))
  
  
  (method (prepare-phase rest)
    (prepare-aliases)
    (prepare-environment rest)
    (prepare-preferences rest)
    (prepare-profile-aliases)
    (prepare-workbench)
    (prepare-manifests)
    (prepare-process rest))


  (method protected virtual (prepare-environment rest)
    (set-process self))


  (method (prepare-preferences rest)
    (setup-preferences))

  
  (method public virtual (prepare-process rest)
    )
  
  
  (method (start-phase rest)
    (start-environment rest)
    (start-process rest))


  (method protected virtual (start-environment rest)
    @windows-specific
    (coinitialize))
  
  
  (method public virtual (start-process rest)
    )
  
  
  ;; tofix
  (method (finalize-phase rest)
    (finalize-environment rest)
    @unimplemented
    (start-servers)
    (setup-loop)
    (finalize-process rest)
    (setup-profile rest))


  (method protected virtual (finalize-environment rest)
    )
  
  
  (method public virtual (finalize-process rest)
    )

  
  (method public virtual (setup-profile rest)
    )
    
  
  (method (finish-phase rest)
    (finish-environment rest)
    (finish-process rest))
  
  
  ;; tofix
  (method protected virtual (finish-environment rest)
    (register-base-objects)
    @unimplemented
    (setup-controller))
  
  
  (method public virtual (finish-process rest)
    )
    
  
  (method (conclude-phase rest)
    (conclude-environment rest)
    (conclude-process rest))
  
  
  (method protected virtual (conclude-environment rest)
    )
  
  
  (method public virtual (conclude-process rest)
    )
  
  
  ;;;
  ;;;; Environment
  ;;;
  
  
  (method public virtual (preserve-environment)
    )
  
  
  (method public virtual (close-environment)
    (close-preferences)
    (detach-from-controller)
    (stop-servers)
    @windows-specific
    (stop-winsock))
  
  
  (method virtual (close-preferences)
    @convert
    (when preferences-designer
      (save~ preferences-designer)))
  
  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public virtual (focus-exit)
    )
  
  
  ;;;
  ;;;; Exit
  ;;;
  

  (method public (exit-process (status 0))
    (focus-exit)
    (preserve-environment)
    (close-environment)
    (let ((signal (new Exit-Signal status: status)))
      (if (catched? signal)
          (throw signal)
        (exit status))))

  ;;;
  ;;;; Alias
  ;;;
  
  
  (method public virtual (process-alias name)
    (case name
      ((:process) self)
      (else {})))
  
  
  ;;;
  ;;;; Context
  ;;;
  
  
  (method public (get-context)
    context)
  
  
  (method public (set-context ctx)
    (set! context ctx)
    (context-update))
  
  
  ;; Ugly hardcoding updates for now as the right approach
  ;; is not clear... Maybe the preferences setters do the
  ;; updates themselves or maybe objects interesseted in beeing
  ;; notified about preferences changes register themselves
  ;; for designer events that could be sent when the context is changed.
  (method protected virtual (context-update)
    (modify-preferences)
    (modify-favorites)
    (modify-connections)
    (modify-toolbox))
  
  
  (method (modify-preferences)
    (let* ((pref (get-preferences {}))
           (designer (get-preferences-designer))
           (branch (find-component~ pref context)))
      (set-active-branch~ pref branch)))
  
  
  (method (modify-favorites)
    @wait
    (when (in-manifest? 'Favorites-Manager)
      (modify-editor (get-guest~ (singleton-docked Favorites-Manager {})))))
  
  
  (method (modify-connections)
    @windows-specific
    (when (in-manifest? 'SQL-Connections-Manager)
      (modify-editor (get-guest~ (singleton-docked SQL-Connections-Manager {})))))
  
  
  (method (modify-toolbox)
    @wait
    (when (in-manifest? 'Toolbox-Manager)
      (modify-editor (get-guest~ (singleton-docked Toolbox-Manager {})))))
  
  
  (method (modify-editor editor)
    (let* ((client (get-client~ editor))
           (branch (find-component~ client context)))
      (set-active-branch~ client branch)
      (set-client~ editor {})
      (set-client~ editor client)))
  
  
  (method public (install-context component)
    (when context
      (let ((branch (find-child~ component context)))
        (when branch
          (set-active-branch~ component branch)))))
  
  
  ;;;
  ;;;; Input/Output
  ;;;
  
  
  @windows-specific
  (method (setup-standard-input/output-handles)
    (let ((si (new STARTUPINFO)))
      (GetStartupInfo si)
      (if (not (mask-bit-set? (get si 'dwFlags) STARTF_USESTDHANDLES))
          (error "Process is not bound to standard input/output handles")
        (set! standard-input  (new Pipe-Reader  (get si 'hStdInput)))
        (set! standard-output (new Pipe-Printer (get si 'hStdOutput)))
        (set! standard-error  (new Pipe-Printer (get si 'hStdError))))))
  
  
  @windows-specific
  (method public (get-standard-input)
    (when (not standard-input)
      (setup-standard-input/output-handles))
    standard-input)
  
  
  @windows-specific
  (method public (get-standard-output)
    (when (not standard-output)
      (setup-standard-input/output-handles))
    standard-output)
  
  
  @windows-specific
  (method public (get-standard-error)
    (when (not standard-error)
      (setup-standard-input/output-handles))
    standard-error)
  
  
  ;;;
  ;;;; Preferences
  ;;;
  
  
  (method protected virtual (preferences-file)
    {File Profile "settings" "Preferences.jml"})
  
  
  (method public (setup-preferences)
    (set! preferences-root (load-preferences))
    (set! preferences-designer (new Designer form: (get-form~ preferences-root) reference: preferences-root))
    (set! context (preferences-context))
    (install-context preferences-root))
  
  
  (method protected virtual (load-preferences)
    (let ((file (preferences-file)))
      (if (and (find-alias 'Profile) (exists?~ file))
          (instantiate~ (read-from-file file))
        (default-preferences))))
  
  
  (method protected virtual (default-preferences)
    (new Process-Preferences))
  
  
  (method (preferences-context)
    (let ((arg (command-argument "context")))
      (cond (arg (string->symbol arg))
            (preferences-root (get-active-context~ preferences-root))
            (else {}))))
  
  
  (method public (apply-preferences preferences (client {}))
    (apply-preferences~ preferences client))
  
  
  (method public (save-preferences preferences (client {}))
    (save-preferences~ preferences (get-preferences-designer) client))

  
  (method public (set-preferences-property preferences property value)
    (set-property~ preferences (get-preferences-designer) property value))
  
  
  (method public virtual (get-preferences-rights)
    {})
  
  
  ;;;
  ;;;; Persistence
  ;;;
  
  
  (method public virtual (persist-usernames?)
    #f)
  
  
  (method public virtual (persist-passwords?)
    #f)
  
  
  ;;;
  ;;;; Versions
  ;;;
  
  
  (method public virtual (mandatory-version what)
    {})

  
  ;;;
  ;;;; Readyness
  ;;;
  
  
  @windows-specific
  (method protected (signal-readyness name)
    (let ((handle (OpenEvent EVENT_MODIFY_STATE #f name)))
      (when handle
        (SetEvent handle))))

  
  ;;;
  ;;;; Loop
  ;;;
  
  
  (method (setup-loop)
    (set! loop (new Toplevel-Loop)))
  
  
  (method public virtual (run-loop)
    (call/ec
      (function (exit)
        (set! loop-exit exit)
        (toplevel-loop~ loop))))
  
  
  (method public (resume-loop)
    (resume-loop-action)
    (run-loop))
  
  
  (method public virtual (resume-loop-action)
    )
  
  
  (method public (call-start-loop)
    (set-loop-running? #t)
    (start-loop))


  (method public virtual (start-loop)
    (while #t
      (process-messages)))
  
  
  (method public (stop-loop)
    (if (not loop-exit)
        (error "Loop is not running")
      (let ((exit loop-exit))
        (set! loop-exit #f)
        (exit))))

  
  ;;;
  ;;;; Messages
  ;;;

  
  (method public virtual (process-messages)
    (default-process-messages))

  
  (method public virtual (process-one-message)
    )
  
  
  (method public (default-process-messages)
    (relinquish-process))


  ;;;
  ;;;; Feedback
  ;;;

  
  (method protected virtual (user-feedback message)
    )


  ;;;
  ;;;; System
  ;;;
  
  
  (method public virtual (system-title)
    "JazzScheme Process")


  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method protected virtual (prepare-aliases)
    )
  
  
  (method public virtual (prepare-profile-aliases)
    (let ((pref (get-preferences 'aliases error?: #f)))
      (when pref
        (let ((aliases (get-children~ pref)))
          (for-each (function (pref)
                      (let ((alias (get-alias~ pref))
                            (directory (get-directory~ pref)))
                        (when directory
                          (set-alias alias (get-list~ directory)))))
                    aliases)))))
  
  
  (method public virtual (resolve-alias name)
    {})


  ;;;
  ;;;; Message
  ;;;
  
  
  (method public virtual (show-box text rest)
    (apply system-message text rest))


  ;;;
  ;;;; Workbench
  ;;;
  
  
  (method public virtual (prepare-workbench)
    )


  ;;;
  ;;;; Manifests
  ;;;
  
  
  (method public virtual (prepare-manifests)
    )
  
  
  ;;;
  ;;;; Servers
  ;;;
  
  
  ;; For some users, starting the stub listener can trigger a firewall that will
  ;; pop a dialog asking for user confirmation (even when listening to localhost!).
  (method protected virtual (start-stub-listener?)
    #f)
  
  
  (method protected virtual (start-servers)
    ;;@threads-commented-for-simpler-c-threading-debugging
    (when (or (start-stub-listener?) (command-argument "debug"))
      (start-stub-listener)))
  
  
  (method protected virtual (stop-servers)
    (stop-stub-listener)
    (stop-proxy-dispatcher))
  
  
  ;;;
  ;;;; Stub Listener
  ;;;
  
  
  (method public virtual (stub-listener-host)
    {})
  
  (method public virtual (stub-listener-port)
    {})
  
  
  (method public (get-stub-listener)
    stub-listener)
  
  
  (method protected (start-stub-listener)
    @convert-socket
    (unless stub-listener
      (set! stub-listener (new Stub-Listener))
      (unless (wait-started~ stub-listener error?: #f)
        (error "Unable to start stub listener"))))
  
  
  (method protected (stop-stub-listener)
    @convert-socket
    (when stub-listener
      (stop~ stub-listener)
      (set! stub-listener {})))
  
  
  ;;;
  ;;;; Proxy Dispatcher
  ;;;
  
  
  (method public (get-proxy-dispatcher)
    (when (not proxy-dispatcher)
      (start-proxy-dispatcher))
    proxy-dispatcher)
  
  
  (method protected (start-proxy-dispatcher)
    (set! proxy-dispatcher (new Proxy-Dispatcher)))
  
  
  (method protected (stop-proxy-dispatcher)
    (when proxy-dispatcher
      (stop-dispatcher~ proxy-dispatcher)
      (set! proxy-dispatcher {})))


  ;;;
  ;;;; Process Server
  ;;;
  
  
  (method public (get-local-process-server)
    (when (not local-process-server)
      (set! local-process-server (new-local-process-server)))
    local-process-server)

  
  (method protected virtual (new-local-process-server)
    #f
    @convert
    (new Process-Server-Local-Proxy (new Process-Server self)))


  ;;;
  ;;;; Directory Server
  ;;;
  
  
  (method public (get-local-directory-server)
    (when (not local-directory-server)
      (set! local-directory-server (new-local-directory-server)))
    local-directory-server)

  
  (method protected virtual (new-local-directory-server)
    #f
    @convert
    (new Directory-Server-Local-Proxy (new Directory-Server)))
  
  
  (method protected virtual (register-base-objects)
    )


  ;;;
  ;;;; Router Server
  ;;;
  
  
  (method public (get-router-server)
    (when (and router-server (not (live?~ router-server)))
      (set! router-server {}))
    (unless router-server
      (set! router-server (locate-router-server)))
    router-server)
  
  
  (method (locate-router-server)
    (let ((server (unmarshal {IOR {Host name: "localhost"} router-stub-listener Router-Server-Remotable ()})))
      (when (not (live?~ server))
        (unless (launch-router-server interpreted?: #t)
          (error "Unable to launch router process")))
      server))
  
  
  (method (launch-router-server (interpreted?: interpreted? #f))
    (if (not interpreted?)
        (unimplemented 'launch-router-server)
      (launch-process app: "Router" homedir: "Products/org.jazz.opt/Projects/Router/Distribution" wait-ready: "JAZZ.ROUTER")))


  ;;;
  ;;;; Controller
  ;;;
  

  (method public (get-controller-process-server)
    controller-process-server)
  

  (method public (get-controller-directory-server)
    controller-directory-server)
  
  
  (method protected virtual (setup-controller)
    (when (command-argument "controllerhost")
      (attach-to-controller (new-controller-process-server))))
  
  
  (method protected virtual (new-controller-process-server)
    (let* ((host (new Host ip: (parse-integer (command-argument "controllerhost"))))
           (port (parse-integer (command-argument "controllerport")))
           (remotable 'Process-Server-Remotable)
           (ior (new IOR host port remotable {})))
      (unmarshal ior)))

  
  (method public (attach-to-controller ct)
    (detach-from-controller reattach-local?: #f)
    (set! controller-process-server ct)
    (set! controller-directory-server (get-directory-server~ controller-process-server))
    (set! controller-debugger-server (find-object~ controller-directory-server 'debugger))
    (setup-local-debuggee)
    (attach-debuggee~ controller-debugger-server local-debuggee))
  
  
  (method public (setup-local-debuggee)
    @convert
    (when (not local-debuggee)
      (set! local-debuggee (new Debuggee-Local-Proxy (new Debuggee self)))))
  
  
  (method public (detach-from-controller (reattach-local?: reattach-local? #t))
    (when controller-process-server
      (detach-from-debugger)
      (set! controller-process-server {})
      (set! controller-directory-server {})
      (set! local-debuggee {})
      (when reattach-local?
        (reattach-local-controller))))
  
  
  (method protected virtual (reattach-local-controller)
    )


  ;;;
  ;;;; Debugger
  ;;;


  (method public (get-controller-debugger-server)
    controller-debugger-server)
  
  
  (method public virtual (get-local-debugger-server)
    {})
  
  
  (method public (detach-from-debugger)
    (when controller-debugger-server
      (when (live?~ controller-debugger-server)
        (detach-debuggee~ controller-debugger-server local-debuggee))
      (set! controller-debugger-server {})))


  ;;;
  ;;;; Debuggee
  ;;;
  
  
  (method public (get-local-debuggee)
    local-debuggee)
  
  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-process (app: app {})
                                 (homedir: homedir {})
                                 (profile: profile {})
                                 (command-action: command-action {})
                                 (command-arguments: command-arguments '())
                                 (debug?: debug? #f)
                                 (wait-ready: wait-ready {})
                                 (wait-ready-timeout: wait-ready-timeout 5000))
    (let* ((root          (parse~ {Directory Jazz}))
           (launcher      (parse~ {File Install "Launcher.exe"}))
           (homedir-arg   (if homedir (format " /homedir \"{a}/{a}\"" root homedir) ""))
           (rootdir-arg   (format " /rootdir \"{a}\"" root))
           (app-arg       (format " /app {a}" app))
           (profile-arg   (format " /profile {a}" profile))
           (action-arg    (if command-action (format " {a}" command-action) ""))
           (arguments-arg (if command-arguments (format " {a}" command-arguments) ""))
           (command       (format "\"{a}\"{a}{a}{a}{a}{a}{a}" launcher action-arg homedir-arg rootdir-arg app-arg profile-arg arguments-arg)))
      (create-process command wait-ready: wait-ready wait-ready-timeout: wait-ready-timeout wait?: #f)))


  ;;;
  ;;;; Error
  ;;;
  
  
  ;; A quick fix for the fact these methods must be handled differently
  ;; if the process is an application or if it's a pure process that will
  ;; not have the classes to implement them using a graphical interface...
  
  
  @convert-error
  (method meta public (present-error error prefix? active-content?)
    (typecase error
      ((Read-Error) (present-read-error error prefix? active-content?))
      ((Walk-Error) (present-walk-error error prefix? active-content?))
      (else (present-generic-error error prefix? active-content?))))
  
  
  @convert-error
  (method meta public virtual abstract (log-error error output)
    )
  
  
  @convert-error
  (method meta public virtual abstract (edit-error error)
    )
  
  
  @convert-error
  (method meta public virtual abstract (edit-error-child error info)
    )
  
  
  @convert-error
  (method meta public virtual (present-generic-error error prefix? active-content?)
    (let ((message (get-message~ error)))
      (list
        (if (not prefix?)
            message
          (format "{a}: {a}" (type-name (class-of error)) message)))))


  ;;;
  ;;;; Read-Error
  ;;;

  
  @convert-error
  (method meta public virtual (present-read-error error prefix? active-content?)
    (let* ((source (get-source~ error))
           (header (format "Read error found in {a}" (if (string? source) "string" (get-base~ source))))
           (message (get-message~ error)))
      (format "{a}{%}{%}{a}" header message)))


  ;;;
  ;;;; Walk-Error
  ;;;
      
  
  @convert-error
  (method meta public virtual (present-walk-error error prefix? active-content?)
    (let* ((problems (get-problems~ error))
           (count (length problems))
           (header (format "{a} walk error{a} found in {a}"
                           count
                           (format-plural count)
                           (get-category-name~ error)))
           (printer (open-output-string)))
      (format printer "{a}{%}" header)
      (for-each (function (problem)
                  (let ((message (walk-problem-message problem)))
                    (format printer "{%}{a}" message)))
                problems)
      (get-output-string printer)))


  ;;;
  ;;;; Debug
  ;;;

  
  (method protected virtual (debug-exception exception frame accountable)
    (process-exception exception frame accountable))
  
  
  (method (process-exception exception frame accountable)
    (exception-reported)
    (log-execution-context exception)
    (cond ((not loop-running?)
           (dump-stack exception: exception)
           (present-exception exception type: 'message)
           (exit-process))
          (else
           (log-exception exception)
           (report-exception exception frame accountable))))
  
  
  (method protected virtual (exception-reported)
    )
  
  
  (method protected virtual (log-exception exception)
    )
  
  
  (method (log-execution-context exception)
    (let ((context (get-execution-context)))
      (when context
        (let ((stack (get-execution-stack))
              (reporter (get-reporter~ context)))
          (when reporter
            (let ((message (present-message~ exception prefix?: prefix?)))
              (report-execution-context message stack reporter)))))))

  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method (report-execution-context message execution-stack reporter)
    (unimplemented 'report-execution-context)
    @convert-error(
    (set-message~ reporter "")
    (set-message~ reporter "*** Error ***")
    (set-message~ reporter "")
    (set-message~ reporter message)
    (set-message~ reporter "")
    (for-each (function (node)
                (let ((title (get-title~ node))
                      (details (get-details~ node)))
                  (set-message~ reporter title)
                  (for-each (function (detail)
                              (user-message~ reporter "- {a}" detail))
                            details)))
              execution-stack)
    (set-message~ reporter "")
    (set-message~ reporter "*************")
    (set-message~ reporter "")))
  
  
  (method protected virtual (report-exception exception frame accountable)
    (unimplemented 'report-exception)
    @convert-error
    (typecase exception
      ((Read-Error)
       (report-read-error exception))
      ((Walk-Error)
       (report-walk-error exception))
      (else
       (case (present-exception exception)
         ((cancel)
          (stop-debugging))
         ((yes)
          (cond ((not controller-debugger-server)
                 (dump-stack exception: exception)
                 (throw-stop))
                ((not (primary-thread?))
                 (present-thread-stack (dump-stack exception: exception))
                 (throw-stop))
                (else
                 (invoke-debugger exception frame accountable))))))))
  
  
  (method protected virtual (present-thread-stack file)
    (message-box "Sorry, thread debugging is not yet fully implemented{%}{%}"))
  
  
  (method protected virtual (select-debugger)
    )


  (method (present-exception exception (type: type 'error) (prefix?: prefix? #t))
    (if (get-execution-context)
        (present-execution-context exception type prefix?)
      (let* ((message (present-message~ exception prefix?: prefix?))
             (yes (case type ((message) "OK") (else "Debug")))
             (cancel (case type ((message) {}) (else "Ignore"))))
        (message-box message
                     type: type
                     yes: yes
                     cancel: cancel))))
  
  
  (method protected virtual (present-execution-context exception type prefix?)
    )
  
  
  (method public (stop-debugging)
    (throw-stop))
  
  
  (method (invoke-debugger exception frame accountable)
    (unimplemented)
    @convert-error
    (if (interpreter-present?)
        (break-exception local-debuggee exception frame accountable)
      (dump-stack exception: exception)
      (stop-debugging)))
  
  
  (method protected virtual (report-read-error exception)
    (let* ((message (present-message~ exception))
           (code (message-box message
                              title: "Read Error")))
      (stop-debugging)))
  
  
  (method protected virtual (report-walk-error exception)
    (let* ((message (present-message~ exception))
           (code (message-box message
                              title: "Walk Error")))
      (stop-debugging)))))
