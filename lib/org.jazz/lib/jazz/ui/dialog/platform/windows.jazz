;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Windows Dialogs
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.dialog.platform.windows jazz


(import (jazz.io)
        (jazz.library)
        (jazz.platform)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.utilities))


;;;
;;;; File
;;;


(definition public (choose-file (title: title {})
                                (directory: directory {})
                                (initial-filename: initial-filename {})
                                (extensions: extensions '())
                                (multiple-selection?: multiple-selection? #f)
                                (anchors: anchors {}))
  (close-all-popups)
  (let ((size (if multiple-selection? (+ MAX_PATH (* 64 50)) MAX_PATH)))
    (with ((r (OPENFILENAME-make))
           (buffer (WCHAR-array-make size)))
      (if (not initial-filename)
          (WCHAR-array-set! buffer 0 #\nul)
        (WCHAR-copy buffer initial-filename size))
      (let ((fake-extensions-filter @fake (extensions-filter extensions) NULL)
            (fake-current-directory @fake (get-current-directory) NULL)
            (fake-dialog-proc @fake (get-dialog-proc) NULL))
        (OPENFILENAME-lStructSize-set! r     (OPENFILENAME-sizeof))
        (OPENFILENAME-hwndOwner-set! r       (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
        (OPENFILENAME-lpstrFilter-set! r     fake-extensions-filter)
        (OPENFILENAME-lpstrFile-set! r       buffer)
        (OPENFILENAME-nMaxFile-set! r        size)
        (OPENFILENAME-lpstrInitialDir-set! r (if directory (parse~ directory) fake-current-directory))
        (OPENFILENAME-lpstrTitle-set! r      (either title NULL))
        (OPENFILENAME-Flags-set! r           (bitwise-ior OFN_EXPLORER (if multiple-selection? OFN_ALLOWMULTISELECT 0) OFN_HIDEREADONLY OFN_ENABLEHOOK OFN_FILEMUSTEXIST OFN_ENABLESIZING))
        (OPENFILENAME-lpstrDefExt-set! r     NULL)
        (OPENFILENAME-lCustData-set! r       0)
        (OPENFILENAME-lpfnHook-set! r        fake-dialog-proc))
      (let ((anchorize
              (function (pathname)
                (anchorize~ pathname anchors: anchors))))
        (if (GetOpenFileName r)
            (begin
              (if (not multiple-selection?)
                  (let ((filename (WCHAR-string buffer)))
                    (anchorize (new File (tokenise-windows filename))))
                (let ((tokens (tokenise-choose-file-string buffer)))
                  (if (= (length tokens) 1)
                      (let ((filename (WCHAR-string buffer)))
                        (list (anchorize (new File (tokenise filename)))))
                    (bind (dir . filenames) tokens
                      (let ((dirlist (tokenise dir)))
                        (map (function (filename)
                               (anchorize (new File (append dirlist (list filename)))))
                             filenames)))))))
          (let ((code (CommDlgExtendedError)))
            (if (= code 0)
                (throw-cancel)
              (error "Dialog error: {t}" code))))))))


;;;
;;;; New File
;;;


(definition (map-WCHAR-array buffer size)
  (map (function dynamic (n)
         (let ((char (WCHAR-array-ref buffer n)))
           char))
       (naturals 0 size)))


(definition public (choose-new-file (directory: directory {})
                                    (initial-filename: initial-filename {})
                                    (default-extension: default-extension {})
                                    (extensions: extensions '())
                                    (anchors: anchors {}))
  ;; (debug directory initial-filename default-extension extensions anchors)
  ;; #f "New" "jazz" (("Jazz Texts (*.jazz)" . "*.jazz")) #f
  (close-all-popups)
  (when directory
    (create-directories~ directory))
  (with ((r (OPENFILENAME-make))               ; not freed!
         (buffer (WCHAR-array-make MAX_PATH))) ; not freed!
    (if (not initial-filename)
        (WCHAR-array-set! buffer 0 #\nul)
      (WCHAR-copy buffer initial-filename MAX_PATH))
    (let ((fake-extensions-filter @fake (extensions-filter extensions) NULL)
          (fake-current-directory @fake (get-current-directory) NULL)
          (fake-dialog-proc @fake (get-dialog-proc) NULL))
      (OPENFILENAME-lStructSize-set! r     (OPENFILENAME-sizeof))
      (OPENFILENAME-hwndOwner-set! r       (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
      (OPENFILENAME-lpstrFilter-set! r     fake-extensions-filter @w (extensions-filter extensions))
      (OPENFILENAME-lpstrFile-set! r       buffer)
      (OPENFILENAME-nMaxFile-set! r        MAX_PATH)
      (OPENFILENAME-lpstrInitialDir-set! r (if directory (parse~ directory) fake-current-directory @w (get-current-directory)))
      (OPENFILENAME-Flags-set! r           (bitwise-ior OFN_EXPLORER OFN_ENABLEHOOK @w OFN_FILEMUSTEXIST OFN_ENABLESIZING OFN_OVERWRITEPROMPT))
      (OPENFILENAME-lpstrDefExt-set! r     (either default-extension NULL))
      (OPENFILENAME-lCustData-set! r       0)
      (OPENFILENAME-lpfnHook-set! r        fake-dialog-proc @w (get-dialog-proc)))
    @debug-bug
    (debug 'before-GetSaveFileName (map-WCHAR-array buffer MAX_PATH))
    (if (GetSaveFileName r)
        (let ((filename (WCHAR-string buffer)))
          @debug-bug
          (debug 'after-GetSaveFileName (map-WCHAR-array buffer MAX_PATH))
          (anchorize~ (new File (tokenise filename)) anchors: anchors))
      (let ((code (CommDlgExtendedError)))
        (if (= code 0)
            (throw-cancel)
          (error "Dialog error: {t}" code))))))


;;;
;;;; Directory
;;;


(definition public (choose-directory (title: title {})
                                     (directory: directory {})
                                     (anchors: anchors {}))
  (close-all-popups)
  (let ((preserved #f @fake (get-current-directory)))
    (when directory
      @fake
      (current-directory (parse~ directory)))
    (with ((r (BROWSEINFO-make))                 ; not freed!
           (buffer (WCHAR-array-make MAX_PATH))) ; not freed!
      (WCHAR-array-set! buffer 0 #\nul)
      (BROWSEINFO-hwndOwner-set! r (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
      (BROWSEINFO-pidlRoot-set! r NULL)
      (BROWSEINFO-pszDisplayName-set! r buffer)
      (BROWSEINFO-lpszTitle-set! r (either title NULL))
      (BROWSEINFO-ulFlags-set! r 0)
      (BROWSEINFO-lpfn-set! r NULL @fake (get-browse-callback))
      (BROWSEINFO-lParam-set! r 0)
      (BROWSEINFO-iImage-set! r 0)
      (with ((items (SHBrowseForFolder r)))      ; not freed!
        (when directory
          @fake
          (current-directory preserved))
        (if (not items)
            (throw-cancel)
          (let ((directory (WCHAR-string buffer)))
            (anchorize~ (new Directory (tokenise directory)) anchors: anchors)))))))


;;;
;;;; Utilities
;;;


(definition (tokenise-choose-file-string buffer)
  (let loop ((offset 0)
             (start-of-string? #t))
       (let ((end-of-string? (eq? #\nul (WCHAR-array-ref buffer offset))))
         (if start-of-string?
             (if end-of-string?
                 '()
               (cons (WCHAR-string (WCHAR-subarray buffer offset))
                     (loop (+ offset 1) end-of-string?)))
           (loop (+ offset 1) end-of-string?)))))


;; Returns NULL used by file dialogs. Windows specific.
;; We will need a platform independent dialog.
(definition public (extensions-filter extensions)
  NULL
  @convert
  (if (null? extensions)
      NULL
    (let ((dst (new List-Factory))
          (separator (make-string 1 #\nul)))
      (for-each (function (ext)
                  (put~ dst (car ext))
                  (put~ dst (cdr ext)))
                extensions)
      (put~ dst separator)
      (join (get-output~ dst) separator)))))
