;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Outline View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.outline.Outline-View jazz


(import (jazz.library)
        (jazz.literals)
        (jazz.ui)
        (jazz.utilities))


;;;
;;;; Terminology
;;;


;; visible   : a row that has all its parents expanded
;; displayed : a row that is displayed on-screen even if only partially
;; rank      : the rank of a visible row


(class Outline-View extends View

  
  (property protected default-row-height <fx>   initialize 17 getter get-default-row-height setter set-default-row-height)
  (property protected row-spacing        <fx>   initialize 0  getter get-row-spacing        setter set-row-spacing)
  (property protected left-padding       <fx>   initialize 0  getter get-left-padding       setter set-left-padding)
  (property protected top-padding        <fx>   initialize 0  getter get-top-padding        setter set-top-padding)
  (property protected background-filler         initialize {} getter get-background-filler  setter set-background-filler)
  
  
  (slot protected root-row                      initialize {})
  (slot protected first-displayed               initialize {})    ;; first row that is displayed even if partially
  (slot protected first-displayed-rank   <fx>   initialize 0)     ;; first displayed row's rank
  (slot protected first-displayed-offset <fx>   initialize 0)     ;; amount of scroll that would be needed to uncover a partially displayed row
  (slot protected visible-count          <fx>   initialize 0)
  (slot protected visible-height         <fx>   initialize 0)
  (slot protected visible-width          <fx>   initialize 0)
  (slot protected selection                     initialize '())
  (slot protected line-size              <fx>   initialize 16)
  (slot protected page-size              <fx>   initialize 320)
  (slot protected hscrollbar?            <bool> initialize #f)
  (slot protected vscrollbar?            <bool> initialize #f)
  

  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method (install rest)
    (nextmethod rest)
    (setup-outline))
  
  
  (method (finish rest)
    (nextmethod rest)
    (layout-scrollee))
  
  
  (method (setup-outline)
    (set! root-row (new (row-class)))
    (set-parent~ root-row self)
    (set-father~ root-row {})
    (set-level~ root-row -1)
    (set-state~ root-row 'expanded))


  ;;;
  ;;;; Events
  ;;;
  
  
  (method (size-change size)
    (nextmethod size)
    @was-this-really-necessary? (unless update-locked?
      (layout-scrollee)))
  

  ;;;
  ;;;; Access
  ;;;


  (method public (get-default-row-height)
    default-row-height)


  (method public (set-default-row-height height)
    (set! default-row-height height))


  (method public (get-row-spacing)
    row-spacing)


  (method public (set-row-spacing spacing)
    (set! row-spacing spacing)
    (invalidate-view))

  
  (method public (get-left-padding)
    left-padding)
  
  
  (method public (set-left-padding padding)
    (set! left-padding padding)
    (invalidate-view))
  
  
  (method public (get-top-padding)
    top-padding)
  
  
  (method public (set-top-padding padding)
    (set! top-padding padding)
    (invalidate-view))
  

  (method public (get-background-filler)
    background-filler)


  (method public (set-background-filler value)
    (set! background-filler value)
    (invalidate-view))


  ;;;
  ;;;; State
  ;;;
  
  
  (method public (get-expand-state (include-invisibles?: include-invisibles? #f))
    (when root-row
      (letrec ((proc
                 (function (row)
                   (let ((title (get-title~ (first-child~ row)))
                         (state (get-state~ row))
                         (sons (get-sons~ row)))
                     (when (or (and include-invisibles? (> (cardinality sons) 0)) (eq? state 'expanded))
                       (cons title
                             (cons state
                                   (collect proc sons))))))))
        (collect proc (get-sons~ root-row) type: List))))
  
  
  ;; This function will only work properly for a fully collapsed outline.
  ;; Note that its main purpose beeing to restore a new outline to a stored state,
  ;; this is not a limitation but a design decision.
  (method public (set-expand-state state)
    (when root-row
      (letrec ((proc
                (function (row info)
                  (bind (title state . children) info
                    (let ((subrow (find-by-title~ row title)))
                      (when subrow
                        (let ((actual (get-state~ subrow)))
                          (if (eq? state 'expanded)
                              (unless (eq? actual 'expanded)
                                (expand/collapse subrow))
                            (when (and (eq? actual 'dynamic) children)
                              (update-row subrow))))
                        (for-each (function (info)
                                    (proc subrow info))
                                  children)))))))
        (for-each (function (info)
                    (proc root-row info))
                  state))))
  
  
  ;;;
  ;;;; Spine
  ;;;
  
  
  (method public (expand-spine spine)
    (when root-row
      (letrec ((proc
                (function (row spine)
                  (bind (title . subspine) spine
                    (let ((subrow (find-by-title~ row title)))
                      (when subrow
                        (let ((actual (get-state~ subrow)))
                          (unless (or (eq? actual 'expanded) (null? subspine))
                            (expand/collapse subrow)))
                        (if (null? subspine)
                            subrow
                          (proc subrow subspine))))))))
        (proc root-row spine))))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method (find-subdrawing pos <Point>)
    (let ((row (v->row (get-v~ pos))))
      (when row
        (let ((row (get-row row)))
          (find-drawing~ row (- pos (get-position~ row)))))))
  

  ;;;
  ;;;; Layout
  ;;;
  
  
  (method (layout-scrollee-content)
    (layout-rows))
  
  
  (method (layout-rows)
    (let ((width (- (get-width) left-padding))
          (row (get-next~ root-row))
          (rt top-padding))
      (while row
        (let* ((height (either (get-row-height~ row) default-row-height))
               (rb (+ rt height)))
          (set-position~ row (new Point left-padding rt))
          (set-size~ row (new Dimension width height))
          (set! rt rb)
          (set! row (get-next~ row))
          (increase! rt row-spacing)))))
  

  ;;;
  ;;;; Scrollee
  ;;;
  
  
  (method (scrollee-size)
    (new Dimension (scrollee-width) (scrollee-height)))
  
  
  (method (scrollee-width)
    (max (get-display-width) (+ left-padding visible-width)))
  
  
  (method (scrollee-height)
    (max (get-display-height) (+ top-padding (+ visible-height row-spacing))))
  
  
  (method public (get-visible-width)
    visible-width)
  
  
  (method public (get-visible-height)
    visible-height)
  

  ;;;
  ;;;; Update
  ;;;
  
  
  (method (invalidate-update)
    (update-displayed)
    (update-visible)
    (layout-scrollee)
    (invalidate-view)
    (update-scrollbars))
  
  
  (method public virtual (update-visible)
    )


  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method (draw-children surface context update lh lv sh sv sc sc?)
    (let ((update-rect (get-update-rect surface update lh lv)))
      (let ((background (get-drawing-background context)))
        (when background
          (fill-rect~ surface update-rect background)))
      (draw-outline surface context update update-rect lh lv sh sv sc sc?)))
  
  
  (method protected virtual (draw-outline surface context update update-rect lh lv sh sv sc sc?)
    (let* ((pos (get-scrolled-position))
           (top (+ (get-top~ update-rect) (get-v~ pos)))
           (bottom (+ (get-bottom~ update-rect) (get-v~ pos))))
      (draw-rows surface context update lh lv top bottom sh sv sc sc?)))
  
  
  (method (draw-rows surface context update lh <fx> lv <fx> top bottom sh <fx> sv <fx> sc <fl> sc? <bool>)
    (let ((row first-displayed)
          (rank <fx> first-displayed-rank)
          (rt <fx> (- top-padding first-displayed-offset))
          (width <fx> (get-width)))
      (while (and row (< rt bottom))
        (let* ((height <fx> (get-height~ row))
               (rb <fx> (+ rt height)))
          (when (>= rb top)
            (draw-row surface context update lh lv row rank sh sv sc sc?))
          (increase! rank)
          (set! rt rb)
          (set! row (get-next~ row))
          (increase! rt row-spacing)))
      (draw-empty surface top bottom sh sv sc sc? rt width)))
  
  
  (method protected virtual (draw-empty surface top bottom sh sv sc sc? rt width)
    )
  
  
  (method (draw-row surface context update lh <fx> lv <fx> row rank sh sv sc sc?)
    @debug-painting
    (when (eq? self (get-%~ Development))
      (log-entry name: "draw-row"))
    (let* ((width (get-width))
           (height (get-height~ row))
           (total-height (+ height row-spacing))
           (selected? (row-draw-selected? rank))
           (pos <Point> (get-position~ row)))
      (set-font~ surface font)
      (let ((new-context (optimize-context selected? rank context)))
        (paint-displayed~ row surface new-context update (+ lh (get-h~ pos)) (+ lv (get-v~ pos)) sh sv sc sc?))))
  
  
  ;; this memory optimisation should work because as drawing always
  ;; occurs in the primary thread, it is implicitly synchronized...
  (definition optimized-context
    (list selected?: {} row-rank: 0))
  
  
  (method (optimize-context selected? rank context)
    (if context
        (cons selected?: (cons selected? (cons row-rank: (cons rank context))))
      (set-second! optimized-context selected?)
      (set-fourth! optimized-context rank)
      optimized-context))


  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method public (on-prior evt)
    (prior-page (get-shift?~ evt)))
  
  
  (method protected virtual (prior-page evt)
    (scroll (new Point 0 (get-page-size 'vert))))
  
  
  (method public (on-next evt)
    (next-page (get-shift?~ evt)))
  
  
  (method protected virtual (next-page evt)
    (scroll (new Point 0 (- (get-page-size 'vert)))))
  
  
  (method (get-line-size orientation)
    (case orientation
      ((vert) default-row-height)
      ((horz) 8)))
  
  
  (method (scroll-invalidate dh dv)
    (follow (- dv)))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method protected virtual (row-class)
    Outline-Row)

  
  (method public (add-row . rest)
    (bind-keywords ((class (row-class)) (row {}) (father {}) (position {}) . others) rest
      (let* ((father (either father root-row))
             (level (+ (get-level~ father) 1))
             (row (either row (apply new class parent: self others))))
        (set-height~ row default-row-height)
        (set-descendants-level~ row level)
        (add-son~ father row position)
        (when (row-visible?~ row)
          (increase! visible-count (+ 1 (count-visible~ row)))
          (when (not update-locked?)
            (let ((height (node-height~ row)))
              (increase! visible-height height)
              (update-visible-width-incremental level (get-effective-width~ row))
              (update-displayed)
              (update-visible)
              (let* ((rank (row-rank row))
                     (top (row-top rank))
                     (display (get-display))
                     (display-size (get-size~ display))
                     (display-width (get-width~ display-size))
                     (display-height (get-height~ display-size)))
                (added-update-selection rank 1)
                (layout-scrollee)
                (when (< top display-height)
                  (invalidate-rect (row-rect rank))
                  (scroll-view~ display 0 height (new Rect 0 (+ top height) display-width display-height) erase?: #f))))))
        (update-father-control father)
        row)))
  
  
  ;; is this really necessary?
  (method protected virtual (update-visible-width-incremental level width)
    )

  
  (method public virtual (remove-row row)
    (when (attached?~ row)
      (let* ((father (get-father~ row))
             (visible? (row-visible?~ row))
             (height (node-height~ row))
             (rank (row-rank row))
             (top (essay rank (row-top rank))))
        (when visible?
          (decrease! visible-count (+ 1 (count-visible~ row)))
          (decrease! visible-height height))
        (remove-son~ father row)
        (when (= (cardinality (get-sons~ father)) 0)
          (set-state~ father 'collapsed))
        (when rank
          (removed-update-selection rank 1))
        (when (and (not update-locked?) visible?)
          (update-displayed)
          (update-visible)
          (let* ((display (get-display))
                 (display-size (get-size~ display))
                 (display-width (get-width~ display-size))
                 (display-height (get-height~ display-size)))
            (layout-scrollee)
            (when (and top (< top display-height))
              (scroll-view~ display 0 (- height) (new Rect 0 (+ top height) display-width display-height) erase?: #f))))
        (detach-descendants~ row)
        (update-father-control father))))
  
  
  (method public (move-row row father (position: position {}))
    (remove-row row)
    (let ((position (if (procedure? position) (position) position)))
      (add-row row: row father: father position: position)))
  
  
  (method public (find-ordered-position title father)
    (if (not title)
        0
      (ordered-position title (get-sons~ father) key: row-title test: (sort-predicate 'smaller/equal))))
  
  
  (method public virtual (remove-every-row)
    (setup-outline)
    (set! visible-count 0)
    (set! visible-height 0)
    (set! visible-width 0)
    (set! first-displayed {})
    (set! first-displayed-rank 0)
    (set! first-displayed-offset 0)
    (set! selection '())
    (when scroller
      (set-position {Point 0 0})
      (set-size {Dimension 0 0})
      (set-scroll-pos 'vert 0 #f)
      (set-scroll-pos 'horz 0 #f))
    (unless update-locked?
      (update-displayed)
      (layout-scrollee)
      (invalidate-view)))
  
  
  (method protected virtual (update-father-control father)
    )
  
  
  (method (update-displayed)
    (let ((row (first-visible-son~ root-row))
          (rank <fx> 0)
          (v <fx> (get-display-v)))
      (when row
        (let ((bottom <fx> (- v (get-height~ row))))
          (while (> bottom 0)
            (let ((next (get-next~ row)))
              (if (not next)
                  (set! bottom 0)
                (set! row next)
                (increase! rank)
                (set! v (- bottom row-spacing))
                (set! bottom (- v (get-height~ row))))))))
      (set! first-displayed row)
      (set! first-displayed-rank rank)
      (set! first-displayed-offset (if row v 0))))
  
  
  (method public (get-root-row)
    root-row)
  
  
  (method public (first-row)
    (first (get-sons~ root-row)))
  
  
  (method public (get-row n <fx>) <Outline-Row>
    ;; the first test is necessary because an update lock will stop update-displayed...
    (if (and (not update-locked?) first-displayed (>= n first-displayed-rank))
        (get-displayed-row (- n first-displayed-rank))
      (let ((row root-row))
        (while (and row (>= n 0))
          (set! row (get-next~ row))
          (decrease! n))
        row)))
  
  
  (method public (get-visible-row n)
    (continuation-capture
      (function (return)
        (for-each-visible-row
          (function (row rank)
            (when (= rank n)
              (continuation-return return row))))
        {})))
  
  
  ;; for debugging...
  (method (get-row-classic n)
    (let ((row root-row))
      (while (and row (>= n 0))
        (set! row (get-next~ row))
        (decrease! n))
      row))
  
  
  (method (get-displayed-row n)
    (let ((row first-displayed))
      (while (and row (> n 0))
        (set! row (get-next~ row))
        (decrease! n))
      row))
  
  
  (method public (row-rank target)
    (continuation-capture
      (function (return)
        (for-each-visible-row
          (function (row rank)
            (when (eq? row target)
              (continuation-return return rank))))
        {})))
  
  
  (method public (rows-ranks targets)
    (map row-rank targets))
  
  
  (method public (row-title row)
    (get-title~ (first-child~ row)))
  
  
  (method public (get-visible-count)
    visible-count)
  
  
  (method (forward row n)
    (while (> n 0)
      (set! row (get-next~ row))
      (decrease! n))
    row)
  
  
  (method (backward row n)
    (while (> n 0)
      (set! row (get-previous~ row))
      (decrease! n))
    row)
  
  
  (method public (ensure-row-exists row)
    (ensure-visible-count (+ row 1)))
  
  
  (method public (ensure-visible-count n)
    (while (< visible-count n)
      (add-empty-row)))
  
  
  (method public virtual (add-empty-row (father: father {}))
    (let ((father (either father root-row)))
      (add-row father: father)))
  
  
  (method protected virtual (row-selected? row)
    (= row selection))
  
  
  (method protected virtual (row-draw-selected? row)
    (row-selected? row))
  

  (method public (get-row-count)
    (if (not root-row)
        0
      (cardinality (get-sons~ root-row))))


  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method (mouse-down view)
    (acquire-focus)
    (let ((row (v->row (get-v~ view))))
      (set-selection row)))
  
  
  (method (double-click view)
    (let ((row (v->row (get-v~ view))))
      (when row
        (expand/collapse (get-row row)))))

  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method protected virtual (empty-selection)
    '())
  
  
  (method public virtual (get-selection)
    selection)
  
  
  (method public virtual (set-selection sel
                                        (force?: force? #f)
                                        (ensure-displayed?: ensure-displayed? #t)
                                        (generate-event?: generate-event? #t)
                                        (user-origin?: user-origin? #f))
    (when (or force? #t @parameterized-fix-me (/= sel selection))
      (let ((old selection))
        (set! selection sel)
        (when ensure-displayed?
          (ensure-displayed))
        (when (not-null? old)
          (invalidate-selection old))
        (when (not-null? selection)
          (invalidate-selection selection))
        (when generate-event?
          (call-selection-handler old selection force? user-origin?)))))

  
  (method public virtual (invalidate-selection sel)
    (let ((player (get-player)))
      (when player
        (let ((root (get-root)))
          (receive (dh dv sc) (get-delta~ root self)
            (with-closed ((region (selection-region sel dh dv sc)))
              (invalidate-region~ player region #t)))))))
  
  
  (method protected virtual (selection-region sel dh dv sc)
    (selection-row-region sel dh dv sc))
  
  
  (method protected (selection-row-region n dh dv sc)
    (new Region rect: (acquire-delta dh dv sc (selection-row-rect n))))
    
  
  (method protected virtual (selection-row-rect n)
    (get-rect~ (get-row n)))

  
  ;; update slots that are rank based
  (method protected virtual (added-update-selection rank count)
    (when (and selection (>= selection rank))
      (increase! selection count)))
  
  
  ;; update slots that are rank based
  (method protected virtual (removed-update-selection rank count)
    (when (not-null? selection)
      (let ((selected? #f))
        (when (>= selection rank)
          (if (>= selection (+ rank count))
              (decrease! selection count)
            (set! selection '())
            (set! selected? #t)))
        selected?)))
  
  
  ;;;
  ;;;; Navigation
  ;;;
  
  
  (method public (for-each-row proc)
    (let ((rank 0))
      (define (recurse row visible?)
        (let* ((visible? (and visible? (get-visible-flag~ row)))
               (son-visible? (and visible? (expanded?~ row))))
          (proc row (essay visible? rank))
          (when visible?
            (increase! rank))
          (iterate (get-sons~ row)
                   (function (row)
                     (recurse row son-visible?)))))
      
      (recurse root-row (row-visible?~ root-row))))
  
  
  (method public (for-each-visible-row proc (start: start {}) (end: end {}) (wrap?: wrap? #f))
    (let ((row (either start (get-next~ root-row)))
          (rank (if start (row-rank start) 0)))
      (when rank
        (while (and row (neq? row end))
          (proc row rank)
          (set! row (get-next~ row))
          (increase! rank))
        (when (and wrap? start (not row))
          (for-each-visible-row proc end: (either end start))))))
  
  
  (method public (for-each-visible-descendant parent-row proc)
    (let* ((first-son (first-visible-son~ parent-row))
           (last-son (last-visible-descendant~ parent-row))
           (end-row (essay last-son (get-next~ last-son))))
      (when first-son
        (for-each-visible-row proc start: first-son end: end-row))))

  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public virtual (get-content)
    (get-sons~ root-row))
  
  
  (method public virtual (set-content content)
    (set-sons~ root-row content)
    (set-next~ root-row (car content))
    (invalidate-columns)
    (set! visible-count (count-visible~ root-row))
    (set! visible-height (sons-height~ root-row))
    (set-selection (empty-selection))
    (update-displayed)
    (layout-scrollee)
    (invalidate-view))
  
  
  (method public (set-subrows row seq proc)
    (unless (empty? seq)
      (let* ((row (either row root-row))
             (count 0)
             (height 0)
             (level (+ (get-level~ row) 1))
             (previous {})
             (rows (map (function (info)
                          (let ((subrow (proc info)))
                            (set-father~ subrow row)
                            (set-level~ subrow level)
                            (when previous
                              (set-previous~ subrow previous)
                              (set-next~ previous subrow))
                            (set! previous subrow)
                            (increase! count)
                            (increase! height (get-row-height~ subrow))
                            subrow))
                        seq)))
        (set-sons~ row (essay rows (coerce rows Axis)))
        (when (eq? (get-state~ row) 'expanded)
          (let ((old-next (get-next~ row))
                (first-son (first rows)))
            (link-rows row first-son)
            (let ((last (last-proper-descendant~ row)))
              (link-rows last old-next)))
          (increase! visible-count count)
          (increase! visible-height height)))))
  
  
  ;; temp...
  (method public virtual (invalidate-columns)
    )


  ;;;
  ;;;; State
  ;;;
  
  
  (method public virtual (expand/collapse row)
    (case (get-state~ row)
      ((collapsed) (expand row))
      ((expanded) (collapse row))))
  
  
  (method protected virtual (update-row row)
    )
  
  
  (method public (expand row (dynamic? #f))
    (when (neq? (get-state~ row) 'expanded)
      (set-state~ row 'expanded)
      (let ((first (first-descendant~ row))
            (last (last-visible-descendant~ row))
            (previous row)
            (next (get-next~ row))
            (in-expand? #t))
        (when first
          (show-rows first last previous next (row-visible?~ row) in-expand? dynamic?)))))
  
  
  (method protected virtual (invalidate-expand row top dynamic?)
    )
  
  
  (method public (expand-all row)
    (with-update-locked
      (function ()
        (unless (eq? (get-state~ row) 'expanded)
          (expand/collapse row))
        (iterate (get-sons~ row) expand-all))))
  
  
  (method public (collapse row)
    (when (neq? (get-state~ row) 'collapsed)
      (let ((first (first-descendant~ row))
            (in-collapse? #t))
        (if (not first)
            (set-state~ row 'collapsed)
          (let ((rank (row-rank row))
                (top (get-v~ (get-position~ row)))
                (selected? (row-selected? row)))
            (invalidate-collapse rank row top selected?))
          (hide-rows first (last-proper-descendant~ row) (row-visible?~ row) in-collapse?)))))
  
  
  (method protected virtual (collapse-selection rank selected?)
    )
  
  
  (method protected virtual (invalidate-collapse rank row top selected?)
    (when selected?
      (invalidate-rect (row-rect rank))))
  
  
  (method public (collapse-all row)
    (with-update-locked
      (function ()
        (iterate (get-sons~ row) collapse-all)
        (when (eq? (get-state~ row) 'expanded)
          (expand/collapse row)))))
  
  
  (method (link-rows before after)
    (when before
      (set-next~ before after))
    (when after
      (set-previous~ after before)))
  
  
  (method (unlink-rows first last)
    (let ((previous (get-previous~ first))
          (next (get-next~ last)))
      (link-rows previous next)
      (set-previous~ first {})
      (set-next~ last {})))
  
  
  (method public (ensure-expanded row)
    (let ((scan (get-father~ row)))
      (while scan
        (when (eq? (get-state~ scan) 'collapsed)
          (expand scan))
        (set! scan (get-father~ scan)))))
  
  
  (method public (ensure-expanded-rows rows)
    (for-each ensure-expanded rows))


  ;;;
  ;;;; Visibility
  ;;;
  
  
  ;; this will currently only work with flat outlines
  (method public (set-visibilities predicate)
    (let ((previous root-row))
      (iterate (get-sons~ root-row)
               (function (row)
                 (let ((visible? (predicate row)))
                   (when visible?
                     (link-rows previous row)
                     (set! previous row)))))))
  
  
  (method public (show-rows first last previous next visible? in-expand? dynamic?)
    (link-rows previous first)
    (link-rows last next)
    (when (and (not update-locked?) visible?)
      (receive (count height width) (count-visible-size first last #t)
        (increase! visible-count count)
        (increase! visible-height height)
        (update-visible-width-incremental (get-level~ previous) width)
        (update-displayed)
        (update-visible)
        (let* ((rank (row-rank previous))
               (top (either (get-v~ (get-position~ previous)) 0))
               (opens (+ top (get-height~ previous)))
               (display (get-display))
               (display-size (get-size~ display))
               (display-width (get-width~ display-size))
               (display-height (get-height~ display-size)))
          (added-update-selection (+ rank 1) count)
          (when (< (+ top (get-scrolled-v)) display-height)
            (when in-expand?
              (invalidate-expand previous top dynamic?))
            (scroll-view~ display 0 height (new Rect 0 opens display-width display-height) erase?: #f))
          (layout-scrollee)
          (when (> count 0)
            (ensure-row-range-displayed (+ rank 1) (+ rank count)))))))
  
  
  (method public (hide-rows first last visible? in-collapse?)
    (receive (count height width) (count-visible-size first last visible?)
      (when visible?
        (decrease! visible-count count)
        (decrease! visible-height height))
      (let ((previous (get-previous~ first)))
        (unlink-rows first last)
        (when in-collapse?
          (set-state~ previous 'collapsed))
        (when (and (not update-locked?) visible?)
          (update-displayed)
          (update-visible)
          (let* ((rank (either (row-rank previous) 0))
                 (top (either (get-v~ (get-position~ previous)) 0))
                 (opens (+ top (get-height~ first)))
                 (removed (removed-update-selection (+ rank 1) count))
                 (display (get-display))
                 (display-size (get-size~ display))
                 (display-width (get-width~ display-size))
                 (display-height (get-height~ display-size)))
            (when in-collapse?
              (collapse-selection rank removed))
            (when (< top display-height)
              (invalidate-collapse rank first top removed)
              (scroll-view~ display 0 (- height) (new Rect 0 (+ opens height) display-width (+ display-height height)) erase?: #f)))
          (layout-scrollee)))))
  
  
  (method public (count-visible-size first last visible?)
    (let ((scan (essay visible? first))
          (stop (essay last (get-next~ last)))
          (count 0)
          (height 0)
          (width 0))
      (while (and scan (neq? scan stop))
        (increase! count)
        (increase! height (+ (get-effective-height~ scan) row-spacing))
        (let ((w (get-effective-width~ scan)))
          (when (and w (> w width))
            (set! width w)))
        (set! scan (get-next~ scan)))
      (values count height width)))
  
  
  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method (follow v)
    ;; This is a patch for a bug I don't want to debug as the whole
    ;; approach about first-displayed needs to be rethought completly
    ;; See the Outline-View.follow Bug.jazz file to reproduce it...
    (let ((succeeded?
            (cond ((> v 0) (follow-forward v))
                  ((< v 0) (follow-backward (- v))))))
      (when (not succeeded?)
        (update-displayed))))
  
  
  (method (follow-forward v)
    (while (> v 0)
      (let* ((height (+ (get-height~ first-displayed) row-spacing))
             (remaining (- height first-displayed-offset)))
        (if (< v remaining)
            (begin
              (increase! first-displayed-offset v)
              (set! v 0))
          (set! first-displayed (get-next~ first-displayed))
          (increase! first-displayed-rank)
          (decrease! v remaining)
          (set! first-displayed-offset 0))))
    #t)
  
  
  (method (follow-backward v)
    (continuation-capture
      (function (return)
        (while (> v 0)
          (if (<= v first-displayed-offset)
              (begin
                (decrease! first-displayed-offset v)
                (set! v 0))
            (set! first-displayed (get-previous~ first-displayed))
            (if (not first-displayed)
                (continuation-return return #f)
              (decrease! first-displayed-rank)
              (decrease! v (+ first-displayed-offset 1))
              (set! first-displayed-offset (- (+ (get-height~ first-displayed) row-spacing) 1)))))
        #t)))


  (method public virtual (ensure-displayed . rest)
    (when (not-null? selection)
      (ensure-row-displayed selection)))
  
  
  (method public (ensure-row-displayed n)
    (let* ((row (get-row n))
           (top (get-top~ row))
           (bottom (get-bottom~ row)))
      (scroll (scroll-needed (new Point 0 top) (new Point 0 bottom) (get-scroll-context)))))
  
  
  (method public (ensure-row-range-displayed from to)
    (let ((top (get-top~ (get-row from)))
          (bottom (get-bottom~ (get-row to))))
      (scroll (scroll-needed (new Point 0 top) (new Point 0 bottom) (get-scroll-context)))))
  
  
  (method public (ensure-at-end)
    (ensure-row-displayed (- visible-count 1)))
  
  
  (method protected virtual (get-scroll-context)
    (cons 0.15 0.20))
  

  ;;;
  ;;;; Coordinates
  ;;;
  
  
  ;; This method gets called before the row is layed out.
  ;; This is why it cannot simply get the position of the row...
  (method protected (row-top n)
    (let ((row (first-row))
          (v 0))
      (while (> n 0)
        (decrease! n)
        (increase! v (get-height~ row))
        (increase! v row-spacing)
        (set! row (get-next~ row)))
      v))
  
  
  (method protected virtual (row-rect n)
    (let ((row   (get-row n))
          (left  0)
          (top   (row-top n))
          (right (get-width)))
      (new Rect left top right (+ top (get-height~ row)))))
  
  
  (method (row-region n)
    (new Region rect: (get-bounds~ (get-row n))))
  
  
  (method protected (row->v r)
    (get-top~ (get-row r)))


  (method protected (v->row v)
    (when first-displayed
      (let* ((scrolled (get-scrolled-v))
             (displayed? (>= v (- scrolled)))
             (v (if displayed? (+ v scrolled) v))
             (row (if displayed? first-displayed (first-row)))
             (rank (if displayed? first-displayed-rank 0))
             (top (if displayed? (- first-displayed-offset) 0))
             (bottom (+ top (get-height~ row) row-spacing)))
        (while (and row (or (< v top) (>= v bottom)))
          (increase! rank)
          (set! row (get-next~ row))
          (when row
            (set! top bottom)
            (set! bottom (+ top (get-height~ row) row-spacing))))
        (when (and row (< v (- bottom row-spacing)))
          rank))))


  ;; Should unify with v->row...
  (method protected (v->row-extended v)
    (when first-displayed
      (let* ((scrolled (get-scrolled-v))
             (displayed? (>= v (- scrolled)))
             (v (if displayed? (+ v scrolled) v))
             (row (if displayed? first-displayed (first-row)))
             (rank (if displayed? first-displayed-rank 0))
             (top (if displayed? (- first-displayed-offset) 0))
             (bottom (+ top (get-height~ row) row-spacing)))
        (while (and row (or (< v top) (>= v bottom)))
          (increase! rank)
          (set! row (get-next~ row))
          (when row
            (set! top bottom)
            (set! bottom (+ top (get-height~ row) row-spacing))))
        (when (and row (< v (- bottom row-spacing)))
          (values rank (- v top) (- bottom top))))))


  ;;;
  ;;;; Designer
  ;;;

  
  (method meta (property-presentation property)
    (case (field-name property)
      ((default-row-height) "Default Row Height")
      ((row-spacing)        "Row Spacing")
      ((left-padding)       "Left Padding")
      ((top-padding)        "Top Padding")
      ((background-filler)  "Background Filler")
      (else (nextmethod property))))))
