;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Drawable Figures
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.view.Drawing jazz


(import (jazz.utilities)
        (jazz.ui)
        (jazz.ui.offscreen)
        (jazz.library)
        (jazz.literals))


(class Drawing extends Figure
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method public virtual (get-player)
    (essay parent (get-player~ parent)))

  
  ;;;
  ;;;; Lie
  ;;;
  
  
  (method public (get-lie) <Point>
    (receive (h <fl> v <fl> sc) (get-lie-parent 0.0 0.0 1.0)
      (new Point (fxround h) (fxround v))))
  
  
  (method protected virtual (get-lie-parent h <fl> v <fl> sc <fl>)
    (if (not parent)
        (values h v sc)
      (get-lie-parent~ parent (+ (get-h~ position) h) (+ (get-v~ position) v) sc)))
  
  
  (method public (set-lie lie <Point>) <void>
    (let* ((actual (get-lie))
           (delta (- lie actual))
           (pos (+ position delta)))
      (set-position pos)))

  
  ;;;
  ;;;; Root
  ;;;
  
  
  (method public (get-root) <View>
    (let ((player (get-player)))
      (if player
          (get-root~ player)
        (if (is? self Root-View)
            self
          (essay parent (get-root~ parent))))))

  
  ;;;
  ;;;; Coordinates
  ;;;


  (method public (acquire origin shape)
    (receive (dh dv sc) (get-delta origin)
      (acquire-delta dh dv sc shape)))


  (method public (acquire-delta dh <fl> dv <fl> sc <fl> shape)
    (typecase shape
      ((Point)
       (let ((h <fx> (get-h~ shape))
             (v <fx> (get-v~ shape)))
         (new Point (fxround (+ dh (* h sc)))
                    (fxround (+ dv (* v sc))))))
      ((Rect)
       (let ((left <fx> (get-left~ shape))
             (top <fx> (get-top~ shape))
             (right <fx> (get-right~ shape))
             (bottom <fx> (get-bottom~ shape)))
         (new Rect (fxround (+ dh (* left sc)))
                   (fxround (+ dv (* top sc)))
                   (fxround (+ dh (* right sc)))
                   (fxround (+ dv (* bottom sc))))))
      (else
       (error "Unable to acquire {t}" shape))))
  
  
  (method protected virtual (get-delta origin <Drawing>)
    (receive (origin-h <fl> origin-v <fl> origin-sc <fl>) (get-lie-parent~ origin 0.0 0.0 1.0)
      (receive (dh <fl> dv <fl> sc <fl>) (get-lie-parent 0.0 0.0 1.0)
        (values (/ (- origin-h dh) sc) (/ (- origin-v dv) sc) (/ origin-sc sc)))))

  
  ;;;
  ;;;; Size
  ;;;


  (method (get-size)
    size)
  

  (method (set-size sz <Dimension>)
    (when (/= sz size)
      (set! size sz)
      (invalidate-layout)
      (when (get-finished?)
        (call-layout))))
  

  (method public (get-width) <fx>
    (get-width~ size))
  
  
  (method public (set-width width <fx>) <void>
    (set-size (new Dimension width (get-height))))


  (method public (get-height) <fx>
    (get-height~ size))
  
  
  (method public (set-height height <fx>)
    (set-size (new Dimension (get-width) height)))
  
  
  (method public (get-left) <fx>
    (get-h~ position))
  
  
  (method public (get-top) <fx>
    (get-v~ position))
  
  
  (method public (get-right) <fx>
    (+ (get-h~ position) (get-width~ size)))
  
  
  (method public (get-bottom) <fx>
    (+ (get-v~ position) (get-height~ size)))

  
  (method public (get-bounds) <Rect>
    (size-rect (get-size)))
  
  
  (method public (set-bounds bounds <Rect>) <void>
    (set-position (rect-position bounds))
    (set-size (rect-size bounds)))
  
  
  (method public (get-rect) <Rect>
    (position/size->rect (get-position) (get-size)))
  
  
  (method public (set-rect rect <Rect>) <void>
    (set-position (rect-position rect))
    (set-size (rect-size rect)))

  
  ;;;
  ;;;; Flags
  ;;;
  
  
  (method (get-layout-valid?)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  
  (method (set-layout-valid? flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method public virtual (get-scaled?)
    #f)


  (method public virtual (set-scaled? value)
    )
  

  (method public virtual (get-scaling) <fl>
    1.0)


  (method public virtual (set-scaling value <fl>)
    )


  (method public (logical->device shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function (lh <fx>) (fxround (+ (* (- lh sh) sc) sh))))
                (vert (function (lv <fx>) (fxround (+ (* (- lv sv) sc) sv)))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))


  (method public (device->logical shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function (dh <fx>) (+ (quotient (- dh sh) sc) sh)))
                (vert (function (dv <fx>) (+ (quotient (- dv sv) sc) sv))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))
  
  
  ;; Maybe this method should be optimized out by setting
  ;; scaling info in every child of the scaled drawing...
  (method (scaling-info)
    (let ((drawing self)
          (sh <fx> 0)
          (sv <fx> 0))
      (call/ec
        (function (return)
          (while drawing
            (let ((sc? (get-scaled?~ drawing))
                  (sc (get-scaling~ drawing)))
              (if sc?
                  (return (values sh sv sc))
                (let ((pos (get-position~ drawing)))
                  (decrease! sh (get-h~ pos))
                  (decrease! sv (get-v~ pos)))
                (set! drawing (get-parent~ drawing)))))
          {}))))

  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (fully-visible?)
    (and (get-visible?) (or (not parent) (fully-visible?~ parent))))

  
  ;;;
  ;;;; Transparency
  ;;;

  
  (method public virtual (get-transparent?)
    #f)
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method protected (invalidate-layout)
    (set-layout-valid? #f))
  
  
  (method protected (call-layout)
    (unless (get-layout-valid?)
      (layout)
      (set-layout-valid? #t)))
  
  
  (method public (layout-drawing)
    ;; No need to layout if the drawing is not initialized, because
    ;; conclude will call layout once the initialization process is done.
    (when (get-finished?)
      (invalidate-layout)
      (call-layout)))
  
  
  (method public virtual (layout)
    )

  
  ;;;
  ;;;; Iterate
  ;;;
  
  
  (method public (for-each-drawing proc <procedure> (include-invisibles?: include-invisibles? #f))
    (loop (for child in children)
          (when (and (is? child View)
                     (or include-invisibles? (get-visible?~ child)))
            (proc child))))
  
  
  (method public (for-each-drawing-reversed proc <procedure> (include-invisibles?: include-invisibles? #f))
    (for-each-reversed (function (child)
                         (when (and (is? child View)
                                    (or include-invisibles? (get-visible?~ child)))
                           (proc child)))
      children))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-drawing pos <Point>)
    (when (in-drawing? pos size)
      (either (find-subdrawing pos)
              (unless (get-transparent?)
                self))))
  
  
  (method protected virtual (in-drawing? pos <Point> size <Dimension>)
    (in-size? pos size))
  
  
  (method protected virtual (find-subdrawing pos <Point>)
    (call/ec
      (function (return)
        (for-each-drawing-reversed
          (function (view <View>)
            (let ((delta <Point> (- pos (get-position~ view))))
              (let* ((scaled? (get-scaled?~ view))
                     (found (if (not scaled?)
                                (find-drawing~ view delta)
                              (let ((scaling <fl> (get-scaling~ view)))
                                (let ((scaled (new Point
                                                (fxround (/ (get-h~ delta) scaling))
                                                (fxround (/ (get-v~ delta) scaling)))))
                                  (find-drawing~ view scaled))))))
                (when found
                  (return found))))))
        {})))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-drawing)
    (let ((rect (get-rect)))
      (invalidate-rect~ parent rect)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  ;; I think that keeping the update region makes the code complex for not much (and it doesn't work
  ;; with scaling). Why not always get the bounding box and pass it around. Drawing methods would then
  ;; always have an update rect available for consultation...
  
  
  (method public (paint surface <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (when (get-visible?)
      ;; beurk code for testing
      (if (or (get-scaled?) sc?)
          (let ((rect (h/v/size->rect lh lv size)))
            ;; quick patch for the time being
            (when #t @w (rect-intersects-region? (get-left~ scaled) (get-top~ scaled) (rect-size scaled) update)
              (paint-displayed surface context update lh lv sh sv sc sc?)))
        (when (cond ((not update) #t)
                    ((is? update Rect) (let ((lie (new Point lh lv))) (rects-intersect? update lie size)))
                    (else (rect-intersects-region? lh lv size update)))
          (paint-displayed surface context update lh lv sh sv sc sc?)))))


  (method public (paint-displayed surface <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (if (not (get-offscreen?))
        (paint-drawing surface context update lh lv sh sv sc sc?)
      (let ((offscreen (get-offscreen surface (get-width~ size) (get-height~ size))))
        (let ((origin (new Point 0 0))
              (clipper (get-bounds)))
          (setup-clipper~ offscreen clipper)
          (paint-drawing offscreen context update lh lv sh sv sc sc?)
          (let ((overlay (get-overlay)))
            (when overlay
              (draw-overlay~ overlay self offscreen (get-width~ size) (get-height~ size))))
          (let ((effect (get-effect)))
            (bit-blit~ offscreen surface size: size)
            @not-converted-to-cairo
            (if (not effect)
              (let ((lie (new Point lh lv)))
                (animate~ effect offscreen surface lie size))
              (set-effect {})))))))

  
  (method public (paint-drawing surface <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (let* ((scaled? (get-scaled?))
           (scaling (get-scaling))
           (new-sh (if (not scaled?) sh lh))
           (new-sv (if (not scaled?) sv lv))
           (new-sc (if (not scaled?) sc scaling))
           (new-sc? (if (not scaled?) sc? #t)))
      (with-transform~ surface self lh lv (get-width~ size) (get-height~ size) new-sh new-sv new-sc new-sc?
        (function ()
          (render surface context update lh lv new-sh new-sv new-sc new-sc?)))))

  
  (method public virtual (render surface <Surface> context update lh lv sh sv sc sc?)
    (draw-background surface context)
    (draw-content surface context update lh lv sh sv sc sc?)
    ;(draw-placeholder surface)
    (draw-children surface context update lh lv sh sv sc sc?))

  
  (method public virtual (draw-background surface <Surface> context)
    )
  
  
  (method public virtual (draw-content surface <Surface> context update lh lv sh sv sc sc?)
    (draw surface context update lh lv))
    
  
  (method public virtual (draw surface <Surface> context update lh lv)
    )
  
  
  (definition *colors*
    '({Color name: Dark-Red}
      {Color name: Dark-Orange}
      {Color name: Dark-Yellow}
      {Color name: Dark-Green}
      {Color name: Dark-Blue}
      {Color name: Dark-Purple}))
  
  (definition *nb-colors*
    (length *colors*))
  
  (definition *current-color*
    0)
  

  (method (draw-placeholder surface)
    (set-color~ surface {Color name: White})
    (paint~ surface)
    (fill-rect~ surface (get-bounds) (element *colors* *current-color*))
    (set! *current-color* (modulo (+ *current-color* 1) *nb-colors*)))
  
  
  (method public virtual (draw-children surface <Surface> context update lh <fx> lv <fx> sh sv sc sc?)
    (for-each-drawing
      (function (drawing)
        (let ((pos (get-position~ drawing)))
          (paint~ drawing surface context update (+ lh (get-h~ pos)) (+ lv (get-v~ pos)) sh sv sc sc?)))))
  
  
  (method protected (get-update-rect surface <Surface> update lh lv)
    (cond ((not update) (get-bounds))
          ((is? update Rect) (device->logical~ surface update))
          (else
           (let* ((box (get-box~ update))
                  (logical (device->logical~ surface box))
                  (bounds (get-bounds)))
             (rect-intersection logical bounds)))))


  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (get-view-clipper)
    (get-translated-clipper 0 0))
  
  
  (method protected virtual (get-translated-clipper h v)
    (let* ((b (get-bounds))
           (r (offset-rect b (fxround h) (fxround v))))
      (if (not parent)
          (copy r)
        (let ((p (get-translated-clipper~ parent (- h (get-h~ position)) (- v (get-v~ position)))))
          (rect-intersection p r)))))
  
  
  (method public virtual (get-offscreen?)
    #f)
  
  
  (method public virtual (set-offscreen? flag <bool>)
    )


  ;;;
  ;;;; Overlay
  ;;;
  
  
  (method public virtual (get-overlay)
    {})
  
  
  (method public virtual (set-overlay value)
    )


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method public virtual (get-effect)
    {})
  
  
  (method public virtual (set-effect value)
    )))
