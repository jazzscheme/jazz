;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Platform-dependant Window Definitions (Carbon)
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.window.platform.carbon jazz


(import (jazz.utilities)
        (jazz.library)
        (jazz.io)
        (jazz.platform)
        (jazz.platform.cairo)
        (jazz.platform.carbon)
        (jazz.ui)
        (time))



(definition public unprocessed '(unprocessed))
(definition public processed '(processed))


(definition (processed-result return)
  (if (and (pair? return) (eq? (car return) 'processed))
      (if (null? (cdr return))
          0
        (cadr return))
    0))


(definition (is-window-HIView? window)
  (not (or (is? window Toplevel)
	   (is? window Desktop)
	   (is? window Orphanage-Window))))


;;;
;;;; Window
;;;


(definition public Windows-Table
  (make-table test: eqv?))


(definition public Window-Title-Table
  (make-table test: eqv?))


(definition public inline (get-window hwnd)
  (let ((hwnd (if (foreign? hwnd) (foreign-address hwnd) hwnd)))
    (table-ref Windows-Table hwnd #f)))


(definition public inline (set-window hwnd window)
  (table-set! Windows-Table (foreign-address hwnd) window))


(definition public inline (platform-get-window-handle-title handle)
  (table-ref Window-Title-Table handle #f))


(definition public inline (set-window-title handle title)
  (table-set! Window-Title-Table handle title))


(definition (prepare-handle window parent rest)
  (if (is-window-HIView? window)
      (create-HIView-handle window parent rest)
      (let* ((window-handle (create-window-handle window parent rest))
	     (handle (HIViewGetContent window-handle)))
	(InstallControlEventHandler handle)
	handle)))


(definition (create-HIView-handle window parent rest)
  (let* ((parent (or parent (get-toplevel~ (get-application))))
	 (parent-handle (get-handle~ parent))
	 (new-handle (HIViewCreate)))
    (HIViewAddSubview parent-handle new-handle)
    (HIViewChangeFeatures new-handle kHIViewFeatureAllowsSubviews 0)
    (HIViewSetFrame new-handle 0.0 0.0 500.0 500.0)
    (InstallControlEventHandler new-handle)
    new-handle))


(definition (create-window-handle window parent rest)
    (let ((handle (CreateNewWindow kDocumentWindowClass
				   (bitwise-ior kWindowStandardDocumentAttributes
						kWindowStandardHandlerAttribute
						kWindowLiveResizeAttribute
						kWindowCompositingAttribute)
				   0
				   0
				   500
				   500)))
      (InstallWindowEventHandler handle)
      handle))


(definition (destroy-window window)
  @with-x11
  (when (= (get-handle~ window) (platform-get-focus))
    (call-focus-lose~ window #f))
  (if (is-window-HIView? window)
      (DestroyView (get-handle~ window))
      (DestroyWindow (HIViewGetWindow (get-handle~ window)))))


(definition (dispatch-message window msg wparam lparam)
  (process-window-message window msg))


(definition (platform-process-messages)
  (RunApplicationEventLoop))


(definition (platform-process-one-message)
  (unimplemented 'platform-process-one-message))
  

(definition (show-window handle)
  ;; We must fix this.
  (if (is? (get-window handle) Desktop)
      #f
      (if (is-window-HIView? (get-window handle))
	  (HIViewSetVisible handle #t)
	  (ShowWindow (HIViewGetWindow handle)))))


(definition (hide-window handle)
  (if (is-window-HIView? (get-window handle))
      (HIViewSetVisible handle #f)
      (HideWindow (HIViewGetWindow handle))))


(definition (bring-window-to-top handle)
  (platform-bring-window-to-front handle))


(definition (minimize-window handle)
  (unimplemented 'minimize-window))


(definition (platform-erase-background handle)
  (unimplemented 'platform-erase-background))


(definition (convert-key char keycode)
  (case char
    ((#\x10) (case keycode
	       ((122) 'F1)
	       ((120) 'F2)
	       ((99)  'F3)
	       ((118) 'F4)
	       ((96)  'F5)
	       ((97)  'F6)
	       ((98)  'F7)
	       ((100) 'F8)))
    ((#\esc) 'Escape)
    ((#\backspace) 'Backspace)
    ((#\return) 'Return)
    ((#\space)  'Space)
    ((#\tab) 'Tab)
    ((#\x1c) 'Left)
    ((#\x1d) 'Right)
    ((#\x1e) 'Top)
    ((#\x1f) 'Down)
    (else    char)))
	       
(definition current-mouse-x 0)
(definition current-mouse-y 0)

(definition (process-window-message handler event userdata)
  (let ((class (GetEventClass event))
	(type  (GetEventKind event)))
    (cond
     ((= class kEventClassWindow)
      (cond
       ((= type kEventWindowClose)
	(QuitApplicationEventLoop)
	noErr)
       ((= type kEventWindowBoundsChanged)
	noErr)
       (else eventNotHandledErr)))
     ((= class kEventClassMouse)
      (cond
       ((= type kEventMouseMoved)
	(let ((window (eventWindowRef event)))
	  (receive (x y) (eventMouseLocation event)
	    (receive (glo-x glo-y) (convertPointToGlobal window x y) 
		   (set! current-mouse-x glo-x)
		   (set! current-mouse-y glo-y)
		   (let* ((view (HIViewForPoint window x y))
			  (win (get-window view)))
		     (if win
			 (receive (x y) (convertCoordinates (HIViewGetRoot window) view x y)
				  (mouse-move~ win (inexact->exact x) (inexact->exact y))
				  noErr)
			 eventNotHandledErr))))))
       ((= type kEventMouseUp)
	(let ((window (eventWindowRef event)))
	  (receive (x y) (eventMouseLocation event)
		   (let* ((view (HIViewForPoint window x y))
			  (win (get-window view)))
		     (if win
			 (receive (x y) (convertCoordinates (HIViewGetRoot window) view x y)
				  (mouse-up~ win (inexact->exact x) (inexact->exact y))
				  noErr)
			 eventNotHandledErr)))))
       ((= type kEventMouseDown)
	(let ((window (eventWindowRef event)))
	  (receive (x y) (eventMouseLocation event)
		   (let* ((view (HIViewForPoint window x y))
			  (win (get-window view)))
		     (if win
			 (receive (x y) (convertCoordinates (HIViewGetRoot window) view x y)
				  (mouse-down~ win (inexact->exact x) (inexact->exact y))
				  noErr)
			 eventNotHandledErr)))))
       (else eventNotHandledErr)))
     ((= class kEventClassKeyboard)
      (cond
       ((= type kEventRawKeyDown)
	(let* ((keycode (eventKeyCode event))
	       (keyboard (eventKeyboardType event))
	       (state   (eventKeyMods    event))
	       (unmodified (unmodifiedKey keycode keyboard state))
	       (unicode (eventKeyUnicode event)))
	  (let ((unmodified (convert-key unmodified keycode))
		(unicode (convert-key unicode keycode))
                (mods '()))
	    (when (bit-set? shiftKeyBit state)   (set! mods (cons :shift mods)))
	    (when (bit-set? controlKeyBit state) (set! mods (cons :control mods)))
	    (when (bit-set? optionKeyBit state)  (set! mods (cons :alt mods)))
	    (when (not (dispatch-shortcut~ (get-application) (new Shortcut mods unmodified)))
		  (let ((unicode (if (eq? unicode 'Space) #\space unicode)))
		    (when (and unicode (char? unicode))
			  (call-key-press~ (get-current-focus) unicode))))))
	noErr)
       (else eventNotHandledErr)))
     (else eventNotHandledErr))))

(set-process-window-message process-window-message)

(definition (process-control-message handler event userdata)
  (let ((type (GetEventKind event))
	(handle (void*->HIViewRef userdata)))
    (cond
     ((= type kEventControlDraw)
      (let ((context (EventCGContext event)))
	(paint~ (get-window handle) #f context))
      noErr)
     ((= type kEventControlBoundsChanged)
      (receive (left top width height) (HIViewGetBounds handle)
	(if (is? (get-window handle) Host-Docked) (show-window handle))
        (call-size-change~ (get-window handle) (inexact->exact width) (inexact->exact height))
	(call-position-change~ (get-window handle) (inexact->exact left) (inexact->exact top)))
      noErr)
     (else
      eventNotHandledErr))))

(set-process-control-message process-control-message)


;;;
;;;; Capture
;;;


(definition (set-capture handle)
  #f)


(definition (unset-capture)
  #f)


(definition (with-platform-painting window platform-data proc)
  (let* ((context (car platform-data))
	 (surface (new Surface (cairo_quartz_surface_create_for_cg_context context (get-width~ window) (get-height~ window)))))
    (unwind-protect
        (proc surface)
      (close~ surface))))


(definition public (get-window-surface window)
  (unimplemented 'get-window-surface)
  @lala
  (let* ((screen-no (XDefaultScreen default-x11-display))
         (visual    (XDefaultVisual default-x11-display screen-no)))
    (cairo_xlib_surface_create default-x11-display (get-handle~ window) visual (get-width~ window) (get-height~ window))))


(definition (set-alpha-blending handle n)
  #f
  @windows 
  ((set-layered? handle #t)
   (SetLayeredWindowAttributes handle 0 n LWA_ALPHA)
   (RedrawWindow handle NULL NULL (bitwise-ior RDW_ERASE RDW_INVALIDATE))))


;;;
;;;; Management
;;;


(definition (platform-set-parent handle parent)
  (when (HIViewGetSuperview handle)
	(HIViewRemoveFromSuperview handle))
  (HIViewAddSubview (get-handle~ parent) handle))


(definition (platform-get-first-child handle)
  (unimplemented 'platform-get-first-child)
  @lala
  (let ((num-of-children (XNumberOfChildren default-x11-display handle)))
    (if (= 0 num-of-children)
        #f
      (XGetChildHandle default-x11-display handle 0))))


(definition (platform-get-first-visible-child handle)
  (unimplemented 'platform-get-first-visible-child)
  @lala
  (let ((num-of-children (XNumberOfChildren default-x11-display handle)))
    (if (= 0 num-of-children) 
        #f
      (let loop ((n 0))
           (if (= n num-of-children)
               #f
             (let ((child-handle (XGetChildHandle default-x11-display handle n)))
               (if (platform-is-window-visible? child-handle)
                   child-handle
                 (loop (+ n 1)))))))))


(definition (platform-is-window-visible? handle)
  (unimplemented 'platform-is-window-visible?)
  @lala
  (let ((infos (XWindowAttributes-make)))
    (XGetWindowAttributes default-x11-display handle infos)
    (= (XWindowAttributes-map_state-ref infos) IsViewable)))

@old
(definition (acquire-point to-handle from-window shape)
  (let ((x (get-h~ shape))
	(y (get-v~ shape)))
    (convertCoordinates (get-handle~ from-window) to-handle (exact->inexact x) (exact->inexact y))))


(definition (acquire-point to-handle from-window shape)
  (let ((x (get-h~ shape))
	(y (get-v~ shape)))
    (receive (x y) (convertCoordinates (get-handle~ from-window) to-handle (exact->inexact x) (exact->inexact y))
             (new Point (inexact->exact x) (inexact->exact y)))))


(definition (acquire-rect handle window shape)
  (unimplemented 'acquire-rect)
  @windows
  (let ((acquired (rect->RECT shape)))
    (MapWindowPoints (get-handle~ window) handle (RECT->POINTS acquired) 2)
    (RECT->rect acquired)))


(definition (platform-get-position-in-root handle)
  (let* ((window (HIViewGetWindow handle))
	 (root   (HIViewGetRoot window)))
    (receive (x y) (convertCoordinates handle root 0.0 0.0)
       (receive (l t w h) (WindowGetRootBounds window)
          (new Point (inexact->exact (+ l x)) (inexact->exact (+ t y)))))))

(definition (platform-get-position handle parent-handle)
  (receive (left top width height) (platform-get-system-rect handle)
     (new Point (inexact->exact left) (inexact->exact top))))


(definition (platform-set-position handle pos)
  (receive (left top width height) (platform-get-system-rect handle)
     (let ((left (get-h~ pos))
	   (top (get-v~ pos)))
       (if (is-window-HIView? (get-window handle))
	   (HIViewSetFrame handle (exact->inexact left) (exact->inexact top) (exact->inexact width) (exact->inexact height))
	   (MoveWindowStructure (HIViewGetWindow handle) left top)))))
  

(definition (platform-get-size handle)
  (receive (left top width height) (platform-get-system-rect handle)
	   (new Dimension (inexact->exact width) (inexact->exact height))))


(definition (platform-get-window-size handle)
  (platform-get-size handle))


(definition (platform-get-system-rect handle)
  (cond ((is-window-HIView? (get-window handle))
	 (HIViewGetFrame handle))
	((is? (get-window handle) Desktop)
	 (HIWindowGetAvailablePositioningBounds))
	(else
	 (WindowGetContentBounds (HIViewGetWindow handle)))))


(definition (platform-set-window-size handle size)
  (receive (left top width height) (platform-get-system-rect handle)
     (let ((width (get-width~ size))
	   (height (get-height~ size)))
       (if (is-window-HIView? (get-window handle))
	   (HIViewSetFrame handle (exact->inexact left) (exact->inexact top) (exact->inexact width) (exact->inexact height))
	   (WindowSetContentBounds (HIViewGetWindow handle) left top width height)))))


(definition (platform-set-position-size handle pos size)
  (unimplemented 'platform-set-position-size)
  @lala
  (XMoveResizeWindow default-x11-display handle (get-h~ pos) (get-v~ pos) (get-width~ size) (get-height~ size)))


(definition (platform-set-bounds handle rect)
  (unimplemented 'platform-set-bounds)
  @windows
  (SetWindowPos handle NULL (get-left~ rect) (get-top~ rect) (rect-width rect) (rect-height rect) (bitwise-ior SWP_NOZORDER SWP_NOACTIVATE)))


(definition (platform-get-rect handle parent-handle)
  (receive (left top width height) (platform-get-system-rect handle)
      (new Rect left top (+ left width) (+ top height))))


(definition (platform-get-bounds handle)
  (unimplemented 'platform-get-bounds)
  @windows
  (with ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (MapWindowPoints NULL handle rect 2)
    (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))))


(definition (platform-mouse-position)
  (new Point current-mouse-x current-mouse-y))


(definition (platform-window-from-point point)
  (unimplemented 'platform-window-from-point)
  @windows
  (with ((pt (POINT-make)))
    (POINT-x-set! pt (get-h~ point))
    (POINT-y-set! pt (get-v~ point))
    (WindowFromPoint pt)))


(definition (platform-child-window-from-point handle point)
  (unimplemented 'platform-child-window-from-point)
  @windows
  (with ((pt (POINT-make)))
    (POINT-x-set! pt (get-h~ point))
    (POINT-y-set! pt (get-v~ point))
    (ChildWindowFromPointEx handle pt (bitwise-ior CWP_SKIPINVISIBLE CWP_SKIPDISABLED CWP_SKIPTRANSPARENT))))


(definition (platform-move-window handle x y cx cy)
  (unimplemented 'platform-move-window)
  @windows
  (MoveWindow handle x y cx cy #t))


(definition (platform-window-enabled? handle)
  (unimplemented 'platform-window-enabled?)
  @windows
  (IsWindowEnabled handle))


(definition (platform-enable-window handle)
  (warn-unimplemented 'platform-enable-window))


(definition (platform-disable-window handle)
  (warn-unimplemented 'platform-disable-window))


(definition (platform-get-client-rect handle)
  (let ((size (platform-get-size handle)))
    (new Rect 0 0 (get-width~ size) (get-height~ size))))


(definition (platform-scroll-window handle dh dv rect clip-rect erase?)
  (platform-update-window handle)
  @windows
  (let ((flags (bitwise-ior (if erase? SW_ERASE 0) SW_INVALIDATE)))
    (with ((rect (rect->RECT rect))
           (clip-rect (rect->RECT clip-rect)))
      (ScrollWindowEx handle dh dv rect clip-rect NULL NULL flags))))


;; Correct this to really invalidate the Rect
(definition (platform-invalidate-rect handle rect erase?)
  (HIViewSetNeedsDisplay handle #t)
  @lala
  (when handle
    (let ((l (if (< (get-left~ rect) 0) 0 (get-left~ rect)))
          (t (if (< (get-top~ rect) 0) 0 (get-top~ rect)))
          (r (if (> (get-right~ rect) (get-width~ (get-window handle)))
                 (get-width~ (get-window handle))
               (get-right~ rect)))
          (b (if (> (get-bottom~ rect) (get-height~ (get-window handle)))
                 (get-height~ (get-window handle))
               (get-bottom~ rect))))
      (let ((w (- r l))
            (h (- b t)))
        (unless (or (< w 0) (< h 0))
          (XInvalidateRect default-x11-display handle l t w h))))))


;; Correct this to really invalidate the Region
(definition (platform-invalidate-region handle region erase?)
  (platform-invalidate-rect handle region erase?)
  @lala
  (for-each (function (rect)
              (platform-invalidate-rect handle rect erase?))
            (get-rectangles~ region)))


(definition (platform-invalidate-window handle erase?)
  (platform-invalidate-rect handle #f #f)
  @windows
  (when handle
    (InvalidateRect handle NULL erase?)))


(definition (platform-redraw-window handle rect region)
  (platform-invalidate-rect handle #f #f)
  @lala
  (platform-update-window handle))


(definition (platform-get-update-rect handle)
  (unimplemented 'platform-get-update-rect)
  @windows
  (with ((rect (RECT-make)))
    (GetUpdateRect handle rect #f)
    (RECT->rect rect)))


(definition (platform-get-update-region handle)
  (unimplemented 'platform-get-update-region)
  @windows
  (let ((region (new Region)))
    (GetUpdateRgn handle (get-handle~ region) #f)
    region))


(definition (platform-redraw-view-only view handle)
  (unimplemented 'platform-redraw-view-only)
  @lala
  (platform-update-window handle))


(definition (platform-update-window handle)
  (platform-invalidate-rect handle #f #f)
  @lala
  (when handle
    (let* ((size (platform-get-size handle))
           (rct (new Rect 0 0 (get-width~ size) (get-height~ size))))
      (platform-invalidate-rect handle rct #t))))
  
  
(definition (platform-show-noactivate handle)
  (show-window handle))


(definition (platform-hide-noactivate handle)
  (hide-window handle))


(definition (platform-bring-window-to-front handle)
  (when (is-window-HIView? (get-window handle))
	(HIViewSetZOrder handle kHIViewZOrderAbove #f)))


(definition (platform-send-window-to-back handle)
  (when (is-window-HIView? (get-window handle))
	(HIViewSetZOrder handle kHIViewZOrderBelow #f)))


(definition public (platform-select-foreground-window handle)
  (if (is-window-HIView? (get-window handle))
      (let* ((parent-view (HIViewGetSuperview handle))
	     (top-view    (HIViewGetFirstSubview handle)))
	(HIViewSetZOrder handle kHIViewZOrderAbove top-view))
      (BringToFront (HIViewGetWindow handle))))


;;;
;;;; Locking
;;;


(definition actions-store (make-table))


(definition (add-position-action window position)
  (let ((action (table-ref actions-store window #f)))
    (table-set! actions-store window (cons position (and action (cdr action))))))


(definition (add-size-action window size)
  (let ((action (table-ref actions-store window #f)))
    (table-set! actions-store window (cons (and action (car action)) size))))


(definition (platform-lock-window-update handle)
  #f
  @lala
  (if handle
      (set! *locked-update* #t)
    (begin 
      (set! *locked-update* #f)
      (process-window-actions))))


(definition (process-window-actions)
  (iterate-table 
    actions-store
    (function (window action)
      (when action
        (let ((handle (get-handle~ window)))
          (hide-window handle)
          (let ((position (car action))
                (size     (cdr action)))
            (if (and position size)
                (platform-set-position-size handle position size)
              (when position (platform-set-position handle position))
              (when size     (platform-set-window-size handle size))))
          (show-window handle)))))
  (set! actions-store (make-table)))


;;;
;;;; Focus
;;;


(definition (platform-get-focus)
  (unimplemented 'platform-get-focus)
  @lala
  (receive (win state) (XGetInputFocus default-x11-display)
    win))


(definition current-focus #f)

(definition (get-current-focus)
  (unless current-focus
    (set! current-focus (get-toplevel~ (get-application))))
  current-focus)

(definition (platform-set-focus handle)
  (set! current-focus (get-window handle))
  (SetUserFocusWindow (HIViewGetWindow handle)))


;;;
;;;; Cursor
;;;


(definition public Current-Cursor
  {})


@unimplemented
(definition public Cursors
  (list
    (list :arrow               IDC_ARROW)
    (list :wait                IDC_WAIT)
    (list :ibeam               IDC_IBEAM)
    (list :cross               IDC_CROSS)
    (list :finger              IDC_HAND)
    (list :all                 IDC_SIZEALL)
    (list :west-east           IDC_SIZEWE)
    (list :no                  IDC_NO)
    (list :move                (new Cursor-Resource "Move"))
    (list :opened-hand         (new Cursor-Resource "OpenedHand"))
    (list :closed-hand         (new Cursor-Resource "ClosedHand"))
    (list :zoom                (new Cursor-Resource "Zoom"))
    (list :zoom-in             (new Cursor-Resource "ZoomIn"))
    (list :zoom-out            (new Cursor-Resource "ZoomOut"))
    (list :spy                 (new Cursor-Resource "Spy"))
    (list :left-arrow          (new Cursor-Resource "LeftArrow"))
    (list :vertical-splitter   (new Cursor-Resource "VerticalSplitter"))
    (list :horizontal-splitter (new Cursor-Resource "HorizontalSplitter"))))


(definition (load-cursor cursor)
  (unimplemented 'load-cursor)
  @unimp
  (if (number? cursor)
      (LoadCursorInt cursor)
    (let* ((cursor  (if (file? cursor) cursor (find-cursor-file cursor)))
           (ident   (parse~ cursor)))
      (LoadImage NULL ident IMAGE_CURSOR 0 0 LR_LOADFROMFILE))))


(definition (get-named-cursor name)
  (unimplemented 'get-named-cursor)
  @unimp
  (let ((info (assq name Cursors)))
    (if (not info)
        (error "Unknown cursor: {t}" name)
      (cadr info))))


(definition public (get-cursor)
  Current-Cursor)


(definition public (set-cursor cursor)
  #f
  @unimp
  (unless #f @to-fix-this-doesnt-work-when-switching-overlapped-windows! (= cursor Current-Cursor)
          (set! Current-Cursor cursor)
          (let ((cursor (if (symbol? cursor) (get-named-cursor cursor) cursor)))
            (SetCursor (load-cursor cursor)))))


(definition public (hide-cursor)
  #f)


(definition public (show-cursor)
  #f)


;;;
;;;; Desktop
;;;


(definition (platform-get-desktop)
  (unimplemented 'platform-get-desktop)
  @lala
  (XRootWindow default-x11-display (XDefaultScreen default-x11-display)))


;; We need to find what is the correct approach to this.
(definition public (get-work-area) <Rect>
  (receive (x y w h) (HIWindowGetAvailablePositioningBounds)
    (new Rect (inexact->exact x) (inexact->exact y) (inexact->exact (+ x w)) (inexact->exact (+ y h)))))


;;;
;;;; Drag and Drop
;;;


(definition (platform-drop-files temp)
  (unimplemented 'platform-drop-files)))
