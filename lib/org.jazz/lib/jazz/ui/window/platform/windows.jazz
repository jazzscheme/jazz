;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Platform-dependant Window Definitions (Windows)
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.window.platform.windows jazz


(import (jazz.library)
        (jazz.io)
        (jazz.platform.windows)
        (jazz.platform.cairo)
        (jazz.system)
        (jazz.ui)
        (jazz.utilities))


(definition public processed '(processed))
(definition public unprocessed '(unprocessed))


;;;
;;;; Window
;;;


(definition public Windows-Table
  (make-table test: eqv?))


(definition public inline (get-window hwnd)
  (let ((hwnd (if (foreign? hwnd) (foreign-address hwnd) hwnd)))
    (table-ref Windows-Table hwnd #f)))


(definition public inline (set-window hwnd window)
  (table-set! Windows-Table (foreign-address hwnd) window))


;; So that the window<->hwnd association can be made on the very first windows message
(definition in-creation {})


(definition (set-in-creation in)
  (set! in-creation in))


(definition (get-in-creation)
  in-creation)


(definition (window-class)
  "JWindow")


;;tofix : Transient CS_SAVEBITS
(definition (class-style)
  (bitwise-ior CS_OWNDC CS_DBLCLKS))


(definition (class-background)
  (GetSysColorBrush COLOR_BTNFACE))


(definition (platform-erase-background handle)
  (if (not (class-background))
      processed
    unprocessed))


(definition (register-window-class)
  (let ((instance (current-instance))
        (background (class-background))
        (wc (WNDCLASS-make)))
    (WNDCLASS-style-set! wc          (class-style))
    (WNDCLASS-lpfnWndProc-set! wc    call-process-hwnd-message)
    (WNDCLASS-cbClsExtra-set! wc     0)
    (WNDCLASS-cbWndExtra-set! wc     0)
    (WNDCLASS-hInstance-set! wc      instance)
    (WNDCLASS-hIcon-set! wc          NULL) ;; specific windows (if icon (load-image~ Image 'icon icon width: 16 height: 16) NULL)
    (WNDCLASS-hCursor-set! wc        NULL)
    ;; To-Fix Remettre le handle brush
    (WNDCLASS-hbrBackground-set! wc  background)
    (WNDCLASS-lpszMenuName-set! wc   NULL)
    (WNDCLASS-lpszClassName-set! wc  "JWindow" @w class)
    (set! CLASS_ATOM (RegisterClass wc))))


(definition CLASS_ATOM
  #f)


(register-window-class)

  
(definition (child-style? rest)
  #t)


(definition (window-style window rest)
  (typecase window
    ((Dialog)           (bitwise-ior (if (child-style? rest) WS_CHILD 0)
                                     WS_CLIPCHILDREN
                                     WS_CLIPSIBLINGS
                                     WS_POPUP
                                     WS_BORDER
                                     WS_OVERLAPPED
                                     WS_CAPTION
                                     WS_DLGFRAME
                                     (if (getf rest sizable?: not-found: #t) WS_THICKFRAME 0)
                                     (if (getf rest closable?: not-found: #t) WS_SYSMENU 0)))
    ((Frame)            (bitwise-ior WS_CHILD
                                     WS_SYSMENU
                                     WS_CLIPCHILDREN
                                     WS_CLIPSIBLINGS))
    ((Orphanage-Window) 0)
    ((Palette)          (bitwise-ior WS_POPUP
                                     WS_CLIPCHILDREN))
    ((Popup)            (bitwise-ior WS_POPUP
                                     WS_CLIPCHILDREN))
    @unimplemented
    ((State-Toplevel)   (bitwise-ior WS_POPUP
                                     WS_CLIPCHILDREN))
    ((Toplevel)         (bitwise-ior WS_CLIPSIBLINGS
                                     WS_CLIPCHILDREN
                                     WS_POPUP
                                     WS_OVERLAPPED
                                     WS_MINIMIZEBOX
                                     WS_SYSMENU))
    (else               (bitwise-ior (if (child-style? rest) WS_CHILD 0)
                                     WS_CLIPCHILDREN
                                     WS_CLIPSIBLINGS))))


(definition (window-ex-style window rest)
  (let ((transparent (if (window-transparent?~ window) WS_EX_TRANSPARENT 0)))
    (bitwise-ior transparent
                 (typecase window
                   ((Dialog)    WS_EX_DLGMODALFRAME)
                   ((Palette)   WS_EX_TOOLWINDOW)
                   ((Popup)     WS_EX_TOOLWINDOW)
                   ((Toplevel)  WS_EX_APPWINDOW)
                   ((Transient) (bitwise-ior WS_EX_TOOLWINDOW WS_EX_TOPMOST))
                   (else        0)))))


(definition (window-parent window parent)
  (if (not parent)
      NULL
    (get-handle~ parent)))


(definition (create-handle window parent rest)
  (typecase window
    ((Desktop) (GetDesktopWindow))
    (else
     (CreateWindowEx
       (window-ex-style window rest)
       CLASS_ATOM @w (either hwnd-class (window-class))
       NULL
       (window-style window rest)
       0 0 500 500
       (window-parent window parent)
       NULL
       (current-instance)
       NULL))))


(definition (prepare-handle window parent rest)
  (bind-keywords ((hwnd {}) . others) rest
    (set-in-creation window)
    (let ((hwnd (create-handle window parent rest)))
      (if (not hwnd)
          (error "Unable to create window {t} error {t}"
                 (list class: (window-class) style: (window-style window rest) ex-style: (window-ex-style window rest) parent: (window-parent window parent))
                 (GetLastError))
        (DragAcceptFiles hwnd #t)
        hwnd))))


(definition (bring-window-to-top hwnd)
  (BringWindowToTop hwnd))


(definition (show-window handle)
  (ShowWindow handle SW_SHOWNORMAL))


(definition (hide-window handle)
  (ShowWindow handle SW_HIDE))


(definition (minimize-window handle)
  (ShowWindow handle SW_MINIMIZE))


(definition (close-window window)
  (send-message~ window WM_CLOSE 0 0))


(definition (destroy-window handle)
  (window-destroy~ (get-window handle))
  (on-nc-destroy~ (get-window handle))
  (DestroyWindow handle))


(definition (dispatch-message window msg <int> wparam <int> lparam <int>)
  (if (eq? (process-window-message window msg wparam lparam) unprocessed)
      (DefWindowProc (get-handle~ window) msg wparam lparam)
    0))


;;;
;;;; Loop
;;;


(definition (platform-process-messages)
  (with ((msg (MSG-make)))
    (let ((hwnd (get-handle~ (get-toplevel~ (get-application)))))
      ;; get messages from all windows
      (while (GetMessage msg NULL 0 0)
        (unless (translate-shortcut msg)
          (TranslateMessage msg)
          (DispatchMessage msg))))))


(definition (platform-process-one-message window)
  (with ((msg (MSG-make)))
    (let ((hwnd (get-handle~ window)))
      ;; get only messages from window
      (when (GetMessage msg hwnd 0 0)
        (unless (translate-shortcut msg)
          (TranslateMessage msg)
          (DispatchMessage msg))))))


;;;
;;;; Shortcuts
;;;


;; - standard usage -
;; ()                     : letters
;; (:shift)               : capital letters
;; (:control)             : standard Windows
;; (:alt)                 : mostly for focus
;; (:control :alt)        : mostly for guest
;; (:alt :shift)          : window management
;; (:control :shift)      : window selection
;; (:control :alt :shift) : favorite files


(definition public Symbolic-Keys
  (list->table
    (list
      (cons VK_OEM_MINUS  #\-)
      (cons VK_OEM_PLUS   #\+)
      (cons VK_OEM_COMMA  #\,)
      (cons VK_OEM_PERIOD #\.)
      (cons VK_OEM_1      #\;)
      (cons VK_OEM_2      #\/)
      (cons VK_OEM_3      #\~)
      (cons VK_OEM_4      #\[)
      (cons VK_OEM_5      #\\)
      (cons VK_OEM_6      #\])
      (cons VK_OEM_7      #\')
      (cons VK_F1         'F1)
      (cons VK_F2         'F2)
      (cons VK_F3         'F3)
      (cons VK_F4         'F4)
      (cons VK_F5         'F5)
      (cons VK_F6         'F6)
      (cons VK_F7         'F7)
      (cons VK_F8         'F8)
      (cons VK_F9         'F9)
      (cons VK_F10        'F10)
      (cons VK_F11        'F11)
      (cons VK_F12        'F12)
      (cons VK_ESCAPE     'Escape)
      (cons VK_BACK       'Backspace)
      (cons VK_RETURN     'Return)
      (cons VK_SPACE      'Space)
      (cons VK_TAB        'Tab)
      (cons VK_HOME       'Home)
      (cons VK_END        'End)
      (cons VK_LEFT       'Left)
      (cons VK_UP         'Up)
      (cons VK_RIGHT      'Right)
      (cons VK_DOWN       'Down)
      (cons VK_PRIOR      'Prior)
      (cons VK_NEXT       'Next)
      (cons VK_INSERT     'Insert)
      (cons VK_PAUSE      'Pause)
      (cons VK_DELETE     'Delete)
      (cons VK_ADD        'Add)
      (cons VK_SUBTRACT   'Subtract)
      (cons VK_MULTIPLY   'Multiply)
      (cons VK_DIVIDE     'Divide))
    test: eqv?))


(definition (translate-shortcut msg)
  (define (modifiers)
    (let ((modifiers '()))
      (let ((try
              (function (down? modifier)
                (when down?
                  (set! modifiers (cons modifier modifiers))))))
        (try (alt-down?) :alt)
        (try (shift-down?) :shift)
        (try (control-down?) :control)
        modifiers)))
  
  (define (key code)
    (and (/= code VK_SHIFT)
         (/= code VK_CONTROL)
         (/= code VK_MENU)
         (or (table-ref Symbolic-Keys code #f)
             (integer->char code))))
  
  (let ((message (MSG-message-ref msg)))
    (if (or (= message WM_KEYDOWN)
            (= message WM_SYSKEYDOWN))
        (let ((key (key (MSG-wParam-ref msg))))
          (if key
              (dispatch-shortcut~ (get-application) (new Shortcut (modifiers) key))
            #f))
      #f)))


;;;
;;;; Messages
;;;


(definition (process-window-message window msg <int> wparam <int> lparam <int>)
  (ecase msg
    ((WM_ERASEBKGND)      (erase-background~ window wparam))
    ((WM_PAINT)           (with-closed ((region (platform-get-update-region (get-handle~ window))))
                            (paint~ window region)))
    ((WM_SETCURSOR)       (cursor-update~ window (= (loword lparam) HTCLIENT)))
    ((WM_MOUSEMOVE)       (mouse-move~ window (loword lparam) (hiword lparam)))
    ((WM_MOUSEHOVER)      (mouse-hover~ window (loword lparam) (hiword lparam)))
    ((WM_MOUSEWHEEL)      (mouse-wheel~ window (hiword wparam)))
    ((WM_LBUTTONDOWN)     (mouse-down~ window (loword lparam) (hiword lparam)))
    ((WM_LBUTTONUP)       (mouse-up~ window (loword lparam) (hiword lparam)))
    ((WM_LBUTTONDBLCLK)   (double-click~ window (loword lparam) (hiword lparam)))
    ((WM_MBUTTONDOWN)     (middle-mouse-down~ window (loword lparam) (hiword lparam)))
    ((WM_MBUTTONUP)       (middle-mouse-up~ window (loword lparam) (hiword lparam)))
    ((WM_RBUTTONDOWN)     (right-mouse-down~ window (loword lparam) (hiword lparam)))
    ((WM_RBUTTONUP)       (right-mouse-up~ window (loword lparam) (hiword lparam)))
    ((WM_CONTEXTMENU)     (call-context-menu~ window (loword lparam) (hiword lparam)))
    ((WM_SYSKEYDOWN)      (if (= wparam VK_MENU) (system-key-down~ window) unprocessed))
    ((WM_SYSKEYUP)        (if (= wparam VK_MENU) (system-key-up~ window) unprocessed))
    ((WM_KEYDOWN)         (key-down~ window wparam))
    ((WM_KEYUP)           (key-up~ window wparam))
    ((WM_CHAR)            (call-key-press~ window (integer->char wparam)))
    ((WM_MOVE)            (call-position-change~ window (loword lparam) (hiword lparam)))    
    ;; Windows sends a size message with both the width
    ;; and the height equal to zero when minimizing a window...
    ((WM_SIZE)            (let ((width (loword lparam))
                                (height (hiword lparam)))
                            (when (or (/= width 0) (/= height 0))
                              (call-size-change~ window width height))))
    ((WM_MOUSEACTIVATE)   (on-mouse-activate~ window))
    ((WM_ACTIVATE)        (let ((kind (if (= (loword wparam) WA_INACTIVE) 'inactive 'active)))
                            (on-activate~ window kind)))
    ((WM_ACTIVATEAPP)     (on-activate-app~ window wparam))
    ((WM_CLOSE)           (on-close~ window {}))
    ((WM_DESTROY)         processed)
    ((WM_NCDESTROY)       processed)
    ((WM_CAPTURECHANGED)  (call-lost-capture~ window lparam))
    ((WM_SETFOCUS)        (call-focus-gain~ window))
    ((WM_KILLFOCUS)       (call-focus-lose~ window wparam))
    ((WM_DROPFILES)       (drop-files~ window wparam))
    ((WM_SETTINGCHANGE)   (ecase wparam
                            ((SPI_SETWORKAREA)
                             @not-correct-to-call-set-fullscreen?
                             (when (is? window Toplevel)
                               (set-fullscreen?~ window #t)))))
    ((WM_TIMER)           (on-timer~ window wparam))
    (else                 unprocessed)))


(definition (set-capture handle)
  (SetCapture handle))


(definition (unset-capture)
  (ReleaseCapture))


(definition (with-platform-painting window proc)
  (let ((handle (get-handle~ window)))
    (with ((ps (PAINTSTRUCT-make)))
      (let ((hdc (BeginPaint handle ps)))
        (with ((surface (new Surface (cairo_win32_surface_create hdc))))
          (unwind-protect
              (proc surface) 
            (close~ surface) 
            (EndPaint handle ps))))))
  processed)


(definition public (get-window-surface window)
  (cairo_win32_surface_create (GetDC (get-handle~ window))))


;;;
;;;; Dispatch
;;;


(set-process-hwnd-message
  (function (hwnd <foreign> msg <int> wparam <int> lparam <int>)
    (let ((window (get-window hwnd)))
      (when (and (not window) (get-in-creation))
        (set! window (get-in-creation))
        (set-handle~ window hwnd)
        (set-window hwnd window)
        (set-in-creation {}))
      (if (not window)
          (DefWindowProc hwnd msg wparam lparam)
        (call-dispatch-message~ window msg wparam lparam)))))


;;;
;;;; Style
;;;


(definition (get-style handle)
  (GetWindowLong handle GWL_STYLE))


(definition (set-style handle style)
  (SetWindowLong handle GWL_STYLE style))


(definition (get-ex-style handle)
  (GetWindowLong handle GWL_EXSTYLE))


(definition (set-ex-style handle style)
  (SetWindowLong handle GWL_EXSTYLE style))


(definition (child-window? handle)
  (mask-bit-set? (get-style handle) WS_CHILD))


;;;
;;;; Layers
;;;


(definition (get-layered? handle)
  (mask-bit-set? (get-ex-style handle) WS_EX_LAYERED))


(definition (set-layered? handle flag)
  (SetWindowLong handle GWL_EXSTYLE (mask-bit-set (GetWindowLong handle GWL_EXSTYLE) WS_EX_LAYERED flag)))


(definition (set-alpha-blending handle n)
  (set-layered? handle #t)
  (SetLayeredWindowAttributes handle 0 n LWA_ALPHA)
  (RedrawWindow handle NULL NULL (bitwise-ior RDW_ERASE RDW_INVALIDATE)))


;;;
;;;; Tracking
;;;


(definition (track-mouse-event handle flags (time: time HOVER_DEFAULT))
  (with ((rec (TRACKMOUSEEVENT-make)))
    (TRACKMOUSEEVENT-cbSize-set! rec (size-of-TRACKMOUSEEVENT))
    (TRACKMOUSEEVENT-dwFlags-set! rec flags)
    (TRACKMOUSEEVENT-hwndTrack-set! rec handle)
    (TRACKMOUSEEVENT-dwHoverTime-set! rec time)
    (TrackMouseEvent rec)))


;;;
;;;; Management
;;;


(definition (platform-send-message handle msg wparam lparam)
  (SendMessage handle msg wparam lparam))


(definition (platform-post-message handle msg wparam lparam)
  (PostMessage handle msg wparam lparam))


(definition (platform-set-parent handle parent)
  (SetParent handle (if parent (get-handle~ parent) NULL)))


(definition (set-window-title handle title)
  (SetWindowText handle title))

  
(definition (get-window-owner-handle handle)
  (GetWindow handle GW_OWNER))


(definition (platform-get-window-child-handle handle)
  (GetWindow handle GW_CHILD))


(definition (platform-get-next-window-handle handle)
  (GetWindow handle GW_HWNDNEXT))


(definition (platform-is-window-visible? handle)
  (IsWindowVisible handle))


(definition (get-top-window-handle handle)
  (GetTopWindow handle))


(definition (acquire-point handle window shape)
  (let ((acquired (point->POINT shape)))
    (MapWindowPoints (get-handle~ window) handle acquired 1)
    (POINT->point acquired)))


(definition (acquire-rect handle window shape)
  (let ((acquired (rect->RECT shape)))
    (MapWindowPoints (get-handle~ window) handle (RECT->POINTS acquired) 2)
    (RECT->rect acquired)))


(definition (platform-get-window-position handle)
  (with ((pos (new-POINT 0 0)))
    (MapWindowPoints handle NULL pos 1)
    (new Point (POINT-x-ref pos) (POINT-y-ref pos))))


(definition (platform-get-position handle parent-handle)
  (with ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (when (and parent-handle (child-window? handle))
      (MapWindowPoints NULL parent-handle (RECT->POINTS rect) 2))
    (new Point (RECT-left-ref rect) (RECT-top-ref rect))))


(definition (platform-set-position handle pos)
  (SetWindowPos handle NULL (get-h~ pos) (get-v~ pos) 0 0 (bitwise-ior SWP_NOSIZE SWP_NOZORDER SWP_NOACTIVATE)))


(definition (platform-get-size handle)
  (with ((rect (RECT-make)))
    (GetClientRect handle rect)
    (new Dimension (RECT-right-ref rect) (RECT-bottom-ref rect))))


(definition (platform-get-window-size handle)
  (let ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (new Dimension (- (RECT-right-ref rect)  (RECT-left-ref rect))
                   (- (RECT-bottom-ref rect) (RECT-top-ref rect)))))


(definition (platform-set-window-size handle size)
    (SetWindowPos handle NULL 0 0 (get-width~ size) (get-height~ size) (bitwise-ior SWP_NOCOPYBITS SWP_NOMOVE SWP_NOZORDER SWP_NOACTIVATE)))


(definition (platform-set-bounds handle rect)
    (SetWindowPos handle NULL (get-left~ rect) (get-top~ rect) (rect-width rect) (rect-height rect) (bitwise-ior SWP_NOZORDER SWP_NOACTIVATE)))


(definition (platform-get-rect handle parent-handle)
  (with ((rect (RECT-make)))
    (GetWindowRect handle rect)
    (when parent-handle
      (MapWindowPoints NULL parent-handle (RECT->POINTS rect) 2))
    (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))))


(definition (platform-get-bounds handle)
    (with ((rect (RECT-make)))
      (GetWindowRect handle rect)
      (MapWindowPoints NULL handle rect 2)
      (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))))


(definition (platform-mouse-position)
  (with ((point (POINT-make)))
    (GetCursorPos point)
    (new Point (POINT-x-ref point) (POINT-y-ref point))))


(definition (platform-window-from-point point)
  (with ((pt (POINT-make)))
    (POINT-x-set! pt (get-h~ point))
    (POINT-y-set! pt (get-v~ point))
    (WindowFromPoint pt)))


(definition (platform-child-window-from-point handle point)
  (with ((pt (POINT-make)))
    (POINT-x-set! pt (get-h~ point))
    (POINT-y-set! pt (get-v~ point))
    (ChildWindowFromPointEx handle pt (bitwise-ior CWP_SKIPINVISIBLE CWP_SKIPDISABLED CWP_SKIPTRANSPARENT))))


(definition (platform-move-window handle x y cx cy)
  (MoveWindow handle x y cx cy #t))


(definition (platform-window-enabled? handle)
  (IsWindowEnabled handle))


(definition (platform-enable-window handle)
  (EnableWindow handle #t))


(definition (platform-disable-window handle)
  (EnableWindow handle #f))


(definition (platform-get-client-rect handle)
  (with ((rect (RECT-make)))
    (GetClientRect handle rect)
    (RECT->rect rect)))


(definition (platform-scroll-window handle dh dv rect clip-rect erase?)
  (let ((flags (bitwise-ior (if erase? SW_ERASE 0) SW_INVALIDATE)))
    (with ((rect (rect->RECT rect))
           (clip-rect (rect->RECT clip-rect)))
      (ScrollWindowEx handle dh dv rect clip-rect NULL NULL flags))))


(definition (platform-invalidate-rect handle rect erase?)
  (when handle
    (with ((rect (rect->RECT rect)))
      (InvalidateRect handle rect erase?))))


(definition (platform-invalidate-region handle region erase?)
  (when handle
    (InvalidateRgn handle (get-handle~ region) erase?)))


(definition (platform-invalidate-window handle erase?)
  (when handle
    (InvalidateRect handle NULL erase?)))


(definition (platform-redraw-window handle rect region)
  (when handle
    ;; Changed RDW_NOCHILDREN to RDW_ALLCHILDREN so that a redraw-window on the
    ;; toplevel would redraw it's children. Hope it doesn't break any code...
    (let ((flags (bitwise-ior RDW_ERASENOW RDW_UPDATENOW RDW_INVALIDATE RDW_ALLCHILDREN)))
      (with ((rect (if (not rect) NULL (rect->RECT rect))))
        (RedrawWindow handle rect (if region (get-handle~ region) NULL) flags)))))


(definition (platform-get-update-rect handle)
  (with ((rect (RECT-make)))
    (GetUpdateRect handle rect #f)
    (RECT->rect rect)))


(definition (platform-get-update-region handle)
  (let ((region (new Region)))
    (GetUpdateRgn handle (get-handle~ region) #f)
    region))


(definition (platform-update-window handle)
  (UpdateWindow handle))
  
  
(definition (platform-show-noactivate handle)
  (SetWindowPos handle HWND_TOP 0 0 0 0 (bitwise-ior SWP_SHOWWINDOW SWP_NOACTIVATE SWP_NOMOVE SWP_NOSIZE)))
  
  
(definition (platform-hide-noactivate handle)
  (SetWindowPos handle 0 0 0 0 0 (bitwise-ior SWP_HIDEWINDOW SWP_NOACTIVATE SWP_NOMOVE SWP_NOSIZE)))


(definition (platform-bring-window-to-front handle)
  (BringWindowToTop handle))


(definition (platform-send-window-to-back handle)
  (SetWindowPos handle HWND_BOTTOM 0 0 0 0 (bitwise-ior SWP_NOMOVE SWP_NOSIZE)))


(definition (platform-select-foreground-window handle)
  (SetForegroundWindow handle))


(definition (platform-get-window-handle-title handle)
  (let* ((size (GetWindowTextLength handle))
         (string (make-string size #\space)))
    (receive (ret str) (GetWindowText handle string (+ size 1))
      str)))


(definition (platform-lock-window-update handle)
  (LockWindowUpdate handle))


;;;
;;;; Focus
;;;


(definition (platform-get-focus)
  (GetFocus))

(definition (platform-set-focus handle)
  (SetFocus handle))


;;;
;;;; Frame Region
;;;


(definition public (frame-region frame <Rect> (insets: insets (new Rect 1 1 1 1)))
  (let ((left   (get-left~ frame))
        (top    (get-top~ frame))
        (right  (get-right~ frame))
        (bottom (get-bottom~ frame))
        (region (new Region)))
    (with-closed ((l (new Region left: left                          top: top                             right: (+ left (get-left~ insets)) bottom: bottom))
                  (t (new Region left: left                          top: top                             right: right                       bottom: (+ top (get-top~ insets))))
                  (r (new Region left: (- right (get-right~ insets)) top: top                             right: right                       bottom: bottom))
                  (b (new Region left: left                          top: (- bottom (get-bottom~ insets)) right: right                       bottom: bottom)))
      (combine!~ region l 'or)
      (combine!~ region t 'or)
      (combine!~ region r 'or)
      (combine!~ region b 'or)
      region)))


;;;
;;;; Cursor
;;;


;;; We need a platform ind interface for this.

(definition public Current-Cursor
  {})


;; tofix Cursor-Resources were literals
(definition public Cursors
  (list
    (list :arrow               IDC_ARROW)
    (list :wait                IDC_WAIT)
    (list :ibeam               IDC_IBEAM)
    (list :cross               IDC_CROSS)
    (list :finger              IDC_HAND)
    (list :all                 IDC_SIZEALL)
    (list :west-east           IDC_SIZEWE)
    (list :no                  IDC_NO)
    (list :move                IDC_ARROW @convert (new Cursor-Resource "Move"))
    (list :opened-hand         IDC_ARROW @convert (new Cursor-Resource "OpenedHand"))
    (list :closed-hand         IDC_ARROW @convert (new Cursor-Resource "ClosedHand"))
    (list :zoom                IDC_ARROW @convert (new Cursor-Resource "Zoom"))
    (list :zoom-in             IDC_ARROW @convert (new Cursor-Resource "ZoomIn"))
    (list :zoom-out            IDC_ARROW @convert (new Cursor-Resource "ZoomOut"))
    (list :spy                 IDC_ARROW @convert (new Cursor-Resource "Spy"))
    (list :left-arrow          IDC_ARROW @convert (new Cursor-Resource "LeftArrow"))
    (list :vertical-splitter   IDC_ARROW @convert (new Cursor-Resource "VerticalSplitter"))
    (list :horizontal-splitter IDC_ARROW @convert (new Cursor-Resource "HorizontalSplitter"))))


(definition public (find-cursor-file object)
  (new File (list 'Jazz "lib" "org.jazz" "lib" "jazz" "resources" "cursors" (string-append (get-name~ object) ".cur"))))


(definition (load-cursor cursor)
  (if (number? cursor)
      (LoadCursorInt cursor)
    (let* ((cursor  (if (file? cursor) cursor (find-cursor-file cursor)))
           (ident   (parse~ cursor)))
      (LoadImage NULL ident IMAGE_CURSOR 0 0 LR_LOADFROMFILE))))


(definition (get-named-cursor name)
  (let ((info (assq name Cursors)))
    (if (not info)
        (error "Unknown cursor: {t}" name)
      (cadr info))))


(definition public (get-cursor)
  Current-Cursor)


(definition public (set-cursor cursor)
  (unless #f @to-fix-this-doesnt-work-when-switching-overlapped-windows! (= cursor Current-Cursor)
          (set! Current-Cursor cursor)
          (let ((cursor (if (symbol? cursor) (get-named-cursor cursor) cursor)))
            (SetCursor (load-cursor cursor)))))


(definition public (hide-cursor)
  (while (>= (ShowCursor #f) 0)
    ))


(definition public (show-cursor)
  (while (< (ShowCursor #t) 0)
    ))


;;;
;;;; Redraw View Only
;;;


(definition (platform-redraw-view-only view hwnd)
  (with ((hrgn (CreateRectRgn 0 0 0 0)))
    ;; preserve the current update region
    (GetUpdateRgn hwnd hrgn #f)
    ;; reset it
    (ValidateRect hwnd NULL)
    ;; redraw the view only
    (redraw-view~ view)
    ;; reinvalidate the preserved update region
    (InvalidateRgn hwnd hrgn #f)
    (DeleteObject hrgn)))


(definition (platform-get-desktop)
  (GetDesktopWindow))


;;;
;;;; Work Area
;;;


(definition public (get-work-area) <Rect>
  (with ((area (RECT-make)))
    (SystemParametersInfo SPI_GETWORKAREA 0 area 0)
    (adjust-work-area-with-taskbar (RECT->rect area))))


;; Because fucking Window's SPI_GETWORKAREA doesn't take autohide into account!
(definition (adjust-work-area-with-taskbar rect)
  rect
  @convert
  (let ((state (get-taskbar-state))
        (edge (get-taskbar-edge)))
    (if (and (mask-bit-set? state ABS_AUTOHIDE) (mask-bit-set? state ABS_ALWAYSONTOP))
        (ecase edge
          ((ABE_LEFT)   (expand-rect rect  1  0  0  0))
          ((ABE_TOP)    (expand-rect rect  0  1  0  0))
          ((ABE_RIGHT)  (expand-rect rect  0  0 -1  0))
          ((ABE_BOTTOM) (expand-rect rect  0  0  0 -1)))
      rect)))


(definition public (get-taskbar-state)
  (unimplemented 'get-taskbar-state)
  @convert
  (with ((data (new APPBARDATA)))
    (set data 'cbSize (size-of APPBARDATA))
    (SHAppBarMessage ABM_GETSTATE data)))


(definition public (get-taskbar-edge)
  (unimplemented 'get-taskbar-edge)
  @convert
  (with ((data (new APPBARDATA)))
    (set data 'cbSize (size-of APPBARDATA))
    (SHAppBarMessage ABM_GETTASKBARPOS data)
    (get data 'uEdge)))


;;;
;;;; Drop Files
;;;


(definition (platform-drop-files window wparam)
  (let ((files (received-files wparam))
        (pt (POINT-make)))
    (DragQueryPoint wparam pt)
    (DragFinish wparam)
    (let ((pos (POINT->point pt)))
      (receive-files~ window pos files))
    (platform-select-foreground-window (get-handle~ (get-toplevel~ (get-application))))))


(definition (received-files wparam)
  (let ((count (DragQueryFile wparam #xFFFFFFFF NULL 0)))
    (map (function (n)
           (let* ((size MAX_PATH)
                  (buffer (WCHAR-array-make size)))
             (WCHAR-array-set! buffer 0 #\nul)
             (DragQueryFile wparam n buffer size)
             (let* ((filename (WCHAR-string buffer))
                    (attributes #f @w (GetFileAttributes filename))
                    (directory? #f @w (mask-bit-set? attributes FILE_ATTRIBUTE_DIRECTORY))
                    (pathname (new (if directory? Directory File) (tokenise-windows filename))))
               (anchorize~ pathname))))
         (naturals 0 count))))


;;;
;;;; Windows
;;;


(definition public (toplevel-windows)
  (unimplemented 'toplevel-windows)
  @convert
  (toplevel-hwnds))


(definition public (process-windows (include-invisibles?: include-invisibles? #f))
  ;; quicky
  (list (get-toplevel~ (get-application)))
  @convert
  (collect (function (hwnd)
             (let ((window (get-window hwnd)))
               (when (and window (or include-invisibles? (get-visible?~ window)))
                 window)))
           (process-hwnds)))


(definition public (all-child-windows hwnd)
  (unimplemented 'all-child-windows)
  @convert
  (all-child-hwnds hwnd))


(definition public (child-windows hwnd)
  (unimplemented 'child-windows)
  @convert
  (collect-if (function (child)
                (= (GetParent child) hwnd))
              (all-child-windows hwnd))))
