;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Test
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library test jazz


;;;
;;;; ADO
;;;


(import (jazz.database)
        (jazz.database.providers.access)
        (jazz.database.providers.sqlserver)
        (jazz.io)
        (jazz.platform.windows.com)
        (jazz.platform.windows.com.ADODB))


(definition (f x)
  (Recordset$get-State x))


@w
(definition (ado)
  (initialize-com)
  (let ((cmd "select * from [Table des bénéficiaires]")
        (data-source (new Access-Data-Source database: {File "C:" "Emilie" "database" "CAB.mdb"})))
    (with-closed ((connection (new-connection~ data-source))
                  (request (new-request~ connection)))
      (debug (load-request~ request cmd)))))


@w
(definition (ado)
  (initialize-com)
  (let ((cmd "select * from orders")
        (data-source (new SQLServer-Data-Source server: "(local)\\SQLEXPRESS" database: "Northwind" username: "jazz" password: "emehcs")))
    (with-closed ((connection (new-connection~ data-source))
                  (request (new-request~ connection)))
      (debug (load-request~ request cmd)))))


@w
(definition (ado)
  (initialize-com)
  (let ((cmd "select * from orders")
        (connection (cocreate Connection-class))
        (connection-string "driver={SQL Server};server=(local)\\SQLEXPRESS;database=Northwind;uid=jazz;pwd=emehcs"))
    (Connection$Open connection connection-string "" "" adConnectUnspecified)
    (let ((recordset (cocreate Recordset-class)))
      (Recordset$Open recordset cmd connection adOpenForwardOnly adLockReadOnly adCmdText)
      (debug (subseq (get-rows recordset) 0 10))
      (when (and recordset (/= (Recordset$get-State recordset) adStateClosed))
        (Recordset$Close recordset)
        (corelease recordset)))
    (when connection
      (Connection$Close connection)
      (corelease connection))))


@w
(definition (get-rows recordset)
  (let ((fields (get-fields recordset)))
    (let ((fact (new List-Factory)))
      (while (not (Recordset$get-EOF recordset))
        (put~ fact (map Field$get-Value fields))
        (Recordset$MoveNext recordset))
      (get-output~ fact))))


@w
(definition (get-fields recordset)
  (let ((fields (Recordset$get-Fields recordset)))
    (prog1 (loop (for n from 0 below (Collection$get-Count fields))
                 (collect (Fields$get-Item fields n)))
      (corelease fields))))


;;;
;;;; DAO
;;;


@w
(definition (dao)
  (debug 'test (initialize-com))
  (let ((engine (cocreate DBEngine-class)))
    (debug engine)
    (let ((workspaces (get-Workspaces$ engine)))
      (debug workspaces)
      (let ((item (get-Item$ workspaces 0)))
        (debug item)
        @w
        (let ((db (OpenDatabase$ (car zz3) "c:/dev/db.mdb" 0 #f "")))
          (debug db)
          (Close$ db)
          (CoRelease db))
        (debug 'item (CoRelease item)))
      (debug 'workspaces (CoRelease workspaces)))
    (debug 'engine (CoRelease engine))))


;;;
;;;; Exception
;;;


@buggy(
(class XX extends Exception)


(definition (foo)
  (catch XX
    (debug 1)
    (throw (new XX))
    (debug 2)))


(definition (bar)
  (catch (XX x (debug x))
    (debug 3)
    (throw (new XX))
    (debug 4)))


(definition (baz)
  (debug 5)
  (throw (new XX))
  (debug 6)))


;;;
;;;; Meta
;;;


@meta
(class Y extends X
  
  
  (method meta (f)
    2))


@expansion
(begin
  (class Y~Class207 extends (:class X)
    
    
    (method (f)
      2))
  
  
  (class Y metaclass Y~Class207 extends X
    ))


@not-uniform-for-interfaces (
(interface I)
(interface J)


(interface K extends (I J)
  
  
  (method meta (f)
    3)))


;;;
;;;; Generics
;;;


@done (
(class U extends Object)
(class V extends U)


;; (jazz.expand-define-generic '(test.foo (test.X x) (test.U u) a b))
;; (jazz.expand-define-specific '(test.foo (test.X x) (test.U u) a b) '(+ a b))
(generic (foo (<X> x) @w u (<U> u) a b)
  (+ a b))
(specific (foo (<Y> x) @w u (<U> u) a b)
  (list (nextmethod x u a b) a b))


(generic (baz (<X> x) @w u (<U> u) . rest)
  (apply + rest))
(specific (baz (<Y> x) @w u (<U> u) . rest)
  (apply list (apply nextmethod x u rest) rest))


(native jazz.display-tree)
(native test.foo!generic)
(native test.baz!generic)


(newline)
(display "--------------------------------")
(newline)
(jazz.debug (foo (new X) (new U) 1 2))
(jazz.debug (foo (new Y) (new U) 1 2))

(newline)
(display "--------------------------------")
(newline)
(jazz.debug (baz (new X) (new U) 1 2))
(jazz.debug (baz (new Y) (new U) 1 2)))


;;;
;;;; Various
;;;


@w(
(import (test.pt))


(definition (f)
  (loop (repeat 1000000)
        (let ((pt (POINT-make)))
          pt)))

(definition (pt)
  (POINT-make)))


@w(
(definition (foo class <category<Axis>>)
  (allocate class 5))


(debug (allocate Axis 10))
(debug (coerce '(a b c d e) Axis)))


@w
(for-each debug "Hello")


@w
(let ((axis (new Axis 0)))
  (axis-grow axis 10)
  (set-element! axis 5 'a)
  (for-each debug axis))


@w
(definition (f c <Cell+>)
  (if (not c)
      #f
    (= c c)))


@w(
(definition (f x <fl>)
  x)

(debug (f 2.3) (f 3))

@w(
(definition (g x) <fl>
  x)

(+ (g 1) (g 1))
(debug (g 2.3) (g 2)))

(definition (h x)
  (let ((y <fl> x))
    y))

(debug (h 2.3) (h 3)))


@w(
(definition (foo)
  (length (new Subseq))
  (length (new Axis 0)))


(new Cell 1 2)
(new-cell 2 3)


(+ (new Cell 1 2) (new-cell 2 3))
(cell+ (new Cell 1 2) (new-cell 2 3)))


@w
(import (jazz.io)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.platform)
        (jazz.repository.git)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.system)
        (jazz.utilities)
        (jedi)
        (test.a))


;;;
;;;; Types
;;;


@w
(definition (f)
  (let iter ((n 0))
    (+ n n)
    (iter "boum")))


@w
(class TC extends Object
  
  
  (slot row <Integer+> initialize 1)
  (slot col <fx>       initialize 3)


  (method (f)
    (when row
      (subseq! "Hello" 0 col)))


  (method (g)
    (subseq! "Hello" 0 col)))


@w
(definition (f)
  (list (class-of (f~ (new TC)))
        (class-of (g~ (new TC)))))


;;;
;;;; CFFI
;;;


@w(
(debug 'init1 (init1))

(debug 'scalar1 (scalar1 2))
(debug 'scalar2 (scalar2 3))
(debug 'scalar3 (scalar3 '(a)))

(let ((t1 (typ1 2 3))
      (t2 (typ2 2 3)))
  (debug 'typ1 t1 (foreign-tags t1) (still-obj-refcount t1))
  (debug 'typ2 t2 (foreign-tags t2) (still-obj-refcount t2))
  (gc)
  (debug 'typ3 (typ3 t1 t2)))

(let ((t4 (typ4 2 3))
      (t5 (typ5 2 3)))
  (debug 'typ4 t4 (foreign-tags t4) (still-obj-refcount t4))
  (debug 'typ5 t5 (foreign-tags t5) (still-obj-refcount t5))
  (gc)
  (debug 'typ6 (typ6 t4 t5)))

(debug 'constant (list ca cb))
(debug 'enumeration (list ea eb ec))

(let ((s1 (make-S1)))
  (debug 's1 s1 (foreign-tags s1) (still-obj-refcount s1))
  (debug 'struct1a (struct1a s1))
  (debug 'struct1c (struct1c s1)))

(debug 'func1 (func1)))


;;;
;;;; Iteration
;;;


@w(
(definition (iter-list lst proc)
  (when lst
    (proc (car lst))
    (iter-list (cdr lst) proc)))


(definition (iter-node node proc)
  (letrec ((iter
             (function (node)
               (proc node)
               (for-each iter (get-children~ node)))))
    (iter node)))


(definition (iter obj proc)
  (cond ((or (null? obj) (pair? obj)) (iter-list obj proc))
        ((is? obj JML-Node) (iter-node obj proc))))


(definition (foldl-list x f s)
  (if (not x)
      s
    (foldl-list (cdr x) f (f (car x) s))))


(definition (foldr-list x f s)
  (if (not x)
      s
    (f (car x) (foldr-list (cdr x) f s))))


(definition (foldl-node x f s)
  (foldl (get-children~ x)
         (function (c s)
           (foldl-node c f s))
         (f x s)))


(definition (foldr-node x f s)
  )


(definition (foldl-component x f s)
  (foldl (get-children~ x)
         (function (c s)
           (foldl-component c f s))
         (f x s)))


(definition (foldr-component x f s)
  )


(definition (foldl x f s)
  (cond ((or (null? x) (pair? x)) (foldl-list x f s))
        ((is? x JML-Node) (foldl-node x f s))
        ((is? x Component) (foldl-component x f s))))


(definition (foldr x f s)
  (cond ((or (null? x) (pair? x)) (foldr-list x f s))
        ((is? x JML-Node) (foldr-node x f s))
        ((is? x Component) (foldr-component x f s))))


(definition (iter-map proc obj)
  (let ((fact (new List-Factory)))
    (iter obj
          (function (x)
            (put~ fact (proc x))))
    (get-output~ fact)))


(definition (iter-linearize obj)
  (iter-map identity obj))


(definition (fold-map proc obj)
  (foldr obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (foldl-map proc obj)
  (foldl obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (fold-linearize obj)
  (fold-map identity obj))


(definition (fold x f s)
  (cond ((or (null? x) (pair? x)) (foldl-list x f s))
        ((is? x JML-Node) (fold-node x f s))
        ((is? x Component) (fold-component x f s))))


(definition (fold-node x f s)
  (let ((ps (f x s)))
    (for-each (function (c)
                (fold-node c f ps))
              (get-children~ x))
    ps))


(definition (fold-component x f s)
  (let ((ps (f x s)))
    (for-each (function (c)
                (fold-component c f ps))
              (get-children~ x))
    ps))


(definition (component->jml x)
  (fold x
        (function (c p)
          (new JML-Element p (identifier-name (type-name (class-of c))) properties: (list 'name (get-name~ c) 'position (get-position~ c) 'size (get-size~ c) 'serial (object->serial c))))
        {}))


(definition (pprint-component x)
  (pretty-print~
    (component->jml x)
    :console))


(definition (ppc x)
  (pprint-component x))


(definition (test x)
  (ppc x))))
