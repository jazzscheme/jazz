;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.workbench.Workbench-Manager jazz


(import (jazz.builder)
        (jazz.builder.workbench)
        (jazz.designer)
        (jazz.groupware)
        (jazz.io)
        (jazz.jml)
        (jazz.language.c)
        (jazz.language.java)
        (jazz.language.jazz)
        (jazz.library)
        (jazz.literals)
        (jazz.platform)
        (jazz.system.process)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.utilities))


(class Workbench-Manager extends Editor-View implements Exit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        (<Push-Combo>     name: configure
          (<!>            name: body               portfolio: :icons image-name: {Bitmap-Resource "Configure"} tooltip?: #t tooltip-text: "Configure" action-handler: {Event-Handler :form on-configure})
          (<!>            name: pick               action-handler: {Event-Handler :form on-configurations-menu}))
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" image-name: {Bitmap-Resource "Synchronize"} portfolio: :icons action-handler: {Event-Handler :form on-highlight-document}))
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           flat?: #t)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Product" width: 291 highlight-color: {Color name: Dark-Blue})))))
  
  
  (method meta (external-name . rest)
    'workbench-manager)

  
  ;;;
  ;;;; Host
  ;;;
  
  
  (method meta (host-icon)
    {Bitmap-Resource "Workbench"})
  
  
  (method meta (host-title)
    "Workbench")
  
  
  (method (install-in-host host)
    (setup-active-configuration)
    (setup-active-product))
  
  
  (method (setup-workbench-title configuration)
    (let ((host (get-host))
          (root (get-root))
          (title
            (if (not configuration)
                "Workbench"
              (format "Workbench - {a}" (get-name~ configuration)))))
      (set-title~ host title)
      (invalidate-view~ root)))
  
  
  (method (setup-active-configuration)
    (let* ((pref (get-preferences 'build))
           (active (get-active-configuration~ pref))
           (configuration (essay active (child~ (child~ pref 'configurations) active))))
      (setup-workbench-title configuration)
      (set-active-configuration configuration)))
  
  
  (method (setup-active-product)
    (let* ((pref (get-preferences 'build))
           (product (get-active-product~ pref))
           (workbench (get-workbench)))
      (when (and product workbench)
        (activate-product (find-product~ workbench product)))))
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method (get-tools-view)
    (locate 'tools))
  
  
  (method (focus-default)
    (let ((tree (get-tree)))
      (acquire-focus~ tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (get-tree)
    (locate '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  (method (new-controller)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (install rest)
    (nextmethod rest)
    (set-shown?~ (locate-component '(descendants header)) #f)
    (set-editor~ (locate 'descendants) self)
    (add-exit-listener~ (get-application) self)
    (set-client (get-workbench)))
  
  
  (method (get-designer-class)
    Workbench-Designer)
  
  
  (method (prepare-exit)
    (when designer
      (save-designer~ designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (on-designer evt)
    (nextmethod evt)
    (case (get-kind~ evt)
      ((:child-add) (child-add (get-property~ evt child:) (get-property~ evt parent:)))
      ((:child-remove) (child-remove (get-property~ evt child:)))))
  
  
  (method (child-add child parent)
    (when (is? child Project)
      (project-add~ designer child)))
  
  
  (method (child-remove child)
    (when (is? child Project)
      (project-remove~ designer child)))

  
  ;;;
  ;;;; Events
  ;;;
    
  
  (method (key-press key)
    (case key
      ((#\return) (launch-selection))))
  
  
  (method (on-configurations-menu evt)
    (let* ((sender (get-sender~ evt))
           (combo (get-combo~ sender))
           (pos (new Point 0 (get-height~ (get-size~ sender)))))
      (track-popup-menu~ sender (new Configurations-Menu client: self) pos initiator: combo)))
  
  
  (method (on-highlight-document evt)
    (highlight-document))
  
  
  (method (on-add-file evt)
    (add-file))
  
  
  (method (on-add-group evt)
    (add-group))
  
  
  (method (on-install-project evt)
    (let* ((current-directory? (get-shift?~ evt))
           (parent (selected-object))
           (file (with-import-directory current-directory? parent
                   (function (directory)
                     (choose-file extensions: '(("Jazz Files" . "jazz")) directory: directory)))))
      (install-project file parent #f)))
  
  
  (method (on-import-files evt)
    (import-files (get-shift?~ evt)))
  
  
  (method (on-import-directory evt)
    (import-directory (get-shift?~ evt)))
  
  
  (method (on-synchronize-content evt)
    (synchronize-content))
  
  
  (method (on-update-catalog evt)
    (update-catalog))
  
  
  (method (on-edit evt)
    (edit-selection))
  
  
  (method (on-activate evt)
    (activate-selection))
  
  
  (method (on-launch evt)
    (launch-selection))
  
  
  (method (on-run evt)
    (run-selection))
  
  
  (method (on-distribute evt)
    (distribute-selection))
  
  
  (method (on-properties evt)
    (show-properties))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-controller~ guest))
               (moniker (get-moniker~ controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (project-file (find-source~ workbench moniker)))
              (if (not project-file)
                  (bell)
                (highlight-component project-file))))))))
  
  
  (method (highlight-component component)
    (let* ((tree (get-tree))
           (row (component-row~ tree component)))
      (if (not row)
          (bell)
        (ensure-expanded~ tree row)
        (set-single-selection~ tree (row-rank~ tree row)))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current)
    (edit-project (current-product)))
  
  
  (method (edit-selection)
    (let ((objects (selected-objects)))
      (for-each (function (object)
                  (typecase object
                    ((Workbench) (edit-workbench))
                    ((Project) (edit-project object))))
                objects)))
  
  
  (definition Workbench-File
    {File Profile "settings" "Workbench.jml"})
  
  
  (method (edit-workbench)
    (let ((appl (get-application))
          (file Workbench-File))
      (edit-document~ appl file)))
  
  
  (method (edit-project project)
    (if (is-not? project Project)
        (bell)
      (edit-definition~ (get-application) (identifier-name (type-name (class-of project))))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (definition Templates-Directory
    {Directory Jazz "lib" "org.jedi" "templates" "new"})
  
  
  (method protected (add-file)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (let ((default-directory (either (default-import-directory parent must-exist?: #f) {Directory Profile})))
          (when (or (exists?~ default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list~ default-directory)) type: 'question) 'yes))
            (create-directories~ default-directory)
            (receive (kind template directory name) (get-modal Add-File-Dialog directory: default-directory)
              (when (memq? kind '(product module product))
                (set! directory (new-directory~ directory name))
                (create~ directory))
              (let* ((expander (new Templates-Directory))
                     (associations (list (cons 'name name)))
                     (template (new-file~ Templates-Directory template))
                     (extension (get-extension~ template))
                     (destination (new-file~ directory (format "{a}.{a}" name extension))))
                (call-with-output-file (parse~ destination)
                  (function (printer)
                    (expand~ expander template associations printer)))
                (select-component~ (get-tree) (import-pathname (ascendant-project parent) destination parent #f)))))))))
  
  
  (method protected (add-group)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Project-Group)
                (is? parent Project))
        (add-component-class~ (get-tree) Project-Group parent: parent))))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method (install-project file parent descendant?)
    (let ((parent-project (ascendant-project parent)))
      (when (validate-pathnames parent-project (list file))
        (let ((name (string->symbol (get-base~ file)))
              (module (find-pathname-module (parse~ file))))
          (if (not module)
              (error "Invalid project file: \"{a}\"" (get-name~ file))
            (let ((class (load-class name module))
                  (workbench (get-workbench)))
              (if (not (subtype? class Project))
                  (error "The file \"{a}\" does not contain a Project class" (get-name~ file))
                (let ((project (new class workbench: workbench parent: parent)))
                  (add-child~ designer project parent)
                  (set-tag-module~ designer project module)
                  (reorder-component~ (get-tree) project)
                  (user-message "{s} installed" (get-presentation~ project))
                  project))))))))

  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  
  (method (import-filter? project file)
    (let ((ext (get-extension~ file))
          (extensions (effective-include-extensions (get-include-extensions~ project))))
      (if extensions
          (member? ext extensions test: ci=?)
        (known-extension-frame-class~ (get-application) ext))))
  
  
  (method (import-directory current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (directory (with-import-directory current-directory? parent
                        (function (directory)
                          (choose-directory directory: directory))))
           (count (count-files~ directory filter: (function (file) (import-filter? project file)) max-count: MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) type: 'question) 'yes))
        (when (validate-pathnames project (list directory))
          (let ((component (import-pathname project directory parent #f)))
            (process-refresh~ designer component 'descendants))
          (user-message "{a} imported"
                        (parse~ directory))))))
  
  
  (method (import-files current-directory?)
    (let* ((parent (selected-object))
           (project (ascendant-project parent))
           (files (with-import-directory current-directory? parent
                    (function (directory)
                      (choose-file multiple-selection?: #t directory: directory)))))
      (import-pathnames project files parent)))
  
  
  (method protected (import-pathnames project pathnames parent)
    (when (validate-pathnames project pathnames)
      (for-each (function (pathname)
                  (let ((component (import-pathname project pathname parent #f)))
                    (process-refresh~ designer component 'descendants)))
                (sort nu<? pathnames key: (function (pathname) (get-name~ pathname))))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (format-cardinality count)
                      (format-plural count)))))
  
  
  (method (import-pathname project pathname parent descendant?)
    (let ((name (get-name~ pathname)))
      (typecase pathname
        ((Directory)
         (let ((project-file (new-file~ pathname (format "{a}.jazz" name))))
           (if (and (exists?~ project-file) (determine-project-file? project-file))
               (install-project project-file parent #t)
             (let ((subgroup (new Project-Group directory: pathname)))
               (add-child~ designer subgroup parent design-events?: (not descendant?) descendant?: descendant?)
               (set-property~ designer subgroup 'directory pathname design-events?: (not descendant?))
               (iterate-directory~ pathname
                 (function (pathname)
                   (import-pathname project pathname subgroup #t))
                 files?: #f
                 directories?: #t
                 sort?: #t
                 recursive?: #f)
               (iterate-directory~ pathname
                 (function (pathname)
                   (import-pathname project pathname subgroup #t))
                 files?: #t
                 directories?: #f
                 sort?: #t
                 recursive?: #f)
               subgroup))))
        ((File)
         (when (or (not descendant?) (import-filter? project pathname))
           (if (determine-project-file? pathname)
               (install-project pathname parent descendant?)
             (import-file pathname parent descendant?)))))))
  
  
  (method (import-file file parent descendant?)
    (let* ((model (extension-model (get-extension~ file)))
           (name (if (eq? model Jazz-File) (string->symbol (get-base~ file)) {}))
           (project-file (new model name: name source: file))
           (workbench (get-workbench)))
      (add-child~ designer project-file parent design-events?: (not descendant?) descendant?: descendant?)
      (set-property~ designer project-file 'source file design-events?: (not descendant?))
      (when (eq? model Jazz-File)
        (set-name~ designer project-file name design-events?: (not descendant?))
        (add-entry~ workbench name project-file))
      project-file))
  
  
  (method (determine-project-file? file)
    #f
    @convert-manifest
    (let ((ext (get-extension~ file)))
      (when (ci=? ext "jazz")
        (let ((info (extract-jazz-file-category file)))
          (when info
            (receive (package type name extends) info
              (when (in-manifest? extends)
                (subtype? (autoload extends) Project))))))))
  
  
  (method (default-import-directory object (must-exist?: must-exist? #t))
    (letrec ((default
               (function (object)
                 (typecase object
                   ((Workbench)
                    {Directory Jazz})
                   ((Project)
                    {})
                   ((Project-Group)
                    (get-directory~ object))
                   (else
                    {})))))
      (let ((dir (default object)))
        (when dir
          (anchorize~ dir)))))
  
  
  (method (with-import-directory current-directory? object proc)
    (let ((default-directory (essay (not current-directory?) (default-import-directory object))))
      (if (and default-directory (exists?~ default-directory))
          (with-preserved-current-directory
            (function ()
              (proc default-directory)))
        (proc {}))))
  
  
  (method (extension-model ext)
    (cond ((member? ext '("jazz") test: ci=?) Jazz-File)
          ((member? ext '("java") test: ci=?) Java-File)
          ((member? ext '("c" "cpp") test: ci=?) C-File)
          ((member? ext '("bmp") test: ci=?) Bitmap-File)
          ((member? ext '("cur") test: ci=?) Cursor-File)
          ((member? ext '("ico") test: ci=?) Icon-File)
          ((member? ext '("wav") test: ci=?) Sound-File)
          (else Project-File)))
  
  
  (method protected (ascendant-project component)
    (if (is? component Project)
        component
      (ascendant-project (get-parent~ component))))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content)
    @wait-complete
    (let* ((object (selected-object))
           (project (ascendant-project object))
           (directory (default-import-directory object must-exist?: #f)))
      (if (not (exists?~ directory))
          (error "Directory {s} not found" directory)
        (let ((fact (new List-Factory))
              (component-name
               (function (component)
                 (->string (get-name~ component))))
              (pathname-name
               (function (pathname)
                 (get-name~ pathname))))
          (letrec ((fold
                    (function (component pathname path)
                      (let ((children (get-children~ component))
                            (content (get-content~ pathname)))
                        (merge-ordered (function (what key left right)
                                         (let ((path (cons key path)))
                                           (case what
                                             ((:left) (put~ fact (list what path)))
                                             ((:right) (put~ fact (list what path)))
                                             ((:same)
                                              (when (directory? right)
                                                (fold left right path))))))
                                       (sort ci<? children key: component-name)
                                       (sort ci<? content key: pathname-name)
                                       left-key: component-name
                                       right-key: pathname-name
                                       case-insensitive?: #t)))))
            (fold object directory '())
            (let ((out-of-synch (get-output~ fact)))
              (if (null? out-of-synch)
                  (message-box "Content is already synchronized")
                (let* ((border (new Synchronize-Border size: {Dimension 500 200}))
                       (tree (locate~ border 'tree))
                       (add
                        (function (what path)
                          (let ((c0 (new Tree-Node title: (join path "/") image: {Bitmap-Resource "OpenedFolder"})))
                            (add-row~ tree children: (list c0 {} {} {}))))))
                  (for-each (function (info)
                              (bind (what path) info
                                (add what (reverse path))))
                            out-of-synch)
                  (message-box "The following elements are out of synch. Synchronize?" class: Synchronize-Box type: 'confirmation content: border)))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames project pathnames)
    @convert-to-checking-conflicts-with-an-understanding-of-the-module-hierarchy
    (validate
      (function (report)
        (letrec ((workbench (get-workbench))
                 (iterate
                  (function (pathname)
                    (typecase pathname
                      ((Directory)
                       (iterate-directory~ pathname iterate
                         files?: #t
                         directories?: #t
                         sort?: #t
                         recursive?: #f))
                      ((File)
                       (when (import-filter? project pathname)
                         (let ((model (extension-model (get-extension~ pathname))))
                           (when (eq? model Jazz-File)
                             (let* ((name (string->symbol (get-base~ pathname)))
                                    (jazz-file (get-entry~ workbench name)))
                               (when jazz-file
                                 (report jazz-file)))))))))))
          (for-each iterate pathnames)))))
  
  
  (method (validate iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (function (jazz-file)
          (put~ already-defined jazz-file)))
      (let ((already-defined (get-output~ already-defined)))
        (if (null? already-defined)
            #t
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following categor{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-y/ies count)
                                 (format-is/are count)))
                 (text
                  `(,header
                    ()
                    ,@(map (function (jazz-file)
                             (let ((project (get-project~ jazz-file))
                                   (action
                                    (function ()
                                      (close-modal-dialog
                                        (function ()
                                          (highlight-component jazz-file))))))
                               (list :bulleted
                                     (list :hyperlink action
                                           (format "{a} defined in {a}"
                                                   (get-name~ jazz-file)
                                                   (get-presentation~ project))))))
                           (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                    ,@(when too-many?
                        (list (list :bulleted "..."))))))
            (message-box text)
            #f)))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection)
    (activate-object (selected-object)))
  
  
  (method (activate-object object)
    (if (is-not? object Product)
        (bell)
      (activate-product object)))
  
  
  (method (activate-product product)
    (unless (eq? product active-product)
      (let ((tree (get-tree)))
        (when active-product
          (unhighlight-component~ tree active-product))
        (set-active-product product)
        (when active-product
          (let ((row (user-data-row~ tree active-product visible?: #f)))
            (when row
              (ensure-expanded~ tree row)))
          (highlight-component~ tree active-product)))
      (let ((appl (get-application)))
        (update-product-titles~ appl)
        (update-product-actions~ appl))))
    
  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (with-cursor :wait
      (function ()
        (let ((catalog (require-catalog~ (selected-project))))
          (load-content~ catalog)
          (update~ catalog)))))
    
  
  ;;;
  ;;;; Test
  ;;;
  
  
  (method public (test-current)
    (let ((product (current-product)))
      (product-test~ product)))

  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-current)
    (debug-product (current-product)))
  
  
  (method public (launch-selection)
    (let ((appl (get-application))
          (tree (get-tree)))
      (for-each (function (component)
                  (typecase component
                    ((Product)
                     (debug-product component))
                    ((Project-File)
                     (let* ((file (get-effective-source~ component))
                            (ext (get-extension~ file)))
                       (edit-document~ appl file)))))
                (selected-components~ tree))))
      
  
  (method (debug-product product)
    (debug-product~ (get-application) product))
  
  
  ;;;
  ;;;; Run
  ;;;
  
  
  (method public (run-current)
    (let ((product (current-product)))
      (run-product product)))


  (method public (run-selection)
    )

  
  (method (run-product product)
    (run-product~ (get-application) product))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let ((moniker (get-moniker~ (get-controller~ guest))))
          (compile-moniker moniker)))))
  
  
  (method public (compile-moniker moniker)
    (compile-file moniker #f)
    @temp
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file moniker project-file))))
  
  
  (method (compile-file moniker project-file)
    (let ((name (find-pathname-module (parse~ moniker))))
      (if (not name)
          (bell)
        (launch-runtime~ (get-application) arguments: (list "-compile" (->string name)) show-console?: #t))))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let* ((moniker (get-moniker~ (get-controller~ guest)))
               (workbench (get-workbench))
               (file (find-source~ workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  (method (preprocess-file moniker file)
    (let ((proc
           (function (thread)
             (let ((product (get-project~ file)))
               (prepare-maps~ product)
               (prepare-directories~ product)
               (user-message "Preprocessing {a}..." moniker)
               (let ((output (get-output-log))
                     (timer (new Timer)))
                 (clear-results~ output)
                 (select-results~ output)
                 (select-palette Output-Log)
                 (preprocess~ file product {} {} output force?: #t)
                 (user-message "Preprocessing done in {a}" (get-duration-in-seconds~ timer)))))))
      (proc {})))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current evt)
    (let ((product (current-product)))
      (if (not product)
          (bell)
        (build-product product))))
  
  
  (method public (build-current)
    ;; should be only the product's files...
    (save-all~ (get-application))
    (let ((product (current-product)))
      (build-product product)))
  
  
  (method (build-product product)
    (if (is-not? product Product)
        (bell)
      (let ((product-name (get-product~ product)))
        (launch-runtime~ (get-application) arguments: (list "-make" (->string product-name)) show-console?: #t))))
  
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current)
    (let ((product (current-product)))
      (clean-product product)))
  
  
  (method (clean-product product)
    (if (is-not? product Product)
        (bell)
      ;; to complete
      {}))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current evt)
    (let ((product (selected-product)))
      (if (not product)
          (bell)
        (distribute-product product))))
  
  
  (method public (distribute-current)
    (let ((product (current-product)))
      (distribute-product product)))
  
  
  (method (distribute-selection)
    (distribute-product (selected-product)))
  
  
  (method (distribute-product product)
    (let* ((mode         'backup)
           (left         (product-distribution~ product))
           (right        (product-distribution-directory~ product))
           (content      (product-distribution-list~ product))
           (ignored-dirs (list ".git" ".hg" "bin"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories left-moniker: left right-moniker: right left-content: content ignored-nodes: ignored-dirs ignored-leaves: files ignored-extensions: extensions host-visible?: #f)))
      (with-cursor :wait
        (function ()
          (compare-trees~ (get-guest~ frame))
          (bring-to-front~ frame)
          (set-visible?~ frame #t)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object)
    (let ((tree (get-tree)))
      (selected-component~ tree)))
  
  
  (method (selected-objects)
    (let ((tree (get-tree)))
      (selected-components~ tree)))
  
  
  (method (selected-project)
    (let ((object (selected-object)))
      (when (is? object Project)
        object)))
  
  
  (method (selected-product)
    (let ((object (selected-object)))
      (when (is? object Product)
        object)))
  
  
  (method (current-product)
    (if (not active-product)
        (error "No active product")
      active-product))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu)
    (let ((object (selected-object)))
      (when object
        (typecase object
          ((Project-Group) (new-group-menu object))
          ((Product) (new-product-menu object))
          ((Project) (new-project-menu object))
          (else (new Element-Menu client: (get-tree)))))))
  
  
  (method (new-group-menu object)
    (let ((menu (new Group-Menu client: (get-tree))))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-product-menu object)
    (let ((menu (new Product-Menu client: (get-tree))))
      (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-project-menu object)
    (let ((menu (new Project-Menu client: (get-tree))))
      @wait-complete
      (when (is? object Workbench)
        (set-visible?~ (locate~ menu 'synchronize-content) #f))
      (set-visible?~ (locate~ menu 'update-catalog) (get-catalog?~ object))
      (update-group/project-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (update-group/project-menu menu)
    (let ((tree (get-tree)))
      (when (> (length (get-selection~ tree)) 1)
        (set-visible?~ (locate~ menu 'install-project) #f)
        (set-visible?~ (locate~ menu 'import-files) #f)
        (set-visible?~ (locate~ menu 'import-directory) #f))))
  
  
  (method (install-configuration configuration)
    (set-active-configuration configuration)
    (setup-workbench-title configuration))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-product = {s}" active-product)
      (format :console "{%}project-designers =")
      (let* ((pairs (sort < (get-project-designers~ designer) key: (function (pair) (type-name (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (project . designer) pair
                      (format :console "{%}  {a} {a}" (type-name (class-of project)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}projects-table =")
      (let* ((pairs (sort < (table-keys/values (get-projects-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . project) pair
                      (format :console "{%}  {a} {a}" name project)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}categories-table =")
      (let* ((pairs (sort < (table-keys/values (get-categories-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . category) pair
                      (format :console "{%}  {a} {a}" name category)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}resources-table =")
      (let* ((pairs (sort < (table-keys/values (get-resources-table~ workbench)) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function (pair)
                    (bind (name . resource) pair
                      (format :console "{%}  {a} {a}" name resource)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Controller
;;;


(class Workbench-Manager-Controller extends Editor-View-Controller
  
  
  (method (document-status)
    "Workbench"))


;;;
;;;; Synchronize-Border
;;;


(class Synchronize-Border extends Border-View
  
  
  (form
    (<install>                                     border-type: solid border-color: {Color name: Outline-Border}
      (<Scroller-View>                             flat?: #t hscroll?: #t vscroll?: #t
        (<!>                         name: content layout-type: fill
          (<Tree-Header>                           flat?: #t
            (<!>                     name: content
              (<Synchronize-Tree>    name: tree))))))))


;;;
;;;; Configurations-Menu
;;;


(class Configurations-Menu extends Context-Menu
  
  
  (method (finish rest)
    (nextmethod rest)
    (let ((configurations (get-children~ (get-preferences '(build configurations)))))
      (for-each (function (configuration)
                  (let* ((name (get-name~ configuration))
                         (title (either (get-title~ configuration) (->string name))))
                    (new Check-Item parent: self checked?: (eq? configuration (get-active-configuration)) title: title action-handler: (new Event-Handler target: self method-name: 'on-action properties: (list configuration: configuration)))))
                configurations)))
  
  
  (method (on-action evt)
    (let ((appl (get-application))
          (configuration (get-property~ evt configuration:)))
      (install-configuration~ client configuration))))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-file            title: "Add..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: add-group           title: "Add Group..." before: add-item action: {Action workbench-manager add-group})
      (<Label-Item>     name: install-project     title: "Install Project..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit                title: "Edit" before: add-item icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager edit})
      (<Separator-Item>                           before: add-item)
      (<Label-Item>     name: add-file            title: "Add..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: add-group           title: "Add Group..." before: add-item action: {Action workbench-manager add-group})
      (<Label-Item>     name: install-project     title: "Install Project..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-project})
      (<Label-Item>     name: import-files        title: "Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "Import Directory..." before: cut action: {Action workbench-manager import-directory})
      @wait-complete
      (<Label-Item>     name: synchronize-content title: "Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut)
      (<Label-Item>     name: update-catalog      title: "Update Catalog" before: cut icon: {Bitmap-Resource "Repository"} action: {Action workbench-manager update-catalog})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Product-Menu
;;;


(class Product-Menu extends Project-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "Set as Active Product" before: cut default?: #t action: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit title: "Edit" before: cut default?: #t icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager launch})
      (<Separator-Item>            before: cut)))))
