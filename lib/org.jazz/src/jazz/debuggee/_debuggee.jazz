;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Debuggee
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debuggee jazz


(export (jazz.debuggee.autoload))
(import (jazz.debuggee.autoload)
        (jazz.debuggee.stub)
        (jazz.jrm)
        (jazz.jrm.register.stub))


;;;
;;;; Local
;;;


(definition local-process
  {})


(definition public (get-local-process)
  local-process)


(definition public (setup-local-process)
  (when (not local-process)
    (set! local-process (new Debuggee-Process-Local-Proxy (new Debuggee-Process)))))


;;;
;;;; Controller
;;;


(definition controller-debugger
  {})


(definition public (get-controller-debugger)
  controller-debugger)


(definition public (attach-to-controller controller-register)
  (detach-from-controller)
  (set! controller-debugger (require-object~ controller-register 'debugger))
  (setup-local-process)
  (set-console-port-getter console-port-getter)
  (attach-process~ controller-debugger local-process)
  (set-exception-debugger jazz-exception-debugger)
  (set-exception-hook exception-debugger-hook))


(definition public (detach-from-controller)
  (when controller-debugger
    (detach-from-debugger)
    (set! local-process {})))


(definition public (detach-from-debugger)
  (when controller-debugger
    (when (live?~ controller-debugger)
      (detach-process~ controller-debugger local-process))
    (set! controller-debugger {})))


(definition (setup-debuggee)
  (when (command-argument "debug")
    (start-remoting-server))
  (when (command-argument "controllerhost")
    (let ((host (string->host (command-argument "controllerhost")))
          (port (string->port (command-argument "controllerport"))))
      (attach-to-controller (new-remote-register host port)))))


(definition (update-debuggee-process)
  (when controller-debugger
    (update-process~ controller-debugger local-process)))


;;;
;;;; Stops
;;;


(definition *stops*
  '())


(definition with-stops-mutex
  (let ((mutex (make-mutex 'stops)))
    (function (thunk)
      (mutex-lock! mutex)
      (thunk)
      (mutex-unlock! mutex))))


(definition (register-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (append *stops* (list stop))))))


(definition (unregister-stop stop)
  (with-stops-mutex
    (function ()
      (set! *stops* (remove! stop *stops*)))))


(definition (get-thread-stops thread)
  (let ((queue (new-queue)))
    (for-each (function (stop)
                (when (eq? (get-thread~ stop) thread)
                  (enqueue queue (new Debuggee-Stop-Local-Proxy stop))))
              *stops*)
    (queue-list queue)))


;;;
;;;; Console
;;;


(class Console extends Object
  
  
  (slot remote  getter generate)
  (slot pump    getter generate)
  (slot tail    getter generate)
  (slot head    getter generate)
  (slot context accessors generate)
  (slot history accessors generate)
  
  
  (method (initialize remote pump tail head)
    (set! remote~self remote)
    (set! pump~self pump)
    (set! tail~self tail)
    (set! head~self head)
    (set! context~self (unspecified))
    (set! history~self {})))


(definition *consoles*
  (make-table test: eq?))


(definition with-consoles-mutex
  (let ((mutex (make-mutex 'consoles)))
    (function (thunk)
      (mutex-lock! mutex)
      (prog1 (thunk)
        (mutex-unlock! mutex)))))


(definition (thread-console thread)
  (with-consoles-mutex
    (function ()
      (either (table-ref *consoles* thread #f)
              (let ((console (make-debuggee-console (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))))
                (table-set! *consoles* thread console)
                console)))))


(definition (thread-console-pump-port thread)
  (get-tail~ (thread-console thread)))

(definition (thread-console-port thread)
  (get-head~ (thread-console thread)))


(definition (current-console)
  (thread-console (current-thread)))


(definition (make-debuggee-console thread-proxy)
  (receive (head tail) (open-string-pipe (list permanent-close: #f))
    (let ((console (register-console~ controller-debugger local-process thread-proxy)))
      (let ((pump (start-debuggee-console-pump console tail)))
        (new Console console pump tail head)))))


(definition (console-port-getter)
  (get-head~ (current-console)))


;;;
;;;; Pump
;;;


(definition (start-debuggee-console-pump console port)
  (thread-start!
    (new-thread
      (function ()
        (start-pump (new Permanent-Port port)
          (function (str)
            (when controller-debugger
              (console-output~ controller-debugger console str)))))
      "Debuggee Console Pump")))


(definition (stop-debuggee-console-pump thread)
  (thread-interrupt! thread
    thread-exit))


;;;
;;;; Repl
;;;


(definition current-repl-level
  (make-parameter 0))

(definition current-repl-frame
  (make-parameter {}))


(definition (with-repl-thread thread reason port level thunk)
  (let ((thread (start-repl-thread thread reason port level)))
    (unwind-protect
        (thunk)
      (thread-interrupt! thread
        thread-exit))))


(definition (start-repl-thread thread reason port (level 0))
  (thread-start!
    (new-thread
      (function ()
        (when (= level 0)
          (display-banner port))
        (when reason
          (display reason port))
        (display-prompt port level)
        (read-eval-print-loop thread port level))
      "Repl")))


(definition (display-banner port)
  (format port "{a} {a}{%}{%}"
          (current-process-title)
          (current-process-version))
  (force-output port))


(definition (display-prompt port level)
  (when (> level 0)
    (format port "{a}" level))
  (format port "> ")
  (force-output port))


(definition (read-eval-print-loop thread port level)
  (declare (proper-tail-calls))
  (let (iterate)
    (read-eval-print thread port level)
    (iterate)))


(definition (read-eval-print thread port level)
  (let ((expr (read port)))
    (if (eof-object? expr)
        (thread-post thread 'resume-loop
          (function ()
            (let ((restarts (find-restarts 'resume-loop)))
              (when (> (length restarts) 1)
                (newline port)
                ;; skip the current resume-loop restart
                (let ((restart (second restarts)))
                  (invoke-restart restart))))))
      (let ((result
              (thread-call thread 'evaluate
                (function ()
                  (evaluate expr)))))
        (when (and (thread-call-result? result)
                   (specified? result))
          (repl-result-history-add result)
          (format port "{s}" result)
          (format port "{%}"))
        (display-prompt port level)
        (force-output port)))))


(definition (evaluate expr)
  (define (context-init console)
    (let ((context (get-context~ console)))
      (if (unspecified? context)
          (let ((new-context
                  (let ((process (get-process)))
                    (if process
                        (context-alias (initial-console-context~ process))
                      {}))))
            (set-context~ console new-context)
            new-context)
        context)))
  
  (define (context-alias context)
    (when (and (enumerator? context) (get-process))
      (process-alias~ (get-process) context)))
  
  (define (parse-unquote-command expr)
    (if (and (pair? expr)
             (eq? (car expr) 'unquote)
             (pair? (cdr expr)))
        (let ((unquoted (cadr expr)))
          (cond ((symbol? unquoted)
                 (values unquoted '()))
                ((pair? unquoted)
                 (values (car unquoted) (cdr unquoted)))
                (else
                 (values {} {}))))
      (values {} {})))
  
  (let ((console (current-console)))
    (let ((context (context-init console))
          (frame-box (current-repl-frame)))
      (receive (command arguments) (parse-unquote-command expr)
        (cond ((eq? command 'ctx)
               (if (null? arguments)
                   context
                 (let ((ctx (car arguments)))
                   (let ((new-context (either (context-alias ctx) (evaluate ctx))))
                     (when (symbol? new-context)
                       (load-module new-context))
                     (set-context~ console new-context)
                     new-context))))
              (#f @convert frame-box
               (evaluate-in-frame (unbox frame-box) expr))
              (else
               (evaluate-in-context context expr)))))))


(definition (evaluate-in-frame frame expr)
  (let ((frame (unbox box)))
    (if (not frame)
        (eval expr)
      (let ((cont (serial->object (get-continuation~ frame))))
        (eval-within-no-winding expr cont)))))


(definition (evaluate-in-context context expr)
  (parameterize ((jazz.walk-for 'eval))
    (cond ((not context)
           (eval expr))
          ((symbol? context)
           (let ((module-name context))
             (load-module module-name)
             (locate-library-declaration module-name)
             (eval
               `(library ,module-name jazz
                ,expr))))
          (else
           (let ((class-identifier (type-name (class-of context))))
             (let ((module-name (identifier-module class-identifier))
                   (class-name (identifier-name class-identifier)))
               (load-module module-name)
               (locate-library-declaration module-name)
               (eval
                 `(library ,module-name jazz
                  (class ,class-name
                    (method (evaluate)
                      ,expr)))))
             ((dispatch context 'evaluate) context))))))


;;;
;;;; Exception
;;;


(definition (jazz-exception-debugger exc)
  (let ((debugger (get-controller-debugger)))
    (if (or (not debugger) (not (use-debugger?)))
        (invoke-exception-hook system-exception-hook exc)
      (with-system-exception-debugger
        (function ()
          (continuation-capture
            (function (continuation)
              (let ((reason (exception-reason exc))
                    (detail (exception-detail exc)))
                (invoke-debugger 'exception reason detail continuation)))))))))


(definition (with-jazz-exception-debugger thunk)
  (with-exception-debugger jazz-exception-debugger
    thunk))


(definition (break (reason {}))
  (continuation-capture
    (function (continuation)
      (invoke-debugger 'break reason {} continuation))))


;;;
;;;; Debugger
;;;


(definition (invoke-debugger kind reason detail continuation)
  (let* ((thread (current-thread))
         (port (get-console-port))
         (level (+ (current-repl-level) 1))
         (restarts (compute-restarts thread))
         (stop (new Debuggee-Stop thread kind reason detail continuation restarts)))
    (dynamic-wind
      (function ()
        (register-stop stop))
      (function ()
        (let ((thread-proxy (new Debuggee-Thread-Local-Proxy (new Debuggee-Thread thread)))
              (stop-proxy (new Debuggee-Stop-Local-Proxy stop)))
          (parameterize ((current-repl-level level))
            (with-repl-thread thread reason port level
              (function ()
                (parameterize ((current-repl-frame (box {})))
                  (debuggee-stop~ controller-debugger local-process thread-proxy stop-proxy kind reason)
                  (let ((process (get-process)))
                    (if (not process)
                        (debuggee-loop)
                      (process-debuggee-loop~ process)))))))))
      (function ()
        (unregister-stop stop)))))


(definition (compute-restarts thread)
  (let ((previous-stops (get-thread-stops thread))
        (all-restarts (current-restarts)))
    (map (function (restart)
           (new Debuggee-Restart-Local-Proxy (new Debuggee-Restart thread restart)))
         (if (null? previous-stops)
             all-restarts
           (let ((skip (apply max (map (function (stop) (length (get-restarts~ stop))) previous-stops))))
             (subseq all-restarts 0 (- (length all-restarts) skip)))))))


(definition (debuggee-loop)
  (let (loop)
    (with-restart-catcher 'resume-loop "Resume loop" {}
      (function ()
        (let ((thunk (thread-read)))
          (with-jazz-exception-debugger
            thunk))))
    (loop)))


;;;
;;;; View
;;;


(definition *current-view-debugger*
  #f)


(definition public (current-view-debugger)
  (when (not *current-view-debugger*)
    (set! *current-view-debugger* (new View-Debugger)))
  *current-view-debugger*))
