;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Cairo Surface
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Jeremie Lasalle Ratelle.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Guillaume Cartier
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.graphic.Surface jazz


(import (jazz.development)
        (jazz.library)
        (jazz.literals)
        (jazz.platform.cairo)
        (jazz.platform.windows (cond windows))
        (jazz.ui)
        (jazz.ui.graphic.font)
        (jazz.utilities))


;; origin  -> origin used by the view painting algorithm
;; clipper -> clip rectangle used by the view painting algorithm


(class Surface extends Object
  
  
  (slot clipper            <Rect>       initialize (new Rect 0 0 0 0))
  (slot surface)
  (slot hdc)
  (slot context)
  (slot dash-array                      initialize {})
  (slot empty-array                     initialize {})
  (slot glyph-array                     initialize {})
  (slot array-length       <fx>         initialize 0)
  (slot landscape?         <bool>       initialize #f)
  (slot landscape-rotation <symbol+>    initialize {})
  (slot landscape-page     <Dimension+> initialize {})

  
  (method (initialize surface . rest)
    (nextmethod)  
    (set! surface~self surface)
    ;;(set! hdc~self (cairo_win32_surface_get_dc surface))
    (set! context~self (cairo_create surface))
    (destroy-mandatory))


  (method (destroy)
    (glyph-array-free glyph-array)
    (destroy-surface)
    (destroy-context)
    (nextmethod))
  
  
  (method public (new-context)
    (destroy-context)
    (set! context (cairo_create surface)))
  
  
  (method protected virtual (destroy-surface)
    (when surface
      (let ((err (cairo-surface-status)))
        (when (/= err 0)
          (error "Cairo Surface Error {t}" err)))
      (cairo_surface_destroy surface)
      (set! surface {})))
  
  
  (method protected virtual (destroy-context)
    (when context
      (let ((err (cairo-status)))
        (when (/= err 0)
          (error "Cairo Context Error {t}" err)))
      (cairo_destroy context)
      (set! context {})))
  
  
  (method public (cairo-finish)
    (cairo_surface_finish surface))
  
  
  (method public (show-page)
    @a
    (cairo_surface_show_page surface))
  
  
  ;;;
  ;;;; Access
  ;;;


  (method public (get-context)
    context)
  
  
  (method public (get-surface)
    surface)
  
  
  (proclaim (optimize))
  
  
  ;;;
  ;;;; Device
  ;;;


  (method public (logical->device shape <Point>)
    (cairo_user_to_device context shape))
  
  
  (method public (device->logical shape <Object>)
    (typecase shape
      ((Point)
       (cairo_device_to_user context shape))
      ((Rect)
       (let ((pt1 (cairo_device_to_user context (new Point (get-left~ shape) (get-top~ shape))))
             (pt2 (cairo_device_to_user context (new Point (get-right~ shape) (get-bottom~ shape)))))
         (new Rect (get-h~ pt1) (get-v~ pt1) (get-h~ pt2) (get-v~ pt2))))))
  
  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (setup-clipper clipper <Rect>)
    (set-clipper clipper))
  
  
  (method public (get-clipper) <Rect>
    (new Rect (get-left~ clipper)
              (get-top~ clipper)
              (get-right~ clipper)
              (get-bottom~ clipper)))
  
  
  (method public (set-clipper rect <Rect>)
    (set-left~ clipper (get-left~ rect))
    (set-top~ clipper (get-top~ rect))
    (set-right~ clipper (get-right~ rect))
    (set-bottom~ clipper (get-bottom~ rect))
    (select-clipper clipper))


  (method public (select-clipper rect <Rect>)
    (cairo_reset_clip context)
    (draw-rectangle rect)
    (cairo_clip context))
  
  
  (method public (with-clipper clip-rect <Rect> proc <procedure>)
    (let* ((old-clipper (get-clipper))
           (new-clipper (rect-intersection old-clipper clip-rect)))
      (let ((selected? #f))
        (unwind-protect
            (begin
              (set-clipper new-clipper)
              (set! selected? #t)
              (proc))
          (when selected?
            (set-clipper old-clipper))))))
  
  
  ;;;
  ;;;; Landscape
  ;;;
  
  
  (method public (with-landscape rotation <symbol> page <Dimension> proc <procedure>)
    (let ((preserved landscape?))
      (unwind-protect
          (begin
            (set! landscape? #t)
            (set! landscape-rotation rotation)
            (set! landscape-page page)
            (proc))
        (set! landscape? preserved))))
  
  
  ;;;
  ;;;; Transform
  ;;;
  
  
  ;; lh lv : position of the drawing relative to the player
  ;; sh sv : position of the scaled view relative to the player
  ;; dh dv : position of the drawing relative to the scaled view, i.e. s - l
  ;; ch cv : position of the clipper in device coordinates
  ;; cwidth cheight : size of the clipper in device coordinates
    
  
  (method public (set-transform drawing <Drawing> lh <fx> lv <fx> width <fx> height <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (define (set-transform-scaled)
      (let* ((dh (- lh sh))
             (dv (- lv sv))
             (dx (if (not landscape?) (+ sh (* dh sc)) (+ sv (* (case landscape-rotation ((clockwise) (- (get-height~ (cast <Dimension> landscape-page)) dv)) (else dv)) sc))))
             (dy (if (not landscape?) (+ sv (* dv sc)) (+ sh (* (case landscape-rotation ((clockwise) dh) (else (- (get-width~ (cast <Dimension> landscape-page)) dh))) sc))))
             (ch (round dx))
             (cv (round dy))
             (cwidth (fxceiling (* width sc)))
             (cheight (fxceiling (* height sc))))
        (let ((old-matrix (cairo_matrix_t-make))
              (new-matrix (cairo_matrix_t-make)))
          (cairo_get_matrix context old-matrix)
          (cairo_identity_matrix context)
          (let* ((clipper (if #f
                              (case landscape-rotation
                                ((clockwise) (new Rect (- ch cheight) cv ch (+ cv cwidth)))
                                ((counterclockwise) (new Rect ch (- cv cwidth) (+ ch cheight) cv)))
                            (new Rect ch cv (+ ch cwidth) (+ cv cheight))))
                 (old-clipper (get-clipper))
                 (new-clipper (rect-intersection old-clipper clipper)))
            (set-clipper new-clipper)
            (if landscape?
                (case landscape-rotation
                  ((clockwise)
                   (cairo_matrix_t-xx-set! new-matrix 0.0) (cairo_matrix_t-xy-set! new-matrix sc)
                   (cairo_matrix_t-yx-set! new-matrix (- sc)) (cairo_matrix_t-yy-set! new-matrix 0.0))
                  ((counterclockwise)
                   (cairo_matrix_t-xx-set! new-matrix 0.0) (cairo_matrix_t-xy-set! new-matrix (- sc))
                   (cairo_matrix_t-yx-set! new-matrix sc) (cairo_matrix_t-yy-set! new-matrix 0.0)))
              (cairo_matrix_t-xx-set! new-matrix sc)
              (cairo_matrix_t-xy-set! new-matrix 0.0)
              (cairo_matrix_t-yx-set! new-matrix 0.0)
              (cairo_matrix_t-yy-set! new-matrix sc))
            (cairo_matrix_t-x0-set! new-matrix (exact->inexact dx))
            (cairo_matrix_t-y0-set! new-matrix (exact->inexact dy))
            (cairo_set_matrix context new-matrix)
            (cairo_matrix_t-free new-matrix)
            (values old-clipper old-matrix)))))
  
  (define (set-transform-unscaled)
    (let ((old-matrix (cairo_matrix_t-make)))
      (cairo_get_matrix context old-matrix)
      (cairo_identity_matrix context)
      (let* ((clipper (new Rect lh lv (+ lh width) (+ lv height)))
             (old-clipper (get-clipper))
             (new-clipper (rect-intersection old-clipper clipper)))
        (set-clipper new-clipper)
        (cairo_translate context (cast <fl> lh) (cast <fl> lv))
        (values old-clipper old-matrix))))
  
  (if sc?
      (set-transform-scaled)
    (set-transform-unscaled)))
        
  
  (method public (with-transform drawing <Drawing> lh <fx> lv <fx> width <fx> height <fx> sh <fx> sv <fx> sc <fl> sc? <bool> proc <procedure>)
    (receive (old-clipper old-matrix) (set-transform drawing lh lv width height sh sv sc sc?)
      (proc)
      (cairo_identity_matrix context)
      (set-clipper old-clipper)
      (cairo_set_matrix context old-matrix)
      (cairo_matrix_t-free old-matrix)))

  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method public (set-text-color color <Color>)
    (set-color color))
  
  
  (method public (get-char-width n <fx>)
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let* ((handle (get-handle~ (cairo-get-font (cairo_get_font_face context))))
             (ch (cairo_glyph_index handle surface n)))
        (cairo_glyph_t-index-set! gly ch)
        (cairo_glyph_t-x-set! gly 0.)
        (cairo_glyph_t-y-set! gly 0.)
        (cairo_glyph_extents context gly 1 ext)
        (let ((width (fxround (cairo_text_extents_t-x_advance-ref ext))))
          (cairo_glyph_t-free gly)
          (cairo_text_extents_t-free ext)
          width))))


  (method public (get-char-widths (first: first 0) (last: last 255))
    (let ((ext (cairo_text_extents_t-make))
          (gly (cairo_glyph_t-make)))
      (let ((vec (make-vector (+ (- last first) 1))))
        (loop (for i from first to last)
              (do
                (let* ((handle (get-handle~ (cairo-get-font (cairo_get_font_face context))))
                       (ch (cairo_glyph_index handle surface i)))
                  (cairo_glyph_t-index-set! gly ch)
                  (cairo_glyph_t-x-set! gly 0.)
                  (cairo_glyph_t-y-set! gly 0.)
                  (cairo_glyph_extents context gly 1 ext)
                  (vector-set! vec i (fxround (cairo_text_extents_t-x_advance-ref ext))))))
        (cairo_glyph_t-free gly)
        (cairo_text_extents_t-free ext)
        vec)))
  

  (method public (get-text-extent text <string>)
    (with ((extents (cairo_text_extents_t-make))
           (metrics (get-text-metrics)))
      (cairo_text_extents context text extents)
      (prog1 (new Dimension 
               (fxround (cairo_text_extents_t-x_advance-ref extents)) 
               (fxround (cairo_font_extents_t-height-ref metrics)))
        (cairo_text_extents_t-free extents)
        (cairo_font_extents_t-free metrics))))
    
  
  (method public (get-font-height)
    (with ((extents (cairo_font_extents_t-make)))
      (cairo_font_extents context extents)
      (prog1 (fxround (cairo_font_extents_t-height-ref extents))
        (cairo_font_extents_t-free extents))))
  
  
  (method public (get-text-metrics)
    (let ((info (cairo_font_extents_t-make)))
      (cairo_font_extents context info)
      info))
  
  
  (method public (cairo_extents->dimension extents)
    (new Dimension 
      (fxceiling (cairo_text_extents_t-width-ref extents)) 
      (fxceiling (cairo_text_extents_t-height-ref extents))))
  

  (method public (get-text-width text <string>)
    (with ((extents (cairo_text_extents_t-make)))
      (cairo_text_extents context text extents)
      (prog1 (fxceiling (cairo_text_extents_t-x_advance-ref extents))
        (cairo_text_extents_t-free extents))))
  
  
  (method public (draw-text h <fx> v <fx> str <string> . rest)
    (let ((uph h)
          (font-ext (cairo_font_extents_t-make))
          (extents (cairo_text_extents_t-make))
          (lgt (cardinality str)))
      (if (< array-length lgt)
          (begin
            (when glyph-array
              (glyph-array-free glyph-array))
            (set! glyph-array (glyph-array-make (* lgt 2)))
            (set! array-length (* lgt 2))))
      (cairo_font_extents context font-ext)
      (let ((y (+ v (fxround (cairo_font_extents_t-ascent-ref font-ext)))))
        (let (iter (i 0))
          (when (< i lgt)
            (let* ((handle (get-handle~ (cairo-get-font (cairo_get_font_face context))))
                   (glyph (glyph-array-ref glyph-array i))
                   (ch (cairo_glyph_index handle surface (char->integer (element str i)))))
              (cairo_glyph_t-index-set! glyph ch)
              (cairo_glyph_t-x-set! glyph (cast <fl> uph))
              (cairo_glyph_t-y-set! glyph (cast <fl> y))
              (cairo_glyph_extents context glyph 1 extents)
              (set! uph (+ uph (fxround (cairo_text_extents_t-x_advance-ref extents))))
              (iter (+ i 1)))))
        (let ((yo (cairo_get_source context)))
        (cairo_set_source context yo))
        (cairo_show_glyphs context glyph-array lgt)
        (cairo_font_extents_t-free font-ext)
        (cairo_text_extents_t-free extents)
        (- uph h))))
  
  
  ;; temp copy/pasted from above until templates
  (method (draw-substring h <fx> v <fx> str <Subseq$string$> color <Color> highlight-color <Color+>) <fx>
    (let ((uph h)
          (font-ext (cairo_font_extents_t-make))
          (extents (cairo_text_extents_t-make))
          (lgt (cardinality str)))
      (if (< array-length lgt)
          (begin
            (when glyph-array
              (glyph-array-free glyph-array))
            (set! glyph-array (glyph-array-make (* lgt 2)))
            (set! array-length (* lgt 2))))
      (cairo_font_extents context font-ext)
      (let ((y (+ v (fxround (cairo_font_extents_t-ascent-ref font-ext)))))
        (let (iter (i 0))
          (when (< i lgt)
            (let* ((handle (get-handle~ (cairo-get-font (cairo_get_font_face context))))
   (glyph (glyph-array-ref glyph-array i))
   (ch (cairo_glyph_index handle surface (char->integer (element str i)))))
              (cairo_glyph_t-index-set! glyph ch)
              (cairo_glyph_t-x-set! glyph (cast <fl> uph))
              (cairo_glyph_t-y-set! glyph (cast <fl> y))
              (cairo_glyph_extents context glyph 1 extents)
              (set! uph (+ uph (fxround (cairo_text_extents_t-x_advance-ref extents))))
              (iter (+ i 1)))))
        (when highlight-color
          (fill-rect (new Rect h v uph (fxround (cairo_font_extents_t-height-ref font-ext))) highlight-color))
        (set-text-color color)
        (cairo_show_glyphs context glyph-array lgt)
        (cairo_font_extents_t-free font-ext)
        (cairo_text_extents_t-free extents)
        (- uph h))))
  
  
  ;; should remove the subseq! and pass the bounds to draw-substring
  (method public (draw-tabbed-text h <fx> v <fx> str <Subseq$string$> tabs origin <fx> color <Color> highlight-color <Color+>) <fx>
    (let ((uph h)
          (beginning 0)
          (stops tabs))
      (loop (for i from 0 below (cardinality str))
            (when (eqv? (element str i) #\tab)
              (when (/= beginning i)
                (set! uph (+ uph (draw-substring uph v (subseq! str beginning i)))))
              (while (<= (+ origin (cast <fx> (car stops))) (+ uph 1))
                (set! stops (cdr stops)))
              (set! uph (+ origin (cast <fx> (car stops))))
              (set! beginning (+ i 1))
              (set! stops (cdr stops))))
      (- (+ uph (draw-substring uph v (subseq! str beginning (cardinality str)) color highlight-color))
         h)))

  
  ;;;
  ;;;; Region
  ;;;
  
  
  (method public (fill-region region <Region> color)
    (loop (for rect in (get-rectangles~ region))
          (do (fill-rect rect color))))
  
  
  (method public (gradient-fill rect <Rect> stops (direction: direction 'horizontal))
    (let* ((left (get-left~ rect))
           (top (get-top~ rect))
           (right (get-right~ rect))
           (bottom (get-bottom~ rect))
           (horzmid (fxfloor/ (- right left) 2))
           (vertmid (fxfloor/ (- bottom top) 2))
           (pattern (case direction
                      ((horizontal)
                       (create-linear-pattern left vertmid right vertmid))
                      ((vertical)
                       (create-linear-pattern horzmid top horzmid bottom)))))
      (for-each (function (stop)
                  (bind (offset color) stop
                    (add-color-stop pattern offset color)))
                stops)
      (draw-rectangle rect)
      (cairo_set_source context pattern)
      (fill)
      (cairo_pattern_destroy pattern)))
  
   
  (method public (ellipse rect <Rect> outside inside)
    (let ((left (get-left~ rect))
          (right (get-right~ rect))
          (top (get-top~ rect))
          (bottom (get-bottom~ rect)))
      (let ((w (- right left))
            (h (- bottom top)))
        (let ((tx (exact->inexact (+ left (/ w 2))))
              (ty (exact->inexact (+ top (/ h 2)))))
          (cairo_translate context tx ty)
          (cairo_scale context (exact->inexact (/ w 2)) (exact->inexact (/ h 2)))
          (cairo_arc context (cast <fl> 0) (cast <fl> 0) (cast <fl> 1) (cast <fl> 0) (* 2 M_PI))
          (cairo_scale context (exact->inexact (/ 2 w)) (exact->inexact (/ 2 h)))
          (cairo_translate context (- tx) (- ty)))))
    (when outside
      (set-color (if (is? outside Color)
                     outside
                   (get-color-for-object outside)))
      (set-line-width (if (and (is? outside Pen) (get-width~ outside))
                          (get-width~ outside)
                        1)))
    (if (not inside)
        (stroke)
      (stroke-preserve)
      (set-color (if (is? inside Color)
                     inside
                   (get-color-for-object inside)))
      (fill)))

  
  (method public (draw-image handle h v)
    (cairo_set_source_surface context handle (cast <fl> h) (cast <fl> v))
    (cairo_paint context))
  
  
  ;;;
  ;;;; Control
  ;;;
  
  
  (method public (draw-scroll-bar rect <Rect> direction)
    (draw-rectangle rect)
    (set-color {Color name: Draw-Edge-Light})
    (fill)
    (draw-edge rect inner: 'raised outer: 'raised edges: 'rectangle)
    (let ((dh (cond ((eq? direction 'left) 1)
                    ((eq? direction 'right) 2)
                    ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)))
          (dv (cond ((eq? direction 'up) 1)
                    ((eq? direction 'down) 1)
                    (else 0))))
      (set-color {Color name: Black})
      (draw-arrow-tip (+ (get-left~ rect) 3 dh) (+ (get-top~ rect) 4 dv) 3 direction)))
   
  
  (method public (draw-caption rect <Rect> type (pushed? #f))
    (draw-rectangle rect)
    (set-color {Color name: Draw-Edge-Light})
    (fill)
    (if pushed?
        (begin
          (draw-edge rect inner: 'sunken edges: 'rectangle)
          (draw-edge (new Rect (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (- (get-right~ rect) 1) (- (get-bottom~ rect) 1)) outer: 'sunken edges: 'rectangle))
      (draw-edge rect inner: 'raised outer: 'raised edges: 'rectangle))
    (set-color {Color name: Black})
    (let ((rect (if pushed? (new Rect (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (+ (get-right~ rect) 1) (+ (get-bottom~ rect) 1)) rect)))
      (cond ((eq? type 'close)
             (set-line-width 1)
             (move-to (+ (get-left~ rect) 4) (+ (get-top~ rect) 3))
             (line-to (- (get-right~ rect) 4) (- (get-bottom~ rect) 4))
             (move-to (- (get-right~ rect) 4) (+ (get-top~ rect) 3))
             (line-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 4))
             (stroke))
            ((eq? type 'minimize)
             (set-line-width 1)
             (move-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 5))
             (line-to (- (get-right~ rect) 6) (- (get-bottom~ rect) 5))
             (move-to (+ (get-left~ rect) 4) (- (get-bottom~ rect) 4))
             (line-to (- (get-right~ rect) 6) (- (get-bottom~ rect) 4))
             (stroke))
            ((eq? type 'restore)
             (set-line-width 1)
             (move-to (+ (get-left~ rect) 3) (- (get-bottom~ rect) 3 0.5))
             (line-to-rel 5.5 0)
             (line-to-rel 0 -4)
             (line-to-rel -5.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 6 0)
             (move-to-rel -5.5 0)
             (line-to-rel 0 5)
             (move-to (+ (get-left~ rect) 8) (- (get-bottom~ rect) 6 0.5))
             (line-to-rel 2.5 0)
             (line-to-rel 0 -4)
             (line-to-rel -5.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 6 0)
             (move-to-rel -5.5 0)
             (line-to-rel 0 3)             
             (stroke))
            ((eq? type 'maximize)
             (move-to (+ (get-left~ rect) 3) (- (get-bottom~ rect) 3 0.5))
             (line-to-rel 8.5 0)
             (line-to-rel 0 -7)
             (line-to-rel -8.5 0)
             (move-to-rel 0 -1)
             (line-to-rel 9 0)
             (move-to-rel -8.5 0)
             (line-to-rel 0 7.5)
             (stroke)))))
  
  
  (method public (draw-radio-button rect <Rect> (inactive?: inactive? #f) (selected?: selected? #f))
    (let ((x (+ (get-left~ rect) (/ (- (get-right~ rect) (get-left~ rect)) 2.)))
          (y (+ (get-top~ rect) (/ (- (get-bottom~ rect) (get-top~ rect)) 2.)))
          (r (/ (- (get-right~ rect) (get-left~ rect)) 2.)))
      (cairo_arc context (cast <fl> x) (cast <fl> y) (cast <fl> r) (cast <fl> 0) (* 2 M_PI))
      (set-color (if inactive? 
                     {Color name: Light-Background}
                   {Color name: White}))
      (fill)
      (set-line-width 1)
      (cairo_arc context (cast <fl> x) (cast <fl> y) (exact->inexact r) (* 3 (/ M_PI 4)) (* 7 (/ M_PI 4)))
      (set-color {Color name: Draw-Edge-Medium})
      (stroke)
      (cairo_arc context (cast <fl> x) (cast <fl> y) (exact->inexact (- r 1)) (* 3 (/ M_PI 4)) (* 7 (/ M_PI 4)))
      (set-color {Color name: Draw-Edge-Dark})
      (stroke)
      (cairo_arc context (cast <fl> x) (cast <fl> y) (exact->inexact r) (* 7 (/ M_PI 4)) (* 3 (/ M_PI 4)))
      (set-color {Color name: White})
      (stroke)
      (cairo_arc context (cast <fl> x) (cast <fl> y) (exact->inexact (- r 1)) (* 7 (/ M_PI 4)) (* 3 (/ M_PI 4)))
      (set-color {Color name: Draw-Edge-Light})
      (stroke)
      (when selected?
        (cairo_arc context (cast <fl> x) (cast <fl> y) (exact->inexact (/ r 3)) (cast <fl> 0) (* 2 M_PI))
        (set-color {Color name: Black})
        (fill))))
  
  
  (method public (draw-push-button rect <Rect> (pushed? #f))
    (set-line-width 1)
    (if pushed?
        (begin
          (set-color {Color name: Draw-Edge-Dark})
          (line (get-left~ rect) (get-top~ rect) (- (get-right~ rect) 1) (get-top~ rect))
          (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (- (get-bottom~ rect) 1))
          (set-color {Color name: Draw-Edge-Medium})
          (line (+ (get-left~ rect) 1) (+ (get-top~ rect) 1) (- (get-right~ rect) 2) (+ (get-top~ rect) 1))
          (line (+ (get-left~ rect) 1) (+ (get-left~ rect) 1) (+ (get-left~ rect) 1) (- (get-bottom~ rect) 2))
          (set-color {Color name: White})
          (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))
          (line (- (get-right~ rect) 1) (- (get-bottom~ rect) 1) (get-left~ rect) (- (get-bottom~ rect) 1)))
      (set-color {Color name: White})
      (move-to (get-left~ rect) (- (get-bottom~ rect) 1))
      (line-to-no-stroke (get-left~ rect) (get-top~ rect))
      (line-to-no-stroke (- (get-right~ rect) 1) (get-top~ rect))
      (stroke)
      (set-line-width 1)
      (set-color {Color name: Draw-Edge-Dark})
      (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))
      (line (- (get-right~ rect) 1) (- (get-bottom~ rect) 1) (get-left~ rect) (- (get-bottom~ rect) 1))
      (set-color {Color name: Draw-Edge-Medium})
      (line (- (get-right~ rect) 2) (+ (get-top~ rect) 1) (- (get-right~ rect) 2) (- (get-bottom~ rect) 1))
      (line (- (get-right~ rect) 2) (- (get-bottom~ rect) 2) (+ (get-left~ rect) 1) (- (get-bottom~ rect) 2))))
     
   
  ;;;
  ;;;; Bliting
  ;;;
  
  
  (method public (bit-blit dest-dc <Surface>
                           (position: position {Point 0 0})
                           (size: size 'tofix)
                           (destination: destination {Point 0 0})
                           (destination-size: destination-size {}))
    (let ((dest-context (get-context~ dest-dc)))
      (cairo_set_source_surface dest-context (get-surface) (cast <fl> (get-h~ destination)) (cast <fl> (get-v~ destination)))
      (paint~ dest-dc)))
  
  
  ;;;
  ;;;; Select Object
  ;;;
  
  
  (method public (set-font font <Font>)
    (cairo_set_scaled_font context (get-scaled-font~ font)))
  
  
  (method public (set-pen pen <Pen>)
    (if (eq? (get-style~ pen) 'alternate)
        (cairo_set_alternate context)
      (cairo_set_solid context))
    (set-line-width (get-width~ pen))
    (set-color (get-color~ pen)))
  
  
  (method public (draw-edge rect <Rect> (edges: edges 'rectangle) (inner: inner {}) (outer: outer {}))
    (let ((edges (if (eq? edges 'rectangle) '(left right top bottom) edges)))
      (set-line-width 1)
      (when (memq? 'top edges)
        (cond ((eq? inner 'raised)
               (set-color {Color name: White})
               (if outer                
                   (line (get-left~ rect) (+ (get-top~ rect) 1) (get-right~ rect) (+ (get-top~ rect) 1))
                 (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect))))
              ((eq? inner 'sunken)
               (set-color {Color name: Draw-Edge-Dark})
               (if outer                
                   (line (get-left~ rect) (+ (get-top~ rect) 1) (get-right~ rect) (+ (get-top~ rect) 1))
                 (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect))))))
      (when (memq? 'left edges)
        (cond ((eq? inner 'raised)
               (set-color {Color name: White})
               (if outer                
                   (line (+ (get-left~ rect) 1) (get-top~ rect) (+ (get-left~ rect) 1) (get-bottom~ rect))
                 (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect))))
              ((eq? inner 'sunken)
               (set-color {Color name: Draw-Edge-Dark})
               (if outer                
                   (line (+ (get-left~ rect) 1) (get-top~ rect) (+ (get-left~ rect) 1) (get-bottom~ rect))
                 (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect))))))
      (when (memq? 'right edges)
        (cond ((eq? inner 'raised)
               (set-color {Color name: Draw-Edge-Medium})
               (if outer                
                   (line (- (get-right~ rect) 2) (get-top~ rect) (- (get-right~ rect) 2) (get-bottom~ rect))
                 (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))))
              ((eq? inner 'sunken)
               (set-color (new Color red: 241 green: 239 blue: 226))
               (if outer               
                   (line (- (get-right~ rect) 2) (get-top~ rect) (- (get-right~ rect) 2) (get-bottom~ rect))
                 (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect))))))
      (when (memq? 'bottom edges)
        (cond ((eq? inner 'raised)
               (set-color {Color name: Draw-Edge-Medium})
               (if outer                
                   (line (get-left~ rect) (- (get-bottom~ rect) 2) (get-right~ rect) (- (get-bottom~ rect) 2))
                 (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1))))
              ((eq? inner 'sunken)
               (set-color {Color name: Draw-Edge-Light})
               (if outer                
                   (line (get-left~ rect) (- (get-bottom~ rect) 2) (get-right~ rect) (- (get-bottom~ rect) 2))
                 (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1))))))
      (when (memq? 'top edges)
        (cond ((eq? outer 'raised)
               (set-color {Color name: Draw-Edge-Light})
               (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color name: Draw-Edge-Medium})
               (line (get-left~ rect) (get-top~ rect) (get-right~ rect) (get-top~ rect)))))
      (when (memq? 'left edges)
        (cond ((eq? outer 'raised)
               (set-color {Color name: Draw-Edge-Light})
               (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color name: Draw-Edge-Medium})
               (line (get-left~ rect) (get-top~ rect) (get-left~ rect) (get-bottom~ rect)))))
      (when (memq? 'right edges)
        (cond ((eq? outer 'raised)
               (set-color {Color name: Draw-Edge-Dark})
               (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect)))
              ((eq? outer 'sunken)
               (set-color {Color name: White})
               (line (- (get-right~ rect) 1) (get-top~ rect) (- (get-right~ rect) 1) (get-bottom~ rect)))))
      (when (memq? 'bottom edges)
        (cond ((eq? outer 'raised)
               (set-color {Color name: Draw-Edge-Dark})
               (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1)))
              ((eq? outer 'sunken)
               (set-color {Color name: White})
               (line (get-left~ rect) (- (get-bottom~ rect) 1) (get-right~ rect) (- (get-bottom~ rect) 1)))))))
  

  (method public (fill-rect rect <Rect> color)
    (set-color color)
    (draw-rectangle rect)
    (fill))
  
  
  (method public (draw-check h <fx> v <fx>)
    (line (+ h 0) (+ v 2) (+ h 0) (+ v 5))
    (line (+ h 1) (+ v 3) (+ h 1) (+ v 6))
    (line (+ h 2) (+ v 4) (+ h 2) (+ v 7))
    (line (+ h 3) (+ v 3) (+ h 3) (+ v 6))
    (line (+ h 4) (+ v 2) (+ h 4) (+ v 5))
    (line (+ h 5) (+ v 1) (+ h 5) (+ v 4))
    (line (+ h 6) (+ v 0) (+ h 6) (+ v 3))
    (stroke))
  
  
  (method public (draw-raised rect <Rect>)
    (set-pen (new Pen color: {Color name: Light-Background}))
    (move-to (get-left~ rect) (- (get-bottom~ rect) 1))
    (line-to-no-stroke (get-left~ rect) (get-top~ rect))
    (line-to-no-stroke (- (get-right~ rect) 1) (get-top~ rect))
    (stroke)
    (set-pen (new Pen color: {Color name: Dark}))
    (move-to (- (get-right~ rect) 1) (get-top~ rect))
    (line-to-no-stroke (- (get-right~ rect) 1) (- (get-bottom~ rect) 1))
    (line-to (get-left~ rect) (- (get-bottom~ rect) 1)))
  
  
  (method public (draw-arrow-tip h <fx> v <fx> size direction)
    (set-line-width 1)
    (case direction
      ((up)
       (let ((width (- (+ size size) 1)))
         (increase! v (- size 1))
         (for-each (function (n)
                     (line h v (+ h width) v)
                     (increase! h)
                     (decrease! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((down)
       (let ((width (- (+ size size) 1)))
         (for-each (function (n)
                     (line h v (+ h width) v)
                     (increase! h)
                     (increase! v)
                     (decrease! width 2))
                   (naturals 0 size))))
      ((left)
       (let ((height (- (+ size size) 1)))
         (increase! h (- size 1))
         (for-each (function (n)
                     (line h v h (+ v height))
                     (decrease! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))
      ((right)
       (let ((height (- (+ size size) 1)))
         (for-each (function (n)
                     (line h v h (+ v height))
                     (increase! h)
                     (increase! v)
                     (decrease! height 2))
                   (naturals 0 size))))))
  
  
  ;;;
  ;;;; Printing
  ;;;
  
  
  (cond-expand
    (windows
      (method public (start-doc rec)
        (StartDoc (cairo_win32_surface_get_dc surface) rec))
  
  
      (method public (end-doc)
        (EndDoc (cairo_win32_surface_get_dc surface)))
  
  
      (method public (start-page)
        (StartPage (cairo_win32_surface_get_dc surface)))
  
  
      (method public (end-page)
        (EndPage (cairo_win32_surface_get_dc surface))))
    (else))
  
  
  (method (with-outside/inside outside inside outside-proc inside-proc)
    (when inside
      (inside-proc)
      (set-color (if (is? inside Color)
                     inside
                   (get-color-for-object inside)))
      (fill))
    (when outside
      (outside-proc)
      (set-color (if (is? outside Color)
                     outside
                   (get-color-for-object outside)))
      (set-line-width (if (and (is? outside Pen) (get-width~ outside))
                          (get-width~ outside)
                        1))
      (stroke-preserve)))
  
  
  (method public (frame-rect rect <Rect> color)
    (set-line-width 1)
    (set-color color)
    (draw-rectangle
      (new Rect 
        (+ (get-left~ rect) 0.5)
        (+ (get-top~ rect) 0.5)
        (- (get-right~ rect) 0.5)
        (- (get-bottom~ rect) 0.5)))
    (stroke))
  
  
  (method public (rectangle rect <Rect> outside inside)
    (with-outside/inside outside inside
      (function ()
        (draw-rectangle (inflate-rect rect -0.5 -0.5)))
      (function ()
        (draw-rectangle rect))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method public (get-color-for-object object)
    (when (is? object Pen)
      (let ((color (get-color~ object)))
        (if (not color)
            (dispatch Color (get-name~ object))
          color))))
  
  
  ;;;
  ;;;; Primitives
  ;;;
  
  
  (method public (cairo-move-to h <fl> v <fl>)
    (cairo_move_to context h v))
  
  
  (method public (cairo-line-to h <fl> v <fl>)
    (cairo_line_to context h v))
  
  
  (method public (arc hc vc radius angle1 angle2)
    (cairo_arc context (cast <fl> hc) (cast <fl> vc) (cast <fl> radius) (cast <fl> angle1) (cast <fl> angle2)))
  
  
  (method public (curve-to-relative dx1 dy1 dx2 dy2 dx3 dy3)
    (cairo_rel_curve_to context (cast <fl> dx1) (cast <fl> dy1) (cast <fl> dx2) (cast <fl> dy2) (cast <fl> dx3) (cast <fl> dy3)))
  
  
  (method public (close-path)
    (cairo_close_path context))
  
  
  (method public (create-linear-pattern sh sv eh ev)
    (cairo_pattern_create_linear (cast <fl> sh) (cast <fl> sv) (cast <fl> eh) (cast <fl> ev)))
  
  
  (method public (set-source pattern)
    (cairo_set_source context pattern))
  
  
  (method public (scale sh sv)
    (cairo_scale context (exact->inexact sh) (exact->inexact sv)))
  
  
  ;;;
  ;;;; Cairo Primitives
  ;;;
  
  
  (method public (move-to h <fl> v <fl>)
    (cairo_move_to context h v))
  
  
  (method public (line-to h <fl> v <fl>)
    (line-to-no-stroke h v)
    (stroke))
  
  
  (method public (line-to-preserve h <fl> v <fl>)
    (line-to-no-stroke h v)
    (stroke-preserve))
  

  (method public (line-to-no-stroke h <fl> v <fl>)
    (let* ((pt (cairo_current_point context))
           (cur-h (get-h~ pt))
           (cur-v (get-v~ pt)))
      (let ((h (if (= cur-h h)
                   (begin
                     (move-to (+ cur-h 0.5) cur-v) 
                     (+ h 0.5))
                 h))
            (v (if (= cur-v v)
                   (begin
                     (move-to cur-h (+ cur-v 0.5))
                     (+ v 0.5))
                 v)))
        (cairo_line_to context h v))))
  
  
  (method public (line-to-rel dh <fl> dv <fl>)
    (cairo_rel_line_to context dh dv))
  
  
  (method public (move-to-rel dh <fl> dv <fl>)
    (cairo_rel_move_to context dh dv))
  
  
  (method public (line h <fl> v <fl> dest-h <fl> dest-v <fl>)
    (move-to h v)
    (line-to dest-h dest-v))
  
  
  (method public (pixel-to h <fl> v <fl>)
    (move-to h v)
    (line-to (+ h 1) v))
  
  
  (method public (set-line-width w <fl>)
    (cairo_set_line_width context w))
  
  
  (method public (get-line-width)
    (cairo_get_line_width context))
  
  
  (method public (stroke)
    (cairo_stroke context))
  
  
  (method public (stroke-preserve)
    (cairo_stroke_preserve context))
  
  
  (method public (fill)
    (cairo_fill context))
  
  
  (method public (fill-preserve)
    (cairo_fill_preserve context))
    
  
  (method public (paint)
    (cairo_paint context))

  
  (method public (draw-rectangle rect <Rect>)
    (let ((x (get-left~ rect))
          (y (get-top~ rect))
          (w (- (get-right~ rect) (get-left~ rect)))
          (h (- (get-bottom~ rect) (get-top~ rect))))
      (cairo_rectangle context
                       (cast <fl> x)
                       (cast <fl> y)
                       (cast <fl> w)
                       (cast <fl> h))))
  
  
  (method public (set-color color <Color>)
    (let ((r (exact->inexact (/ (get-red~ color) 255.0)))
          (g (exact->inexact (/ (get-green~ color) 255.0)))
          (b (exact->inexact (/ (get-blue~ color) 255.0)))
          (a (get-alpha~ color)))
      (if (not a)
          (cairo_set_source_rgb context r g b)
        (cairo_set_source_rgba context r g b a))))
  
  
  (method (add-color-stop pattern offset color)
    (let ((r (/ (get-red~ color) 255))
          (g (/ (get-green~ color) 255))
          (b (/ (get-blue~ color) 255))
          (a (get-alpha~ color)))
      (if (not a)
          (cairo_pattern_add_color_stop_rgb pattern (exact->inexact offset) (exact->inexact r) (exact->inexact g) (exact->inexact b))
        (cairo_pattern_add_color_stop_rgba pattern (exact->inexact offset) (exact->inexact r) (exact->inexact g) (exact->inexact b) (exact->inexact a)))))
  
  
  (method public (export-to-png file)
    (cairo_surface_write_to_png surface (parse~ file)))
  

  (method public (cairo-status)
    (cairo_status context))
  
  
  (method public (cairo-surface-status)
    (cairo_surface_status surface))
  
  
  (proclaim (not optimize))))
