;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Exploring Text
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.text.Text-Explorer jazz


(import (jazz.library)
        (jazz.ui)
        (jazz.utilities))


(proclaim (optimize))


(class Text-Explorer extends Explorer


  (slot text       <Text-View>)
  (slot paragraphs <Axis>)
  (slot limit      <fx>)
  (slot beginning  <Cell>)
  (slot ending     <Cell>)
  (slot start      <Cell>    initialize (new Cell 0 0))
  (slot end        <Cell>    initialize (new Cell 0 0))
  (slot kind       <symbol+> initialize {})
  
  
  (method (initialize txt (direction: direction 'forward) (start: start {}) (end: end {}) (range: range {}))
    (nextmethod)
    (set! text txt)
    (set! paragraphs (get-paragraphs~ text))
    (set! limit (get-limit~ text))
    (set! beginning (text-beginning~ text))
    (set! ending (text-ending~ text))
    (set-direction direction)
    (if range
        (set-range range)
      (when (or start end)
        (set-start (or start end))
        (set-end (or end start)))))
  
  
  (method protected virtual (get-syntax)
    )


  ;;;
  ;;;; Accessors
  ;;;


  (method (goto-beginning) <void>
    (set-start beginning))


  (method (goto-ending) <void>
    (set-end ending))


  (method public (at-beginning?) <bool>
    (<= start beginning))


  (method public (at-ending?) <bool>
    (>= end ending))


  (method public (get-start) <Cell>
    (copy start))


  (method public (set-start pos <Cell>) <void>
    (set-row~ start (get-row~ pos))
    (set-col~ start (get-col~ pos)))


  (method public (get-end) <Cell>
    (copy end))


  (method public (set-end pos <Cell>) <void>
    (set-row~ end (get-row~ pos))
    (set-col~ end (get-col~ pos)))


  (method public (get-range) <Range$Cell$>
    (new Range$Cell$ (copy start) (copy end)))


  (method public (set-range range <Range$Cell$>) <void>
    (set-start (get-start~ range))
    (set-end (get-end~ range)))
  
  
  (method public (set-pos pos <Cell+>) <void>
    (set-start pos)
    (set-end pos))


  ;;;
  ;;;; Mark
  ;;;


  (method public inline (get-kind) <symbol>
    kind)


  (method protected inline (set-kind knd <symbol+>) <void>
    (set! kind knd))
  

  (method inline (get-paragraph n <fx>) <Paragraph>
    (element paragraphs n))


  (method inline (paragraph-string n <fx>) <string>
    (get-string~ (get-paragraph n)))


  (method inline (paragraph-length n <fx>) <fx>
    (cardinality (paragraph-string n)))

  
  (method inline (get-inside-char pos <Cell>) <char>
    (if (< (get-col~ pos) (paragraph-length (get-row~ pos)))
        (get-char~ text pos)
      #\newline))
  
  
  (method (get-char pos <Cell>) <char+>
    (when (in-text? pos)
      (get-inside-char pos)))


  (method public (get-range-string start <Cell> end <Cell>) <string>
    (get-string~ text (new Range$Cell$ start end)))
  
  
  (method public (get-marked) <string>
    (get-range-string start end))
  
  
  ;; a quicky for now: will skip the quote in front of a symbol
  ;; the right thing would probably for backward-expr not to include the quote
  (method public (get-symbol-string) <string>
    (if (eqv? (get-inside-char start) #\quote)
        (get-range-string (+ start 1) end)
      (get-marked)))
  
  
  (method public (find-marked-symbol) <symbol+>
    (find-symbol (get-marked)))
  
  
  (method public (intern-marked-symbol) <symbol>
    (string->symbol (get-marked)))


  (method public (get-range-symbol start end) <symbol+>
    (find-symbol (get-range-string start end)))
  
  
  (method public (get-mark)
    (new Explorer-Mark (get-kind) (get-range)))


  ;;;
  ;;;; Moving
  ;;;


  (method (next! pos <Cell>) <bool>
    (cond ((< (get-col~ pos) (paragraph-length (get-row~ pos)))
           (increase-col~ pos)
           #t)
          ((< (get-row~ pos) limit)
           (increase-row~ pos)
           (set-col~ pos 0)
           #t)
          (else
           #f)))


  (method (previous! pos <Cell>) <bool>
    (cond ((> (get-col~ pos) 0)
           (increase-col~ pos -1)
           #t)
          ((> (get-row~ pos) 0)
           (increase-row~ pos -1)
           (set-col~ pos (paragraph-length (get-row~ pos)))
           #t)
          (else
           #f)))


  (method (next-cell! pos <Cell>)
    (when (next! pos)
      pos))


  (method (previous-cell! pos <Cell>)
    (when (previous! pos)
      pos))
  

  (method (next-pos pos <Cell> offset <fx>) <Cell>
    (next~ text pos offset))


  (method (previous-pos pos <Cell> offset <fx>) <Cell>
    (previous~ text pos offset))

  
  (method (forward)
    (next! end))
  
  
  (method (backward)
    (previous! start))
  
  
  (method public (char-forward offset <fx>) <char+>
    (next-char end offset))
  
  
  (method public (next-char pos <Cell> offset <fx>) <char+>
    (let ((pos (next-pos pos offset)))
      (when (and pos (next-in-text? pos))
        (get-inside-char pos))))
  
  
  (method public (char-backward offset <fx>) <char+>
    (previous-char start offset))
  

  (method public (previous-char pos <Cell> offset <fx>) <char+>
    (let ((pos (previous-pos pos (+ offset 1))))
      (when pos
        (get-inside-char pos))))
  
  
  (method (in-text? pos <Cell>) <bool>
    (let ((row (get-row~ pos))
          (col (get-col~ pos)))
      (and (>= row 0) (>= col 0) (or (< row limit) (and (= row limit) (<= col (paragraph-length row)))))))
  
  
  (method (next-in-text? pos <Cell>) <bool>
    (let ((row (get-row~ pos))
          (col (get-col~ pos)))
      (if (< row limit)
          (in-text? pos)
        (and (= row limit) (< col (paragraph-length row))))))
  
  
  (method public (forward-while predicate <procedure>)
    (let (iterate)
      (let ((c (char-forward 0)))
        (if (not c)
            #f
          (if (predicate c)
              (if (forward)
                  (iterate)
                #f)
            #t)))))
  
  
  (method public (backward-while predicate <procedure>)
    (let (iterate)
      (let ((c (char-backward 0)))
        (if (not c)
            #f
          (if (predicate c)
              (if (backward)
                  (iterate)
                #f)
            #t)))))
  
  
  (method public (forward-until predicate <procedure>)
    (forward-while (function (c) (not (predicate c)))))
  
  
  (method public (backward-until predicate <procedure>)
    (backward-while (function (c) (not (predicate c)))))
  
  
  (method public (forward-to char)
    (forward-until (function (c) (eqv? c char))))
  
  
  (method public (backward-to char)
    (backward-until (function (c) (eqv? c char))))
  
  
  (method public (forward-whitespaces)
    (forward-while whitespace?))
  
  
  (method public (backward-whitespaces)
    (backward-while whitespace?))


  ;;;
  ;;;; Word
  ;;;
  
  
  (method public (forward-word)
    (let (iterate)
      (let ((c (char-forward 0)))
        (if (or (not c) (not (word-constituent? c)))
            #t
          (forward)
          (iterate)))))
  
  
  (method public (forward-non-word)
    (let (iterate)
      (let ((c (char-forward 0)))
        (if (or (not c) (word-constituent? c))
            #t
          (forward)
          (iterate)))))
  
  
  (method public (backward-word)
    (let (iterate)
      (let ((c (char-backward 0)))
        (if (or (not c) (not (word-constituent? c)))
            #t
          (backward)
          (iterate)))))
  
  
  (method public (backward-non-word)
    (let (iterate)
      (let ((c (char-backward 0)))
        (if (or (not c) (word-constituent? c))
            #t
          (backward)
          (iterate)))))


  (method public virtual (outer-expr . rest)
    (forward-word)
    (backward-word))


  ;;;
  ;;;; Paragraph
  ;;;


  (method public (paragraph-start)
    (set-col~ start 0))
  
  
  (method public (paragraph-end)
    (set-col~ end (paragraph-length (get-row~ end))))


  (method public (previous-paragraph)
    (increase-row~ start -1)
    (set-col~ start 0))


  (method public (next-paragraph)
    (increase-row~ end)
    (set-col~ end 0))
  
  
  (method public (paragraph-column)
    (forward-while (function (c) (eqv? c #\space))))


  ;;;
  ;;;; Style
  ;;;
  
  
  (method public (backward-style target)
    (let (iterate)
      (let ((run (get-run-at~ text start)))
        (when (or (not run) (inherits?~ (get-style~ run) target))
          (when (backward)
            (iterate))))))
  
  
  (method public (forward-style target)
    (let (iterate)
      (let ((next (next-pos end 1)))
        (when next
          (let ((run (get-run-at~ text next)))
            (when (or (not run) (inherits?~ (get-style~ run) target))
              (when (forward)
                (iterate))))))))
  
  
  (method public (select-style target)
    (backward-style target)
    (forward-style target))))
