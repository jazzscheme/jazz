;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Drawable Figures
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.view.Drawing jazz


(import (jazz.library)
        (jazz.literals)
        (jazz.platform.cairo)
        (jazz.ui)
        (jazz.ui.offscreen)
        (jazz.ui.view)
        (jazz.utilities))


(class Drawing extends Figure
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method public virtual (get-player)
    (essay parent (get-player~ parent)))

  
  ;;;
  ;;;; Lie
  ;;;
  
  
  (method public (get-lie) <Point>
    (receive (h <fl> v <fl> sc) (get-lie-parent 0.0 0.0 1.0)
      (new Point (fxround h) (fxround v))))
  
  
  (method protected virtual (get-lie-parent h <fl> v <fl> sc <fl>)
    (if (not parent)
        (values h v sc)
      (get-lie-parent~ parent (+ (get-h~ position) h) (+ (get-v~ position) v) sc)))
  
  
  (method public (set-lie lie <Point>) <void>
    (let* ((actual (get-lie))
           (delta (- lie actual))
           (pos (+ position delta)))
      (set-position pos)))

  
  ;;;
  ;;;; Root
  ;;;
  
  
  ;; ZOO temp virtual
  (method public virtual (get-root) <View>
    (let ((player (get-player)))
      (when player
        (get-root~ player))))

  
  ;;;
  ;;;; Coordinates
  ;;;


  (method public (acquire origin shape)
    (receive (dh dv sc) (get-delta origin)
      (acquire-delta dh dv sc shape)))


  (method public (acquire-delta dh <fl> dv <fl> sc <fl> shape)
    (typecase shape
      ((Point)
       (let ((h <fx> (get-h~ shape))
             (v <fx> (get-v~ shape)))
         (new Point (fxround (+ dh (* h sc)))
                    (fxround (+ dv (* v sc))))))
      ((Rect)
       (let ((left <fx> (get-left~ shape))
             (top <fx> (get-top~ shape))
             (right <fx> (get-right~ shape))
             (bottom <fx> (get-bottom~ shape)))
         (new Rect (fxround (+ dh (* left sc)))
                   (fxround (+ dv (* top sc)))
                   (fxround (+ dh (* right sc)))
                   (fxround (+ dv (* bottom sc))))))
      (else
       (error "Unable to acquire {t}" shape))))
  
  
  (method protected virtual (get-delta origin <Drawing>)
    (receive (origin-h <fl> origin-v <fl> origin-sc <fl>) (get-lie-parent~ origin 0.0 0.0 1.0)
      (receive (dh <fl> dv <fl> sc <fl>) (get-lie-parent 0.0 0.0 1.0)
        (values (/ (- origin-h dh) sc) (/ (- origin-v dv) sc) (/ origin-sc sc)))))

  
  ;;;
  ;;;; Size
  ;;;


  (method (get-size)
    size)
  

  (method (set-size sz <Dimension>)
    (when (/= sz size)
      (set! size sz)
      (invalidate-layout)
      (when (get-finished?)
        (call-layout))))
  
  
  (method public virtual (set-size-noevent sz <Dimension>)
    (set! size sz))
  

  (method public (get-width) <fx>
    (get-width~ size))
  
  
  (method public (set-width width <fx>) <void>
    (set-size (new Dimension width (get-height))))


  (method public (get-height) <fx>
    (get-height~ size))
  
  
  (method public (set-height height <fx>)
    (set-size (new Dimension (get-width) height)))
  
  
  (method public (set-height-noevent height <fx>)
    (set-size-noevent (new Dimension (get-width) height)))
  
  
  (method public (get-left) <fx>
    (get-h~ position))
  
  
  (method public (get-top) <fx>
    (get-v~ position))
  
  
  (method public (get-right) <fx>
    (+ (get-h~ position) (get-width~ size)))
  
  
  (method public (get-bottom) <fx>
    (+ (get-v~ position) (get-height~ size)))

  
  (method public (get-bounds) <Rect>
    (size-rect (get-size)))
  
  
  (method public (set-bounds bounds <Rect>) <void>
    (set-position (rect-position bounds))
    (set-size (rect-size bounds)))
  
  
  (method public (grow-bounds dh dv dwidth dheight)
    (let ((pos (+ (get-position) (new Point dh dv)))
          (size (+ (get-size) (new Dimension dwidth dheight))))
      (set-size size)
      (set-position pos)))
  
  
  (method public (get-rect) <Rect>
    (position/size->rect (get-position) (get-size)))
  
  
  (method public (set-rect rect <Rect>) <void>
    (set-position (rect-position rect))
    (set-size (rect-size rect)))

  
  ;;;
  ;;;; Flags
  ;;;
  
  
  (method (get-layout-valid?)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  
  (method (set-layout-valid? flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method public virtual (get-scaled?)
    #f)


  (method public virtual (set-scaled? value)
    )
  

  (method public virtual (get-scaling) <fl>
    1.0)


  (method public virtual (set-scaling value <fl>)
    )


  (method public (logical->device shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function (lh <fx>) (fxround (+ (* (- lh sh) sc) sh))))
                (vert (function (lv <fx>) (fxround (+ (* (- lv sv) sc) sv)))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))


  (method public (device->logical shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function (dh <fx>) (+ (quotient (- dh sh) sc) sh)))
                (vert (function (dv <fx>) (+ (quotient (- dv sv) sc) sv))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))
  
  
  ;; Maybe this method should be optimized out by setting
  ;; scaling info in every child of the scaled drawing...
  (method (scaling-info)
    (let ((drawing self)
          (sh <fx> 0)
          (sv <fx> 0))
      (continuation-capture
        (function (return)
          (while drawing
            (let ((sc? (get-scaled?~ drawing))
                  (sc (get-scaling~ drawing)))
              (if sc?
                  (continuation-return return (values sh sv sc))
                (let ((pos (get-position~ drawing)))
                  (decrease! sh (get-h~ pos))
                  (decrease! sv (get-v~ pos)))
                (set! drawing (get-parent~ drawing)))))
          {}))))

  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (view-visible?)
    (and (get-visible?) (or (not parent) (view-visible?~ parent))))

  
  ;;;
  ;;;; Transparency
  ;;;

  
  (method public virtual (get-transparent?)
    #f)
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method protected (invalidate-layout)
    (set-layout-valid? #f))
  
  
  (method protected (call-layout)
    (unless (get-layout-valid?)
      (layout)
      (set-layout-valid? #t)))
  
  
  (method public (layout-drawing)
    ;; No need to layout if the drawing is not initialized, because
    ;; conclude will call layout once the initialization process is done.
    (when (get-finished?)
      (invalidate-layout)
      (call-layout)))
  
  
  (method public virtual (layout)
    )

  
  ;;;
  ;;;; Iterate
  ;;;
  
  
  (method public (for-each-drawing proc <procedure> (include-invisibles?: include-invisibles? #f))
    (loop (for child in children)
          (when (and (is? child View)
                     (or include-invisibles? (get-visible?~ child)))
            (proc child))))
  
  
  (method public (for-each-drawing-reversed proc <procedure> (include-invisibles?: include-invisibles? #f))
    (for-each-reversed (function (child)
                         (when (and (is? child View)
                                    (or include-invisibles? (get-visible?~ child)))
                           (proc child)))
      children))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-drawing pos <Point> (ignore: ignore {}))
    (when (in-drawing? pos size)
      (either (find-subdrawing pos ignore)
              (unless (get-transparent?)
                self))))
  
  
  (method protected virtual (in-drawing? pos <Point> size <Dimension>)
    (in-size? pos size))
  
  
  (method protected virtual (find-subdrawing pos <Point> ignore)
    (continuation-capture
      (function (return)
        (for-each-drawing-reversed
          (function (view <View>)
            (let ((delta <Point> (- pos (get-position~ view))))
              (let* ((scaled? (get-scaled?~ view))
                     (found (if (not scaled?)
                                (find-drawing~ view delta)
                              (let ((scaling <fl> (get-scaling~ view)))
                                (let ((scaled (new Point
                                                (fxround (/ (get-h~ delta) scaling))
                                                (fxround (/ (get-v~ delta) scaling)))))
                                  (find-drawing~ view scaled))))))
                (when (and found (or (not ignore) (not (memq? found ignore))))
                  (continuation-return return found))))))
        {})))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-drawing)
    (let ((rect (get-rect)))
      (invalidate-rect~ parent rect)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method public (paint surface <Surface> context <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (when (get-visible?)
      (if (not (get-offscreen?))
          (paint-drawing surface context lh lv sh sv sc sc?)
        (let ((offscreen (get-offscreen surface (get-width~ size) (get-height~ size))))
          (setup-clipper~ offscreen (get-clipper~ surface))
          (paint-drawing offscreen context lh lv sh sv sc sc?)
          (bit-blit~ offscreen surface size: size)
          @convert-to-cairo
          (let ((effect (get-effect)))
            (if (not effect)
                (let ((lie (new Point lh lv)))
                  (animate~ effect offscreen surface lie size))
              (set-effect {})))))))
  
  
  (method public (paint-drawing surface <Surface> context <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (let* ((scaled? (get-scaled?))
           (scaling (get-scaling))
           (new-sh (if (not scaled?) sh lh))
           (new-sv (if (not scaled?) sv lv))
           (new-sc (if (not scaled?) sc scaling))
           (new-sc? (if (not scaled?) sc? #t)))
      (with-transform~ surface self lh lv (get-width~ size) (get-height~ size) new-sh new-sv new-sc new-sc?
        (function ()
          (when (let ((lie (new Point lh lv))) (rects-intersect? (get-clipper~ surface) lie size))
            (render surface context lh lv new-sh new-sv new-sc new-sc?))))))

  
  (method public virtual (render surface <Surface> context lh lv sh sv sc sc?)
    (if *debug-paint*
        (draw-placeholder surface)
      (draw-background surface context))
    (draw-content surface context lh lv sh sv sc sc?)
    (draw-children surface context lh lv sh sv sc sc?))

  
  (method public virtual (draw-background surface <Surface> context)
    )
  
  
  (method public virtual (draw-content surface <Surface> context lh lv sh sv sc sc?)
    (draw surface context lh lv))
    
  
  (method public virtual (draw surface <Surface> context lh lv)
    )
  

  (method (draw-placeholder surface)
    (set-color~ surface {Color name: White})
    (paint~ surface)
    (fill-rect~ surface (get-bounds) (cycle-debug-color!)))
  
  
  (method public virtual (draw-children surface <Surface> context lh <fx> lv <fx> sh sv sc sc?)
    (for-each (function (drawing)
                (when (and (is? drawing View)
                           (get-visible?~ drawing))
                  (let ((pos (get-position~ drawing)))
                    (paint~ drawing surface context (+ lh (get-h~ pos)) (+ lv (get-v~ pos)) sh sv sc sc?))))
              children))


  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (get-clipper)
    (get-translated-clipper 0 0))
  
  
  (method protected virtual (get-translated-clipper h v)
    (let* ((b (get-bounds))
           (r (offset-rect b (fxround h) (fxround v))))
      (if (not parent)
          r
        (let ((p (get-translated-clipper~ parent (- h (get-h~ position)) (- v (get-v~ position)))))
          (rect-intersection p r)))))
  
  
  (method public virtual (get-offscreen?)
    #f)
  
  
  (method public virtual (set-offscreen? flag <bool>)
    )


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method public virtual (get-layer)
    {})
  
  
  (method public virtual (set-layer value)
    )


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method public virtual (get-effect)
    {})
  
  
  (method public virtual (set-effect value)
    )))
