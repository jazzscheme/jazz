;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Utilities
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2008
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.utilities jazz


(export (jazz.utilities.syntax (phase syntax))
        (jazz.utilities.platform.carbon  (cond carbon))
        (jazz.utilities.platform.windows (cond windows))
        (jazz.utilities.platform.x11     (cond x11)))


(import (jazz.utilities.platform.carbon  (cond carbon))
        (jazz.utilities.platform.windows (cond windows))
        (jazz.utilities.platform.x11     (cond x11))
        (jazz.io)
        (jazz.library)
        (jazz.platform)
        (jazz.ui)
        (time))


;;;
;;;; Actions
;;;


(definition public (find-actions context)
  (child~ (get-bindings~ (get-application)) context))


(definition public (find-action-item context name)
  (find-component~ (find-actions context) name))


(definition public (require-action-item action)
  (either (find-action-item (get-action-context~ action) (get-action-name~ action))
          (error "Unable to find action: {t}" action)))


(definition public (call-action action sender properties (event: event {}))
  (let ((action-item (require-action-item action)))
    (invoke~ action-item sender properties action: action event: event)))


(definition public (get-action-enabled? action)
  (let ((action-item (require-action-item action)))
    (get-enabled?~ action-item)))


(definition public (set-action-enabled? action enabled?)
  (let ((action-item (require-action-item action)))
    (set-enabled?~ action-item enabled?)))


(definition public (set-actions-enabled? actions enabled?)
  (for-each (function (action)
              (set-action-enabled? action enabled?))
            actions))


;;;
;;;; Constants
;;;


(definition public Pi
  3.14159)


;;;
;;;; Lines
;;;


(definition public (split-lines string)
  (call-with-input-string string
    read-lines))


(definition public (join-lines lines)
  (join lines "\n"))


;;;
;;;; Class
;;;


(definition public (for-each-definition model definition proc)
  (unimplemented 'for-each-definition)
  @field-creator
  (letrec ((process
             (function (model)
               (when model
                 (let ((definition (category-field model definition)))
                   (when definition
                         (proc definition)
                         (process (type-ascendant (field-creator definition)))))))))
    (process model)))


;;;
;;;; Descriptors
;;;


;; I think that all this is a bit of a kludge... because there will always be only one
;; instance of a class descriptor for any class, using forms and instantiating them seems
;; a bit overkill. On the other hand it could enable a subclass to modify its inherited
;; descriptor! Note that this paragraph also applies to class actions...


(definition public Class-Descriptors
  (make-table test: eq?))


(definition public (get-descriptor model)
  (let ((name (type-name model)))
    (either (table-ref Class-Descriptors name #f)
            (let ((form (get-class-descriptor~ model)))
              (when form
                (let ((descriptor (instantiate~ form)))
                  (set-name~ descriptor name)
                  (table-set! Class-Descriptors name descriptor)
                  descriptor))))))


(definition public (get-properties-descriptor model)
  (let ((class-descriptor (get-descriptor model)))
    (when class-descriptor
      (find-component~ class-descriptor 'properties))))


(definition public (get-property-descriptor model name)
  (let ((properties-descriptor (get-properties-descriptor model)))
    (when properties-descriptor
      (find-component~ properties-descriptor name))))


;;;
;;;; Debugging
;;;


(definition public (console . rest)
  (console-string (format "{l detail: :describe}" rest)))


(definition public (console-string string (color: color {}))
  (let ((output (console-output-port)))
    (if (not output)
        (terminal-string string)
      (format output "{a}" string)
      @wait-new-console-completion (
      (format output #"\($\)\(color Debug {a}\)\(%\){%}"# string)
      (format output #"\(prompt\){%}"#)
      )
      (force-output output)))
  {})


(definition public debug
  console)


(definition public debug-string
  console-string)


;;;
;;;; Execution
;;;


(definition public (with-execution-context proc (title: title {}) (details: details '()) (reporter: reporter {}))
  (proc)
  ;; to convert
  @unimp
  (with-closed ((context (new Execution-Context title: title details: details reporter: reporter)))
    (proc)))


(definition public (with-execution-node proc (title: title {}) (details: details '()) (reporter: reporter {}))
  (proc)
  ;; to convert
  @unimp
  (with-closed ((node (new Execution-Node title: title details: details reporter: reporter)))
    (proc)))


(definition public (get-execution-context)
  (unimplemented 'get-execution-context)
  @active-thread
  (let ((thread (current-thread)))
    (get-active-context~ thread)))


(definition public (get-execution-stack)
  (unimplemented 'get-execution-stack)
  @active-thread
  (let* ((thread (current-thread))
         (node (get-active-node~ thread))
         (lst '()))
    (while node
      (set! lst (cons node lst))
      (set! node (essay (is-not? node Execution-Context) (get-previous-node~ node))))
    lst))

@unimplemented
(class Execution-Node extends Object
  
  
  (slot title)
  (slot details)
  (slot reporter)
  (slot previous-node)
  
  
  (definition (initialize (title: title {}) (details: details '()) (reporter: reporter {}))
    (nextmethod)
    (set! title~self title)
    (set! details~self details)
    (set! reporter~self reporter)
    (let ((thread (current-thread)))
      (set! previous-node~self (get-active-node~ thread))
      (set-active-node~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (current-thread)))
      (set-active-node~ thread previous-node))
    (nextmethod))
  
  
  (definition public (get-title)
    title)
  
  
  (definition public (get-details)
    details)
  
  
  (definition public (get-reporter)
    reporter))

@unimplemented
(class Execution-Context extends Execution-Node
  
  
  (slot previous-context)
  (slot continuable?     initialize #f)
  (slot auto-continue?   initialize #f)
  
  
  (definition (initialize . rest)
    (apply nextmethod rest)
    (let ((thread (current-thread)))
      (set! previous-context~self (get-active-context~ thread))
      (set-active-context~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (current-thread)))
      (set-active-context~ thread previous-context))
    (nextmethod))
  
  
  (definition public (get-continuable?)
    continuable?)
  
  
  (definition public (set-continuable? value)
    (set! continuable? value))
  
  
  (definition public (get-auto-continue?)
    auto-continue?)
  
  
  (definition public (set-auto-continue? value)
    (set! auto-continue? value)))


;;;
;;;; Continue
;;;


@convert
(definition public (with-continue proc)    
  (unimplemented 'with-continue)
  @call-cc?
  (let ((context (get-execution-context)))
    (if (not context)
        (error "Registering a continuable error outside an execution context is not allowed")
      (let ((preserved (get-continuable?~ context)))
        (unwind-protect
            (begin
              (set-continuable?~ context #t)
              (catch Continue
                (proc)))
          (set-continuable?~ context preserved))))))


@convert
(definition public (continuable? exception)
  (unimplemented 'continuable?)
  @call-cc?
  (let ((context (get-execution-context)))
    (and context (get-continuable?~ context))))


@convert
(definition public (continue-exception exception)
  (unimplemented 'continue)
  @call-cc
  (throw (new Continue)))


;;;
;;;; Restart
;;;


@convert
(definition public Restartable?
  #f)


@convert
(definition public (with-restart proc (cleanup {}))
  (unimplemented 'with-restart)
  @call-cc?
  (let ((preserved Restartable?))
    (unwind-protect
        (begin
          (set! Restartable? #t)
          (while #t
            (catch Restart
              (proc)
              (return))
            (when cleanup
              (cleanup))))
      (set! Restartable? preserved))))


@convert
(definition public (restartable? exception)
  Restartable?)


@convert
(definition public (restart (exception {}))
  (unimplemented 'restart)
  @call-cc?
  (throw (new Restart)))


;;;
;;;; Jazz
;;;


(definition public (extract-jazz-file-category file)
  (let ((in/toplevel (extract-jazz-file-toplevel file)))
    (when in/toplevel
      (receive (in toplevel) in/toplevel
        (let ((package (extract-package in))
              (type/name/extends (extract-category toplevel)))
          (when type/name/extends
            (receive (type name extends) type/name/extends
              (values package type name extends))))))))


(definition (extract-jazz-file-toplevel file)
  (unimplemented 'extract-jazz-file-toplevel)
  @convert
  (call-with-input-file (list path: (parse~ file) eol-encoding: 'cr-lf)
    (function (reader)
      (catch (Read-Error err {})
        (let ((in/toplevel (read reader)))
          (if (and (pair? in/toplevel) (eq? (car in/toplevel) 'in))
              (values in/toplevel (read reader))
            (values {} in/toplevel)))))))


(definition (extract-package in)
  (when (pair? (cdr in))
    (let ((package (cadr in)))
      (when (symbol? package)
        package))))


(definition (extract-category toplevel)
  (when (pair? toplevel)
    (let ((type (car toplevel)))
      (when (memq? type '(class interface package))
        (let ((scan (cdr toplevel)))
          (when (pair? scan)
            (let ((name (car scan)))
              (when (symbol? name)
                (if (or (and (eq? type 'class) (eq? name 'Object))
                        (and (eq? type 'interface) (eq? name 'Unknown))
                        (and (eq? type 'package) (eq? name 'Common)))
                    (values type name {})
                  (let ((scan (cdr scan)))
                    (when (and (pair? scan) (eq? (car scan) 'extends))
                      (let ((scan (cdr scan)))
                        (when (pair? scan)
                          (let ((extends (car scan)))
                            (when (symbol? extends)
                              (values type name extends))))))))))))))))


;;;
;;;; Component
;;;


(definition public (component-name component)
  (get-name~ component))


;;;
;;;; Dispatch
;;;


(definition public (dispatch? expr)
  (and (symbol? expr)
       (ends-with? (symbol->string expr) "~")))


(definition public (dispatch-string? string)
  (ends-with? string "~"))


(definition public (dispatch->name dispatch)
  (let ((extract
          (function (string)
            (subseq string 0 (- (cardinality string) 1)))))
    (if (string? dispatch)
        (extract dispatch)
      (string->symbol (extract (symbol->string dispatch))))))


;;;
;;;; Form
;;;


(definition (form-name form)
  (get-name~ form))


;;;
;;;; JML
;;;


(definition public (tag? expr)
  (and (symbol? expr)
       (tag-string? (symbol->string expr))))


(definition public (tag-string? string)
  (and (> (string-length string) 2)
       (starts-with? string "<")
       (ends-with? string ">")))


(definition public (tag->name tag)
  (let ((extract
          (function (string <string>)
            (subseq string 1 (- (cardinality string) 1)))))
    (if (string? tag)
        (extract tag)
      (string->symbol (extract (symbol->string tag))))))


(definition public (name->tag name)
  (string->symbol (string-append "<" (symbol->string name) ">")))


(definition public (jml-keyword? expr)
  (keyword? expr))


;;;
;;;; Logging
;;;


(definition public Logs
  (new List-Factory))


(definition public (get-logs)
  (get-list~ Logs))

@unimplemented
(definition public Add-Log-Lock
  (new Lock))


(definition public (add-log log)
  (unimplemented 'add-log)
  @Mutex?
  (synchronize Add-Log-Lock
    (unless (memq? log (get-logs))
      (put~ Logs log))))


(definition public (current-log)
  (either (get-current-log)
          (let ((log (default-log)))
            (set-current-log log)
            (add-log log)
            log)))


(definition (default-log)
  (unimplemented 'default-log)
  @Logs
  (new Log name: "Default"))


(definition public (get-current-log)
  (unimplemented 'get-current-log)
  @Parameters
  (get-parameter 'current-log))


(definition public (set-current-log log)
  (unimplemented 'set-current-log)
  @Parameters
  (set-parameter 'current-log log))


(definition public (with-log log proc (name: name {}) (file: file {}))
  (unimplemented 'with-log)
  @unwind-protect
  (let ((preserved (get-current-log)))
    (unwind-protect
        (begin
          (set-current-log log)
          (proc))
      (set-current-log preserved))
    (let ((name (get-name~ log)))
      (when (and name (not file))
        (add-log log)))))


(definition public (with-node proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (let ((node (either node (new-entry~ log tag name message data))))
    (with-node~ log node proc)))


(definition public (log-node node (log: log (current-log)))
  (log-node~ log node))


(definition public (log-entry (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (log-entry~ log tag name message data))


(definition public (log-properties properties (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (let ((printer (open-output-string))
        (first? #t))
    (for-each-property (function (property value)
                         (if first?
                             (set! first? #f)
                           (format printer ", "))
                         (format printer "{a}: {a}" (keyword->symbol property) value))
      properties)
    (let ((message (get-output-string printer)))
      (log-entry tag: tag name: name message: message data: data log: log))))


(definition public (new-log-node (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (new-entry~ log tag name message data))


;;;
;;;; Profiling
;;;


(definition public (with-profile proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (unimplemented 'with-profile)
  @Profiling-later
  (with-node
    (function (node)
      (let ((result))
        (log-profile name: 'before log: log)
        ;; this is ugly but necessary not to change stack depth
        (set! result (proc node))
        (log-profile name: 'after log: log)
        result))
    node: (either node (new-entry~ log tag name message data))))


(definition public (log-profile (name: name {}) (log: log (current-log)))
  (unimplemented 'log-profile)
  @Profiling-later (
  (gc)
  (log-node (resources-snapshot~ Performance name: name) log: log)))


(definition public (log-stack (tag: tag {}) (name: name {}) (message: message {}) (log: log (current-log)))
  (unimplemented 'log-stack)
  @later
  (let ((data (new Stack-Snapshot)))
    (log-entry tag: tag name: name message: message data: data log: log)))


(definition public (profiles->jml profiles)
  (unimplemented 'profiles->jml)
  @later
  (let ((nodes '()))
    (iterate-table (get-profiles)
      (function (name profile)
        (when (not (profile-parent profile))
          (set! nodes (cons (profile->jml {} profile) nodes)))))
    (sort < nodes key: (function (node) (get-property~ node 'name)))))


(definition (profile->jml parent profile)
  (unimplemented 'profile->jml)
  @later
  (let ((node (profile-content parent profile)))
    (insert-profile-children node profile)
    node))


(definition (profile-content parent profile)
  (unimplemented 'profile-content)
  @later
  (let ((name (profile-name profile))
        (count (profile-count profile 0))
        (total (profile-total profile 0)))
    (new JML-Element parent 'profile properties: (list 'name name 'count count 'total total))))


(definition (insert-profile-children parent profile)
  (unimplemented 'insert-profile-children)
  @later
  (map (function (child)
         (profile->jml parent child))
       (collect-profile-children profile)))


(definition (collect-profile-children profile)
  (unimplemented 'collect-profile-children)
  @later
  (let ((children '())
        (child (profile-last-child profile)))
    (while child
      (set! children (cons child children))
      (set! child (profile-previous-brother child)))
    children))


;;;
;;;; Locales
;;;


(definition public Active-Locales
  '(english:))

(definition public Active-Locale
  english:)


(definition public (get-locales)
  Active-Locales)


(definition public (get-locale)
  Active-Locale)


(definition public (set-locale loc (update?: update? #t))
  (let ((loc (standardize-locale loc)))
    (when (neq? loc Active-Locale)
      (set! Active-Locale loc)
      (let ((appl (get-application)))
        (select-locale~ appl loc)
        (when update?
          (locale-update~ appl))))))


(definition (standardize-locale loc)
  (cond ((keyword? loc) loc)
        ((enumerator? loc) (symbol->keyword (enumerator->symbol loc)))
        ((symbol? loc) (symbol->keyword loc))
        (else (error "Invalid locale: {s}" loc))))


(definition public (localize object)
  (if (is? object Locales)
      (localize~ object Active-Locale)
    object))


(definition public (localize-to object locale)
  (if (is? object Locales)
      (localize~ object locale)
    object))


(definition public (present-locale locale)
  (case locale
    ((english:) "English")))


;;;
;;;; Extension
;;;


(definition public Scheme-Extensions
  '("scm" "sch" "ss" "gambcini" "jazzini"))

(definition public CommonLisp-Extensions
  '("lisp"))

(definition public Jazz-Extensions
  '("jazz" "jcat" "jml" "mnf" "pck" "snapshot"))

(definition public C-Extensions
  '("c" "cpp" "h" "hpp"))

(definition public Textual-Extensions
  '("conf" "css" "erl" "ftx" "htm" "java" "js" "log" "lua" "mnf" "pck" "prop" "properties" "py" "rc" "sh" "sql" "template" "txt"))

(definition public Text-Extensions
  (append Scheme-Extensions
          CommonLisp-Extensions
          Jazz-Extensions
          C-Extensions
          Textual-Extensions))


(definition public (effective-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Extensions)
    ((:commonlisp) CommonLisp-Extensions)
    ((:jazz) Jazz-Extensions)
    ((:c) C-Extensions)
    ((:text) Text-Extensions)
    (else extensions)))


(definition public Scheme-Include-Extensions
  Scheme-Extensions)

(definition public CommonLisp-Include-Extensions
  CommonLisp-Extensions)

(definition public Jazz-Include-Extensions
  (append Scheme-Include-Extensions
          '("jazz" "jml" "mnf" "pck")))

(definition public C-Include-Extensions
  C-Extensions)

(definition public Textual-Include-Extensions
  Textual-Extensions)

(definition public Text-Include-Extensions
  (append Scheme-Include-Extensions
          CommonLisp-Include-Extensions
          Jazz-Include-Extensions
          C-Include-Extensions
          Textual-Include-Extensions))


(definition (effective-include-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Include-Extensions)
    ((:commonlisp) CommonLisp-Include-Extensions)
    ((:jazz) Jazz-Include-Extensions)
    ((:c) C-Include-Extensions)
    ((:text) Text-Include-Extensions)
    (else extensions)))


(definition public Scheme-Catalog-Extensions
  Scheme-Extensions)

(definition public CommonLisp-Catalog-Extensions
  CommonLisp-Extensions)

(definition public Jazz-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          '("jazz")))

(definition public C-Catalog-Extensions
  C-Extensions)

(definition public Textual-Catalog-Extensions
  Textual-Extensions)

(definition public Text-Catalog-Extensions
  (append Scheme-Catalog-Extensions
          CommonLisp-Catalog-Extensions
          Jazz-Catalog-Extensions
          C-Catalog-Extensions
          Textual-Catalog-Extensions))


(definition (effective-catalog-extensions extensions)
  (case extensions
    ((:scheme) Scheme-Catalog-Extensions)
    ((:commonlisp) CommonLisp-Catalog-Extensions)
    ((:jazz) Jazz-Catalog-Extensions)
    ((:c) C-Catalog-Extensions)
    ((:text) Text-Catalog-Extensions)
    (else extensions)))


;;;
;;;; Pathname
;;;


(definition public (make-filename base extension)
  (format "{a}.{a}" base extension))


(definition public (ensure-read/write moniker (cancel-action: cancel-action 'throw))
  @convert
  (let ((file (get-file~ moniker)))
    (if (or (not (exists?~ file)) (read/write?~ file))
        'no-action
      (let* ((appl (get-application))
             (pref (get-depots-preferences~ appl))
             (code (case (message-box (format "File {s} is read-only. Overwrite?" (get-name~ moniker))
                                      title: "File Status"
                                      type: 'question
                                      process-keys?: #f)
                     ((yes) 'set-read/write)
                     ((no) 'cancel))))
        (case code
          ((set-read/write)
           (set-read/write~ file)
           'read/write)
          ((cancel)
           (throw-cancel)))))))


(definition public (convert-extension object from to)
  (unimplemented 'convert-extension)
  @file?
  (cond ((not object) {})
        ((string? object) (convert-name-extension object from to))
        ((pair? object) (convert-path-extension object from to))
        ((file? object) (convert-file-extension object from to))
        ((directory? object) object)
        (else "Unable to convert extension for {t}" object)))


(definition (convert-name-extension name from to)
  (unimplemented 'convert-name-extension)
  @Pathname
  (if (ci=? (extract-extension name) from)
      (make-filename (extract-base name) to)
    name))


(definition (convert-path-extension path from to)
  (unimplemented 'convert-path-extension)
  @Pathname
  (let ((name (last path)))
    (if (ci=? (extract-extension name) from)
        (append (butlast path) (list (convert-name-extension name from to)))
      path)))


(definition (convert-file-extension file from to)
  (if (ci=? (get-extension~ file) from)
      (new-brother~ file (make-filename (get-base~ file) to))
    file))


;;;
;;;; Resource
;;;


(definition public inline (resource? object)
  (is? object Resource))



;;;
;;;; Safety
;;;


(definition public (with-safe-execution title proc (continue-text: continue-text {}) (continue-handler: continue-handler {}))
  (proc)
  @convert-message-box?
  (call-with-catch Error
        (function (err)
          (dump-stack exception: err)
          (let ((invite (format "The following error occured while {a}:" title))
                (message (present-message~ err active-content?: #f))
                (message-box? (message-box?)))
            (let ((text
                    (if (not message-box?)
                        (format "{a}{%}{%}{a}{%}{%}Press Yes to try and continue, No to exit" invite (car message))
                      (append (list invite {})
                              message
                              (if (and continue-handler continue-text)
                                  (append (list {}) continue-text)
                                '())))))
              (if (not continue-handler)
                  (begin
                    (if (not message-box?)
                        (system-message text)
                      (message-box text yes: "Exit"))
                    (exit))
                (case (if (not message-box?)
                          (system-message text type: 'question)
                        (message-box text
                                     type: 'question
                                     yes: "Continue"
                                     no: "Exit"))
                  ((yes) (continue-handler err))
                  ((no) (exit)))))))
      {}
    proc))


;;;
;;;; Various
;;;


(definition public (sleep delay)
  (thread-sleep! delay))


(definition public (warn string . rest)
  (format :console "{%}Warning: ")
  (apply format :console string rest))


(definition public (warn-unimplemented name)
  (format :console "{%}Warning: {a} is unimplemented" name))


(definition public (bits->symbolic bits enumeration)
  (let ((entries (get-entries~ enumeration)))
    (let ((fact (new List-Factory)))
      (for-each (function (entry)
                  (bind (name value) entry
                    (when (mask-bit-set? bits value)
                      (put~ fact name))))
                entries)
      (get-output~ fact))))


(definition public (copy-into! seq1 seq2)
  (for-each (function (element rank)
              (set-element! seq2 rank element))
            seq1
            (naturals 0 (cardinality seq1))))


;;;
;;;; Context
;;;


(definition public (present-context-actions title actions)
  (unimplemented 'present-context-actions)
  @?self?
  (present-context-text title
                        (map (function (action)
                               (let* ((image (get-image~ action))
                                      (title (get-title~ action))
                                      (handler (get-handler~ action))
                                      (action
                                        (function ()
                                          (when handler
                                            (invoke~ handler self {})))))
                                 (list (list image: image) "  " (list :hyperlink action title))))
                             actions)))


(definition public (present-context-text title text)
  (unimplemented 'present-context-text)
  @Context-Text-View
  (let ((text-view (new Context-Text-View)))
    (set-text~ text-view text)
    (list title text-view)))


;;;
;;;; Tabulated
;;;


(definition public (display-tabulated data printer)
  (unimplemented 'display-tabulated)
  @Column-Display-Display-Column
  (let* ((display (new Columns-Display))
         (sample (car data))
         (last (- (length sample) 1))
         (columns (loop (for ignore in sample)
                        (for n from 0)
                        (collect (if (= n last)
                                     (new Display-Column display)
                                   (new Aligned-Column display border-after: 1 alignment: 'left))))))
    (add-columns~ display columns)
    (for-each (function (row)
                (for-each (function (object column)
                            (output~ column (->string object)))
                          row
                          columns)
                (newline~ display))
              data)
    (print-to~ display printer)))


;;;
;;;; Shape
;;;


;; Best way to think of rectangle and intervals is that they are between the pixels.
;; This is consistant with the mathematical definition of an interval [start end) as
;; to enclose the pixels no 0 1 2 3, the lines in between have to go from 0 to 4.


(definition public (size-rect size <Dimension>) <Rect>
  (new Rect 0 0 (get-width~ size) (get-height~ size)))


(definition public (position/size->rect position <Point> size <Dimension>) <Rect>
  (h/v/size->rect (get-h~ position) (get-v~ position) size))


(definition public (h/v/size->rect h <fx> v <fx> size <Dimension>) <Rect>
  (new Rect h v (+ h (get-width~ size)) (+ v (get-height~ size))))


(definition public (h/v/width/height h <fx> v <fx> width <fx> height <fx>) <Rect>
  (new Rect h v (+ h width) (+ v height)))


(definition public (corners->rect top-left <Point> bottom-right <Point>) <Rect>
  (new Rect (get-h~ top-left) (get-v~ top-left) (get-h~ bottom-right) (get-v~ bottom-right)))


(definition public (normalize-rect rect <Rect>) <Rect>
  (let ((l (get-left~ rect))
        (t (get-top~ rect))
        (r (get-right~ rect))
        (b (get-bottom~ rect)))
    (new Rect
      (if (<= l r) l r)
      (if (<= t b) t b)
      (if (<= l r) r l)
      (if (<= t b) b t))))


(definition public (rect-position rect <Rect>) <Point>
  (new Point (get-left~ rect) (get-top~ rect)))


(definition public (rect-size rect <Rect>) <Dimension>
  (new Dimension
    (rect-width rect)
    (rect-height rect)))


(definition public (rect-width rect <Rect>) <fx>
  (- (get-right~ rect) (get-left~ rect)))


(definition public (rect-height rect <Rect>) <fx>
  (- (get-bottom~ rect) (get-top~ rect)))


(definition public (offset-rect rect <Rect> h <fx> v <fx>) <Rect>
  (new Rect
    (+ (get-left~ rect)   h)
    (+ (get-top~ rect)    v)
    (+ (get-right~ rect)  h)
    (+ (get-bottom~ rect) v)))


(definition public (inflate-rect rect <Rect> w <number> h <number>) <Rect>
  (new Rect
    (- (get-left~ rect)   w)
    (- (get-top~ rect)    h)
    (+ (get-right~ rect)  w)
    (+ (get-bottom~ rect) h)))


(specialize (inflate-rect rect <Rect> w <fx> h <fx>) <Rect>
  (new Rect
    (- (get-left~ rect)   w)
    (- (get-top~ rect)    h)
    (+ (get-right~ rect)  w)
    (+ (get-bottom~ rect) h)))


(definition public (expand-rect rect <Rect> l <fx> t <fx> r <fx> b <fx>) <Rect>
  (new Rect
    (+ (get-left~ rect)   l)
    (+ (get-top~ rect)    t)
    (+ (get-right~ rect)  r)
    (+ (get-bottom~ rect) b)))


(definition public (base-rect rect <Rect>) <Rect>
  (offset-rect rect (- (get-left~ rect)) (- (get-top~ rect))))


(definition public (fit-rects src dst mode)
  (let* ((dw (rect-width dst))
         (dh (rect-height dst))
         (sw (rect-width src))
         (sh (rect-height src))
         (rw (/ dw sw))
         (rh (/ dh sh)))
    (case mode
      ((width) rw)
      ((height) rh)
      ((both) (if (> rw rh) rh rw)))))


(definition public (fit-within outer rect (minimum-size: minimum-size {Dimension 0 0}) (padding: padding 0))
  (let* ((size (rect-size rect))
         (position (rect-position rect))
         (width  (max (get-width~ minimum-size)  (min (get-width~ size) (- (get-width~ outer) padding padding))))
         (height (max (get-height~ minimum-size) (min (get-height~ size)(- (get-height~ outer) padding padding))))
         (new-size (new Dimension width height))
         (min-position (new Point padding padding))
         (max-position (new Point (- (get-width~ outer) (get-width~ new-size) padding) (- (get-height~ outer) (get-height~ new-size) padding)))
         (new-position (new Point (between (get-h~ min-position) (get-h~ position) (get-h~ max-position)) (between (get-v~ min-position) (get-v~ position) (get-v~ max-position)))))
    (values new-position new-size)))


(definition public (rect-union x <Rect> y <Rect>) <Rect>
  (new Rect
    (if (< (get-left~ x) (get-left~ y)) (get-left~ x) (get-left~ y))
    (if (< (get-top~ x) (get-top~ y)) (get-top~ x) (get-top~ y))
    (if (> (get-right~ x) (get-right~ y)) (get-right~ x) (get-right~ y))
    (if (> (get-bottom~ x) (get-bottom~ y)) (get-bottom~ x) (get-bottom~ y))))


(definition public (rect-intersection x <Rect> y <Rect>) <Rect>
  (if (rect-intersect? x y)
      (new Rect
        (if (> (get-left~ x) (get-left~ y)) (get-left~ x) (get-left~ y))
        (if (> (get-top~ x) (get-top~ y)) (get-top~ x) (get-top~ y))
        (if (< (get-right~ x) (get-right~ y)) (get-right~ x) (get-right~ y))
        (if (< (get-bottom~ x) (get-bottom~ y)) (get-bottom~ x) (get-bottom~ y)))
    (new Rect 0 0 0 0)))


(definition public (rect-intersect? x <Rect> y <Rect>) <bool>
  (and (< (get-left~ x) (get-right~ y))
       (< (get-top~ x) (get-bottom~ y))
       (> (get-right~ x) (get-left~ y))
       (> (get-bottom~ x) (get-top~ y))))


(definition public (rects-intersect? rect <Rect> position <Point> size <Dimension>) <bool>
  (and (< (get-left~ rect) (+ (get-h~ position) (get-width~ size)))
       (< (get-top~ rect) (+ (get-v~ position) (get-height~ size)))
       (> (get-right~ rect) (get-h~ position))
       (> (get-bottom~ rect) (get-v~ position))))


(definition public (in-rect? pt <Point> rect <Rect>) <bool>
  (and (>= (get-h~ pt) (get-left~ rect))
       (>= (get-v~ pt) (get-top~ rect))
       (<  (get-h~ pt) (get-right~ rect))
       (<  (get-v~ pt) (get-bottom~ rect))))


(definition public (in-size? pt <Point> size <Dimension>) <bool>
  (and (>= (get-h~ pt) 0)
       (>= (get-v~ pt) 0)
       (<  (get-h~ pt) (get-width~ size))
       (<  (get-v~ pt) (get-height~ size))))


(definition public (add-rects r1 <Rect> r2 <Rect>) <Rect>
  (new Rect
    (+ (get-left~ r1) (get-left~ r2))
    (+ (get-top~ r1) (get-top~ r2))
    (+ (get-right~ r1) (get-right~ r2))
    (+ (get-bottom~ r1) (get-bottom~ r2))))


(definition public (subtract-rects r1 <Rect> r2 <Rect>) <Rect>
  (new Rect
    (- (get-left~ r1) (get-left~ r2))
    (- (get-top~ r1) (get-top~ r2))
    (- (get-right~ r1) (get-right~ r2))
    (- (get-bottom~ r1) (get-bottom~ r2))))


(definition public (inverse-rect rect <Rect>) <Rect>
  (new Rect
    (get-top~ rect)
    (get-left~ rect)
    (get-bottom~ rect)
    (get-right~ rect)))


(definition public (positive-rect? rect <Rect>) <bool>
  (and (>= (get-top~ rect) 0)
       (>= (get-left~ rect) 0)
       (>= (get-bottom~ rect) 0)
       (>= (get-right~ rect) 0)))


(definition public (center inner outer)
  (justify inner outer 'center))


(definition public (justify inner outer justification)
  (let ((proc
          (function (i o j)
            (if (integer? j)
                (if (>= j 0)
                    j
                  (+ o j))
              (case j
                ((head) 0)
                ((center) (quotient (- o i) 2))
                ((tail) (- o i))
                (else (error "Unknown justification: {t}" j)))))))
    (cond ((and (is? inner Dimension) (is? outer Dimension))
           (new Point
             (proc (get-width~ inner) (get-width~ outer) (if (pair? justification) (first justification) justification))
             (proc (get-height~ inner) (get-height~ outer) (if (pair? justification) (second justification) justification))))
          ((and (number? inner) (number? outer))
           (proc inner outer justification))
          (else
           (error "Unable to justify a {t} into a {t}"
                  (type-name (class-of inner))
                  (type-name (class-of outer)))))))


(definition public (cycle-naturals cycle subcycle)
  (let* ((fact (new List-Factory))
         (cardinality (* cycle subcycle))
         (inc (quotient cardinality cycle)))
    (loop (for n from 0 below subcycle)
          (do (loop (for m from 0 below cardinality by inc)
                    (do (put~ fact (+ n m))))))
    (get-output~ fact)))


(definition public (fit pos <fx> alternate <fx+> size <fx> max <fx> padding <fx>)
  (cond ((> size max) 0)
        ((<= (+ pos size padding) max) (+ pos padding))
        ((and alternate (<= (+ alternate size padding) max)) (+ alternate padding))
        ((>= (- pos size) 0) (- pos size))
        ((and alternate (>= (- alternate size) 0)) (- alternate size))
        (else (- max size))))


(definition public (fit-point pos <Point> alternate <Point+> size <Dimension> max <Dimension> padding <Dimension>)
  (new Point
    (fit (get-h~ pos) (essay alternate (get-h~ alternate)) (get-width~ size) (get-width~ max) (get-width~ padding))
    (fit (get-v~ pos) (essay alternate (get-v~ alternate)) (get-height~ size) (get-height~ max) (get-height~ padding))))


(definition public (scalar-product a <Point> b <Point>)
  (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))


(definition public (line-distance point <Point> start <Point> end <Point>)
  (let ((divider (sqrt (+ (sqr (- (get-h~ start) (get-h~ end)))
                          (sqr (- (get-v~ start) (get-v~ end)))))))
    (if (= divider 0)
        {}
      (abs
        (/ (scalar-product (new Point (- (get-h~ point) (get-h~ start)) (- (get-v~ point) (get-v~ start)))
                           (new Point (- (get-v~ end) (get-v~ start)) (- (get-h~ start) (get-h~ end))))
           divider)))))


;; For any questions, call Stephane!
;; divide delta into count parts, but since we're doing integer maths...
;; constraints: must be reversible, transitive and commutative
;; reversible: (f w d N) + (f w+d -d N) == no change == all zeroes
;; transitive: (f w a N) + (f w+a b N) == (f w a+b N)
;; 
;; forex: (resize-parts 7 1 3) returns (0 1 0)
;; because 7 is split (3 2 2) while 8 is split (3 3 2)
;;
;; the original definition didn't make this clear, nor does this one
(definition public (resize-parts size delta count)
  (let* ((offset (if (< delta 0) count 0))
         (base (quotient (- delta offset) count))
         (extra (+ (modulo delta count) offset))
         (parity (modulo size count))
         (start (modulo (+ parity count) count))
         (end (+ start extra -1))
         (end2 (- end count)))
    (map (function (n)
           (+ base (if (or (between? n start end) (<= n end2)) 1 0)))
         (naturals 0 count))))


(definition public (scale shape sc)
  (let ((sc (exact->inexact sc)))
    (typecase shape
      ((Point)
       (let ((h <fx> (get-h~ shape))
             (v <fx> (get-v~ shape)))
         (new Point
           (fxround (* h sc))
           (fxround (* v sc)))))
      ((Dimension)
       (let ((width <fx> (get-width~ shape))
             (height <fx> (get-height~ shape)))
         (new Dimension
           (fxround (* width sc))
           (fxround (* height sc)))))
      ((Rect)
       (let ((left <fx> (get-left~ shape))
             (top <fx> (get-top~ shape))
             (right <fx> (get-right~ shape))
             (bottom <fx> (get-bottom~ shape)))
         (new Rect
           (fxround (* left sc))
           (fxround (* top sc))
           (fxround (* right sc))
           (fxround (* bottom sc)))))
      ((Number)
       (fxround (* shape sc))))))


(definition public (scale-factor outer inner)
  (/ outer inner))


(definition public (get-area size)
  (* (get-width~ size) (get-height~ size)))


;;;
;;;; Iterate
;;;


(definition public (iterate-cells top-left bottom-right start direction proc)
  (let* ((next (case direction
                 ((forward) next-cell)
                 ((backward) previous-cell)))
         (advance (function (cell) (next cell top-left bottom-right 'horizontal)))
         (cell (advance (either start (case direction
                                        ((forward) top-left)
                                        ((backward) bottom-right))))))
    (while cell
      (proc cell)
      (set! cell (advance cell)))))


(definition (previous-cell cell min-cell max-cell direction)
  (case direction
    ((vertical) (let ((info (loop-cell (get-col~ cell) (get-row~ cell) (get-col~ max-cell) (get-row~ max-cell) (get-col~ min-cell) (get-row~ min-cell) -1 >)))
                  (when info
                    (receive (major minor) info
                      (new Cell minor major)))))
    ((horizontal) (let ((info (loop-cell (get-row~ cell) (get-col~ cell) (get-row~ max-cell) (get-col~ max-cell) (get-row~ min-cell) (get-col~ min-cell) -1 >)))
                    (when info
                      (receive (major minor) info
                        (new Cell major minor)))))))


(definition (next-cell cell min-cell max-cell direction)
  (case direction
    ((vertical) (let ((info (loop-cell (get-col~ cell) (get-row~ cell) (get-col~ min-cell) (get-row~ min-cell) (get-col~ max-cell) (get-row~ max-cell) 1 <)))
                  (when info
                    (receive (major minor) info
                      (new Cell minor major)))))
    ((horizontal) (let ((info (loop-cell (get-row~ cell) (get-col~ cell) (get-row~ min-cell) (get-col~ min-cell) (get-row~ max-cell) (get-col~ max-cell) 1 <)))
                    (when info
                      (receive (major minor) info
                        (new Cell major minor)))))))


;; caveat: step must be +1 or -1
(definition (loop-cell major minor start-major start-minor end-major end-minor step test)
  (cond ((test major start-major) (values start-major start-minor))
        ((test end-major major) {})
        ((test minor start-minor) (values major start-minor))
        ((test minor end-minor) (values major (+ minor step)))
        ((test major end-major) (values (+ major step) start-minor))
        (else {})))


;;;
;;;; Output
;;;


(definition public (output-header title printer (language: language 'jazz) (system: system {}) (license: license {}) (author: author {}) (copyright: copyright {}) (contributors: contributors '()) (end-proper?: end-proper? #t))
  (with-printer printer
    (function (printer)
      (let* ((system (either system (system-title~ (get-process))))
             (system-padding (make-string (string-length system) #\=))
             (comment (case language ((jazz) ";;;") ((c) "//")))
             (toplevel-comment (case language ((jazz) ";;;;") ((c) "///"))))
        (format printer #"{a}=={a}=={%}"# comment system-padding)
        (format printer #"{a}  {a}{%}"# comment system)
        (format printer #"{a}=={a}=={%}"# comment system-padding)
        (format printer #"{a}{%}"# comment)
        (format printer #"{a} {a}{%}"# toplevel-comment title)
        (format printer #"{a}"# comment)
        (case license
          ((jazzscheme)
           (format printer "{%}")
           (format printer #"{a}  The contents of this file are subject to the Mozilla Public License Version{%}"# comment)
           (format printer #"{a}  1.1 (the "License"); you may not use this file except in compliance with{%}"# comment)
           (format printer #"{a}  the License. You may obtain a copy of the License at{%}"# comment)
           (format printer #"{a}  http://www.mozilla.org/MPL/{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Software distributed under the License is distributed on an "AS IS" basis,{%}"# comment)
           (format printer #"{a}  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License{%}"# comment)
           (format printer #"{a}  for the specific language governing rights and limitations under the{%}"# comment)
           (format printer #"{a}  License.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  The Original Code is JazzScheme.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  The Initial Developer of the Original Code is {a}.{%}"# comment author)
           (format printer #"{a}  Portions created by the Initial Developer are Copyright (C) {a}{%}"# comment copyright)
           (format printer #"{a}  the Initial Developer. All Rights Reserved.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Contributor(s):{%}"# comment)
           (for-each (function (contributor)
                       (format printer #"{a}    {a}{%}"# comment contributor))
                     contributors)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Alternatively, the contents of this file may be used under the terms of{%}"# comment)
           (format printer #"{a}  the GNU General Public License Version 2 or later (the "GPL"), in which{%}"# comment)
           (format printer #"{a}  case the provisions of the GPL are applicable instead of those above. If{%}"# comment)
           (format printer #"{a}  you wish to allow use of your version of this file only under the terms of{%}"# comment)
           (format printer #"{a}  the GPL, and not to allow others to use your version of this file under the{%}"# comment)
           (format printer #"{a}  terms of the MPL, indicate your decision by deleting the provisions above{%}"# comment)
           (format printer #"{a}  and replace them with the notice and other provisions required by the GPL.{%}"# comment)
           (format printer #"{a}  If you do not delete the provisions above, a recipient may use your version{%}"# comment)
           (format printer #"{a}  of this file under the terms of any one of the MPL or the GPL.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  See www.jazzscheme.org for details."# comment)))
        (when end-proper?
          (format printer "{%}"))))))


(definition public (output-section title printer (language: language 'jazz) (level: level 0))
  (let ((comment (case language ((jazz) ";;;") ((c) "//")))
        (toplevel (case language ((jazz) ";;;;") ((c) "///")))
        (extra (case language ((jazz) "") ((c) (make-string (+ (string-length title) 4) #\-)))))
    (format printer "{%}{%}")
    (format printer "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format printer "{_ :v}{a} {a}{%}" (* level 2) toplevel title)
    (format printer "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format printer "{%}{%}")))


;;;
;;;; Arguments
;;;


(definition public (require-argument key)
  (unimplemented 'require-argument)
  @command-argument
  (either (command-argument key)
          (error "Mandatory argument /{a} was not found in command line:{%}{a}" key (command-line))))


(definition public (argument/property arg prop)
  (unimplemented 'argument/property)
  @command-argument
  (either (command-argument arg)
          (get-setting prop)))


(definition public (require-argument/property arg prop)
  (unimplemented 'require-argument/property)
  @command-line
  (either (argument/property arg prop)
          (error "Mandatory argument /{a} was not found on command line or in properties:{%}{a}" arg (command-line))))


(definition public (boolean-argument/property arg prop default)
  (let ((value (argument/property arg prop)))
    (if (not value)
        default
      value)))


(definition public (integer-argument/property arg prop)
  (let ((str/int (argument/property arg prop)))
    (when str/int
      (if (integer? str/int)
          str/int
        (parse-integer str/int)))))


(definition public (file-argument/property arg prop extension)
  (let ((str (argument/property arg prop)))
    (when str
      (make-file str arg extension))))


(definition public (require-file-argument/property arg prop extension)
  (make-file (require-argument/property arg prop) arg extension))


(definition (make-file str arg extension)
  (unimplemented 'make-file)
  @Pathname
  (let ((file (new File (tokenise-filename str))))
    (if (/= (get-extension~ file) extension)
        (error "Argument /{a} is not of the expected .{a} type in command line:{%}{a}" arg extension (command-line))
      file)))


(definition public (directory-argument/property arg prop)
  (let ((str (argument/property arg prop)))
    (when str
      (make-directory str))))


(definition public (require-directory-argument/property arg prop)
  (make-directory (require-argument/property arg prop)))


(definition (make-directory str)
  (unimplemented 'make-directory)
  @Pathname
  (new Directory (tokenise-filename str)))


(definition public (host-argument/property arg prop)
  (unimplemented 'host-argument/property)
  @Host
  (let ((name (argument/property arg prop)))
    (when name
      (new Host name: name))))


(definition public (port-argument/property arg prop)
  (argument/property arg prop))


;;;
;;;; Preferences
;;;


(definition public (get-preferences name (error?: error? #t))
  (let* ((process (get-process))
         (root (get-preferences-root~ process)))
    (if (not root)
        (when error?
          (error "Could not find preferences"))
      (if (not name)
          root
        (either (find-component~ root name)
                (when error?
                  (error "Could not find preferences: {t}" name)))))))


(definition public (set-preference preferences property value)
  (let ((designer (get-preferences-designer~ (get-process))))
    (set-property~ designer preferences property value)))


(definition public (sort-case-sensitive?)
  (let ((pref (get-preferences '(interface tree) error?: #f)))
    (and pref (get-sort-case-sensitive?~ pref))))


(definition public (sort-predicates)
  (if (sort-case-sensitive?)
      (values = < >)
    (values ci=? ci<? ci>?)))


(definition public (sort-predicate name)
  (let ((case-sensitive? (sort-case-sensitive?)))
    (case name
      ((equal)         (if case-sensitive? =  ci=?))
      ((smaller)       (if case-sensitive? <  ci<?))
      ((smaller/equal) (if case-sensitive? <= ci<=?))
      ((greater)       (if case-sensitive? >  ci>?))
      ((greater/equal) (if case-sensitive? >= ci>=?))
      ((compare)       (if case-sensitive? compare ci-compare))
      (else (error "Unknown sort predicate: {t}" name)))))


;;;
;;;; Input/Output
;;;


(definition public (backup-file file)
  (new-unique-file~ (get-parent~ file) (format "{a}.back.{a}" (get-base~ file) (get-extension~ file)) separator: {}))


(definition public (fail-safe-save file proc)
  (unimplemented 'fail-safe-save)
  @unwind-protect
  (let ((temp (clone-file~ file "tmp"))
        (back (backup-file file))
        (completed? #f))
    (unwind-protect
        (begin
          (proc temp)
          (set! completed? #t))
      (cond ((not completed?)
             (delete-file~ temp error?: #f))
            ((exists?~ file)
             (move-pathname~ file back)
             (move-pathname~ temp file)
             (delete-file~ back))
            (else
             (move-pathname~ temp file))))))


;;;
;;;; External
;;;


(definition public (read-tab-delimited file)
  (call-with-input-file (list path: (parse~ file) eol-encoding: 'cr-lf)
    (function (reader)
      (let ((tab (string #\tab))
            (fact (new List-Factory))
            (done? #f))
        (while (not done?)
          (let ((line (read-line reader)))
            (if (not line)
                (set! done? #t)
              (let ((values (split line tab)))
                (put~ fact (map patch-for-excel values))))))
        (get-output~ fact)))))


(definition (patch-for-excel line)
  (if (and (starts-with? line "\"")
           (ends-with? line "\""))
      (subseq line 1 (- (string-length line) 1))
    line))


(definition public (convert-tab-delimited->jml input parser)
  (unimplemented 'convert-tab-delimited->jml)
  @JML
  (let* ((output (new-file~ (get-parent~ input) (format "{a}.jml" (get-base~ input))))
         (content (read-tab-delimited input))
         (jml (parser content))
         (pref (new JML-Preferences))
         (parser (new JML-Parser preferences: pref))
         (jml (parse~ parser jml)))
    (call-with-output-file (list path: (parse~ output) char-encoding: 'UTF-8)
      (function (printer)
        (pretty-print~ jml printer)))
    (user-message "{a} converted to {a}" (get-name~ input) (get-name~ output))
    (let ((appl (get-application)))
      (verify-reload~ appl output))))


(definition public (save-tab-delimited content file)
  (unimplemented 'save-tab-delimited)
  @File-Printer
  (call-with-output-file (parse~ file)
    (function (printer)
      (for-each (function (line)
                  (let ((first? #t))
                    (for-each (function (text)
                                (if first?
                                    (set! first? #f)
                                  (format printer "{&}"))
                                (format printer "{a}" text))
                              line))
                  (format printer "{%}"))
                content))))


;;;
;;;; Message
;;;


(definition public (user-message obj . rest)
  (let ((appl (get-application)))
    (when appl
      (set-status-message~ appl (if (is? obj Locales) obj (apply format obj rest))))))


(definition public (clear-user-message)
  (user-message ""))


(definition public (make-directory-feedback)
  (let ((directory {}))
    (function (file)
      (let ((dir (get-parent~ file)))
        (when (or (not directory) (not (pathname=? dir directory)))
          (let ((expanded (expand~ dir)))
            (let ((len (length expanded)))
            (user-message "Searching {l detail: :human}..." (subseq expanded (max 0 (- len 3)) len))
            (set! directory dir))))))))


;;;
;;;; Error
;;;


(definition public (disabled-functionnality)
  (error "Sorry, this functionnality is temporarily disabled"))


(definition public (must-implement definition-name (what {}))
  (error "The {a} definition must be implemented for {a} to work correctly"
         definition-name
         (either what "this application")))


;;;
;;;; Unicode
;;;


(definition public (sequence->string seq)
  (let* ((size (cardinality seq))
         (len (- (quotient size 2) 1))
         (string (make-string len)))
    (for-each (function (i)
                (let* ((n (* i 2))
                       (c (make-word (element seq n) (element seq (+ n 1)))))
                  (set-element! string i c)))
              (naturals 0 len))
    string))


(definition public (string->sequence string type)
  (let* ((len (cardinality string))
         (size (* (+ len 1) 2))
         (seq (new type size: size)))
    (for-each (function (i)
                (let ((n (* i 2))
                      (c (char->integer (element string i))))
                  (set-element! seq n (lobyte c))
                  (set-element! seq (+ n 1) (hibyte c))))
              (naturals 0 len))
    (set-element! seq (- size 2) 0)
    (set-element! seq (- size 1) 0)
    seq))


;;;
;;;; Data
;;;


(definition public (iterate-hierarchical-data proc data size key)
  (unless (not data)
    (let* ((id-row (car data))
           (id (key id-row))
           (id-data data)
           (id-size 1)
           (scan (cdr data))
           (scan-count 1))
      (while (< scan-count size)
        (let* ((scan-row (car scan))
               (scan-id (key scan-row)))
          (when (/= scan-id id)
            (proc id-row id-data id-size)
            (set! id-row scan-row)
            (set! id scan-id)
            (set! id-data scan)
            (set! id-size 0))
          (increase! id-size)
          (set! scan (cdr scan))
          (increase! scan-count)))
      (proc id-row id-data id-size))))


(definition public (collect-hierarchical-data proc data size key)
  (let ((fact (new List-Factory)))
    (iterate-hierarchical-data
      (function (row data size)
        (let ((object (proc row data size)))
          (when object
            (put~ fact object))))
      data
      size
      key)
    (get-output~ fact)))


;; quicky ugly
(definition public (sorted-hierarchical-data proc data size key sort-test sort-key)
  (collect (function (data)
             (proc (first data) (second data) (third data)))
           (sort sort-test (collect-hierarchical-data list data size key)
             key: (function (data)
                    (sort-key (first data))))))


;;;
;;;; Data Source
;;;


@convert-and-relocate
(definition public (request-data-source (provider: provider {}))
  (receive (process? dialog) (new-dialog (autoload 'Data-Source-Chooser) host-visible?: #f)
    (let ((manager (get-guest~ dialog)))
      (when provider
        (set-provider~ manager (external-name~ provider)))
      (process-modal~ dialog))))


;;;
;;;; Time
;;;


(definition public 2-Seconds-Tolerance
  2)


(definition (different-times? time1 time2 (tolerance: tolerance 2-Seconds-Tolerance))
  (> (abs (- (time->seconds time1) (time->seconds time2)))
     tolerance))


(definition (different-file-content? file1 file2)
  (if (and (member? (get-extension~ file1) Text-Extensions test: ci=?)
           (member? (get-extension~ file2) Text-Extensions test: ci=?))
      (different-text-file-content? file1 file2)
    (call-with-input-file (parse~ file1)
      (function (input1)
        (call-with-input-file (parse~ file2)
          (function (input2)
            (or @convert
                (/= (get-size~ input1)
                    (get-size~ input2))
                (let (iterate)
                  (let ((u1 (read-u8 input1))
                        (u2 (read-u8 input2)))
                    (cond ((and (eof-object? u1)
                                (eof-object? u2))
                           #f)
                          ((eqv? u1 u2)
                           (iterate))
                          (else
                           #t)))))))))))


(definition (different-text-file-content? file1 file2)
  (not (equal? (load-lines~ file1)
               (load-lines~ file2))))


(definition (different-file-content-no-whitespace? file1 file2)
  (call-with-input-file (parse~ file1)
    (function (input1)
      (call-with-input-file (parse~ file2)
        (function (input2)
          (not (wi= (read-content-string input1)
                    (read-content-string input2))))))))


(definition public (present-hour/minutes hour minutes)
  (format "{a width: 2 justify: :right padding: #\\0}:{a width: 2 justify: :right padding: #\\0}"
    hour
    minutes))


;;;
;;;; Message
;;;


(definition public (message-box text . rest)
  (let ((process (get-process)))
    (if (not process)
        (apply system-message text rest)
      (show-box~ process text rest))))


;;;
;;;; Actions
;;;


(definition public (get-class-actions object)
  (class-actions~ object))


(definition public (get-guest-actions view)
  ;; necessary for dialogs that come before user bindings
  (if (not (get-bindings~ (get-application)))
      '()
    (guest-actions~ view)))


(definition public (extract-actions actions-list)
  (let ((fact (new List-Factory)))
    (for-each (function (action-list)
                (let ((context-name (get-name~ action-list)))
                  (for-each (function (action-item)
                              (let* ((action-name (get-name~ action-item))
                                     (shortcut (get-shortcut~ action-item)))
                                (when shortcut
                                  (put~ fact action-item))))
                            (get-children~ action-list))))
              actions-list)
    (get-output~ fact)))


;;;
;;;; Logger
;;;


(definition *logger-directory*
  {Directory User})

(definition *logger-file*
  {})


(definition (logger-file)
  (when (not *logger-file*)
    (set! *logger-file* (timestamped-file *logger-directory* "log" "txt")))
  *logger-file*)


(definition (with-logger-output proc)
  (call-with-output-file (list path: (parse~ (logger-file)) append: #t eol-encoding: platform-eol-encoding)
    (function (port)
      (proc port))))


(definition (logger-log . rest)
  (with-logger-output
    (function (port)
      (apply format port rest))))


(definition (logger-line line)
  (logger-log "{a}{%}" line))


(definition (logger-debug . rest)
  (logger-log "{l}{%}" rest))


(definition (logger-exception exc)
  (with-logger-output
    (function (port)
      (display-exception exc port))))


(definition (logger-backtrace cont)
  (with-logger-output
    (function (port)
      (display-continuation-backtrace cont port))))


;;;
;;;; Snapshot
;;;


(definition *snapshots-directory*
  {Directory User})


(definition public (snapshot-process . rest)
  (let ((file (timestamped-file *snapshots-directory* {} "snapshot")))
    (create-directories~ file)
    (call-with-output-file (list path: (parse~ file) eol-encoding: platform-eol-encoding)
      (function (printer)
        (apply print-process-snapshot printer rest)))
    file))


(definition public (print-process-snapshot printer (continuation: continuation {}) (reason: reason {}) (exception: exception {}))
  (define (print-process)
    (format printer "  ;;;{%}")
    (format printer "  ;;;; PROCESS{%}")
    (format printer "  ;;;{%}{%}")
    (format printer "  process: {s}{%}" (either (current-process-present) "{}"))
    (format printer "  date: {s}{%}" (present-date (current-date)))
    (when reason
      (format printer "  reason: {s}{%}" reason)))
  
  (define (print-exception)
    (when exception
      (format printer "{%}")
      (format printer "  ;;;{%}")
      (format printer "  ;;;; EXCEPTION{%}")
      (format printer "  ;;;{%}{%}")
      (format printer "  exception:{%}")
      (format printer "  ~{Exception-Snapshot{%}")
      (format printer "   reason: {s}}{%}" (exception-reason exception))))
  
  (define (print-threads)
    (format printer "{%}")
    (format printer "  ;;;{%}")
    (format printer "  ;;;; THREADS{%}")
    (format printer "  ;;;{%}{%}")
    (format printer "  threads:{%}")
    (format printer "  (")
    (if continuation
        (print-thread (current-thread) continuation)
      (continuation-capture
        (function (continuation)
          (print-thread (current-thread) continuation))))
    (loop (for thread in (top-threads))
          (do (when (neq? thread (current-thread))
                (format printer "{%}{%}   ")
                (print-thread thread {}))))
    (format printer ")"))
  
  (define (print-thread thread continuation)
    (format printer "~{Thread-Snapshot{%}")
    (format printer "    name: {s}{%}" (present-thread-name (thread-name thread)))
    (format printer "    state: {s}" (present-thread-state (thread-state thread)))
    (when continuation
      (format printer "{%}")
      (format printer "    stack:{%}")
      (format printer "    (")
      (print-stack continuation)
      (format printer ")"))
    (format printer "}"))
  
  (define (print-stack continuation)
    (let ((stack (get-continuation-stack continuation #f)))
      (loop (for first? first #t then #f)
            (for cont in stack)
            (do (when (not first?)
                  (format printer "{%}     "))
                (let ((name (get-continuation-name cont))
                      (variables (get-continuation-lexical-environment cont)))
                  (format printer "({a}" name)
                  (loop (for variable in variables)
                        (do (format printer "{%}       ")
                            (bind (name . value) variable
                              (format printer "({s} {s})" name (present-object value)))))
                  (format printer ")"))))))
  
  (format printer "~{Process-Snapshot{%}{%}")
  (print-process)
  (print-exception)
  (print-threads)
  (format printer "}{%}"))


(definition public (snapshot-exception-debugger (feedback: feedback {}))
  (function (exception)
    (with-system-exception-debugger
      (function ()
        (continuation-capture
          (function (continuation)
            (let ((snapshot (snapshot-process continuation: continuation exception: exception)))
              (when feedback
                (feedback exception snapshot)))))
        (exit 1)))))


(definition public (application-exception-debugger)
  (snapshot-exception-debugger
    feedback: application-exception-feedback))


(definition (application-exception-feedback exception snapshot)
  (let ((process (get-process)))
    (system-message (format "{a} {a}:{%}{%}{a}.{%}{a}.{%}{%}{a}{%}    {a}{a}"
                            (localize {Locales english: "An unexpected problem occured while executing" french: "Une erreur imprvue s'est produite lors de l'excution de"})
                            (current-process-present)
                            (localize {Locales english: "This will terminate the application immediately" french: "Ceci entraine la terminaision immdiate de l'application"})
                            (localize {Locales english: "Unsaved work currently in progress will be lost" french: "Tout travaux en cours non sauvegards seront perdus"})
                            (localize {Locales english: "A log file has been generated at" french: "Un fichier de log a t gnr "})
                            (parse~ snapshot)
                            (if process
                                (let ((email (process-email~ process)))
                                  (if email
                                      (format "{%}{%}{a}{%}{a}: {a}."
                                              (localize {Locales english: "Help us fix this problem by sending the log file and any comments" french: "Aidez nous  corriger ce problme en fesant parvenir le fichier de log"})
                                              (localize {Locales english: "about how the problem occured to" french: "ainsi que tout commentaires explicatifs "})
                                              email)
                                    ""))
                              ""))
                    title: (localize {Locales english: "Application Error" french: "Erreur d'application"})
                    type: 'problem)))


;;;
;;;; Stack
;;;


(definition public (continuation-stack cont (dynamic-environment?: dynamic-environment? #f) (lexical-environment?: lexical-environment? #f) (depth: depth #f))
  (let ((stack (get-continuation-stack cont depth)))
    (map (function (cont)
           (let ((name (get-continuation-name cont)))
             (cond ((and (not dynamic-environment?) (not lexical-environment?))
                    name)
                   ((not dynamic-environment?)
                    (cons name (get-continuation-lexical-environment cont)))
                   (else
                    (cons name (append (get-continuation-dynamic-environment cont)
                                       (get-continuation-lexical-environment cont)))))))
         stack)))


(definition public (execution-stack (dynamic-environment?: dynamic-environment? #f) (lexical-environment?: lexical-environment? #f) (depth: depth #f))
  (continuation-capture
    (function (cont)
      (continuation-stack cont dynamic-environment?: dynamic-environment? lexical-environment?: lexical-environment? depth: depth)))))
