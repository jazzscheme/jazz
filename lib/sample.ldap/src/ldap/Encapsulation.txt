ENCAPSULATION

When deciding how to implement some library (naming, using functions,
classes, generic methods, dynamic dispatch, ...), there are many
approaches with various pros and cons.

Ultimately, the key elements of this decision pretty much come down
to complexity and encapsulation.

Here are some encapsulation strategies available in Jazz. Note that
these strategies are *not* mutually exclusive and can easily be mixed
together depending on your needs. The example we will be using is
of exporting basic LDAP functionality accessed through some FFI code.


STRATEGIES

0- Barebones FFI

  Simply export your FFI interface.

  No encapsulation. All the weight is on your users code.


1- Purely Functional

  This solution is a very valid one and depending on the complexity of
  the system and level of polymorphism desired it can easily be the
  simplest one to implement and the most flexible.

  In this approach, encapsulation is done by the module system using
  the symbols your module exports. With this approach, every behavior
  is associated with an exported symbol.


2- Object-Oriented with Generic Methods

  If you want a very functional solution but desire polymorphic
  behavior on some classes, then you can use classes and generic
  methods. This is the Common Lisp approach and a very flexible one
  indeed.

  In this approach, encapsulation is done by the module system using
  the symbols your module exports. Here too, every behavior is
  associated with an exported symbol, but common behaviors are grouped
  together into one generic method that is exported only once.

  In 1 and 2, encapsulation being done by symbols, when complexity
  grows, risk of conflicts between imported symbols becomes greater
  and so you will usually want to prefix your exported symbols, for
  example: ldap-search. Not prefixing is possible but puts the burden
  of renaming conflicting imports on your users shoulders.


3- Object-Oriented with Dynamic Dispatch

  In this approach, dynamic dispatch is used to encapsulate every
  behavior inside classes. Only classes and maybe some high-level
  functions are exported, thus greatly augmenting the encapsulation
  of your library.


NOTES

As a rule of thumb, I'd say that as a system's complexity grows,
encapsulation becomes more and more critical and thus you would tend
to go progressively from 1 to 3. This said, 1, 2 and 3 are all valid
strategies in every case and offer different tradeoffs from one
another and this is exactly why Jazz supports all 3!

Regarding what strategy to choose, lets not forget that one huge
benefit of developing in an interpreted language is that you don't
have to over-design before deciding on an approach. Should your needs
evolve and should you change your approach, changing typeless code is
easily done and will break a lot less user code than with a typed
language. So you can start coding early, evolve easily and have fun
doing it knowing evolving is easy and part of a good development cycle!


EXAMPLES

I added some sample packages to showcase each strategy using a simple
simulation of an LDAP server.

To try the samples :
- pull the latest code from the jazz_opt repository
- launch Jedi and choose the LDAP profile (it is a profile created to
  showcase the 4 strategies)
- execute the profile's test method: ctrl-t to create a simple GUI
  that can be used to execute an ldap search (note that all strategies
  behave exactly the same)
- explore the code by expanding contrib.ldap in the workbench and
  double-clicking the various modules
- expand profile.ldap and double-click LDAP.jazz if you are curious
  about how the search GUI was created

Note that the example being very simple and having no polymorphic
behavior, clearly solution 1 is the simplest and most elegant. I would
like this example to evolve to better showcase strategies 2 and 3.
