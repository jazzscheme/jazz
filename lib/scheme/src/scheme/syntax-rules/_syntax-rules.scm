
(library scheme.syntax-rules scheme

(define-syntax public syntax-rules
  (rsc-macro-transformer
   (lambda (expr mac-env)
     (define (rename x) (make-syntactic-closure mac-env '() x))
     (define (compare x y) (identifier=? mac-env x mac-env y))
     (let ((lits (unwrap-syntactic-closure (cadr (unwrap-syntactic-closure expr))))
           (forms (cddr (unwrap-syntactic-closure expr)))
           (count 0)
           (_er-macro-transformer (rename 'er-macro-transformer))
           (_unwrap-syntactic-closure (rename 'unwrap-syntactic-closure))
           (_strip-source-info (rename 'strip-source-info))
           (_strip-syntactic-closures (rename 'strip-syntactic-closures))
           (_lambda (rename 'lambda))      (_let (rename 'let))
           (_begin (rename 'begin))        (_if (rename 'if))
           (_and (rename 'and))            (_or (rename 'or))
           (_eq? (rename 'eq?))            (_equal? (rename 'equal?))
           (_car (rename 'car))            (_cdr (rename 'cdr))
           (_cons (rename 'cons))          (_pair? (rename 'pair?))
           (_null? (rename 'null?))        (_quote (rename 'quote))
           (_apply (rename 'apply))        (_append (rename 'append))
           (_map (rename 'map))            (_vector? (rename 'vector?))
           (_list? (rename 'list?))        (_lp (rename 'lp))
           ;;(_res (rename 'res)) (_display (rename 'display)) (_write (rename 'write))
           (_reverse (rename 'reverse))
           (_vector->list (rename 'vector->list))
           (_list->vector (rename 'list->vector))
           (_expr (jazz.generate-symbol "expr"))
           (_rename (jazz.generate-symbol "rename"))
           (_compare (jazz.generate-symbol "compare")))
       (define (next-v)
         (set! count (+ count 1))
         (jazz.generate-symbol
          (string-append "v_" (number->string count))))
       (define (any pred ls)
         (and (pair? ls) (or (pred (car ls)) (any pred (cdr ls)))))
       (define (expand-pattern pat tmpl)
         (let lp ((p (cdr (unwrap-syntactic-closure pat)))
                  (x `(,_cdr (,_unwrap-syntactic-closure ,_expr)))
                  (dim 0)
                  (vars '())
                  (k (lambda (vars) (or (expand-template tmpl vars) `(,_begin #f)))))
           (let ((v (next-v)))
             `(,_let ((,v ,x))
                ,(cond
                  ((identifier? p)
                   (if (any (lambda (l) (compare p l)) lits)
                       `(,_and (,_compare ,v (,_quote ,p)) ,(k vars))
                       `(,_let ((,p ,v)) ,(k (cons (cons p dim) vars)))))
                  (else
                   (let ((p (unwrap-syntactic-closure p)))
                     (cond
                      ((ellipse? p)
                       (cond
                        ((not (null? (cddr p)))
                         (jazz.error "syntax-rules: non-trailing ellipse: {s}" pat))
                        ((identifier? (car p))
                         `(,_and (,_list? (,_unwrap-syntactic-closure ,v))
                                 (,_let ((,(car p) ,v))
                                   ,(k (cons (cons (car p) (+ 1 dim)) vars)))))
                        (else
                         (let* ((w (next-v))
                                (new-vars (all-vars (car p) (+ dim 1)))
                                (ls-vars (map (lambda (x)
                                                (jazz.generate-symbol
                                                 (string-append
                                                  (symbol->string
                                                   (unwrap-syntactic-closure (car x)))
                                                  "-ls")))
                                              new-vars))
                                (once
                                 (lp (car p)
                                     `(,_car (,_unwrap-syntactic-closure ,w))
                                     (+ dim 1)
                                     '()
                                     (lambda (_)
                                       `(,_lp (,_cdr (,_unwrap-syntactic-closure ,w))
                                              ,@(map (lambda (x l) `(,_cons ,(car x) ,l))
                                                     new-vars
                                                     ls-vars))))))
                           `(,_let ,_lp ((,w ,v)
                                         ,@(map (lambda (x) (list x '())) ls-vars))
                               (,_if (,_null? ,w)
                                   (,_let ,(map (lambda (x l) `(,(car x) (,_reverse ,l)))
                                                new-vars
                                                ls-vars)
                                     ,(k (append new-vars vars)))
                                   (,_and (,_pair? (,_unwrap-syntactic-closure ,w))
                                          ,once)))))))
                      ((pair? p)
                       `(,_and (,_pair? (,_unwrap-syntactic-closure ,v))
                               ,(lp (car p)
                                    `(,_car (,_unwrap-syntactic-closure ,v))
                                    dim
                                    vars
                                    (lambda (vars)
                                      (lp (cdr p)
                                          `(,_cdr (,_unwrap-syntactic-closure ,v))
                                          dim vars k)))))
                      ((vector? p)
                       `(,_and (,_vector? (,_unwrap-syntactic-closure ,v))
                               ,(lp (vector->list p)
                                    `(,_vector->list (,_unwrap-syntactic-closure ,v))
                                    dim vars k)))
                      ((null? p)
                       `(,_and (,_null? ,v) ,(k vars)))
                      (else
                       `(,_and (,_equal? (,_strip-source-info ,v) ,p) ,(k vars)))
                      ))))))))
       (define (ellipse? x)
         (and (pair? x)
              (pair? (unwrap-syntactic-closure (cdr x)))
              (compare '... (car (unwrap-syntactic-closure (cdr x))))))
       (define (ellipse-depth x)
         (if (ellipse? x)
             (+ 1 (ellipse-depth (cdr x)))
             0))
       (define (ellipse-tail x)
         (if (ellipse? x)
             (ellipse-tail (unwrap-syntactic-closure (cdr x)))
             (cdr x)))
       (define (assoc-id id ls)
         (and (pair? ls)
              (if (compare id (caar ls))
                  (car ls)
                  (assoc-id id (cdr ls)))))
       (define (all-vars x dim)
         (let lp ((x x) (dim dim) (vars '()))
           (cond ((identifier? x)
                  (if (any (lambda (l) (compare x l)) lits)
                      vars
                      (cons (cons x dim) vars)))
                 ((or (syntactic-closure? x) (jazz.source? x))
                  (lp (unwrap-syntactic-closure x) dim vars))
                 ((ellipse? x) (lp (car x) (+ dim 1) vars))
                 ((pair? x) (lp (car x) dim (lp (cdr x) dim vars)))
                 ((vector? x) (lp (vector->list x) dim vars))
                 (else vars))))
       (define (free-vars x vars dim)
         (let lp ((x x) (free '()))
           (cond
            ((identifier? x)
             (if (and (not (any (lambda (f) (compare f x)) free))
                      (let ((cell (assoc-id x vars)))
                        (and cell (>= (cdr cell) dim))))
                 (cons x free)
                 free))
            ((or (syntactic-closure? x) (jazz.source? x))
             (lp (unwrap-syntactic-closure x) free))
            ((pair? x) (lp (car x) (lp (cdr x) free)))
            ((vector? x) (lp (vector->list x) free))
            (else free))))
       (define (expand-template tmpl vars)
         (let lp ((t tmpl) (dim 0))
           (cond
            ((identifier? t)
             (if (syntactic-closure? t)
                 t
                 (let ((cell (assoc-id t vars)))
                   (if cell
                       (if (<= (cdr cell) dim)
                           t
                           (jazz.error "syntax-rules: too few ...'s: {s}" tmpl))
                       `(,_rename (,_quote ,t))))))
            ((or (syntactic-closure? t) (jazz.source? t))
             (lp (unwrap-syntactic-closure t) dim))
            ((pair? t)
             (if (ellipse? t)
                 (let* ((depth (ellipse-depth t))
                        (ell-dim (+ dim depth))
                        (ell-vars (free-vars (car t) vars ell-dim)))
                   (if (null? ell-vars)
                       (jazz.error "syntax-rules: too many ...'s: {s} in {s}" t tmpl)
                       (let* ((once (lp (car t) ell-dim))
                              (nest (if (and (null? (cdr ell-vars))
                                             (identifier? once)
                                             (eq? once (car vars)))
                                        once ;; shortcut
                                        (cons _map
                                              (cons (list _lambda ell-vars once)
                                                    ell-vars))))
                              (many (do ((d depth (- d 1))
                                         (many nest
                                               (list _apply _append many)))
                                        ((= d 1) many))))
                         (if (null? (ellipse-tail t))
                             many ;; shortcut
                             (list _append many (lp (ellipse-tail t) dim))))))
                 (list _cons (lp (car t) dim) (lp (cdr t) dim))))
            ((vector? t) (list _list->vector (lp (vector->list t) dim)))
            ((null? t) (list _quote '()))
            (else t))))
       (let ((res `(,_er-macro-transformer
                    (,_lambda (,_expr ,_rename ,_compare)
                      (,_or
                       ,@(map
                          (lambda (clause)
                            (let ((clause (unwrap-syntactic-closure clause)))
                              (if (not (and (pair? clause) (pair? (cdr clause))))
                                  (jazz.error "syntax-rules: bad clause: {s}" clause)
                                  (expand-pattern (car clause) (cadr clause)))))
                          forms)
                       (jazz.error "syntax-rules: no expansion: {s}" ,_expr))
                      ))))
         ;;(display "expansion: ") (write (strip-syntactic-closures res)) (newline)
         res))))))

