;;; Scheme Raytracer v0.1
;;;
;;; Obj
;;;
;;; 10/04/2007
;;; James Long


(library raytrace.obj jazz


(import (raytrace.vec)
        (raytrace.scene))


(proclaim (optimize))


;;;
;;;; Obj
;;;


(class obj extends Object
  
  (slot type  <symbol> getter generate)
  (slot color <vec3d>  getter generate)
  
  (method public virtual abstract (normal point <vec3d>) <vec3d>
    )
  
  (method public virtual abstract (intersection origVec <vec3d> dirVec <vec3d>) <fl>
    ))


(definition public inline (obj-type obj <obj>) <symbol>
  (get-type~ obj))

(definition public inline (obj-color obj <obj>) <vec3d>
  (get-color~ obj))


;;;
;;;; Triangle
;;;


(class triangle extends obj
  
  (slot v1        <vec3d> getter generate)
  (slot v2        <vec3d> getter generate)
  (slot v3        <vec3d> getter generate)
  (slot normalvec <vec3d>)
  
  (method (normal point <vec3d>) <vec3d>
    normalvec)
  
  (method (intersection origVec <vec3d> dirVec <vec3d>) <fl>
    (let* ((n (normal no-vec3d))
           (v$n (vec3d-dot dirVec n)))
      (if (>= v$n 0.0)
          depth
        (begin
          (let* ((a v1)
                 (b v2)
                 (c v3)
                 (o-a$n (vec3d-dot (vec3d-sub origVec a) n))
                 (d (- (/ o-a$n v$n)))
                 (p (vec3d-add origVec (vec3d-scalar-mul dirVec d))))
            (let ((signf #f))
              (if (negative? (vec3d-dot (vec3d-cross (vec3d-sub b a) (vec3d-sub p a)) n))
                  (set! signf negative?)
                (set! signf (lambda (n) (or (zero? n) (positive? n)))))
              (if (and (>= d 0.0)
                       (signf (vec3d-dot (vec3d-cross (vec3d-sub c b) (vec3d-sub p b)) n))
                       (signf (vec3d-dot (vec3d-cross (vec3d-sub a c) (vec3d-sub p c)) n)))
                  d
                depth))
            ; Barycentric projection - has some bugs
            @w (let ((u (/ (- (* (vec3d-y p) (vec3d-x c))
                              (* (vec3d-x p) (vec3d-y c)))
                           (- (* (vec3d-y b) (vec3d-x c))
                              (* (vec3d-x b) (vec3d-y c)))))
                     (v (/ (- (* (vec3d-y p) (vec3d-x b))
                              (* (vec3d-x p) (vec3d-y b)))
                           (- (* (vec3d-y c) (vec3d-x b))
                              (* (vec3d-x c) (vec3d-y b))))))
                 (if (and (>= u 0.0) (>= v 0.0) (<= (+ u v) 1.0))
                     d
                   depth))))))))


(definition public inline (make-triangle color v1 v2 v3)
  (construct triangle 'triangle color v1 v2 v3
    (vec3d-unit
      (vec3d-cross
        (vec3d-sub v2 v1)
        (vec3d-sub v3 v1)))))

(specialize inline (new class <category<triangle>> color <vec3d> v1 <vec3d> v2 <vec3d> v3 <vec3d>) <triangle>
  (make-triangle color v1 v2 v3))


(definition public inline (triangle-v1 v <triangle>) <vec3d>
  (get-v1~ v))

(definition public inline (triangle-v2 v <triangle>) <vec3d>
  (get-v2~ v))

(definition public inline (triangle-v3 v <triangle>) <vec3d>
  (get-v3~ v))


;;;
;;;; Sphere
;;;


(class sphere extends obj
  
  (slot pos    <vec3d> getter generate)
  (slot radius <fl>    getter generate)
  
  (method (normal point <vec3d>) <vec3d>
    (vec3d-unit (vec3d-sub point pos)))

  (method (intersection origVec <vec3d> dirVec <vec3d>) <fl>
    (let* ((eo (vec3d-sub origVec pos))
           (b (vec3d-dot eo dirVec))
           (c (- (vec3d-dot eo eo) (cast <fl> (expt radius 2.0))))
           (d (- (* b b) c)))
      (if (<= d (cast <fl> 0.0))
          depth
        (let ((r (- (- b) (cast <fl> (sqrt d)))))
          (if (> r 0.0)
              r
            depth))))))


(definition public inline (make-sphere color pos radius)
  (construct sphere 'sphere color pos radius))

(specialize inline (new class <category<sphere>> color <vec3d> pos <vec3d> radius <fl>) <sphere>
  (make-sphere color pos radius))


(definition public inline (sphere-pos obj <sphere>) <vec3d>
  (get-pos~ obj))

(definition public inline (sphere-radius obj <sphere>) <fl>
  (get-radius~ obj))


;;;
;;;; Light
;;;


(class light extends sphere)


(definition public inline (make-light color pos radius)
  (construct light 'light color pos radius))

(specialize inline (new class <category<light>> color <vec3d> pos <vec3d> radius <fl>) <light>
  (make-light color pos radius))


(definition public inline (light-pos obj <light>) <vec3d>
  (sphere-pos obj))


;;;
;;;; Plane
;;;


(class plane extends obj
  
  (slot distance  <fl>    getter generate)
  (slot normalvec <vec3d> getter generate)
  
  (method (normal point <vec3d>) <vec3d>
    normalvec)
  
  (method (intersection origVec <vec3d> dirVec <vec3d>) <fl>
    (let ((d (vec3d-dot normalvec dirVec)))
      (if (not (zero? d))
          (let ((dist (/ (- (+ (vec3d-dot normalvec origVec)
                               distance))
                         d)))
            (if (positive? dist)
                dist
              depth))
        depth))))


(definition public inline (make-plane color distance normal)
  (construct plane 'plane color distance normal))

(specialize inline (new class <category<plane>> color <vec3d> distance <fl> normal <vec3d>) <plane>
  (make-plane color distance normal))


;;;
;;;; Mesh
;;;


;; Simplistic meshes
(class mesh extends obj
  
  (slot pos     <vec3d> getter generate)
  (slot promise         getter generate))


(definition public inline (make-mesh color pos promise)
  (construct mesh 'mesh color pos promise))

(specialize inline (new class <category<mesh>> color <vec3d> pos <vec3d> promise) <mesh>
  (make-mesh color pos promise))


(definition public inline (mesh-pos obj <mesh>) <vec3d>
  (get-pos~ obj))

(definition (mesh-primitives obj <mesh>)
  (let ((a (get-promise~ obj)))
    (if (pair? a)
        a
      (force a)))))
