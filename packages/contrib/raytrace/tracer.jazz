;;; Scheme Raytracer v0.1
;;;
;;; Performs sphere/plane/triangle intersection tests, loads
;;; .obj files as a list of triangles, applies Phong
;;; illumination and reflections.
;;;
;;; The math here hasn't been optimized at all, and there's
;;; a good deal that could be done.  However, I simply wanted
;;; to build a prototype.  Optimization will come in the
;;; next version.
;;;
;;; This outputs to a file 'image.ppm' which is of the format
;;; Portable Pixmap.  Netpbm provides nice tools to convert
;;; ppm's to other file formats if you need it.
;;;
;;; 10/04/2007
;;; James Long


(library raytrace.tracer jazz


(import (raytrace.syntax (phase syntax))
        (raytrace.log)
        (raytrace.parser)
        (raytrace.vec))


(proclaim (optimize))


;;; Utility

(definition (real->u8 n <fl>) <fx>
  (max 0
       (min 255
            (fxfloor n))))

(definition (real->percentage n <fl>) <fx>
  (fxfloor (* 100.0 n)))

(definition (write-color v1 <vec3d> port <port>)
  (write-u8 (real->u8 (* (vec3d-x v1) 255.0)) port)
  (write-u8 (real->u8 (* (vec3d-y v1) 255.0)) port)
  (write-u8 (real->u8 (* (vec3d-z v1) 255.0)) port))


;;; Config constants
(definition screenDimen <vec2d> (make-vec2d 8.0 6.0))
(definition x-res <fx> 600)
(definition y-res <fx> 450)
(definition eye <vec3d> (make-vec3d 0.0 0.0 -5.0))
(definition depth <fl> 10000.0)
(definition backColor <vec3d> (make-vec3d 0.0 0.0 0.0))
(definition ambient <vec3d> (make-vec3d .1 .1 .1))
(definition maxsteps <fx> 3)

(definition coptix (delay (load-obj "coptix_slim")))
(definition box (delay (load-obj "box")))


(definition (generate-spheres)
  (let ((start (make-vec3d 0.0 0.0 65.0))
        (dX (make-vec3d -1.0 -.25 .5))
        (dY (make-vec3d 0.0 -1.0 0.0)))
    (let loop ((num 0)
               (acc '()))
      (if (< num 25)
          (loop (+ num 1) (cons `(sphere ,(make-vec3d .8 (+ .2 (/ (cast <fl> num) 50.0)) .2)
                                         ,(vec3d-add
                                            (vec3d-add start
                                                       (vec3d-scalar-mul
                                                         (vec3d-scalar-mul dX 10.0)
                                                         (cast <fl> (remainder num 5))))
                                            (vec3d-scalar-mul
                                              (vec3d-scalar-mul dY 10.0)
                                              (/ num 5.0)))
                                         5.0)
                                acc))
          acc))))


(definition scene `(,@(generate-spheres)
                ;(sphere ,(make-vec3d .4 .6 .5) ,(make-vec3d -15.0 0.0 90.0) 20.0)
                ;(sphere ,(make-vec3d .75 .95 .92) ,(make-vec3d 20.0 -20.0 65.0) 5.0)
                (plane ,(make-vec3d .7 .7 1.0) 10.0 ,(make-vec3d .25 -1.0 0.0))
                (mesh #f ,(make-vec3d 23.0 0.0 50.0) ,coptix)
                (light ,(make-vec3d .7 .9 .9) ,(make-vec3d -40.0 -15.0 60.0) 1.0)))


(definition (obj-type obj)
  (car obj))

(definition (obj-color obj)
  (cadr obj))

(definition (obj-normal obj point)
  (obj-dispatch obj
   ((sphere) (sphere-normal obj point))
   ((light) (sphere-normal obj point))
   ((plane) (plane-normal obj))
   ((triangle) (triangle-normal obj))))

;;; Light
(definition (light-pos obj) <vec3d>
  (sphere-pos obj))

(definition (light-intersection obj origVec <vec3d> dirVec <vec3d>) <fl>
  (sphere-intersection obj origVec dirVec))

;;; Sphere
(definition (sphere-pos obj) <vec3d>
  (caddr obj))

(definition (sphere-radius obj) <fl>
  (cadddr obj))

(definition (sphere-intersection obj origVec <vec3d> dirVec <vec3d>) <fl>
  (let* ((eo (vec3d-sub origVec (sphere-pos obj)))
         (b (vec3d-dot eo dirVec))
         (c (- (vec3d-dot eo eo) (cast <fl> (expt (sphere-radius obj) 2.0))))
         (d (- (* b b) c)))
    (if (<= d (cast <fl> 0.0))
        depth
        (let ((r (- (- b) (cast <fl> (sqrt d)))))
          (if (> r 0.0)
              r
              depth)))))

(definition (sphere-normal obj point <vec3d>) <vec3d>
  (vec3d-unit (vec3d-sub point (sphere-pos obj))))

;;; Plane
(definition (plane-normal obj) <vec3d>
  (cadddr obj))

(definition (plane-distance obj) <fl>
  (caddr obj))

(definition (plane-intersection obj origVec <vec3d> dirVec <vec3d>) <fl>
  (let ((d (vec3d-dot (plane-normal obj) dirVec)))
    (if (not (zero? d))
        (let ((dist (/ (- (+ (vec3d-dot (plane-normal obj) origVec)
                             (plane-distance obj)))
                       d)))
          (if (positive? dist)
              dist
              depth))
        depth)))

;;; Triangles
(definition (triangle-v1 obj) <vec3d>
  (caddr obj))
(definition (triangle-v2 obj) <vec3d>
  (cadddr obj))
(definition (triangle-v3 obj) <vec3d>
  (car (cddddr obj)))

(definition (triangle-normal obj) <vec3d>
  (vec3d-unit
    (vec3d-cross
      (vec3d-sub (triangle-v2 obj)
                 (triangle-v1 obj))
      (vec3d-sub (triangle-v3 obj)
                 (triangle-v1 obj)))))

(definition (triangle-intersection obj origVec <vec3d> dirVec <vec3d>) <fl>
  (let* ((n (triangle-normal obj))
         (v$n (vec3d-dot dirVec n)))
    (if (>= v$n 0.0)
        depth
        (begin
          (let* ((a (triangle-v1 obj))
                 (b (triangle-v2 obj))
                 (c (triangle-v3 obj))
                 (o-a$n (vec3d-dot (vec3d-sub origVec a) n))
                 (d (- (/ o-a$n v$n)))
                 (p (vec3d-add origVec (vec3d-scalar-mul dirVec d))))
            (let ((signf #f))
              (if (negative? (vec3d-dot (vec3d-cross (vec3d-sub b a) (vec3d-sub p a)) n))
                  (set! signf negative?)
                  (set! signf (lambda (n) (or (zero? n) (positive? n)))))
              (if (and (>= d 0.0)
                       (signf (vec3d-dot (vec3d-cross (vec3d-sub c b) (vec3d-sub p b)) n))
                       (signf (vec3d-dot (vec3d-cross (vec3d-sub a c) (vec3d-sub p c)) n)))
                  d
                  depth))
            ; Barycentric projection - has some bugs
            #;(let ((u (/ (- (* (vec3d-y p) (vec3d-x c))
                           (* (vec3d-x p) (vec3d-y c)))
                        (- (* (vec3d-y b) (vec3d-x c))
                           (* (vec3d-x b) (vec3d-y c)))))
                  (v (/ (- (* (vec3d-y p) (vec3d-x b))
                           (* (vec3d-x p) (vec3d-y b)))
                        (- (* (vec3d-y c) (vec3d-x b))
                           (* (vec3d-x c) (vec3d-y b))))))
              (if (and (>= u 0.0) (>= v 0.0) (<= (+ u v) 1.0))
                  d
                  depth)))))))

;; Simplistic meshes
(definition (mesh-pos obj) <vec3d>
  (caddr obj))

(definition (mesh-primitives obj)
  (let ((a (cadddr obj)))
    (if (pair? a)
        a
        (force a))))

;;; Intersections and casting
(definition (test-intersection obj origVec <vec3d> dirVec <vec3d>) <fl>
  (obj-dispatch obj
   ((sphere) (sphere-intersection obj origVec dirVec))
   ((light) (sphere-intersection obj origVec dirVec))
   ((plane) (plane-intersection obj origVec dirVec))
   ((triangle) (triangle-intersection obj origVec dirVec))))

(definition (apply-lighting hitObj point v)
  (if (eq? (obj-type hitObj) 'light)
      (obj-color hitObj)
      (let ((acc (make-vec3d 0.0 0.0 0.0)))
        (for-each (lambda (obj)
                    (if (eq? (obj-type obj) 'light)
                          (let* ((pointToLight (vec3d-sub (light-pos obj) point))
                                 (l (vec3d-unit pointToLight))
                                 (n (obj-normal hitObj point))
                                 (n$l (saturate (vec3d-dot n l)))
                                 (r (vec3d-sub l (vec3d-scalar-mul n (* 2.0 (vec3d-dot n l)))))
                                 (r$v (saturate (vec3d-dot r v)))
                                 (diff n$l)
                                 (spec (expt r$v 30))
                                 (shadow (saturate (* 4.0 diff))))
                            (if (> diff 0.0) 
                                (set! acc (vec3d-add acc (vec3d-component-mul
                                                           (vec3d-scalar-mul
                                                             (vec3d-add
                                                               (vec3d-scalar-mul (obj-color hitObj)
                                                                                 diff)
                                                               (obj-dispatch hitObj
                                                                ((plane) (make-vec3d 0.0 0.0 0.0))
                                                                (else (vec3d-scalar-mul (make-vec3d 1.0 1.0 1.0)
                                                                                        spec))))
                                                             shadow)
                                                           (obj-color obj))))))))
                  scene)
        (obj-dispatch hitObj
         ((plane) acc)
         (else (vec3d-add ambient acc))))))

(definition (find-closest-prim orig dir prims cont)
  (let ((closestObj #f)
        (closestDepth depth))
    (for-each (lambda (obj)
                (if (eq? (obj-type obj) 'mesh)
                    (find-closest-prim (vec3d-add orig (vec3d-inverse (mesh-pos obj))) dir (mesh-primitives obj)
                                       (lambda (o d <fl>)
                                         (if (< d closestDepth)
                                             (begin
                                               (set! closestDepth d)
                                               (set! closestObj o)))))
                    (let ((d (test-intersection obj orig dir)))
                      (if (< d closestDepth)
                          (begin
                            (set! closestDepth d)
                            (set! closestObj obj))))))
              prims)
    (if closestObj
        (cont closestObj closestDepth)
        backColor)))

(definition (shoot-ray orig dir step <fx>)
  (if (< step maxsteps)
      (find-closest-prim
        orig
        dir
        scene
        (lambda (closestObj closestDepth <fl>)
          (if closestObj
              (let* ((d closestDepth)
                     (point (vec3d-add orig (vec3d-scalar-mul dir d)))
                     (n (obj-normal closestObj point))
                     (r (vec3d-unit (vec3d-sub dir (vec3d-scalar-mul n (* 2.0 (vec3d-dot dir n))))))
                     (view (vec3d-unit (vec3d-sub point eye))))
                (vec3d-add
                  (apply-lighting closestObj point view)
                  (vec3d-scalar-mul (shoot-ray (vec3d-add point (vec3d-scalar-mul r .0001)) r (+ step 1)) (/ (* (cast <fl> (+ step 1)) 2.0)))))
              backColor)))
      (make-vec3d 0.0 0.0 0.0)))

(definition (shoot-screen-rays)
  (let ((dX (/ (vec2d-x screenDimen) x-res))
        (dY (/ (vec2d-y screenDimen) y-res))
        (screenCorner (make-vec3d (- (/ (vec2d-x screenDimen) 2.0))
                                  (- (/ (vec2d-y screenDimen) 2.0))
                                  0.0))
        (count (* x-res y-res)))
    (let loop ((n 0)
               (acc '()))
      (if (< n count)
          (let* ((curPoint (make-vec3d (* (cast <fl> (remainder n x-res)) dX) (* (fl/ n y-res) dY) 0.0))
                 (view (vec3d-unit
                        (vec3d-sub (vec3d-add screenCorner curPoint)
                                   eye)))
                 (curColor (shoot-ray eye
                                      view
                                      0)))
            (if (zero? (remainder n (* y-res 5)))
                  (log-args (real->percentage (/ (cast <fl> n) (cast <fl> count))) "%"))
            (loop (+ n 1) (cons curColor acc)))
          (reverse acc))))))
