;;; Scheme Raytracer v0.1
;;;
;;; Performs sphere/plane/triangle intersection tests, loads
;;; .obj files as a list of triangles, applies Phong
;;; illumination and reflections.
;;;
;;; The math here hasn't been optimized at all, and there's
;;; a good deal that could be done.  However, I simply wanted
;;; to build a prototype.  Optimization will come in the
;;; next version.
;;;
;;; This outputs to a file 'image.ppm' which is of the format
;;; Portable Pixmap.  Netpbm provides nice tools to convert
;;; ppm's to other file formats if you need it.
;;;
;;; 10/04/2007
;;; James Long


(library raytrace.tracer jazz


(import (raytrace.log)
        (raytrace.parser)
        (raytrace.scene)
        (raytrace.vec)
        (raytrace.obj))


(proclaim (optimize))


;;; Utility
(definition inline (real->u8 n <fl>) <fx>
  (max 0
       (min 255
            (fxfloor n))))

(definition inline (real->percentage n <fl>) <fx>
  (fxfloor (* 100.0 n)))

(definition (write-color v1 <vec3d> port <port>) <void>
  (write-u8 (real->u8 (* (vec3d-x v1) 255.0)) port)
  (write-u8 (real->u8 (* (vec3d-y v1) 255.0)) port)
  (write-u8 (real->u8 (* (vec3d-z v1) 255.0)) port))


(definition (generate-spheres)
  (let ((start (make-vec3d 0.0 0.0 65.0))
        (dX (make-vec3d -1.0 -.25 .5))
        (dY (make-vec3d 0.0 -1.0 0.0)))
    (let loop ((num 0)
               (acc '()))
         (if (< num 25)
             (loop (+ num 1) (cons (make-sphere (make-vec3d .8 (+ .2 (/ (cast <fl> num) 50.0)) .2)
                                                (vec3d-add
                                                  (vec3d-add start
                                                             (vec3d-scalar-mul
                                                               (vec3d-scalar-mul dX 10.0)
                                                               (cast <fl> (remainder num 5))))
                                                  (vec3d-scalar-mul
                                                    (vec3d-scalar-mul dY 10.0)
                                                    (/ num 5.0)))
                                                5.0)
                                   acc))
           acc))))


(definition coptix (delay (load-obj "coptix_slim")))
(definition box (delay (load-obj "box")))

(definition scene <list>
  `(,@(generate-spheres)
    ;(sphere ,(make-vec3d .4 .6 .5) ,(make-vec3d -15.0 0.0 90.0) 20.0)
    ;(sphere ,(make-vec3d .75 .95 .92) ,(make-vec3d 20.0 -20.0 65.0) 5.0)
    ,(make-plane (make-vec3d .7 .7 1.0) 10.0 (make-vec3d .25 -1.0 0.0))
    ,(make-mesh no-vec3d (make-vec3d 23.0 0.0 50.0) coptix)
    ,(make-light (make-vec3d .7 .9 .9) (make-vec3d -40.0 -15.0 60.0) 1.0)))


(definition (apply-lighting hitObj <obj> point <vec3d> v <vec3d>) <vec3d>
  (if (eq? (obj-type hitObj) 'light)
      (get-color~ hitObj)
    (let ((acc (make-vec3d 0.0 0.0 0.0)))
      (for-each (lambda (obj <obj>)
                  (when (eq? (obj-type obj) 'light)
                    (let* ((pointToLight (vec3d-sub (light-pos obj) point))
                           (l (vec3d-unit pointToLight))
                           (n (normal~ hitObj point))
                           (n$l (saturate (vec3d-dot n l)))
                           (r (vec3d-sub l (vec3d-scalar-mul n (* 2.0 (vec3d-dot n l)))))
                           (r$v (saturate (vec3d-dot r v)))
                           (diff n$l)
                           (spec (expt r$v 30))
                           (shadow (saturate (* 4.0 diff))))
                      (if (> diff 0.0) 
                          (set! acc (vec3d-add acc (vec3d-mul
                                                     (vec3d-scalar-mul
                                                       (vec3d-add
                                                         (vec3d-scalar-mul (obj-color hitObj)
                                                                           diff)
                                                         (if (eq? (obj-type hitObj) 'plane)
                                                             (make-vec3d 0.0 0.0 0.0)
                                                           (vec3d-scalar-mul (make-vec3d 1.0 1.0 1.0)
                                                                             spec)))
                                                       shadow)
                                                     (obj-color obj))))))))
                scene)
      (if (eq? (obj-type hitObj) 'plane)
          acc
        (vec3d-add ambient acc)))))


(definition (find-closest-prim orig <vec3d> dir <vec3d> prims <list> cont <procedure>) <vec3d>
  (let ((closestObj #f)
        (closestDepth depth))
    (for-each (lambda (obj <obj>)
                (if (eq? (obj-type obj) 'mesh)
                    (find-closest-prim (vec3d-add orig (vec3d-inverse (mesh-pos obj))) dir (mesh-primitives obj)
                      (lambda (o d <fl>)
                        (if (< d closestDepth)
                            (begin
                              (set! closestDepth d)
                              (set! closestObj o)))))
                  (let ((d (intersection~ obj orig dir)))
                    (if (< d closestDepth)
                        (begin
                          (set! closestDepth d)
                          (set! closestObj obj))))))
              prims)
    (if closestObj
        (cont closestObj closestDepth)
      backColor)))


(definition (shoot-ray orig <vec3d> dir <vec3d> step <fx>) <vec3d>
  (if (< step maxsteps)
      (find-closest-prim
        orig
        dir
        scene
        (lambda (closestObj <obj+> closestDepth <fl>)
          (if closestObj
              (let* ((obj <obj> closestObj)
                     (d closestDepth)
                     (point (vec3d-add orig (vec3d-scalar-mul dir d)))
                     (n (normal~ obj point))
                     (r (vec3d-unit (vec3d-sub dir (vec3d-scalar-mul n (* 2.0 (vec3d-dot dir n))))))
                     (view (vec3d-unit (vec3d-sub point eye))))
                (vec3d-add
                  (apply-lighting obj point view)
                  (vec3d-scalar-mul (shoot-ray (vec3d-add point (vec3d-scalar-mul r .0001)) r (+ step 1)) (/ (* (cast <fl> (+ step 1)) 2.0)))))
            backColor)))
    (make-vec3d 0.0 0.0 0.0)))


(definition (shoot-screen-rays) <list>
  (let ((dX (/ (vec2d-x screenDimen) x-res))
        (dY (/ (vec2d-y screenDimen) y-res))
        (screenCorner (make-vec3d (- (/ (vec2d-x screenDimen) 2.0))
                                  (- (/ (vec2d-y screenDimen) 2.0))
                                  0.0))
        (count (* x-res y-res)))
    (let loop ((n 0)
               (acc '()))
         (if (< n count)
             (let* ((curPoint (make-vec3d (* (cast <fl> (remainder n x-res)) dX) (* (fl/ n y-res) dY) 0.0))
                    (view (vec3d-unit
                            (vec3d-sub (vec3d-add screenCorner curPoint)
                                       eye)))
                    (curColor (shoot-ray eye
                                         view
                                         0)))
               (if (zero? (remainder n (* y-res 5)))
                   (log-args (real->percentage (/ (cast <fl> n) (cast <fl> count))) "%"))
               (loop (+ n 1) (cons curColor acc)))
           (reverse acc))))))
