;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; JDBC Database Inventory
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.access.providers.inventory.jdbc.JDBC-Inventory jazz


(import (jazz.access)
        (jazz.library)
        (jazz.utilities))


(class JDBC-Inventory extends Inventory
  
  
  (slot schemas     initialize '())
  (slot table-types initialize '())
  (slot metadata    initialize {})
  
  
  (method (initialize connection url schemas table-types password . rest)
    (nextmethod connection)
    (set! [schemas self] schemas)
    (set! [table-types self] table-types)
    (setup-metadata))
  
  
  (method (setup-metadata)
    (set! metadata (getMetaData~ (get-handle~ connection))))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-schemas)
    schemas)
  
  
  (method public (get-table-types)
    table-types)
  
  
  (method public (get-metadata)
    metadata)
  
  
  ;;;
  ;;;; Version
  ;;;
  
  
  (method (get-version)
    (new Version
      (getDatabaseMajorVersion~ metadata)
      (getDatabaseMinorVersion~ metadata)))
  
  
  ;;;
  ;;;; Match
  ;;;
  
  
  (method (match-schema schema)
    (or (null? schema)
        (match~ (new Regular-Expression schemas) schema)))
  
  
  (method (match-table-type table-type)
    (match~ (new Regular-Expression table-types) table-type))
  
  
  ;;;
  ;;;; Tables
  ;;;
  

  (method (get-tables)
    '()
    @fucking-doesnt-work-anymore-since-i-installed-db2-v8-client
    (let ((fact (new List-Factory)))
      (for-each-table
        (function dynamic (schema name resultset)
          (put~ fact (new JDBC-Inventory-Table self self resultset))))
      (get-output~ fact)))
  
  
  (method (get-table-names)
    (let ((fact (new List-Factory)))
      (for-each-table
        (function dynamic (schema name resultset)
          (put~ fact (cons schema name))))
      (get-output~ fact)))
  
  
  (method (for-each-table proc)
    ;; passing "TABLE" "VIEW" ... is a big simplification for now
    (let ((resultset (getTables~ metadata {} {} {} (list "TABLE" "VIEW" "ALIAS" "SYNONYM"))))
      (while (next~ resultset)
        (let ((schema (getString~ resultset "TABLE_SCHEM"))
              (name (getString~ resultset "TABLE_NAME"))
              (table-type (getString~ resultset "TABLE_TYPE")))
          (when (and (match-schema schema) (match-table-type table-type))
            (proc schema name resultset))))))
  
  
  ;;;
  ;;;; Views
  ;;;
  

  @wait-having-view-columns-info-not-yet-supported-and-i-need-it
  (method (get-views)
    (let ((resultset (getTables~ metadata {} {} {} (list "VIEW")))
          (fact (new List-Factory)))
      (while (next~ resultset)
        (let ((schema (getString~ resultset "TABLE_SCHEM")))
          (when (match-schema schema)
            (put~ fact (new JDBC-Inventory-View self self resultset)))))
      (get-output~ fact)))
  
  
  ;;;
  ;;;; Relations
  ;;;
  
  
  @w
  (method (get-relations)
    (let ((fact (new List-Factory))
          (table-names (get-table-names)))
      (for-each (function dynamic (info)
                  (bind (schema . name) info
                    (let ((relations (get-table-relations~ table)))
                      (if relations
                          (put-sequence~ fact relations)
                        (close~ table)))))
                table-names)
      (get-output~ fact)))))
