;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Applications
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.application.Application jazz


(import (jazz.literals)
        (jazz.platform)
        (jazz.platform.windows)
        (jazz.application)
        (jazz.console)
        (jazz.debugger)
        (jazz.designer)
        (jazz.jazz)
        (jazz.jazz.debuggee)
        (jazz.jml)
        (jazz.jrm)
        (jazz.library)
        (jazz.library.component)
        (jazz.process)
        (jazz.sql)
        (jazz.ui)
        (jazz.ui.look)
        (jazz.ui.clipboard)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.ui.workspace)
        (jazz.utilities)
        (user))


(class Application extends Process implements (Context-Provider History-Provider Event-Consumer Save-Environment-Listener Exit-Listener)


  (slot toplevel                        initialize {})
  (slot stage                           initialize {})
  (slot menubar                         initialize {})
  (slot status-bar                      initialize {})
  (slot user-pathname                   initialize {})
  (slot user                            initialize {})
  (slot focus-listeners                 initialize '())
  (slot application-listeners           initialize (new-hashtable eq?))
  (slot selected-owner                  initialize {})
  (slot selected                        initialize {})
  (slot selected-listeners              initialize '())
  (slot event-consumer                  initialize self)
  (slot history-manager                 initialize (new History-Manager self))
  (slot repositories-preferences        initialize {})
  (slot active?                         initialize false)
  (slot application-actions             initialize '())
  (slot user-actions                    initialize '())
  (slot guest-actions                   initialize '())
  (slot focus-actions                   initialize '())
  (slot bindings                        initialize {})
  (slot bindings-designer               initialize {})
  (slot accelerators-table              initialize {})
  (slot accelerators-handle             initialize {})
  (slot accelerators-dispatch           initialize {})
  (slot accelerators-hook               initialize {})
  
  
  (method (prepare-exit));;abstract
  
  
  @convert-external
  (method meta (external-name . rest)
    'application)

  
  ;;;
  ;;;; Access
  ;;;


  (method public (get-toplevel)
    toplevel)


  (method public (get-stage)
    stage)


  (method public (get-menubar)
    menubar)


  (method public (set-menubar bar)
    (set! menubar bar))


  (method public (get-status-bar)
    status-bar)


  (method public (set-status-bar status)
    (set! status-bar status))


  (method public (get-user)
    user)


  ;;;
  ;;;; Startup
  ;;;
  
  
  @test-java
  (definition Java-Classpath
    '({File Native "C:" "Java" "j2sdk1.4.2_04" "jre" "lib" "rt.jar"}
      {File Native "C:" "Java" "BCEL" "lib" "bcel-5.1.jar"}
      {File Native "C:" "Java" "JDBC" "msbase.jar"}
      {File Native "C:" "Java" "JDBC" "msutil.jar"}
      {File Native "C:" "Java" "JDBC" "mssqlserver.jar"}))
  
  
  @test-java
  (method (test-java)
    (setup-jvm :classpath Java-Classpath)
    (c-test)
    (let* ((loader (getSystemClassLoader~ java.lang.ClassLoader))
           (class (forName~ java.lang.Class "yo" true loader)))
      (message-box (format "{a}" class))))


  (method (prepare-environment rest)
    (nextmethod rest)
    (set-application self)
    (setup-accelerators)
    @test-java
    (test-java)
    (let ((flat-look (new Flat-Look))
          (windows-look (new Windows-Look)))
      (set-looks (list flat-look windows-look))
      (set-look flat-look))
    (when (use-user?)
      (log-user)))

  
  (method (start-environment rest)
    (nextmethod rest)
    (setup-bindings)
    @windows-specific
    (initialize-dde)
    (initialize-messaging)
    (initialize-toplevel)
    @unimplemented
    (setup-repositories)
    @unimplemented
    (register-clipboard-formats))


  (method (finalize-environment rest)
    (nextmethod rest)
    (set-cursor :arrow)
    (splash-screen)
    (let ((pref (get-preferences {} :error? false)))
      (set-state~ (get-root~ toplevel) (if pref (get-toplevel-state~ pref) 'restored)))
    (when stage
      (install-wallpaper~ stage)))

  
  (method (setup-user rest)
    (when (and (use-user?) (use-user-class?))
      (create-user)
      (set-user-actions (get-class-actions user))))
  
  
  (method (finish-environment rest)
    (nextmethod rest)
    (add-save-environment-listener self)
    (when user
      (with-safe-execution "initing the user"
        (function dynamic ()
          (init~ user))
        :continue-handler
        (function dynamic (err)
          )))
    (reload-session)
    (remove-splash-screen))
  
  
  (method (conclude-environment rest)
    (nextmethod rest)
    (update-windowing-actions)
    (set-visible?~ toplevel true)
    (when user
      (with-safe-execution "finalizing the user"
        (function dynamic ()
          (finalize~ user))
        :continue-handler
        (function dynamic (err)
          ))))


  ;;;
  ;;;; Clipboard
  ;;;
  
  
  (method public virtual (clipboard-prefix)
    (format "{a}_{a}_"
            (process-name)
            (present~ (process-version))))
  
  
  (method protected virtual (register-clipboard-formats)
    (register-jazz-clipboard-formats))


  ;;;
  ;;;; Clipboard Stack
  ;;;

  
  (definition Clipboard-Stack
    null)
  
  (definition Max-Stack
    256)
  
  
  (method public (get-clipboard-stack)
    Clipboard-Stack)
  
  
  (method public (empty-clipboard-stack?)
    (null? Clipboard-Stack))
  
  
  (method public (add-clipboard)
    (set! Clipboard-Stack (cons (get-clipboard) Clipboard-Stack))
    (trim-clipboard))
  
  
  (method public (push-clipboard-list list)
    (let ((pushed (length list)))
      (if (> pushed Max-Stack)
          (error "Unable to push list of {a} onto the clipboard stack" pushed)
        (set! Clipboard-Stack (append list Clipboard-Stack))
        (trim-clipboard))))
  
  
  (method (trim-clipboard)
    (when (> (length Clipboard-Stack) Max-Stack)
      (set-cdr! (tail Clipboard-Stack (- Max-Stack 1)) null)))
  
  
  (method public (pop-clipboard)
    (let ((string (car Clipboard-Stack)))
      (set! Clipboard-Stack (cdr Clipboard-Stack))
      (set-clipboard string)
      string))
  
  
  (method public (on-paste-from-stack evt)
    (let ((focus (get-focus)))
      (if (is-not? focus Text-View)
          (bell)
        (if (null? Clipboard-Stack)
            (bell)
          (pop-clipboard))
        (paste-clipboard~ focus))))
  
  
  (method public (on-pop-clipboard-stack evt)
    (if (null? Clipboard-Stack)
        (bell)
      (let ((string (pop-clipboard)))
        (user-message "Popped {s} from clipboard stack" string))))

  
  ;;;
  ;;;; History
  ;;;
  
  
  (method public (on-add-history evt)
    (add-current~ history-manager))
  
  
  (method public (on-backward-history evt)
    (go-backward-history~ history-manager))
  
  
  (method public (on-forward-history evt)
    (go-forward-history~ history-manager))
  
  
  (method public (add-history item)
    (add-history~ history-manager item))
  
  
  (method (current-history-item)
    (let ((frame (current-frame)))
      (when frame
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (current-history-item~ guest))))))
  
  
  (method public (update-history-actions)
    (let ((backward (get-backward-history~ history-manager))
          (forward (get-forward-history~ history-manager)))
      (set-action-enabled? {Action application backward-history} backward)
      (set-action-enabled? {Action application forward-history} forward)))


  ;;;
  ;;;; Recording
  ;;;
  
  
  (method public virtual (get-recorder)
    {})


  ;;;
  ;;;; User
  ;;;
  
  
  (method protected virtual (use-user?)
    true)
  
  
  (method protected virtual (use-user-logging?)
    false)
  
  
  (method protected virtual (use-user-class?)
    false)
  
  
  (method (log-user)
    (let* ((user-arg (command-argument "user"))
           (user (cond (user-arg (standard-user user-arg))
                       ((use-user-logging?) (login-user))
                       (else (windows-user)))))
      (setup-user-file user)
      (setup-user-alias user)))
  
  
  (method (standard-user username)
    (cond ((not (use-user-class?))
           (new Directory (list 'Users username)))
          (else
           (new File (list 'Users username (format "{a}.jazz" username))))))
  
  
  (method (windows-user)
    (standard-user (get-windows-user-name)))

  
  (method (login-user)
    (let ((name "Guillaume"))
      (new File (list 'Users name (format "{a}.jazz" name))))
    @convert(
    (debug 'LOGIN)
    (if (or (command-argument "defaultstart") (get-system-property 'Default-Start?))
        (let ((name (either (command-argument "defaultuser") (get-system-property 'Default-User))))
          (new File (list 'Users name (format "{a}.jazz" name))))
      (get-modal Login-Dialog :use-user-class? (use-user-class?))
      @catch-syntax-not-implemented
      (catch (Cancel-Signal signal
               (exit))
        (get-modal Login-Dialog :use-user-class? (use-user-class?))))
    (debug 'LOGINDONE)))
  
  
  (method (setup-user-file user)
    (if (not (exists?~ user))
        (cond ((not (use-user-class?))
               (setup-new-user user (get-name~ user)))
              (else
               (setup-new-user (get-parent~ user) (get-base~ user))))
      (set! user-pathname user)))
  
  
  (method (setup-new-user directory name)
    (let ((expander (new Template-Expander))
          (associations (list (cons 'user name))))
      @convert
      (create-directories~ directory)
      @convert
      (copy-user-settings directory expander associations)
      (cond ((not (use-user-class?))
             (set! user-pathname directory))
            (else
             (let ((file (new-file~ directory (format "{a}.jazz" name))))
               @convert
               (copy-user file expander associations)
               (set! user-pathname file))))))
  
  
  (method (copy-user-settings directory expander associations)
    (let ((settings {Directory Home "Defaults" "Settings"}))
      (copy-directory~ settings (new-directory~ directory "Settings")
        :copier (function dynamic (src dst)
                  (copy-template src dst expander associations))
        :touch-files? true)))
  
  
  (method (copy-user file expander associations)
    (let ((template {File Home "Defaults" "User.jazz"}))
      (copy-template {File Home "Defaults" "User.jazz"} file expander associations)))
  
  
  (method (copy-template template destination expander associations)
    (with-closed ((printer (new File-Printer :pathname destination)))
      (expand~ expander template associations printer)))
  
  
  (method (setup-user-alias user)
    @convert/wait
    (set-alias 'User (cond ((not (use-user-class?))
                            (get-list~ user-pathname))
                           (else
                            (get-list~ (get-parent~ user-pathname))))))

  
  (method (create-user)
    (let ((user-name (string->symbol (get-base~ user-pathname))))
      @cannot-yet-use-because-the-exception-presenter-kicks-in-only-after-the-debugger-is-installed
      (with-execution-context
        (function dynamic ()
          (with-continue
            (function dynamic ()
              (set! user (new (load-source user-name user-pathname))))))
        :title "Create User")
      (with-safe-execution "creating the user"
        (function dynamic ()
          (set! user (new (case user-name
                            ;;(Guillaume (new Guillaume))
                            (else Guillaume))))
          @convert
          (set! user (new (load-source user-name user-pathname))))
        :continue-text (list (format "Press Continue to bypass this problem by using the generic User class instead of {a} to instantiate the user" user-name))
        :continue-handler
        (function dynamic (err)
          (set! user (new User))))))


  ;;;
  ;;;; Closing
  ;;;
  
  
  (method (preserve-environment)
    (nextmethod)
    (call-save-environment-listeners))
  
  
  (method (close-environment)
    ;; called before closing frames because saving a class form
    ;; can potentialy modify an opened text
    (call-exit-listeners)
    (confirm-all-close)
    (close-all)
    @windows-specific
    (uninitialize-dde)
    (save-bindings)
    (save-page-setup)
    (nextmethod))
      
  
  (method public (confirm-all-close)
    (let ((stage (get-stage))
          (frame-dependent-document?
           (function dynamic (frame)
             (and (is? frame View-Host)
                  (let ((guest (get-guest~ frame)))
                    (and (is? guest Document)
                         (let ((controller (get-controller~ guest)))
                           (dependent-document?~ controller))))))))
      (when stage
        (for-each (function dynamic (frame)
                    (unless (frame-dependent-document? frame)
                      (confirm-close~ frame)))
                  (get-children~ stage)))))
  
  
  (method (close-all)
    (let ((stage (get-stage)))
      (when stage
        (close-children~ stage))))
  
  
  (method (focus-exit)
    (validate-focus))


  ;;;
  ;;;; Splash
  ;;;
  
  
  (definition Splash-Screen
    {})
  
  (definition Splash-End
    {})
  
  
  (method protected virtual (splash-screen)
    )
  
  
  (method (show-splash-screen . rest)
    (bind-keywords ((duration {})) rest
      (set! Splash-Screen (show-splash))
      (set! Splash-End (essay duration (+ (clock) duration)))))
  
  
  (method (remove-splash-screen)
    (when Splash-Screen
      (let ((time (clock)))
        (when (and Splash-End (> Splash-End time))
          (sleep (- Splash-End time)))
        (remove-splash Splash-Screen))))
  
  
  (method protected virtual (show-splash)
    )
  
  
  (method protected virtual (remove-splash splash-screen)
    )


  ;;;
  ;;;; Help
  ;;;
  
  
  (method public (on-about evt)
    (show-about))
  
  
  (method public virtual (show-about)
    (let ((name (process-name))
          (owner (process-owner))
          (copyright (process-copyright))
          (licensee (process-licensee))
          (version (present~ (process-version)))
          (email (process-email)))
      (message-box
        (append!
         (list
          (list (list :font {Font :font-name "Times New Roman" :point-size 12 :bold? #t :italic? #f :underline? #f :monospace? #f} :color {Color name: Dark-Blue} (format "{a} v{a}" name version)))
          (list))
         (when owner
           (list
            (list (list :font {Font :font-name "Times New Roman" :point-size 10 :bold? #f :italic? #t :underline? #f :monospace? #f} (format "Copyright {a}{a}" (if copyright (format "{a} " copyright) "") owner)))
            (list)))
         (when licensee
           (list
            (list "This product is licensed to " (list licensee))
            (list)))
         (when email
           (list
            (list "Send comments, suggestions, bugs,... to:")
            (list email))))
        :title (format "About {a}" name))))


  ;;;
  ;;;; Exit
  ;;;
  

  (slot exit-listeners initialize '())
  
  
  (method public (add-exit-listener listener)
    (set! exit-listeners (cons listener exit-listeners)))
  
  
  (method public (remove-exit-listener listener)
    (set! exit-listeners (remove! listener exit-listeners)))
  
  
  (method public (call-exit-listeners)
    (for-each (function dynamic (listener)
                (prepare-exit~ listener))
              exit-listeners))


  ;;;
  ;;;; Activation
  ;;;
  
  
  (method public (get-active?)
    active?)
  
  
  (method public virtual (deactivate)
    (close-popups~ toplevel)
    (set! active? false)
    (invalidate-caption~ (get-root~ toplevel)))
  
  
  (method public virtual (activate)
    (set! active? true)
    (when toplevel
      (invalidate-caption~ (get-root~ toplevel)))
    ;; Necessary because verify-reloads can pop a dialog
    (if (mouse-clicked?)
        (set-delayed-mouse-action
          (function ()
            (verify-reloads)))
      (verify-reloads)))
  
  
  (method public (verify-reloads)
    (when stage
      (for-each (function dynamic (window)
                  (when (is? window Host-Frame)
                    (let ((guest (get-guest~ window)))
                      (when (is? guest Document)
                        (verify-reload~ (get-controller~ guest))))))
                (get-windows~ stage :include-invisibles? true))))
  
  
  (method public (verify-reload moniker)
    (let ((frame (find-document moniker)))
      (when frame
        (let ((document (get-guest~ frame)))
          (verify-reload~ (get-controller~ document))))))


  ;;;
  ;;;; Environment
  ;;;
  

  (slot save-environment-listeners initialize '())
  
  
  (method public (add-save-environment-listener listener)
    (set! save-environment-listeners (cons listener save-environment-listeners)))
  
  
  (method public (remove-save-environment-listener listener)
    (set! save-environment-listeners (remove! listener save-environment-listeners)))
  
  
  (method public (call-save-environment-listeners)
    (for-each (function dynamic (listener)
                (save-environment~ listener))
              save-environment-listeners))
  
  
  ;;;
  ;;;; Session
  ;;;
  
  
  (method public (reload-session)
    (reload-opened-windows))
  
  
  (method public virtual (reload-opened-windows)
    )
  
  
  (method public virtual (reload-component class properties)
    )

  
  (method (save-environment)
    (save-application)
    (save-all-guest))
  
  
  (method (save-application)
    (when preferences-root
      (set-property~ preferences-designer preferences-root :active-context context :branch {})
      (set-property~ preferences-designer preferences-root :current-directory (get-current-directory) :branch {})))
  
  
  (method (save-all-guest)
    @wait
    (let ((stage (get-stage)))
      (when stage
        (for-each (function dynamic (frame)
                    (when (is? frame Host-Frame)
                      (let ((guest (get-guest~ frame)))
                        (when guest
                          (save-guest~ guest session-designer session)))))
                  (get-children~ stage)))))

  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method public virtual (display-aliases?)
    true)
  
  
  (method public virtual (display-protocol?)
    true)
  
  
  (method public virtual (application-anchors)
    (map (function dynamic (alias)
           (new Directory (list alias)))
         (append! (gather-keys~ (get-aliases))
                  (let ((workbench (get-workbench)))
                    (if (not workbench)
                        {}
                      (gather-keys~ (get-products-hashtable~ workbench)))))))

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (add-focus-listener listener)
    (set! focus-listeners (add-listener listener focus-listeners)))
  
  
  (method public (remove-focus-listener listener)
    (set! focus-listeners (remove-listener listener focus-listeners)))

  
  (method public (process-focus-change old-focus new-focus)
    (when focus-listeners
      (let ((evt (new Focus-Event :focus-change self old-focus new-focus)))
        (for-each (function dynamic (listener)
                    (invoke~ listener self evt))
                  focus-listeners)))
    (update-focus-actions))
  
  
  (method public (update-focus-actions)
    (let* ((focus (get-focus))
           (view? (and focus (is? focus View))))
      (when preferences-root
        (set-action-enabled? {Action view undo} (and view? (can-undo?~ focus)))
        (set-action-enabled? {Action view redo} (and view? (can-redo?~ focus)))
        (set-action-enabled? {Action view cut} (and view? (can-cut?~ focus)))
        (set-action-enabled? {Action view copy} (and view? (can-copy?~ focus)))
        (set-action-enabled? {Action view paste} (and view? (can-paste?~ focus)))
        (set-action-enabled? {Action application paste-from-stack} (and view? (can-paste?~ focus) Clipboard-Stack))
        (set-action-enabled? {Action application pop-clipboard-stack} Clipboard-Stack)
        (set-action-enabled? {Action view paste-properties} (and view? (can-paste-properties?~ focus)))
        (set-action-enabled? {Action view delete} (and view? (can-delete?~ focus)))
        (set-action-enabled? {Action view select-all} (and view? (can-select-all?~ focus)))
        (when view?
          (focus-update-actions~ focus)))))
  
  
  ;;;
  ;;;; Selected
  ;;;
  
  
  (method public (add-selected-listener listener)
    (set! selected-listeners (add-listener listener selected-listeners)))
  
  
  (method public (remove-selected-listener listener)
    (set! selected-listeners (remove-listener listener selected-listeners)))
  
  
  (method public (get-selected)
    selected)
  
  
  (method public (get-selected-owner)
    selected-owner)
  
  
  (method public (set-selected owner sel . rest)
    (bind-keywords ((force? false)) rest
      (let ((new-owner? (neq? owner selected-owner)))
        (when (or force? new-owner? (/= sel selected))
          (process-selected-change owner selected sel force?)))))
  
  
  (method public (close-selected owner)
    (when (eq? owner selected-owner)
      (set! selected-owner {})
      (process-selected-change {} selected {} false)))

  
  (method (process-selected-change owner old-selected new-selected force?)
    (set! selected-owner owner)
    (set! selected new-selected)
    (when selected-listeners
      (let ((evt (new Selected-Event :selected-change self owner old-selected new-selected :force? force?)))
        (for-each (function dynamic (listener)
                    (invoke~ listener self evt))
                  selected-listeners))))

  
  ;;;
  ;;;; Application
  ;;;
  
  
  (method public (add-application-listener category listener)
    (set-application-listeners category (add-listener listener (get-application-listeners category))))
  
  
  (method public (remove-application-listener category listener)
    (set-application-listeners category (remove-listener listener (get-application-listeners category))))

  
  (method public (process-application-event category kind sender . properties)
    (let ((listeners (get-application-listeners category)))
      (let ((evt (apply new Application-Event kind sender properties)))
        (for-each (function dynamic (listener)
                    (invoke~ listener self evt))
                  listeners))))
  
  
  (method (get-application-listeners category)
    (hash-ref application-listeners category '()))
  
  
  (method (set-application-listeners category listeners)
    (hash-set! application-listeners category listeners))

  
  ;;;
  ;;;; Repository
  ;;;
  
  
  (method public (get-repositories-preferences)
    repositories-preferences)
  
  
  (method (setup-repositories)
    (load-repositories-preferences))
  
  
  (method (repositories-file)
    {File User "Settings" "Repositories.jml"})
  
  
  (method (load-repositories-preferences)
    (with-safe-execution "loading the repositories"
      (function dynamic ()
        (let ((file (repositories-file)))
          (when (exists?~ file)
            (let ((preferences (instantiate~ (read-from-file file))))
              (install-context preferences)
              (set! repositories-preferences preferences)))))))
  
  
  (method public virtual (get-repository-classes)
    null)

  
  ;;;
  ;;;; Frames
  ;;;


  (method public virtual (base-frame-class)
    {})
  
  
  (method public virtual (default-frame-class)
    {})


  (method public virtual (file-frame-class file)
    (let ((extension (get-extension~ file)))
      (either (extension-frame-class extension)
              (error "Unknown file extension .{a}" extension))))


  (method public virtual (extension-frame-class ext)
    (either (user-extension-frame-class ext)
            (known-extension-frame-class ext)
            (unknown-extension-frame-class)))
  
  
  (method (user-extension-frame-class ext)
    (when user
      (extension-frame-class~ user ext)))


  (method public virtual (known-extension-frame-class ext)
    {})
  
  
  (method public virtual (unknown-extension-frame-class)
    {})


  (method public virtual (frame-class . rest)
    (bind-keywords ((file {})) rest
      (if (not file)
          (default-frame-class)
        (file-frame-class file))))
  
  
  (method (get-default-frame-class)
    (let* ((pref (get-workspace-preferences))
           (model (get-frame-model~ pref)))
      (if model
          (autoload model)
        (default-frame-class))))

  
  ;;;
  ;;;; Messaging
  ;;;
  
  
  ;; tofix
  (method (initialize-messaging)
    @unimplemented
    (setup-messaging))

  
  ;;;
  ;;;; Toplevel
  ;;;
  
  
  (method (initialize-toplevel)
    (set! toplevel (new-toplevel))
    (ensure-displayed~ toplevel)
    (set! stage (stage-window~ toplevel))
    (initialize-actions))
  
  
  (method public virtual (new-toplevel)
    (new Toplevel))
  
  
  (method (initialize-actions)
    (set-application-actions (get-class-actions self)))
  
  
  ;;;
  ;;;; Accelerators
  ;;;
  
  
  (method (setup-accelerators)
    (set! accelerators-table (all-accelerators-table))
    (set! accelerators-handle (get-handle~ accelerators-table))
    (set! accelerators-dispatch (new-hashtable = =-hash)))
  
  
  (method (register-actions-shortcuts old-actions new-actions)
    (when accelerators-dispatch
      (for-each (function dynamic (actions)
                  (for-each (function dynamic (action-item)
                              (let ((shortcut (get-shortcut~ action-item)))
                                (when shortcut
                                  (hash-remove! accelerators-dispatch shortcut action-item))))
                            (get-children~ actions)))
                old-actions)
      (for-each-reversed (function dynamic (actions)
                           (for-each (function dynamic (action-item)
                                       (let ((shortcut (get-shortcut~ action-item)))
                                         (when shortcut
                                           (hash-add accelerators-dispatch shortcut action-item))))
                                     (get-children~ actions)))
                         new-actions)))
  
  
  (method public (update-accelerator action-item old-shortcut new-shortcut)
    (when old-shortcut
      (hash-remove! accelerators-dispatch old-shortcut action-item))
    (when new-shortcut
      (hash-add accelerators-dispatch new-shortcut action-item)))
  
  
  (method public (dispatch-shortcut shortcut)
    (if accelerators-hook
        (accelerators-hook shortcut)
      (let ((action-items (get-bound-actions shortcut)))
        (when action-items
          (invoke~ (car action-items) self {})
          true))))
  
  
  (method public (get-bound-actions shortcut)
    (hash-ref accelerators-dispatch shortcut {}))
  
  
  (method public (get-accelerators-hook)
    accelerators-hook)
  
  
  (method public (set-accelerators-hook value)
    (set! accelerators-hook value))
  
  
  ;;;
  ;;;; Bindings
  ;;;
  
  
  (method (setup-bindings)
    (with-safe-execution "loading the bindings"
      (function dynamic ()
        (set! bindings (load-bindings))
        (set! bindings-designer (new Designer form: (get-form~ bindings) :reference bindings))
        (let ((branch (locate-component~ bindings 'user)))
          (when (is? branch Branch)
            (set-active-branch~ bindings branch))))
      :continue-handler
      (function dynamic (err)
        )))
  
  
  (method protected virtual (load-bindings)
    (let ((file {File User "Settings" "Bindings.jml"}))
      (when (exists?~ file)
        (instantiate~ (read-from-file file)))))
  
  
  (method (save-bindings)
    (when (and bindings-designer (get-modified?~ bindings-designer))
      (save~ bindings-designer)))
  
  
  (method public (get-bindings)
    bindings)
  
  
  (method public (get-bindings-designer)
    bindings-designer)
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method public (set-application-actions actions-list)
    (register-actions-shortcuts application-actions actions-list)
    (set! application-actions actions-list))
  
  
  (method public (set-user-actions actions-list)
    (register-actions-shortcuts user-actions actions-list)
    (set! user-actions actions-list))


  (method public (set-guest-actions actions-list)
    (register-actions-shortcuts guest-actions actions-list)
    (set! guest-actions actions-list))
  
  
  (method public (set-focus-actions actions-list)
    (register-actions-shortcuts focus-actions actions-list)
    (set! focus-actions actions-list))

  
  ;;;
  ;;;; Menubar
  ;;;
  
  
  (method public (get-menubar-class)
    (let ((pref (get-preferences 'workspaces)))
      (when pref
        (let* ((classes (get-toolbar-classes~ pref))
               (model (cdr (assq :menubar classes))))
          (when model
            (autoload model))))))
  
  
  (method public (find-menubar)
    (let ((menubar-class (get-menubar-class)))
      (when menubar-class
        (find-palette~ (get-workspace-splitter~ toplevel) menubar-class))))
  
  
  (method public (update-menubar-buttons)
    (when menubar
      (update-buttons~ menubar)))

  
  ;;;
  ;;;; Status
  ;;;
  
  
  (definition Undisplayed-Message
    {})


  (method public (set-status-message msg)
    (let ((message (get-message-view)))
      (if (not message)
          (set! Undisplayed-Message msg)
        (set! Undisplayed-Message {})
        (set-title~ message (cond ((not msg) "")
                                  ((is? msg Locales) msg)
                                  (else (->string msg)))))))
  
  
  (method public (get-message-view)
    (when status-bar
      (find-component~ status-bar 'message)))
  
  
  (method public (show-undisplayed-message)
    (when Undisplayed-Message
      (set-status-message Undisplayed-Message)
      (set! Undisplayed-Message {})))

  
  ;;;
  ;;;; Messages
  ;;;

  
  (method (process-messages)
    (let ((msg (MSG-make))
          (hwnd (get-hwnd~ (get-toplevel))))
      ;; process messages from all windows
      (while (GetMessage msg NULL 0 0)
        (when (= (TranslateAccelerator hwnd accelerators-handle msg) 0)
          (TranslateMessage msg)
          (DispatchMessage msg)))))
  
  
  (method (process-one-message . rest)
    (bind-optionals ((window (get-toplevel))) rest
      (with ((msg (MSG-make)))
        (let ((hwnd (get-hwnd~ window)))
          (when (GetMessage msg hwnd 0 0)
            (when (= (TranslateAccelerator hwnd accelerators-handle msg) 0)
              (TranslateMessage msg)
              (DispatchMessage msg)))))))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method (class-actions)
    (cons (find-actions 'application)
          (nextmethod)))


  ;;;
  ;;;; Alias
  ;;;
  
  
  (method (process-alias name)
    (case name
      ((:application)  self)
      ((:toplevel)     (get-toplevel))
      ((:stage)        (get-stage))
      ((:wallpaper)    (get-root~ (get-stage)))
      ((:frame)        (current-frame))
      ((:document)     (current-document))
      ((:guest)        (current-guest))
      ((:focus-guest)  (focus-guest))
      ((:focus)        (get-focus))
      ((:user)         (get-user))
      ((:icons)        (get-icons-cache))
      ((:small-icons)  (get-small-icons-cache))
      ((:large-icons)  (get-large-icons-cache))
      ((:invite-icons) (get-invite-icons-cache))
      ((:banner-icons) (get-banner-icons-cache))
      (else            (nextmethod name))))
  
  
  ;;;
  ;;;; Menus
  ;;;
  
  
  (method public virtual (text-menu text)
    (new-text-context-menu~ text))


  ;;;
  ;;;; Message
  ;;;
  
  
  (method (show-box text rest)
    (if (not (get-bindings~ (get-application)))
        (system-message text rest)
      (ui-message-box text rest)))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public virtual (get-output-log)
    {})
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (definition All-Results
    {})
  
  (definition Active-Results
    {})
  
  
  (method public virtual (navigable-results)
    (must-implement 'navigable-results "results navigation"))
  
  
  (method (get-navigable-results)
    (unless All-Results
      (set! All-Results (navigable-results)))
    All-Results)
  
  
  (method public (get-active-results)
    (unless Active-Results
      (set! Active-Results (car (get-navigable-results))))
    Active-Results)
  
  
  (method public (set-active-results results)
    (set! Active-Results results))
  
  
  ;;;
  ;;;; Workspace
  ;;;
  
  
  (method public (on-select-workspace evt)
    (select-workspace (get-property~ evt :workspace)))
  
  
  (method public (on-next-workspace evt)
    (select-next-workspace))
  
  
  (method public (on-previous-workspace evt)
    (select-previous-workspace))
  
  
  (method public (on-workspace evt)
    (case (get-kind~ evt)
      ((activate)
       (let ((toolbar (find-toolbar)))
         (when toolbar
           (let* ((workspace (get-property~ evt :workspace))
                  (name (get-name~ workspace))
                  (radio (locate-component~ toolbar name)))
             (if (not radio)
                 (unselect-elements~ toolbar :class Radio-Tool :group 'workspace)
               (set-selected?~ radio true))))))))

  
  (method public (select-workspace name)
    (apply-preferences~ (get-preferences (list 'workspaces name))))
  
  
  (method public (select-next-workspace)
    (let* ((current (get-workspace-preferences))
           (workspaces (collect-type Workspace-Preferences (get-children~ (get-preferences 'workspaces))))
           (rank (find current workspaces :return 'position))
           (next (element workspaces (modulo (+ rank 1) (length workspaces)))))
      (unless (eq? next current)
        (apply-preferences~ next))))
  
  
  (method protected (select-previous-workspace)
    (let* ((current (get-workspace-preferences))
           (workspaces (collect-type Workspace-Preferences (get-children~ (get-preferences 'workspaces))))
           (rank (find current workspaces :return 'position))
           (previous-rank (if (= rank 0) (- (length workspaces) 1) (- rank 1)))
           (previous (element workspaces previous-rank)))
      (unless (eq? previous current)
        (apply-preferences~ previous))))
  
  
  (method public virtual (workspace-installed)
    )
  
  
  (method public (on-zoom-horizontally evt)
    (with-locked-update
      (function dynamic ()
        (let ((started? false))
          (call/ec
            (function (return)
              (for-each-splitter (get-stage-border)
                (function dynamic (splitter window)
                  (if (eq? (get-orientation~ splitter) 'vert)
                      (when started?
                        (return))
                    (if (= (get-state~ splitter) 'split)
                        (if (workspace-zoomable?~ splitter window)
                            (zoom~ splitter window)
                          (return))
                      (unzoom~ splitter))
                    (set! started? true))))))))))
  
  
  (method public (on-zoom-vertically evt)
    (with-locked-update
      (function dynamic ()
        (let ((started? false)
              (border (get-stage-border)))
          (call/ec
            (function (return)
              (for-each-splitter border
                (function dynamic (splitter window)
                  (if (eq? (get-orientation~ splitter) 'horz)
                      (when started?
                        (return))
                    (if (= (get-state~ splitter) 'split)
                        (zoom~ splitter window)
                      (unzoom~ splitter))
                    (set! started? true))
                  (when (eq? window border)
                    (return))))))))))
  
  
  (method public (on-maximize/restore evt)
    (let ((stage (get-stage)))
      (if (get-maximized?~ stage)
          (restore~ stage)
        (maximize~ stage))))
  
  
  (method public (on-full-screen evt)
    (let ((pref (get-preferences {})))
      (when (not (get-fullscreen-warned?~ pref))
        (message-box "Warning: There is currently only one way of exiting the fullscreen mode which is by using the Alt-Shift Backspace shortcut for Full Screen toggle")
        (set-property~ preferences-designer pref :fullscreen-warned? true)))
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (set-fullscreen?~ (selected-workspace) fullscreen?)
      (full-screen-stage fullscreen?)))
  
  
  (method public (full-screen-stage fullscreen?)
    (full-screen (get-stage-border) fullscreen?))
  
  
  (method public (toggle-full-screen window)
    (let ((fullscreen? (not (get-fullscreen?~ (get-toplevel)))))
      (full-screen window fullscreen?)))
  
  
  (method public (full-screen window fullscreen?)
    (let ((toplevel (get-toplevel))
          (stage (get-stage)))
      (when (neq? fullscreen? (get-fullscreen?~ toplevel))
        (with-locked-update
          (function dynamic ()
            (set-fullscreen?~ toplevel fullscreen?)
            (set-fullscreen?~ stage fullscreen?)
            (for-each-splitter window
              (function dynamic (splitter window)
                (set-full?~ splitter fullscreen?)
                (if fullscreen?
                    (zoom~ splitter window)
                  (unzoom~ splitter)))))))))


  ;;;
  ;;;; Toolbar
  ;;;
  
  
  (method public (get-toolbar-class)
    (let ((pref (get-preferences 'workspaces)))
      (when pref
        (let* ((classes (get-toolbar-classes~ pref))
               (model (cdr (assq :toolbar classes))))
          (when model
            (autoload model))))))
  
  
  (method public (find-toolbar)
    (let ((toolbar-class (get-toolbar-class)))
      (when toolbar-class
        (find-palette~ (get-workspace-splitter~ toplevel) toolbar-class))))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method (get-context-text)
    {})
   
  
  ;;;
  ;;;; Classes
  ;;;
  
  
  (method public virtual (get-text-class)
    Plain-Text-View)
  
  
  (method public virtual (get-explorer-class)
    (unimplemented 'get-explorer-class)
    @convert
    Explorer-View)


  ;;;
  ;;;; Icons
  ;;;
  
  
  (definition Icons-Cache
    {})
  
  (definition Small-Icons-Cache
    {})
  
  (definition Large-Icons-Cache
    {})
  
  (definition Invite-Icons-Cache
    {})
  
  (definition Banner-Icons-Cache
    {})
  
  
  (method public (get-icons-cache)
    (unless Icons-Cache
      (set! Icons-Cache (new Portfolio :width 16 :height 16)))
    Icons-Cache)
  
  
  (method public (get-small-icons-cache)
    (unless Small-Icons-Cache
      (set! Small-Icons-Cache (new Portfolio :width 12 :height 12)))
    Small-Icons-Cache)
  
  
  (method public (get-large-icons-cache)
    (unless Large-Icons-Cache
      (set! Large-Icons-Cache (new Portfolio :width 32 :height 32)))
    Large-Icons-Cache)
  
  
  (method public (get-invite-icons-cache)
    (unless Invite-Icons-Cache
      (set! Invite-Icons-Cache (new Portfolio :width 52 :height 52)))
    Invite-Icons-Cache)
  
  
  (method public (get-banner-icons-cache)
    (unless Banner-Icons-Cache
      (set! Banner-Icons-Cache (new Portfolio :width 1200 :height 200)))
    Banner-Icons-Cache)


  ;;;
  ;;;; Catalog
  ;;;


  (method public virtual (get-cataloguer)
    {})


  (method public virtual (get-catalog-context)
    {})


  ;;;
  ;;;; Feedback
  ;;;


  (method (display-boot-time launch-time)
    (user-message "Boot Time: {s} seconds"
                  (/ (- (clock) launch-time) (clocks/second))))

  
  (method (user-feedback message)
    )


  ;;;
  ;;;; Events
  ;;;
  

  (method (get-event-consumer)
    event-consumer)
  
  
  (method (set-event-consumer consumer)
    (set! event-consumer consumer))


  (method (deliver-event handler target proc event)
    (proc target event))


  (method public virtual (record-event? event)
    true)


  ;;;
  ;;;; Console
  ;;;


  (method public (fresh-prompt . rest)
    (bind-keywords ((text {}) (force? false)) rest
      (let ((text (either text (get-console-text))))
        (when text
          (fresh-prompt~ text :force? force?)
          (ensure-displayed~ text)))))
  
  
  (method public (on-console evt)
    (let ((had-focus? (is? (get-focus) Console-Text-View)))
      (show-console)
      (when had-focus?
        (fresh-prompt :force? true))))
  
  
  (method public (on-debugger evt)
    (let ((had-focus? (is? (get-focus) Debugger-Console-Text-View)))
      (show-console :class Debugger-Console-Manager)
      (when had-focus?
        (fresh-prompt :text (get-debugger-console-text) :force? true))))
  
  
  @waiting
  (method public (on-dialect-console evt)
    (let ((had-focus? (is? (get-focus) Dialect-Console-Text-View)))
      (show-console :class Dialect-Console-Manager)
      (when had-focus?
        (fresh-prompt :text (get-dialect-console-text) :force? true))))
  
  
  (method public (on-sql-console evt)
    (unimplemented 'on-sql-console)
    @convert-waiting
    (let ((had-focus? (is? (get-focus) SQL-Console-Text-View)))
      (show-console :class SQL-Console-Manager :workspace 'sql)
      (when had-focus?
        (fresh-prompt :text (get-sql-console-text) :force? true))))
  
  
  (method public (show-console . rest)
    (bind-keywords ((class Jazz-Console-Manager) (workspace 'home) (focus? true)) rest
      (let ((console (select-palette class :workspace workspace)))
        (when (and console focus?)
          (acquire-focus~ (get-text~ console))))))
  
  
  (method (on-sql-connections evt)
    (unimplemented 'on-sql-connections)
    @convert-waiting
    (select-palette SQL-Connections-Manager :workspace 'sql :focus? true))
  
  
  (method (on-sql-inventory evt)
    (unimplemented 'on-sql-inventory)
    @convert-waiting
    (select-palette Inventory-Browser :workspace 'sql :focus? true))
  
  
  (method (on-sql-tree-output evt)
    (unimplemented 'on-sql-tree-output)
    @convert-waiting
    (select-palette SQL-Tree-Output 'sql :focus? true))
  

  ;;;
  ;;;; Error
  ;;;
      
  
  @convert-error
  (method meta (log-error error output)
    (typecase error
      ((Read-Error) (log-read-error error output))
      ((Walk-Error) (log-walk-error error output))
      (else (log-generic-error error output))))
  
  
  @convert-error
  (method meta (edit-error error)
    (typecase error
      ((Read-Error) (edit-read-error error))
      ((Walk-Error) (edit-walk-error error))
      (else (edit-generic-error error))))
  
  
  @convert-error
  (method meta (edit-error-child error info)
    (typecase error
      ((Read-Error) (edit-read-error-child error info))
      ((Walk-Error) (edit-walk-error-child error info))
      (else (edit-generic-error-child error info))))

  
  @convert-error
  (method meta (log-generic-error error output)
    (log-line~ output (get-message~ error) :image {Bitmap-Resource "Error"} :user-data error))

  
  @convert-error
  (method meta (edit-generic-error error)
    (bell))
  
  
  @convert-error
  (method meta (edit-generic-error-child error info)
    (bell))


  ;;;
  ;;;; Read-Error
  ;;;
  
  
  @convert-error
  (method (report-read-error exception)
    (let* ((message (present-message~ exception))
           (yes "Show Me")
           (no "Ignore")
           (code (message-box message
                              :type 'message
                              :title "Read Error"
                              :yes yes
                              :no no)))
      (when (= code 'yes)
        (edit-read-error exception))
      (stop-debugging)))

  
  @convert-error
  (method meta (present-read-error error prefix? active-content?)
    (let* ((source (get-source~ error))
           (header (format "Read error found in {a}" (if (string? source) "string" (get-base~ (get-source~ error)))))
           (message (get-message~ error)))
      (list header
            (let ((action
                   (function ()
                     (close-modal-dialog
                       (function ()
                         (edit~ error))))))
              (list :bulleted (if active-content? (list :hyperlink action message) message))))))
  
  
  @convert-error
  (method meta (log-read-error error output)
    (log-line~ output (get-message~ error) :image {Bitmap-Resource "ReadError"} :user-data error))
  
  
  @convert-error
  (method meta (edit-read-error error)
    (let ((source (get-source~ error))
          (start (get-start~ error))
          (end (get-end~ error)))
      (if (string? source)
          (message-box source :selection (new Range start end))
        (edit-document~ (get-application) source :selection (new Range start end)))))
  
  
  @convert-error
  (method meta (edit-read-error-child error info)
    (edit-generic-error-child error info))


  ;;;
  ;;;; Walk-Error
  ;;;
  
  
  @convert-error
  (method (report-walk-error exception)
    (let* ((message (present-message~ exception))
           (yes "Highlight")
           (no "Ignore")
           (code (message-box message
                              :type 'message
                              :title "Walk Error"
                              :yes yes
                              :no no)))
      (when (= code 'yes)
        (highlight-walk-problems exception))
      (stop-debugging)))
  
  
  @convert-error
  (method meta (present-walk-error error prefix? active-content?)
    (let* ((problems (get-problems~ error))
           (count (length problems))
           (header (format "{a} walk error{a} found in {a}"
                           count
                           (format-plural count)
                           (get-unit-name~ error))))
      (cons header
            (map (function dynamic (problem)
                   (let ((message (walk-problem-message problem)))
                     (let ((action
                            (function ()
                              (close-modal-dialog
                                (function ()
                                  (edit-child~ error problem))))))
                       (list :bulleted (if active-content? (list :hyperlink action message) message)))))
                 problems))))
  
  
  @convert-error
  (method meta (log-walk-error error output)
    (let ((row (log-line~ output (get-message~ error) :state 'expanded :image {Bitmap-Resource "WalkError"} :user-data error)))
      (for-each (function dynamic (problem)
                   (let ((message (walk-problem-message problem))
                         (declarations (walk-problem-declarations problem)))
                    (log-line~ output (format "{a} -> {l}" message declarations) :father row :image {Bitmap-Resource "Red"} :user-data (cons error problem))))
                (get-problems~ error))))

  
  @convert-error
  (method meta (edit-walk-error error)
    (edit-generic-error error))

  
  @convert-error
  (method meta (edit-walk-error-child error problem)
    (let ((message (walk-problem-message problem)))
      (user-message "{a}" message)
      (let ((location (edit-walk-problem problem)))
        (when location
          (bind-values (frame text range) location
            (let ((text (get-guest~ frame)))
              (set-selection~ text range)
              (bring-to-front~ frame)
              (set-visible?~ frame true)
              (acquire-focus~ text)))))))
  
  
  @convert-error
  (method meta (edit-walk-problem problem)
    (let ((declarations (walk-problem-declarations problem)))
      (bind-values (resolved? in-context? toplevel-closure object) (resolve-location~ Interpreter declarations)
        (when (and object (definition? object))
          (let ((value (definition-value object)))
            (when (closure? value)
              (let ((location (object-location~ Interpreter problem (closure-function~ Interpreter value))))
                (when location
                  (find-location~ (new Jazz-Code-Location location))))))))))
  
  
  @convert-error
  (method (highlight-walk-problems exception)
    (let ((problems (get-problems~ exception))
          (first-text)
          (first-row {}))
      (for-each (function dynamic (problem)
                  (let ((severity (walk-problem-severity~ Interpreter problem))
                        (message (walk-problem-message~ Interpreter problem))
                        (location (edit-walk-problem problem)))
                    (when location
                      (bind-values (frame text range) location
                        (let ((text (get-guest~ frame))
                              (row [row start range]))
                          (when (or (not first-row) (< row first-row))
                            (set! first-text text)
                            (set! first-row row))
                          (let ((style (case severity
                                         ((warning) 'Walk-Warning)
                                         ((fatal) 'Walk-Fatal))))
                            (apply-style~ text style (get-start~ range) (get-end~ range)))
                          (bring-to-front~ frame)
                          (set-visible?~ frame true)
                          (acquire-focus~ text))))))
                problems)
      (when first-row
        (ensure-cell-displayed~ first-text (new Cell first-row 0)))))


  ;;;
  ;;;; Debugger
  ;;;
  
  
  (method (exception-reported)
    ;; so as not to get recursive exceptions
    (catch Exception
      (cleanup-mouse-processing)))
  
  
  (method (present-execution-context exception type prefix?)
    (present~ (new Exception-Presenter) exception :type type :prefix? prefix?))

  
  ;;;
  ;;;; Search
  ;;;
  
  
  (method public virtual (get-search-manager)
    )
  
  
  (method public virtual (get-search-results)
    (get-guest~ (singleton-docked Search-Results {})))
  
  
  (method public (active-search)
    (let ((manager (get-search-manager)))
      (when manager
        (get-search~ (get-guest~ manager)))))
  
  
  ;; This needs cleanup as it cannot be done for every application
  (method public (update-search-actions)
    (let* ((stage (get-stage))
           (frames (if (not stage) null (get-windows~ stage)))
           (count (length frames))
           (results (get-search-results))
           (results-count (get-visible-count~ (get-tree~ results)))
           (results-stack-count (length (get-results-stack~ results)))
           (in-modal? (in-modal?)))
      (set-action-enabled? {Action application edit-next} (>= results-count 1))
      (set-action-enabled? {Action application edit-previous} (>= results-count 1))
      (set-action-enabled? {Action application edit-current} (>= results-count 1))
      (set-action-enabled? {Action application pop-results} (> results-stack-count 1))
      (set-action-enabled? {Action application find-forward} (>= count 1))
      (set-action-enabled? {Action application find-backward} (>= count 1))
      (set-action-enabled? {Action application replace} (>= count 1))
      (set-action-enabled? {Action application replace&find-forward} (>= count 1))
      (set-action-enabled? {Action application replace-all} (>= count 1))
      (set-action-enabled? {Action application replace-all-selected} (>= results-count 1))))


  ;;;
  ;;;; Search Menu
  ;;;
  
  
  (method public (on-find evt)
    (update-search (function (search) (next-tab~ search)) 'active-window))
  
  
  (method public (on-find-in-files evt)
    (update-search (function (search) (next-radio~ search)) 'jazz-files))
  
  
  (method (update-search proc domain)
    (let* ((focus (get-focus))
           (internal? (is? focus Tree-Embedded-Search-Text-View))
           (string (if (and (not internal?) (is? focus Text-View)) (get-selected-string~ focus) {}))
           (palette (get-search-manager))
           (manager (get-guest~ palette))
           (search (get-search~ manager)))
      (when internal?
        (let ((tree (get-targets-tree~ search)))
          (end-edition~ tree)))
      (when (eq? (get-window-focus) palette)
        (proc search))
      (when (not (get-visible?~ palette))
        (bring-search-with-domain palette manager 'text domain))
      (for-each (function dynamic (search)
                  (let ((targets (get-search-targets~ search)))
                    (unless (or (not string)
                                (and (not-null? targets)
                                     (equal? string (first (first targets)))))
                      (set-search-targets~ search (list (list string ""))))))
                (get-searches~ manager))
      (select-search~ (get-search~ manager))))
  
  
  (method public (end-search-edition)
    (let* ((palette (get-search-manager))
           (manager (get-guest~ palette))
           (search (get-search~ manager))
           (tree (get-targets-tree~ search)))
      (end-edition~ tree)))
  
  
  (method (bring-search-with-domain palette manager tab domain)
    (set-selection-name~ (locate~ manager 'tab) tab)
    (let ((search (get-search~ manager)))
      (set-search-domain~ search domain)
      (bring-to-front~ palette)
      (set-visible?~ palette true)))


  (method public (on-edit-next evt)
    (edit-next~ (get-active-results)))


  (method public (on-edit-previous evt)
    (edit-previous~ (get-active-results)))


  (method public (on-edit-current evt)
    (edit-current~ (get-active-results)))


  (method public (on-pop-results evt)
    (clear-results~ (get-search-results)))


  (method public (on-find-forward evt)
    (let ((search (active-search)))
      (if (not search)
          (unless (select-next~ (get-text-view~ (get-guest~ (first-child~ stage))) (get-find-targets))
            (bell))
        (on-find-forward~ search evt))))


  (method public (on-find-backward evt)
    (let ((search (active-search)))
      (if (not search)
          (unless (select-previous~ (get-text-view~ (get-guest~ (first-child~ stage))) (get-find-targets))
            (bell))
        (on-find-backward~ search evt))))


  (method public (on-replace evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace~ search evt))))


  (method public (on-replace&find-forward evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace&find-forward~ search evt))))


  (method public (on-replace-all evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace-all~ search evt))))


  (method public (on-replace-all-selected evt)
    (let ((search (active-search)))
      (if (not search)
          (bell)
        (on-replace-all-selected~ search evt))))
  
  
  (method public (on-quick-find evt)
    (let* ((quick-find (get-quick-find))
           (text (get-text~ quick-find)))
      (if (= (get-focus) text)
          (let ((frame (first-child~ stage)))
            (if (is-not? frame Host-Frame)
                (bell)
              (let ((guest (get-guest~ frame)))
                (if (is-not? guest Document)
                    (bell)
                  (focus-document~ guest)))))
        (acquire-focus~ text))))
  
  
  (method public virtual (get-quick-find)
    (locate~ (find-toolbar) 'quick-find))


  ;;;
  ;;;; Search Context
  ;;;


  (method public (get-search-targets)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Targets)
        (get-search-targets~ search))))
  
  
  (method public (set-search-targets targets)
    (let ((search (active-search)))
      (if (not search)
          (set-system-property 'Search-Targets targets)
        (set-search-targets~ search targets))))


  (method public (get-find-targets)
    (map first (get-search-targets)))


  (method public (get-replace-targets)
    (map second (get-search-targets)))

  
  (method public (get-whole-words?)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Whole-Words?)
        (get-whole-words?~ search))))
    
  
  (method public (get-ignore-case?)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Ignore-Case?)
        (get-ignore-case?~ search))))
    
  
  (method public (get-preserve-case?)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Preserve-Case?)
        (get-preserve-case?~ search))))
    
  
  (method public (get-play-recording?)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Play-Recording?)
        (get-play-recording?~ search))))

  
  (method public (get-expression?)
    (let ((search (active-search)))
      (if (not search)
          (get-system-property 'Search-Expression?)
        (get-expression?~ search))))


  ;;;
  ;;;; DDE
  ;;;
  
  
  @windows-specific
  (definition meta public DDE-Instance
    {})
  
  @windows-specific
  (definition meta public Application-Service
    {})
  
  @windows-specific
  (definition meta public System-Topic
    {})
  
  
  @windows-specific
  (method (initialize-dde)
    (bind-values (err instance) (DdeInitialize 0 (get-dde-callback) APPCLASS_STANDARD 0)
	  (when (= err DMLERR_NO_ERROR)
        (set! DDE-Instance instance)
        (set! Application-Service (DdeCreateStringHandle DDE-Instance (process-name) CP_WINUNICODE))
        (set! System-Topic (DdeCreateStringHandle DDE-Instance "System" CP_WINUNICODE))
        (DdeNameService DDE-Instance Application-Service NULL DNS_REGISTER))))
  
  
  @windows-specific
  (method (uninitialize-dde)
    (when DDE-Instance
      (DdeNameService DDE-Instance Application-Service NULL DNS_UNREGISTER)
      (DdeUninitialize DDE-Instance)))


  ;;;
  ;;;; Files
  ;;;


  (method public virtual (on-new evt)
    (new-event (get-default-frame-class)))
    

  (method public virtual (on-open evt)
    (open-files))
  
  
  (method public (open-files . rest)
    (bind-keywords ((directory {})) rest
      (let ((files (get-modal OpenFile-Dialog :directory directory :extensions (open-extensions) :multiple-selection? true)))
        (for-each edit-file
                  (sort > files :key (function dynamic (file) (get-name~ file)))))))
  
  
  (method public virtual (receive-files pos pathnames)
    (if (and (= (length pathnames) 1) (directory? (car pathnames)))
        (let* ((dir (car pathnames))
               (filename (parse~ dir)))
          (set-current-directory filename)
          (user-message "Current directory set to {a}" filename))
      (let ((class (cond ((alt-down?) Jazz-Plain-Text-View)
                         ((shift-down?) Jazz-Text-View)
                         (else {}))))
        (for-each (function dynamic (pathname)
                    (when (file? pathname)
                      (if class
                          (edit-document pathname :class class)
                        (edit-file pathname))))
                  pathnames))))
  
  
  (method public virtual (edit-file file)
    (edit-document file))
  
  
  ;; a quicky... this should really be up to the current workspace
  (method public virtual (open-extensions)
    {})


  (method public (find-document moniker)
    (find-if (function dynamic (frame)
               (and (is? frame Host-Frame)
                    (let ((guest (get-guest~ frame)))
                      (and (is? guest Document)
                           (let ((guest-moniker (get-moniker~ (get-controller~ guest))))
                             (and guest-moniker
                                  (pathname= guest-moniker moniker)))))))
             (get-children~ stage)))
  
  
  (method public (edit-document moniker . rest)
    (bind-keywords ((class {}) (workspace {}) (selection {}) (wrap? false) (force-new? false) (activate-focus? true) (visible? true) (return-new? false)) rest
      (when moniker
        (if (not (exists?~ moniker))
            (error "Unable to locate document: {t}" moniker)
          (let ((file moniker))
            @ejb-to-convert
            (when (is? moniker Zipped)
              (set! file (get-file~ moniker))
              (set! selection (cons (get-entry~ moniker) selection)))
            (let* ((frame (if force-new? {} (find-document file)))
                   (result (function dynamic (frame new?) (if return-new? (values frame new?) frame))))
              (if (not frame)
                  (let ((class (either class (file-frame-class file))))
                    (with-cursor :wait
                      (function dynamic ()
                        (result (new-frame class
                                  :host-workspace workspace
                                  :host-visible? visible?
                                  :host-focus? activate-focus?
                                  :initialize (function dynamic (host document)
                                                (let ((timer (new Timer)))
                                                  (set-moniker~ (get-controller~ document) moniker)
                                                  @testing-speed
                                                  (when (typed? self 'IDE)
                                                    (report-duration~ timer)))
                                                (when wrap?
                                                  (set-wrap?~ document true))
                                                (when selection
                                                  (set-selection~ document selection))))
                                true))))
                (when selection
                  (set-selection~ (get-guest~ frame) selection))
                (when visible?
                  (bring-to-front~ frame)
                  (set-visible?~ frame true)
                  (when activate-focus?
                    (acquire-focus~ frame)))
                (verify-reload~ (get-controller~ (get-guest~ frame)))
                (result frame false))))))))
  
  
  (method public (edit-help-document moniker)
    (let* ((frame (edit-document moniker))
           (text (get-guest~ frame)))
      (set-editable?~ text false)))
  
  
  (method public (edit-filename filename)
    (let* ((workbench (get-workbench))
           (project-file (find-filename~ workbench filename)))
      (if (not project-file)
          (error "Unable to locate filename: {t}" filename)
        (let* ((frame (edit-document (get-source~ project-file)))
               (text (get-guest~ frame)))
          (verify-reload~ (get-controller~ text))))))
  
  
  (method public virtual (edit-unit name)
    )
  
  
  (method public (browse-url url)
    (let ((frame (find-explorer-frame url)))
      (if (not frame)
          (let* ((frame (new-frame (get-explorer-class) :host-visible? false))
                 (explorer (get-guest~ frame)))
            (set-url~ explorer url)
            (bring-to-front~ frame)
            (set-visible?~ frame true)
            frame)
        (let ((explorer (get-guest~ frame)))
          (refresh~ explorer)
          (bring-to-front~ frame)
          (set-visible?~ frame true)
          frame))))


  (method public (find-explorer-frame url)
    (unimplemented 'find-explorer-frame)
    @convert
    (let ((string (parse~ url)))
      (find-if (function dynamic (frame)
                 (and (is? frame Host-Frame)
                      (let ((guest (get-guest~ frame)))
                        (and (is? guest Explorer-View)
                             (= (get-current-url~ (get-site~ (get-browser~ guest))) string)))))
               (get-children~ stage))))
  
  
  (method public virtual (on-close evt)
    (let ((frame (first-window~ stage)))
      (when frame
        (validate-focus)
        (send-message~ frame WM_CLOSE 0 0))))

  
  (method public virtual (on-close-all evt)
    (for-each (function dynamic (window)
                (when (is? window Host-Frame)
                  (let ((guest (get-guest~ window)))
                    (when (and (is? guest Document) (close-on-close-all?~ (get-controller~ guest)))
                      (confirm-close~ window)
                      (close~ window)))))
              (get-windows~ stage)))
        
    
  (method public virtual (on-save-all evt)
    (save-all))
  
  
  (method public virtual (on-print evt)
    (let ((guest (current-guest)))
      (print-document~ guest)))

   
  (method public virtual (on-print-layout evt)
    (let ((guest (current-guest)))
      (print-layout~ guest)))

  
  (method public virtual (on-print-preview evt)
    (let ((guest (current-guest)))
      (print-preview~ guest)))
  
  
  (method public virtual (on-exit-application evt)
    (exit-process))
  
  
  (method public (save-all . rest)
    (bind-keywords ((class Document) (save-unanchored? true)) rest
      (let ((save-documents
             (function dynamic (main-documents?)
               (for-each (function dynamic (window)
                           (when (is? window Host-Frame)
                             (let ((guest (get-guest~ window)))
                               (when (is? guest Document)
                                 (let ((controller (get-controller~ guest)))
                                   (when (and (is? guest class)
                                              (or save-unanchored? (get-moniker~ guest))
                                              (xor main-documents? (dependent-document?~ controller))
                                              (get-modified?~ (get-controller~ guest)))
                                     (save~ guest)))))))
                         (get-windows~ stage :include-invisibles? true)))))
        ;; saving dependent documents will make their main document modified
        (save-documents false)
        (save-documents true))))


  ;;;
  ;;;; Definitions
  ;;;

  
  (method public virtual (edit-definition object . rest)
    )

  
  (method public virtual (edit-references object . rest)
    )


  ;;;
  ;;;; Context
  ;;;
  
  
  (method (context-update)
    (nextmethod)
    (modify-catalogs)
    (modify-user)
    (user-message "Context set to {a}" context))
  
  
  (method (modify-catalogs)
    (let ((pref (get-preferences 'catalogs :error? false)))
      (when pref
        (let ((cataloguer (get-cataloguer)))
          (for-each (function dynamic (config)
                      (let* ((name (get-name~ config))
                             (catalog (get-catalog~ cataloguer name :error? false)))
                        (when catalog
                          (set-active?~ catalog (get-active?~ config)))))
                    (get-children~ pref))))))

  
  (method (modify-user)
    (when user
      (close~ user))
    (let ((pref (get-preferences {} :error? false)))
      (when pref
        (let ((class (either (get-user-class~ pref) User)))
          (when class
            (set! user (new (autoload class)))))))
    (when user
      (init~ user))
    (when user
      (finalize~ user)))
  

  ;;;
  ;;;; Favorites
  ;;;

  
  (method (on-add-to-favorites evt)
    (let ((guest (current-document)))
      (if (not guest)
          (bell)
        (add-to-favorites~ guest))))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (definition Default-Page-Setup
    {})
  
  (definition Default-Page-Setup-Designer
    {})
  
  (definition Default-Page-Setup-Form
    (form>>
      (<Page-Setup>)))
  
  (definition Default-Page-Setup-File
    {File User "Settings" "PageSetup.jml"})
  
  
  (method public (default-page-setup)
    (when (not Default-Page-Setup)
      (setup-page-setup))
    Default-Page-Setup)
  
  
  (method public (default-page-setup-designer)
    (when (not Default-Page-Setup-Designer)
      (setup-page-setup))
    Default-Page-Setup-Designer)
  
  
  (method (setup-page-setup)
    (let* ((file Default-Page-Setup-File)
           (form (if (exists?~ file) (read-from-file file) Default-Page-Setup-Form)))
      (set! Default-Page-Setup (instantiate~ form))
      (set! Default-Page-Setup-Designer (new Designer form: (get-form~ Default-Page-Setup) :reference Default-Page-Setup))))
  
  
  (method (save-page-setup)
    (when Default-Page-Setup-Designer
      (let ((form (get-form~ Default-Page-Setup-Designer)))
        (when (not (get-origin~ form))
          (set-origin~ form Default-Page-Setup-File)))
      (save~ Default-Page-Setup-Designer)))


  ;;;
  ;;;; Documentation
  ;;;
  
  
  (method public virtual (get-documentation-cataloguer)
    {})
  
  
  ;;;
  ;;;; Scaling
  ;;;
  
  
  (method (on-zoom-out evt)
    (let ((view (scaled-view (get-property~ evt :what))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (- scaling 0.25) true)))))
  
  
  (method (on-zoom-in evt)
    (let ((view (scaled-view (get-property~ evt :what))))
      (if (not view)
          (bell)
        (let ((scaling (get-scaling~ view)))
          (scale-view view (+ scaling 0.25) true)))))
  
  
  (method (on-unzoom evt)
    (let ((view (scaled-view (get-property~ evt :what))))
      (if (not view)
          (bell)
        (scale-view view 1.0 false))))
  
  
  (method (scaled-view what)
    (case what
      ((document) (current-document))
      ((mouse-view) (mouse-view))))
  
  
  (method (scale-view view scaling scaled?)
    (user-message "Scaling set to {a}" scaling)
    (set-scaling~ view scaling)
    (set-scaled?~ view scaled?))



  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (on-capture-document evt)
    (pick-figure
      (function dynamic (window position view pos)
        (let ((player (get-player~ view)))
          (when (is? player View-Host)
            (let ((guest (get-guest~ view)))
              (when guest
                (export-picture~ guest))))))
      :draw-overlays? true
      :feedback true
      :feedback-figure? false
      :report-figure? false
      :tooltips? false))
  
  
  (method (on-capture-root evt)
    (pick-figure
      (function dynamic (window position view pos)
        (let ((root (get-root~ view)))
          (export-picture~ root)))
      :draw-overlays? true
      :feedback true
      :feedback-figure? false
      :report-figure? false
      :tooltips? false))


  ;;;
  ;;;; Windows
  ;;;
  
  
  (method public virtual (update-windowing-actions)
    )
  
  
  (method public (update-window-actions)
    (let ((stage (get-stage)))
      (when stage
        (let* ((frames (get-windows~ stage))
               (count (length frames))
               (in-modal? (in-modal?)))
          (set-action-enabled? {Action application close}             (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application close-all}         (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action guest save}                    (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action guest save-as}                 (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application save-all}          (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action guest revert-saved}            (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action guest compare-saved}           (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application page-setup}        (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application print-layout}      (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application print-preview}     (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application print}             (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application next-window}       (and (>= count 2) (not in-modal?)))
          (set-action-enabled? {Action application previous-window}   (and (>= count 2) (not in-modal?)))
          (set-action-enabled? {Action application current-window}    (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application toggle-window}     (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application cascade}           (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application tile-horizontally} (and (>= count 2) (not in-modal?)))
          (set-action-enabled? {Action application tile-vertically}   (and (>= count 2) (not in-modal?)))
          (set-action-enabled? {Action application minimize-all}      (and (>= count 1) (not in-modal?)))
          (set-action-enabled? {Action application restore-all}       (and (>= count 1) (not in-modal?)))))))
  
  
  (method public virtual (on-next-window evt)
    (let* ((stage (get-stage))
           (first (first-window~ stage)))
      (send-to-back~ first)
      (acquire-focus~ (current-frame))))
  
  
  (method public virtual (on-previous-window evt)
    (let* ((stage (get-stage))
           (last (last-window~ stage)))
      (bring-to-front~ last)
      (acquire-focus~ (current-frame))))
  
  
  (method public virtual (on-current-window evt)
    (let* ((stage (get-stage))
           (first (first-window~ stage)))
      (acquire-focus~ first)))
  
  
  (method public virtual (on-toggle-window evt)
    (let ((text (current-document)))
      (if (is? text Text-View)
          (toggle-text text)
        (bell))))


  (method (toggle-text text)
    (let ((file (get-moniker~ (get-controller~ text))))
      (if (not file)
          (bell)
        (let ((ext (get-extension~ file)))
          (cond ((member? ext Cpp-Extensions :test ci=) (toggle-c++-text file))
                ((ci= ext "jazz") (toggle-jazz-text file))
                (else (bell)))))))
  
  
  (method (toggle-c++-text file)
    (let* ((base (get-base~ file))
           (ext (get-extension~ file))
           (toggled (if (ci= ext "h") "cpp" "h"))
           (filename (format "{a}.{a}" base toggled)))
      (edit-filename filename)))
  
  
  (method (toggle-jazz-text file)
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench file))
           (project (get-product~ project-file)))
      (if (is-not? project (autoload 'Project))
          (bell)
        (let* ((c++ (get-source-file~ project (get-name~ project-file) false))
               (frame (edit-document c++))
               (text (get-guest~ frame)))
          (verify-reload~ (get-controller~ text))))))
  
  
  (method public virtual (on-cascade evt)
    (let* ((stage (get-stage))
           (frames (get-windows~ stage)))
      (unimplemented 'on-cascade)))
  
  
  (method public virtual (on-tile-horizontally evt)
    (let* ((stage (get-stage))
           (frames (get-windows~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (h (quotient height count))
           (t 0))
      (with-locked-update
        (function dynamic ()
          (restore~ stage)
          (for-each (function dynamic (frame)
                      (set-position~ frame (new Point 0 t))
                      (set-size~ frame (new Dimension width h))
                      (increase! t h))
                    frames)))))
  
  
  (method public virtual (on-tile-vertically evt)
    (let* ((stage (get-stage))
           (frames (get-windows~ stage))
           (count (length frames))
           (width (get-width~ stage))
           (height (get-height~ stage))
           (w (quotient width count))
           (l 0))
      (with-locked-update
        (function dynamic ()
          (restore~ stage)
          (for-each (function dynamic (frame)
                      (set-position~ frame (new Point l 0))
                      (set-size~ frame (new Dimension w height))
                      (increase! l w))
                    frames)))))
    
  
  (method public virtual (on-minimize-all evt)
    @windows-specific
    (let* ((stage (get-stage))
           (windows (get-windows~ stage)))
      (for-each (function dynamic (window)
                  (show-window~ window SW_MINIMIZE))
                windows)))
    
  
  (method public virtual (on-restore-all evt)
    @windows-specific
    (let* ((stage (get-stage))
           (windows (get-windows~ stage)))
      (for-each (function dynamic (window)
                  (show-window~ window SW_RESTORE))
                windows)))
    
  
  (method public virtual (on-select-window evt)
    @windows-specific
    (let ((window (get-property~ evt :window)))
      (unless (is? window Palette)
        (show-window~ window SW_RESTORE))
      (bring-to-front~ window)
      (acquire-focus~ window)))))
