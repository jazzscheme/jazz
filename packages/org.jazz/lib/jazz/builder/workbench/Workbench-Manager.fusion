;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Workbench Manager
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.workbench.Workbench-Manager jazz


(import (jazz.builder)
        (jazz.designer)
        (jazz.jml)
        (jazz.platform)
        (jazz.process)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.literals)
        (jazz.library)
        (jazz.utilities))


(definition active-project
  {})


(definition public (get-active-project)
  active-project)


;;;
;;;; Policy
;;;


(definition public Current-Policy
  'Distribution)


(definition public (get-current-policy)
  Current-Policy)


(definition public (set-current-policy policy)
  (set! Current-Policy policy))


(definition public (current-policy)
  (get-preferences (list 'build 'policies Current-Policy)))


(class Workbench-Manager extends Editor-View implements Exit-Listener


  (form
    (<install>                                     size: {Dimension 650 400} layout-type: border
      (<Layout-View>      name: tools
        (<Push-Combo>     name: build
          (<!>            name: body               portfolio: :icons image-name: {Bitmap-Resource "Build"} tooltip?: #t tooltip-text: "Build" action-handler: {Event-Handler form: on-build-current})
          (<!>            name: pick               action-handler: {Event-Handler form: on-policies-menu}))
        (<Push-Tool>      name: highlight-document size: {Dimension 22 22} tooltip?: #t tooltip-text: "Highlight Document" image-name: {Bitmap-Resource "Synchronize"} portfolio: :icons action-handler: {Event-Handler form: on-highlight-document})
        )
      (<Workbench-Editor> name: descendants        location: center
        (<!>              name: scroller           flat?: #t)
        (<!>              name: tree               show-header?: #f highlight-edited?: #f
          (<!>            name: descendant         title: "Project" width: 291 highlight-color: {Color name: Dark-Blue})))))
  
  
  @convert-external
  (method meta (external-name . rest)
    'workbench-manager)

  
  ;;;
  ;;;; Palette
  ;;;
  
  
  @convert-guest
  (method meta (palette-class)
    Tool-Palette)
  
  
  @convert-guest
  (method meta (palette-icon)
    {Bitmap-Resource "ProjectsManager"})
  
  
  @convert-guest
  (method meta (palette-title)
    "Workbench")
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method (get-tools-view)
    (locate 'tools))
  
  
  (method (focus-default)
    (let ((tree (get-tree)))
      (acquire-focus~ tree)))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (get-tree)
    (locate '(descendants tree)))
  
  
  ;;;
  ;;;; Controller
  ;;;


  @convert
  (class Workbench-Manager-Controller extends Editor-View-Controller
    
    
    (method (document-status)
      "Workbench"))


  @convert
  (method (new-controller)
    (new Workbench-Manager-Controller self))

  
  ;;;
  ;;;; Component
  ;;;
  
  
  (method (install rest)
    (nextmethod rest)
    (set-shown?~ (locate-component '(descendants header)) false)
    (set-editor~ (locate 'descendants) self)
    (add-exit-listener~ (get-application) self)
    (setup-active-policy)
    (set-client (get-workbench)))
  

  (method (conclude rest)
    (nextmethod rest)
    (setup-active-project))
  
  
  (method (setup-active-policy)
    (let* ((pref (get-preferences 'build))
           (policy (get-active-policy~ pref)))
      (when policy
        (set-current-policy policy))))
  
  
  (method (setup-active-project)
    (let* ((pref (get-preferences 'build))
           (project (get-active-project~ pref))
           (workbench (get-workbench)))
      (when (and project workbench)
        (activate-project (find-project~ workbench project)))))
  
  
  (method (get-designer-class)
    Workbench-Designer)
  
  
  (method (prepare-exit)
    (when designer
      (save-designer~ designer)))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (on-designer evt)
    (nextmethod evt)
    (case (get-kind~ evt)
      ((:child-add) (child-add (get-property~ evt :child) (get-property~ evt parent:)))
      ((:child-remove) (child-remove (get-property~ evt :child)))))
  
  
  (method (child-add child parent)
    (unimplemented 'child-add)
    @convert
    (when (is? child Product)
      (product-add~ designer child)
      (let* ((workbench (get-workbench))
             (parent-product (if (is? parent Product) parent (find-ascendant~ parent Product)))
             (parent-designer (if (eq? parent-product workbench) designer (get-product-designer~ designer parent-product))))
        (set-tag-source~ parent-designer child (get-manifest-source (type-name (class-of child)))))))
  
  
  (method (child-remove child)
    (when (is? child Product)
      (product-remove~ designer child)))

  
  ;;;
  ;;;; Events
  ;;;
    
  
  (method (key-press key)
    (case key
      ((#\return) (launch-selection))))
  
  
  (method (on-policies-menu evt)
    (let* ((sender (get-sender~ evt))
           (combo (get-combo~ sender))
           (pos (new Point 0 [height (get-size~ sender)])))
      (track-popup-menu~ sender (new Policies-Menu) pos :initiator combo)))
  
  
  (method (on-highlight-document evt)
    (highlight-document))
  
  
  (method (on-add-file evt)
    (add-file))
  
  
  (method (on-add-group evt)
    (add-group))
  
  
  (method (on-add-dependency evt)
    (add-dependency))
  
  
  (method (on-install-product evt)
    (let* ((default-directory? (get-shift?~ evt))
           (parent (selected-object))
           (file (with-import-directory default-directory? parent
                   (function dynamic (directory)
                     (get-modal OpenFile-Dialog :extensions '(("Jazz Files (*.jazz)" . "*.jazz")) :directory directory)))))
      (install-product file parent false)))
  
  
  (method (on-import-files evt)
    (import-files (get-shift?~ evt)))
  
  
  (method (on-import-directory evt)
    (import-directory (get-shift?~ evt)))
  
  
  (method (on-synchronize-content evt)
    (synchronize-content))
  
  
  (method (on-update-catalog evt)
    (update-catalog))
  
  
  (method (on-edit evt)
    (edit-selection))
  
  
  (method (on-activate evt)
    (activate-selection))
  
  
  (method (on-launch evt)
    (launch-selection))
  
  
  (method (on-execute evt)
    (execute-selection))
  
  
  (method (on-distribute evt)
    (distribute-selection))
  
  
  (method (on-properties evt)
    (show-properties))

  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method (highlight-document)
    (let ((guest (current-document)))
      (if (is-not? guest Document)
          (bell)
        (let* ((controller (get-controller~ guest))
               (moniker (get-moniker~ controller)))
          (if (not moniker)
              (bell)
            (let* ((workbench (get-workbench))
                   (product-file (find-source~ workbench moniker)))
              (if (not product-file)
                  (bell)
                (highlight-component product-file))))))))
  
  
  (method (highlight-component component)
    (let* ((tree (get-tree))
           (row (component-row~ tree component)))
      (if (not row)
          (bell)
        (ensure-expanded~ tree row)
        (set-single-selection~ tree (row-rank~ tree row)))))

  
  ;;;
  ;;;; Edit
  ;;;
  
  
  (method public (edit-current)
    (edit-product (current-project)))
  
  
  (method (edit-selection)
    (let ((objects (selected-objects)))
      (for-each (function dynamic (object)
                  (typecase object
                    ((Workbench) (edit-workbench))
                    ((Product) (edit-product object))))
                objects)))
  
  
  (method (edit-workbench)
    (let ((appl (get-application))
          (file {File User "Settings" "Workbench.jml"}))
      (edit-document~ appl file)))
  
  
  (method (edit-product product)
    (if (is-not? product Product)
        (bell)
      (edit-definition~ (get-application) (type-name (class-of product)))))

  
  ;;;
  ;;;; Add
  ;;;
  
  
  (definition Template-Directory
    {Directory Home "Templates" "New"})
  
  
  (method protected (add-file)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Product-Group)
                (is? parent Product))
        (let ((default-directory (either (default-import-directory parent :must-exist? false) {Directory User})))
          (when (or (exists?~ default-directory)
                    (= (message-box (format "Directory {l} does not exist. Create?" (get-list~ default-directory)) :type 'question) 'yes))
            (create-directories~ default-directory)
            (bind-values (kind template directory name) (get-modal Add-File-Dialog :directory default-directory)
              (when (memq? kind '(product module project))
                (set! directory (new-directory~ directory name))
                (create~ directory))
              (let* ((expander (new Template-Expander))
                     (associations (list (cons 'name name)))
                     (template (new-file~ Template-Directory template))
                     (extension (get-extension~ template))
                     (destination (new-file~ directory (format "{a}.{a}" name extension))))
                (with-closed ((printer (new File-Printer destination)))
                  (expand~ expander template associations printer))
                (select-component~ (get-tree) (import-pathname (ascendant-product parent) destination parent false)))))))))
  
  
  (method protected (add-group)
    (let ((parent (either (selected-object) (get-workbench))))
      (when (or (is? parent Product-Group)
                (is? parent Product))
        (add-component-class~ (get-tree) Product-Group parent: parent))))
  
  
  (method protected (add-dependency)
    @obsolete
    (let ((parent (selected-object)))
      (add-component-class~ (get-tree) Project-Dependency parent: parent)))

  
  ;;;
  ;;;; Install
  ;;;
  
  
  (method (install-product file parent descendant?)
    (let ((parent-product (ascendant-product parent)))
      (when (validate-pathnames parent-product (list file))
        (let* ((dir (get-parent~ file))
               (base (get-base~ file))
               (class-name (string->symbol base))
               (class (load-source class-name file))
               (workbench (get-workbench)))
          (if (not (subtype? class Product))
              (error "The file \"{a}\" does not contain a Product class" (get-name~ file))
            (let ((product (new class :workbench workbench parent: parent)))
              (add-child~ designer product parent)
              (reorder-component~ (get-tree) product)
              (user-message "{s} installed" (get-presentation~ product))
              product))))))

  
  ;;;
  ;;;; Import
  ;;;
  
  
  (definition MaxFiles-Warning
    100)
  
  
  (method (import-filter? product file)
    (let ((ext (get-extension~ file))
          (extensions (get-include-extensions~ product)))
      (if extensions
          (member? ext extensions test: ci=)
        (known-extension-frame-class~ (get-application) ext))))
  
  
  (method (import-directory default-directory?)
    (let* ((parent (selected-object))
           (product (ascendant-product parent))
           (directory (with-import-directory default-directory? parent
                        (function dynamic (directory)
                          (get-modal BrowseFolder-Dialog :directory directory))))
           (count (count-files~ directory :filter (function dynamic (file) (import-filter? product file)) :max-count MaxFiles-Warning)))
      (when (or count (eq? (message-box (format "The directory you are importing contains more than {a} files. Are you sure you want to import?" MaxFiles-Warning) :type 'question) 'yes))
        (when (validate-pathnames product (list directory))
          (let ((component (import-pathname product directory parent false)))
            (process-refresh~ designer component 'descendants))
          (user-message "{a} imported"
                        (parse~ directory))))))
  
  
  (method (import-files default-directory?)
    (let* ((parent (selected-object))
           (product (ascendant-product parent))
           (files (with-import-directory default-directory? parent
                    (function dynamic (directory)
                      (get-modal OpenFile-Dialog :multiple-selection? true :directory directory)))))
      (import-pathnames product files parent)))
  
  
  (method protected (import-pathnames product pathnames parent)
    (when (validate-pathnames product pathnames)
      (for-each (function dynamic (pathname)
                  (import-pathname product pathname parent false))
                (sort < pathnames key: (function dynamic (pathname) (get-name~ pathname))))
      (let ((count (length pathnames)))
        (user-message "{a} file{a} imported"
                      (format-cardinality count)
                      (format-plural count)))))
  
  
  (method (import-pathname product pathname parent descendant?)
    (let ((name (get-name~ pathname)))
      (typecase pathname
        ((Directory)
         (let ((product-file (new-file~ pathname (format "{a}.jazz" name))))
           (if (and (exists?~ product-file) (determine-product-file? product-file))
               (install-product product-file parent true)
             (let ((subgroup (new Product-Group name: name)))
               (add-child~ designer subgroup parent :design-events? (not descendant?) :descendant? descendant?)
               (set-name~ designer subgroup name :design-events? (not descendant?))
               (iterate-directory~ pathname
                 (function dynamic (pathname)
                   (import-pathname product pathname subgroup true))
                 :files? true
                 :directories? true
                 :sort? true
                 :recursive? false)
               subgroup))))
        ((File)
         (when (import-filter? product pathname)
           (if (determine-product-file? pathname)
               (install-product pathname parent descendant?)
             (import-file pathname parent descendant?)))))))
  
  
  (method (import-file file parent descendant?)
    (let* ((model (extension-model (get-extension~ file)))
           (name (if (eq? model Jazz-File) (string->symbol (get-base~ file)) {}))
           (product-file (new model name: name :source file))
           (workbench (get-workbench)))
      (add-child~ designer product-file parent :design-events? (not descendant?) :descendant? descendant?)
      (set-property~ designer product-file 'source file :design-events? (not descendant?))
      (when (eq? model Jazz-File)
        (set-name~ designer product-file name :design-events? (not descendant?))
        (add-entry~ workbench name product-file))
      product-file))
  
  
  (method (determine-product-file? file)
    (unimplemented 'determine-product-file?)
    @convert-manifest-stuff
    (let ((ext (get-extension~ file)))
      (when (ci= ext "jazz")
        (let ((info (extract-jazz-file-unit file)))
          (when info
            (bind-values (package type name extends) info
              (when (in-manifest? extends)
                (subtype? (autoload extends) Product))))))))
  
  
  (method (default-import-directory object . rest)
    (unimplemented 'default-import-directory)
    @convert
    (bind-keywords ((must-exist? true)) rest
      (letrec ((default
                (function dynamic (object)
                  (typecase object
                    ((Workbench)
                     {Directory Root})
                    ((Product)
                     (let ((source (get-manifest-source (type-name (class-of object)))))
                       (get-parent~ source)))
                    ((Product-Group)
                     (get-directory~ object))
                    (else
                     (let ((parent-dir (default (get-parent~ object))))
                       (when parent-dir
                         (let ((dir (new Directory (append (get-list~ parent-dir) (list (get-name~ object))))))
                           (if (or (not must-exist?) (exists?~ dir))
                               dir
                             parent-dir)))))))))
        (let ((dir (default object)))
          (when dir
            (anchorize~ dir))))))
  
  
  (method (with-import-directory default-directory? object proc)
    (let ((default-directory (essay default-directory? (default-import-directory object))))
      (if (and default-directory (exists?~ default-directory))
          (with-preserved-current-directory
            (function dynamic ()
              (proc default-directory)))
        (proc {}))))
  
  
  (method (extension-model ext)
    (cond ((member? ext '("jazz") test: ci=) Jazz-File)
          ((member? ext '("java") test: ci=) Java-File)
          ((member? ext '("c" "cpp") test: ci=) Cpp-File)
          ((member? ext '("bmp") test: ci=) Bitmap-File)
          ((member? ext '("cur") test: ci=) Cursor-File)
          ((member? ext '("ico") test: ci=) Icon-File)
          ((member? ext '("wav") test: ci=) Sound-File)
          (else Product-File)))
  
  
  (method protected (ascendant-product component)
    (if (is? component Product)
        component
      (ascendant-product (get-parent~ component))))
  
  
  ;;;
  ;;;; Synchronize
  ;;;
  
  
  (method (synchronize-content)
    (unimplemented 'synchronize-content)
    @convert
    (let* ((object (selected-object))
           (product (ascendant-product object))
           (directory (default-import-directory object :must-exist? false)))
      (if (not (exists?~ directory))
          (error "Directory {s} not found" directory)
        (let ((fact (new List-Factory))
              (component-name
               (function dynamic (component)
                 (if (is? component Product-Group)
                     (get-name~ component)
                   (get-name~ (get-manifest-source (type-name (class-of component)))))))
              (pathname-name
               (function dynamic (pathname)
                 (get-name~ pathname))))
          (letrec ((fold
                    (function dynamic (component pathname path)
                      (let ((children (collect-if (function dynamic (child)
                                                    (is-not? child Project-Dependencies))
                                                  (get-children~ component)))
                            (content (get-content~ pathname)))
                        (merge-ordered (function dynamic (what key left right)
                                         (let ((path (cons key path)))
                                           (case what
                                             (:left (put~ fact (list what path)))
                                             (:right (put~ fact (list what path)))
                                             (:same
                                              (when (directory? right)
                                                (fold left right path))))))
                                       (sort ci< children key: component-name)
                                       (sort ci< content key: pathname-name)
                                       :left-key component-name
                                       :right-key pathname-name
                                       :case-insensitive? true)))))
            (fold object directory '())
            (let ((out-of-synch (get-output~ fact)))
              (if (null? out-of-synch)
                  (message-box "Content is synchronized")
                (let* ((border (new Synchronize-Border :size {Dimension 500 200}))
                       (tree (locate~ border 'tree))
                       (add
                        (function dynamic (what path)
                          (let ((c0 (new Tree-Node :title (join path "/") :image {Bitmap-Resource "OpenedFolder"})))
                            (add-row~ tree :children (list c0 {} {} {}))))))
                  (for-each (function dynamic (info)
                              (bind (what path) info
                                (add what (reverse path))))
                            out-of-synch)
                  (message-box "The following elements are out of synch. Synchronize?" :class Synchronize-Box :type 'confirmation :content border)))))))))
  
  
  ;;;
  ;;;; Validate
  ;;;
  
  
  (method (validate-pathnames product pathnames)
    (validate
      (function dynamic (report)
        (letrec ((workbench (get-workbench))
                 (iterate
                  (function dynamic (pathname)
                    (typecase pathname
                      ((Directory)
                       (iterate-directory~ pathname iterate
                         :files? true
                         :directories? true
                         :sort? true
                         :recursive? false))
                      ((File)
                       (when (import-filter? product pathname)
                         (let ((model (extension-model (get-extension~ pathname))))
                           (when (eq? model Jazz-File)
                             (let* ((name (string->symbol (get-base~ pathname)))
                                    (jazz-file (get-entry~ workbench name)))
                               (when jazz-file
                                 (report jazz-file)))))))))))
          (for-each iterate pathnames)))))
  
  
  (method (validate iterate)
    (let ((workbench (get-workbench))
          (already-defined (new List-Factory)))
      (iterate
        (function dynamic (jazz-file)
          (put~ already-defined jazz-file)))
      (let ((already-defined (get-output~ already-defined)))
        (if (null? already-defined)
            true
          (let* ((count (length already-defined))
                 (max-displayed 10)
                 (too-many? (> count max-displayed))
                 (header (format "{a} import problem{a} detected. The following unit{a} {a} already defined:"
                                 count
                                 (format-plural count)
                                 (format-plural count)
                                 (format-is/are count)))
                 (text
                  `(,header
                    ()
                    ,@(map (function dynamic (jazz-file)
                             (let ((product (get-product~ jazz-file))
                                   (action
                                    (function ()
                                      (close-modal-dialog
                                        (function ()
                                          (highlight-component jazz-file))))))
                               (list :bulleted
                                     (list :hyperlink action
                                           (format "{a} defined in {a}"
                                                   (get-name~ jazz-file)
                                                   (get-presentation~ product))))))
                           (if too-many? (subseq already-defined 0 max-displayed) already-defined))
                    ,@(when too-many?
                        (list (list :bulleted "..."))))))
            (message-box text)
            false)))))
  
  
  ;;;
  ;;;; Activate
  ;;;
  
  
  (method public (activate-selection)
    (activate-object (selected-object)))
  
  
  (method (activate-object object)
    @obsolete
    (if (is-not? object Project)
        (bell)
      (activate-project object)))
  
  
  (method (activate-project project)
    (unless (eq? project active-project)
      (let ((tree (get-tree)))
        (when active-project
          (unhighlight-component~ tree active-project))
        (set! active-project project)
        (when active-project
          (let ((row (user-data-row~ tree active-project :visible? false)))
            (when row
              (ensure-expanded~ tree row)))
          (highlight-component~ tree active-project)))
      (let ((appl (get-application)))
        (update-project-titles~ appl)
        (update-project-actions~ appl))))
    
  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method (update-catalog)
    (with-cursor :wait
      (function dynamic ()
        (let ((catalog (require-catalog~ (selected-product))))
          (load-content~ catalog)
          (update~ catalog)))))
    
  
  ;;;
  ;;;; Launch
  ;;;
  
  
  (method public (launch-current)
    (launch-project (current-project)))
  
  
  (method public (launch-selection)
    @obsolete-Project!?
    (let ((appl (get-application))
          (tree (get-tree)))
      (for-each (function dynamic (component)
                  (typecase component
                    ((Project)
                     (launch-project component))
                    ((Product-File)
                     (let* ((file (get-effective-source~ component))
                            (ext (get-extension~ file)))
                       (if (= ext "wav")
                           (play-sound file)
                         (edit-document~ appl file))))))
                (selected-components~ tree))))
      
  
  (method (launch-project project)
    (launch~ (get-application) project))
  
  
  ;;;
  ;;;; Execute
  ;;;
  
  
  (method public (execute-current)
    (let ((project (current-project)))
      (execute-project project)))


  (method public (execute-selection)
    )

  
  (method (execute-project project)
    (execute~ (get-application) project))
  
  
  ;;;
  ;;;; Compile
  ;;;
  
  
  (method public (compile-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let ((moniker (get-moniker~ (get-controller~ guest))))
          (compile-moniker moniker)))))
  
  
  (method public (compile-moniker moniker)
    (let* ((workbench (get-workbench))
           (project-file (find-source~ workbench moniker)))
      (if (not project-file)
          (error "Unable to find {t} in workbench" moniker)
        (compile-file moniker project-file))))
  
  
  (method (compile-file moniker project-file)
    (let ((proc
           (function (thread)
             (let ((project (get-product~ project-file)))
               (prepare-maps~ project)
               (prepare-directories~ project)
               (user-message "Compiling {a}..." moniker)
               (let ((output (get-output-log))
                     (timer (new Timer)))
                 (clear-results~ output)
                 (select-results~ output)
                 (select-palette Output-Log)
                 (build~ project-file project {} {} output :force? true)
                 (user-message "Done in {a}" (get-duration-in-seconds~ timer)))))))
      (proc {})
      @w
      (new Thread
        name: "File Compiler"
        :information file
        :context self
        :execute proc)))
  
  
  ;;;
  ;;;; Preprocess
  ;;;
  
  
  (method public (preprocess-current)
    (let ((guest (current-document)))
      (when (and guest (is? guest Document))
        (when (get-modified?~ guest)
          (save~ guest))
        (let* ((moniker (get-moniker~ (get-controller~ guest)))
               (workbench (get-workbench))
               (file (find-source~ workbench moniker)))
          (if (not file)
              (error "Unable to find {t} in workbench" moniker)
            (preprocess-file moniker file))))))
  
  
  (method (preprocess-file moniker file)
    (let ((proc
           (function (thread)
             (let ((project (get-product~ file)))
               (prepare-maps~ project)
               (prepare-directories~ project)
               (user-message "Preprocessing {a}..." moniker)
               (let ((output (get-output-log))
                     (timer (new Timer)))
                 (clear-results~ output)
                 (select-results~ output)
                 (select-palette Output-Log)
                 (preprocess~ file project {} {} output :force? true)
                 (user-message "Preprocessing done in {a}" (get-duration-in-seconds~ timer)))))))
      (proc {})))
  
  
  ;;;
  ;;;; Build
  ;;;
  
  
  (method (on-build-current evt)
    (let ((project (current-project)))
      (if (not project)
          (bell)
        (build-project project))))
  
  
  (method public (build-current)
    ;; should be only the project's files...
    (save-all~ (get-application))
    (let ((project (current-project)))
      (build-project project)))
  
  
  (method (build-project project)
    @obsolete-Project!?
    (if (is-not? project Project)
        (bell)
      (let ((log? true @wait (get-selected?~ (locate 'log?)))
            (force-link? false @wait (get-selected?~ (locate 'force-link?))))
        (build~ project :log? log? :force-link? force-link?))))
    
  
  ;;;
  ;;;; Clean
  ;;;
  
  
  (method public (clean-current)
    (let ((project (current-project)))
      (clean-project project)))
  
  
  (method (clean-project project)
    @obsolete-Project!?
    (if (is-not? project Project)
        (bell)
      ;; to complete
      {}))
    
  
  ;;;
  ;;;; Options
  ;;;
  
  
  (method public (options-current)
    (let ((project (current-project)))
      (options-project project)))
  
  
  (method (options-project project)
    @obsolete-Project!?
    (if (is-not? project Project)
        (bell)
      ;; to complete
      {}))
  
  
  ;;;
  ;;;; References
  ;;;
  
  
  (method public (references-current)
    (let ((project (current-project)))
      (references-project project)))


  (method (references-project project)
    @obsolete-Project!?
    (if (is-not? project Project)
        (bell)
      (new-frame Reference-Finder :project (type-name (class-of project)))))
  
  
  ;;;
  ;;;; Log
  ;;;
  
  
  (method public (view-log)
    (let ((project (current-project)))
      (view-project-log project)))
  
  
  (method (view-project-log project)
    (let ((appl (get-application))
          (file (log-file~ project)))
      (if (not file)
          (bell)
        (edit-document~ appl file :wrap? true))))

  
  ;;;
  ;;;; Distribute
  ;;;
  
  
  (method (on-distribute-current evt)
    (let ((project (selected-project)))
      (if (not project)
          (bell)
        (distribute-project project))))
  
  
  (method public (distribute-current)
    (let ((project (current-project)))
      (distribute-project project)))
  
  
  (method (distribute-selection)
    (distribute-project (selected-project)))
  
  
  (method (distribute-project project)
    (let* ((mode         'backup)
           (left         (project-distribution~ project))
           (right        (project-distribution-directory~ project))
           (content      (project-distribution-list~ project))
           (ignored-dirs (list "Debug" "Release" "Work"))
           (files        (list "vssver.scc"))
           (extensions   (list))
           (frame        (new-frame Compare-Directories :left-moniker left :right-moniker right :left-content content :ignored-nodes ignored-dirs :ignored-leaves files :ignored-extensions extensions :host-visible? false)))
      (with-cursor :wait
        (function dynamic ()
          (compare-trees~ (get-guest~ frame))
          (bring-to-front~ frame)
          (set-visible?~ frame true)))))
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (selected-object)
    (let ((tree (get-tree)))
      (selected-component~ tree)))
  
  
  (method (selected-objects)
    (let ((tree (get-tree)))
      (selected-components~ tree)))
  
  
  (method (selected-product)
    (let ((object (selected-object)))
      (when (is? object Product)
        object)))
  
  
  (method (selected-project)
    @obsolete-Project!?
    (let ((object (selected-object)))
      (when (is? object Project)
        object)))
  
  
  (method (current-project)
    (if (not active-project)
        (error "No active project")
      active-project))

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method public (new-menu)
    @obsolete-Project!?
    (let ((object (selected-object)))
      (when object
        (typecase object
          ((Product-Group) (new-group-menu object))
          ((Project) (new-project-menu object))
          ((Product) (new-product-menu object))
          ((Project-Dependencies) (new-dependencies-menu object))
          (else (new Element-Menu :client (get-tree)))))))
  
  
  (method (new-group-menu object)
    (let ((menu (new Group-Menu :client (get-tree))))
      (update-group/product-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-project-menu object)
    (let ((menu (new Project-Menu :client (get-tree))))
      (update-group/product-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-product-menu object)
    (let ((menu (new Product-Menu :client (get-tree))))
      (when (is? object Workbench)
        (set-visible?~ (locate~ menu 'synchronize-content) false))
      (update-group/product-menu menu)
      (cleanup-separators~ menu)
      (layout-menu~ menu)
      menu))
  
  
  (method (new-dependencies-menu object)
    (let ((menu (new Dependencies-Menu :client (get-tree))))
      menu))
  
  
  (method (update-group/product-menu menu)
    (let ((tree (get-tree)))
      (when (> (length (get-selection~ tree)) 1)
        (set-visible?~ (locate~ menu 'install-product) false)
        (set-visible?~ (locate~ menu 'import-files) false)
        (set-visible?~ (locate~ menu 'import-directory) false))))
  
  
  (method (install-policy policy)
    (set! Current-Policy policy)
    (let* ((tree (get-tree))
           (cell {Cell 0 0})
           (node (get-cell-data~ tree cell)))
      @waiting
      (set-title~ node (format "Workbench - {a}" policy))
      (invalidate-cell~ tree cell)))
  
  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method (describe-state pos)
    (let ((workbench (get-workbench)))
      (format :console "{%}active-project = {s}" active-project)
      (format :console "{%}product-designers =")
      (let* ((pairs (sort < [product-designers designer] key: (function dynamic (pair) (type-name (class-of (car pair))))))
             (more? (> (length pairs) 5)))
        (for-each (function dynamic (pair)
                    (bind (product . designer) pair
                      (format :console "{%}  {a} {a}" (type-name (class-of product)) designer)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}products-hashtable =")
      (let* ((pairs (sort < (gather-keys/values~ [products-hashtable workbench]) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function dynamic (pair)
                    (bind (name . product) pair
                      (format :console "{%}  {a} {a}" name product)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}units-hashtable =")
      (let* ((pairs (sort < (gather-keys/values~ [units-hashtable workbench]) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function dynamic (pair)
                    (bind (name . unit) pair
                      (format :console "{%}  {a} {a}" name unit)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ...")))
      (format :console "{%}resources-hashtable =")
      (let* ((pairs (sort < (gather-keys/values~ [resources-hashtable workbench]) key: car))
             (more? (> (length pairs) 5)))
        (for-each (function dynamic (pair)
                    (bind (name . resource) pair
                      (format :console "{%}  {a} {a}" name resource)))
                  (if more? (subseq pairs 0 5) pairs))
        (when more?
          (format :console "{%}  ..."))))))


;;;
;;;; Synchronize-Border
;;;


(class Synchronize-Border extends Border-View
  
  
  (form
    (<install>                                     border-type: solid border-color: {Color name: Outline-Border}
      (<Scroller-View>                             flat?: #t hscroll?: #t vscroll?: #t
        (<!>                         name: content layout-type: fill
          (<Tree-Header>                           flat?: #t
            (<!>                     name: content
              (<Synchronize-Tree>    name: tree))))))))


;;;
;;;; Policies-Menu
;;;


(class Policies-Menu extends Context-Menu
  
  
  (method (finish rest)
    (nextmethod rest)
    (let* ((pref (get-preferences '(build policies)))
           (policies (get-children~ pref)))
      (for-each (function dynamic (policy)
                  (let ((name (get-name~ policy))
                        (title (get-title~ policy)))
                    (new Check-Item parent: self :checked? (eq? name [Current-Policy Workbench-Manager]) :title title :action-handler (new Event-Handler :target self :method-name 'on-action :properties (list :policy name)))))
                policies)))
  
  
  (method (on-action evt)
    @convert
    (let ((appl (get-application))
          (policy (get-property~ evt :policy)))
      (install-policy policy))))


;;;
;;;; Group-Menu
;;;


(class Group-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-file            title: "&Add..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: add-group           title: "Add &Group..." before: add-item action: {Action workbench-manager add-group})
      (<Label-Item>     name: install-product     title: "&Install Product..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-product})
      (<Label-Item>     name: import-files        title: "&Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "&Import Directory..." before: cut action: {Action workbench-manager import-directory})
      (<Label-Item>     name: synchronize-content title: "&Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Product-Menu
;;;


(class Product-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit                title: "&Edit" before: add-item icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager edit})
      (<Separator-Item>                           before: add-item)
      (<Label-Item>     name: add-file            title: "&Add..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-file})
      (<Label-Item>     name: add-group           title: "Add &Group..." before: add-item action: {Action workbench-manager add-group})
      (<Label-Item>     name: install-product     title: "&Install Product..." before: cut icon: {Bitmap-Resource "Import"} action: {Action workbench-manager install-product})
      (<Label-Item>     name: import-files        title: "&Import Files..." before: cut action: {Action workbench-manager import-files})
      (<Label-Item>     name: import-directory    title: "&Import Directory..." before: cut action: {Action workbench-manager import-directory})
      (<Label-Item>     name: synchronize-content title: "&Synchronize Content..." before: cut action: {Action workbench-manager synchronize-content})
      (<Separator-Item>                           before: cut)
      (<Label-Item>     name: update-catalog      title: "&Update Catalog" before: cut icon: {Bitmap-Resource "Repository"} action: {Action workbench-manager update-catalog})
      (<Separator-Item>                           before: cut))))


;;;
;;;; Project-Menu
;;;


(class Project-Menu extends Product-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: activate title: "&Set as Active Project" before: cut default?: #t action: {Action workbench-manager activate})
      (<Separator-Item>                before: cut))))


;;;
;;;; Dependencies-Menu
;;;


(class Dependencies-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: add-dependency title: "Add &Dependency..." before: add-item icon: {Bitmap-Resource "Added"} action: {Action workbench-manager add-dependency})
      (<Separator-Item>                      before: cut))))


;;;
;;;; Element-Menu
;;;


(class Element-Menu extends Component-Menu
  
  
  (form
    (<install>
      (<Label-Item>     name: edit title: "&Edit" before: cut default?: #t icon: {Bitmap-Resource "Edit"} action: {Action workbench-manager launch})
      (<Separator-Item>            before: cut)))
  
  
  (method (on-properties evt)
    @convert
    (show-properties))))
