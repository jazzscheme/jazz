;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Indexed Catalogs
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.catalog.catalog.Indexed-Catalog jazz


(import (jazz.catalog)
        (jazz.io)
        (jazz.library)
        (jazz.utilities))


(class Indexed-Catalog extends Filing-Catalog
  

  (slot directories)
  (slot extensions)
  (slot recursive?)
  (slot references?)
  (slot content)
  (slot definitions-index)
  (slot references-index)


  (method (initialize name file directories extensions recursive? active? references? (report?: report? #t))
    (nextmethod name file active?)
    (set! directories~self directories)
    (set! extensions~self extensions)
    (set! recursive?~self recursive?)
    (set! references?~self references?)
    (set! content~self (make-table test: equal?))
    (set! definitions-index~self (make-table test: equal?))
    (set! references-index~self (make-table test: equal?)))


  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-directories)
    directories)
  
  
  (method public virtual (get-extensions)
    extensions)
  
  
  (method public (get-recursive?)
    recursive?)
  
  
  (method public (get-references?)
    references?)
  
  
  (method public (get-content)
    content)
  
  
  (method public (get-definitions-index)
    definitions-index)
  
  
  (method public (get-references-index)
    references-index)
  
  
  (method public (get-file-definitions name)
    (table-ref content name '()))
  
  
  (method (get-file-entry file)
    (find-if (function (definition)
               (pathname= (get-file~ definition) file))
             (get-file-definitions (get-base~ file))))
  
  
  (method public (get-statistics)
    (let ((f (count-file-entries content))
          (d (table-length definitions-index))
          (r (table-length references-index)))
      (format "{a} file{a}, {a} definition{a}, {a} reference{a}"
              f (format-plural f)
              d (format-plural d)
              r (format-plural r))))
  
  
  (method (count-file-entries content)
    (let ((count 0))
      (iterate-table content
                     (function (name file-entries)
                       (increase! count (length file-entries))))
      count))
  
  
  (method (table-info table)
    (format "{s} entries"
            (table-length table)))

  
  (method (get-entry-time definition)
    (get-time~ definition))
  
  
  (method (update-entry entry)
    (update-indexes~ entry definitions-index references-index))
  
  
  (method (add-entry name entry)
    (table-add content name entry))


  ;;;
  ;;;; Activation
  ;;;
      
  
  (method (activate)
    (load-content report?: #t))
      
  
  (method (deactivate)
    )


  ;;;
  ;;;; Load
  ;;;


  (method public (load-content (report?: report? #f))
    (when (and (not loaded?) (get-active?) (exists?~ file))
      (when report?
        (user-message "Loading Catalog..."))
      (load-table content file #t)
      (update-catalog-indexes report?)
      (set! loaded? #t)
      (when report?
        (user-message "Done"))))

  
  (method (update-catalog-indexes report?)
    (when report?
      (user-message "Updating Indexes..."))
    (iterate-table content
                   (function (class-name definitions)
                     (for-each (function (file-definition)
                                 (set-catalog~ file-definition self)
                                 (update-indexes~ file-definition definitions-index references-index))
                               definitions))))


  ;;;
  ;;;; Save
  ;;;
  
  
  (method (save)
    (when modified?
      (user-message "Saving {a} Catalog..." name)
      (save-content)
      (set-modified? #f)
      (user-message "Done")))


  (method (save-content)
    (let* ((all (table-keys/values content))
           (sorted (sort string<? all key: car)))
      (call-with-output-file (parse~ file)
        (function (printer)
          (for-each (function (info)
                      (bind (name . definitions) info
                        (when definitions
                          (format printer "{s}{%}" name)
                          (format printer " (")
                          (let ((first? #t))
                            (for-each (function (definition)
                                        (print-catalog~ definition first? printer)
                                        (set! first? #f))
                                      definitions))
                          (format printer "){%}"))))
                    sorted)))))


  ;;;
  ;;;; Update
  ;;;
  
  
  (method (update (report?: report? #t))
    (set-active? #t)
    (when report?
      (user-message "Updating Catalog..."))
    (let ((processed (scan)))
      (sweep)
      (reset-marks)
      (when report?
        (user-message "{a} Catalog Updated ({s} files processed)"
                      name
                      processed))))
  
  
  (method public (update-file file)
    (set-active? #t)
    (let* ((entry (get-file-entry file))
           (marked? (and entry (get-marked?~ entry))))
      (catch (Parse-Error err
               (user-message "Error at line {s}" (get-row~ (get-start~ err)))
               (when entry
                 (set-marked?~ entry marked?))
               #f)
        (when entry
          (set-marked?~ entry #f))
        (process-file file)
        (sweep)
        #t)))
  
  
  (method (reset-marks)
    (iterate-table content
                   (function (class-name definitions)
                     (for-each (function (file-definition)
                                 (set-marked?~ file-definition #f))
                               definitions))))
  

  ;;;
  ;;;; Scan
  ;;;
  
  
  (definition Zip-Extensions
    '("zip" "jar"))
  
  
  (method (scan-directories)
    (let* ((processed 0)
           (scandir
            (function (dir)
              (increase! processed (scan-directory dir recursive?: recursive?)))))
      (if (is? directories Directory-Group)
          (for-each scandir (get-list~ directories))
        (scandir directories))
      processed))
  
  
  (definition Parser-Associations
    '((CommonLisp-Parser "lisp")
      (Cpp-Parser "c" "cpp" "h")
      (CSS-Parser "css")
      (Jazz-Parser "jazz")
      (Java-Parser "java")
      (JavaScript-Parser "js")
      (Lua-Parser "lua")
      (Properties-Parser "properties")
      (Python-Parser "py")
      (Scheme-Parser "scm" "ss")))
  
  
  (method (get-parser-class extension)
    (let ((info
           (rassociate extension Parser-Associations
             test: (function (ext extensions)
                     (member? ext extensions test: ci=?)))))
      (when info
        (autoload (car info)))))
  
  
  (method (get-parser extension)
    (let ((class (get-parser-class extension)))
      (when class
        (new class self references?: references?))))

  
  (method (scan-file? file)
    (let ((extension (get-extension~ file))
          (extensions (get-extensions)))
      (and (or (not extensions) (member? extension extensions test: ci=?))
           (not-null? (get-parser-class extension)))))

  
  (method (scan-file file time)
    (user-message "Parsing {a}" file)
    (let ((extension (get-extension~ file)))
      (if (member? extension Zip-Extensions test: ci=?)
          (scan-zip-file file time)
        (parse~ (get-parser extension) file time))))
  
  
  (method (scan-zip-file file time)
    @convert
    (let ((entries (new List-Factory)))
      (with-closed ((unzip (new Unzip-File file)))
        (iterate-files~ unzip
          (function (filename size)
            (let ((parser (get-parser (extract-extension filename))))
              (when parser
                (let* ((zipped (new Zipped file filename))
                       (entry (get-entry~ zipped)))
                  (user-message "Parsing {a}" entry)
                  (put~ entries (parse-zipped~ parser zipped))))))))
      (new Zip-File-Entry catalog file time (get-output~ entries))))


  ;;;
  ;;;; Sweep
  ;;;
  
  
  (method (sweep)
    (sweep-table content marked? #t)
    (sweep-table definitions-index marked? #f)
    (sweep-table references-index marked? #f))
  
  
  (method (marked? definition)
    (get-marked?~ (get-file-definition~ definition)))
  
  
  (method (sweep-table table marked? reset?)
    (iterate-table table
                   (function (class-name definitions)
                     (when (not-null? definitions)
                       (let ((previous definitions)
                             (list (cdr definitions)))
                         (while (not-null? list)
                           (let ((definition (car list)))
                             (if (marked? definition)
                                 (begin
                                   (set! previous list)
                                   (set! list (cdr list)))
                               (when reset?
                                 (set-marked?~ definition #f))
                               (set-cdr! previous (cddr previous))
                               (set! list (cdr previous))))))
                       (when (not (marked? (car definitions)))
                         (set-modified? #t)
                         (table-set! table class-name (cdr definitions)))))))


  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method (get-definitions name)
    (table-ref definitions-index (canonicalize-name name) #f))
  
  
  (method (get-references name)
    (table-ref references-index (canonicalize-name name) #f))


  (method (get-completions name)
    (either (table-complete definitions-index name)
            (table-complete references-index name)))
  
  
  (method protected virtual (canonicalize-name name)
    (->string name))
  
  
  ;; The next two methods are a bit convoluted because
  ;; of the current implementation of java definitions...
  (method public (get-qualified-category qualified)
    (let ((name (last qualified))
          (qualifier (butlast qualified)))
      (find-if (function (definition)
                 (and (is? definition Category-Entry)
                      (let ((package (get-category-package definition)))
                        (and package
                             (= (get-qualified~ package) qualifier)))))
               (get-definitions name))))
  
  
  (method (get-category-package definition)
    (find-if (function (definition)
               (is? definition Package-Entry))
             (get-definitions~ (get-file-definition~ definition))))


  ;;;
  ;;;; Completions
  ;;;
  
  
  (method (table-complete table string)
    (let ((length (cardinality string))
          (result '()))
      (iterate-table table
                     (function (name value)
                       (when (compare-n name string length)
                         (set! result (cons name result)))))
      result))))
