;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Gambit Debugger
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.debugger.gambit.Gambit-Debugger jazz


(import (jazz.debugger)
        (jazz.platform)
        (jazz.process)
        (jazz.library)
        (jazz.library.shell)
        (jazz.utilities))


(class Gambit-Debugger extends Debugger implements Exit-Listener
  
  
  (slot process          initialize {})
  (slot attached-process initialize {})
  (slot standard-input)
  (slot standard-output)
  (slot standard-error)
  (slot banner)
  (slot console-text)
  (slot listener-thread)
  (slot listener-done?)
  (slot mode)
  
  
  (method (initialize (console-text: console-text {}))
    (nextmethod)
    (set! console-text~self console-text)
    (set! mode~self 'gambit))
  
  
  ;;;
  ;;;; Start
  ;;;

  
  (method public (start-gambit)
    (add-exit-listener~ (get-application) self)
    (let* ((command "gsc -:dar-")
           (directory {Directory jazz})
           (process (create-process command directory: directory :capture-input? #t :capture-output? #t :capture-error? #t console?: #f :debug-console? #f :wait? #f visible?: #f)))
      (set! process~self (new Gambit-Debugger-Process process))
      (set! standard-input~self (get-standard-input~ process))
      (set! standard-output~self (get-standard-output~ process))
      (set! standard-error~self (get-standard-error~ process))
      (process-wait)
      (start-listener)
      (register-debugger)))
  
  
  (method (process-wait)
    ;; skip banner
    (sleep 50)
    (let ((done? #f)
          (count 0))
      (while (not done?)
        (if (output-available?)
            (begin
              (read-content~ standard-output)
              (set! done? #t))
          (sleep 100)
          (increase! count)
          (when (>= count 30)
            (set! done? #t))))))
  
  
  (method (output-available?)
    (bytes-available?~ standard-output))
  
  
  (method (register-debugger)
    (register-debugger self))

  
  ;;;
  ;;;; Stop
  ;;;
  
  
  (method public (stop-gambit)
    (unregister-debugger)
    (stop-listener)
    (process-command {} ",q" :output? #f)
    (set-prompt~ console-text "> ")
    (close~ process)
    (remove-exit-listener~ (get-application) self))
  
  
  (method (unregister-debugger)
    (unregister-debugger self))

  
  ;;;
  ;;;; Exit
  ;;;
  
  
  (method (prepare-exit)
    (when process
      (stop-gambit)
      ;; I don't know why this pause is necessary but without it the Gambit process doesn't quit
      (sleep 100)))

  
  ;;;
  ;;;; Process
  ;;;
  
  
  (method (get-process)
    process)

  
  ;;;
  ;;;; Command
  ;;;
  
  
  (method public (gambit-command name command console?)
    (cond ((= command "j")
           (set! mode 'jazz)
           (list "jazz"))
          ((= command "g")
           (set! mode 'gambit)
           (list "gambit"))
          ((= command "m")
           (list (->string mode)))
          ((= command "r")
           (refresh-gambit)
           '())
          ((= command "q")
           (set! mode 'gambit)
           (stop-gambit)
           (list "bye"))
          (else
           (process-command name
             (cond ((or (member? command '("b" "t" "d" "i" "e" "?")) (numeric? command))
                    (format ",{a}" command))
                   ((= command "l")
                    (set! mode 'jazz)
                    "(jl)")
                   ((= command "ls")
                    (set! mode 'jazz)
                    "(jls)")
                   ((= command "lr")
                    "(jlrs)")
                   (else
                    (if (and console? (eq? mode 'jazz))
                        (format "(package jazz.dev uses (jazz jazz.test product) {a})" command)
                      command)))
             console?: console?)
           (fresh-prompt~ console-text)
           '())))
  
  
  (method public (gambit-commands names commands console?)
    (for-each (function dynamic (name command)
                (process-command name command console?: console?))
              names
              commands)
    (fresh-prompt~ console-text))
  
  
  (method (process-command name command (console?: console? #f) (output?: output? #t))
    ;; this is a workaround for the annoying fact that in gambit
    ;; definitions can only be evaluated when at error level 0
    (write-line~ standard-input (if console? command (format ",t {a}" command)))
    (when output?
      (flush-output~ standard-input)
      (gambit-output name: name)))
  
  
  (method (refresh-gambit)
    (when (output-available?)
      (display-output~ console-text (read-content~ standard-output))
      (fresh-prompt~ console-text)))
  
  
  (method (gambit-output (name: name {}))
    (let ((done? #f)
          (some-output? #f)
          (count 0)
          (prmpt {}))
      (sleep 25)
      (with-colored-output~ console-text (eval-color~ console-text)
        (function dynamic ()
          (while (not done?)
            (if (not (output-available?))
                (begin
                  (increase! count)
                  (when (> count 400)
                    (set! done? #t)))
              (receive (output prompt) (parse-gambit-output)
                (display-output~ console-text output)
                (when name
                  (let ((proc
                          (function dynamic (name)
                            (display-output~ console-text (if name (->string name) "<expr>"))
                            (newline-output~ console-text))))
                    (if (pair? name)
                        (for-each proc name)
                      (proc name)))
                  (set! name {}))
                (if some-output?
                    (update-view~ console-text)
                  (set! some-output? #t))
                (if prompt
                    (begin
                      (set! prmpt prompt)
                      (set! done? #t))
                  (set! count 0))))
            (sleep 25))))
      (when prmpt
        (set-prompt~ console-text prmpt))))

  
  ;;;
  ;;;; Listener
  ;;;
  
  
  (method (start-listener)
    (set! listener-done? #f)
    @w
    (set! listener-thread (new-listener-thread)))
  
  
  (method (stop-listener)
    (set! listener-done? #t)
    @w
    (wait-for listener-thread))
  
  
  (method (new-listener-thread)
    (new Thread
      name: "Gambit Listener"
      context: self
      execute: (function (thread)
                 (listen-gambit))))
  
  
  (method (listen-gambit)
    (while (not listener-done?)
      (if (output-available?)
          (receive (output prompt) (parse-gambit-output)
            (debug-output~ console-text output))
        (sleep 100))))
  
  
  (definition Prompt
    (coerce (list #\> #\space) String))
  
  
  (method (find-prompt str)
    (let ((n (- (length str) 2)))
      (let ((skip-numeric
              (function dynamic ()
                (while (and (> n 0) (numeric? (element str (- n 1))))
                  (decrease! n)))))
        (skip-numeric)
        (when (and (> n 0) (eqv? (element str (- n 1)) #\backslash))
          (decrease! n))
        (skip-numeric)
        n)))
  
  
  (method (parse-gambit-output)
    (let ((output (read-content~ standard-output)))
      (if (ends-with? output Prompt)
          (let ((n (find-prompt output)))
            (values (subseq output 0 n) (subseq output n)))
        (values output {}))))))
