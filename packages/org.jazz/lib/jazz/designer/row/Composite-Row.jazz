;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Composite Row
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.designer.row.Composite-Row jazz


(import (jazz.designer)
        (jazz.platform)
        (jazz.literals)
        (jazz.library)
        (jazz.system)
        (jazz.ui)
        (jazz.utilities))


(class Composite-Row extends String-Row
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method (editor-class)
    Composite-Text-View)
  
  
  ;;;
  ;;;; Edition
  ;;;
  
  
  (method (get-edited-value)
    (let ((string (get-string-content~ editor)))
      (if (or (empty-string? string) (= string "{}"))
          {}
        (parse-entries (current-entries)))))
  
  
  ;;;
  ;;;; Parse
  ;;;
  
  
  (method protected virtual (accepts-spaces?)
    #t)
  
  
  (method protected virtual (parse-entries entries)
    (map parse-entry entries))
  
  
  (method protected virtual (parse-entry entry)
    )
  
  
  (method (parse-error (message: message {}) (start: start {}) (end: end {}) (part: part {}))
    (let ((message (either message (syntax-message)))
          (start (either start (essay part (get-start~ part))))
          (end (either end (essay part (get-end~ part)))))
      (signal (new Parse-Error message: message start: (essay start (new Cell 0 start)) end: (essay end (new Cell 0 end))))))
  
  
  (method protected virtual (syntax-message)
    "Invalid value")
  
  
  ;;;
  ;;;; Presentation
  ;;;
  
  
  (method (present value)
    (if (null? value)
        "{}"
      (format "{l detail: :human separator: \", \"}"
              (present-value value))))
  
  
  (method protected virtual (present-value value)
    (map present-entry value))
  
  
  (method protected virtual (present-entry entry)
    )
  
  
  ;;;
  ;;;; Navigation
  ;;;
  
  
  (method (navigate-backward)
    (let* ((entries (current-entries))
           (pos (get-col~ (get-start~ editor)))
           (part (pos->part entries pos)))
      (if (null? part)
          (bell)
        (let ((previous (- (get-rank~ part) 1)))
          (for-each-part entries
            (function dynamic (part)
              (when (= (get-rank~ part) previous)
                (select-part part))))))))
  
  
  (method (navigate-forward)
    (let* ((entries (current-entries))
           (pos (get-col~ (get-end~ editor)))
           (part (pos->part entries pos)))
      (if (null? part)
          (bell)
        (let ((next (+ (get-rank~ part) 1)))
          (for-each-part entries
            (function dynamic (part)
              (when (= (get-rank~ part) next)
                (select-part part))))))))
  
  
  (method (current-entries)
    (determine-entries (get-string-content~ editor)))
  
  
  (method (current-part entries)
    (let ((pos (get-col~ (get-start~ editor))))
      (pos->part entries pos)))
  
  
  (method (current-position entries)
    (let ((pos (get-col~ (get-start~ editor))))
      (pos->position entries pos)))
  
  
  (method (pos->part entries pos)
    (call/ec
      (lambda (return)
        (for-each-part entries
          (function dynamic (part)
            (when (and (>= pos (get-start~ part)) (<= pos (get-end~ part)))
              (return part))))
        {})))
  
  
  (method (pos->position entries pos)
    (call/ec
      (lambda (return)
        (let ((string (get-string-content~ editor)))
          (for-each-part entries
            (function dynamic (part)
              (if (between? pos (get-start~ part) (get-end~ part))
                  (return (get-position~ part))
                (let* ((n (get-end~ part))
                       (end (find-entry-end string n)))
                  (when (and end (between? pos (+ n 1) end))
                    (return (+ (get-position~ part) 1)))))))
          (decrease! pos)
          (while #t
            (if (< pos 0)
                (return 0)
              (let ((c (element string pos)))
                (cond ((and (accepts-spaces?) (eqv? c #\space)) (decrease! pos))
                      ((eqv? c #\comma) (return 0))
                      (else (return {}))))))))))
  
  
  (method (find-entry-end string n)
    (let ((len (cardinality string)))
      (call/ec
        (lambda (return)
          (while #t
            (if (>= n len)
                (return n)
              (let ((c (element string n)))
                (cond ((and (accepts-spaces?) (eqv? c #\space)) (increase! n))
                      ((eqv? c #\comma) (return n))
                      (else (return {}))))))))))
  
  
  (method (for-each-part entries proc)
    (for-each (function dynamic (entry)
                (for-each proc entry))
              entries))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (method (view-completions)
    (let ((info (find-to-complete)))
      (if (null? info)
          (bell)
        (receive (position text start end) info
          (let ((domain (part-domain position)))
            (if (null? domain)
                (bell)
              (let* ((height (* (length domain) 17))
                     (border (new Border-View name: 'border border-type: 'solid border-color: {Color red: 128 green: 128 blue: 128}))
                     (scroller (new Scroller-View size: (new Dimension 150 (max 50 (min height 250))) flat?: #t vscroll?: #t))
                     (content (get-content~ scroller))
                     (tree (new Completion-Tree :selected (get-selection~ editor) start: start end: end)))
                (set-layout-type~ content 'fill)
                (set-parent~ tree content)
                (set-client~ scroller tree)
                (let ((sorted (sort ci< domain)))
                  (for-each (function dynamic (name)
                              (add-row~ tree children: (list (new Tree-Node image: {Bitmap-Resource "DesignColumn"} title: name)) user-data: name))
                            sorted))
                (let* ((start (get-start~ editor))
                       (par (get-paragraph~ editor (get-row~ start)))
                       (view (text->view~ editor start))
                       (pos (+ view (new Dimension -10 (+ (get-height~ par) 2))))
                       (alternate (+ view (new Dimension -10 -2))))
                  (popup~ editor scroller pos alternate-position: alternate border: border)
                  (if (null? text)
                      (set-selection~ tree (list 0))
                    (locate-prefix~ tree text))
                  (acquire-focus~ tree)))))))))
  
  
  (method (find-to-complete)
    (let* ((entries (current-entries))
           (part (current-part entries)))
      (if (null? part)
          (let ((position (current-position entries)))
            (when position
              (values position {} (get-col~ (get-start~ editor)) (get-col~ (get-end~ editor)))))
        (values (get-position~ part) (get-text~ part) (get-start~ part) (get-end~ part)))))
  
  
  (method (complete-part start end tree)
    (let ((rank (get-single-selection~ tree)))
      (if (null? rank)
          (bell)
        (let ((string (get-user-data~ (get-row~ tree rank))))
          (close-popups~ (get-player~ parent) all?: #t)
          (set-selection~ editor (new Range$Cell$ (new Cell 0 start) (new Cell 0 end)))
          (insert-string~ editor string)))))
  
  
  ;;;
  ;;;; Structure
  ;;;
  
  
  (method (determine-entries string)
    (let ((entries (new List-Factory))
          (rank 0)
          (offset 0))
      (for-each (function dynamic (string)
                  (let ((parts (determine-entry string rank offset)))
                    (put~ entries parts)
                    (increase! rank (length parts))
                    (increase! offset (+ (cardinality string) 1))))
                (split string ","))
      (get-output~ entries)))
  
  
  (method (determine-entry string rank offset)
    (let* ((parts (new List-Factory))
           (position 0)
           (start {})
           (end {})
           (end-part
            (function dynamic ()
              (when start
                (put~ parts (new Part rank position (subseq string start (+ end 1)) (+ offset start) (+ offset end 1)))
                (increase! rank)
                (increase! position)
                (set! start {})
                (set! end {})))))
      (loop (for c in-sequence string)
            (for n from 0)
            (if (and (accepts-spaces?) (eqv? c #\space))
                (end-part)
              (if (null? start)
                  (begin
                    (set! start n)
                    (set! end n))
                (set! end n))))
      (end-part)
      (get-output~ parts)))
  
  
  ;;;
  ;;;; Text
  ;;;
  
  
  (method protected virtual (part-domain position)
    {})
  
  
  (method (select-part part)
    (set-selection~ editor (new Range$Cell$ (new Cell 0 (get-start~ part)) (new Cell 0 (get-end~ part))))))


;;;
;;;; Part
;;;


(class Part extends Object
  
  
  (slot rank)
  (slot position)
  (slot text)
  (slot start)
  (slot end)
  
  
  (method (initialize rank position text start end)
    (nextmethod)
    (set! rank~self rank)
    (set! position~self position)
    (set! text~self text)
    (set! start~self start)
    (set! end~self end))
  
  
  (method (print printer readably)
    (print-unreadable self printer
      (function dynamic (printer)
        (format printer "{a} {a} {a}" text start end))))
  
  
  (method public (get-rank)
    rank)
  
  
  (method public (get-position)
    position)
  
  
  (method public (get-text)
    text)
  
  
  (method public (get-start)
    start)
  
  
  (method public (get-end)
    end))


;;;
;;;; Composite-Text-View
;;;


(class Composite-Text-View extends Value-Text-View
  
  
  (method (tab-press key modifiers)
    (cond ((has-completion?) (end-completion))
          ((control-key? modifiers) (view-completions))
          ((shift-key? modifiers) (navigate-backward))
          (else (navigate-forward))))
  
  
  (method (get-context-menu)
    (new Composite-Menu))
  
  
  (method (on-navigate-backward evt)
    (navigate-backward))
  
  
  (method (on-navigate-forward evt)
    (navigate-forward))
  
  
  (method (on-view-completions evt)
    (view-completions))
  
  
  ;;;
  ;;;; Actions
  ;;;
  

  (method (focus-actions)
    (cons (find-actions 'composite-text)
          (nextmethod)))
  
  
  ;;;
  ;;;; Completion
  ;;;
  
  
  (method (complete-name? size)
    (>= size 1))
  
  
  (method (favorite-completions)
    '())
  
  
  (method (symbol-completions name favorites)
    (let* ((entries (current-entries))
           (position (current-position entries)))
      (when position
        (let ((domain (part-domain position)))
          (when domain
            (let ((completer (new Symbol-Completer domain)))
              (complete~ completer name))))))))


;;;
;;;; Composite-Menu
;;;


(class Composite-Menu extends Text-Context-Menu
  
  
  (form
    (<install>
      (<Separator-Item>)
      (<Label-Item>     name: navigate-backward title: "Move &Backward" icon: {Bitmap-Resource "Backward"} action: {Action composite-text navigate-backward})
      (<Label-Item>     name: navigate-forward  title: "Move &Forward" icon: {Bitmap-Resource "Forward"} action: {Action composite-text navigate-forward})
      (<Separator-Item>)
      (<Label-Item>     name: view-completions  title: "View &Completions" icon: {Bitmap-Resource "Edit"} action: {Action composite-text view-completions}))))


;;;
;;;; Completion-Tree
;;;


(class Completion-Tree extends Tree-View
  
  
  (form
    (<install>            portfolio: :icons selection-mode: node
      (<Tree-Node-Column> width: 200 toplevel-controls?: #f)))
  
  
  (property selected initialize {} getter get-selected setter set-selected)
  (property start    initialize {} getter get-start    setter set-start)
  (property end      initialize {} getter get-end      setter set-end)
  
  
  (method public (get-selected)
    selected)
  
  
  (method public (set-selected value)
    (set! selected value))
  
  
  (method public (get-start)
    start)
  
  
  (method public (set-start value)
    (set! start value))
  
  
  (method public (get-end)
    end)
  
  
  (method public (set-end value)
    (set! end value))
  
  
  (method (return-press key)
    (complete-part start end self))
  
  
  (method (tab-press key modifiers)
    (complete-part start end self))
  
  
  (method (double-click pos)
    (complete-part start end self))))
