;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Documentation Extractor to a Design
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.doc.extract jazz


(import (jazz.ui)
        (jazz.library)
        (jazz.utilities))


(class Doc-Design-Extractor extends Object
  
  
  @commented-because-this-refers-to-metascoop-classes-metamodeler-to-convert (
  
  
  (method public (extract-doc file)
    (let* ((categories (documented-categories))
           (environment (new-environment (make-table test: eq?) {}))
           (frame (new-event Design-Book-View))
           (book (get-guest~ frame))
           (architecture (get-client~ book :architecture))
           (architecture-designer (get-designer~ book :architecture))
           (layout (get-client~ book :layout))
           (layout-designer (get-designer~ book :layout)))
      (for-each (function (category-name)
                  (let ((category (get-category category-name environment)))
                    (extract-category category book architecture architecture-designer layout layout-designer)))
                categories)
      (for-each (function (category-name)
                  (let ((category (get-category category-name environment)))
                    (extract-relation category book architecture architecture-designer layout layout-designer)))
                categories)
      (process-refresh~ architecture-designer (get-tables-section~ architecture) 'descendants)
      (user-message "Doc extracted ({a} categories)" (length categories))))
  
  
  ;;;
  ;;;; Categories
  ;;;
  
  
  (definition Details
    '((name 90 #t)
      (physical-name 100 #f)
      (physical-datatype 100 #f)
      (logical-datatype 100 #f)
      (nullable? 100 #f)
      (description filled #t)))
  
  
  (method (extract-category category book architecture architecture-designer layout layout-designer)
    (let ((name (->string (type-name category)))
          (meta (class-of category)))
      (user-message "Extracting {a}..." name)
      (let* ((tables (get-tables-section~ architecture))
             (table (add-child~ architecture-designer (new Design-Table name: name parent: tables) tables name: name design-events?: #f))
             (columns (get-columns-section~ table))
             (graphicals (get-graphicals-section~ layout)))
        (extract-category-signature category table columns architecture-designer)
        (add-child~ layout-designer (new Design-Table-View name: name parent: graphicals) graphicals name: name properties: (list size: {Dimension 283 110} :details Details) design-events?: #f))))
  
  
  (method (extract-category-signature category table columns architecture-designer)
    (let ((kind (category-kind category))
          (ascendant (type-ascendant category))
          (package (category-package category)))
      (add-column architecture-designer columns "kind"    (list :description (->string kind)))
      (add-column architecture-designer columns "package" (list :description (if package (->string (type-name package)) "")))
      (add-column architecture-designer columns "extends" (list :description (if ascendant (->string (type-name ascendant)) "")))
      (case kind
        ((class)
          (let ((interfaces (class-interfaces category)))
            (add-column architecture-designer columns "implements" (list :description (join (map ->string (map type-name interfaces)) " "))))))))
  
  
  ;;;
  ;;;; Relations
  ;;;
  
  
  (method (extract-relation category book architecture architecture-designer layout layout-designer)
    (let ((name (->string (type-name category)))
          (ascendant (type-ascendant category)))
      (when ascendant
        (let* ((ascendant-name (->string (type-name ascendant)))
               (relation-name (format "{a} -> {a}" name ascendant-name))
               (relations (get-relations-section~ architecture)))
          (add-child~ architecture-designer (new Design-Relation name: name parent: relations) relations name: relation-name properties: (list primary-table: name foreign-table: ascendant-name) design-events?: #f)
          (let ((relations (get-relations-section~ layout)))
            (add-child~ layout-designer (new Design-Relation-View name: name parent: relations) relations name: relation-name properties: (list start: name end: ascendant-name) design-events?: #f))))))
  
  
  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (add-column architecture-designer parent name properties)
    (add-child~ architecture-designer (new Design-Column) parent name: (->string name) properties: properties design-events?: #f))
  
  
  ;;;
  ;;;; Utilities
  ;;;

  
  (method (documented-categories)
    (let ((categories '()))
      (for-each-source
        (function (category-name source properties)
          (when (neq? category-name 'Language)
            (set! categories (cons category-name categories)))))
      (sort < categories)))
  
  
  (method (category-kind category)
    (cond ((class? category) 'class)
          ((interface? category) 'interface)
          ((package? category) 'package)
          (else (error "What's that: {t}" category)))))))
