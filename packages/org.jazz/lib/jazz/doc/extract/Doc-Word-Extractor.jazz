;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Documentation Extractor to Word
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; See Doc-Extractor for comments


(class Doc-Word-Extractor extends Object
  
  
  (method public (extract-doc file)
    (let ((categories (documented-categories))
          (environment (new-environment (make-table test: eq?) {})))
      (call-with-output-file (parse~ file)
        (lambda (printer)
          (for-each (function dynamic (category-name)
                      (let ((category (get-category category-name environment)))
                        (extract-category category printer)))
                    categories)))
      (user-message "Doc extracted ({a} categories)" (length categories))))
  
  
  ;;;
  ;;;; Categories
  ;;;
  
  
  (method (extract-category category printer)
    (let ((name (type-name category))
          (meta (class-of category)))
      (user-message "Extracting {a}..." name)
      (format printer "%%hs%%{a}%%he%%{%}" name)
      (extract-category-signature category printer)
      (unless (memq? name '(Category Type))
        (extract-fields meta " meta" printer))
      (extract-fields category "" printer)
      (format printer "{%}{%}")))
  
  
  (method (extract-category-signature category printer)
    (let ((kind (category-kind category))
          (ascendant (type-ascendant category)))
      (format printer "{%}  {a} %%us%%{a}%%ue%%" kind (type-name category))
      (when ascendant
        (format printer " extends %%rs%%{a}%%re%%" (type-name ascendant)))
      (case kind
        ((class)
          (let ((interfaces (class-interfaces category)))
            (case (length interfaces)
              ((0))
              ((1) (format printer " implements %%rs%%{l}%%re%%" (map type-name interfaces)))
              (else (format printer " implements {a}"
                            (map (function dynamic (interface)
                                   (let ((name (type-name interface)))
                                     (format "%%rs%%{a}%%re%%" name)))
                                 interfaces)))))))
      (format printer "{%}")))
  
  
  (method (extract-fields category prefix printer)
    (let ((forms (collect-forms category)))
      (extract-properties category forms prefix printer)
      (extract-methods category forms prefix printer)))
  

  (method (collect-forms category)
    (map (function dynamic (info)
           (bind (name . value) info
             (let ((field (category-field category name)))
               (list field name value))))
         (gather (category-forms category))))
  
  
  ;;;
  ;;;; Properties
  ;;;
  
  
  (method (extract-properties category forms prefix printer)
    (let ((properties (collect-type Property forms key: car)))
      (when properties
        (format printer "{%}")
        (let ((max (apply max (map length (map second properties)))))
          (for-each (function dynamic (form)
                      (bind (field name value) form
                        (let ((getter (property-getter field))
                              (setter (property-setter field)))
                          (format printer "  (property{a} %%fs%%{a}%%fe%%{_ :v} getter {a}{_ :v}{a}){%}"
                                  prefix
                                  name (- max (length name))
                                  getter (- max (length name))
                                  (if setter (format " setter {a}" setter) "")))))
                    properties)))))
  
  
  ;;;
  ;;;; Methods
  ;;;
  
  
  (method (extract-methods category forms prefix printer)
    (let ((methods (sort < (collect-if (function dynamic (form)
                                         (bind (field name value) form
                                           (or (memq? name '(construct-literal initialize))
                                               (and (definition? field)
                                                    (or (field-public? field)
                                                        (definition-virtual? field))
                                                    (procedure? value)
                                                    (eq? (field-creator (definition-origin field)) category)))))
                                       forms)
                         key: second)))
      (when methods
        (let ((pair (find-in methods 'initialize key: second)))
          (when pair
            (set! methods (cons pair (remove! pair methods)))))
        (let ((pair (find-in methods 'construct-literal key: second)))
          (when pair
            (set! methods (cons pair (remove! pair methods)))))
        (let ((max (apply max (map length (map second methods)))))
          (format printer "{%}")
          (for-each (function dynamic (form)
                      (bind (field name value) form
                        (extract-method field name value max prefix printer)))
                    methods)))))
  
  
  (method (extract-method field name func max prefix printer)
    (let ((parameters (function-parameters func))
          (body (function-body func))
          (access (present-access field))
          (virtual (if (definition-virtual? field) "virtual" "")))
      (format printer "  (method{a} {a}{_ :v} {a}{_ :v} (%%fs%%{a}%%fe%%{_ :v} {a})){%}"
              prefix
              access
              (- 9 (length access))
              virtual
              (- 7 (length virtual))
              name
              (- max (length name))
              (present-parameters parameters body))))
  
  
  (method (present-access field)
    (cond ((field-public? field)
           'public)
          ((field-protected? field)
           'protected)))
  
  
  (method (present-parameters parameters body)
    (if (proper-list? parameters)
        (format "{l}" parameters)
      (let ((proper (but-last-cdr parameters))
            (rest (last-cdr parameters)))
        (format "{l}{a}. {a}"
                proper
                (if proper " " "")
                present-rest))))
  
  
  ;;;
  ;;;; Utilities
  ;;;

  
  (method (documented-categories)
    (let ((categories '()))
      (for-each-source
        (function dynamic (category-name source properties)
          (when (neq? category-name 'Language)
            (set! categories (cons category-name categories)))))
      (sort < categories)))
  
  
  (method (category-kind category)
    (cond ((class? category) 'class)
          ((interface? category) 'interface)
          ((package? category) 'package))))
