;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; JML Parser
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.jml.parser.JML-Parser jazz


(import (jazz.utilities)
        (jazz.jml)
        (jazz.library))


(class JML-Parser-Class extends Class
  
   
  (slot patterns initialize '())
  
  
  (method public (get-patterns)
    patterns)
  
  
  (method public (add-pattern pattern)
    (unless (memq? pattern patterns)
      (set! patterns (cons pattern patterns))))
  
  
  (method public (has-pattern? tag)
    (let ((class self)
          (found? #f))
      (while (and (not found?) (neq? class JML-Parser))
        (let ((patterns (get-patterns~ class)))
          (if (memq? tag patterns)
              (set! found? #t)
            (set! class (type-ascendant class)))))
      found?)))

(class JML-Parser metaclass JML-Parser-Class extends Object
  
 
  
  
  ;;;
  ;;;; Parser
  ;;;
  
  
  (slot preferences)
  
  
  (method (initialize (preferences: preferences {}))
    (nextmethod)
    (set! preferences~self preferences))
  
  
  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-preferences)
    preferences)
  
  
  ;;;
  ;;;; Parse
  ;;;
  
  
  (method public (parse reader/expr)
    (if (is? reader/expr Reader)
        (parse-reader reader/expr)
      (parse-expr {} reader/expr)))
  
  
  (method (parse-reader reader)
    (parse-expr {} (read reader)))
  
  
  (method (parse-expr parent expr)
    (parse-any parent expr))
  
  
  (method (parse-any parent object)
    (if (pattern-expr? object)
        (parse-pattern parent object)
      (parse-noexpand parent object)))
  
  
  (method (parse-noexpand parent object)
    (cond ((not object)
           {})
          ((is? object JML-Node)
           (set-parent~ object parent)
           object)
          ((tagged-expr? object)
           (parse-node parent object))
          ((and (pair? object) (symbol? (car object)))
           (parse-new-node parent object))
          ((pair? object)
           (map (function dynamic (sub)
                  (parse-expr parent sub))
                object))
          (else
           (error "Unable to parse: {s}" object))))
  
  
  (method (parse-pattern parent pattern)
    (let* ((first (car pattern))
           (tag (tag->name first))
           (expansion (expand-pattern pattern tag)))
      (if (and (pair? expansion) (eq? (car expansion) first))
          (parse-noexpand parent expansion)
        (parse-any parent expansion))))
  
  
  (method (parse-node parent expr)
    (let ((first (car expr)))
      (if (tag? first)
          (parse-jml-node parent expr)
        (parse-new-node parent expr))))
  
  
  (method (parse-new-node parent expr)
    (bind (model . rest) expr
      (let ((class (autoload model)))
        (receive (properties-list children-list) (parse-jml-properties/children rest :keywords? #t)
          (let* ((node (apply new class properties-list))
                 (children (parse-children node children-list)))
            (when children
              (set-children~ node children))
            node)))))
  
  
  (method (parse-jml-expr expr)
    (bind (first . rest) expr
      (let ((tag (tag->name first)))
        (receive (properties-list children-list) (parse-jml-properties/children rest)
          (values tag properties-list children-list)))))
  
  
  (method (parse-jml-node parent expr)
    (bind (first . rest) expr
      (let ((tag (tag->name first)))
        (receive (properties-list children-list) (parse-jml-properties/children rest)
          (let* ((node (new JML-Element parent tag))
                 (properties (parse-properties properties-list))
                 (children (parse-children node children-list)))
            (set-properties~ node properties)
            node)))))
  
  
  (method (parse-properties properties)
    (let ((fact (new List-Factory)))
      (for-each-property (function dynamic (property value)
                           (let ((name (symbol->string property)))
                             (if (or (starts-with? name "<") (ends-with? name "="))
                                 (error "Invalid property: {s}" property)
                               (let ((value (parse-property value)))
                                 (validate-property property value)
                                 (put~ fact property)
                                 (put~ fact value)))))
                         properties)
      (get-output~ fact)))
  
  
  (method (parse-children parent children)
    (let ((fact (new List-Factory)))
      (for-each (function dynamic (element)
                  (if (string? element)
                      (put~ fact (new JML-Text parent element))
                    (let ((jml (parse-expr parent element)))
                      (add-nodes fact jml))))
                children)
      (get-output~ fact)))
  
  
  (method (add-nodes fact nodes)
    (if (or (null? nodes) (pair? nodes))
        (for-each (function dynamic (node)
                    (add-nodes fact node))
                  nodes)
      (put~ fact nodes)))
  
  
  (method (parse-property value)
    (if (and (pair? value) (eq? (car value) :string))
        (map parse-property value)
      (parse-value value)))
  
  
  (method (parse-value value)
    (if (is? value Path)
        (parse-path value)
      value))
  
  
  (method (parse-path value (use-generator?: use-generator? #t))
    (bind (alias . path) (get-path~ value)
      (apply append (cons (get-alias alias :use-generator? use-generator?) path))))
  
  
  (method protected virtual (tag-valid? tag)
    #t)
  
  
  (method protected virtual (validate-tag tag)
    (unless (tag-valid? tag)
      (error "Unknown tag: {a}" tag)))
  
  
  (method protected virtual (validate-property property value)
    )
  
  
  ;;;
  ;;;; Utilities
  ;;;
  
  
  (method (parse-result expr)
    (parse-noexpand
      {}
      expr))
  
  
  (method (pattern-expr? expr)
    (and (pair? expr)
         (let ((first (car expr)))
           (and (tag? first)
                (let ((class (class-of self))
                      (tag (tag->name first)))
                  (has-pattern?~ class tag))))))
  
  
  (method (tagged-expr? expr)
    (and (pair? expr)
         (let ((first (car expr)))
           (tag? first))))
  
  
  (method (expand-pattern tree tag)
    (let ((proc (eval-symbol tag self)))
      (proc~ self tree)))
  
  
  ;;;
  ;;;; Aliases
  ;;;
  
  
  (method protected virtual (get-alias name . rest)
    (error "Unknown alias: {s}" name))))
