;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; New-Reader
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.library.iterator.New-Reader jazz


(import (jazz.library)
        (jazz.utilities))


(class New-Reader extends Iterator


  (definition Empty
    '(empty))


  (slot next)


  (method (getc)
    (if (eq? next Empty)
        (get-next)
      (prog1 next
        (set! next Empty))))


  (method (ungetc c)
    (set! next c))


  (method (peekc)
    (when (eq? next Empty)
      (set! next (get-next)))
    next)


  (method (reset-next)
    )


  (method protected virtual (read)
    )


  (method (skip-line)
    (let ((c (getc)))
      (while (and (/= c (eof-object)) (/= c #x0A) (/= c #x0D))
        (set! c (getc)))
      (when (eqv? c #x0D)
        (getc))))


  (method (skip-whites)
    (while #t
      (let ((c (getc)))
        (cond ((eqv? c (eof-object))
               (return))
              ((eqv? c #\semi-colon)
               (skip-line))
              ((space? c))
              (else
               (ungetc c)
               (return))))))


  (method (read-list)
    (getc)
    (read-composite #\right-parenthesis))


  (method (read-reference)
    (getc)
    (let ((form (read))
          (context (read)))
      (skip-whites)
      (when (!= (getc) #\close-bracket)
        (error "Bad reference form"))
      (new-reference form context)))


  (method (read-literal context)
    (getc)
    (let ((symbol (read)))
      (construct-literal context (eval-symbol symbol self) (read-composite #\close-brace))))


  (method (read-composite delimiter)
    (let ((out (new List-Factory)))
      (skip-whites)
      (while (!= (peekc) delimiter)
        (cond ((= (peekc) #\period)
               (getc)
               (put-sequence~ out (read)))
              (let ((form (read)))
                (cond ((= form Empty)
                       ???)
                      ((= form (eof-object))
                       (error "Unexpected end of stream reached while reading composite {t}" delimiter))
                      (else
                       (put~ out form))))))
      (getc)
      (get-output~ out)))


  (method (end-composite delimiter)
    (skip-whites)
    (let ((c (getc)))
      (when (not (eqv? c delimiter))
        (error "Unexpected character while reading composite: {t}" c))))


  (method (read-into-string str numeric?)
    (let ((c)
          (first? #t)
          (pos 0))
      (while #t
        (let ((c (getc)))
          (cond ((eqv? c (eof-object))
                 )
                ((eqv? c #\backslash)
                 (set! c (getc)))
                ((and (not first?)
                      (/= (JzReadtableCharType c) 'constituent)
                      (or (/= c #\period) (not numeric?)))
                 (ungetc)
                 ))
          (set-element! str pos c)
          (set! pos (+ pos 1))
          (set! first? #f)))
      (set-element! str pos #\nul)
      (adjust-string str)
      str))


  (method (read-constituent)
    (let ((str (make-string 256)))
      (read-into-string str #f)
      (cond ((hexadecimal-string? str)
             (parse-hexadecimal-string str))
            ((integer-string? str)
             (JzAtol str))
            (else
             (intern str)))))


  (method (read-quote)
    (getc)
    (list 'quote (read)))


  (method (read-string)
    (let ((str (make-string 256))
          (pos 0))
      (getc)
      (while #t
        (let ((c (getc)))
          (cond ((eqv? c (eof-object))
                 (read-error))
                ((eqv? c #\double-quote)
                 )
                ((eqv? c #\backslash)
                 (set! c (getc))))
          (set-element! str pos c)
          (set! pos (+ pos 1))))
      (set-element! str pos #\nul)
      (adjust-string str)
      str))


  (method (read-error)
    (error "Read error"))


  (method protected virtual (read-block jBuffer)
    )))
