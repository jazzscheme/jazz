;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Directories
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.library.moniker.Directory-Group jazz


(import (jazz.library)
        (jazz.io))


(class Directory-Group extends Directory
  
  
  (method (fold-literal)
    `(new Directory-Group ',path))
  
  
  (method (print printer readably)
    (format printer "~{Directory-Group {l detail: :v}}"
            (get-list)
            readably))
  
  
  @convert
  (method meta (validate-component lst)
    (for-each (function dynamic (dir)
                (when (is-not? dir Directory)
                  (error "{s} is not of the expected Directory type" dir)))
              lst))
    
        
  ;;;
  ;;;; Protocol
  ;;;
  
  
  @convert
  (method meta (get-protocol)
    'group)
  
  
  @convert-dialog
  (method meta (get-modal . rest)
    (bind-keywords ((actual {}) . others) rest
      (new Directory-Group (get-modal Directories-Chooser :directories (essay actual (get-list~ actual))))))
  
  
  @convert
  (method meta (new-moniker list)
    (new self list))
  
  
  (method (present)
    (format "{l}" (get-list)))
  
  
  ;;;
  ;;;; Operations
  ;;;
  
  
  (method (get-name)
    "Directory-Group")
  
  
  (method (get-directory)
    self)
  
  
  (method public (get-content . rest)
    (let* ((content (apply nextmethod rest))
           (key (function dynamic (moniker) (get-name~ moniker)))
           (some-symbol? (some? symbol? content key: key))
           (some-string? (some? string? content key: key)))
      (if (and some-string? some-symbol?)
          (map (function dynamic (moniker)
                 (if (string? (key moniker))
                     moniker
                   (new (class-of moniker) (expand~ moniker))))
               content)
        content)))


  (method (get-modification-time)
    {})


  (method public (create)
    (break)
    ;; Do nothing
    )
  
  
  (method public (delete-directory (overwrite-read-only?: overwrite-read-only? false) (feedback: feedback {}))
    (when feedback
      (feedback self))
    (empty-directory :overwrite-read-only? overwrite-read-only? feedback: feedback))
     
   
  ;;;
  ;;;; Iterator
  ;;;
  
  
  (method public (iterate-directory proc (full?: full? true) (files?: files? true) (directories?: directories? false) (recursive?: recursive? true) (ignored-directories: ignored-directories '()))
    ;;  this function might not give the expected result
    ;;  if full? is false and the content elements are not all brothers
    ;;  ignored-directories is not used to filter the first level, only susequent ones
    (let ((items (get-list)))
      (for-each (function dynamic (element)
                  (typecase element
                    ((File)
                     (when files?
                       (if full? (proc element) (proc (list (get-name~ element)) 'file))))
                    ((Directory)
                     (when directories?
                       (let ((name (get-name~ element)))
                         (when (and directories? (not (member? name ignored-directories)))
                           (if full?
                               (proc element)
                             (proc (list name) 'directory)))
                         (when recursive?
                           (iterate-directory-content~ element files? directories? recursive? ignored-directories (list name) (parse~ element) proc)))))))
                items)))))
