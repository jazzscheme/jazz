;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Performance Utilities
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library Performance jazz


@WAIT (
  
  
  ;;;
  ;;;; Performance
  ;;;
  
  
  (method public (performance-snapshot . rest)
    (bind-keywords ((name {})) rest
      (let ((handle (GetCurrentProcess)))
        (let ((creation-time (new FILETIME))
              (exit-time (new FILETIME))
              (kernel-time (new FILETIME))
              (user-time (new FILETIME)))
          (GetProcessTimes handle creation-time exit-time kernel-time user-time)
          (let ((time (function dynamic (filetime)
                        (make-long (get filetime 'dwLowDateTime)
                                   (get filetime 'dwHighDateTime)))))
            (parse-jml
              `(<performance>
                 name: ,name
                 kernel-time: ,(time kernel-time)
                 user-time: ,(time user-time))))))))
  
  
  ;;;
  ;;;; Resources
  ;;;
  
  
  (method public (resources-snapshot . rest)
    (bind-keywords ((name {})) rest
      (let ((handle (GetCurrentProcess)))
        (let ((private-bytes (get-private-bytes)))
          (let ((gui-gdi-objects (GetGuiResources handle GR_GDIOBJECTS))
                (gui-user-objects (GetGuiResources handle GR_USEROBJECTS)))
            (bind-values (ok? handles) (GetProcessHandleCount handle)
              (bind (symbols-allocated symbols-free) (symbols-statistics)
                (let ((system-stack (system-stack-info))
                      (data-stack (data-stack-info))
                      (undestroyed (gc-undestroyed-count)))
                  (bind (collector-stack collector-roots) (gc-statistics)
                    (bind (symbols zones heap) (statistics)
                      (bind ({} {} string vector hashtable map virtual object collector) heap
                        (bind (size bags committed allocated free bytes-committed bytes-allocated bytes-free usage trigger-count lifetime) (last (objects-info zones))
                          (parse-jml
                            `(<resources>
                               name: ,name
                               private-bytes: ,private-bytes
                               committed: ,bytes-committed
                               allocated: ,bytes-allocated
                               gui-gdi-objects: ,gui-gdi-objects
                               gui-user-objects: ,gui-user-objects
                               handles: ,handles
                               symbols: ,(- symbols-allocated symbols-free)
                               strings: ,string
                               virtual: ,virtual
                               system-stack: ,system-stack
                               data-stack: ,data-stack
                               collector-stack: ,collector-stack
                               collector-roots: ,collector-roots
                               undestroyed: ,undestroyed
                               bags: ,bags))))))))))))))
  
  
  ;; All this could probably be encapsulated by caching the query and/or counter
  ;; in the query and/or counter class like .net most probably does...
  
  
  (definition Private-Bytes-Query
    {})
  
  (definition Private-Bytes-Counter
    {})
  
  
  (method (get-private-bytes-query)
    (when (null? Private-Bytes-Query)
      (setup-private-bytes))
    Private-Bytes-Query)
  
  
  (method (get-private-bytes-counter)
    (when (null? Private-Bytes-Counter)
      (setup-private-bytes))
    Private-Bytes-Counter)
  
  
  (method (setup-private-bytes)
    (let* ((query (new Performance-Query))
           (counter (add-counter~ query :object-name "Process" :counter-name "Private Bytes")))
      (set! Private-Bytes-Query query)
      (set! Private-Bytes-Counter counter)))
  
  
  (method public (get-private-bytes)
    (let ((query (get-private-bytes-query))
           (counter (get-private-bytes-counter)))
      (collect-data~ query)
      (get-counter-value~ query counter)))
  
  
  ;;;
  ;;;; Memory
  ;;;
  
  
  (method public (objects-info info)
    (bind (zones) info
      (let ((bags-total            0)
             (committed-total        0)
             (allocated-total       0)
             (free-total            0)
             (bytes-committed-total  0)
             (bytes-allocated-total 0)
             (bytes-free-total      0)
             (gc-count              0)
             (lifetime-total        0)
             (factory (new List-Factory)))
        (for-each (function dynamic (info)
                    (bind (nb-bags size committed free trigger-count lifetime) info
                      (let* ((allocated       (- committed free))
                             (bytes-committed  (* size committed))
                             (bytes-allocated (* size allocated))
                             (bytes-free      (* size free)))
                        (increase! bags-total            nb-bags)
                        (increase! committed-total        committed)
                        (increase! allocated-total       allocated)
                        (increase! free-total            free)
                        (increase! bytes-committed-total  bytes-committed)
                        (increase! bytes-allocated-total bytes-allocated)
                        (increase! bytes-free-total      bytes-free)
                        (increase! gc-count              trigger-count)
                        (increase! lifetime-total        lifetime)
                        (put~ factory
                              (list
                               size
                               nb-bags
                               committed
                               allocated
                               free
                               bytes-committed
                               bytes-allocated
                               bytes-free
                               (if (= committed 0) 0 (percentage allocated committed))
                               trigger-count
                               lifetime)))))
                  zones)
        (put~ factory
              (list
               "Total"
               bags-total
               committed-total
               allocated-total
               free-total
               bytes-committed-total
               bytes-allocated-total
               bytes-free-total
               (percentage bytes-allocated-total bytes-committed-total)
               gc-count
               lifetime-total))
        (get-output~ factory))))
  
  
  ;;;
  ;;;; I/O
  ;;;
  
  
  (method public (i/o-snapshot . rest)
    (bind-keywords ((name {})) rest
      (let ((handle (GetCurrentProcess)))
        (let ((io (new IO_COUNTERS)))
          (GetProcessIoCounters handle io)
          (parse-jml
            `(<i/o>
               name: ,name
               read-bytes: ,(get io 'ReadTransferCount)
               write-bytes: ,(get io 'WriteTransferCount)
               other-bytes: ,(get io 'OtherTransferCount))))))))
)