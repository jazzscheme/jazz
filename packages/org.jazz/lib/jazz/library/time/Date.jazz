;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Dates
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.library.time.Date jazz


(definition public (parse-string str (error?: error? #t))
  (if (valid-string? str)
      (let* ((len    (cardinality str))
             (year   (parse-integer (subseq str 0 4)))
             (month  (parse-integer (subseq str 5 7)))
             (day    (parse-integer (subseq str 8 10)))
             (hour   (parse-integer (subseq str 11 13)))
             (minute (parse-integer (subseq str 14 16)))
             (second (if (memq? len '(19 23)) (parse-integer (subseq str 17 19)) 0))
             (milliseconds (if (= len 23) (parse-integer (subseq str 20 23)) 0)))
        (new Date year month day hour minute second milliseconds))
    (when error?
      (error "Unable to parse date: {t}" str))))


(definition public (valid-string? str)
  (let ((len (cardinality str)))
    (and (string? str)
         (memq? len '(16 19 23))
         (member? (element str 4) '(#\slash #\minus))
         (member? (element str 7) '(#\slash #\minus))
         (= (element str 10) #\space)
         (= (element str 13) #\colon)
         (numeric? (subseq str 0 4))
         (numeric? (subseq str 5 7))
         (numeric? (subseq str 8 10))
         (numeric? (subseq str 11 13))
         (numeric? (subseq str 14 16))
         (or (= len 16)
             (and (= (element str 16) #\colon)
                  (or (= len 19)
                      (= (element str 19) #\period)))))))


(definition public (parse-date str (error?: error? #t))
  (if (valid-date-string? str)
      (let ((year   (parse-integer (subseq str 0 4)))
            (month  (parse-integer (subseq str 5 7)))
            (day    (parse-integer (subseq str 8 10))))
        (new Date year month day))
    (when error?
      (error "Unable to parse date: {t}" str))))


(definition public (valid-date-string? str)
  (and (string? str)
       (= (cardinality str) 10)
       (member? (element str 4) '(#\slash #\minus))
       (member? (element str 7) '(#\slash #\minus))
       (numeric? (subseq str 0 4))
       (numeric? (subseq str 5 7))
       (numeric? (subseq str 8 10))))


(definition public (local-date)
  (unimplemented 'local-date)
  @SYSTEMTIME
  (let ((st (new SYSTEMTIME)))
    (GetLocalTime st)
    (from-systemtime st)))


(definition public (universal-date)
  (unimplemented 'universal-date)
  @SYSTEMTIME
  (let ((st (new SYSTEMTIME)))
    (GetSystemTime st)
    (from-systemtime st)))


(definition public (from-systemtime st)
  (unimplemented 'from-systemtime)
  @Window-specific
  (let ((time (new Date (get st 'wYear)
                   (get st 'wMonth)
                   (get st 'wDay)
                   (get st 'wHour)
                   (get st 'wMinute)
                   (get st 'wSecond))))
    (set-day-of-week~ time (get st 'wDayOfWeek))
    (set-milliseconds~ time (get st 'wMilliseconds))
    time))


(definition public (from-vtdate vtdate)
  (unimplemented 'from-vtdate)
  @SYSTEMTIME
  (with ((system (new SYSTEMTIME)))
    (VariantTimeToSystemTime vtdate system)
    (from-systemtime system)))


;;;
;;;; Week
;;;


(definition Days-Of-Week
  '((0 sunday    "Sun" "Sunday")
    (1 monday    "Mon" "Monday")
    (2 tuesday   "Tue" "Tuesday")
    (3 wednesday "Wed" "Wednesday")
    (4 thursday  "Thu" "Thursday")
    (5 friday    "Fri" "Friday")
    (6 saturday  "Sat" "Saturday")))


(definition public (symbolic-days-of-week)
  (map second Days-Of-Week))


(definition public (symbolic-day-of-week numeric)
  (let ((info (find-day-of-week-info numeric)))
    (second info)))


(definition public (numeric-day-of-week symbolic)
  (let ((info (find-day-of-week-info symbolic)))
    (first info)))


(definition public (present-day-of-week key)
  (let ((info (find-day-of-week-info key)))
    (third info)))


(definition public (weekend-day? key)
  (let ((info (find-day-of-week-info key)))
    (memq? (second info) '(sunday saturday))))


(definition (find-day-of-week-info key)
  (find-in Days-Of-Week key key: (if (integer? key) first second)))


;;;
;;;; Date
;;;
  

(class Date extends Object)


@very-windows-specific
  

(class Date extends Object
  
  
  (slot year)
  (slot month)
  (slot day-of-week)
  (slot day)
  (slot hour)
  (slot minute)
  (slot second)
  (slot milliseconds)
  
  
  @unimplemented
  (method meta (construct-literal context year (month 1) (day 1) (hour 0) (minute 0) (second 0) (milliseconds 0))
    (new self year month day hour minute second milliseconds))
  
  
  ;;;
  ;;;; System
  ;;;
  
  
  (method public (universal->local)
    (get-date~ (universal->local~ (get-time))))
  
  
  (method public (local->universal)
    (get-date~ (local->universal~ (get-time))))
  
  
  ;;;
  ;;;; Parse
  ;;;
  
  
  ;;;
  ;;;; Date
  ;;;
  
  
  (method (initialize year (month 1) (day 1) (hour 0) (minute 0) (second 0) (milliseconds 0))
    (nextmethod)
    (set! year~self year)
    (set! month~self month)
    (set! day~self day)
    (set! hour~self hour)
    (set! minute~self minute)
    (set! second~self second)
    (set! milliseconds~self milliseconds)
    (update))
  
  
  (method (update)
    (update-day-of-week))
  
  
  (method (copy-object deep?)
    (new Date year month day hour minute second milliseconds))


  (method (compare-object target)
    (if (is-not? target Date)
        :incompatible
      (compare (get-time) (get-time~ target))))
  
  
  (method (print printer readably)
    (if (= readably :human)
        (format printer "{a}" (present))
      (if (day-date?)
          (format printer "~{{a} {a} {a} {a}}"
                  (identifier-name (type-name (class-of self)))
                  year
                  month
                  day)
        (format printer "~{{a} {a} {a} {a} {a} {a} {a} {a}}"
                (identifier-name (type-name (class-of self)))
                year
                month
                day
                hour
                minute
                second
                milliseconds))))
  
  
  ;;;
  ;;;; Convert
  ;;;
  
  
  (method public (get-time)
    (let ((systemtime (get-systemtime))
          (filetime (new FILETIME)))
      ;; this will cause an error for a date like {Date 1000 1 1}
      (unless (SystemTimeToFileTime systemtime filetime)
        (error "Invalid date: {t}" self))
      (from-filetime filetime)))


  (method (get-systemtime)
    (let ((st (new SYSTEMTIME)))
      (fill-systemtime st)
      st))
  
  
  (method (fill-systemtime st)
    (set st 'wYear year)
    (set st 'wMonth month)
    (set st 'wDay day)
    (set st 'wHour hour)
    (set st 'wMinute minute)
    (set st 'wSecond second)
    (set st 'wMilliseconds milliseconds))
  
  
  ;;;
  ;;;; Arithmetic
  ;;;
  
  
  (definition days/week
    7)
  
  
  (method public (add field (value {}))
    (if (not value)
        (add-duration field)
      (add-field field value)))
  
  
  ;; This implementation is ugly in terms of memory allocation.
  ;; It is there temporarely for simplicity. A real implementation
  ;; would make use of an 'add!' method that adds destructively.
  (method (add-duration duration)
    (receive (years months weeks days hours minutes seconds) (get-amounts~ duration)
      (let ((result {}))
        (when years   (set! result (add-field 'year years)))
        (when months  (set! result (add-field 'month months)))
        (when weeks   (set! result (add-field 'week weeks)))
        (when days    (set! result (add-field 'day days)))
        (when hours   (set! result (add-field 'hour hours)))
        (when minutes (set! result (add-field 'minute minutes)))
        (when seconds (set! result (add-field 'second seconds)))
        (either result self))))
  
  
  (method (add-field field value)
    (case field
      ((year) (add-year value))
      ((month) (add-month value))
      ((week) (add 'day (* value days/week)))
      (else
       (let ((time (get-time)))
         (add~ time field value)
         (get-date~ time)))))
  
  
  (method (add-year value)
    (new Date (+ year value)))
  
  
  (method (add-month value)
    (let ((year year~self)
          (month (+ month value)))
      (cond ((<= month 0)
             (while (<= month 0)
               (decrease! year)
               (increase! month 12)))
            ((> month 12)
             (while (> month 12)
               (increase! year)
               (decrease! month 12))))
      (new Date year month day~self)))
  
  
  ;;;
  ;;;; Fields
  ;;;
  
  
  (method public (get-field field)
    (case field
      ((year) year)
      ((month) month)
      ((day) day)
      ((hour) hour)
      ((minute) minute)
      ((second) second)
      ((milliseconds) milliseconds)))
  
  
  ;;;
  ;;;; Year
  ;;;
  
  
  (method public (get-year)
    year)
  
  
  (method public (year-date)
    (if (year-date?)
        self
      (new Date year)))
  
  
  (method public (year-date?)
    (and (= month 1)
         (= day 1)
         (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-year? date)
    (= year (get-year~ date)))
  
  
  (method public (iterate-year proc)
    (let ((date (year-date)))
      (while (same-year? date)
        (proc date)
        (set! date (add~ date 'month 1)))))
  
  
  ;;;
  ;;;; Month
  ;;;
  
  
  (method public (get-month)
    month)
  
  
  (method public (month-date)
    (if (month-date?)
        self
      (new Date year month)))
  
  
  (method public (month-date?)
    (and (= day 1)
         (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-month? date)
    (and (= year (get-year~ date))
         (= month (get-month~ date))))
  
  
  (method public (iterate-month proc)
    (let ((date (month-date)))
      (while (same-month? date)
        (proc date)
        (set! date (add~ date 'day 1)))))
  
  
  (method public (first-day-of-month)
    (let ((day (copy (day-date))))
      (set-day~ day 1)
      day))
  
  
  (method public (last-day-of-month)
    (add~ (add~ (first-day-of-month) 'month 1) 'day -1))
  
  
  (method public (previous-month)
    (add~ (first-day-of-month) 'month -1))
  
  
  (method public (next-month)
    (add~ (first-day-of-month) 'month 1))
  
  
  (definition Month-Names
    '((1  . "January")
      (2  . "February")
      (3  . "Mars")
      (4  . "April")
      (5  . "May")
      (6  . "June")
      (7  . "July")
      (8  . "August")
      (9  . "September")
      (10 . "October")
      (11 . "November")
      (12 . "December")))
  
  
  (definition Month-Abbrevs
    '((1  . "Jan")
      (2  . "Feb")
      (3  . "Mar")
      (4  . "Apr")
      (5  . "May")
      (6  . "Jun")
      (7  . "Jul")
      (8  . "Aug")
      (9  . "Sep")
      (10 . "Oct")
      (11 . "Nov")
      (12 . "Dec")))
  
  
  (method public (month-name)
    (cdr (assq month Month-Names)))
  
  
  (method public (month-abbrev)
    (cdr (assq month Month-Abbrevs)))
  
  
  (method public (get-week)
    (let ((date (add~ (last-day-of-week) 'week -1))
          (week 0))
      (while (same-month? date)
        (set! date (add~ date 'week -1))
        (increase! week))
      week))
  
  
  (method public (get-day-of-week)
    day-of-week)
  
  
  (method public (first-day-of-week)
    (add~ (day-date) 'day (- day-of-week)))
  
  
  (method public (last-day-of-week)
    (add~ (day-date) 'day (- 6 day-of-week)))
  
  
  (method public (day-abbrev)
    (third (find-day-of-week-info day-of-week)))
  
  
  (definition System-Time
    (new SYSTEMTIME))
  
  (definition File-Time
    (new FILETIME))
  
  
  (method synchronized (update-day-of-week)
    (fill-systemtime System-Time)
    (SystemTimeToFileTime System-Time File-Time)
    (FileTimeToSystemTime File-Time System-Time)
    (set! day-of-week (get System-Time 'wDayOfWeek)))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method public (get-day)
    day)
  
  
  (method public (set-day value)
    (set! day value)
    (update))
  
  
  (method public (day-date)
    (if (day-date?)
        self
      (new Date year month day)))
  
  
  (method public (day-date?)
    (and (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-day? date)
    (and (= year (get-year~ date))
         (= month (get-month~ date))
         (= day (get-day~ date))))
  
  
  ;;;
  ;;;; Hour
  ;;;
  
  
  (method public (get-hour)
    hour)
  
  
  (method public (set-hour value)
    (set! hour value))
  
  
  ;;;
  ;;;; Minute
  ;;;
  
  
  (method public (get-minute)
    minute)
  
  
  ;;;
  ;;;; Second
  ;;;
  
  
  (method public (get-second)
    second)
  
  
  ;;;
  ;;;; Milliseconds
  ;;;
  
  
  (method public (get-milliseconds)
    milliseconds)
  
  
  ;;;
  ;;;; Present
  ;;;
  
  
  (method public (present (date-separator: date-separator "/")
                          (time-separator: time-separator ":")
                          (milliseconds-separator: milliseconds-separator ".")
                          (seconds?: seconds? #t)
                          (milliseconds?: milliseconds? #f))
    (format "{a width: 4 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0} {a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a}"
            (subseq (->string year) 0 4)
            date-separator
            month
            date-separator
            day
            hour
            time-separator
            minute
            (if (or seconds? milliseconds?)
                (format "{a}{a width: 2 justify: :right padding: #\\0}" time-separator second)
              "")
            (if milliseconds?
                (format "{a}{a width: 3 justify: :right padding: #\\0}" milliseconds-separator milliseconds)
              "")))
  
  
  (method public (present-date . rest)
    (subseq (apply present rest) 0 10))
  
  
  ;; yuk... for informix
  @does-seem-necessary-anymore
  (method public (present-date2)
    (let ((date-separator "/"))
      (format "{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 4 justify: :right padding: #\\0}"
              day
              date-separator
              month
              date-separator
              (subseq (->string year) 0 4))))
  
  
  (method public (present-time . rest)
    (subseq (apply present rest) 11 16))
  
  
  (method public (present-compact (date-separator: date-separator "/") (time-separator: time-separator ":"))
    (format "{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0} {a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}"
            (subseq (->string year) 2)
            date-separator
            month
            date-separator
            day
            hour
            time-separator
            minute))
  
  
  (method public (present-duration (seconds?: seconds? #t))
    (let* ((printer (open-output-string))
           (empty? #t)
           (output
             (function dynamic (field)
               (let ((n (get-field field)))
                 (when (/= n 0)
                   (if empty?
                       (set! empty? #f)
                     (format printer ", "))
                   (format printer "{a} {a}{a}" n field (format-plural n)))))))
      (output 'year)
      (output 'month)
      (output 'day)
      (output 'hour)
      (output 'minute)
      (when (or seconds? empty?)
        (output 'second))
      (get-output-string printer)))))
