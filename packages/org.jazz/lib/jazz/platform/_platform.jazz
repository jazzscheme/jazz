;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Platform Access
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2006
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.platform jazz


(import (jazz.io)
        (jazz.library)
        (jazz.system)
        (jazz.ui)
        (jazz.ui.window))


;;;
;;;; Message Post
;;;


(definition public Pending-Posts
  '())

@unimplemented
(definition public Post-Primary-Lock
  (new Lock))


(definition public (post-primary proc)
  (proc)
  @calls-synchronize (
  (if (primary-thread?)
      (proc)
    (synchronize Post-Primary-Lock
      (set! Pending-Posts (cons proc Pending-Posts))
      (post-message~ Messenger JZ_POST (object-address proc) NULL)))
  {}))


(definition public (queue-primary proc)
  (unimplemented 'queue-primary)
  @calls-synchronize
  (synchronize Post-Primary-Lock
    (set! Pending-Posts (cons proc Pending-Posts))
    (post-message~ Messenger JZ_POST (object-address proc) NULL))
  {})


(definition public (receive-post wparam)
  (unimplemented 'receive-post)
  @address-object-unsafe
  (let ((proc (address-object-unsafe wparam)))
    (set! Pending-Posts (remove! proc Pending-Posts))
    (proc)
    0))

;; All this state manipulation is necessary because I dont
;; know any Windows API that returns the running state of a thread...
(definition public (wait-for object/objects (timeout: timeout {}) (error?: error? #t))
  (unimplemented 'wait-for)
  @unimp
  (let* ((get-handle
           (function dynamic (object)
             (if (integer? object)
                 object
               (get-handle~ object))))
         (timeout (either timeout INFINITE))
         (single? (not (pair? object/objects)))
         (handle/array
           (if single?
               (get-handle object/objects)
             (let ((handles (remove-nils (map get-handle object/objects))))
               (when handles
                 (let* ((count (length object/objects))
                        (array (new-array int count)))
                   (loop (for object in object/objects)
                         (for n from 0)
                         (do (array-set! array n (get-handle object))))
                   array)))))
         (thread (active-thread))
         (state (get-state~ thread)))
    ;; Can happen for instance if the thread has already terminated...
    (if (not handle/array)
        #t
      (unwind-protect
          (begin
            (set-state~ thread (+ state 1))
            (let ((result (if single?
                              (WaitForSingleObject handle/array timeout)
                            (WaitForMultipleObjects (array-length handle/array) handle/array #t timeout))))
              (if (= result WAIT_OBJECT_0)
                  #t
                (when (and (= result WAIT_TIMEOUT) error?)
                  (error "Wait for {t} timed out" object/objects)))))
        (set-state~ thread state)))))


;;;
;;;; Processes
;;;


(definition public (guess-process-instance)
  (unimplemented 'guess-process-instance)
  @gambit-threads
  (let ((process-id (GetCurrentProcessId))
        (process-base (module-base))
        (count 0))
    (call/ec
      (lambda (return)
        (for-each (function dynamic (id)
                    (if (= id process-id)
                        (return count)
                      (let ((handle (OpenProcess (bit-or PROCESS_QUERY_INFORMATION PROCESS_VM_READ) #f id)))
                        (let ((name (make-string MAX_PATH)))
                          (when (GetModuleBaseName handle NULL name MAX_PATH)
                            (adjust-string name)
                            (let ((base (extract-base name)))
                              (when (= base process-base)
                                (increase! count)))))
                        (CloseHandle handle))))
                  (collect-processes-id))))))


(definition public (collect-processes-id)
  (unimplemented 'collect-processes-id)
  @gambit-threads
  (let* ((count 512)
         (processes (new-array int count)))
    (receive (success? received) (EnumProcesses processes count)
      (let ((fact (new List-Factory)))
        (for-each (function dynamic (n)
                    (let ((id (array-ref processes n)))
                      (when (/= id 0)
                        (put~ fact id))))
                  (naturals 0 (array-length processes)))
        (get-output~ fact)))))


;;;
;;;; Crash
;;;


(definition public (snapshot-process)
  (unimplemented 'snapshot-process)
  @threads
  (new Thread
    name: "Process Snapshot"
    context: self
    execute: (function (thread)
               (snapshot-process-content))))


(definition public (dump-memory)
  (unimplemented 'dump-memory)
  @threads
  (new Thread
    name: "Memory Dump"
    context: self
    execute: (function (thread)
               (dump-memory-content))))


(definition public Crash-Info
  {})


(definition public (register-crash-info name context info)
  (unimplemented 'register-crash-info)
  @threads
  (let ((pair (assq name Crash-Info))
        (value (cons context info)))
    (if (not pair)
        (set! Crash-Info (append! Crash-Info (list (cons name value))))
      (set-cdr! pair value)))
  (update-crash-info))


(definition (update-crash-info)
  (unimplemented 'update-crash-info)
  @threads
  (let ((printer (open-output-string)))
    (for-each (function dynamic (pair)
                (bind (name . (context . info)) pair
                  (format printer "{%}   {a}{a} {a}"
                    name
                    (if context (format " {a}" context) "")
                    info)))
              Crash-Info)
    (let ((info (get-output-string printer)))
      (set-crash-info info))))


;;;
;;;; Platform
;;;


(definition public Mac
  0)

(definition public Unix
  1)

(definition public Win32
  2)


;;;
;;;; Line Ending
;;;


(definition public Mac-Ending
  0)

(definition public Unix-Ending
  1)

(definition public Windows-Ending
  2)


;;;
;;;; Aliases
;;;


(definition public (initialize-aliases)
  (new-alias 'Root #t)
  (new-alias 'Network "\\")
  (new-alias 'Home '("~"))
  (new-alias 'Boot '("."))
  (new-alias 'Jazz '(Boot ".." ".."))
  (new-alias 'org.jazz '(Jazz "packages" "org.jazz"))
  (new-alias 'org.jedi '(Jazz "packages" "org.jedi"))
  (new-alias 'Launch (get-launch-dir)))


(definition (get-launch-dir)
  (let ((path (pathname-argument "launchdir")))
    (if path
        (validate-alias 'Launch path)
      (list 'org.jedi "lib" "jedi"))))


(definition (pathname-argument name)
  (let ((arg (command-argument name)))
    (if (not arg)
        #f
      (tokenise
        (if (= (element arg 0) #\double-quote)
            (subseq arg 1 (- (length arg) 1))
          arg)))))


(definition (validate-alias name path)
  (if (exists?~ (new Directory path))
      path
    (error "Unable to set alias {t} to inexistant directory: {t}" name path)))


;;;
;;;; Module
;;;


(definition public (module-path)
  (unimplemented 'module-path)
  @windows-specific
  (let ((filename (make-string MAX_PATH)))
    (GetModuleFileName NULL filename MAX_PATH)
    (adjust-string filename)
    (tokenise filename)))


(definition public (module-pathname)
  (new File (module-path)))


(definition public (module-name)
  (get-name~ (module-pathname)))


(definition public (module-base)
  (get-base~ (module-pathname)))


(definition public (module-file filename)
  (new-file~ {Directory Boot} filename))


(definition public (module-timestamped-file base ext)
  (timestamped-file {Directory Boot} base expt))


;;;
;;;; File
;;;


(definition public (timestamped-file directory base ext)
  (let* ((dir (parse~ directory))
         (path (tokenise (timestamped-filename dir base ext))))
    (new File path)))


(definition (timestamped-filename dir base ext)
  (unimplemented))


;;;
;;;; Marshalling
;;;


(definition public (marshal-object object)
  (marshal~ object))


(definition public (unmarshal-object object)
  (unmarshal~ object))


;;;
;;;; Stack
;;;


;;(constant VK_CONTROL #x11)
;;(constant VK_MENU    #x12)


(definition public (dump-stack . rest)
  (bind-keywords ((file {}) (user-feedback? #f) . others) rest
    (unimplemented 'dump-stack)
    @windows-specific
    ;; this is really not nice but will do for now as sometimes a stack
    ;; just won't do if the problem is entirelly in the C code...
    (if (and (/= (hibyte (GetAsyncKeyState VK_CONTROL)) 0)
             (/= (hibyte (GetAsyncKeyState VK_MENU)) 0))
        (crash-process)
      (let ((file (either file (module-timestamped-file "Stack" "stack"))))
        (call-with-output-file (parse~ file)
          (lambda (printer)
            (apply print-stack printer others)))
        (when user-feedback?
          (message-box (format "Stack dumped to {t}" file)))
        file))))


(definition public (report-stack)
  (unimplemented 'report-stack)
  @windows-specific
  (if (and (kernel-initialized?) (in-manifest? 'Stack-Presenter))
      (report-stack~ (autoload 'Stack-Presenter))
    (let ((process (snapshot-stack))
          (printer (open-output-string)))
      (for-each (function dynamic (thread)
                  (format printer "{a}{%}" (get-label~ thread))
                  (for-each (function dynamic (frame)
                              (format printer "  {a}{%}" (car frame)))
                            (get-call-stack~ thread)))
                (get-threads~ process))
      (message-box (get-output-string printer)))))


(definition public (snapshot-stack)
  (unimplemented 'snapshot-stack)
  @windows-specific
  (read-string-element (print-stack :string)))


(definition public (print-stack destination . rest)
  (unimplemented 'print-stack)
  @windows-specific
  (if (= destination :string)
      (let ((printer (open-output-string)))
        (apply print-stack-to printer rest)
        (get-output-string printer))
    (apply print-stack-to destination rest)))


(definition (print-stack-to printer . rest) ;; CONVERT (thread: thread (active-thread)) (execution-stack: execution-stack (bootsafe-get-execution-stack)) (exception: exception {}))
  (unimplemented 'print-stack-to)
  @windows-specific (
  (format printer "~{Process-Snapshot{%}{%}")
  (format printer "  ;;;{%}")
  (format printer "  ;;;; PROCESS{%}")
  (format printer "  ;;;{%}{%}")
  (format printer "  :process {s}{%}" (parse~ (module-pathname)))
  (format printer "  :application {s}{%}" (command-argument "app"))
  (format printer "  date: \"")
  (print-date printer)
  (format printer "\"{%}")
  (when exception
    (format printer "{%}")
    (format printer "  ;;;{%}")
    (format printer "  ;;;; EXCEPTION{%}")
    (format printer "  ;;;{%}{%}")
    (format printer "  :exception{%}")
    (format printer "  ~{Exception-Snapshot{%}")
    (format printer "   :description {s}}{%}" (get-message~ exception)))
  (format printer "{%}")
  ;; todo
  (when execution-stack
    )
  (format printer "  ;;;{%}")
  (format printer "  ;;;; THREADS{%}")
  (format printer "  ;;;{%}{%}")
  (format printer "  :threads{%}")
  (format printer "  (~{Thread-Snapshot{%}")
  (format printer "    :model {a}{%}" (type-name (class-of thread)))
  (format printer "    :label {s}{%}" (get-name~ thread))
  (format printer "    state: {a}{%}" (get-state~ thread))
  (format printer "    :call-stack{%}")
  (format printer "    (")
  (print-stack-content thread printer)
  (format printer ")})}{%}")))


;; Temp copied from Date class because I don't want to make Date a core class
(definition (print-date printer)
  (unimplemented 'print-date)
  @windows-specific
  (let ((st (new SYSTEMTIME)))
    (GetLocalTime st)
    (let ((date-separator "/")
          (time-separator ":")
          (year   (get st 'wYear))
          (month  (get st 'wMonth))
          (day    (get st 'wDay))
          (hour   (get st 'wHour))
          (minute (get st 'wMinute))
          (second (get st 'wSecond)))
      (format printer "{a width: 4 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0} {a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}"
        (subseq (->string year) 0 4)
        date-separator
        month
        date-separator
        day
        hour
        time-separator
        minute
        time-separator
        second))))


;;;
;;;; Window
;;;


(definition public (toplevel-windows)
  (unimplemented 'toplevel-windows)
  @convert
  (toplevel-hwnds))


(definition public (process-windows (include-invisibles?: include-invisibles? #f))
  ;; quicky
  (list (get-toplevel))
  @convert
  (collect (function dynamic (hwnd)
             (let ((window (get-window hwnd)))
               (when (and window (or include-invisibles? (get-visible?~ window)))
                 window)))
           (process-hwnds)))


(definition public (all-child-windows hwnd)
  (unimplemented 'all-child-windows)
  @convert
  (all-child-hwnds hwnd))


(definition public (child-windows hwnd)
  (unimplemented 'child-windows)
  @convert
  (collect-if (function dynamic (child)
                (= (GetParent child) hwnd))
              (all-child-windows hwnd))))
