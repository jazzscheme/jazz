;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Macro Recording
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.recorder.Macro-Recorder jazz


(import (jazz.platform)
        (jazz.recorder)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.library)
        (jazz.utilities))


(definition public Recording?
  false)

(definition public Recording-Playing?
  false)

(definition public Recording-Factory
  (new List-Factory))

(definition public Registered-Recordings
  (new-hashtable eqv?))

(definition public Active-Recording
  {})


(class Macro-Recorder extends Object
    
  
  ;;;
  ;;;; Events
  ;;;

  
  (method (on-start-recording evt)
    (when (not Recording?)
      (user-message "Recording...")
      (set! Recording? true)
      (set! Recording-Factory (new List-Factory))))
  
  
  (method (on-stop-recording evt)
    (when Recording?
      (user-message "Stopped")
      (set! Recording? false)
      (set! Recording-Factory (coalesce-actions (get-output~ Recording-Factory)))
      (set! Active-Recording {})))

  
  (method (on-continue-recording evt)
    (when (not Recording?)
      (user-message "Recording...")
      (set! Recording? true)))
  
  
  (method (on-play-recording evt)
    (if (not Recording?)
        (begin
          (user-message "Playing...")
          (let ((no (get-property~ evt :no)))
            (if (null? no)
                (play-current-recording)
              (play-recording (get-recording no))))
          (user-message "Done"))
      (error "You cannot play while a recording is in progress")))
  
  
  (method (on-output-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (output-recording actions))))
  
  
  (method (on-present-recording evt)
    (let ((actions (get-output~ Recording-Factory)))
      (if (null? actions)
          (bell)
        (present-recording actions))))
  
  
  (method (on-register-recording evt)
    (let ((no (parse-integer (request-string :title "Register Recording" :prefix "No:" :initial-value "1"))))
      (assert (between? no 1 6))
      (let ((recording (get-output~ Recording-Factory)))
        (register-recording no recording)
        (user-message "Recording {a} registered" no))))
  
  
  (method (on-set-active-recording evt)
    (let ((name (read-string-element (request-string :title "Enter Recording Name"))))
      (if (null? name)
          (begin
            (set! Active-Recording {})
            (user-message "Active recording reset to default"))
        (get-recording name)
        (set! Active-Recording name)
        (user-message "Active recording set to {a}" name))))
  
  
  (method (coalesce-actions actions)
    (let* ((fact (new List-Factory))
           (string {})
           (coalesce
            (function dynamic ()
              (when string
                (let ((handler {Event-Handler :focus on-insert})
                      (event (new Event :string self :content string)))
                  (put~ fact (cons handler event))
                  (set! string {}))))))
      (for-each (function dynamic (action)
                  (bind (action/handler . event) action
                    (if (and (= (get-target-name action/handler) :focus)
                             (= (get-action/method-name action/handler) 'on-key-press))
                        (let* ((char (get-property~ event :key))
                               (added (coerce char String)))
                          (if (null? string)
                              (set! string added)
                            (set! string (append string added))))
                      (coalesce)
                      (put~ fact action))))
                actions)
      (coalesce)
      fact))
  
  
  (method (present-recording actions)
    (let* ((focus (get-focus))
           (printer (new String-Printer))
           (targets (remove-duplicates (map get-target-name (map car actions)))))
      (loop (for action in actions)
            (for first? first true then false)
            (do (bind (action/handler . event) action
                  (format printer "{?:{%}~}{a} {a} {a}"
                          (not first?)
                          (get-target-name action/handler)
                          (get-action/method-name action/handler)
                          event))))
      (message-box (get-output~ printer)
        :title "Recording")))
  
  
  (method (output-recording actions)
    (let ((text (get-focus)))
      (if (is-not? text Text-View)
          (bell)
        (with-atomic-undo~ (get-undoer~ text)
          (function dynamic ()
            (insert-char~ text #\open-parenthesis)
            (loop (for first? first true then false)
                  (for action in actions)
                  (do (unless first?
                        (insert-newline~ text))
                      (insert-string~ text (->string action :reader))
                      (unless first?
                        (tabulate~ text))))
            (insert-char~ text #\close-parenthesis))))))
  
  
  (method (target-name target)
    (if (= target :application)
        'appl
      (keyword->symbol target)))
  
  
  ;;;
  ;;;; Patch
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...
  
  
  (method (get-target-name action/handler)
    (typecase action/handler
      ((Action) (get-target-name~ action/handler))
      (else (get-target-name~ action/handler))))
  
  
  (method (get-action/method-name action/handler)
    (typecase action/handler
      ((Action) (get-action-name~ action/handler))
      (else (get-method-name~ action/handler))))
  
  
  ;;;
  ;;;; Recording
  ;;;
  
  
  ;; All this about having actions or handlers is a temporary solution until
  ;; a big cleanup between event handlers and actions...

  
  (method public (record action/handler event)
    (unless (= (get-target-name action/handler) :recorder)
      (put~ Recording-Factory (cons action/handler event))))
  
  
  (method public (register-recording name recording)
    (hash-set! Registered-Recordings name recording))
  
  
  (method public (get-recording name)
    (either (hash-ref Registered-Recordings name)
            (error "No recording {a} is registered" name)))
    
  
  ;;;
  ;;;; Playback
  ;;;
  
  
  (method public (play-current-recording)
    (if (not Active-Recording)
        (let ((user (get-user~ (get-application))))
          (unless (play-recording~ user)
            (play-recording (get-output~ Recording-Factory))))
      (play-recording (get-recording Active-Recording))))


  (method public (play-recording recording)
    (let ((old Recording-Playing?))
      (unwind-protect
          (begin
            (set! Recording-Playing? true)
            (let ((focus (get-focus)))
              (if (is? focus Text-View)
                  (with-atomic-undo~ (get-undoer~ focus)
                    (function dynamic ()
                      (for-each play-action recording)))
                (for-each play-action recording))))
        (set! Recording-Playing? old))))
  
  
  (method public (play-action action)
    (bind (action/handler . event) action
      (typecase action/handler
        ((Action)
         (call-action action/handler {} '() :event event))
        (else
         (let ((target (get-focus)))
           (invoke~ action/handler target event))))))
  
  
  (method public (find-target target)
    (process-alias~ (get-process) target))))
