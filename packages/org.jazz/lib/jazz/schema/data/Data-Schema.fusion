;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Data Schemas
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.schema.data.Data-Schema jazz


(import (jazz.schema)
        (jazz.library)
        (jazz.utilities))


(class Data-Schema extends Data-Entity implements Entity
  
  
  (slot tables     initialize (new-hashtable equal?))
  (slot views      initialize (new-hashtable equal?))
  (slot relations  initialize (new-hashtable equal?))
  (slot procedures initialize (new-hashtable equal?))
  
  
  @convert-literal
  (method meta (construct-literal context properties tables views relations procedures)
    (new self properties: properties :tables tables :views views :relations relations :procedures procedures))
  
  
  (method (initialize (name: name {}) (parent: parent {}) (properties: properties '()) (tables: tables '()) (views: views '()) (relations: relations '()) (procedures: procedures '()))
    (nextmethod)
    (set! name~self name)
    (set! parent~self parent)
    (set! properties~self properties)
    (add-tables tables)
    (add-views views)
    (add-relations relations)
    (add-procedures procedures))

 
  (method (print printer readably)
    (print-unreadable self printer
      (function dynamic (printer)
        (format printer "{a} tables, {a} views, {a} relations, {a} procedures"
                (hashtable-length tables)
                (hashtable-length views)
                (hashtable-length relations)
                (hashtable-length procedures)))))
  
  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method public (print-schema printer)
    (receive (equal smaller greater) (sort-predicates)
      (format printer "~{{s} {s list?: #t}{%}"
              (identifier-name (type-name (class-of self)))
              properties)
      (print-tables smaller printer)
      (print-views smaller printer)
      (print-relations smaller printer)
      (print-procedures smaller printer)
      (format printer "}{%}")))
  
  
  (method (print-tables smaller printer)
    (format printer " (")
    (let ((first? #t))
      (for-each (function dynamic (table)
                  (if first?
                      (set! first? #f)
                    (format printer "{%}{_ 2}"))
                  (print-schema~ table printer))
                (sort smaller (gather tables) key: object-name)))
    (format printer "){%}"))
  
  
  (method (print-views smaller printer)
    (format printer " (")
    (let ((first? #t))
      (for-each (function dynamic (view)
                  (if first?
                      (set! first? #f)
                    (format printer "{%}{_ 2}"))
                  (print-schema~ view printer))
                (sort smaller (gather views) key: object-name)))
    (format printer "){%}"))
  
  
  (method (print-relations smaller printer)
    (format printer " (")
    (let ((first? #t))
      (for-each (function dynamic (relation)
                  (if first?
                      (set! first? #f)
                    (format printer "{%}{_ 2}"))
                  (print-schema~ relation printer))
                (sort smaller (gather relations) key: object-name)))
    (format printer "){%}"))
  
  
  (method (print-procedures smaller printer)
    (format printer " (")
    (let ((first? #t))
      (for-each (function dynamic (procedure)
                  (if first?
                      (set! first? #f)
                    (format printer "{%}{_ 2}"))
                  (print-schema~ procedure printer))
                (sort smaller (gather procedures) key: object-name)))
    (format printer ")"))
  
  
  ;;;
  ;;;; Object
  ;;;
  
  
  (method (get-kind)
    'schema)
  
  
  ;;;
  ;;;; Entity
  ;;;
  
  
  (method (create kind name)
    (case kind
      ((table) (new Data-Table name: name))
      ((view) (new Data-View name: name))
      ((relation) (new Data-Relation name: name))
      ((procedure) (new Data-Procedure name: name))))
  
  
  (method (add kind object)
    (case kind
      ((table) (add-table object))
      ((view) (add-view object))
      ((relation) (add-relation object))
      ((procedure) (add-procedure object))))
  
  
  ;;;
  ;;;; Children
  ;;;
  
  
  (method (get-children)
    (let* ((fact (new List-Factory))
           (add
            (function dynamic (object)
              (put~ fact object))))
      (for-each add tables)
      (for-each add views)
      (for-each add relations)
      (for-each add procedures)
      (get-output~ fact)))
  
  
  (method (get-categorized-children)
    (let ((fact (new List-Factory)))
      (put-sequence!~ fact (get-categorized-tables))
      (put-sequence!~ fact (get-categorized-views))
      (put-sequence!~ fact (get-categorized-relations))
      (put-sequence!~ fact (get-categorized-procedures))
      (get-output~ fact)))
  
  
  ;;;
  ;;;; Tables
  ;;;
  
  
  (method public (get-tables)
    (gather tables))
  
  
  (method public (get-categorized-tables)
    (receive (equal smaller greater) (sort-predicates)
      (let ((tables (get-tables)))
        (append! (sort smaller (collect-normal-tables tables) key: object-name)
                 (sort smaller (collect-linked-tables tables) key: object-name)))))
  
  
  (method public (collect-normal-tables tables)
    (collect-if (function dynamic (table)
                  (not (get-property~ table :linked?)))
                tables))
  
  
  (method public (collect-linked-tables tables)
    (collect-if (function dynamic (table)
                  (get-property~ table :linked?))
                tables))
  
  
  (method public (get-table name)
    (hash-ref tables name))
  
  
  (method public (add-table table)
    (set-parent~ table self)
    (hash-set! tables (get-name~ table) table))
  
  
  (method public (add-tables tables)
    (for-each add-table tables))
  
  
  ;;;
  ;;;; Views
  ;;;
  
  
  (method public (get-views)
    (gather views))
  
  
  (method public (get-categorized-views)
    (receive (equal smaller greater) (sort-predicates)
      (sort smaller (get-views) key: object-name)))
  
  
  (method public (get-view name)
    (hash-ref views name))
  
  
  (method public (add-view view)
    (set-parent~ view self)
    (hash-set! views (get-name~ view) view))
  
  
  (method public (add-views views)
    (for-each add-view views))
  
  
  ;;;
  ;;;; Relations
  ;;;
  
  
  (method public (get-relations)
    (gather relations))
  
  
  (method public (get-categorized-relations)
    (receive (equal smaller greater) (sort-predicates)
      (sort smaller (get-relations) key: object-name)))
  
  
  (method public (get-relation name)
    (hash-ref relations name))
  
  
  (method public (add-relation relation)
    (set-parent~ relation self)
    (hash-set! relations (get-name~ relation) relation))
  
  
  (method public (add-relations relations)
    (for-each add-relation relations))
  
  
  ;;;
  ;;;; Procedures
  ;;;
  
  
  (method public (get-procedures)
    (gather procedures))
  
  
  (method public (get-categorized-procedures)
    (receive (equal smaller greater) (sort-predicates)
      (sort smaller (get-procedures) key: object-name)))
  
  
  (method public (get-procedure name)
    (hash-ref procedures name))
  
  
  (method public (add-procedure procedure)
    (set-parent~ procedure self)
    (hash-set! procedures (get-name~ procedure) procedure))
  
  
  (method public (add-procedures procedures)
    (for-each add-procedure procedures))
  
  
  ;;;
  ;;;; Present
  ;;;
  
  
  (method public (present)
    (get-property name:))
  
  
  ;;;
  ;;;; Inventory
  ;;;
  
  
  (method meta public (import-inventory source-name data-source reporter)
    (let* ((properties (list name: (present~ data-source) :provider (external-name~ (get-provider~ data-source)) :data-source (present~ data-source)))
           (schema (new self properties: properties)))
      (with-closed ((connection (new-connection~ data-source)))
        (let ((inventory (get-inventory~ connection read-only?: #t)))
          (import-inventory~ schema source-name inventory reporter)
          schema))))
  
  
  (method (import-inventory source-name inventory reporter)
    (import-tables source-name inventory reporter)
    (import-views source-name inventory reporter)
    (import-relations source-name inventory reporter)
    (import-procedures source-name inventory reporter))
  
  
  (method (import-tables source-name inventory reporter)
    (let ((columns-consecutive? (columns-ordinal-position-consecutive?~ inventory)))
      (with-closed ((tables (get-tables~ inventory)))
        (for-each (function dynamic (table)
                    (let* ((owner (get-owner~ table))
                           (name (get-title~ table))
                           (properties (table-properties table))
                           (data-table (new Data-Table owner: owner name: name properties: properties)))
                      (user-message~ reporter "Importing {a} Table {a}..." source-name name)
                      (unless (getf properties :linked?)
                        (set-primary-key~ data-table (create-primary-key data-table table))
                        (set-columns~ data-table (create-columns data-table table columns-consecutive?))
                        (set-indexes~ data-table (create-indexes data-table table))
                        (set-triggers~ data-table (create-triggers data-table table))
                        (set-constraints~ data-table (create-constraints data-table table)))
                      (add-table data-table)))
                  tables))))
  
  
  (method (table-properties table)
    (let ((linked? (get-linked?~ table)))
      (list
       :linked?           linked?
       :description       (get-description~ table)
       :validation-rule   (get-validation-rule~ table)
       :validation-text   (get-validation-text~ table)
       :connect           (essay linked? (get-connect~ table))
       :source-table-name (essay linked? (get-source-table-name~ table)))))
  
  
  (method (create-primary-key data-table table)
    (with-closed ((primary-key (get-primary-key~ table)))
      (when primary-key
        (let ((name (get-title~ primary-key))
              (properties (primary-key-properties primary-key)))
          (new Data-Primary-Key name: name properties: properties)))))
  

  (method (primary-key-properties primary-key)
    (list
     :clustered?    (get-clustered?~ primary-key)
     :fill-factor   (get-fill-factor~ primary-key)
     :fields/orders (get-fields/orders~ primary-key)))
  
  
  (method (create-columns data-table table columns-consecutive?)
    (let ((ordinal-position 0))
      (with-closed ((columns (get-columns~ table)))
        (map (function dynamic (column)
               (let ((name (get-title~ column))
                     (properties (column-properties column (essay (not columns-consecutive?) ordinal-position))))
                 (increase! ordinal-position)
                 (new Data-Column name: name properties: properties)))
             columns))))
  

  (method (column-properties column ordinal-position)
    (list
     :datatype              (get-datatype~ column)
     nullable?:             (get-nullable?~ column)
     :default-value         (get-default-value~ column)
     :validation-rule       (get-validation-rule~ column)
     :validation-text       (get-validation-text~ column)
     :allow-zero-length?    (get-allow-zero-length?~ column)
     :description           (get-description~ column)
     :ordinal-position      (either ordinal-position (get-ordinal-position~ column))
     :display-format        (get-display-format~ column)
     :auto-increment?       (get-auto-increment?~ column)
     :identity?             (get-identity?~ column)
     :identity-replication? (get-identity-replication?~ column)
     :identity-seed         (get-identity-seed~ column)
     :identity-increment    (get-identity-increment~ column)))
  
  
  (method (create-indexes data-table table)
    (with-closed ((indexes (get-indexes~ table)))
      (map (function dynamic (index)
             (let ((name (get-title~ index))
                   (properties (index-properties index)))
               (new Data-Index name: name properties: properties)))
           indexes)))
  

  (method (index-properties index)
    (list
     unique?:               (get-unique?~ index)
     :clustered?            (get-clustered?~ index)
     :ignore-duplicates?    (get-ignore-duplicates?~ index)
     :recompute-statistics? (get-recompute-statistics?~ index)
     :fill-factor           (get-fill-factor~ index)
     :pad-index?            (get-pad-index?~ index)
     :fields/orders         (get-fields/orders~ index)))
  
  
  (method (create-triggers data-table table)
    (with-closed ((triggers (get-triggers~ table)))
      (map (function dynamic (trigger)
             (let ((name (get-title~ trigger))
                   (properties (trigger-properties trigger)))
               (new Data-Trigger name: name properties: properties)))
           triggers)))
  

  (method (trigger-properties trigger)
    (list
     text: (get-text~ trigger)))
  
  
  (method (create-constraints data-table table)
    (with-closed ((constraints (get-constraints~ table)))
      (map (function dynamic (constraint)
             (let ((name (get-title~ constraint))
                   (properties (constraint-properties constraint)))
               (new Data-Constraint name: name properties: properties)))
           constraints)))
  

  (method (constraint-properties constraint)
    (list
     text:                 (get-text~ constraint)
     checked?:             (get-checked?~ constraint)
     exclude-replication?: (get-exclude-replication?~ constraint)))
  
  
  (method (import-views source-name inventory reporter)
    (with-closed ((views (get-views~ inventory)))
      (for-each (function dynamic (view)
                  (let* ((name (get-title~ view))
                         (properties (view-properties view))
                         (data-view (new Data-View name: name properties: properties)))
                    (user-message~ reporter "Importing {a} View {a}..." source-name name)
                    (add-view data-view)))
                views)))
  

  (method (view-properties view)
    (list
     text: (get-text~ view)))
  
  
  (method (import-relations source-name inventory reporter)
    (with-closed ((relations (get-relations~ inventory)))
      (for-each (function dynamic (relation)
                  (let* ((name (get-title~ relation))
                         (properties (relation-properties relation))
                         (data-relation (new Data-Relation name: name properties: properties)))
                    (user-message~ reporter "Importing {a} Relation {a}..." source-name name)
                    (add-relation data-relation)))
                relations)))
  

  (method (relation-properties relation)
    (list
     primary-table:        (get-primary-table~ relation)
     primary-columns:      (get-primary-field-names~ relation)
     foreign-table:        (get-foreign-table~ relation)
     foreign-columns:      (get-foreign-field-names~ relation)
     unique?:              (get-unique?~ relation)
     update-cascade?:      (get-update-cascade?~ relation)
     delete-cascade?:      (get-delete-cascade?~ relation)
     left?:                (get-left?~ relation)
     right?:               (get-right?~ relation)
     checked?:             (get-checked?~ relation)
     exclude-replication?: (get-exclude-replication?~ relation)))
  
  
  (method (import-procedures source-name inventory reporter)
    (with-closed ((procedures (get-procedures~ inventory)))
      (for-each (function dynamic (procedure)
                  (let* ((name (get-title~ procedure))
                         (properties (procedure-properties procedure))
                         (data-procedure (new Data-Procedure name: name properties: properties)))
                    (user-message~ reporter "Importing {a} Procedure {a}..." source-name name)
                    (add-procedure data-procedure)))
                procedures)))
  

  (method (procedure-properties procedure)
    (list
     text: (get-text~ procedure)))
  
  
  ;;;
  ;;;; Entity
  ;;;
  
  
  (method (get-factory)
    (new Data-Schema-Factory))
  
  
  (method (get-factories)
    '())
  
  
  (method (get-presentation)
    (get-property name:))
  
  
  (method (set-presentation controller presentation)
    (set-property name: presentation))
  
  
  (method (can-cut-entity?)
    #f
    @to-convert
    #t)
  
  
  (method (can-copy-entity?)
    #f
    @to-convert
    #t)
  
  
  (method (can-paste-entity?)
    #f)
  
  
  (method (determine-paster . rest)
    {})
  
  
  (method (can-rename-entity?)
    #t)
  
  
  (method (can-delete-entity?)
    #t)
  
  
  (method (can-move-entity?)
    #t)
  
  
  (method (can-view-properties?)
    #f)
  
  
  (method (get-categorized-properties)
    '())))
