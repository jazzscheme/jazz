;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Dates
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.system.time.Date jazz


(import (jazz.system)
        (jazz.system.time)
        (jazz.utilities))
  

(class Date extends Object
  
  
  (slot year)
  (slot month)
  (slot day-of-week)
  (slot day)
  (slot hour)
  (slot minute)
  (slot second)
  (slot milliseconds)
  
  
  @unimplemented
  (method meta (construct-literal context year (month 1) (day 1) (hour 0) (minute 0) (second 0) (milliseconds 0))
    (new self year month day hour minute second milliseconds))
  
  
  ;;;
  ;;;; System
  ;;;
  
  
  @convert/wait
  (method public (universal->local)
    (get-date~ (universal->local~ (get-time))))
  
  
  @convert/wait
  (method public (local->universal)
    (get-date~ (local->universal~ (get-time))))
  
  
  ;;;
  ;;;; Parse
  ;;;
  
  
  ;;;
  ;;;; Date
  ;;;
  
  
  (method (initialize year (month 1) (day 1) (hour 0) (minute 0) (second 0) (milliseconds 0))
    (nextmethod)
    (set! year~self year)
    (set! month~self month)
    (set! day~self day)
    (set! hour~self hour)
    (set! minute~self minute)
    (set! second~self second)
    (set! milliseconds~self milliseconds)
    @convert/wait
    (update))
  
  
  (method (update)
    (update-day-of-week))
  
  
  (method (copy-object deep?)
    (new Date year month day hour minute second milliseconds))


  (method (compare-object target)
    (if (is-not? target Date)
        :incompatible
      (compare (get-time) (get-time~ target))))
  
  
  (method (print printer readably)
    (if (= readably :human)
        (format printer "{a}" (present))
      (if (day-date?)
          (format printer "~{{a} {a} {a} {a}}"
                  (identifier-name (type-name (class-of self)))
                  year
                  month
                  day)
        (format printer "~{{a} {a} {a} {a} {a} {a} {a} {a}}"
                (identifier-name (type-name (class-of self)))
                year
                month
                day
                hour
                minute
                second
                milliseconds))))
  
  
  ;;;
  ;;;; Convert
  ;;;
  
  
  (method public (get-time)
    (unimplemented)
    @convert-windows-specific
    (let ((systemtime (get-systemtime))
          (filetime (new FILETIME)))
      ;; this will cause an error for a date like {Date 1000 1 1}
      (unless (SystemTimeToFileTime systemtime filetime)
        (error "Invalid date: {t}" self))
      (from-filetime filetime)))


  @convert-windows-specific
  (method (get-systemtime)
    (let ((st (new SYSTEMTIME)))
      (fill-systemtime st)
      st))
  
  
  @convert-windows-specific
  (method (fill-systemtime st)
    (set st 'wYear year)
    (set st 'wMonth month)
    (set st 'wDay day)
    (set st 'wHour hour)
    (set st 'wMinute minute)
    (set st 'wSecond second)
    (set st 'wMilliseconds milliseconds))
  
  
  ;;;
  ;;;; Arithmetic
  ;;;
  
  
  (definition days/week
    7)
  
  
  (method public (add field (value {}))
    (if (not value)
        (add-duration field)
      (add-field field value)))
  
  
  ;; This implementation is ugly in terms of memory allocation.
  ;; It is there temporarely for simplicity. A real implementation
  ;; would make use of an 'add!' method that adds destructively.
  (method (add-duration duration)
    (receive (years months weeks days hours minutes seconds) (get-amounts~ duration)
      (let ((result {}))
        (when years   (set! result (add-field 'year years)))
        (when months  (set! result (add-field 'month months)))
        (when weeks   (set! result (add-field 'week weeks)))
        (when days    (set! result (add-field 'day days)))
        (when hours   (set! result (add-field 'hour hours)))
        (when minutes (set! result (add-field 'minute minutes)))
        (when seconds (set! result (add-field 'second seconds)))
        (either result self))))
  
  
  (method (add-field field value)
    (case field
      ((year) (add-year value))
      ((month) (add-month value))
      ((week) (add 'day (* value days/week)))
      (else
       (let ((time (get-time)))
         (add~ time field value)
         (get-date~ time)))))
  
  
  (method (add-year value)
    (new Date (+ year value)))
  
  
  (method (add-month value)
    (let ((year year~self)
          (month (+ month value)))
      (cond ((<= month 0)
             (while (<= month 0)
               (decrease! year)
               (increase! month 12)))
            ((> month 12)
             (while (> month 12)
               (increase! year)
               (decrease! month 12))))
      (new Date year month day~self)))
  
  
  ;;;
  ;;;; Fields
  ;;;
  
  
  (method public (get-field field)
    (case field
      ((year) year)
      ((month) month)
      ((day) day)
      ((hour) hour)
      ((minute) minute)
      ((second) second)
      ((milliseconds) milliseconds)))
  
  
  ;;;
  ;;;; Year
  ;;;
  
  
  (method public (get-year)
    year)
  
  
  (method public (year-date)
    (if (year-date?)
        self
      (new Date year)))
  
  
  (method public (year-date?)
    (and (= month 1)
         (= day 1)
         (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-year? date)
    (= year (get-year~ date)))
  
  
  (method public (iterate-year proc)
    (let ((date (year-date)))
      (while (same-year? date)
        (proc date)
        (set! date (add~ date 'month 1)))))
  
  
  ;;;
  ;;;; Month
  ;;;
  
  
  (method public (get-month)
    month)
  
  
  (method public (month-date)
    (if (month-date?)
        self
      (new Date year month)))
  
  
  (method public (month-date?)
    (and (= day 1)
         (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-month? date)
    (and (= year (get-year~ date))
         (= month (get-month~ date))))
  
  
  (method public (iterate-month proc)
    (let ((date (month-date)))
      (while (same-month? date)
        (proc date)
        (set! date (add~ date 'day 1)))))
  
  
  (method public (first-day-of-month)
    (let ((day (copy (day-date))))
      (set-day~ day 1)
      day))
  
  
  (method public (last-day-of-month)
    (add~ (add~ (first-day-of-month) 'month 1) 'day -1))
  
  
  (method public (previous-month)
    (add~ (first-day-of-month) 'month -1))
  
  
  (method public (next-month)
    (add~ (first-day-of-month) 'month 1))
  
  
  (definition Month-Names
    '((1  . "January")
      (2  . "February")
      (3  . "Mars")
      (4  . "April")
      (5  . "May")
      (6  . "June")
      (7  . "July")
      (8  . "August")
      (9  . "September")
      (10 . "October")
      (11 . "November")
      (12 . "December")))
  
  
  (definition Month-Abbrevs
    '((1  . "Jan")
      (2  . "Feb")
      (3  . "Mar")
      (4  . "Apr")
      (5  . "May")
      (6  . "Jun")
      (7  . "Jul")
      (8  . "Aug")
      (9  . "Sep")
      (10 . "Oct")
      (11 . "Nov")
      (12 . "Dec")))
  
  
  (method public (month-name)
    (let ((pair (assq month Month-Names)))
      (if (not pair)
          #f
        (cdr pair))))
  
  
  (method public (month-abbrev)
    (let ((pair (assq month Month-Abbrevs)))
      (if (not pair)
          #f
        (cdr pair))))
  
  
  (method public (get-week)
    (let ((date (add~ (last-day-of-week) 'week -1))
          (week 0))
      (while (same-month? date)
        (set! date (add~ date 'week -1))
        (increase! week))
      week))
  
  
  (method public (get-day-of-week)
    day-of-week)
  
  
  (method public (first-day-of-week)
    (add~ (day-date) 'day (- day-of-week)))
  
  
  (method public (last-day-of-week)
    (add~ (day-date) 'day (- 6 day-of-week)))
  
  
  (method public (day-abbrev)
    (third (find-day-of-week-info day-of-week)))
  
  
  @convert-windows-specific
  (definition System-Time
    (new SYSTEMTIME))
  
  @convert-windows-specific
  (definition File-Time
    (new FILETIME))
  
  
  (method synchronized (update-day-of-week)
    (unimplemented)
    @convert-windows-specific(
    (fill-systemtime System-Time)
    (SystemTimeToFileTime System-Time File-Time)
    (FileTimeToSystemTime File-Time System-Time)
    (set! day-of-week (get System-Time 'wDayOfWeek))))
  
  
  ;;;
  ;;;; Day
  ;;;
  
  
  (method public (get-day)
    day)
  
  
  (method public (set-day value)
    (set! day value)
    (update))
  
  
  (method public (day-date)
    (if (day-date?)
        self
      (new Date year month day)))
  
  
  (method public (day-date?)
    (and (= hour 0)
         (= minute 0)
         (= second 0)
         (= milliseconds 0)))
  
  
  (method public (same-day? date)
    (and (= year (get-year~ date))
         (= month (get-month~ date))
         (= day (get-day~ date))))
  
  
  ;;;
  ;;;; Hour
  ;;;
  
  
  (method public (get-hour)
    hour)
  
  
  (method public (set-hour value)
    (set! hour value))
  
  
  ;;;
  ;;;; Minute
  ;;;
  
  
  (method public (get-minute)
    minute)
  
  
  ;;;
  ;;;; Second
  ;;;
  
  
  (method public (get-second)
    second)
  
  
  ;;;
  ;;;; Milliseconds
  ;;;
  
  
  (method public (get-milliseconds)
    milliseconds)
  
  
  ;;;
  ;;;; Present
  ;;;
  
  
  (method public (present (date-separator: date-separator "/")
                          (time-separator: time-separator ":")
                          (milliseconds-separator: milliseconds-separator ".")
                          (seconds?: seconds? #t)
                          (milliseconds?: milliseconds? #f))
    (format "{a width: 4 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0} {a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a}"
            (subseq (->string year) 0 4)
            date-separator
            month
            date-separator
            day
            hour
            time-separator
            minute
            (if (or seconds? milliseconds?)
                (format "{a}{a width: 2 justify: :right padding: #\\0}" time-separator second)
              "")
            (if milliseconds?
                (format "{a}{a width: 3 justify: :right padding: #\\0}" milliseconds-separator milliseconds)
              "")))
  
  
  (method public (present-date . rest)
    (subseq (apply present rest) 0 10))
 
  
  (method public (present-time . rest)
    (subseq (apply present rest) 11 16))
  
  
  (method public (present-compact (date-separator: date-separator "/") (time-separator: time-separator ":"))
    (format "{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0} {a width: 2 justify: :right padding: #\\0}{a}{a width: 2 justify: :right padding: #\\0}"
            (subseq (->string year) 2)
            date-separator
            month
            date-separator
            day
            hour
            time-separator
            minute))
  
  
  (method public (present-duration (seconds?: seconds? #t))
    (let* ((printer (open-output-string))
           (empty? #t)
           (output
             (function (field)
               (let ((n (get-field field)))
                 (when (/= n 0)
                   (if empty?
                       (set! empty? #f)
                     (format printer ", "))
                   (format printer "{a} {a}{a}" n field (format-plural n)))))))
      (output 'year)
      (output 'month)
      (output 'day)
      (output 'hour)
      (output 'minute)
      (when (or seconds? empty?)
        (output 'second))
      (get-output-string printer)))))
