;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Windows Dialogs
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.dialog.platform.windows jazz


(import (jazz.io)
        (jazz.library)
        (jazz.platform)
        (jazz.platform.windows)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.utilities))


;;;
;;;; File
;;;


(definition public (choose-file (title: title {})
                                (directory: directory {})
                                (initial-filename: initial-filename {})
                                (extensions: extensions '())
                                (multiple-selection?: multiple-selection? #f)
                                (anchors: anchors {}))
  (close-all-popups)
  (let ((size (if multiple-selection? (+ MAX_PATH (* 64 50)) MAX_PATH)))
    (with ((r (OPENFILENAME-make))
           (buffer (WCHAR-array-make size)))
      (if (not initial-filename)
          (WCHAR-array-set! buffer 0 #\nul)
        (WCHAR-copy buffer initial-filename size))
      (let ((fake-extensions-filter @fake (extensions-filter extensions) NULL)
            (fake-current-directory @fake (get-current-directory) NULL)
            (fake-dialog-proc @fake (get-dialog-proc) NULL))
        (OPENFILENAME-lStructSize-set! r     (OPENFILENAME-sizeof))
        (OPENFILENAME-hwndOwner-set! r       (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
        (OPENFILENAME-lpstrFilter-set! r     fake-extensions-filter)
        (OPENFILENAME-lpstrFile-set! r       buffer)
        (OPENFILENAME-nMaxFile-set! r        size)
        (OPENFILENAME-lpstrInitialDir-set! r (if directory (parse~ directory) fake-current-directory))
        (OPENFILENAME-lpstrTitle-set! r      (either title NULL))
        (OPENFILENAME-Flags-set! r           (bit-or OFN_EXPLORER (if multiple-selection? OFN_ALLOWMULTISELECT 0) OFN_HIDEREADONLY OFN_ENABLEHOOK OFN_FILEMUSTEXIST OFN_ENABLESIZING))
        (OPENFILENAME-lpstrDefExt-set! r     NULL)
        (OPENFILENAME-lCustData-set! r       0)
        (OPENFILENAME-lpfnHook-set! r        fake-dialog-proc))
      (let ((anchorize
              (function dynamic (pathname)
                pathname
                @w
                (anchorize~ pathname anchors: anchors))))
        (if (GetOpenFileName r)
            (begin
              (if (not multiple-selection?)
                  (let ((filename (WCHAR-string buffer)))
                    (anchorize (new File (tokenise filename))))
                (let ((tokens (tokenise-choose-file-string buffer)))
                  (if (= (length tokens) 1)
                      (let ((filename (WCHAR-string buffer)))
                        (list (anchorize (new File (tokenise filename)))))
                    (bind (dir . filenames) tokens
                      (let ((dirlist (tokenise dir)))
                        (map (function dynamic (filename)
                               (anchorize (new File (append dirlist (list filename)))))
                             filenames)))))))
          (let ((code (CommDlgExtendedError)))
            (if (= code 0)
                (throw-cancel)
              (error "Dialog error: {t}" code))))))))


;;;
;;;; New File
;;;


(definition public (choose-new-file (directory: directory {})
                                    (initial-filename: initial-filename {})
                                    (default-extension: default-extension {})
                                    (extensions: extensions '())
                                    (anchors: anchors {}))
  (unimplemented 'choose-new-file)
  @convert (
  (close-all-popups)
  (when directory
    (create-directories~ directory))
  (let ((r (new OPENFILENAME))
        (filename (make-string MAX_PATH)))
    (if (null? initial-filename)
        (set-element! filename 0 #\nul)
      (copy-into! initial-filename filename))
    (set r 'lStructSize     (size-of OPENFILENAME))
    (set r 'hwndOwner       (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
    (set r 'lpstrFilter     (extensions-filter extensions))
    (set r 'lpstrFile       filename)
    (set r 'nMaxFile        MAX_PATH)
    (set r 'lpstrInitialDir (if directory (parse~ directory) (get-current-directory)))
    (set r 'Flags           (bit-or OFN_EXPLORER OFN_ENABLEHOOK @w OFN_FILEMUSTEXIST OFN_ENABLESIZING OFN_OVERWRITEPROMPT))
    (set r 'lpstrDefExt     (either default-extension NULL))
    (set r 'lCustData       NULL)
    (set r 'lpfnHook        (get-dialog-proc))
    (if (GetSaveFileName r)
        (begin
          (adjust-string filename)
          (anchorize~ (new File (tokenise filename)) anchors: anchors))
      (let ((code (CommDlgExtendedError)))
        (if (= code 0)
            (throw-cancel)
          (error "Dialog error: {t}" code)))))))


;;;
;;;; Directory
;;;


(definition public (choose-directory (title: title {})
                                     (directory: directory {})
                                     (anchors: anchors {}))
  (unimplemented 'choose-directory)
  @convert (
  (close-all-popups)
  (let ((preserved {}))
    (when directory
      (set! preserved (get-current-directory))
      (set-current-directory (parse~ directory)))
    (let ((r (new BROWSEINFO)))
      (set r 'hwndOwner (let ((toplevel (get-toplevel))) (if toplevel (get-handle~ toplevel) NULL)))
      (set r 'pidlRoot  NULL)
      (set r 'lpfn      (get-browse-callback))
      (set r 'lpszTitle (either title NULL))
      (let ((items (SHBrowseForFolder r)))
        (when preserved
          (set-current-directory preserved))
        (if (not items)
            (throw-cancel)
          (let ((path (new Ansi-String size: MAX_PATH)))
            (SHGetPathFromIDList items path)
            (let ((string (coerce path String)))
              (adjust-string string)
              (let ((directory (anchorize~ (new Directory (tokenise string)) anchors: anchors)))
                (set-current-directory (parse~ directory))
                directory)))))))))


;;;
;;;; Utilities
;;;


(definition (tokenise-choose-file-string buffer)
  (let loop ((offset 0)
             (start-of-string? #t))
       (let ((end-of-string? (eq? #\nul (WCHAR-array-ref buffer offset))))
         (if start-of-string?
             (if end-of-string?
                 '()
               (cons (WCHAR-string (WCHAR-subarray buffer offset))
                     (loop (+ offset 1) end-of-string?)))
           (loop (+ offset 1) end-of-string?)))))


;; Returns NULL used by file dialogs. Windows specific.
;; We will need a platform independent dialog.
(definition public (extensions-filter extensions)
  (unimplemented 'extensions-filter)
  @returns-NULL
  (if (null? extensions)
      NULL
    (let ((dst (new List-Factory))
          (separator (make-string 1 #\nul)))
      (for-each (function dynamic (ext)
                  (put~ dst (car ext))
                  (put~ dst (cdr ext)))
                extensions)
      (put~ dst separator)
      (join (get-output~ dst) separator)))))
