;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Search View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.search.Search-View jazz


(import (jazz.jml)
        (jazz.platform)
        (jazz.literals)
        (jazz.library)
        (jazz.ui)
        (jazz.ui.activity)
        (jazz.utilities))


(class Search-View extends Layout-View

  
  (form
    (<install>
      (<Push-Button>                   name: search          title: "Search" position: {Point 763 14} size: {Dimension 80 24} action-handler: {Event-Handler form: on-search} default?: #t)
      (<Group-Box>                     name: domain          position: {Point 10 8} size: {Dimension 350 124})
      (<Splitter>                      name: vertical        position: {Point 362 8} size: {Dimension 6 124} move-handler: {Event-Handler form: on-splitter-move})
      (<Border-View>                   name: targets-border  position: {Point 370 14} size: {Dimension 381 118} border-type: edge style: ()
        (<Scroller-View>                                     vscroll?: #t
          (<content~>                                        layout-type: fill
            (<Tree-Header>
              (<content~>
                (<Search-Targets>      name: targets         font: {Font name: Ansi-Var} default-row-height: 15
                  (<Tree-Node-Column>                        title: "Find" width: 176 toplevel-controls?: #f display-images?: #f)
                  (<Tree-Label-Column>                       title: "Replace" width: 173)))))))
      (<Check-Box>                     name: whole-words?    title: "Whole Words" position: {Point 10 141} size: {Dimension 100 18})
      (<Check-Box>                     name: ignore-case?    title: "Ignore Case" position: {Point 118 141} size: {Dimension 100 18})
      (<Check-Box>                     name: preserve-case?  title: "Preserve Case" position: {Point 220 141} size: {Dimension 100 18})
      (<Check-Box>                     name: expression?     title: "Expression" position: {Point 388 141} size: {Dimension 200 18})
      (<Check-Box>                     name: play-recording? title: "Play Recording" position: {Point 530 141} size: {Dimension 100 18})))
  
  
  (method public (next-radio)
    (let* ((domain (get-search-domain))
           (domains (get-search-domains))
           (pos (find domain domains :return 'position)))
      (when pos
        (set-search-domain (element domains (modulo (+ pos 1) (length domains)))))))
  
  
  (method public (next-tab)
    (let* ((manager (get-manager))
           (max-selection (length (get-children~ manager)))
           (old-selection (get-selection~ manager))
           (new-selection (modulo (+ old-selection 1) max-selection)))
      (set-selection~ manager new-selection)))
    


  ;;;
  ;;;; Component
  ;;;
  
  
  (method (finish rest)
    (nextmethod rest)
    (let ((tree (locate 'targets)))
      (for-each (function dynamic (column)
                  (set-title-vertical-offset~ column 1))
                (get-columns~ tree))))


  ;;;
  ;;;; Session
  ;;;
  
  
  (method public virtual (get-session-properties)
    (list
      'domain          (get-search-domain)
      'targets         (get-search-targets)
      'whole-words?    (get-whole-words?)
      'ignore-case?    (get-ignore-case?)
      'preserve-case?  (get-preserve-case?)
      'play-recording? (get-play-recording?)
      'expression?     (get-expression?)))
  
  
  (method public virtual (set-session-properties config)
    (set-search-targets  (get-targets~ config))
    (set-whole-words?    (get-whole-words?~ config))
    (set-ignore-case?    (get-ignore-case?~ config))
    (set-preserve-case?  (get-preserve-case?~ config))
    (set-play-recording? (get-play-recording?~ config))
    (set-expression?     (get-expression?~ config)))


  ;;;
  ;;;; Manager
  ;;;
  
  
  (method (get-manager)
    (child 3))
    

  ;;;
  ;;;; Access
  ;;;
  
  
  (method protected (get-results)
    (get-search-results~ (get-application)))
  
  
  (method public (get-targets-tree)
    (locate 'targets))
  
  
  (method public (get-search-targets)
    (let* ((tree (locate 'targets))
           (height (get-visible-count~ tree))
           (fact (new List-Factory)))
      ;; to-convert temp patch
      (if (in-edition?~ tree)
          null
        (for-each (function dynamic (row)
                    (let ((find (get-title~ (get-cell-data~ tree (new Cell row 0))))
                          (repl (get-title~ (get-cell-data~ tree (new Cell row 1)))))
                      (unless (and (empty-string? find) (empty-string? repl))
                        (put~ fact (list find repl)))))
                  (naturals 0 height))
        (get-output~ fact))))


  (method public (set-search-targets targets)
    (let ((tree (locate 'targets))
          (count (length targets)))
      (ensure-visible-count~ tree count)
      (let ((width (get-columns-count~ tree))
            (height (get-visible-count~ tree)))
        (with-update-locked~ tree
          (function dynamic ()
            (for-each (function dynamic (line row)
                        (for-each (function dynamic (target col)
                                    (let ((cell (new Cell row col)))
                                      (set-title~ (get-cell-data~ tree cell) target)
                                      (invalidate-cell~ tree cell)))
                                  line
                                  (naturals 0 (length line))))
                      targets
                      (naturals 0 (length targets)))
            (for-each (function dynamic (row)
                        (for-each (function dynamic (col)
                                    (let ((cell (new Cell row col)))
                                      (set-title~ (get-cell-data~ tree cell) "")
                                      (invalidate-cell~ tree cell)))
                                  (naturals 0 width)))
                      (naturals (length targets) height)))))))
  
  
  (method public (get-find-targets)
    (map first (get-search-targets)))
  
  
  (method (get-replace-targets)
    (map second (get-search-targets)))
  
  
  (method public (get-search-domain)
    (let* ((group (locate 'domain))
           (proc (function dynamic (name)
                   (let ((radio (find-component~ group name)))
                     (when (and radio (get-selected?~ radio))
                       name)))))
      (find-if proc (get-search-domains))))
  
  
  (method public (set-search-domain domain)
    (let* ((group (locate 'domain))
           (radio (find-component~ group domain)))
      (when radio
        (for-each (function dynamic (child)
                    (when (is? child Radio-Button)
                      (set-selected?~ child (eq? child radio))))
                  (get-children~ group)))))
  
  
  (method public (get-whole-words?)
    (get-checked?~ (locate 'whole-words?)))
  
  
  (method public (set-whole-words? flag)
    (set-checked?~ (locate 'whole-words?) flag))
  
  
  (method public (get-ignore-case?)
    (get-checked?~ (locate 'ignore-case?)))
  
  
  (method public (set-ignore-case? flag)
    (set-checked?~ (locate 'ignore-case?) flag))
  
  
  (method public (get-preserve-case?)
    (get-checked?~ (locate 'preserve-case?)))
  
  
  (method public (set-preserve-case? flag)
    (set-checked?~ (locate 'preserve-case?) flag))
  
  
  (method public (get-play-recording?)
    (get-checked?~ (locate 'play-recording?)))
  
  
  (method public (set-play-recording? flag)
    (set-checked?~ (locate 'play-recording?) flag))
  
  
  (method public (get-expression?)
    (get-checked?~ (locate 'expression?)))
  
  
  (method public (set-expression? flag)
    (set-checked?~ (locate 'expression?) flag))
    

  ;;;
  ;;;; Domains
  ;;;
  
  
  (method public virtual (get-search-domains)
    null)
  
  
  (method public virtual (get-active-window-domain)
    {})


  ;;;
  ;;;; Events
  ;;;
  
  
  (method public (on-search evt)
    (hide~ (get-player))
    (let ((targets (locate 'targets)))
      (end-edition~ targets)
      (let ((find-targets (get-find-targets)))
        (if (null? find-targets)
            (bell)
          (search-targets find-targets)))))
  
  
  (method protected virtual (search-targets targets)
    )


  (method (resize dh dv)
    (nextmethod dh dv)
    (move-figure~ (locate 'search) dh 0)
    (size-figure~ (locate 'domain) 0 dv)
    (size-figure~ (locate 'targets-border) dh dv)
    (move-figure~ (locate 'whole-words?) 0 dv)
    (move-figure~ (locate 'ignore-case?) 0 dv)
    (move-figure~ (locate 'preserve-case?) 0 dv)
    (move-figure~ (locate 'play-recording?) 0 dv)
    (move-figure~ (locate 'expression?) 0 dv))
  
  
  (method (on-splitter-move evt)
    (let ((delta (get-property~ evt :delta)))
      (size-figure~ (locate 'domain) delta 0)
      (move-figure~ (locate 'targets-border) delta 0)
      (size-figure~ (locate 'targets-border) (- delta) 0)
      (update-view)))
    
    
  (method public (on-return-press evt)
    (on-search evt))
  
  
  (method public (on-find-forward evt)
    (let ((find (get-find-targets))
          (target (get-target-text))
          (domain (get-search-domain)))
      (unless (and target (find-forward target find (follow-search-results? domain)))
        (bell))))
  
  
  (method public (on-find-backward evt)
    (let ((find (get-find-targets))
          (target (get-target-text))
          (domain (get-search-domain)))
      (unless (and target (find-backward target find (follow-search-results? domain)))
        (bell))))
  
  
  (method public (on-replace evt)
    (let* ((find (get-find-targets))
           (repl (get-replace-targets))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (target (get-target-text)))
      (unless (and target (replace target find repl ignore-case? case? play? expression?))
        (bell))))
  
  
  (method public (on-replace&find-forward evt)
    (let* ((find (get-find-targets))
           (repl (get-replace-targets))
           (domain (get-search-domain))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (next? (follow-search-results? domain))
           (target (get-target-text)))
      (unless (and target (replace&find-forward target find repl ignore-case? case? play? expression? next?))
        (bell))))
  
  
  (method public (on-replace-all evt)
    (let* ((find (get-find-targets))
           (repl (get-replace-targets))
           (appl (get-application))
           (ignore-case? (get-ignore-case?~ appl))
           (case? (get-preserve-case?~ appl))
           (play? (get-play-recording?~ appl))
           (expression? (get-expression?~ appl))
           (target (get-target-text)))
      (if (not target)
          (bell)
        (replace-all target find repl ignore-case? case? play? expression?))))
  
  
  (method public (on-replace-all-selected evt)
    (let ((code (message-box "Automatically save & close files that are not currently edited?" :type 'confirmation)))
      (if (eq? code 'cancel)
          (throw-cancel)
        (let* ((auto-save/close? (eq? code 'yes))
               (find (get-find-targets))
               (repl (get-replace-targets))
               (appl (get-application))
               (ignore-case? (get-ignore-case?~ appl))
               (case? (get-preserve-case?~ appl))
               (play? (get-play-recording?~ appl))
               (expression? (get-expression?~ appl))
               (results (get-results))
               (tree (locate~ results 'results))
               (selection (get-selection~ tree))
               (modified-count 0))
          (for-each (function dynamic (item)
                      (bind-values (frame new?) (edit-item~ results item true false)
                        (let* ((guest (get-guest~ frame))
                               (target (get-text-view~ guest))
                               (moniker (get-moniker~ (get-controller~ target))))
                          (user-message "Processing {a}..." (get-name~ moniker))
                          (replace-all target find repl ignore-case? case? play? expression?)
                          (when (and auto-save/close? new?)
                            (when (get-modified?~ target)
                              (save~ guest)
                              (increase! modified-count))
                            (close~ frame)))))
                    selection)
          (when auto-save/close?
            (message-box (format "{a} file{a} modified" modified-count (format-plural modified-count))))
          (user-message "Done")))))


  (method (get-target-text)
    (let ((frame (first-child~ (get-stage))))
      (when (is? frame Host-Frame)
        (let ((guest (get-guest~ frame)))
          (when (is? guest Document)
            (get-text-view~ guest))))))
  
  
  (method (follow-search-results? domain)
    (or (not domain) (/= domain (get-active-window-domain))))


  ;;;
  ;;;; Reporting
  ;;;
  
  
  (method protected (get-search-reporter count)
    (let* ((manager (get-activity-manager))
           (reporter (register-activity~ manager)))
      (setup-search-reporter reporter count)
      (show~ manager)
      reporter))
  
  
  (method protected virtual (setup-search-reporter reporter count)
    )

  
  ;;;
  ;;;; Menu
  ;;;
  
  
  (method (determine-case str)
    (if (or (empty-string? str) (lower-case? (element str 0)))
        'lower-case
      (if (or (= (length str) 1) (upper-case? (element str 1)))
          'upper-case
        'capitalized)))
  
  
  (method (convert-case str cs)
    (case cs
      ((lower-case)  (downcase str))
      ((upper-case)  (upcase str))
      ((capitalized) (capitalize str))))
  
  
  (method (replace target find-list repl-list ignore-case? case? play? expression?)
    (let* ((str (get-selected-string~ target))
           (rank (if expression? 0 (find str find-list :test (if ignore-case? ci= =) :return 'position))))
      (when rank
        (let ((repl (element repl-list rank)))
          (if (not play?)
              (insert-string~ target (if case? (convert-case repl (determine-case str)) repl))
            ;; temp... should not be necessary. play-recording should be
            ;; made to work even if the window doesn't have the focus.
            (acquire-focus~ target)
            (play-current-recording~ (get-recorder~ (get-application)))))
        true)))
  
  
  (method (replace&find-forward target find repl ignore-case? case? play? expression? . rest)
    (bind-optionals ((next? true)) rest
      (replace target find repl ignore-case? case? play? expression?)
      (find-forward target find next?)))
  
  
  (method (replace-all target find repl ignore-case? case? play? expression?)
    (replace target find repl ignore-case? case? play? expression?)
    (while (find-forward target find false)
      (replace target find repl ignore-case? case? play? expression?)))
  
  
  (method protected (find-forward target strings . rest)
    (bind-optionals ((next? true)) rest
      (either (select-next~ target strings)
              (essay next? (edit-next~ (get-results))))))
  
  
  (method protected (find-backward target strings . rest)
    (bind-optionals ((previous? true)) rest
      (either (select-previous~ target strings)
              (essay previous? (edit-previous~ (get-results))))))


  ;;;
  ;;;; Search
  ;;;


  (method (search-in-file targets file whole-words? ignore-case? expression? constituent-test factory reporter)
    (unless (and reporter (cancel-requested?~ reporter))
      (when reporter
        (user-message~ reporter "Searching {a}" (get-name~ file))
        (step-it~ reporter))
      (let ((info (search-file file targets whole-words? ignore-case? expression? constituent-test)))
        (when info
          (put~ factory (list file info targets))))))
  
  
  (method (search-in-zip targets file extensions whole-words? ignore-case? expression? constituent-test factory reporter)
    (with-closed ((unzip (new Unzip-File file)))
      (iterate-files~ unzip
        (function dynamic (filename size)
          (let ((extension (extract-extension filename)))
            (when (member? extension extensions :test ci=)
              (unless (and reporter (cancel-requested?~ reporter))
                (when reporter
                  (user-message~ reporter "Searching {a}" filename)
                  (step-it~ reporter))
                (let* ((zipped (new Zipped file filename))
                       (content (coerce (read-content~ zipped) String))
                       (info (search-content content targets whole-words? ignore-case? expression? constituent-test)))
                  (when info
                    (put~ factory (list (new Zipped file filename) info targets)))))))))))
  
  
  (method protected (search-in-directories targets directories extensions whole-words? ignore-case? expression? constituent-test factory reporter)
    (for-each (function dynamic (directory)
                (search-in-directory targets directory extensions whole-words? ignore-case? expression? constituent-test factory reporter))
              directories))
    

  (method protected (search-in-directory targets directory extensions whole-words? ignore-case? expression? constituent-test factory reporter)
    (let ((all-extensions? (equal? extensions '("*"))))
      (iterate-directory~ directory
        (function dynamic (file)
          (let ((ext (get-extension~ file)))
            (cond ;; very quick and dirty solution
             ((and all-extensions? (not (member? ext '("obj" "dll" "exe") :test ci=)) (<= (get-size~ file) 512000))
              (search-in-file targets file whole-words? ignore-case? expression? constituent-test factory reporter))
             ((member? ext extensions :test ci=)
              (search-in-file targets file whole-words? ignore-case? expression? constituent-test factory reporter))
             @i-dont-really-like-auto-searching-zips-there-should-be-a-user-option
             ((member? ext '("zip" "jar") :test ci=)
              (search-in-zip targets file extensions whole-words? ignore-case? expression? constituent-test factory reporter)))))
        :ignored-directories '("Debug" "Release" "Work"))))


  (method (search-file file targets whole-words? ignore-case? expression? constituent-test)
    (when (exists?~ file)
      (if (not expression?)
          (with-closed ((reader (new File-Reader :pathname file)))
            (let ((content (read-string-content~ reader)))
              (search-content content targets whole-words? ignore-case? constituent-test)))
        (let ((text (new Jazz-Text-View)))
          (set-moniker~ text file)
          (let* ((beginning (text-beginning~ text))
                 (expl (new Jazz-Explorer text :start beginning :end beginning))
                 (mode (if (ci= (get-extension~ file) "jazz") 'code 'quotation)))
            (search-expressions~ expl mode targets beginning whole-words? ignore-case?))))))
  
  
  (method (search-content content targets whole-words? ignore-case? constituent-test)
    (multisearch-string~ content targets :whole-words? whole-words? :ignore-case? ignore-case? :self self :constituent-test constituent-test))


  ;;;
  ;;;; Targets
  ;;;


  (method public virtual (select-search)
    (let ((targets (locate 'targets)))
      (select-cell~ targets {Cell 0 0})))
  
  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (current-history-item)
    (let ((tree (locate 'results)))
      (new History-Search-Item
        (get-mode~ (get-results))
        (get-search-domain)
        (get-search-targets)
        (get-whole-words?)
        (get-ignore-case?)
        (get-preserve-case?)
        (get-play-recording?)
        (get-expression?)
        (get-content~ tree)
        (get-selection~ tree))))
  
  
  (method protected (install-history-item item)
    (let ((tree (locate 'results)))
      (set-mode~ (get-results) [mode item])
      (set-search-domain [domain item])
      (set-search-targets [targets item])
      (set-whole-words? [whole-words? item])
      (set-ignore-case? [ignore-case? item])
      (set-preserve-case? [preserve-case? item])
      (set-play-recording? [play-recording? item])
      (set-expression? [expression? item])
      (set-content~ tree [content item])
      (set-selection~ tree [selection item]))))


;;;
;;;; Search-Targets
;;;


(class Search-Targets extends Tree-View
  
  
  (form
    (<install> font: {Font name: Code}))
  
  
  (method (mouse-down pos)
    (let ((cell (view->tree pos :any? true :uniform-height? true)))
      (if (not cell)
          (nextmethod pos)
        (select-cell cell))))
  
  
  (method (tab-stop-enter)
    (select-cell {Cell 0 0}))
  
  
  (method (add-empty-row . rest)
    (bind-keywords ((father {})) rest
      (let ((father (either father root-row))
            (children (map (function dynamic (column)
                             (new-empty-cell~ column))
                           columns)))
        (add-row :father father :children children))))
  
  
  (method (select-cell cell)
    (let* ((data (get-cell-data cell))
           (left (if (= [col cell] 0) 3 0))
           (editor (new Border-View :border-type 'solid :border-color {Color name: Medium}))
           (scroller (new Scroller-View parent: editor :vscroll? false :hscroll? false))
           (text (new Tree-Embedded-Search-Text-View parent: (get-content~ scroller) :left-padding left :top-padding 0 :font font)))
      (when data
        (set-string-content~ text (get-title~ data)))
      (edit-cell cell
                 :editor editor
                 :end-proc (function () (set-title~ (get-cell-data cell) (get-string-content~ text))))
      (set-client~ scroller text)
      (set-tree~ text self)
      (layout-scrollee~ text)
      (acquire-focus~ text)
      (select-all~ text)))))
