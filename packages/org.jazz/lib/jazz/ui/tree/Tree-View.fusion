;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Tree View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Stephane Le Cornec
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.tree.Tree-View jazz


(import (jazz.ui)
        (jazz.ui.view)
        (jazz.library)
        (jazz.platform)
        (jazz.utilities)
        (jazz.designer)
        (jazz.jml)
        (jazz.literals))


;; For now, cell selection-mode only supports single select mode


;;;
;;;; Terminology
;;;


;; visible   : a row that has all its parents expanded
;; displayed : a row that is displayed on-screen even if only partially


(class Tree-View extends Outline-View implements Selection-Provider
  
  
  (definition delayed-autorow
    {})

  
  (property protected portfolio                 initialize {}        getter get-portfolio                 setter set-portfolio)
  (property protected show-header?              initialize true      getter get-show-header?              setter set-show-header?)
  ;; row cell node
  (property protected selection-mode            initialize 'row      getter get-selection-mode            setter set-selection-mode)
  (property protected multiple-selection?       initialize false     getter get-multiple-selection?       setter set-multiple-selection?)
  (property protected can-select-empty?         initialize true      getter get-can-select-empty?         setter set-can-select-empty?)
  (property protected show-unfocused-selection? initialize true      getter get-show-unfocused-selection? setter set-show-unfocused-selection?)
  (property protected auto-expand/collapse?     initialize false     getter get-auto-expand/collapse?     setter set-auto-expand/collapse?)
  (property protected cell-background           initialize {}        getter get-cell-background           setter set-cell-background)
  (property protected empty-background          initialize {}        getter get-empty-background          setter set-empty-background)
  (property protected filled-column             initialize true      getter get-filled-column             setter set-filled-column)
  (property protected column-spacing            initialize 0         getter get-column-spacing            setter set-column-spacing)
  (property protected reorderable?              initialize false     getter get-reorderable?              setter set-reorderable?)
  (property protected content                   initialize {}       getter get-content                   setter set-content)
  
  
  (slot protected columns                initialize '())
  (slot protected node-column            initialize {})
  (slot protected sorted-column          initialize {})
  (slot protected sort-ascending?        initialize true)
  (slot protected selection-pivot        initialize {})
  (slot protected highlighted            initialize '())
  (slot protected indentation            initialize 16)
  (slot protected columns-borders        initialize '())
  (slot protected columns-right          initialize 0)
  (slot protected has-focus?             initialize false)
  (slot protected edited-cell            initialize {})
  (slot protected cell-editor            initialize {})
  (slot protected close-cell-editor?     initialize true)
  (slot protected auto-expanded-row      initialize {})
  (slot protected locator                initialize (new Tree-Locator))
  (slot protected selection-manager      initialize (new Selection-Manager self))
    
  
  (form
    (<install> background: {Color name: White}))


  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method (finish rest)
    (nextmethod rest)
    (invalidate-columns))
  
  
  (method (destroy-component)
    (end-edition)
    (nextmethod))
  

  ;;;
  ;;;; Component
  ;;;


  (method (add-child child)
    (nextmethod child)
    (when (is? child Tree-Column)
      (set! columns (append! columns (list child)))))
  
  
  (method (remove-child child)
    (nextmethod child)
    (when (is? child Tree-Column)
      (set! columns (remove! child columns))))
  

  ;;;
  ;;;; Access
  ;;;
  
  
  (method public (get-columns)
    columns)


  (method public (get-portfolio)
    (when portfolio
      (if (is? portfolio Portfolio)
          portfolio
        (set! portfolio (child portfolio))
        portfolio)))


  (method public (set-portfolio object)
    (set! portfolio object)
    (invalidate-view))


  (method public (get-show-header?)
    show-header?)


  (method public (set-show-header? value)
    (set! show-header? value))


  (method public (get-multiple-selection?)
    multiple-selection?)


  (method public (set-multiple-selection? flag)
    (set! multiple-selection? flag)
    (invalidate-view))


  (method public (get-can-select-empty?)
    can-select-empty?)


  (method public (set-can-select-empty? flag)
    (set! can-select-empty? flag)
    (invalidate-view))


  (method public (get-show-unfocused-selection?)
    show-unfocused-selection?)


  (method public (set-show-unfocused-selection? flag)
    (set! show-unfocused-selection? flag)
    (invalidate-view))


  (method public (get-selection-mode)
    selection-mode)


  (method public (set-selection-mode value)
    (set! selection-mode value)
    (invalidate-view))


  (method public (get-auto-expand/collapse?)
    auto-expand/collapse?)


  (method public (set-auto-expand/collapse? flag)
    (set! auto-expand/collapse? flag))


  (method public (get-filled-column)
    filled-column)


  (method public (set-filled-column value)
    (set! filled-column value))
  
  
  (method public (get-cell-background)
    cell-background)
  
  
  (method public (set-cell-background color)
    (set! cell-background color)
    (invalidate-view))
  
  
  (method public (get-empty-background)
    empty-background)
  
  
  (method public (set-empty-background color)
    (set! empty-background color)
    (invalidate-view))


  (method public (get-column-spacing)
    column-spacing)


  (method public (set-column-spacing spacing)
    (set! column-spacing spacing)
    (invalidate-view))


  (method public (get-reorderable?)
    reorderable?)


  (method public (set-reorderable? flag)
    (set! reorderable? flag))
  
  
  (method public (get-indentation)
    indentation)
  
  
  (method public (get-cell-editor)
    cell-editor)
  
  
  ;;;
  ;;;; Focus
  ;;;


  (method (focus-gain)
    (nextmethod)
    (set! has-focus? true)
    (invalidate-selection selection))


  (method (focus-lose window view)
    (nextmethod window view)
    (set! has-focus? false)
    (invalidate-selection selection))
  
  
  (method public (selection-color)
    (if (focused?)
        (focused-color)
      (unfocused-color)))
  
  
  (method protected virtual (focused-color)
    {Color name: Focused-Selection})
  
  
  (method protected virtual (unfocused-color)
    {Color name: Unfocused-Selection})
  
  
  (method public (selected-text-color)
    (if (focused?)
        {Color name: Focused-Selected-Text}
      {Color name: Unfocused-Selected-Text}))
  
  
  (method public virtual (focused?)
    (or has-focus?
        (let ((focus (get-focus)))
          (and focus (has-parent?~ focus self)))))
  
  
  (method public (focus-and-select)
    (acquire-focus)
    (when (> (get-visible-count) 0)
      (set-single-selection 0)))


  ;;;
  ;;;; Actions
  ;;;
  

  (method (focus-actions)
    (cons (find-actions 'tree)
          (nextmethod)))


  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-expand evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (expand row))))
  
  
  (method (on-expand-all evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (expand-all row))))
  
  
  (method (on-collapse evt)
    (let ((row (get-selected-row)))
      (if (not row)
          (bell)
        (collapse row))))
  
  
  (method protected virtual (on-properties evt)
    )
  
  
  ;;;
  ;;;; Header
  ;;;
  
  
  (method public (get-header)
    (let ((header (get-parent~ parent)))
      (when (is? header Tree-Header)
        header)))
  
  
  (method public (invalidate-header)
    (let ((header (get-header)))
      (when header
        (invalidate-view~ header))))


  ;;;
  ;;;; Layout
  ;;;
  
  
  (method protected (layout-column column)
    (let ((row [next root-row])
          (rt 0))
      (while row
        (let* ((height (get-effective-height~ row))
               (rb (+ rt height)))
          (set-size~ row (new Dimension columns-right height))
          (set! rt rb)
          (set! row [next row])
          (increase! rt row-spacing)))))
  

  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method (layout-scrollee)
    (nextmethod)
    (when filled-column
      (fill-column (get-display-size))))
  
  
  (method (scrollee-width)
    (max (get-display-width) (if show-header? columns-right (+ visible-width column-spacing))))
  

  ;;;
  ;;;; Update
  ;;;
  
  
  ;; todo: when metamodeler stability is less critical, take the time
  ;; to do both of these in a single pass
  (method (update-visible)
    (update-visible-height)
    (update-visible-width))
  
  
  (method (update-visible-height)
    (let ((count 0)
          (height 0)
          (first? true))
      (for-each-visible-row
        (function dynamic (row rank)
          (increase! count)
          (increase! height (get-effective-height~ row))
          (if first?
              (set! first? false)
            (increase! height row-spacing))))
      (set! visible-count count)
      (set! visible-height height)))
  
  
  ;; todo: can very easily optimize the text-h call away by calculating at the start the
  ;; base (text-h for some row - level * indentation) and then only adding level * indentation
  (method (update-visible-width)
    (when (not show-header?)
      (let ((width 0))
        ;; a quick not too clean solution for now...
        (when (is? node-column Tree-Node-Column)
          (for-each-visible-row
            (function dynamic (row rank)
              (let* ((highlight-border 3)
                     (nw (+ (either [node-width row] 0) highlight-border))
                     (w (+ (text-h~ node-column [level row]) nw)))
                (when (> w width)
                  (set! width w)))))
          (set! visible-width width)
          (set! columns-right width)
          (set! columns-borders (list (cons 0 width)))
          (set-width~ node-column width)))))
  
  
  (method (scroll-invalidate dh dv)
    (nextmethod dh dv)
    (invalidate-header))


  ;;;
  ;;;; Drawing
  ;;;
  
  
  (definition Highlighted-Outer-Color
    (new Color :red 0 :green 0 :blue 128))
  
  (definition Highlighted-Inner-Color
    (new Color :red 218 :green 218 :blue 255))
    
  (definition Highlighted-Insert-Color
    {Color name: Dark-Red})

  
  (method (draw-outline dc context update update-rect lh lv sh sv sc sc?)
    (nextmethod dc context update update-rect lh lv sh sv sc sc?)
    (let* ((pos (get-position))
           (left (+ [left update-rect] [h pos]))
           (right (+ [right update-rect] [h pos]))
           (height (get-height)))
      ;; probably buggy in ftx fix with alain
      (when (and empty-background (<= columns-right right))
        (with ((rect (new Rect (if sc? (round (* columns-right sc)) columns-right) 0 (if sc? (round (* right sc)) right) (if sc? (round (* height sc)) height))))
          (fill-rect~ dc rect empty-background))))
    (draw-highlighted dc))
  
  
  ;; probably still buggy when scaling, so limit to tree-view for now
  (method (draw-empty dc top bottom sh sv sc sc? rt width)
    (when (and empty-background (<= rt bottom))
      (with ((rect (new Rect 0 (round (if sc? (* rt sc) rt)) (round (if sc? (* width sc) width)) (round (if sc? (* bottom sc) bottom)))))
        (fill-rect~ dc rect empty-background))))
  
  
  (method (draw-highlighted dc)
    (for-each-reversed (function dynamic (highlight)
                         (let ((row (get-row~ highlight))
                               (col (get-col~ highlight))
                               (insert (get-insert~ highlight)))
                           (if (not insert)
                               (draw-highlighted-cell dc row col highlight)
                             (with ((rect (highlighted-insert-rect row insert)))
                               (fill-rect~ dc rect Highlighted-Insert-Color)))))
                       highlighted))
  
  
  (method protected virtual (draw-highlighted-cell dc row col highlight)
    (with ((inner-rect (highlighted-target-rect row col))
           (outer-rect (inflate-rect inner-rect 1 1)))
      (let ((outer-color (either (get-outer-color~ highlight) (highlighted-outer-color)))
             (inner-color (either (get-inner-color~ highlight) (highlighted-inner-color))))
        (frame-rect~ dc outer-rect outer-color)
        (when (highlight-inner?)
          (frame-rect~ dc inner-rect inner-color)))))
  
  
  (method protected virtual (highlighted-outer-color)
    Highlighted-Outer-Color)
  
  
  (method protected virtual (highlighted-inner-color)
    Highlighted-Inner-Color)
  
  
  (method protected virtual (highlight-inner?)
    true)
  
  
  (method public virtual (header-color)
    {Color name: Medium})
  
  
  ;;;
  ;;;; Highlight
  ;;;
  
  
  (method public (get-highlighted)
    highlighted)
  
  
  (method public (set-highlighted value)
    (assert (every? (function dynamic (object) (is? object Tree-Highlight)) value))
    (when (not (equal? value highlighted))
      (let ((old highlighted))
        (set! highlighted value)
        (invalidate-highlighted old)
        (invalidate-highlighted highlighted))))
  
  
  (method (invalidate-highlighted highlighted)
    (for-each (function dynamic (highlight)
                (let ((row (get-row~ highlight))
                      (col (get-col~ highlight))
                      (insert (get-insert~ highlight)))
                  (if (not insert)
                      (invalidate-highlighted-cell row col)
                    (invalidate-rect (highlighted-insert-rect row insert)))))
              highlighted))
  
  
  (method protected virtual (invalidate-highlighted-cell row col)
    (with-closed ((inner (highlighted-target-rect row col))
                  (outer (inflate-rect inner 1 1))
                  (region (frame-region outer :insets {Rect 2 2 2 2})))
      (invalidate-region region)))

  
  (method (highlighted-target-rect row col)
    (if (not col)
        (cell-text-rect (new Cell (row-rank row) 0))
      (cell-rect (new Cell (row-rank row) col))))
  
  
  (method (highlighted-insert-rect row insert)
    (let* ((height (get-height))
           (rank (row-rank row))
           (rect (row-rect rank) @old-l&f-probably-better (cell-content-rect (new Cell (row-rank row) 0)))
           (before-first? (and (= rank 0) (eq? insert 'before)))
           (after-last? (and (= rank (- visible-count 1)) (eq? insert 'after)))
           (half-spacing (- (round (/ row-spacing 2)) 1))
           (offset (cond (before-first? 0)
                         (after-last? -2)
                         ((eq? insert 'after) half-spacing)
                         (else (- half-spacing row-spacing))))
           (proc
            (function dynamic (v)
              (let* ((top (+ v offset))
                     (bottom (+ top 2)))
                (new Rect [left rect] top [right rect] bottom)))))
      (case insert
        ((before) (proc [top rect]))
        ((after) (proc [bottom rect])))))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method (update-visible-width-incremental level width)
    @wait-optimized
    (let ((width (+ (text-h~ node-column level) width)))
      (when (> width visible-width)
        (set! visible-width width))))

  
  (method (remove-row row)
    (when (and (attached?~ row) (eq? row auto-expanded-row))
      (close-auto-expanded-row))
    (nextmethod row))
  
  
  (method (remove-every-row)
    (close-auto-expanded-row)
    (set-sorted {} true)
    (set! highlighted '())
    (nextmethod))
  

  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method (allow-start-drag? pos)
    (and (nextmethod pos)
         (allow-start-drag?~ selection-manager)))
  
  
  (method (mouse-down view)
    (let* ((cell (view->tree view))
           (pos (essay cell (cell-coordinates cell view)))
           (part (essay cell (find-part~ (get-column [col cell]) cell pos))))
      (mouse-down~ selection-manager view part (shift-down?) (control-down?) (alt-down?) (get-multiple-selection?)))
    (acquire-focus)
    (acquire-capture)
    (let ((cell (view->tree view))
          (shift? (shift-down?))
          (control? (control-down?)))
      (if (not cell)
          (when can-select-empty?
            (set-selection '()))
        (let ((pos (cell-coordinates cell view))
              (column (get-column [col cell])))
          (mouse-down~ column cell pos shift? control?)))))
  
  
  (method (drag-move view)
    (let ((cell (view->tree view)))
      (when cell
        (let ((pos (cell-coordinates cell view))
              (column (get-column [col cell])))
          (drag-move~ column cell pos)))))
  
  
  (method (drag-up view . rest)
    (bind-optionals ((dragging? false)) rest
      (mouse-up~ selection-manager (shift-down?) (control-down?) (alt-down?))
      (let ((cell (view->tree (either (unless dragging? (get-mouse-down-view~ selection-manager)) view)))
            (shift? (shift-down?))
            (control? (control-down?)))
        (unless (or dragging? cell)
          (set-selection '()))
        ;; the idea is there to do the selection only at mouse-up when the cell is already
        ;; selected (necessary for dnd) but this code is a not very elegant quick solution
        (when (and cell (not dragging?))
          (let ((pos (cell-coordinates cell view))
                (row (get-row [row cell]))
                (column (get-column [col cell])))
            (unless (mouse-down-part-control?~ selection-manager)
              (complete-mouse-down~ column cell pos shift? control?)
              (when auto-expand/collapse?
                (auto-select~ row))
              (focus-delegate)
              (drag-up~ column cell pos)))))
      (release-capture)
      (process-action self)
      (reset~ selection-manager)))
  
  
  (method (call-double-click view)
    (let ((cell (view->tree view)))
      (when cell
        (let* ((pos (cell-coordinates cell view))
               (column (get-column [col cell]))
               (part (find-part~ column cell pos)))
          (case part
            ((control) (mouse-down view))
            ((content) (nextmethod view))
            (else (double-click~ column cell pos)))))))
  
  
  (method (double-click view)
    (double-click~ selection-manager (shift-down?) (control-down?) (alt-down?))
    (let ((cell (view->tree view)))
      (when cell
        (let* ((pos (cell-coordinates cell view))
               (column (get-column [col cell]))
               (part (find-part~ column cell pos)))
          (double-click~ column cell pos)))))
  
  
  (method (context-menu view)
    (let ((cell (view->tree view)))
      (when cell
        (let ((row (get-row [row cell])))
          (context-menu~ row (acquire~ row self view))))))
  
  
  (method (cell-coordinates cell pos)
    (- pos (cell-position cell)))


  ;;;
  ;;;; Keyboard
  ;;;


  (method (key-press key)
    (when (and (alphanumeric? key) (> visible-count 0))
      (enter~ locator key)))


  ;;;
  ;;;; Locator
  ;;;
  
  
  (method public (locate-prefix prefix)
    (locate~ locator prefix))
  

  ;;;
  ;;;; Sort
  ;;;

  
  (method public virtual (header-click column)
    (sort-column (column-rank column))
    (ensure-displayed))
  
  
  (method (set-sorted column ascending?)
    (let ((header (get-header))
          (same? (and sorted-column (= column sorted-column))))
      (when (and sorted-column (not same?))
        (invalidate-column-header~ header (get-column sorted-column)))
      (set! sort-ascending? ascending?)
      (set! sorted-column column)
      (when sorted-column
        (invalidate-column-header~ header (get-column sorted-column)))))
  
  
  (method public (sort-column column)
    (set-sorted column (or (not sorted-column) (/= column sorted-column) (not sort-ascending?)))
    (bind-values (equal smaller greater) (sort-predicates)
      (letrec ((direction (if sort-ascending? smaller greater))
               (proc (function dynamic (row)
                       (let ((sorted (sort-rows (get-sons~ row) column equal direction)))
                         (reorder-sons~ row sorted)
                         (for-each proc (get-sons~ row))))))
        (with-preserved-selection
          (function dynamic ()
            (with-update-locked
              (function dynamic ()
                (proc root-row))))
          :ensure-displayed? false))))
  
  
  (method (sort-rows rows column equal direction)
    (let ((dual? (/= column 0))
           (get-node
            (function dynamic (row children n)
              (let ((cell (element children n)))
                (either (sort-value~ (get-column n) row cell) "")))))
      (sort (function dynamic (rx ry)
              (let* ((cx (get-children~ rx))
                     (cy (get-children~ ry))
                     (nx (localize (get-node rx cx column)))
                     (ny (localize (get-node ry cy column))))
                (or (direction nx ny)
                    (and dual?
                         (equal nx ny)
                         (direction (localize (get-node rx cx 0)) (localize (get-node ry cy 0)))))))
            rows)))
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public (get-content)
    content)
  
  
  (method public (set-content value)
    (loop (for row in value)
          (for i from 0)
          (loop (for info in row)
                (for j from 0)
                (do (let* ((cell (new Cell i j))
                           (data (get-cell-data cell)))
                      (set-title~ data info)
                      (invalidate-cell cell))))))


  ;;;
  ;;;; Context
  ;;;

  
  (method (with-context-click pos proc)
    (acquire-focus)
    (let ((cell (view->tree pos)))
      (if (not cell)
          (when can-select-empty?
            (set-selection '()))
        (let ((row (get-row [row cell])))
          (case selection-mode
            ((cell)
             (unless (member? cell (get-selection))
               (set-selection (list cell))))
            (else
             (unless (memq? [row cell] (get-selection))
               (set-selection (list [row cell])))))
          (when auto-expand/collapse?
            (auto-select~ row)))
        (update-view))
      (proc)))

  
  ;;;
  ;;;; Flatten
  ;;;
  
  
  (method public (flattened?)
    (let ((path-column (get-path-column)))
      (and path-column (get-visible?~ path-column))))
  
  
  (method public (flatten/unflatten)
    (let* ((path-column (get-path-column))
           (flattened? (flattened?)))
      (if (not path-column)
          (error "Unable to find path column")
        (set-visible?~ path-column (not flattened?))
        (fill-column (get-display-size))
        (with-preserved-selection
          (function dynamic ()
            (with-update-locked
              (function dynamic ()
                (if flattened?
                    (unflatten)
                  (flatten)))))))))
  
  
  (method public (get-path-column)
    (find-if (function dynamic (column)
               (is? column Tree-Path-Column))
             columns))
  
  
  (method public virtual (flatten-row? row)
    true)
  
  
  (method public (flatten)
    (let ((sons (get-sons~ root-row)))
      (for-each (function dynamic (son)
                  (if (flatten-row? son)
                      (disconnect~ son)
                    (flatten~ son root-row)))
                sons)
      (for-each (function dynamic (son)
                  (unless (disconnected?~ son)
                    (set-visible?~ son false)))
                sons)))
  
  
  (method public (unflatten)
    (for-each (function dynamic (son)
                (when (disconnected?~ son)
                  (reconnect~ son)))
              (get-sons~ root-row))
    (for-each (function dynamic (son)
                (unless (get-visible?~ son)
                  (set-visible?~ son true)))
              (get-sons~ root-row)))
  

  ;;;
  ;;;; Tooltip
  ;;;


  (method (get-tooltip?)
    true)
  
  
  (method (get-tooltip-context pos)
    (if (get-tooltip-text)
        (nextmethod pos)
      (let ((cell (view->tree pos)))
        (when cell
          (let ((row (get-row [row cell]))
                (column (get-column [col cell]))
                (text (localize (get-cell-tooltip cell))))
            (when text
              (let* ((width (column-width [col cell]))
                     (height (get-height~ row))
                     (content-rect (content-rect~ column row cell width height))
                     (formatted? (get-formatted-tooltip?))
                     (text-width (if formatted? 0 (+ (text-width~ font text) 5))))
                (when (or (cell-tooltips?) (> text-width (rect-width content-rect)))
                  (let ((rect (inflate-rect (cell-rect cell) 1 1))
                        (h (+ (content-h~ column (get-level~ row)) (if (= [col cell] 0) 2 -2))))
                    (new Tooltip-Context
                      :view self
                      :text (if formatted? text (split text (cn)))
                      :bounds rect
                      :position (get-tooltip-position text rect h 0)
                      :font font))))))))))
  
  
  (method protected virtual (cell-tooltips?)
    false)
  
  
  (method protected virtual (get-cell-tooltip cell)
    (let ((column (get-column [col cell]))
          (data (get-cell-data cell)))
      (get-cell-tooltip~ column data)))
  
  
  (method protected virtual (get-tooltip-position text rect h v)
    (+ (rect-position rect) (new Point (- h 10) (+ v (rect-height rect) 5))))
  
  
  (method protected virtual (get-column-tooltip column)
    {})


  ;;;
  ;;;; Dnd
  ;;;
  
  
  (method (get-drag-drop)
    (when (view->tree mouse-down-point)
      (nextmethod)))


  ;;;
  ;;;; Drag
  ;;;
  
  
  (method (get-drag-source)
    (let* ((pos (get-drag-position))
           (cell (view->tree pos))
           (row (get-row [row cell]))
           (col [col cell]))
      (get-drag-cell-source pos row col)))
  
  
  (method protected virtual (get-drag-cell-source pos row col)
    (new Tree-Drag-Source :view self :position pos @old :image @old (get-drag-image pos) :row row :col col))
  
  
  (method (get-drag-hotspot)
    (let* ((cell (view->tree mouse-down-point))
           (row (get-row [row cell]))
           (left (image-h~ node-column (get-level~ row)))
           (top [v (get-position~ row)]))
      (new Point left top)))
  
  
  (method (get-drag-image pos)
    (let* ((cell (view->tree pos))
           (row [row cell]))
      (get-node-image row)))

  
  (method public (get-node-image n)
    (let* ((cdc (new Cairo-Client-Surface player))
           (row (get-row n))
           (cell (get-cell-data (new Cell n 0)))
           (image (get-image~ cell))
           (title (get-title~ cell))
           (width (column-width (get-node-column-index)))
           (height (get-height~ row))
           (bitmap)
           (mask))
      (with-closed ((memdc (new Cairo-Memory-Surface cdc :size (new Dimension width height) :keep-bitmap? true))
                    (maskdc (new Cairo-Memory-Surface cdc :size (new Dimension width height) :keep-bitmap? true)))
        (fill-rect~ memdc (new Rect 0 0 width height) {Color name: White})
        (fill-rect~ maskdc (new Rect 0 0 width height) {Color name: White})
        (draw-image~ portfolio memdc {} image 0 0)
        (draw-mask~ portfolio maskdc image 0 0)
        (set-font~ memdc font)
        (set-text-color~ memdc {Color name: Black})
        (draw-text~ memdc 19 2 title)
        (set-font~ maskdc font)
        (set-text-color~ maskdc {Color name: Black})
        (draw-text~ maskdc 19 2 title)
        (set! bitmap (get-bitmap~ memdc))
        (set! mask (get-bitmap~ maskdc)))
      (let* ((portfolio (new Portfolio :width width :height height :masked? true))
             (no (add-masked-bitmap~ portfolio bitmap mask)))
        (new Image :portfolio portfolio :image-name no))))
    

  ;;;
  ;;;; Drop
  ;;;
  
  
  (method (current-drop drag-drop pos)
    (if (get-surrogate)
        (nextmethod drag-drop pos)
      (if (and reorderable? (eq? self (get-view~ (get-source~ drag-drop))))
          (get-reorder-target drag-drop pos)
        (get-tree-target drag-drop pos))))
  
  
  (method (get-reorder-target drag-drop pos)
    (let ((info (view->tree-extended pos)))
      (when info
        (bind-values (cell v height) info
          (when cell
            (let* ((rank [row cell])
                   (quarter (get-row-quarter v height))
                   (current (get-target~ drag-drop))
                   (row (get-row rank)))
              (if (and current (eq? self [view current]) (eq? row (get-row~ current)) (= quarter (get-quarter~ current)))
                  current
                (get-row-reorder-target drag-drop row quarter))))))))
  
  
  (method (get-row-quarter v height)
    (let ((quarter (/ height 4))
          (middle (/ height 2)))
      (cond ((< v quarter) 1)
            ((< v middle) 2)
            ((< v (- height quarter)) 3)
            (else 4))))
  
  
  (method protected virtual (get-row-reorder-target drag-drop row quarter)
    (let* ((same-row? (memq? (row-rank row) selection))
           (src-selection (get-selection~ (get-view~ (get-source~ drag-drop))))
           (src-range (contiguous-range src-selection))
           (dst (get-user-data~ row))
           (dst-rank (row-rank row))
           (current-rank (if (memq? quarter '(1 2)) dst-rank (+ dst-rank 1)))
           (accept? (or (not src-range) (and (not (memq? current-rank src-selection)) (/= current-rank (+ (cdr src-range) 1))))))
      (when accept?
        (let ((part (if (= current-rank dst-rank) 'before 'after)))
          (new Tree-Drop-Target :view self :row row :part part)))))
  
  
  (method protected virtual (get-tree-target drag-drop pos)
    (get-tree-row-target drag-drop pos))
  
  
  (method protected (get-tree-row-target drag-drop pos)
    (let ((info (view->tree-extended pos)))
      (when info
        (bind-values (cell v height) info
          (when cell
            (let ((row (get-row [row cell]))
                  (current (get-target~ drag-drop)))
              (if (and current (eq? self [view current]) (eq? row (get-row~ current)))
                  current
                (get-row-target drag-drop row))))))))
  
    
  (method public (get-tree-cell-target drag-drop pos)
    (let ((info (view->tree-extended pos)))
      (when info
        (bind-values (cell v height) info
          (when cell
            (let ((row (get-row [row cell]))
                  (col [col cell])
                  (source (get-source~ drag-drop))
                  (current (get-target~ drag-drop)))
              (when (or (neq? (get-view~ source) self) (neq? (get-row~ source) row) (/= (get-col~ source) col))
                (if (and current (eq? self [view current]) (eq? row (get-row~ current)) (= col (get-col~ current)))
                    current
                  (get-cell-target drag-drop row col)))))))))
  
  
  (method protected virtual (get-row-target drag-drop row)
    {})
  
  
  (method protected virtual (get-cell-target drag-drop row col)
    {})
    
  
  (method (highlight-drop drag-drop pos)
    (let ((target (get-target~ drag-drop)))
      ;; temp patch... this should always be a t-d-t
      (when (is? target Tree-Drop-Target)
        (let* ((row (get-row~ target))
               (col (get-col~ target))
               (part (get-part~ target))
               (insert
                (case part
                  ((row) {})
                  ((before) 'before)
                  ((after) 'after)))
               (highlight (new Tree-Highlight row col :insert insert :outer-color Highlighted-Outer-Color :inner-color Highlighted-Inner-Color)))
          (set-highlighted (cons highlight (get-highlighted)))))))
  
  
  (method (unhighlight-drop drag-drop)
    (set-highlighted (cdr (get-highlighted))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method (tab-stop-enter)
    )

  
  ;;;
  ;;;; Edition
  ;;;


  (method public (on-home evt)
    (home-action))
  
  
  (method public (home-action)
    (let ((count (get-visible-count)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot [col selection-pivot] 0)))
             (set-selection (list (new Cell 0 col)))))
          (else
           (set-selection (list 0)))))))


  (method public (on-end evt)
    (end-action))
  
  
  (method public (end-action)
    (let ((count (get-visible-count)))
      (when (> count 0)
        (case selection-mode
          ((cell)
           (let ((col (if selection-pivot [col selection-pivot] 0)))
             (set-selection (list (new Cell (- count 1) col)))))
          (else
           (set-selection (list (- count 1))))))))


  (method (left-arrow-press modifiers)
    (left-arrow-action modifiers true))
  
  
  (method public (left-arrow-action modifiers user?)
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (when (> [col cell] 0)
             (move-cell (new Cell [row cell] (- [col cell] 1)) 'left user?)))))
      ((row)
       (let ((row (get-selected-row)))
         (if (not row)
             (bell)
           (if (expanded?~ row)
               (expand/collapse row)
             (when (> (get-level~ row) 0)
               (set-selection (list (row-rank (get-father~ row)))))))))))


  (method (up-arrow-press modifiers)
    (up-arrow-action modifiers true))
  
  
  (method public (up-arrow-action modifiers user?)
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (when (> [row cell] 0)
             (move-cell (new Cell (- [row cell] 1) [col cell]) 'up user?)))))
      (else
       (let ((count (get-visible-count)))
         (if (null? selection)
             (when (> count 0)
               (move-selection (- count 1) 'backward user?))
           (let ((row (car selection)))
             (when (> row 0)
               (move-selection (- row 1) 'backward user?))))))))


  (method (right-arrow-press modifiers)
    (right-arrow-action modifiers true))
  
  
  (method public (right-arrow-action modifiers user?)
    (case selection-mode
      ((cell)
       (when (not-null? selection)
         (let ((cell selection-pivot))
           (when (< [col cell] (- (get-columns-count) 1))
             (move-cell (new Cell [row cell] (+ [col cell] 1)) 'right user?)))))
      (else
       (let ((row (get-selected-row)))
         (if (not row)
             (bell)
           (unless (expanded?~ row)
             (expand/collapse row)))))))


  (method (down-arrow-press modifiers)
    (down-arrow-action modifiers true))
  
  
  (method public (down-arrow-action modifiers user?)
    (let* ((count (get-visible-count))
           (last (- count 1)))
      (case selection-mode
        ((cell)
         (when (not-null? selection)
           (let ((cell selection-pivot))
             (when (< [row cell] last)
               (move-cell (new Cell (+ [row cell] 1) [col cell]) 'down user?)))))
        (else
         (if (null? selection)
             (when (> count 0)
               (move-selection 0 'forward user?))
           (let ((row (car selection)))
             (when (< row last)
               (move-selection (+ row 1) 'forward user?))))))))
    
  
  (method (move-selection n direction user?)
    (when user?
      (acquire-focus))
    (let ((row (get-row n)))
      (set-selection (list n) :user-origin? true)
      (when auto-expand/collapse?
        (auto-select~ row))
      (update-view)))
  
  
  (method (move-cell cell direction user?)
    (when user?
      (acquire-focus))
    (set-selection (list cell) :ensure-displayed? false :user-origin? true)
    (let ((rect (cell-rect cell)))
      (case direction
        ((left)  (scroll (new Point (horizontal-scroll-needed [left rect] 'backward) 0)))
        ((up)    (scroll (new Point 0 (vertical-scroll-needed [top rect] 'backward))))
        ((right) (scroll (new Point (horizontal-scroll-needed [right rect] 'forward) 0)))
        ((down)  (scroll (new Point 0 (vertical-scroll-needed [bottom rect] 'forward))))))
    (update-view))
  
  
  (method (row-displayed? n)
    (let* ((row (get-row n))
           (top (get-top~ row))
           (bottom (get-bottom~ row))
           (needed (scroll-needed (new Point 0 top) (new Point 0 bottom) {})))
      (= [v needed] 0)))
  
  
  (method (cell-displayed? cell)
    (let* ((rect (cell-rect cell))
           (needed (scroll-needed (new Point [left rect] [top rect]) (new Point [right rect] [bottom rect]) {})))
      (and (= [h needed] 0)
           (= [v needed] 0))))
  
  
  (method (select-all . rest)
    (bind-keywords ((user-origin? false)) rest
      (when multiple-selection?
        (set-selection (naturals 0 visible-count) :user-origin? user-origin?))))

  
  ;;;
  ;;;; Columns
  ;;;
  
  @w
  (method public (fill-column size)
    (when (and filled-column (not-null? columns-borders))
      (let* ((column (find-filled-column filled-column))
             (rank (column-rank column)))
        (when (< rank (length columns-borders))
          (let* ((filled-borders (element columns-borders rank))
                 (min-delta (- (get-width~ column) 10))
                 (size-delta (- [width size] (space-after-column rank) (borders-right filled-borders)))
                 (delta @w (max size-delta min-delta) size-delta)
                 (old-right (cdr filled-borders))
                 (new-right (+ old-right delta)))
            (when (/= 0 delta)
              (if false @w (/= delta min-delta)
                  (when (= self [% Development])
                    (log-stack name: "fill-column" :message (format ":size {a}" size))
                    @reset-scroller-width xxx)
                (for-each (function dynamic (pair)
                            (set-car! pair (+ (car pair) delta))
                            (set-cdr! pair (+ (cdr pair) delta)))
                          (tail columns-borders (+ rank 1)))
                (set-cdr! filled-borders new-right)
                (increase! columns-right delta)
                (increase! [width column] delta)
                (with ((rect (new Rect
                               (- (min old-right new-right) 2) 0
                               [width size] [height size])))
                  (invalidate-rect rect))
                (invalidate-header))))))))
  
  
  (method public (fill-column size)
    (when (and filled-column (not-null? columns-borders))
      (let* ((column (find-filled-column filled-column))
             (rank (column-rank column)))
        (when (< rank (length columns-borders))
          (let* ((filled-borders (element columns-borders rank))
                 (delta (- [width size] (space-after-column rank) (borders-right filled-borders)))
                 (old-right (cdr filled-borders))
                 (new-right (+ old-right delta)))
            (for-each (function dynamic (pair)
                        (set-car! pair (+ (car pair) delta))
                        (set-cdr! pair (+ (cdr pair) delta)))
                      (tail columns-borders (+ rank 1)))
            (set-cdr! filled-borders new-right) 
            (increase! columns-right delta)
            (increase! [width column] delta)
            (with ((rect (new Rect
                           (- (min old-right new-right) 2) 0
                           [width size] [height size])))
              (invalidate-rect rect))
            (invalidate-header))))))
  
  
  (method (find-filled-column name)
    (cond ((integer? name) (element columns name))
          ((eq? name true) (last columns))
          (else (find-if (function dynamic (column)
                           (= (get-name~ column) name))
                         columns))))
  
  
  (method (space-after-column rank)
    (let ((total 0))
      (for-each (function dynamic (borders)
                  (increase! total (borders-width borders)))
                (tail columns-borders (+ rank 1)))
      total))

  
  (method public (add-column . rest)
    (bind-keywords ((context self) (class Tree-Column) (title {}) (width {}) . others) rest
      (let ((column (apply new-in context class parent: self others)))
        (when (is? column Tree-Node-Column)
          (set! node-column column))
        (when width
          (set-width~ column width))
        @called-by-set-width (invalidate-columns)
        (when title
          (set-title~ column title))
        (fill-column (get-display-size))
        (invalidate-header)
        column)))
  
  
  (method public (remove-column column)
    (set! columns (remove! column columns))
    (when (eq? column node-column)
      (set! node-column {}))
    (invalidate-columns)
    (fill-column (get-display-size))
    (invalidate-header))
  
  
  (method public (remove-columns . rest)
    (bind-keywords ((preserve-node-column? false) (preserve {})) rest
      (if (or preserve-node-column? preserve)
          (remove-columns-preserving preserve-node-column? preserve)
        (remove-all-columns))))
  
  
  (method (remove-all-columns)
    (remove-every-row)
    (set-children '())
    (set! columns '())
    (set! columns-borders '())
    (set! columns-right 0)
    (set! node-column {})
    (invalidate-header))
  
  
  (method (remove-columns-preserving preserve-node-column? preserve)
    (remove-every-row)
    (for-each (function dynamic (column)
                (unless (or (and preserve-node-column? (is? column Tree-Node-Column))
                            (memq? (get-name~ column) preserve))
                  (remove-column column)))
              (get-columns))
    (invalidate-header))

  
  (method (invalidate-columns)
    (when (not-null? columns)
      (invalidate-node-column)
      (invalidate-borders)))
  
  
  (method (invalidate-node-column)
    (set! node-column (find-if (function dynamic (column)
                                 (is? column Tree-Node-Column))
                               columns)))

  
  (method protected (invalidate-borders)
    (let ((left 0))
      (with ((proc <Procedure>
              (function dynamic (column)
                (let* ((width (get-width~ column))
                       (right (+ left width)))
                  (prog1 (cons left right)
                    (when (get-visible?~ column)
                      (set! left (+ right column-spacing))))))))
        (set! columns-borders (map proc columns)))
      (set! columns-right (+ (borders-right (last columns-borders)) column-spacing))))
    
  
  (method public (get-columns-count)
    (length columns))
    
  
  (method public (get-column n)
    (element columns n))
  
  
  (method public (get-node-column)
    node-column)
  
  
  (method public (find-column name)
    (find-component name))
  
  
  (method public (get-node-column-index)
    (column-rank node-column))
  
  
  (method public (column-rank column)
    (find column columns return: 'position))

  
  ;;;
  ;;;; Rows
  ;;;
  
  
  (method (row-class)
    Tree-Row)
  
  
  (method (update-father-control father)
    (when (and (not update-locked?) (neq? father root-row) (row-visible?~ father))
      (let* ((rank (row-rank father))
             (top (row-top rank)))
        (when (< top (get-height))
          (invalidate-rect (control-rect~ node-column father top))
          (invalidate-rect (image-rect~ node-column father top))))))
  
  
  (method (add-empty-row . rest)
    (bind-keywords ((father {})) rest
      (let ((father (either father root-row)))
        (add-row :father father :children (map (function dynamic (column)
                                                 (new-empty-cell~ column))
                                               columns)))))
  
  
  (method (row-selected? row)
    (case selection-mode
      ((cell) (some? (function dynamic (cell) (= [row cell] row)) selection))
      (else (memq? row selection))))
  
  
  (method (row-draw-selected? row)
    (and (nextmethod row)
         (or has-focus? show-unfocused-selection?)))

  
  ;;;
  ;;;; User
  ;;;
  
  
  (method public (row-index target)
    (call/ec
      (lambda (return)
        (for-each-visible-row
          (function dynamic (row rank)
            (when (eq? row target)
              (return rank))))
        {})))


  (method public (user-data-row data . rest)
    (bind-keywords ((test eqv?) (visible? true)) rest
      (call/ec
        (lambda (return)
          ((if visible? for-each-visible-row for-each-row)
           (function dynamic (row rank)
             (when (test (get-user-data~ row) data)
               (return row))))
          {}))))


  (method public (user-data-rows data-list . rest)
    (bind-keywords ((test eqv?) (visible? true)) rest
      (let ((fact (new List-Factory)))
        ((if visible? for-each-visible-row for-each-row)
         (function dynamic (row rank)
           (let ((user-data (get-user-data~ row)))
             (when (member? user-data data-list test: test)
               (put~ fact row)))))
        (get-output~ fact))))


  ;; Because it returns the rank, this method only makes sense on visible rows
  (method public (user-data-index data . rest)
    (bind-keywords ((test eqv?)) rest
      (call/ec
        (lambda (return)
          (for-each-visible-row
            (function dynamic (row rank)
              (when (test (get-user-data~ row) data)
                (return rank))))
          {}))))


  ;; Because it returns the rank, this method only makes sense on visible rows
  (method public (user-data-indexes data-list . rest)
    (bind-keywords ((test eqv?)) rest
      (let ((fact (new List-Factory)))
        (for-each-visible-row
          (function dynamic (row rank)
            (let ((user-data (get-user-data~ row)))
              (when (member? user-data data-list test: test)
                (put~ fact rank)))))
        (get-output~ fact))))
  
  
  (method public (select-user-data-row data)
    (let ((row (user-data-row data)))
      (if (not row)
          (error "Unable to select user-data: {t}" data)
        (set-single-selection (row-rank row)))))

  
  ;;;
  ;;;; Cells
  ;;;
  
  
  (method public (get-cell-data cell)
    (let ((row (get-row [row cell])))
      (when row
        (when (>= [col cell] (length (get-children~ row)))
          (set! selection '())
          (error "Sequence overrun"))
        (element (get-children~ row) [col cell]))))
  
  
  (method public (set-cell-data cell data)
    (let ((row (get-row [row cell])))
      (set-element! (get-children~ row) [col cell] data)))
  
  
  (method public (invalidate-cell cell)
    (invalidate-rect (cell-rect cell)))
  
  
  (method public (redraw-cell cell)
    (invalidate-rect (cell-rect cell))
    (update-view))


  ;;;
  ;;;; State
  ;;;
  
  
  (method (expand/collapse row)
    (let ((top [v (get-position~ row)]))
      (invalidate-rect (control-rect~ node-column row top)))
    (case [state row]
      ((dynamic) (dynamic-expand row))
      (else (nextmethod row))))
  
  
  (method public (dynamic-expand row)
    (update-row row)
    (expand row true))
  
  
  (method (invalidate-expand row top dynamic?)
    (invalidate-rect (image-rect~ node-column row top))
    (if (and dynamic? (null? [sons row]))
        (invalidate-rect (control-rect~ node-column row top))
      (invalidate-rect (plus/minus-rect~ node-column row top))))
  
  
  (method (invalidate-collapse rank row top selected?)
    (invalidate-rect (image-rect~ node-column row top))
    (if selected?
        (invalidate-rect (row-rect rank))
      (invalidate-rect (plus/minus-rect~ node-column row top))))
  
  
  (method (collapse-selection rank removed)
    (case selection-mode
      ((cell)
       (when removed
         (let ((cell (new Cell rank [col removed])))
           (unless (member? cell selection)
             (set! selection (cons cell selection))))))
      (else
       (when (and removed (not (row-selected? rank)))
         (set! selection (cons rank selection))))))
  
  
  (method public (auto-expand/collapse row . rest)
    (bind-keywords ((close-auto-expanded? true) (auto-toggle? false)) rest
      (with-update-locked
        (function dynamic ()
          (let ((selected-rows (selection->rows selection)))
            (cond
              ((mouse-down?~ selection-manager)
               (when (and close-auto-expanded? auto-expanded-row (/= auto-expanded-row row))
                 (close-auto-expanded :new-spine (essay row (get-spine~ row)) :force? false)
                 (set! delayed-autorow auto-expanded-row)
                 (set! auto-expanded-row {}))
               (when (and row (auto-inplace?~ row))
                 (auto-toggle row auto-toggle?)))
              ((mouse-up?~ selection-manager)
               (when delayed-autorow
                 (if row
                     (close-delayed-row :new-spine (get-spine~ row))
                   (auto-collapse~ delayed-autorow)
                   (set! delayed-autorow {})))
               (when (and row (not (auto-inplace?~ row)))
                 (auto-toggle row auto-toggle?)))
              (else
               (when close-auto-expanded?
                 (close-auto-expanded :new-spine (essay row (get-spine~ row))))
               (when row
                 (auto-toggle row auto-toggle?))))
            (set! selection (rows->selection selected-rows)))))))
  
  
  (method (auto-toggle row auto-toggle?)
    (if (expanded?~ row)
        (when auto-toggle?
          (auto-collapse~ row)
          (set! auto-expanded-row {}))
      (auto-expand~ row)
      (set! auto-expanded-row row)))
  
  
  (method public (close-delayed-row . rest)
    (bind-keywords ((new-spine {})) rest
      (when delayed-autorow
        (let ((old-spine (get-spine~ delayed-autorow))
              (done? false))
          (set! delayed-autorow {})
          (for-each-reversed (function dynamic (row)
                               (unless done?
                                 (if (memq? row new-spine)
                                     (set! done? true)
                                   (auto-collapse~ row))))
                             old-spine)))))
  
  
  (method public (close-auto-expanded . rest)
    (bind-keywords ((new-spine {}) (force? true)) rest
      (when auto-expanded-row
        (let ((old-spine (get-spine~ auto-expanded-row))
              (done? false))
          (set! auto-expanded-row {})
          (for-each-reversed (function dynamic (row)
                               (unless done?
                                 (if (memq? row new-spine)
                                     (set! done? true)
                                   (if (or force? (auto-inplace?~ row))
                                       (auto-collapse~ row)
                                     (set! auto-expanded-row row)
                                     (set! done? true)))))
                             old-spine)))))
  
  
  (method (close-auto-expanded-row)
    (when auto-expanded-row
      (auto-collapse~ auto-expanded-row)
      (set! auto-expanded-row {})))
  
  
  ;; Should not really be public... Only used by the List-Row class.
  (method public (set-auto-expanded-row row)
    (set! auto-expanded-row row))
  
  
  (method public (set-dynamic row)
    (when (/= [state row] 'dynamic)
      (set! [state row] 'dynamic)
      (let* ((rank (row-rank row))
             (top (row-top rank)))
        (invalidate-rect (control-rect~ node-column row top)))))

  
  ;;;
  ;;;; Scroll
  ;;;


  (method (ensure-displayed . rest)
    (when (not-null? selection)
      (if (= selection-mode 'cell)
          (ensure-cell-displayed (car selection))
        (ensure-row-displayed (selection-row (car selection))))))
  
  
  (method (ensure-cell-displayed cell)
    (let* ((rect (cell-rect cell))
           (pos (rect-position rect)))
      ;; the second pos should take in the cell width and height
      (scroll (scroll-needed pos pos (get-scroll-context)))))

  
  ;;;
  ;;;; Selection
  ;;;
  
  
  (method public (process-selection cell shift? control?)
    (let ((element (case selection-mode ((cell) cell) (else [row cell]))))
      (if (and multiple-selection? (or shift? control?))
          (cond ((and shift? control?)
                 (set! selection-pivot element)
                 (unless (member? element selection)
                   (set-selection (list element) :set-pivot? false :user-origin? true)))
                (shift?
                 (unless (= selection-mode 'cell) ; unimplemented
                   (let ((pivot (either selection-pivot 0)))
                     (cond ((= element pivot) (set-selection (list element) :set-pivot? false :user-origin? true))
                           ((> element pivot) (set-selection (naturals pivot (+ element 1)) :set-pivot? false :user-origin? true))
                           ((< element pivot) (set-selection (naturals element (+ pivot 1)) :set-pivot? false :user-origin? true))))))
                (control?
                 (if (member? element selection)
                     (set-selection (remove element selection test: equal?) :set-pivot? false :user-origin? true)
                   (set-selection (cons element selection) :set-pivot? false :user-origin? true))
                 (when (= element selection-pivot)
                   (cond ((null? selection) (set! selection-pivot {}))
                         ((< selection-pivot (car selection)) (set! selection-pivot (car selection)))
                         ((> selection-pivot (last selection)) (set! selection-pivot (last selection)))))))
        (when (and (member? element selection) (allow-start-drag?~ selection-manager))
          (delay-selection~ selection-manager))
        (set! selection-pivot element)
        (set-selection (list element) :set-pivot? false :user-origin? true))))
  
  
  (method public (get-selection)
    selection)
  
  
  (method public (get-ordered-selection)
    (sort < selection))
  
  
  (method public (set-selection sel . rest)
    (bind-keywords ((force? false) (set-pivot? true) (ensure-displayed? true) (auto-expand? true)
                    (generate-event? true) (user-origin? false)) rest
      (unless (locked?~ selection-manager)
        (reset~ locator)
        (when (change-selection?~ selection-manager)
          (let ((old-selection selection))
            (set! selection sel)
            (when set-pivot?
              (set! selection-pivot (if (null? selection) {} (car selection))))
            (when (not-null? old-selection)
              (invalidate-selection old-selection))
            (when (not-null? selection)
              (invalidate-selection selection))
            (when generate-event?
              (selection-change old-selection force? user-origin?))))
        (let ((auto-row (essay (not-null? sel) (get-row (selection-row (car sel))))))
          (when (and auto-expand/collapse? auto-expand?)
            (unless multiple-selection?
              (auto-expand/collapse auto-row :auto-toggle? true))
            (when auto-row
              (auto-select~ auto-row))))
        (when (and ensure-displayed? (end-delayed?~ selection-manager))
          (ensure-displayed)))))
  
  
  (method protected virtual (selection-change old-selection force? user-origin?)
    (with-locked-operation~ selection-manager
     (function dynamic ()
       (call-selection-handler old-selection selection force? user-origin?))))
  
  
  (method (remember-selection use)
    (let ((proc (case use
                  ((row) get-row)
                  ((rank) identity)
                  ((data) (function dynamic (row) [user-data (get-row row)])))))
      (case selection-mode
        ((cell) (map (function dynamic (cell)
                     (cons (proc [row cell]) [col cell]))
                   (get-selection)))
        (else (map proc (get-selection))))))
  
  
  (method (restore-selection use saved-sel test)
    (let ((proc (case use
                  ((row) row-rank)
                  ((rank) identity)
                  ((data) (function dynamic (data) (user-data-index data test: test))))))
      (remove-nils
       (case selection-mode
         ((cell) (map (function dynamic (pair)
                      (bind (row . col) pair
                        (let ((row (proc row)))
                          (when row
                            (new Cell row col)))))
                    saved-sel))
         (else (map proc saved-sel))))))
  
  
  (method public (with-preserved-selection proc . rest)
    (bind-keywords ((use 'row) (test eqv?) (ensure-displayed? true) (generate-event? false)) rest
      (let ((saved-sel (remember-selection use)))
        (set-selection '())
        (proc)
        (let ((selection (restore-selection use saved-sel test)))
          (when (in-edition?)
            (let ((edition-row (get-parent~ cell-editor)))
              (when (neq? edition-row (get-row [row edited-cell]))
                (set! [row edited-cell] (row-rank edition-row)))))
          (set-selection selection :ensure-displayed? ensure-displayed? :generate-event? generate-event? :auto-expand? false)))))
  
  
  (method public (get-single-selection)
    (if (null? selection)
        {}
      (car selection)))
  
  
  (method public (set-single-selection sel . rest)
    (assert (or (integer? sel) (is? sel Cell)))
    (apply set-selection (list sel) rest))
  
  
  (method public (auto-select-first)
    (when (and (null? selection) (> (get-visible-count) 0))
      (set-selection (list 0))))
  
  
  (method (selected-row-proc)
    (case selection-mode
      ((cell) (function (cell)
              (get-row [row cell])))
      (else get-row)))
  
  
  (method public (get-selected-row)
    (let ((selection (get-single-selection)))
      (when (not-null? selection)
        ((selected-row-proc) selection))))
  
  
  (method public (get-selected-rows)
    (map (selected-row-proc) selection))
  
  
  (method public (get-selected-data)
    (map (function dynamic (row)
           (get-user-data~ row))
         (get-selected-rows)))
  
  
  (method public (get-single-selected-data)
    (let ((row (get-selected-row)))
      (when row
        (get-user-data~ row))))
  
  
  (method public (get-selection-data selection)
    (map (function dynamic (n)
           (let ((row (get-row n)))
             (get-user-data~ row)))
         selection))
  
  
  (method public (with-deleted-selection selection proc . rest)
    (bind-keywords ((can-survive? false)) rest
      (let ((data (essay can-survive? (get-selection-data selection)))
            (smallest (apply generic-min selection)))
        (proc)
        (let ((sel (essay can-survive? (remove-nils (map user-data-index data)))))
          (if (and can-survive? (= (length selection) (length sel)))
              (set-selection sel)
            (when (and smallest (> smallest 0))
              (let ((previous (- smallest 1)))
                (set-single-selection previous))))))))
  
  
  (method (selection->rows selection)
    (case selection-mode
      ((cell)
       (map (function dynamic (cell)
              (cons (get-visible-row [row cell]) [col cell]))
            selection))
      (else
       (map get-visible-row selection))))
  
  
  (method (rows->selection rows)
    (case selection-mode
      ((cell)
       (remove-nils (map (function dynamic (pair)
                           (bind (row . col) pair
                             (new Cell (row-index row) col)))
                         rows)))
      (else
       (remove-nils (map row-index rows)))))
  
  
  ;; update slots that are rank based
  (method (added-update-selection rank count)
    (when (and edited-cell (>= [row edited-cell] rank))
      (increase! [row edited-cell] count))
    (with ((proc
            (case selection-mode
              ((cell) (function dynamic (pair)
                      (let* ((cell (car pair))
                             (r [row cell]))
                        (when (>= r rank)
                          (set-car! pair (new Cell (+ r count) [col cell]))))))
              (else (function dynamic (pair)
                      (let ((r (car pair)))
                        (when (>= r rank)
                          (set-car! pair (+ r count)))))))))
      (for-each-pair proc selection)))
  
  
  ;; update slots that are rank based
  (method (removed-update-selection rank count)
    (when (and edited-cell (>= [row edited-cell] rank))
      (decrease! [row edited-cell] count))
    (let ((removed '()))
      (with ((proc
               (case selection-mode
                 ((cell) (function dynamic (cell)
                           (let ((r [row cell]))
                             (if (< r rank)
                                 cell
                               (if (> r (+ rank count -1))
                                   (new Cell (- r count) [col cell])
                                 (set! removed (cons cell removed))
                                 {})))))
                 (else (function dynamic (r)
                         (if (< r rank)
                             r
                           (if (> r (+ rank count -1))
                               (- r count)
                             (set! removed (cons r removed))
                             {})))))))
        (set! selection (collect proc selection)))
      (either (essay removed (car removed))
              false)))
  
  
  (method (selection-region sel dh dv sc)
    (let ((region (new Region)))
      (loop (for element in sel)
            (with-closed ((row-region (selection-element-region element dh dv sc)))
              (combine!~ region row-region 'or)))
      region))
  
  
  (method (selection-element-region element dh dv sc)
    (case selection-mode
      ((cell) (new Region :rect (acquire-delta dh dv sc (cell-rect element))))
      (else (selection-row-region element dh dv sc))))
    
  
  (method (selection-row-rect n)
    (let* ((row   (get-row n))
           (left  (row-text-left~ node-column row))
           (top   [v (get-position~ row)])
           (right columns-right))
      (new Rect (- left 3) top right (+ top (get-height~ row)))))
  
  
  (method (selection-row element)
    (case selection-mode
      ((cell) [row element])
      (else element)))
  
  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (cell-visible? cell)
    (and (< [row cell] visible-count)
         (< [col cell] (get-columns-count))))


  ;;;
  ;;;; Borders
  ;;;
  
  
  (method (borders-left borders)
    (car borders))
  
  
  (method (borders-right borders)
    (cdr borders))
  
  
  (method (borders-width borders)
    (- (borders-right borders) (borders-left borders)))
  
  
  (method public (get-borders col)
    (element columns-borders col))
  
  
  (method public (column-width col)
    (bind (left . right) (get-borders col)
      (- right left)))
  

  ;;;
  ;;;; Coordinates
  ;;;
  
  
  ;; temp patch to be virtual...
  (method (row-rect n)
    (let* ((row   (get-row n))
           (left  (borders-left (car columns-borders)))
           (top   [v (get-position~ row)])
           (right columns-right))
      (new Rect left top right (+ top (get-height~ row)))))
  
  
  (method public (cell-position cell)
    (let ((rect (cell-rect cell)))
      (new Point [left rect] [top rect])))

  
  (method public (cell-rect cell)
    (let* ((borders (get-borders [col cell]))
           (row (get-row [row cell]))
           (top [v (get-position~ row)]))
      (new Rect (borders-left borders) top (borders-right borders) (+ top (get-height~ row)))))
  
  
  (method public (cell-region cell)
    (new Region :rect (cell-rect cell)))
  
  
  (method (cell-content-rect cell)
    (let* ((n       [row cell])
           (col     [col cell])
           (row     (get-row n))
           (top     [v (get-position~ row)])
           (cell    (get-cell-data cell))
           (width   (column-width col))
           (borders (get-borders col))
           (left    (borders-left borders)))
      (offset-rect (content-rect~ (get-column col) row cell width (get-height~ row)) left top)))
    
  
  (method (cell-text-rect cell)
    (let* ((n     [row cell])
           (col   [col cell])
           (row   (get-row n))
           (top   [v (get-position~ row)])
           (cell  (get-cell-data cell))
           (width (column-width (get-node-column-index))))
      (offset-rect (text-rect~ (get-column col) row cell width (get-height~ row) false) 0 top)))


  (method public (view->tree pos . rest)
    (bind-keywords ((any? false) (uniform-height? false)) rest
      (let ((row (if uniform-height? (floor (/ [v pos] default-row-height)) (v->row [v pos])))
            (col (h->col [h pos])))
        (when (and row col (>= row 0))
          (let ((cell (new Cell row col)))
            (if any?
                cell
              (when (cell-visible? cell)
                cell)))))))


  ;; Should unify with view->tree...
  (method public (view->tree-extended pos)
    (let ((info (v->row-extended [v pos])))
      (when info
        (bind-values (row v height) info
          (let ((col (h->col [h pos])))
            (when (and row col (>= row 0))
              (let ((cell (new Cell row col)))
                (when (cell-visible? cell)
                  (values cell v height)))))))))


  (method public (tree->view cell)
    (new Point
      (col->h [col cell])
      (row->v [row cell])))
  

  (method public (h->col h)
    (call/ec
      (lambda (return)
        (loop (for borders in columns-borders)
              (for n from 0 below (get-columns-count))
              (bind (left . right) borders
                (when (and (>= h left) (<= h right) (/= left right))
                  (return n))))
        {})))


  (method (col->h n)
    (borders-left (get-borders n)))
  
  
  ;;;
  ;;;; Embedded Edition
  ;;;
  
  
  (method public (in-edition?)
    edited-cell)
  
  
  (method public (get-edited-cell)
    edited-cell)
  
  
  (method public (edit-cell cell . rest)
    (bind-keywords ((editor {}) (location {Point 0 0}) (draw-preserved? false) (close-editor? true) (end-proc {})) rest
      (when (< [col cell] (get-columns-count))
        (end-edition)
        (ensure-row-exists [row cell])
        ;; We need proper layout to get the cell rect...
        (when update-locked?
          (update-displayed)
          (layout-scrollee-content))
        (let ((bounds (cell-editor-rect cell)))
          (when bounds
            (let ((view (new Tree-Cell-View
                          :location (new Point (+ [left bounds] [h location]) [v location])
                          :draw-preserved? draw-preserved?
                          :preserved-data (get-cell-data cell)
                          :edition-end-proc end-proc
                          :children (list editor))))
              (replace-cell cell view)
              (set-bounds~ view (expand-rect (offset-rect bounds 0 (- [top bounds])) [h location] [v location] 0 0))
              (invalidate-rect bounds)
              (set! edited-cell cell)
              (set! cell-editor view)
              (set! close-cell-editor? close-editor?)))))))
  
  
  (method public (end-edition)
    (when edited-cell
      (let ((bounds (cell-editor-rect edited-cell))
            (end-proc (get-edition-end-proc~ cell-editor)))
        (replace-cell edited-cell (get-preserved-data~ cell-editor))
        (if close-cell-editor?
            (close~ cell-editor)
          (set-parent~ cell-editor {}))
        (let ((cell edited-cell))
          (set! edited-cell {})
          (set! cell-editor {})
          (when end-proc
            (end-proc))
          (invalidate-rect bounds)))))
  
  
  (method public (replace-cell cell child)
    (replace-child~ (get-row [row cell]) [col cell] child))
    
  
  (method (cell-editor-rect cell)
    (let* ((n       [row cell])
           (col     [col cell])
           (row     (get-row n))
           (column  (get-column col))
           (top     [v (get-position~ row)])
           (cell    (get-cell-data cell))
           (width   (if show-header? (column-width col) (get-width)))
           (borders (get-borders col))
           (left    (borders-left borders))
           (h       (text-h~ column (get-level~ row)))
           (rect    (content-rect~ column row cell width (get-height~ row))))
      (offset-rect rect left top)))
  
  
  (method public virtual (select-up cell)
    (let ((row (- [row cell] 1))
          (col [col cell]))
      (when (>= row 0)
        (end-edition)
        (select-cell (new Cell row col)))))
  
  
  (method public virtual (select-down cell . rest)
    (bind-optionals ((validate? true)) rest
      (let ((row (+ [row cell] 1))
            (col [col cell]))
        (when (or (not validate?) (< row (get-visible-count)))
          (end-edition)
          (select-cell (new Cell row col))))))
    
  
  (method public virtual (select-left cell)
    (let ((row [row cell])
          (col (- [col cell] 1)))
      (when (>= col 0)
        (end-edition)
        (select-cell (new Cell row col)))))

  
  (method public virtual (select-right cell)
    (let ((row [row cell])
          (col (+ [col cell] 1)))
      (when (< col (get-columns-count))
        (end-edition)
        (select-cell (new Cell row col)))))
  
  
  (method public virtual (select-cell cell)
    (set-single-selection [row cell]))


  ;;;
  ;;;; Designer
  ;;;
  
  
  @convert-descriptor
  (method meta (get-class-image)
    {Bitmap-Resource "Preferences"})

  
  @convert
  (method meta (property-presentation property)
    (case (field-name property)
      ((portfolio)                 "Portfolio")
      ((show-header?)              "Show Header")
      ((selection-mode)            "Selection Mode")
      ((multiple-selection?)       "Multiple Selection")
      ((can-select-empty?)         "Can Select Empty")
      ((show-unfocused-selection?) "Show Unfocused Selection")
      ((auto-expand/collapse?)     "Auto Expand/Collapse")
      ((cell-background)           "Cell Background")
      ((filled-column)             "Filled Column")
      ((column-spacing)            "Column Spacing")
      ((reorderable?)              "Reorderable")
      (else (nextmethod property))))

  
  (method (get-row-instance property)
    (case (field-name property)
      ((show-header? multiple-selection? can-select-empty? show-unfocused-selection? auto-expand/collapse? reorderable?) (new Boolean-Row))
      (else (nextmethod property))))

  
  ;;;
  ;;;; Debugging
  ;;;

  
  @convert
  (method (debug-view view)
    (nextmethod view)
    (let ((cell (view->tree view)))
      (when cell
        (let* ((pos (cell-coordinates cell view))
               (column (get-column [col cell]))
               (row (get-row [row cell]))
               (node (car (get-children~ row)))
               (user-data (get-user-data~ row)))
          (bind-values (cell part) (get-debugged~ column cell pos)
            (let ((data (get-cell-data cell)))
              (set! [%c Development] cell)
              (set! [%d Development] data)
              (set! [%n Development] node)
              (set! [%o Development] column)
              (set! [%p Development] part)
              (set! [%r Development] row)
              (set! [%u Development] user-data)))))))


  @convert
  (method (describe-view view)
    (append (nextmethod view)
            (let ((cell (view->tree view)))
              (when cell
                (let* ((pos (cell-coordinates cell view))
                       (column (get-column [col cell]))
                       (row (get-row [row cell]))
                       (node (car (get-children~ row)))
                       (user-data (get-user-data~ row)))
                  (bind-values (cell part) (get-debugged~ column cell pos)
                    (let ((data (get-cell-data cell)))
                      (list
                       (list "Node Column" node-column)
                       (list "Columns Borders" columns-borders)
                       (list "Columns Right" columns-right)
                       (list "User Data" user-data)
                       (list "Image" (get-image~ node)))))))))))


;;;
;;;; Locator
;;;


(class Tree-Locator extends Locator)


@convert


(class Tree-Locator extends Locator
  
  
  (slot column initialize {})
  
  
  (method (iterate proc)
    (bind (row . proc2) (prepare-iterate)
      (for-each-visible-row
        (function dynamic (row rank)
          (let* ((node (proc2 row))
                 (title (get-title~ node)))
            (proc title rank)))
        start: (when row (if prefix row [next row]))
        :wrap? true)))
  
  
  (method (select rank)
    (case selection-mode
      ((cell) (set-single-selection (new Cell rank column)))
      (else (set-single-selection rank))))
  
  
  (method (prepare-iterate)
    (let ((sel (get-single-selection)))
      (case selection-mode
        ((cell)
         (set! column (if sel [col sel] 0))
         (cons (essay sel (get-row [row sel]))
               (function dynamic (row) (element (get-children~ row) column))))
        (else
         (cons (essay sel (get-row sel))
               (function dynamic (row) (car (get-children~ row))))))))))
