;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Drawable Figures
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.view.Drawing jazz


(import (jazz.utilities)
        (jazz.ui)
        (jazz.library)
        (jazz.literals))


;;;
;;;; Offscreen
;;;


(definition offscreen
  {})


(definition (get-offscreen dc <Surface> width <fx> height <fx>)
  (if (and offscreen
           (let ((size (get-size~ offscreen)))
             (and (<= width (get-width~ size))
                  (<= height (get-height~ size)))))
      (begin
        (new-context~ offscreen)
        offscreen)
    (when offscreen
      (close~ offscreen))
    (set! offscreen (new-offscreen dc width height))
    offscreen))


(definition (new-offscreen dc <Surface> width <fx> height <fx>)
  (new Cairo-Memory-Surface dc size: (new Dimension width height)))


(class Drawing-Class extends Figure-Class


  ;;;
  ;;;; Effect
  ;;;
  
  
  (definition effect-offscreen
    {})
  
  
  (method public (get-effect-offscreen dc <Surface> width <fx> height <fx>)
    (if (and effect-offscreen
             (let ((size (get-size~ effect-offscreen)))
               (and (<= width (get-width~ size))
                    (<= height (get-height~ size)))))
        effect-offscreen
      (when effect-offscreen
        (close~ effect-offscreen))
      (set! effect-offscreen (new-offscreen dc width height))))


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (property-presentation property)
    (case (field-name property)
      ((offscreen?) "Offscreen")
      ((effect) "Effect")
      (else (nextmethod property)))))


(class Drawing metaclass Drawing-Class extends Figure
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method public virtual (get-player)
    (essay parent (get-player~ parent)))

  
  ;;;
  ;;;; Lie
  ;;;
  
  
  (method public (get-lie)
    (receive (h <fl> v <fl> sc) (get-lie-parent 0.0 0.0 1.0)
      (new Point (round h) (round v))))
  
  
  (method protected virtual (get-lie-parent h <fl> v <fl> sc <fl>)
    (if (not parent)
        (values h v sc)
      (get-lie-parent~ parent (+ (get-h~ position) h) (+ (get-v~ position) v) sc)))
  
  
  (method public (set-lie lie <Point>)
    (with ((actual (get-lie))
           (delta (- lie actual))
           (pos (+ position delta)))
      (set-position pos)))

  
  ;;;
  ;;;; Root
  ;;;
  
  
  (method public (get-root)
    (let ((player (get-player)))
      (if player
          (get-root~ player)
        (if (is? self Root-View)
            self
          (essay parent (get-root~ parent))))))

  
  ;;;
  ;;;; Coordinates
  ;;;


  (method public (acquire origin shape)
    (receive (dh dv sc) (get-delta origin)
      (acquire-delta dh dv sc shape)))


  (method public (acquire-delta dh <fl> dv <fl> sc <fl> shape)
    (typecase shape
      ((Point)
       (let ((h <fx> (get-h~ shape))
             (v <fx> (get-v~ shape)))
         (new Point (round (+ dh (* h sc)))
                    (round (+ dv (* v sc))))))
      ((Rect)
       (let ((left <fx> (get-left~ shape))
             (top <fx> (get-top~ shape))
             (right <fx> (get-right~ shape))
             (bottom <fx> (get-bottom~ shape)))
         (new Rect (round (+ dh (* left sc)))
                   (round (+ dv (* top sc)))
                   (round (+ dh (* right sc)))
                   (round (+ dv (* bottom sc))))))
      (else
       (error "Unable to acquire {t}" shape))))
  
  
  (method protected virtual (get-delta origin)
    (receive (origin-h <fl> origin-v <fl> origin-sc <fl>) (get-lie-parent~ origin 0.0 0.0 1.0)
      (receive (dh <fl> dv <fl> sc <fl>) (get-lie-parent 0.0 0.0 1.0)
        (values (/ (- origin-h dh) sc) (/ (- origin-v dv) sc) (/ origin-sc sc)))))

  
  ;;;
  ;;;; Size
  ;;;


  (method (get-size)
    size)
  

  (method (set-size sz <Dimension>)
    (when (/= sz size)
      (set! size sz)
      (invalidate-layout)
      (when (get-finished?)
        (call-layout))))
  

  (method public (get-width)
    (get-width~ size))
  
  
  (method public (set-width width <fx>)
    (set-size (new Dimension width (get-height))))


  (method public (get-height) <fx>
    (get-height~ size))
  
  
  (method public (set-height height <fx>)
    (set-size (new Dimension (get-width) height)))
  
  
  (method public (get-left)
    (get-h~ position))
  
  
  (method public (get-top)
    (get-v~ position))
  
  
  (method public (get-right)
    (+ (get-h~ position) (get-width~ size)))
  
  
  (method public (get-bottom)
    (+ (get-v~ position) (get-height~ size)))

  
  (method public (get-bounds)
    (size-rect (get-size)))
  
  
  (method public (set-bounds bounds <Rect>)
    (set-position (rect-position bounds))
    (set-size (rect-size bounds)))
  
  
  (method public (get-rect)
    (position/size->rect (get-position) (get-size)))
  
  
  (method public (set-rect rect <Rect>)
    (set-position (rect-position rect))
    (set-size (rect-size rect)))

  
  ;;;
  ;;;; Flags
  ;;;
  
  
  (method (get-layout-valid?)
    (mask-bit-set? flags Layout-Valid-Flag))
  
  
  (method (set-layout-valid? flag <bool>)
    (set! flags (mask-bit-set flags Layout-Valid-Flag flag)))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method public virtual (get-scaled?)
    false)


  (method public virtual (set-scaled? value)
    )
  

  (method public virtual (get-scaling)
    1.0)


  (method public virtual (set-scaling value)
    )


  (method public (logical->device shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function dynamic (lh <fx>) (round (+ (* (- lh sh) sc) sh))))
                (vert (function dynamic (lv <fx>) (round (+ (* (- lv sv) sc) sv)))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))


  (method public (device->logical shape (orientation: orientation {}) (info: info {}))
    (let ((info (either info (scaling-info))))
      (if (not info)
          shape
        (receive (sh <fx> sv <fx> sc <fl>) info
          (let ((horz (function dynamic (dh <fx>) (+ (quotient (- dh sh) sc) sh)))
                (vert (function dynamic (dv <fx>) (+ (quotient (- dv sv) sc) sv))))
            (typecase shape
              ((Point) (new Point (horz (get-h~ shape)) (vert (get-v~ shape))))
              ((Dimension) (new Dimension (horz (get-width~ shape)) (vert (get-height~ shape))))
              ((Rect) (new Rect (horz (get-left~ shape)) (vert (get-top~ shape)) (horz (get-right~ shape)) (vert (get-bottom~ shape))))
              ((Number) (case orientation
                          ((horz) (horz shape))
                          ((vert) (vert shape))
                          (else (error "Unknown orientation: {t}" orientation))))
              (else (error "Unable to translate {t}" shape))))))))
  
  
  ;; Maybe this method should be optimized out by setting
  ;; scaling info in every child of the scaled drawing...
  (method (scaling-info)
    (let ((drawing self)
           (sh <fx> 0)
           (sv <fx> 0))
      (call/ec
        (lambda (return)
          (while drawing
            (let ((sc? (get-scaled?~ drawing))
                  (sc (get-scaling~ drawing)))
              (if sc?
                  (return (values sh sv sc))
                (let ((pos (get-position~ drawing)))
                  (decrease! sh (get-h~ pos))
                  (decrease! sv (get-v~ pos)))
                (set! drawing (get-parent~ drawing)))))
          {}))))

  
  ;;;
  ;;;; Visibility
  ;;;
  
  
  (method public (fully-visible?)
    (and (get-visible?) (or (not parent) (fully-visible?~ parent))))

  
  ;;;
  ;;;; Transparency
  ;;;

  
  (method public virtual (get-transparent?)
    false)
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method protected (invalidate-layout)
    (set-layout-valid? false))
  
  
  (method protected (call-layout)
    (unless (get-layout-valid?)
      (layout)
      (set-layout-valid? true)))
  
  
  (method public (layout-drawing)
    ;; No need to layout if the drawing is not initialized, because
    ;; conclude will call layout once the initialization process is done.
    (when (get-finished?)
      (invalidate-layout)
      (call-layout)))
  
  
  (method public virtual (layout)
    )

  
  ;;;
  ;;;; Iterate
  ;;;
  
  
  (method public (for-each-drawing proc <procedure> (include-invisibles?: include-invisibles? false))
    (loop (for child in children)
          (when (and (is? child View)
                     (or include-invisibles? (get-visible?~ child)))
            (proc child))))
  
  
  (method public (for-each-drawing-reversed proc <procedure> (include-invisibles?: include-invisibles? false))
    (with ((proc
             (function dynamic (child)
               (when (and (is? child View)
                          (or include-invisibles? (get-visible?~ child)))
                 (proc child)))))
      (for-each-reversed proc children)))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-drawing pos <Point>)
    (when (in-drawing? pos size)
      (either (find-subdrawing pos)
              (unless (get-transparent?)
                self))))
  
  
  (method protected virtual (in-drawing? pos <Point> size <Dimension>)
    (in-size? pos size))
  
  
  (method protected virtual (find-subdrawing pos <Point>)
    (call/ec
      (lambda (return)
        (with ((proc <procedure>
                 (function dynamic (view)
                   (with ((delta <Point> (- pos (get-position~ view))))
                     (let* ((scaled? (get-scaled?~ view))
                            (found (if (not scaled?)
                                       (find-drawing~ view delta)
                                     (let ((scaling <fl> (get-scaling~ view)))
                                       (with ((scaled (new Point
                                                        (round (/ (get-h~ delta) scaling))
                                                        (round (/ (get-v~ delta) scaling)))))
                                         (find-drawing~ view scaled))))))
                       (when found
                         (return found)))))))
          (for-each-drawing-reversed proc))
        {})))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-drawing)
    (with ((rect (get-rect)))
      (invalidate-rect~ parent rect)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  ;; I think that keeping the update region makes the code complex for not much (and it doesn't work
  ;; with scaling). Why not always get the bounding box and pass it around. Drawing methods would then
  ;; always have an update rect available for consultation...
  
  ;; debug
  (method public (paint dc <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (when (get-visible?)
      ;; beurk code for testing
      (if (or (get-scaled?) sc?)
          (with ((rect (h/v/size->rect lh lv size)))
            ;; quick patch for the time being
            (when true @w (rect-intersects-region? (get-left~ scaled) (get-top~ scaled) (rect-size scaled) update)
              (paint-displayed dc context update lh lv sh sv sc sc?)))
        (when (cond ((not update) true)
                    ((is? update Rect) (with ((lie (new Point lh lv))) (rects-intersect? update lie size)))
                    (else (rect-intersects-region? lh lv size update)))
          (paint-displayed dc context update lh lv sh sv sc sc?)))))


  (method public (paint-displayed dc <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (if (not (get-offscreen?))
        (paint-drawing dc context update lh lv sh sv sc sc?)
      (let ((offscreen (get-offscreen dc (get-width~ size) (get-height~ size))))
        (with ((origin (new Point 0 0))
               (clipper (get-bounds)))
          (setup-clipper~ offscreen clipper)
          (paint-drawing offscreen context update lh lv sh sv sc sc?)
          ;; the next lines are in case an error occurs in the paint process
          ;; so that on the next pass at least these values will be reset...
          @JLR-Check-What-This-Does
          (if (not Cairo?)
              (begin
                (SetWindowOrgEx offhdc 0 0 NULL)
                (SetViewportOrgEx offhdc 0 0 NULL)
                (SetMapMode offhdc MM_TEXT)
                (let ((overlay (get-overlay)))
                  (when overlay
                    (draw-overlay~ overlay self offscreen (get-width~ size) (get-height~ size))))))
          (let ((effect (get-effect)))
            (bit-blit~ offscreen dc size: size)
            @not-converted-to-cairo
            (if (not effect)
              (with ((lie (new Point lh lv)))
                (animate~ effect offscreen dc lie size))
              (set-effect {})))))))

  
  (method public (paint-drawing dc <Surface> context <Object> update <Object> lh <fx> lv <fx> sh <fx> sv <fx> sc <fl> sc? <bool>)
    (let* ((scaled? (get-scaled?))
           (scaling (get-scaling))
           (new-sh (if (not scaled?) sh lh))
           (new-sv (if (not scaled?) sv lv))
           (new-sc (if (not scaled?) sc scaling))
           (new-sc? (if (not scaled?) sc? true)))
      (with-transform~ dc self lh lv (get-width~ size) (get-height~ size) new-sh new-sv new-sc new-sc?
        (function dynamic ()
          (render dc context update lh lv new-sh new-sv new-sc new-sc?)))))

  
  (method public virtual (render dc <Surface> context update lh lv sh sv sc sc?)
    (draw-background dc context)
    (draw-content dc context update lh lv sh sv sc sc?)
    ;(draw-placeholder dc)
    (draw-children dc context update lh lv sh sv sc sc?))

  
  (method public virtual (draw-background dc <Surface> context)
    )
  
  
  (method public virtual (draw-content dc <Surface> context update lh lv sh sv sc sc?)
    (draw dc context update lh lv))
    
  
  (method public virtual (draw dc <Surface> context update lh lv)
    )
  
  
  (definition *colors*
    '({Color name: Dark-Red}
      {Color name: Dark-Orange}
      {Color name: Dark-Yellow}
      {Color name: Dark-Green}
      {Color name: Dark-Blue}
      {Color name: Dark-Purple}))
  
  (definition *nb-colors*
    (length *colors*))
  
  (definition *current-color*
    0)
  

  (method (draw-placeholder dc)
    (set-color~ dc {Color name: White})
    (paint~ dc)
    (fill-rect~ dc (get-bounds) (element *colors* *current-color*))
    (set! *current-color* (modulo (+ *current-color* 1) *nb-colors*)))
  
  
  (method public virtual (draw-children dc <Surface> context update lh <fx> lv <fx> sh sv sc sc?)
    (with ((proc <procedure>
            (function dynamic (drawing)
              (let ((pos (get-position~ drawing)))
                (paint~ drawing dc context update (+ lh (get-h~ pos)) (+ lv (get-v~ pos)) sh sv sc sc?)))))
      (for-each-drawing proc)))
  
  
  (method protected (get-update-rect dc <Surface> update lh lv)
    (cond ((not update) (get-bounds))
          ((is? update Rect) (device->logical~ dc update))
          (else
           (with ((box (get-box~ update))
                  (logical (device->logical~ dc box))
                  (bounds (get-bounds)))
             (rect-intersection logical bounds)))))


  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method public (get-view-clipper)
    (get-translated-clipper 0 0))
  
  
  (method protected virtual (get-translated-clipper h v)
    (with ((b (get-bounds))
           (r (offset-rect b (round h) (round v))))
      (if (not parent)
          (copy r)
        (with ((p (get-translated-clipper~ parent (- h (get-h~ position)) (- v (get-v~ position)))))
          (rect-intersection p r)))))
  
  
  (method public virtual (get-offscreen?)
    false)
  
  
  (method public virtual (set-offscreen? flag <bool>)
    )


  ;;;
  ;;;; Overlay
  ;;;
  
  
  (method public virtual (get-overlay)
    {})
  
  
  (method public virtual (set-overlay value)
    )
  
  
  (method public virtual (get-effect)
    {})
  
  
  (method public virtual (set-effect value)
    )))
