;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Window
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.window.Window jazz


(import (jazz.library)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.utilities)
        (jazz.platform)
        (jazz.platform.windows)
        (jazz.platform.cairo.cairo-win32)
        (jazz.literals))


;;;
;;;; Orphanage
;;;


(definition Orphanage
  {})


(definition public (get-orphanage)
  (unless Orphanage
    (set! Orphanage (new Orphanage-Window)))
  Orphanage)


(class Window-Class extends Figure-Class
  
  
  (definition registered?
    false)
  
  
  (method (initialize)
    (nextmethod)
    (unless registered?
      (register-class)
      (set! registered? true)))
  
  
  @convert
  (method protected virtual (window-class)
    "JWindow")


  @convert
  (method protected virtual (class-style)
    (bit-or CS_OWNDC CS_DBLCLKS))


  @convert
  (method protected virtual (class-background)
    COLOR_BTNFACE)
  

  (method public (register-class (class: class (window-class)) (icon: icon {}))
    @wait
    (let ((instance (current-instance))
          (background (class-background))
          (wc (make-WNDCLASS)))
      (WNDCLASS-style-set! wc          (class-style))
      (WNDCLASS-lpfnWndProc-set! wc    call-process-handle-message)
      (WNDCLASS-cbClsExtra-set! wc     0)
      (WNDCLASS-cbWndExtra-set! wc     0)
      (WNDCLASS-hInstance-set! wc      instance)
      (WNDCLASS-hIcon-set! wc          NULL) ;; specific windows (if icon (load-image~ Image 'icon icon width: 16 height: 16) NULL)
      (WNDCLASS-hCursor-set! wc        NULL)
      ;; To-Fix Remettre le handle brush
      (WNDCLASS-hbrBackground-set! wc  background)
      (WNDCLASS-lpszMenuName-set! wc   NULL)
      (WNDCLASS-lpszClassName-set! wc  "JWindow" @w class)
      (set! CLASS_ATOM (RegisterClass wc)))))


(class Window metaclass Window-Class extends Figure @w implements @w Message-Consumer
 

  (property title         initialize {} getter get-title setter set-title)
  (property surface-class initialize {} accessors generate)
  

  (slot handle           initialize {})
  (slot previous-size    initialize {})
  (slot subclassed-proc  initialize {})
  (slot message-consumer initialize {})


  ;;;
  ;;;; Initialization
  ;;;
  
  
  (slot handle-class initialize {})
  
  
  (method (initialize . rest)
    (bind-keywords ((window-class {}) . others) rest
      (if (not (primary-thread?))
          (error "Unable to create window outside the primary thread")
        (set! handle-class window-class)
        (set! message-consumer self)
        (apply nextmethod others))))


  (method (initially-visible?)
    false)
  
  
  (method (setup-handle handle)
    (set-window handle self)
    (set-handle handle))


  (method (default-parent)
    (get-orphanage))


  (method (prepare rest)
    (nextmethod rest)
    (setup-handle (prepare-handle self parent rest)))
  
  
  (method (conclude rest)
    (nextmethod rest)
    (size-change (get-size)))
  
  
  (method public (open?)
    (boolean handle))


  (method (show)
    (nextmethod)
    (show-window handle))


  (method (hide)
    (nextmethod)
    (when handle
      (hide-window handle)))
  
  
  (method public (minimize)
    (minimize-window handle))


  (method (close)
    (destroy-window handle))

  
  (method (print printer readably)
    (print-unreadable self printer
      (function dynamic (printer)
        (if (not handle)
            (format printer "orphaned")
          (let ((position (get-position))
                (size (get-size)))
            (if (or (not title) (empty-string? title))
                (format printer "{a} {a}" position size)
              (format printer "{a} {a} {a}" title position size)))))))
  
  
  ;;;
  ;;;; Component
  ;;;


  (method (add-child child)
    (set! children (cons child children)))
  
  
  (method (add-form parent-form child-form)
    (add-child~ parent-form child-form))


  ;;;
  ;;;; Dispatch
  ;;;


  (method public (call-dispatch-message msg <fx> wparam <fx> lparam <fx>)
    (dispatch-message message-consumer msg wparam lparam))
  

  (method public (get-message-consumer)
    message-consumer)
  
  
  (method public (set-message-consumer consumer <Object>)
    (set! message-consumer consumer))


  ;;;
  ;;;; Paint
  ;;;


  (method protected virtual (erase-background hdc)
    (if (not (class-background))
        processed
      unprocessed))
  

  (method protected virtual (paint)
    (paint-window))
  
  
  (method protected (paint-window)
    (with ((ps (PAINTSTRUCT-make)))
      (let ((hdc (BeginPaint handle ps)))
        (with ((dc (new Cairo-Win32-Surface (cairo_win32_surface_create hdc))))
          ;;(draw-placeholder dc)
          (draw dc ps)
          (close~ dc)
          (EndPaint handle ps))))
    processed)
  
  
  (definition *colors*
    '({Color name: Dark-Red}
      {Color name: Dark-Orange}
      {Color name: Dark-Yellow}
      {Color name: Dark-Green}
      {Color name: Dark-Blue}
      {Color name: Dark-Purple}))
  
  (definition *nb-colors*
    (length *colors*))
  
  (definition *current-color*
    0)
  

  (method (draw-placeholder dc)
    (set-color~ dc {Color name: White})
    (paint~ dc)
    (fill-rect~ dc (get-bounds) (element *colors* *current-color*))
    (set! *current-color* (modulo (+ *current-color* 1) *nb-colors*)))
  

  (method protected virtual (draw dc ps)
    )


  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method protected virtual (mouse-hover h v)
    unprocessed)
  
  
  (method protected virtual (mouse-wheel delta)
    unprocessed)

  
  (method protected virtual (mouse-down h v)
    unprocessed)
  
  
  (method protected virtual (mouse-move h v)
    unprocessed)
  
  
  (method protected virtual (mouse-up h v)
    unprocessed)
  
  
  (method protected virtual (double-click h v)
    (mouse-down h v))
  
  
  (method protected virtual (middle-mouse-down h v)
    unprocessed)
  
  
  (method protected virtual (middle-mouse-up h v)
    unprocessed)
  
  
  (method protected virtual (right-mouse-down h v)
    unprocessed)
  
  
  (method protected virtual (right-mouse-up h v)
    unprocessed)
  
  
  ;; tofix : window-specific
  (method (call-context-menu h v)
    (let ((pos (acquire (get-desktop) (new Point h v))))
      (context-menu (get-h~ pos) (get-v~ pos))))
  
  
  (method protected virtual (context-menu h v)
    unprocessed)


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method (call-lost-capture handle)
    unprocessed)


  (method public virtual (on-lost-capture evt)
    unprocessed)
  
  
  (method public (acquire-capture)
    (set-capture handle))
  
  
  (method public (release-capture)
    (unset-capture))


  ;;;
  ;;;; Cursor
  ;;;

  
  (method protected virtual (cursor-update hit)
    (if hit
        processed
      unprocessed))


  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method (system-key-down wparam)
    (if (/= wparam VK_MENU)
        unprocessed
      (view-update-cursor)
      processed))
  
  
  (method (system-key-up wparam)
    (if (/= wparam VK_MENU)
        unprocessed
      (view-update-cursor)
      processed))
  
  
  (method (modifier-changed wparam)
    (when (memq? wparam '(16 17))
      (view-update-cursor)))
  
  
  (method (call-key-down wparam)
    (modifier-changed wparam)
    (key-down (integer->char wparam)))
  
  
  (method (call-key-up wparam)
    (modifier-changed wparam)
    (key-up (integer->char wparam)))
  
  
  (method (call-key-press wparam)
    (key-press (integer->char wparam)))


  (method public virtual (key-down char)
    unprocessed)


  (method public virtual (key-up char)
    unprocessed)


  (method public virtual (key-press char)
    unprocessed)


  ;;;
  ;;;; Handlers
  ;;;
  
  
  (method public (call-position-change h v)
    (position-change (new Point h v)))
  
  
  (method protected virtual (position-change position)
    unprocessed)


  (method public (call-size-change type width height)
    ;; Windows sends a size message with both the width
    ;; and the height equal to zero when minimizing a window...
    (when (or (/= width 0) (/= height 0))
      (when (get-installed?)
        (let ((size (new Dimension width height)))
          (size-change size)
          (set! previous-size size)))))


  (method protected virtual (size-change size)
    unprocessed)


  (method protected virtual (on-command lparam wparam)
    (if (= lparam 0)
        (let ((action-item/shortcut (get-id-cookie (loword wparam))))
          (if (not action-item/shortcut)
              unprocessed
            (if (is? action-item/shortcut Shortcut)
                (dispatch-shortcut~ (get-application) action-item/shortcut)
              (invoke~ action-item/shortcut self {})
              processed)))
      (let ((object (get-window lparam)))
        (if (not object)
            unprocessed
          (process-action~ object self)
          processed))))


  (method protected virtual (on-system-command type)
    unprocessed)


  (method protected virtual (on-mouse-activate)
    unprocessed)


  ;; when a toplevel window (including palettes) is activated or deactivated
  (method protected virtual (on-activate kind)
    (if (= kind WA_INACTIVE)
        (on-deactivate-palette)
      (on-activate-palette))
    unprocessed)

  
  (method protected virtual (on-activate-palette)
    )
  
  
  (method protected virtual (on-deactivate-palette)
    )


  ;; Called when a toplevel window (including palettes)
  ;; is activated or deactivated by a change of the active application
  (method protected virtual (on-activate-app status)
    unprocessed)


  (method protected virtual (on-close evt)
    unprocessed)


  (method (window-destroy)
    (destroy-component)
    unprocessed)


  (method (on-nc-destroy evt)
    (set-window handle {})
    (set-handle NULL)
    unprocessed)


  (method (call-focus-gain)
    (focus-gain))


  (method protected virtual (call-focus-lose wparam)
    (focus-lose (get-window wparam)))


  (method protected virtual (focus-gain)
    unprocessed)


  (method protected virtual (focus-lose receiving)
    unprocessed)
  
  
  ;;;
  ;;;; Drop Files
  ;;;
  
  
  (method (drop-files wparam)
    (unimplemented 'drop-files)
    @get-toplevel-handle
    (let ((files (received-files wparam))
          (pt (POINT-make)))
      (DragQueryPoint wparam pt)
      (DragFinish wparam)
      (let ((pos (POINT->point pt)))
        (receive-files pos files))
      (SetForegroundWindow (get-toplevel-handle))))
  
  
  (method (received-files wparam)
    (unimplemented 'received-files)
    @adjust-string
    (let ((count (DragQueryFile wparam -1 NULL 0)))
      (map (function dynamic (n)
             (let* ((size MAX_PATH)
                    (filename (WCHAR-array-make size)))
               (WCHAR-array-set! filename 0 #\nul)
               (let ((filename (WCHAR-string filename)))
                 (DragQueryFile wparam n filename size)
                 (adjust-string filename)
                 (let* ((attributes (GetFileAttributes filename))
                        (directory? (mask-bit-set? attributes FILE_ATTRIBUTE_DIRECTORY))
                        (pathname (new (if directory? Directory File) (tokenise filename))))
                   (anchorize~ pathname))))
             (naturals 0 count)))))
  
  
  (method protected virtual (receive-files pos files)
    )
  
  
  ;;;
  ;;;; Settings
  ;;;
  
  
  (method protected virtual (setting-change wparam)
    )
  
  
  ;;;
  ;;;; Timers
  ;;;
  
  
  (method (on-timer serial-number)
    (let ((object (serial-number->object serial-number)))
      (call-pulse~ object)))


  ;;;
  ;;;; Style
  ;;;


  (method (get-style)
    (GetWindowLong handle GWL_STYLE))


  (method (set-style style)
    (SetWindowLong handle GWL_STYLE style))


  (method (get-ex-style)
    (GetWindowLong handle GWL_EXSTYLE))


  (method (set-ex-style style)
    (SetWindowLong handle GWL_EXSTYLE style))
  
  
  (method (child-window?)
    (mask-bit-set? (get-style) WS_CHILD))


  ;;;
  ;;;; Layers
  ;;;
  
  
  (method public (get-layered?)
    (mask-bit-set? (get-ex-style) WS_EX_LAYERED))
  
  
  (method public (set-layered? flag)
    (SetWindowLong handle GWL_EXSTYLE (mask-bit-set (GetWindowLong handle GWL_EXSTYLE) WS_EX_LAYERED flag)))
  
  
  (method public (set-alpha-blending n)
    (set-layered? true)
    (SetLayeredWindowAttributes handle 0 n LWA_ALPHA)
    (RedrawWindow handle NULL NULL (bit-or RDW_ERASE RDW_INVALIDATE)))
  
  
  (method public (fade-in (fade-speed: fade-speed {}))
    (set-alpha-blending 0)
    (set-visible? true)
    (update-window)
    (let* ((max 255)
           (delay (* (clocks/second) 0.15))
           (now (clock))
           (start now))
      (while (< now (+ start delay))
        (set-alpha-blending (ceil (* (- now start) (/ max delay))))
        (set! now (clock)))
      (set-alpha-blending max))
    (set-layered? false))
  
  
  (method public (fade-out (to: to 0) (step: step 5))
    @need-to-get-layered-attributes
    (let ((alpha))
      (loop (for n from 0 to to by step)
            (set-alpha-blending n)
            (set! alpha n))
      (unless (= alpha to)
        (set-alpha-blending to))))


  ;;;
  ;;;; Hosting
  ;;;
  
  
  (method public (find-host guest-type)
    (with ((proc <procedure>
            (function dynamic (window)
              (and (is? window View-Host)
                   (is? (get-guest~ window) guest-type)))))
      (find-if proc children)))
  
  
  (method public (find-guest guest-type)
    (let ((host (find-host guest-type)))
      (when host
        (get-guest~ host))))
  
  
  (method public (collect-guest guest-type)
    (collect (function dynamic (window)
               (when (is? window View-Host)
                 (let ((guest (get-guest~ window)))
                   (when (is? guest guest-type)
                     guest))))
             children))


  ;;;
  ;;;; Tracking
  ;;;
  
  
  (method public (track-mouse-event flags (time: time HOVER_DEFAULT))
    (with ((rec (TRACKMOUSEEVENT-make)))
      (TRACKMOUSEEVENT-cbSize-set! rec (size-of-TRACKMOUSEEVENT))
      (TRACKMOUSEEVENT-dwFlags-set! rec flags)
      (TRACKMOUSEEVENT-hwndTrack-set! rec handle)
      (TRACKMOUSEEVENT-dwHoverTime-set! rec time)
      (TrackMouseEvent rec)))


  ;;;
  ;;;; Management
  ;;;


  (method public (send-message msg wparam lparam)
    (SendMessage handle msg wparam lparam))


  (method public (post-message msg wparam lparam)
    (PostMessage handle msg wparam lparam))


  (method public (get-handle)
    handle)


  (method public (set-handle hw <int>)
    (set! handle hw))


  (method public (set-parent parent)
    (nextmethod parent)
    (SetParent handle (if parent (get-handle~ parent) NULL)))


  (method (get-frame)
    (if (is? self Frame)
        self
      (when parent
        (get-frame~ parent))))
  
  
  (method public (get-overlapped)
    (if (is? self Overlapped)
        self
      (get-overlapped~ parent)))
  
  
  (method public (get-window-owner)
    (get-window (GetWindow handle GW_OWNER)))
  
  
  (method public (get-root-owner)
    (let ((root (get-window-owner)))
      (when root
        (let ((done? false))
          (while (not done?)
            (let ((owner (get-window-owner~ root)))
              (if (not owner)
                  (set! done? true)
                (set! root owner))))
          root))))
  
  
  (method public (get-top-window)
    (get-window (GetTopWindow handle)))
  

  (method public virtual (get-title)
    title)
  

  (method public virtual (set-title value)
    (set! title value)
    (set-window-title (localize title)))
  

  (method public (get-window-title)
    (get-hwnd-title handle))
  

  (method public (set-window-title title)
    (SetWindowText handle title))
  

  (method public (acquire window shape)
    (typecase shape
      ((Point)
        (with ((acquired (point->POINT shape)))
          (MapWindowPoints (get-handle~ window) handle acquired 1)
          (POINT->point acquired)))
      ((Rect)
        (with ((acquired (rect->RECT shape)))
          (MapWindowPoints (get-handle~ window) handle (RECT->POINTS acquired) 2)
          (RECT->rect acquired)))
      (else
        (error "Unable to translate {t}" shape))))


  (method (get-position)
    (with ((rect (RECT-make)))
      (GetWindowRect handle rect)
      (when (and parent (child-window?))
        (MapWindowPoints NULL (get-handle~ parent) (RECT->POINTS rect) 2))
      (new Point (RECT-left-ref rect) (RECT-top-ref rect))))
  
  
  (method public (get-window-position)
    (with ((pos (new-point 0 0)))
      (MapWindowPoints handle NULL pos 1)
      (new Point (POINT-x-ref pos) (POINT-y-ref pos))))
  

  (method (set-position pos)
    (SetWindowPos handle NULL (get-h~ pos) (get-v~ pos) 0 0 (bit-or SWP_NOSIZE SWP_NOZORDER SWP_NOACTIVATE)))


  (method public (move-window dh dv)
    (let ((pos (get-position)))
      (set-position (new Point (+ (get-h~ pos) dh) (+ (get-v~ pos) dv)))))


  (method (get-size)
    (with ((rect (RECT-make)))
      (GetClientRect handle rect)
      (new Dimension (RECT-right-ref rect) (RECT-bottom-ref rect))))


  (method (set-size size)
    (let ((delta (- size (get-size))))
      (set-window-size (+ (get-window-size) delta))))


  (method public (size-window dwidth dheight)
    (let ((size (get-size)))
      (set-size (new Dimension (+ (get-width~ size) dwidth) (+ (get-height~ size) dheight)))))


  (method public (get-window-size)
    (let ((rect (RECT-make)))
      (GetWindowRect handle rect)
      (new Dimension (- (RECT-right-ref rect)  (RECT-left-ref rect))
                     (- (RECT-bottom-ref rect) (RECT-top-ref rect)))))


  (method public (set-window-size size)
    (SetWindowPos handle NULL 0 0 (get-width~ size) (get-height~ size) (bit-or SWP_NOCOPYBITS SWP_NOMOVE SWP_NOZORDER SWP_NOACTIVATE)))
  
  
  (method public (set-bounds rect)
    (SetWindowPos handle NULL (get-left~ rect) (get-top~ rect) (rect-width rect) (rect-height rect) (bit-or SWP_NOZORDER SWP_NOACTIVATE)))
  
  
  (method public (grow-bounds dh dv dwidth dheight)
    (let ((pos (+ (get-position) (new Point dh dv)))
          (size (+ (get-window-size) (new Dimension dwidth dheight))))
      (set-window-size size)
      (set-position pos)))


  (method public (get-width)
    (get-width~ (get-size)))

  
  (method public (get-height)
    (get-height~ (get-size)))
  

  (method public (get-rect)
    (with ((rect (RECT-make)))
      (GetWindowRect handle rect)
      (when parent
        (MapWindowPoints NULL (get-handle~ parent) (RECT->POINTS rect) 2))
      (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))))
  

  (method public (get-bounds)
    (with ((rect (RECT-make)))
      (GetWindowRect handle rect)
      (MapWindowPoints NULL handle (RECT->POINTS rect) 2)
      (new Rect (RECT-left-ref rect) (RECT-top-ref rect) (RECT-right-ref rect) (RECT-bottom-ref rect))))
  
  
  (method public (ensure-displayed)
    (let ((outer (if (not parent) (get-size~ (get-desktop)) (get-size~ parent)))
          (rect (get-rect)))
      (receive (new-position new-size) (fit-within outer rect padding: 8)
        (set-size new-size)
        (set-position new-position))))


  (method public (mouse-position)
    (with ((point (POINT-make)))
      (GetCursorPos point)
      (acquire (get-desktop) (new Point (POINT-x-ref point) (POINT-y-ref point)))))


  (method public (mouse-window)
    (find-window (mouse-position)))


  (method public (mouse-in-window?)
    (point-in-window? (mouse-position)))


  (method public (point-in-window? point)
    (let ((size (get-window-size)))
      (and (in-interval? (get-h~ point) 0 (get-width~ size))
           (in-interval? (get-v~ point) 0 (get-height~ size)))))


  (method public (find-window point)
    (with ((pt (POINT-make)))
      (POINT-x-set! pt (get-h~ point))
      (POINT-y-set! pt (get-v~ point))
      (get-window (WindowFromPoint pt))))
  
  
  (method public (find-child-window point)
    (with ((pt (POINT-make)))
      (POINT-x-set! pt (get-h~ point))
      (POINT-y-set! pt (get-v~ point))
      (let ((window (get-window (ChildWindowFromPointEx handle pt (bit-or CWP_SKIPINVISIBLE CWP_SKIPDISABLED CWP_SKIPTRANSPARENT)))))
        (if (or (not window) (eq? window self))
            window
          (find-child-window~ window (acquire~ window self point))))))


  (method public (flash-window)
    (unimplemented 'flash-window)
    @FlashWindow
    (loop (repeat 3)
          (FlashWindow handle true)
          (sleep 100)
          (FlashWindow handle false)
          (sleep 100)))


  (method public (move x y cx cy)
    (MoveWindow handle x y cx cy true))


  (method public (acquire-focus)
    (set-window-focus self))
  
  
  (method public (get-enabled?)
    (IsWindowEnabled handle))
  
  
  (method public (enable-window)
    (EnableWindow handle true))
  
  
  (method public (disable-window)
    (EnableWindow handle false))


  (method public (get-client-rect)
    (with ((rect (RECT-make)))
      (GetClientRect handle rect)
      (RECT->rect rect)))


  (method public (scroll-window dh dv rect (clip-rect: clip-rect {}) (erase?: erase? true))
    (let ((flags (bit-or (if erase? SW_ERASE 0) SW_INVALIDATE)))
      (with ((rect (rect->RECT rect))
             (clip-rect (rect->RECT clip-rect)))
        (ScrollWindowEx handle dh dv rect clip-rect NULL NULL flags))))

  
  (method public (invalidate-rect rect (erase? false))
    (when handle
      (with ((rect (rect->RECT rect)))
        (InvalidateRect handle rect erase?))))

  
  (method public (invalidate-region region (erase? false))
    (when handle
      (InvalidateRgn handle (get-handle~ region) erase?)))

  
  (method public (invalidate-window (erase? false))
    (when handle
      (InvalidateRect handle NULL erase?)))

  
  (method public (redraw-window (rect: rect {}) (region: region {}))
    (when handle
      ;; Changed RDW_NOCHILDREN to RDW_ALLCHILDREN so that a redraw-window on the
      ;; toplevel would redraw it's children. Hope it doesn't break any code...
      (let ((flags (bit-or RDW_ERASENOW RDW_UPDATENOW RDW_INVALIDATE RDW_ALLCHILDREN)))
        (with ((rect (if (not rect) NULL (rect->RECT rect))))
          (RedrawWindow handle rect (if region (get-handle~ region) NULL) flags)))))


  (method public (invalidate-border (insets: insets {Rect 1 1 1 1}))
    (with-closed ((region (border-region insets: insets)))
      (invalidate-region region)))


  (method public (redraw-border (insets: insets {Rect 1 1 1 1}))
    (with-closed ((region (border-region insets: insets)))
      (redraw-window region: region)))


  (method public (border-region (insets: insets {Rect 1 1 1 1}))
    (frame-region (get-client-rect) insets: insets))


  (method public (get-update-rect)
    (with ((rect (RECT-make)))
      (GetUpdateRect handle rect false)
      (RECT->rect rect)))


  (method public (get-update-region)
    (let ((region (new Region)))
      (GetUpdateRgn handle (get-handle~ region) false)
      region))


  (method public (get-class-background)
    (GetClassLong handle GCL_HBRBACKGROUND))


  (method public (update-window)
    (UpdateWindow handle))
  
  
  (method public (show-noactivate)
    (SetWindowPos handle HWND_TOP 0 0 0 0 (bit-or SWP_SHOWWINDOW SWP_NOACTIVATE SWP_NOMOVE SWP_NOSIZE)))
  
  
  (method public (hide-noactivate)
    (SetWindowPos handle 0 0 0 0 0 (bit-or SWP_HIDEWINDOW SWP_NOACTIVATE SWP_NOMOVE SWP_NOSIZE)))


  ;;;
  ;;;; Children
  ;;;


  (method public (first-window)
    (let ((windows (get-windows)))
      (if (null? windows)
          #f
        (first windows))))


  (method public (second-window)
    (let ((windows (get-windows)))
      (if (>= (length windows) 2)
          (second windows)
        #f)))


  (method public (last-window)
    (last (get-windows)))
    
  
  (method public (get-windows (include-invisibles?: include-invisibles? false))
    (with ((proc <procedure>
             (function dynamic (child)
               (and (is? child Window)
                    (or include-invisibles? (get-visible?~ child))))))
      (collect-if proc (get-children))))


  (method public (front-window?)
    (eq? self (first-window~ parent)))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method (bring-to-front)
    (nextmethod)
    (BringWindowToTop handle))


  (method (send-to-back)
    (nextmethod)
    (SetWindowPos handle HWND_BOTTOM 0 0 0 0 (bit-or SWP_NOMOVE SWP_NOSIZE)))


  ;;;
  ;;;; Layout
  ;;;


  (method (get-location)
    location)


  (method (set-location loc)
    (set! location loc))
  
  
  (method public (layout-window)
    (layout))
  
  
  (method public virtual (layout)
    )
  
  
  ;;;
  ;;;; View
  ;;;
  
  
  (method public (mouse-view)
    (find-view (mouse-position)))
  
  
  (method public (find-view pos)
    (let ((window (find-window pos)))
      (when (is? window View-Player)
        (let ((root (get-root~ window)))
          (find-drawing~ root (acquire~ window self pos))))))
  
  
  (method public (to-view shape view)
    (let* ((player (get-player~ view))
           (acquired (acquire~ player self shape)))
      (acquire~ view (get-root~ player) acquired)))


  ;;;
  ;;;; Debugging
  ;;;
  
  
  (method public virtual (debug-window pos)
    (unimplemented 'debug-window)
    @Development
    (set-%~ Development self))


  (method public virtual (describe-window pos)
    (unimplemented 'describe-window)
    @WINSTYLE(
    (format :console "{%}")
    (format :console "Class:            {s}{%}" (class-of self))
    (format :console "Name:             {s}{%}" (get-name))
    (format :console "Class Background: {s}{%}" (get-class-background))
    (format :console "Clip Children?:   {s}{%}" (mask-bit-set? (get-style) WS_CLIPCHILDREN))
    (format :console "Clip Siblings?:   {s}{%}" (mask-bit-set? (get-style) WS_CLIPSIBLINGS))
    (format :console "Position:         {s}{%}" (get-position))
    (format :console "Size:             {s}{%}" (get-size))
    (format :console "Window rect:      {s}{%}" (get-bounds))
    (format :console "Client rect:      {s}{%}" (get-client-rect))
    (format :console "Style:            {s}{%}" (bits->symbolic (get-style) WINSTYLE))
    (format :console "Extended Style:   {s}{%}" (bits->symbolic (get-ex-style) WINEXSTYLE))))))
