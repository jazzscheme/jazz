;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Utilities
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.utilities jazz


(export (jazz.utilities.platform.windows (cond windows))
        (jazz.utilities.platform.x11     (cond x11)))


(import (jazz.utilities.platform.windows (cond windows))
        (jazz.utilities.platform.x11     (cond x11))
        (jazz.io)
        (jazz.library)
        (jazz.ui))


;;;
;;;; Constants
;;;


(definition public (cn)
  (coerce #\newline String))


(definition public (cr)
  (coerce #\return String))


(definition public (crlf)
  (coerce (list #\return #\line-feed) String))


;;;
;;;; Actions
;;;


(definition public (find-actions context)
  (child~ (get-bindings~ (get-application)) context))


(definition public (find-action-item context name)
  (child~ (find-actions context) name))


(definition public (require-action-item action)
  (either (find-action-item (get-action-context~ action) (get-action-name~ action))
          (error "Unable to find action: {t}" action)))


(definition public (call-action action sender properties (event: event {}))
  (let ((action-item (require-action-item action)))
    (invoke~ action-item sender properties action: action event: event)))


(definition public (get-action-enabled? action)
  (let ((action-item (require-action-item action)))
    (get-enabled?~ action-item)))


(definition public (set-action-enabled? action enabled?)
  (let ((action-item (require-action-item action)))
    (set-enabled?~ action-item enabled?)))


(definition public (set-actions-enabled? actions enabled?)
  (for-each (function dynamic (action)
              (set-action-enabled? action enabled?))
            actions))


;;;
;;;; Shortcuts
;;;


(definition public Alphabetic-Chars
  '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))

(definition public Numerical-Chars
  '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\0))

;; Should work on almost every keyboard
(definition public Standard-Chars
  '(F1
     F2
     F3
     F4
     F5
     F6
     F7
     F8
     F9
     F10
     F11
     F12
     Escape
     Backspace
     Return
     Space
     Tab
     Home
     End
     Left
     Up
     Right
     Down
     Prior
     Next
     Insert
     Pause
     Delete
     Add
     Subtract
     Multiply
     Divide))

;; Can be very keyboard specific
(definition public Non-Standard-Chars
  '(Tilde
     Minus
     Plus
     Open-Bracket
     Close-Bracket
     Backslash
     Semi-Colon
     Quote
     Comma
     Period
     Slash))

;; Kludge for the macro recorder specific to standard english keyboards
(definition Non-Standard-Characters
  '(#\backquote
    #\minus
    #\equal
    #\open-bracket
    #\close-bracket
    #\backslash
    #\semi-colon
    #\quote
    #\comma
    #\period
    #\slash))


(definition public All-Modifiers
  '(()                     ;; letters
    (:shift)               ;; capital letters
    (:control)             ;; standard Windows
    (:alt)                 ;; mostly for focus
    (:control :alt)        ;; mostly for guest
    (:alt :shift)          ;; window management
    (:control :shift)      ;; window selection
    (:control :alt :shift) ;; favorite files
    ))

(definition public Shift-Modifiers
  '((:shift)))

(definition public Text-Modifiers
  '(() (:shift)))


(definition (all-accelerators-table)
  (get-accelerators-table (all-shortcuts)))


(definition (all-shortcuts)
  (append (build-shortcuts Alphabetic-Chars All-Modifiers)
          (build-shortcuts Numerical-Chars (difference All-Modifiers Text-Modifiers test: equal?))
          (build-shortcuts Standard-Chars All-Modifiers)
          (build-shortcuts Non-Standard-Chars (difference All-Modifiers Text-Modifiers test: equal?))))


(definition (build-shortcuts keys modifiers)
  (let ((fact (new List-Factory)))
    (for-each (function dynamic (key)
                (for-each (function dynamic (modifiers)
                            (put~ fact (new Shortcut modifiers key)))
                          modifiers))
              keys)
    (get-output~ fact)))


;;;
;;;; Cookies
;;;


(definition public Unique-Id
  8000)

(definition public Id-Cookies
  (new-hashtable eqv?))


(definition public (register-cookie-id cookie)
  (let ((id Unique-Id))
    (increase! Unique-Id)
    (hash-set! Id-Cookies id cookie)
    id))


(definition public (unregister-cookie-id id)
  (hash-clear Id-Cookies id))


(definition public (get-id-cookie id)
  (hash-ref Id-Cookies id))


;;;
;;;; Constants
;;;


(definition public Pi
  3.14159)


;;;
;;;; Class
;;;


(definition public (for-each-definition model definition proc)
  (unimplemented 'for-each-definition)
  @field-creator
  (letrec ((process
             (function dynamic (model)
               (when model
                 (let ((definition (category-field model definition)))
                   (when definition
                         (proc definition)
                         (process (type-ascendant (field-creator definition)))))))))
    (process model)))


;;;
;;;; Descriptors
;;;


;; I think that all this is a bit of a kludge... because there will always be only one
;; instance of a class descriptor for any class, using forms and instantiating them seems
;; a bit overkill. On the other hand it could enable a subclass to modify its inherited
;; descriptor! Note that this paragraph also applies to class actions...


(definition public Class-Descriptors
  (new-hashtable eq?))


(definition public (get-descriptor model)
  (let ((name (type-name model)))
    (either (hash-ref Class-Descriptors name)
            (let ((form (get-class-descriptor~ model)))
              (when form
                (let ((descriptor (instantiate~ form)))
                  (set-name~ descriptor name)
                  (hash-set! Class-Descriptors name descriptor)
                  descriptor))))))


(definition public (get-properties-descriptor model)
  (let ((class-descriptor (get-descriptor model)))
    (when class-descriptor
      (find-component~ class-descriptor 'properties))))


(definition public (get-property-descriptor model name)
  (let ((properties-descriptor (get-properties-descriptor model)))
    (when properties-descriptor
      (find-component~ properties-descriptor name))))


;;;
;;;; Formatting
;;;


(definition public (format-cardinality n <fx>)
  (if (= n 0)
      "No"
    (->string n)))


(definition public (format-plural n <fx> (plural "s"))
  (if (= n 1)
      ""
    plural))


(definition public (format-gender word)
  (if (vowel? (first word))
      "an"
    "a"))


(definition public (format-is/are n <fx>)
  (if (= n 1)
      "is"
    "are"))


(definition public (format-was/were n <fx>)
  (if (= n 1)
      "was"
    "were"))


(definition public (format-y/ies n <fx>)
  (if (= n 1)
      "y"
    "ies"))


(definition public (format-following name <Object> n <fx>)
  (if (= n 1)
      (format "{a} was" name)
    (format "{a} {a}s where" n name)))


;;;
;;;; Debugging
;;;


(definition public Debug-Color
  {})


(definition (get-debug-color)
  (unimplemented 'get-debug-color)
  @unimplemented
  (unless Debug-Color
    (set! Debug-Color (new Color red: 90 green: 90 blue: 90)))
  Debug-Color)

@old-debug
(definition public (debug . rest)
  (debug-string (format "{l detail: :describe}" rest)))


(definition public (debug-string string (color: color {}))
  (unimplemented 'debug-string)
  @get-application
  (let ((appl (get-application)))
    (when (and appl (get-loop-running?~ appl))
      (let ((text (get-console-text)))
        (when text
          (fresh-line)
          (with-colored-output~ text (either color (get-debug-color))
            (function dynamic ()
              (display string)))
          (fresh-prompt~ text)))))
  {})


(definition public (debug-text . rest)
  (unimplemented 'debug-text)
  @typed?
  (unless (typed? self 'Console-Text-View)
    (apply debug rest)))


(definition public (debug-self object . rest)
  (unimplemented 'debug-self)
  @Development
  (when (eq? object (get-%~ Development))
    (apply debug rest)))


;;;
;;;; Execution
;;;


;; Does this have to do with debugging?


(definition public (with-execution-context proc (title: title {}) (details: details '()) (reporter: reporter {}))
  (proc)
  ;; to convert
  @unimp
  (with-closed ((context (new Execution-Context title: title :details details reporter: reporter)))
    (proc)))


(definition public (with-execution-node proc (title: title {}) (details: details '()) (reporter: reporter {}))
  (proc)
  ;; to convert
  @unimp
  (with-closed ((node (new Execution-Node title: title :details details reporter: reporter)))
    (proc)))


(definition public (get-execution-context)
  (unimplemented 'get-execution-context)
  @active-thread
  (let ((thread (active-thread)))
    (get-active-context~ thread)))


(definition public (get-execution-stack)
  (unimplemented 'get-execution-stack)
  @active-thread
  (let* ((thread (active-thread))
         (node (get-active-node~ thread))
         (lst '()))
    (while node
      (set! lst (cons node lst))
      (set! node (essay (is-not? node Execution-Context) (get-previous-node~ node))))
    lst))

@unimplemented
(class Execution-Node extends Object
  
  
  (slot title)
  (slot details)
  (slot reporter)
  (slot previous-node)
  
  
  (definition (initialize (title: title {}) (details: details '()) (reporter: reporter {}))
    (nextmethod)
    (set! title~self title)
    (set! details~self details)
    (set! reporter~self reporter)
    (let ((thread (active-thread)))
      (set! previous-node~self (get-active-node~ thread))
      (set-active-node~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (active-thread)))
      (set-active-node~ thread previous-node))
    (nextmethod))
  
  
  (definition public (get-title)
    title)
  
  
  (definition public (get-details)
    details)
  
  
  (definition public (get-reporter)
    reporter))

@unimplemented
(class Execution-Context extends Execution-Node
  
  
  (slot previous-context)
  (slot continuable?     initialize #f)
  (slot auto-continue?   initialize #f)
  
  
  (definition (initialize . rest)
    (apply nextmethod rest)
    (let ((thread (active-thread)))
      (set! previous-context~self (get-active-context~ thread))
      (set-active-context~ thread self))
    (destroy-mandatory))
  
  
  (definition (destroy)
    (let ((thread (active-thread)))
      (set-active-context~ thread previous-context))
    (nextmethod))
  
  
  (definition public (get-continuable?)
    continuable?)
  
  
  (definition public (set-continuable? value)
    (set! continuable? value))
  
  
  (definition public (get-auto-continue?)
    auto-continue?)
  
  
  (definition public (set-auto-continue? value)
    (set! auto-continue? value)))


;;;
;;;; Continue
;;;


(definition public (with-continue proc)    
  (unimplemented 'with-continue)
  @call-cc?
  (let ((context (get-execution-context)))
    (if (not context)
        (error "Registering a continuable error outside an execution context is not allowed")
      (let ((preserved (get-continuable?~ context)))
        (unwind-protect
            (begin
              (set-continuable?~ context #t)
              (catch Continue
                (proc)))
          (set-continuable?~ context preserved))))))


(definition public (continuable? exception)
  (unimplemented 'continuable?)
  @call-cc?
  (let ((context (get-execution-context)))
    (and context (get-continuable?~ context))))


(definition public (continue exception)
  (unimplemented 'continue)
  @call-cc
  (throw (new Continue)))


;;;
;;;; Restart
;;;


(definition public Restartable?
  #f)


(definition public (with-restart proc (cleanup {}))
  (unimplemented 'with-restart)
  @call-cc?
  (let ((preserved Restartable?))
    (unwind-protect
        (begin
          (set! Restartable? #t)
          (while #t
            (catch Restart
              (proc)
              (return))
            (when cleanup
              (cleanup))))
      (set! Restartable? preserved))))


(definition public (restartable? exception)
  Restartable?)


(definition public (restart (exception {}))
  (unimplemented 'restart)
  @call-cc?
  (throw (new Restart)))


;;;
;;;; Jazz
;;;


(definition public (extract-jazz-file-category file)
  (let ((in/toplevel (extract-jazz-file-toplevel file)))
    (when in/toplevel
      (receive (in toplevel) in/toplevel
        (let ((package (extract-package in))
              (type/name/extends (extract-category toplevel)))
          (when type/name/extends
            (receive (type name extends) type/name/extends
              (values package type name extends))))))))


(definition (extract-jazz-file-toplevel file)
  (unimplemented 'extract-jazz-file-toplevel)
  @convert
  (call-with-input-file file
    (lambda (reader)
      (catch (Read-Error err {})
        (let ((in/toplevel (read reader)))
          (if (and (pair? in/toplevel) (eq? (car in/toplevel) 'in))
              (values in/toplevel (read reader))
            (values {} in/toplevel)))))))


(definition (extract-package in)
  (when (pair? (cdr in))
    (let ((package (cadr in)))
      (when (symbol? package)
        package))))


(definition (extract-category toplevel)
  (when (pair? toplevel)
    (let ((type (car toplevel)))
      (when (memq? type '(class interface package))
        (let ((scan (cdr toplevel)))
          (when (pair? scan)
            (let ((name (car scan)))
              (when (symbol? name)
                (if (or (and (eq? type 'class) (eq? name 'Object))
                        (and (eq? type 'interface) (eq? name 'Unknown))
                        (and (eq? type 'package) (eq? name 'Common)))
                    (values type name {})
                  (let ((scan (cdr scan)))
                    (when (and (pair? scan) (eq? (car scan) 'extends))
                      (let ((scan (cdr scan)))
                        (when (pair? scan)
                          (let ((extends (car scan)))
                            (when (symbol? extends)
                              (values type name extends))))))))))))))))


;;;
;;;; Component
;;;


(definition public (component-name component)
  (get-name~ component))


;;;
;;;; Dispatch
;;;


(definition public (dispatch? expr)
  (and (symbol? expr)
       (ends-with? (symbol->string expr) "~")))


(definition public (dispatch-string? string)
  (ends-with? string "~"))


(definition public (dispatch->name dispatch)
  (let ((extract
          (function dynamic (string)
            (subseq string 0 (- (length string) 1)))))
    (if (string? dispatch)
        (extract dispatch)
      (string->symbol (extract (symbol->string dispatch))))))


;;;
;;;; Form
;;;


(definition (form-name form)
  (get-name~ form))


;;;
;;;; JML
;;;


(definition public (tag? expr)
  (and (symbol? expr)
       (starts-with? (symbol->string expr) "<")))


(definition public (tag-string? string)
  (and (starts-with? string "<")
       (ends-with? string ">")))


(definition public (tag->name tag)
  (let ((extract
          (function dynamic (string)
            (subseq string 1 (- (length string) 1)))))
    (if (string? tag)
        (extract tag)
      (string->symbol (extract (symbol->string tag))))))


(definition public (jml-keyword? expr)
  (keyword? expr))


;;;
;;;; Logging
;;;


(definition public Logs
  (new List-Factory))


(definition public (get-logs)
  (get-list~ Logs))

@unimplemented
(definition public Add-Log-Lock
  (new Lock))


(definition public (add-log log)
  (unimplemented 'add-log)
  @Mutex?
  (synchronize Add-Log-Lock
    (unless (memq? log (get-logs))
      (put~ Logs log))))


(definition public (current-log)
  (either (get-current-log)
          (let ((log (default-log)))
            (set-current-log log)
            (add-log log)
            log)))


(definition (default-log)
  (unimplemented 'default-log)
  @Logs
  (new Log name: "Default"))


(definition public (get-current-log)
  (unimplemented 'get-current-log)
  @Parameters
  (get-parameter 'current-log))


(definition public (set-current-log log)
  (unimplemented 'set-current-log)
  @Parameters
  (set-parameter 'current-log log))


(definition public (with-log log proc (name: name {}) (file: file {}))
  (unimplemented 'with-log)
  @unwind-protect
  (let ((preserved (get-current-log)))
    (unwind-protect
        (begin
          (set-current-log log)
          (proc))
      (set-current-log preserved))
    (let ((name (get-name~ log)))
      (when (and name (not file))
        (add-log log)))))


(definition public (with-node proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (let ((node (either node (new-entry~ log tag name message data))))
    (with-node~ log node proc)))


(definition public (log-node node (log: log (current-log)))
  (log-node~ log node))


(definition public (log-entry (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (log-entry~ log tag name message data))


(definition public (log-properties properties (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (unimplemented 'log-properties)
  @String-Printer
  (let ((printer (new String-Printer))
        (first? #t))
    (for-each-property (function dynamic (property value)
                         (if first?
                             (set! first? #f)
                           (format printer ", "))
                         (format printer "{a}: {a}" (keyword->symbol property) value))
      properties)
    (let ((message (get-output~ printer)))
      (log-entry :tag tag name: name message: message :data data :log log))))


(definition public (new-log-node (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (new-entry~ log tag name message data))


;;;
;;;; Profiling
;;;


(definition public (with-profile proc (node: node {}) (tag: tag {}) (name: name {}) (message: message {}) (data: data {}) (log: log (current-log)))
  (unimplemented 'with-profile)
  @Profiling-later
  (with-node
    (function dynamic (node)
      (let ((result))
        (log-profile name: 'before :log log)
        ;; this is ugly but necessary not to change stack depth
        (set! result (proc node))
        (log-profile name: 'after :log log)
        result))
    :node (either node (new-entry~ log tag name message data))))


(definition public (log-profile (name: name {}) (log: log (current-log)))
  (unimplemented 'log-profile)
  @Profiling-later (
  (gc)
  (log-node (resources-snapshot~ Performance name: name) :log log)))


(definition public (log-stack (tag: tag {}) (name: name {}) (message: message {}) (log: log (current-log)))
  (unimplemented 'log-stack)
  @later
  (let ((data (new Stack-Snapshot)))
    (log-entry :tag tag name: name message: message :data data :log log)))


(definition public (profiles->jml profiles)
  (unimplemented 'profiles->jml)
  @later
  (let ((nodes '()))
    (for-each-map (function dynamic (name profile)
                    (when (not (profile-parent profile))
                      (set! nodes (cons (profile->jml {} profile) nodes))))
                  (get-profiles))
    (sort < nodes key: (function dynamic (node) (get-property~ node 'name)))))


(definition (profile->jml parent profile)
  (unimplemented 'profile->jml)
  @later
  (let ((node (profile-content parent profile)))
    (insert-profile-children node profile)
    node))


(definition (profile-content parent profile)
  (unimplemented 'profile-content)
  @later
  (let ((name (profile-name profile))
        (count (profile-count profile 0))
        (total (profile-total profile 0)))
    (new JML-Element parent 'profile properties: (list 'name name 'count count 'total total))))


(definition (insert-profile-children parent profile)
  (unimplemented 'insert-profile-children)
  @later
  (map (function dynamic (child)
         (profile->jml parent child))
       (collect-profile-children profile)))


(definition (collect-profile-children profile)
  (unimplemented 'collect-profile-children)
  @later
  (let ((children '())
        (child (profile-last-child profile)))
    (while child
      (set! children (cons child children))
      (set! child (profile-previous-brother child)))
    children))


;;;
;;;; Manifest
;;;


(definition public (for-each-source proc)
  (unimplemented 'for-each-source)
  @Workbench
  (let ((workbench (get-workbench))
        (manifest (get-manifest)))
    (cond (workbench
            (for-each-jazz-file~ workbench
              (function dynamic (file)
                (proc (get-name~ file) (get-source~ file) (manifest-properties~ file)))))
          (manifest
            (for-each-map (function dynamic (category-name properties)
                            (proc category-name (getf properties :source) properties))
                          (get-manifest)))
          (else
           (for-each-map (function dynamic (name value)
                           (bind (ignore time . properties) value
                             (proc name {} properties)))
                         (get-compiled-categories))))))


;;;
;;;; Optimized
;;;


(definition public Optimized?
  #t)


;; wait inline
(definition public (optimized?)
  Optimized?)


;; wait inline
(definition public (set-optimized? flag)
  (set! Optimized? flag))


;;;
;;;; Macro Recorder
;;;


(definition public (macro-recording?)
  #f
  @Macro-Recorder
  (and (in-manifest? 'Macro-Recorder) Recording?))


(definition public (macro-playing?)
  #f
  @Macro-Recorder
  (and (in-manifest? 'Macro-Recorder) Recording-Playing?))


;;;
;;;; Locales
;;;


(definition public Active-Locales
  '(:english @waiting-for-real-translation :french))

(definition public Active-Locale
  :english)


(definition public (get-locales)
  Active-Locales)


(definition public (get-locale)
  Active-Locale)


(definition public (set-locale loc (update?: update? #t))
  (when (/= loc Active-Locale)
    (set! Active-Locale loc)
    (select-locale loc)
    (when update?
      (locale-update))))


(definition (select-locale locale)
  (unimplemented 'select-locale)
  @get-application
  (let* ((appl (get-application))
         (status (get-status-bar~ appl)))
    (when status
      (let ((label (locate-component~ status 'locales)))
        (when label
          (set-title~ label (localize (present-locale locale))))))))


(definition (locale-update)
  (unimplemented 'locale-update)
  @get-application(
                   ;; All this should of course be event based but it will do for now...
                   (layout-menu~ (get-menubar~ (get-application)))
                   (redraw-window~ (get-toplevel))))


(definition public (localize object)
  object
  ;; convert
  @Locales
  (if (is? object Locales)
      (localize~ object Active-Locale)
    object))


(definition public (localize-to object locale)
  object
  ;; convert
  @Locales
  (if (is? object Locales)
      (localize~ object locale)
    object))


(definition public (present-locale locale)
  (case locale
    ((:english) "English")))


;;;
;;;; Extension
;;;


(definition public Scheme-Extensions
  '("scm" "ss" "jscm"))

(definition public CommonLisp-Extensions
  '("lisp"))

(definition public Jazz-Extensions
  '("jazz" "jcat" "jml" "mnf"))

(definition public Cpp-Extensions
  '("c" "cpp" "h" "hpp"))


;;;
;;;; Pathname
;;;


(definition public (make-filename base extension)
  (format "{a}.{a}" base extension))


(definition public (tokenise-alias name)
  (when (is-alias? name)
    (let ((alias (get-alias name)))
      (when (string? alias)
        (set-alias name (tokenise alias))))))


(definition public (ensure-read/write moniker (cancel-action: cancel-action 'throw))
  @convert
  (let ((file (get-file~ moniker)))
    (if (or (not (exists?~ file)) (read/write?~ file))
        'no-action
      (let* ((appl (get-application))
             (pref (get-repositories-preferences~ appl))
             (repository (essay (in-manifest? 'Repository) (find-repository~ Repository moniker)))
             (status (essay repository (get-file-status~ repository file error?: #f)))
             (code (cond ((not status)
                          (case (message-box (format "File {s} is read-only. Overwrite?" (get-name~ moniker))
                                             title: "File Status"
                                             type: 'question
                                             process-keys?: #f)
                            ((yes) 'set-read/write)
                            ((no) 'cancel)))
                         ((or (= status 'checked-out-me) (get-auto-checkout?~ pref))
                          'checkout)
                         (else
                          (case (message-box (format "File {s} is read-only. Do you want to check it out?{%}Overwrite read-only status by pressing \"Set Read/Write\"." (get-name~ moniker))
                                             title: "File Status"
                                             type: 'confirmation
                                             yes: "Check Out"
                                             no: "Set Read/Write"
                                             cancel: (case cancel-action (throw "Cancel") (ignore "Ignore"))
                                             process-keys?: #f)
                            ((yes) 'checkout)
                            ((no) 'set-read/write)
                            ((cancel) 'cancel))))))
        (case code
          ((checkout)
           (unless (= status 'checked-out-me)
             (checkout-file~ repository file))
           (set-read/write~ file)
           'checkout)
          ((set-read/write)
           (set-read/write~ file)
           'read/write)
          ((cancel)
           (throw-cancel)))))))


(definition public (convert-extension object from to)
  (unimplemented 'convert-extension)
  @file?
  (cond ((not object) {})
        ((string? object) (convert-name-extension object from to))
        ((pair? object) (convert-path-extension object from to))
        ((file? object) (convert-file-extension object from to))
        ((directory? object) object)
        (else "Unable to convert extension for {t}" object)))


(definition (convert-name-extension name from to)
  (unimplemented 'convert-name-extension)
  @Pathname
  (if (ci= (extract-extension name) from)
      (make-filename (extract-base name) to)
    name))


(definition (convert-path-extension path from to)
  (unimplemented 'convert-path-extension)
  @Pathname
  (let ((name (last path)))
    (if (ci= (extract-extension name) from)
        (append (butlast path) (list (convert-name-extension name from to)))
      path)))


(definition (convert-file-extension file from to)
  (if (ci= (get-extension~ file) from)
      (new-brother~ file (make-filename (get-base~ file) to))
    file))


;;;
;;;; Resource
;;;


(definition public inline (resource? object)
  (is? object Resource))



;;;
;;;; Safety
;;;


(definition public (with-safe-execution title proc (continue-text: continue-text {}) (continue-handler: continue-handler {}))
  (proc)
  @convert-message-box?
  (call-with-catch Error
        (function dynamic (err)
          (dump-stack :exception err)
          (let ((invite (format "The following error occured while {a}:" title))
                (message (present-message~ err :active-content? #f))
                (message-box? (message-box?)))
            (let ((text
                    (if (not message-box?)
                        (format "{a}{%}{%}{a}{%}{%}Press Yes to try and continue, No to exit" invite (car message))
                      (append (list invite {})
                              message
                              (if (and continue-handler continue-text)
                                  (append (list {}) continue-text)
                                '())))))
              (if (not continue-handler)
                  (begin
                    (if (not message-box?)
                        (system-message text)
                      (message-box text yes: "Exit"))
                    (exit))
                (case (if (not message-box?)
                          (system-message text type: 'question)
                        (message-box text
                                     type: 'question
                                     yes: "Continue"
                                     no: "Exit"))
                  ((yes) (continue-handler err))
                  ((no) (exit)))))))
      {}
    proc))


;;;
;;;; Various
;;;


(definition public (sleep delay)
  (thread-sleep! (/ delay 1000)))


(definition public (warn string . rest)
  (format :console "{%}Warning: ")
  (apply format :console string rest))


(definition public (bits->symbolic bits enumeration)
  (let ((entries (get-entries~ enumeration)))
    (with ((fact (new List-Factory)))
      (for-each (function dynamic (entry)
                  (bind (name value) entry
                    (when (mask-bit-set? bits value)
                      (put~ fact name))))
                entries)
      (get-output~ fact))))


(definition public (copy-into! seq1 seq2)
  (for-each (function dynamic (element rank)
              (set-element! seq2 rank element))
            seq1
            (naturals 0 (length seq1))))


;;;
;;;; Events
;;;


@tofix-move-or-delete
(definition public (wait-while predicate <procedure> (window (get-toplevel)))
  (let ((process (get-process)))
    (while (predicate)
      (process-one-message~ process window)
      (sleep 0))))


@tofix-move-or-delete
(definition public (wait-until predicate <procedure> (window (get-toplevel)))
  (let ((process (get-process)))
    (while (not (predicate))
      (process-one-message~ process window)
      (sleep 0))))


;;;
;;;; Critical Sections
;;;


(definition public (monitor section proc)
  (unimplemented 'monitor)
  @unwind-protect
  (let ((entered? #f))
    (unwind-protect
        (begin
          (enter~ section)
          (set! entered? #t)
          (proc))
      (when entered?
        (leave~ section)))))


;;;
;;;; Context
;;;


(definition public (present-context-actions title actions)
  (unimplemented 'present-context-actions)
  @?self?
  (present-context-text title
                        (map (function dynamic (action)
                               (let* ((image (get-image~ action))
                                      (title (get-title~ action))
                                      (handler (get-handler~ action))
                                      (action
                                        (function ()
                                          (when handler
                                            (invoke~ handler self {})))))
                                 (list (list image: image) "  " (list :hyperlink action title))))
                             actions)))


(definition public (present-context-text title text)
  (unimplemented 'present-context-text)
  @Context-Text-View
  (let ((text-view (new Context-Text-View)))
    (set-text~ text-view text)
    (list title text-view)))


;;;
;;;; Tabulated
;;;


(definition public (display-tabulated data printer)
  (unimplemented 'display-tabulated)
  @Column-Display-Display-Column
  (let* ((display (new Columns-Display))
         (sample (car data))
         (last (- (length sample) 1))
         (columns (loop (for ignore in sample)
                        (for n from 0)
                        (collect (if (= n last)
                                     (new Display-Column display)
                                   (new Aligned-Column display border-after: 1 alignment: 'left))))))
    (add-columns~ display columns)
    (for-each (function dynamic (row)
                (for-each (function dynamic (object column)
                            (output~ column (->string object)))
                          row
                          columns)
                (newline~ display))
              data)
    (print-to~ display printer)))


;;;
;;;; Shape
;;;


;; Best way to think of rectangle and intervals is that they are between the pixels.
;; This is consistant with the mathematical definition of an interval [start end) as
;; to enclose the pixels no 0 1 2 3, the lines in between have to go from 0 to 4.


(definition public (size-rect size <Dimension>) <Rect>
  (new Rect 0 0 (get-width~ size) (get-height~ size)))


(definition public (position/size->rect position <Point> size <Dimension>) <Rect>
  (h/v/size->rect (get-h~ position) (get-v~ position) size))


(definition public (h/v/size->rect h <fx> v <fx> size <Dimension>) <Rect>
  (new Rect h v (+ h (get-width~ size)) (+ v (get-height~ size))))


(definition public (h/v/width/height h <fx> v <fx> width <fx> height <fx>) <Rect>
  (new Rect h v (+ h width) (+ v height)))


(definition public (corners->rect top-left <Point> bottom-right <Point>) <Rect>
  (new Rect (get-h~ top-left) (get-v~ top-left) (get-h~ bottom-right) (get-v~ bottom-right)))


(definition public (normalize-rect rect <Rect>) <Rect>
  (let ((l (get-left~ rect))
        (t (get-top~ rect))
        (r (get-right~ rect))
        (b (get-bottom~ rect)))
    (new Rect
      (if (<= l r) l r)
      (if (<= t b) t b)
      (if (<= l r) r l)
      (if (<= t b) b t))))


(definition public (rect-position rect <Rect>) <Point>
  (new Point (get-left~ rect) (get-top~ rect)))


(definition public (rect-size rect <Rect>) <Dimension>
  (new Dimension
    (rect-width rect)
    (rect-height rect)))


(definition public (rect-width rect <Rect>) <fx>
  (- (get-right~ rect) (get-left~ rect)))


(definition public (rect-height rect <Rect>) <fx>
  (- (get-bottom~ rect) (get-top~ rect)))


(definition public (offset-rect rect <Rect> h <fx> v <fx>) <Rect>
  (new Rect
    (+ (get-left~ rect)   h)
    (+ (get-top~ rect)    v)
    (+ (get-right~ rect)  h)
    (+ (get-bottom~ rect) v)))


(definition public (inflate-rect rect <Rect> w <fx> h <fx>) <Rect>
  (new Rect
    (- (get-left~ rect)   w)
    (- (get-top~ rect)    h)
    (+ (get-right~ rect)  w)
    (+ (get-bottom~ rect) h)))


(definition public (expand-rect rect <Rect> l <fx> t <fx> r <fx> b <fx>) <Rect>
  (new Rect
    (+ (get-left~ rect)   l)
    (+ (get-top~ rect)    t)
    (+ (get-right~ rect)  r)
    (+ (get-bottom~ rect) b)))


(definition public (base-rect rect <Rect>) <Rect>
  (offset-rect rect (- (get-left~ rect)) (- (get-top~ rect))))


(definition public (fit-rects src dst mode)
  (let* ((dw (rect-width dst))
         (dh (rect-height dst))
         (sw (rect-width src))
         (sh (rect-height src))
         (rw (/ dw sw))
         (rh (/ dh sh)))
    (case mode
      ((width) rw)
      ((height) rh)
      ((both) (if (> rw rh) rh rw)))))


(definition public (fit-within outer rect (minimum-size: minimum-size {Dimension 0 0}) (padding: padding 0))
  (let* ((size (rect-size rect))
         (position (rect-position rect))
         (width  (max (get-width~ minimum-size)  (min (get-width~ size) (- (get-width~ outer) padding padding))))
         (height (max (get-height~ minimum-size) (min (get-height~ size)(- (get-height~ outer) padding padding))))
         (new-size (new Dimension width height))
         (min-position (new Point padding padding))
         (max-position (new Point (- (get-width~ outer) (get-width~ new-size) padding) (- (get-height~ outer) (get-height~ new-size) padding)))
         (new-position (new Point (between (get-h~ min-position) (get-h~ position) (get-h~ max-position)) (between (get-v~ min-position) (get-v~ position) (get-v~ max-position)))))
    (values new-position new-size)))


(definition public (rect-union x <Rect> y <Rect>)
  (new Rect
    (if (< (get-left~ x) (get-left~ y)) (get-left~ x) (get-left~ y))
    (if (< (get-top~ x) (get-top~ y)) (get-top~ x) (get-top~ y))
    (if (> (get-right~ x) (get-right~ y)) (get-right~ x) (get-right~ y))
    (if (> (get-bottom~ x) (get-bottom~ y)) (get-bottom~ x) (get-bottom~ y))))


(definition public (rect-intersection x <Rect> y <Rect>) <Rect>
  (if (rect-intersect? x y)
      (new Rect
        (if (> (get-left~ x) (get-left~ y)) (get-left~ x) (get-left~ y))
        (if (> (get-top~ x) (get-top~ y)) (get-top~ x) (get-top~ y))
        (if (< (get-right~ x) (get-right~ y)) (get-right~ x) (get-right~ y))
        (if (< (get-bottom~ x) (get-bottom~ y)) (get-bottom~ x) (get-bottom~ y)))
    (new Rect 0 0 0 0)))


(definition public (rect-intersect? x <Rect> y <Rect>)
  (and (< (get-left~ x) (get-right~ y))
       (< (get-top~ x) (get-bottom~ y))
       (> (get-right~ x) (get-left~ y))
       (> (get-bottom~ x) (get-top~ y))))


(definition public (rects-intersect? rect <Rect> position <Point> size <Dimension>)
  (and (< (get-left~ rect) (+ (get-h~ position) (get-width~ size)))
       (< (get-top~ rect) (+ (get-v~ position) (get-height~ size)))
       (> (get-right~ rect) (get-h~ position))
       (> (get-bottom~ rect) (get-v~ position))))


(definition public (in-rect? pt <Point> rect <Rect>)
  (and (>= (get-h~ pt) (get-left~ rect))
       (>= (get-v~ pt) (get-top~ rect))
       (<  (get-h~ pt) (get-right~ rect))
       (<  (get-v~ pt) (get-bottom~ rect))))


(definition public (in-size? pt <Point> size <Dimension>)
  (and (>= (get-h~ pt) 0)
       (>= (get-v~ pt) 0)
       (<  (get-h~ pt) (get-width~ size))
       (<  (get-v~ pt) (get-height~ size))))

;; Nous aurons besoin de notre propre implementation des regions.

(definition public (rect-intersects-region? h <fx> v <fx> size <Dimension> region)
  #t
  @To-be-redone
  (with ((rect (new-rect h
                         v
                         (+ h (get-width~ size))
                         (+ v (get-height~ size)))))
    (RectInRegion (get-handle~ region)
                  rect)))


(definition public (add-rects r1 r2)
  (new Rect
    (+ (get-left~ r1) (get-left~ r2))
    (+ (get-top~ r1) (get-top~ r2))
    (+ (get-right~ r1) (get-right~ r2))
    (+ (get-bottom~ r1) (get-bottom~ r2))))


(definition public (subtract-rects r1 r2)
  (new Rect
    (- (get-left~ r1) (get-left~ r2))
    (- (get-top~ r1) (get-top~ r2))
    (- (get-right~ r1) (get-right~ r2))
    (- (get-bottom~ r1) (get-bottom~ r2))))


(definition public (inverse-rect rect)
  (new Rect
    (get-top~ rect)
    (get-left~ rect)
    (get-bottom~ rect)
    (get-right~ rect)))


(definition public (center inner outer)
  (justify inner outer 'center))


(definition public (justify inner outer justification)
  (let ((proc
          (function dynamic (i o j)
            (if (integer? j)
                (if (>= j 0)
                    j
                  (+ o j))
              (case j
                ((head) 0)
                ((center) (quotient (- o i) 2))
                ((tail) (- o i))
                (else (error "Unknown justification: {t}" j)))))))
    (cond ((and (is? inner Dimension) (is? outer Dimension))
           (new Point
             (proc (get-width~ inner) (get-width~ outer) (if (pair? justification) (first justification) justification))
             (proc (get-height~ inner) (get-height~ outer) (if (pair? justification) (second justification) justification))))
          ((and (number? inner) (number? outer))
           (proc inner outer justification))
          (else
           (error "Unable to justify a {t} into a {t}"
                  (type-name (class-of inner))
                  (type-name (class-of outer)))))))


(definition public (cycle-naturals cycle subcycle)
  (let* ((fact (new List-Factory))
         (cardinality (* cycle subcycle))
         (inc (quotient cardinality cycle)))
    (loop (for n from 0 below subcycle)
          (do (loop (for m from 0 below cardinality by inc)
                    (do (put~ fact (+ n m))))))
    (get-output~ fact)))


(definition public (fit pos <fx> alternate <fx> size <fx> max <fx>)
  (cond ((> size max) 0)
        ((<= (+ pos size) max) pos)
        ((>= (- alternate size) 0) (- alternate size))
        (else (- max size))))


(definition public (fit-point pos <Point> alternate <Point> size <Dimension> max <Dimension>)
  (new Point
    (fit (get-h~ pos) (get-h~ alternate) (get-width~ size) (get-width~ max))
    (fit (get-v~ pos) (get-v~ alternate) (get-height~ size) (get-height~ max))))


(definition public (scalar-product a <Point> b <Point>)
  (+ (* (get-h~ a) (get-h~ b)) (* (get-v~ a) (get-v~ b))))


(definition public (distance start end)
  (norm (- end start)))


(definition public (line-distance point <Point> start <Point> end <Point>)
  (let ((divider (sqrt (+ (sqr (- (get-h~ start) (get-h~ end)))
                          (sqr (- (get-v~ start) (get-v~ end)))))))
    (if (= divider 0)
        {}
      (abs
        (/ (scalar-product (new Point (- (get-h~ point) (get-h~ start)) (- (get-v~ point) (get-v~ start)))
                           (new Point (- (get-v~ end) (get-v~ start)) (- (get-h~ start) (get-h~ end))))
           divider)))))


;; For any questions, call Stephane!
;; divide delta into count parts, but since we're doing integer maths...
;; constraints: must be reversible, transitive and commutative
;; reversible: (f w d N) + (f w+d -d N) == no change == all zeroes
;; transitive: (f w a N) + (f w+a b N) == (f w a+b N)
;; 
;; forex: (resize-parts 7 1 3) returns (0 1 0)
;; because 7 is split (3 2 2) while 8 is split (3 3 2)
;;
;; the original definition didn't make this clear, nor does this one
(definition public (resize-parts size delta count)
  (let* ((offset (if (< delta 0) count 0))
         (base (quotient (- delta offset) count))
         (extra (+ (modulo delta count) offset))
         (parity (modulo size count))
         (start (modulo (+ parity count) count))
         (end (+ start extra -1))
         (end2 (- end count)))
    (map (function dynamic (n)
           (+ base (if (or (between? n start end) (<= n end2)) 1 0)))
         (naturals 0 count))))


(definition public (scale shape sc)
  (typecase shape
    ((Point)
     (let ((h <fx> (get-h~ shape))
           (v <fx> (get-v~ shape)))
       (new Point (round (* h sc))
            (round (* v sc)))))
    ((Dimension)
     (let ((width <fx> (get-width~ shape))
           (height <fx> (get-height~ shape)))
       (new Dimension (round (* width sc))
            (round (* height sc)))))
    ((Rect)
     (let ((left <fx> (get-left~ shape))
           (top <fx> (get-top~ shape))
           (right <fx> (get-right~ shape))
           (bottom <fx> (get-bottom~ shape)))
       (new Rect (round (* left sc))
            (round (* top sc))
            (round (* right sc))
            (round (* bottom sc)))))
    ((Number)
     (round (* shape sc)))))


(definition public (scale-factor outer inner)
  (/ outer inner))


(definition public (get-area size)
  (* (get-width~ size) (get-height~ size)))


;;;
;;;; Iterate
;;;


(definition public (iterate-cells top-left bottom-right start direction proc)
  (let* ((next (case direction
                 ((forward) next-cell)
                 ((backward) previous-cell)))
         (advance (function dynamic (cell) (next cell top-left bottom-right 'horizontal)))
         (cell (advance (either start (case direction
                                        ((forward) top-left)
                                        ((backward) bottom-right))))))
    (while cell
      (proc cell)
      (set! cell (advance cell)))))


(definition (previous-cell cell min-cell max-cell direction)
  (case direction
    ((vertical) (let ((info (loop-cell (get-col~ cell) (get-row~ cell) (get-col~ max-cell) (get-row~ max-cell) (get-col~ min-cell) (get-row~ min-cell) -1 >)))
                  (when info
                    (receive (major minor) info
                      (new Cell minor major)))))
    ((horizontal) (let ((info (loop-cell (get-row~ cell) (get-col~ cell) (get-row~ max-cell) (get-col~ max-cell) (get-row~ min-cell) (get-col~ min-cell) -1 >)))
                    (when info
                      (receive (major minor) info
                        (new Cell major minor)))))))


(definition (next-cell cell min-cell max-cell direction)
  (case direction
    ((vertical) (let ((info (loop-cell (get-col~ cell) (get-row~ cell) (get-col~ min-cell) (get-row~ min-cell) (get-col~ max-cell) (get-row~ max-cell) 1 <)))
                  (when info
                    (receive (major minor) info
                      (new Cell minor major)))))
    ((horizontal) (let ((info (loop-cell (get-row~ cell) (get-col~ cell) (get-row~ min-cell) (get-col~ min-cell) (get-row~ max-cell) (get-col~ max-cell) 1 <)))
                    (when info
                      (receive (major minor) info
                        (new Cell major minor)))))))


;; caveat: step must be +1 or -1
(definition (loop-cell major minor start-major start-minor end-major end-minor step test)
  (cond ((test major start-major) (values start-major start-minor))
        ((test end-major major) {})
        ((test minor start-minor) (values major start-minor))
        ((test minor end-minor) (values major (+ minor step)))
        ((test major end-major) (values (+ major step) start-minor))
        (else {})))


;;;
;;;; Output
;;;


(definition public (output-header title printer (language: language 'jazz) (system: system {}) (license: license {}) (author: author {}) (copyright: copyright {}) (contributors: contributors '()) (end-proper?: end-proper? #t))
  (with-printer printer
    (function dynamic (printer)
      (let* ((system (either system (system-title~ (get-process))))
             (system-padding (make-string (length system) #\=))
             (comment (case language ((jazz) ";;;") ((cpp/java) "//")))
             (toplevel-comment (case language ((jazz) ";;;;") ((cpp/java) "///"))))
        (format printer #"{a}=={a}=={%}"# comment system-padding)
        (format printer #"{a}  {a}{%}"# comment system)
        (format printer #"{a}=={a}=={%}"# comment system-padding)
        (format printer #"{a}{%}"# comment)
        (format printer #"{a} {a}{%}"# toplevel-comment title)
        (format printer #"{a}"# comment)
        (case license
          ((jazzscheme)
           (format printer "{%}")
           (format printer #"{a}  The contents of this file are subject to the Mozilla Public License Version{%}"# comment)
           (format printer #"{a}  1.1 (the "License"); you may not use this file except in compliance with{%}"# comment)
           (format printer #"{a}  the License. You may obtain a copy of the License at{%}"# comment)
           (format printer #"{a}  http://www.mozilla.org/MPL/{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Software distributed under the License is distributed on an "AS IS" basis,{%}"# comment)
           (format printer #"{a}  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License{%}"# comment)
           (format printer #"{a}  for the specific language governing rights and limitations under the{%}"# comment)
           (format printer #"{a}  License.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  The Original Code is JazzScheme.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  The Initial Developer of the Original Code is {a}.{%}"# comment author)
           (format printer #"{a}  Portions created by the Initial Developer are Copyright (C) {a}{%}"# comment copyright)
           (format printer #"{a}  the Initial Developer. All Rights Reserved.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Contributor(s):{%}"# comment)
           (for-each (function dynamic (contributor)
                       (format printer #"{a}    {a}{%}"# comment contributor))
                     contributors)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  Alternatively, the contents of this file may be used under the terms of{%}"# comment)
           (format printer #"{a}  the GNU General Public License Version 2 or later (the "GPL"), in which{%}"# comment)
           (format printer #"{a}  case the provisions of the GPL are applicable instead of those above. If{%}"# comment)
           (format printer #"{a}  you wish to allow use of your version of this file only under the terms of{%}"# comment)
           (format printer #"{a}  the GPL, and not to allow others to use your version of this file under the{%}"# comment)
           (format printer #"{a}  terms of the MPL, indicate your decision by deleting the provisions above{%}"# comment)
           (format printer #"{a}  and replace them with the notice and other provisions required by the GPL.{%}"# comment)
           (format printer #"{a}  If you do not delete the provisions above, a recipient may use your version{%}"# comment)
           (format printer #"{a}  of this file under the terms of any one of the MPL or the GPL.{%}"# comment)
           (format printer #"{a}{%}"# comment)
           (format printer #"{a}  See www.jazzscheme.org for details."# comment)))
        (when end-proper?
          (format printer "{%}"))))))


(definition public (output-section title printer (language: language 'jazz) (level: level 0))
  (let ((comment (case language ((jazz) ";;;") ((cpp/java) "//")))
        (toplevel (case language ((jazz) ";;;;") ((cpp/java) "///")))
        (extra (case language ((jazz) "") ((cpp/java) (make-string (+ (length title) 4) #\-)))))
    (format printer "{%}{%}")
    (format printer "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format printer "{_ :v}{a} {a}{%}" (* level 2) toplevel title)
    (format printer "{_ :v}{a}{a}{%}" (* level 2) comment extra)
    (format printer "{%}{%}")))


;;;
;;;; Arguments
;;;


(definition public (require-argument key)
  (unimplemented 'require-argument)
  @command-argument
  (either (command-argument key)
          (error "Mandatory argument /{a} was not found in command line:{%}{a}" key (command-line))))


(definition public (argument/property arg prop)
  (unimplemented 'argument/property)
  @command-argument
  (either (command-argument arg)
          (get-system-property prop)))


(definition public (require-argument/property arg prop)
  (unimplemented 'require-argument/property)
  @command-line
  (either (argument/property arg prop)
          (error "Mandatory argument /{a} was not found on command line or in properties:{%}{a}" arg (command-line))))


(definition public (boolean-argument/property arg prop default)
  (let ((value (argument/property arg prop)))
    (if (not value)
        default
      value)))


(definition public (integer-argument/property arg prop)
  (let ((str/int (argument/property arg prop)))
    (when str/int
      (if (integer? str/int)
          str/int
        (parse-integer str/int)))))


(definition public (file-argument/property arg prop extension)
  (let ((str (argument/property arg prop)))
    (when str
      (make-file str arg extension))))


(definition public (require-file-argument/property arg prop extension)
  (make-file (require-argument/property arg prop) arg extension))


(definition (make-file str arg extension)
  (unimplemented 'make-file)
  @Pathname
  (let ((file (new File (tokenise str))))
    (if (/= (get-extension~ file) extension)
        (error "Argument /{a} is not of the expected .{a} type in command line:{%}{a}" arg extension (command-line))
      file)))


(definition public (directory-argument/property arg prop)
  (let ((str (argument/property arg prop)))
    (when str
      (make-directory str))))


(definition public (require-directory-argument/property arg prop)
  (make-directory (require-argument/property arg prop)))


(definition (make-directory str)
  (unimplemented 'make-directory)
  @Pathname
  (new Directory (tokenise str)))


(definition public (host-argument/property arg prop)
  (unimplemented 'host-argument/property)
  @Host
  (let ((name (argument/property arg prop)))
    (when name
      (new Host name: name))))


(definition public (port-argument/property arg prop)
  (argument/property arg prop))


;;;
;;;; Preferences
;;;


(definition public (get-preferences name (error?: error? #t))
  (let* ((process (get-process))
         (root (get-preferences-root~ process)))
    (if (not root)
        (when error?
          (error "Could not find preferences"))
      (if (not name)
          root
        (either (find-component~ root name)
                (when error?
                  (error "Could not find preferences: {t}" name)))))))


(definition public (set-preference preferences property value)
  (let ((designer (get-preferences-designer~ (get-process))))
    (set-property~ designer preferences property value)))


(definition public (sort-case-sensitive?)
  (let ((pref (get-preferences '(interface tree) error?: #f)))
    (and pref (get-sort-case-sensitive?~ pref))))


(definition public (sort-predicates)
  (if (sort-case-sensitive?)
      (values = < >)
    (values ci= ci< ci>)))


(definition public (sort-predicate name)
  (let ((case-sensitive? (sort-case-sensitive?)))
    (case name
      ((equal)         (if case-sensitive? =  ci=))
      ((smaller)       (if case-sensitive? <  ci<))
      ((smaller/equal) (if case-sensitive? <= ci<=))
      ((greater)       (if case-sensitive? >  ci>))
      ((greater/equal) (if case-sensitive? >= ci>=))
      ((compare)       (if case-sensitive? compare ci-compare))
      (else (error "Unknown sort predicate: {t}" name)))))


;;;
;;;; Input/Output
;;;


(definition public (backup-file file)
  (new-unique-file~ (get-parent~ file) (format "{a}.back.{a}" (get-base~ file) (get-extension~ file)) separator: {}))


(definition public (fail-safe-save file proc)
  (unimplemented 'fail-safe-save)
  @unwind-protect
  (let ((temp (clone-file~ file "tmp"))
        (back (backup-file file))
        (completed? #f))
    (unwind-protect
        (begin
          (proc temp)
          (set! completed? #t))
      (cond ((not completed?)
             (delete-file~ temp error?: #f))
            ((exists?~ file)
             (move-pathname~ file back)
             (move-pathname~ temp file)
             (delete-file~ back))
            (else
             (move-pathname~ temp file))))))


;;;
;;;; External
;;;


(definition public (read-tab-delimited file)
  (call-with-input-file file
    (lambda (reader)
      (let ((tab (coerce (list #\tab) String))
            (fact (new List-Factory))
            (done? #f))
        (while (not done?)
          (let ((line (read-line reader)))
            (if (not line)
                (set! done? #t)
              (let ((values (split line tab)))
                (put~ fact (map patch-for-excel values))))))
        (get-output~ fact)))))


(definition (patch-for-excel line)
  (if (and (starts-with? line "\"")
           (ends-with? line "\""))
      (subseq line 1 (- (length line) 1))
    line))


(definition public (convert-tab-delimited->jml input parser)
  (unimplemented 'convert-tab-delimited->jml)
  @JML
  (let* ((output (new-file~ (get-parent~ input) (format "{a}.jml" (get-base~ input))))
         (content (read-tab-delimited input))
         (jml (parser content))
         (pref (new JML-Preferences))
         (parser (new JML-Parser preferences: pref))
         (jml (parse~ parser jml)))
    (with-closed ((printer (new File-Printer output)))
      (set-printer-use-utf8? printer #t)
      (pretty-print~ jml printer))
    (user-message "{a} converted to {a}" (get-name~ input) (get-name~ output))
    (let ((appl (get-application)))
      (verify-reload~ appl output))))


(definition public (save-tab-delimited content file)
  (unimplemented 'save-tab-delimited)
  @File-Printer
  (with-closed ((printer (new File-Printer file)))
    (for-each (function dynamic (line)
                (let ((first? #t))
                  (for-each (function dynamic (text)
                              (if first?
                                  (set! first? #f)
                                (format printer "{&}"))
                              (format printer "{a}" text))
                            line))
                (format printer "{%}"))
              content)))


;;;
;;;; Message
;;;


(definition public (system-error id)
  (unimplemented 'system-error)
  @unimp
  (error "System error {a}" (present-system-message id)))

@could-be-removed
(definition public (present-system-message id)
  (format "(#x{x}){? : {a}~}"
    id
    (format-system-message id)))


(definition public (present-winerror)
  (unimplemented 'present-winerror)
  @winerror
  (present-system-message (winerror)))


;;;
;;;; WinHelp
;;;


(definition public (winhelp winhelp-file entry)
  (unimplemented 'winhelp)
  @threads
  (WinHelp (get-toplevel-hwnd) (parse~ winhelp-file) HELP_KEY entry))


;;;
;;;; Listeners
;;;


(definition public (add-listener listener lst)
  (cons listener lst))


(definition public (remove-listener listener lst)
  (if (typed? listener 'Handler)
      (remove! listener lst)
    (remove! listener lst test: listener-target?)))


(definition public (listener? object lst)
  (member? object lst test: listener-target?))


(definition (listener-target? object listener)
  (eq? object (get-target~ listener)))


;;;
;;;; Document
;;;


(definition public (file-document file)
  (unimplemented 'file-document)
  @get-application
  (let* ((appl (get-application))
         (frame (find-document~ appl file)))
    (when frame
      (get-guest~ frame))))


;;;
;;;; Resource
;;;


(definition public (int-resource resource)
  (unimplemented 'int-resource)
  @make-int-resource
  (if (integer? resource)
      (make-int-resource resource)
    (get-name~ resource)))


;;;
;;;; Message
;;;


(definition public (user-message obj . rest)
  (let ((appl (get-application)))
    (when appl
      (set-status-message~ appl (if (is? obj Locales) obj (apply format obj rest))))))


(definition public (clear-user-message)
  (user-message ""))


;;;
;;;; Error
;;;


(definition public (disabled-functionnality)
  (error "Sorry, this functionnality is temporarily disabled"))


(definition public (must-implement definition-name (what {}))
  (error "The {a} definition must be implemented for {a} to work correctly"
         definition-name
         (either what "this application")))


;;;
;;;; Unicode
;;;


(definition public (sequence->string seq)
  (let* ((size   (length seq))
         (length (- (quotient size 2) 1))
         (string (make-string length)))
    (for-each (function dynamic (i)
                (let* ((n (* i 2))
                       (c (make-word (element seq n) (element seq (+ n 1)))))
                  (set-element! string i c)))
              (naturals 0 length))
    string))


(definition public (string->sequence string type)
  (let* ((length (length string))
         (size   (* (+ length 1) 2))
         (seq    (new type size: size)))
    (for-each (function dynamic (i)
                (let ((n (* i 2))
                      (c (char->integer (element string i))))
                  (set-element! seq n (lochar c))
                  (set-element! seq (+ n 1) (hichar c))))
              (naturals 0 length))
    (set-element! seq (- size 2) 0)
    (set-element! seq (- size 1) 0)
    seq))


;;;
;;;; Data
;;;


(macro public (datacontainer form)
  (bind (name . fields) form
    (let ((table (generate-symbol "table"))
          (rank 1))
      `(class ,name extends Data-Container
         ,@(map (function dynamic (field)
                  (increase! rank)
                  `(attribute (:location (,name ,rank))
                     (slot ,field)))
                fields)
         (definition (initialize ,table ,@fields)
           (nextmethod ,table)
           ,@(map (function dynamic (field)
                    (let ((access (string->symbol (format "{a}~self" field))))
                      `(set! ,access ,field)))
                  fields))))))


(definition public (iterate-hierarchical-data proc data size key)
  (unless (not data)
    (let* ((id-row (car data))
           (id (key id-row))
           (id-data data)
           (id-size 1)
           (scan (cdr data))
           (scan-count 1))
      (while (< scan-count size)
        (let* ((scan-row (car scan))
               (scan-id (key scan-row)))
          (when (/= scan-id id)
            (proc id-row id-data id-size)
            (set! id-row scan-row)
            (set! id scan-id)
            (set! id-data scan)
            (set! id-size 0))
          (increase! id-size)
          (set! scan (cdr scan))
          (increase! scan-count)))
      (proc id-row id-data id-size))))


(definition public (collect-hierarchical-data proc data size key)
  (let ((fact (new List-Factory)))
    (iterate-hierarchical-data
      (function dynamic (row data size)
        (let ((object (proc row data size)))
          (when object
            (put~ fact object))))
      data
      size
      key)
    (get-output~ fact)))


;; quicky ugly
(definition public (sorted-hierarchical-data proc data size key sort-test sort-key)
  (collect (function dynamic (data)
             (proc (first data) (second data) (third data)))
           (sort sort-test (collect-hierarchical-data list data size key)
             key: (function dynamic (data)
                    (sort-key (first data))))))


;;;
;;;; Data Source
;;;


@convert-and-relocate
(definition public (request-data-source (provider: provider {}))
  (receive (process? dialog) (new-dialog (autoload 'Data-Source-Chooser) host-visible?: #f)
    (let ((manager (get-guest~ dialog)))
      (when provider
        (set-provider~ manager (external-name~ provider)))
      (process-modal~ dialog))))


;;;
;;;; Time
;;;


(definition public 2-Seconds-Tolerance
  20000000)


(definition (different-times? time1 time2 (tolerance: tolerance 2-Seconds-Tolerance))
  (> (abs (- (get-elapse~ time1) (get-elapse~ time2)))
     tolerance))


(definition (different-file-content? file1 file2)
  (call-with-input-file file1
    (lambda (input1)
      (call-with-input-file file2
        (lambda (input2)
          (or (/= (get-size~ input1)
                  (get-size~ input2))
              (/= (read-content-string input1)
                  (read-content-string input2))))))))


(definition (different-file-content-no-whitespace? file1 file2)
  (call-with-input-file file1
    (lambda (input1)
      (call-with-input-file file2
        (lambda (input2)
          (not (wi= (read-content-string input1)
                    (read-content-string input2))))))))


(definition public (present-hour/minutes hour minutes)
  (format "{a width: 2 justify: :right padding: #\\0}:{a width: 2 justify: :right padding: #\\0}"
    hour
    minutes))


;;;
;;;; Message Box
;;;


(definition (system-message text . rest)
  (debug text))


(definition public (message-box text . rest)
  (let ((process (get-process)))
    (if (not process)
        (apply system-message text rest)
      (show-box~ process text rest))))


;;;
;;;; Message Receive
;;;

;; This seems almost platform independent. Needs to adapt to gambit.

;; This definition relies on the fact that the conservative garbage collector will find
;; the address of the result somewhere on the stack or in a register thus protecting it
(definition public (receive-primary proc)
  (proc)
  @JZ-RECEIVE-NULL
  (if (primary-thread?)
      (proc)
    (address-object-unsafe (send-message~ Messenger JZ_RECEIVE (object-address proc) NULL))))


(definition public (receive-primary-with-error proc)
  (values (proc) {} {})
  @print-stack
  ;; a quick solution to get accurate debug info back to the calling thread
  (receive (result err stack)
      (receive-primary
        (function dynamic ()
          (let ((result)
                (error {})
                (stack {}))
            (call-with-catch Error
                  (function dynamic (err)
                    (set! error err)
                    (set! stack (print-stack :string)))
                (function dynamic (err)
                  (values {} error stack))
              (function dynamic ()
                (values (proc) {} {}))))))
    (if (not err)
        result
      ;; a quick patch of putting everything in the error message
      (let ((printer (new String-Printer)))
        (format printer "{a}{%}{%}{a}"
          (get-message~ err)
          stack)
        (error "{a}" (get-output~ printer))))))


;;;
;;;; Command Argument
;;;


;; tofix : do in gambit
(definition public (command-argument string)
  #f))
