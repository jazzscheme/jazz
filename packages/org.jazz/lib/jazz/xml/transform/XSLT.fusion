;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; XSLT Module
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Dominique Boucher.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;;;
;;; Le compilateur de règles de transformation
;;;


(library XSLT jazz


@WAIT (
  
  
  (macro public (xsl-transformation form)
    (bind ((method-name document . params) . rules) form
      (expand-xsl-transformation method-name document params rules)))
  
  
  (macro public (xsl-rules arguments)
    (when (<= (length arguments) 1)
      (error "Not enough arguments to xsl-rules"))
    (let ((expr     (car arguments))
          (rules    (cdr arguments)))
      (expand-xsl-rules expr rules)))
  
  
  (macro public (>>xml arguments)
    `(begin
       ,@(map expand-replacement arguments)))
  
  
  (method public (expand-xsl-transformation method-name document params rules)
    `(method public (,method-name ,document ,@params)
       (or
        ,@(map (function (rule) 
                 (expand-rule rule document))
               rules))))
  
  
  (method public (expand-xsl-rules expr rules)
    (let ((node-var (generate-symbol)))
      `(let ((,node-var ,expr))
         (or
          ,@(map (function (rule)
                   (expand-rule rule node-var))
                 rules)))))

  
  (method (expand-rule rule node-var)
    (let* ((pattern     (car rule))
           (replacement (cdr rule))
           (variables   (collect-variables pattern)))
      `(let* (,@(map (function (var) `(,var ())) (collect-variables pattern)))
         (and ,(expand-pattern pattern node-var)
              (begin
                ,(expand-replacement-list replacement node-var)
                #t)))))
  
 
  ;;;
  ;;;; Pattern compiler
  ;;;
  
  
  (method (expand-pattern pattern node-var)
    (cond
     ((pattern-variable? pattern)
      `(begin (set! ,(variable->symbol pattern) ,node-var) #t))
     ((element? pattern)
      (expand-pattern-element pattern node-var))
    (else
      '#f)))
  
  
  (method (expand-pattern-element pattern node-var)
    (bind-values (tag attributes children) (destructure-pattern-element pattern)
      `(and (element? ,node-var)
            (eq? (element-tag ,node-var) ',tag)
            ,@(map (function (attr)
                     (expand-attribute-pattern attr node-var))
                   attributes)
            ,(expand-pattern-children children node-var))))
  

  (method (expand-attribute-pattern attr node-var)
    (let ((name  (car attr))
          (value (cadr attr)))
      (if (pattern-variable? value)
          `(begin (set! ,(variable->symbol value) (node-attribute ,node-var ',name)) #t)
        `(equal? (node-attribute ,node-var ',name) ,(cadr attr)))))
           
  
  (method (expand-pattern-children children node-var)
    (cond
     ((pattern-variable? children)
      `(begin (set! ,(variable->symbol children) (node-children ,node-var)) #t))
     ((list? children)
      (let ((children-var (generate-symbol)))
        `(let* ((,node-var ,node-var)
                (,children-var (node-children ,node-var)))
           (and (>= (length ,children-var) ,(length children))
                ,@(map (function (child)
                         `(begin
                            (set! ,node-var (car ,children-var))
                            (set! ,children-var (cdr ,children-var))
                            ,(expand-pattern child node-var)))
                       children)))))
     (else
      (error "invalid pattern" children))))
  
  
  (method (pattern-variable? object)
    (and (symbol? object)
         (= #\? (element (symbol->string object) 0))))
  
  
  (method (variable->symbol var)
    (let ((string (symbol->string var)))
      (string->symbol (subseq string 1 (length string)))))
  
 
  (method (collect-variables pattern)
    (typecase pattern
      ((Pair)    (union (collect-variables (car pattern))
                      (collect-variables (cdr pattern))))
      ((Symbol)  (if (pattern-variable? pattern)
                   (list (variable->symbol pattern))
                 '()))
      (else    '())))
  

  ;;;
  ;;;; Replacement compiler
  ;;;
  
  
  ;; Temporarely replaced by methods because of a problem
  ;; in the compiler where definition values of units loaded
  ;; from environments are not evaluated
  
  ;; (definition escape-xml-symbol 'xml>>)
  ;; (definition return-xml-symbol '>>xml)
  ;; (definition inject-xml-symbol '<-xml)
  
  
  (method (escape-xml-symbol)
    'xml>>)
  
  (method (return-xml-symbol)
    '>>xml)
  
  (method (inject-xml-symbol)
    '<-xml)
  
  
  (method (expand-replacement-list replacement-list node-var)
    `(let ((node ,node-var))
       ,@(map expand-replacement replacement-list)))
  
  
  (method (expand-replacement replacement)
    (cond
     ((string? replacement)            (expand-text-replacement replacement))
     ((pattern-variable? replacement)  (expand-variable-replacement replacement))
     ((escape-to-jazz? replacement)    (expand-escape-replacement replacement))
     ((inject-in-xml? replacement)     (expand-injection-replacement replacement))
     ((element? replacement)           (expand-element-replacement replacement))
     (else                             (error "invalid replacement!" replacement))))
  
  
  (method (expand-text-replacement string)
    `(text ,string))
  
  
  (method (expand-variable-replacement variable)
    `(text ,(variable->symbol variable)))
  

  (method (expand-injection-replacement replacement)
    `(text (->string (begin ,@(cdr replacement)))))
  
  
  (method (expand-escape-replacement replacement)
    `(begin ,@(cdr replacement)))
  
  
  (method (expand-element-replacement replacement)
    (bind-values (tag attributes children) (destructure-replacement-element replacement)
      `(begin
         (begin-element ',tag)
         ,@(map expand-attribute-replacement attributes)
         ,@(map expand-replacement children)
         (end-element ',tag))))
  
  
  (method (expand-attribute-replacement attribute)
    (let ((name (car attribute))
          (value (cadr attribute)))
      (cond
       ((pattern-variable? value)
        `(add-attribute ',name ,(variable->symbol value)))
       ((inject-in-xml? value)
        `(add-attribute ',name (->string (begin ,@(cdr value)))))
       ((string? value)
        `(add-attribute ',name ,value))
       (else
        (error "invalid attribute replacement")))))
  
  
  (method (escape-to-jazz? code)
    (and (pair? code) (eq? (car code) (escape-xml-symbol))))
  
  
  (method (inject-in-xml? code)
    (and (pair? code) (eq? (car code) (inject-xml-symbol))))
  
  
  ;;;
  ;;;; XML accessors
  ;;;
  
  
  (method (element? object)
    (and (pair? object) (symbol? (car object))))
  
  
  (method (attribute-list? object)
    (and (list? object)
         (every? (function (object)
                   (and (pair? object)
                        (symbol? (car object))))
                 object)))
  

  (method (destructure-pattern-element element)
    (destructure-element element pattern-attribute?))
  
  
  (method (destructure-replacement-element element)
    (destructure-element element replacement-attribute?))
  
  
  (method (destructure-element element attribute?)
    (let ((attrs/children (cdr element)))
      (if (and (pair? attrs/children)
               (list? (car attrs/children))
               (every? attribute? (car attrs/children)))
          (values (car element) (car attrs/children) (cdr attrs/children))
        (values (car element) '() attrs/children))))
  
  
  (method (pattern-attribute? object)
    (and (list? object)
         (= (length object) 2)
         (symbol? (car object))
         (or (string? (cadr object))
             (pattern-variable? (cadr object)))))
  
  
  (method (replacement-attribute? object)
    (and (list? object)
         (= (length object) 2)
         (symbol? (car object)))))
)