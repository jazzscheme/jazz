;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Test
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2006
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library test jazz


@w
(import (dev)
        (jazz.git)
        (jazz.jml)
        (jazz.library)
        (jazz.literals)
        (jazz.platform)
        (jazz.platform.windows)
        (jazz.ui)
        (jazz.ui.dialog)
        (jazz.ui.view)
        (jazz.ui.window)
        (jazz.utilities)
        (jedi)
        (test.a))


;;;
;;;; Types
;;;


(definition (yoo) <pair>
  '(a))


(definition (f aa <pair>)
  (let ((bb '(a))
        (cc '(a)))
    (let (iterate (dd '(a)) (ee '(a)))
      (let* ((ff '(a)))
        (letrec ((gg '(a)))
          (receive (hh <pair>) (values '(a))
            (debug (car aa) (car bb) (car cc) (car dd) (car ee) (car ff) (car gg) (car hh) (car (yoo)))
            (set! cc 2)
            (set! ee 3)))))))


@w
(definition (ff x <fx> y <fx>)
  (let ((a 2))
    (+ x y)
    (* x a)))


@inlining
(definition (f x)
  (nneq? x 2))


@inlining
(definition (g)
  (let ((a <A> (new A)))
    (set-aa~ a (+ (get-aa~ a) 1))
    (yoo~ a 2)))


@w
(class X extends Object
  
  (method (f a <fx> b <fx>)
    (/ (+ (* a b 2) 3) 5)))


@w (
(definition (yo x <fx> y <fx>)
  (+ x y))


(definition (f start <Cell> end <Cell>)
  (= (get-row~ start) (get-row~ end)))


(definition (ff start <Cell> end <Cell>)
  (= (get-row~ start) (get-row~ end)))


(definition public inline (perc part <fl> total <fl>) <fl>
  (* (/ part total) 100.0))


(class X extends Object
  
  (slot a <fx> initialize 2)
  
  (method (ff x) <fx>
    (set! a x)
    2)
  
  (method virtual (gg) <fx>
    3))


(class Y extends X)


(define yo <fx>
  2)

(definition yu <fl>
  2.3)


(definition (foo a)
  (set! yo 3)
  (set! yu 'a)
  (let ((x <X> (new X)))
    (set-a~ x "yo")))

(definition (goo <fx> a)
  a)

(definition (hoo)
  (receive (a <fx>) (values 2)
    a)))


;;;
;;;; NEO
;;;


@w (
(class X extends Object
  
  (slot s)
  
  (definition (d)
    2)
  
  (method (f)
    (set! [s self] #f)
    3)
  
  (method virtual (g)
    5)
  
  (neomethod (f2 a . rest)
    (cons 'xf2 rest))
  
  (neomethod virtual (g2)
    'xg2)
  
  (method (foo)
    (d)
    (f)
    (g)))


;; see jazz.walk-dispatch
(let ((x (new X)))
  (debug (f2$ x 1))
  (debug (g2$ x)))


(interface I
  
  (neomethod virtual abstract (h2 a)))


(class Y extends X implements I
  
  (slot t)
  
  (method (g)
    7)
  
  (neomethod (g2)
    @w
    (nextmethod)
    (set! s #f)
    (set! [s self] #f)
    (set! t #f)
    (set! [t self] #f)
    (cons 'yg2 (nextmethod)))
  
  (neomethod (h2 a)
    'yh2))

(let ((x (new X)))
  (debug (f~ x)))


;; see jazz.walk-dispatch
(let ((x (new X)))
  (debug (f2$ x 1))
  (debug (g2$ x)))


(let ((y (new Y)))
  (debug (f2$ y 1))
  (debug (g2$ y))
  (debug (h2$ y 1))))


;;;
;;;; Git
;;;


@w(
(definition *jazz-repository*
  (new Git-Repository {Directory Root}))


(git-repository-set! *jazz-repository*)


(prepare-merge~ *jazz-repository* {Directory Native "C:" "Merge"}))


;;;
;;;; CFFI
;;;


@w(
(debug 'init1 (init1))

(debug 'scalar1 (scalar1 2))
(debug 'scalar2 (scalar2 3))
(debug 'scalar3 (scalar3 '(a)))

(let ((t1 (typ1 2 3))
      (t2 (typ2 2 3)))
  (debug 'typ1 t1 (foreign-tag t1) (still-obj-refcount t1))
  (debug 'typ2 t2 (foreign-tag t2) (still-obj-refcount t2))
  (gc)
  (debug 'typ3 (typ3 t1 t2)))

(let ((t4 (typ4 2 3))
      (t5 (typ5 2 3)))
  (debug 'typ4 t4 (foreign-tag t4) (still-obj-refcount t4))
  (debug 'typ5 t5 (foreign-tag t5) (still-obj-refcount t5))
  (gc)
  (debug 'typ6 (typ6 t4 t5)))

(debug 'constant (list ca cb))
(debug 'enumeration (list ea eb ec))

(let ((s1 (make-S1)))
  (debug 's1 s1 (foreign-tag s1) (still-obj-refcount s1))
  (debug 'struct1a (struct1a s1))
  (debug 'struct1c (struct1c s1)))

(debug 'func1 (func1)))


;;;
;;;; Iteration
;;;


@w (
(definition (iter-list lst proc)
  (when lst
    (proc (car lst))
    (iter-list (cdr lst) proc)))


(definition (iter-node node proc)
  (letrec ((iterate
             (function dynamic (node)
               (proc node)
               (for-each iterate (get-children~ node)))))
    (iterate node)))


(definition (iter obj proc)
  (cond ((or (null? obj) (pair? obj)) (iter-list obj proc))
        ((is? obj JML-Node) (iter-node obj proc))))


(definition (foldl-list x f s)
  (if (not x)
      s
    (foldl-list (cdr x) f (f (car x) s))))


(definition (foldr-list x f s)
  (if (not x)
      s
    (f (car x) (foldr-list (cdr x) f s))))


(definition (foldl-node x f s)
  (foldl (get-children~ x)
         (function dynamic (c s)
           (foldl-node c f s))
         (f x s)))


(definition (foldr-node x f s)
  )


(definition (foldl-component x f s)
  (foldl (get-children~ x)
         (function dynamic (c s)
           (foldl-component c f s))
         (f x s)))


(definition (foldr-component x f s)
  )


(definition (foldl x f s)
  (cond ((or (null? x) (pair? x)) (foldl-list x f s))
        ((is? x JML-Node) (foldl-node x f s))
        ((is? x Component) (foldl-component x f s))))


(definition (foldr x f s)
  (cond ((or (null? x) (pair? x)) (foldr-list x f s))
        ((is? x JML-Node) (foldr-node x f s))
        ((is? x Component) (foldr-component x f s))))


(definition (iter-map proc obj)
  (let ((fact (new List-Factory)))
    (iter obj
          (function (x)
            (put~ fact (proc x))))
    (get-output~ fact)))


(definition (iter-linearize obj)
  (iter-map identity obj))


(definition (fold-map proc obj)
  (foldr obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (foldl-map proc obj)
  (foldl obj
         (function (x lst)
           (cons (proc x) lst))
         {}))


(definition (fold-linearize obj)
  (fold-map identity obj))


(definition (fold x f s)
  (cond ((or (null? x) (pair? x)) (foldl-list x f s))
        ((is? x JML-Node) (fold-node x f s))
        ((is? x Component) (fold-component x f s))))


(definition (fold-node x f s)
  (let ((ps (f x s)))
    (for-each (function dynamic (c)
                (fold-node c f ps))
              (get-children~ x))
    ps))


(definition (fold-component x f s)
  (let ((ps (f x s)))
    (for-each (function dynamic (c)
                (fold-component c f ps))
              (get-children~ x))
    ps))


(definition (component->jml x)
  (fold x
        (function dynamic (c p)
          (new JML-Element p (identifier-name (type-name (class-of c))) properties: (list 'name (get-name~ c) 'position (get-position~ c) 'size (get-size~ c) 'serial (object->serial-number c))))
        {}))


(definition (pprint-component x)
  (pretty-print~
    (component->jml x)
    :console))


(definition (ppc x)
  (pprint-component x))


(definition (test x)
  (ppc x)))


;;;
;;;; NoNextMethod
;;;


@no-nextmethod-seems-broken (
(class X extends Object
  
  (method virtual (f)
    (nextmethod)))

(f~ (new X)))


;;;
;;;; Explore
;;;


@ok
(let ((e (explore "Hello" direction: 'backward)))
  (debug e))


@ok
(debug (find #\period "a.b.c" reversed?: true return: 'position))


;;;
;;;; To Fix
;;;


@to-fix (
(class A extends Object
  
  (method (f)
    2))

(class B extends A
  
  (method (f)
    3))


(let ((a (new A))
      (b (new B)))
  (debug (f~ a))
  (debug (f~ b))))


;;;
;;;; Property
;;;


@ok
(class A extends Object
  
  (property a setter set-aaa)
  
  (method (set-aaa v)
    (set! a (+ v v v)))
  
  (method (foo)
    a
    (set! a 2)))

@ok
(let ((a (new A)))
  (let ((p (category-field A 'a)))
    ((property-setter p) a 2)
    (debug a p ((property-getter p) a))))


;;;
;;;; Loop
;;;


@ok
(definition (test)
  (loop (for (property value) in-properties '(a: 2 b: 3 c: 5))
        (do (debug property value))))


;;;
;;;; Component
;;;


@ok
(class A extends Component
  
  (form
    (<install> visible?: #t)))

@ok
(class B extends Component
  
  (form
    (<install> visible?: #f)))

@ok
(let ((a (new A))
      (b (new B)))
  (debug a (get-visible?~ a))
  (debug b (get-visible?~ b)))


;;;
;;;; File
;;;


@done
(let ((d (new Directory '(test "Jazz"))))
  (let ((f (new-file~ d "yo.txt"))
        (t {File Native "C:" "Jazz" "dev" "jazz" "Todo.txt"}))
    (debug d f (parse~ f) (exists?~ f) (exists?~ {Directory Native "C:" "Jazz"}))))


;;;
;;;; Reader
;;;


@done
(with-closed ((r (new File-Reader "a.scm")))
  (debug (read-char r))
  (debug (read-delimited r "yo" #\)))
  (debug (read-lines r)))


;;;
;;;; Printer
;;;


@done
(with-closed ((p (new File-Printer "b.scm")))
  (format p "Hello {s}" 'les)
  (display #\a p)
  (write "yo" p))


;;;
;;;; Format
;;;


@done
(with-closed ((p (new String-Printer)))
  (debug (format "hello"))
  (format p "Hello {a width: 10} {s} {l}{%}" "a" "b" '(7 "yo" 9))
  (debug (get-output~ p))
  (debug (= (format "{?foo{a}bar{c}~}ZZZ{a}" {} #\* 'yyy) "ZZZyyy"))
  (debug (= (format "{?foo{a}bar{c}~}ZZZ{a}" 'hello #\* 'yyy) "foohellobar*ZZZyyy"))
  (debug (= (format "{?:foo{a}bar{c}~}ZZZ{a}" #f {} {} 'yyy) "ZZZyyy"))
  (debug (= (format "{?:foo{a}bar{c}~}ZZZ{a}" #t 'hello #\* 'yyy) "foohellobar*ZZZyyy")))


;;;
;;;; Axis
;;;


@done
(let ((a (new Axis)))
  (debug a (length a))
  (axis-add a 'a)
  (axis-add a 'b)
  (axis-add a 'c)
  (debug a (length a) (element a 1)))


;;;
;;;; Subseq
;;;


@done
(let* ((s "Hello")
       (x (subseq s 2 4))
       (y (subseq! s 2 5)))
  (debug (new Subseq 1 2 3) s x y)))
