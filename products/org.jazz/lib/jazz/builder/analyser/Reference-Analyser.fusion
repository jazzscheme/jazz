;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Finding References
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.analyser.Reference-Analyser jazz


(import (jazz.builder)
        (jazz.jml)
        (jazz.library)
        (jazz.utilities))


(class Reference-Analyser extends Object)


@WAIT


(class Reference-Analyser extends Analyser
      
  
  ;; In the same fashion than a unit has to be completly loaded
  ;; before some its code starts executing possibly triggering other
  ;; units into being loaded, this code preserves toplevel references
  ;; so they can be loaded only when the current unit is done loading.


  (slot project         initialize {})
  (slot environment     initialize {})
  (slot extra-modules   initialize '())
  (slot debugged?       initialize false)
  (slot include-path?   initialize true)
  (slot current-path    initialize '())
  (slot unvisited       initialize null)
  (slot unvisited-forms initialize null)
  (slot states          initialize (new-map))   ; null, :unvisited or (path ...)
  (slot resources       initialize (new-hashtable :equal?))

  
  (method (initialize . rest)
    (bind-keywords ((project null) (units-map null) (extra-modules null) (debugged? false) (include-path? true)) rest
      (nextmethod)
      (setup project units-map extra-modules debugged? include-path?)))
  
  
  (method (setup prj units-map modules dbg? path?)
    (set! project prj)
    (set! environment (new-environment (either units-map (new-map)) (new-walker self null literal-listener load-hook null null null form-hook toplevel-hook null (if path? define-hook null))))
    (set! extra-modules modules)
    (set! debugged? dbg?)
    (set! include-path? path?))
  
  
  (method (get-state name)
    (map-ref states name))
  
  
  (method (set-state name state)
    (map-set! states name state))


  (method public (find-references roots root-databases)
    (for-each walk-unit roots)
    (for-each walk-database root-databases)
    (walk-unvisited)
    (prog1 (values (collect-references include-path?) (collect-resources include-path?))
      (user-message "Done")))


  (method (walk-unit name . rest)
    (bind-optionals ((get? true)) rest
      (let ((state (get-state name)))
        (when (and (or (null? state) (eq? state :unvisited)) (in-manifest? name))
          (execute-primary
            (function ()
              (user-message "Walking {s}" name)))
          ;; This is a major patch... If debugged? (i.e. when exporting manifest) then use the old code
          ;; so that every unit gets included and we don't get walk errors.
          (if debugged?
              (begin
                (set-state name current-path)
                (when (and get? (or (null? project) (analyse-unit?~ project name extra-modules)))
                  (with-restart
                    (function dynamic ()
                      (get-unit name environment))
                    (function dynamic ()
                      (environment-reset environment name)))))
            (if (not get?)
                (set-state name current-path)
              (set-state name null)
              (when (or (null? project) (analyse-unit?~ project name extra-modules))
                (set-state name current-path)
                (with-restart
                  (function dynamic ()
                    (get-unit name environment))
                  (function dynamic ()
                    (environment-reset environment name))))))))))
  
  
  (method (walk-database database)
    (with-closed ((reader (new File-Reader database :context self :literal-listener literal-listener)))
      (let ((jml (read reader)))
        (walk-jml-form null jml))))
  
  
  (method (walk-unvisited)
    (while (or unvisited unvisited-forms)
      (cond (unvisited
             (bind (name . path) (car unvisited)
               (set! unvisited (cdr unvisited))
               (let ((old current-path))
                 (set! current-path path)
                 (walk-unit name)
                 (set! current-path old))))
            (else
             (bind (unit . jml) (car unvisited-forms)
               (set! unvisited-forms (cdr unvisited-forms))
               (walk-jml-form unit jml))))))
  
  
  (method public (push-reference name)
    (unless (get-state name)
      (set-state name :unvisited)
      (set! unvisited (cons (cons name current-path) unvisited))))
  
  
  (method public (push-form form)
    (set! unvisited-forms (cons form unvisited-forms)))
  
  
  (definition Resource-Models
    '(Bitmap-Resource Icon-Resource Cursor-Resource Sound-Resource))
  
  
  (method (literal-listener literal)
    (let ((model-name (type-name (class-of literal))))
      (when (in-manifest? model-name)
        (push-reference model-name))
      (when (memq? model-name Resource-Models)
        (resource-listener literal model-name)))
    (walk-literal~ literal self))


  (method (resource-listener literal model-name)
    (let* ((name (get-name~ literal))
           (model (autoload model-name))
           (type (resource-type~ model))
           (key (cons type name)))
      (unless (hash-ref resources key)
        (hash-set! resources key current-path))))
  

  (method (load-hook param unit-name entering?)
    (cond (entering?
           (set! current-path (cons unit-name current-path))
           (walk-unit unit-name false))
          (else
           (set! current-path (cdr current-path)))))


  (method (form-hook unit param form)
    (when (eq? (car form) 'form>>)
      (let ((jml (cadr form)))
        (push-form (cons unit jml)))))
  
  
  (method (walk-jml-form unit jml)
    (let ((form (jml->form jml)))
      (letrec ((walk-node
                (function dynamic (form toplevel?)
                  (let ((model-name (get-model-name~ form)))
                    (if (and toplevel? unit (eq? model-name 'install))
                        (walk-form~ (metaclass-instance unit) self form)
                      (when (and model-name (in-manifest? model-name))
                        (push-reference model-name)
                        (let ((class (autoload model-name)))
                          (walk-form~ class self form)))))
                  (for-each (function dynamic (child)
                              (walk-node child false))
                            (get-children~ form)))))
        (walk-node form true))))
  

  (method (toplevel-hook param name)
    (push-reference name))
  

  (method (define-hook param name entering?)
    (cond (entering?
           (set! current-path (cons name current-path)))
          (else
           (set! current-path (cdr current-path)))))
  
  
  ;;;
  ;;;; Results
  ;;;
  
  
  (method (collect-references include-path?)
    (let ((list null))
      (for-each-map (function dynamic (name path)
                      (when path
                        (set! list (cons (if include-path? (cons name path) name) list))))
                    states)
      list))
  
  
  (method (collect-resources include-path?)
    (let ((list null))
      (for-each-hash (function dynamic (key path)
                       (when path
                         (set! list (cons (if include-path? (cons key path) key) list))))
                     resources)
      list))))
