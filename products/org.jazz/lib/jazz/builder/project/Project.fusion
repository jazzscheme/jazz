;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Projects
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.builder.project.Project jazz


(import (jazz.builder)
        (jazz.jml)
        (jazz.library)
        (jazz.library.shell)
        (jazz.ui.activity)
        (jazz.utilities))


(class Project extends Product uses (Utilities System WinDef)
  
  
  ;; A bug that was fixed is back `@#$@`#$% a free symbol will crash the compile if threaded
  (definition Threaded-Build?
    false)
  

  (property icon                initialize {}       getter get-icon                setter set-icon)
  (property owner               initialize {}       getter get-owner               setter set-owner)
  (property copyright           initialize {}       getter get-copyright           setter set-copyright)
  (property version             initialize {}       getter get-version             setter set-version)
  (property type                initialize 'jazz    getter get-type                setter set-type)
  (property setup-class         initialize {}       getter get-setup-class         setter set-setup-class)
  (property application-class   initialize {}       getter get-application-class   setter set-application-class)
  (property uses-bin-directory? initialize true     getter get-uses-bin-directory? setter set-uses-bin-directory?)
  (property bind-settings?      initialize true     getter get-bind-settings?      setter set-bind-settings?)
  (property bind-properties?    initialize true     getter get-bind-properties?    setter set-bind-properties?)
  (property bind-libraries?     initialize true     getter get-bind-libraries?     setter set-bind-libraries?)
  (property bind-imports?       initialize true     getter get-bind-imports?       setter set-bind-imports?)
  (property protected?          initialize false    getter get-protected?          setter set-protected?)
  (property output-type         initialize 'windows getter get-output-type         setter set-output-type)
  (property output-name         initialize {}       getter get-output-name         setter set-output-name)
  (property anonymous-build     initialize {}       getter get-anonymous-build     setter set-anonymous-build)


  (slot unit-files)
  (slot dependencies-hashtable)
  (slot analyser-map            initialize (new-map))
  
  
  (form
    (<install>                                     catalog?: #f
      (<Project-Dependencies> name: dependencies)
      ;; Damn, we have a conceptual bug with the fact that has always annoyed me,
      ;; that a module is a project. Configurations do not make sense for modules...
      @wait
      (<Configurations>       name: configurations)))
  
  
  (method (finish rest)
    (nextmethod rest)
    (setup-project))
  
  
  (method (setup-project)
    (set! dependencies-hashtable (new-hashtable :eq?))
    (for-each (function dynamic (dependency)
                (let ((type-name (get-name~ dependency)))
                  (hash-set! dependencies-hashtable type-name dependency)))
              (project-dependencies)))


  (method (process-name)
    (project-application))


  ;;;
  ;;;; Access
  ;;;


  (method public (get-icon)
    icon)


  (method public (set-icon value)
    (set! icon value))


  (method public (get-owner)
    owner)


  (method public (set-owner value)
    (set! owner value))


  (method public (get-copyright)
    copyright)


  (method public (set-copyright value)
    (set! copyright value))


  (method public (get-version)
    version)


  (method public (set-version value)
    (set! version value))


  (method public (get-type)
    type)


  (method public (set-type value)
    (set! type value))


  (method public (get-setup-class)
    setup-class)


  (method public (set-setup-class value)
    (set! setup-class value))


  (method public (get-application-class)
    application-class)


  (method public (set-application-class value)
    (set! application-class value))


  (method public (get-uses-bin-directory?)
    uses-bin-directory?)


  (method public (set-uses-bin-directory? flag)
    (set! uses-bin-directory? flag))


  (method public virtual (jazz-runtime?)
    false)


  (method public (get-bind-settings?)
    bind-settings?)


  (method public (set-bind-settings? flag)
    (set! bind-settings? flag))


  (method public (get-bind-libraries?)
    bind-libraries?)


  (method public (set-bind-libraries? flag)
    (set! bind-libraries? flag))


  (method public (get-bind-properties?)
    bind-properties?)


  (method public (set-bind-properties? flag)
    (set! bind-properties? flag))



  (method public (get-bind-imports?)
    bind-imports?)


  (method public (set-bind-imports? flag)
    (set! bind-imports? flag))


  (method public (get-protected?)
    protected?)


  (method public (set-protected? flag)
    (set! protected? flag))


  (method public (get-output-type)
    output-type)


  (method public (set-output-type type)
    (set! output-type type))


  (method public (get-output-name)
    output-name)


  (method public (set-output-name name)
    (set! output-name name))


  (method public (get-anonymous-build)
    anonymous-build)


  (method public (set-anonymous-build value)
    (set! anonymous-build value))
  
  
  (method public (get-work-name)
    (->string (type-name (class-of self))))
  
  
  (method public (get-build-directory)
    (new Directory (list 'org.jazz "Jazz" "Build" "Work" "Compiler" (get-title~ (current-policy~ Workbench-Manager)))))


  (method public (project-analyser-map)
    analyser-map)


  ;;;
  ;;;; Abstract
  ;;;
  
  
  (method public virtual (project-setup)
    null)
  
  
  (method public virtual (project-directory)
    (new Directory (list (type-name (class-of self)))))
  
  
  (method public virtual (project-development)
    (new-directory~ (project-directory) "Development"))
  
  
  (method public virtual (project-distribution)
    (new-directory~ (project-directory) "Distribution"))
  
  
  (method public virtual (project-binaries)
    (new-directory~ (project-distribution) "Bin"))
  
  
  (method public virtual (project-manifest)
    (new-file~ (new-directory~ (project-distribution) "Debug") "Manifest.jazz"))
  
  
  (method public virtual (project-home)
    (project-distribution))
  
  
  (method public virtual (project-owner)
    owner)
  
  
  (method public virtual (project-copyright)
    copyright)
  
  
  (method public virtual (project-version)
    version)
  
  
  (method public virtual (project-distribution-directory)
    (let* ((version (project-version))
           (dirname (format "v{a}" (present~ version))))
      (new Directory (list 'Distribution (product-title) dirname))))
  
  
  (method public virtual (project-distribution-list)
    true)


  (method public virtual (project-application)
    application-class)
  
  
  (method public virtual (project-settings)
    (let* ((fact (new List-Factory))
           (proc
            (function dynamic (setting value)
              (put~ fact setting)
              (put~ fact value))))
      (proc 'UsesBinDirectory (get-uses-bin-directory?))
      (proc 'JazzRuntime (jazz-runtime?))
      (proc 'IsService (let ((class (autoload (project-application)))) (subtype? class Service)))
      (get-output~ fact)))
  
  
  (method public virtual (project-properties)
    (list 'Compiled? true
          'Application (project-application)))


  (method public virtual (project-c++-files)
    (collect-files Cpp-File))
  
  
  (method public virtual (project-headers)
    '({Directory Kernel-Module "Core" "Headers"}
      {Directory Slayer-Module "Core" "Include"}
      ;; Putting these three directories here is not clean but will do
      ;; until I figure out were to put JJavaExternal (it needs Java
      ;; and the Interpreter but putting it in any one creates unwanted
      ;; dependencies between the two modules...)
      {Directory Java-Module "Core" "Include"}
      {Directory Java-Module "Core" "Headers"}
      {Directory JavaParser-Module "Core" "Headers"}))
  
  
  (method public virtual (project-paths)
    null)
  
  
  (method public virtual (project-libraries)
    null)
  
  
  (method public virtual (project-classpath)
    null)
  
  
  (method public (require-classpath)
    (either (project-classpath)
            (error "Project {a} doesn't define a classpath" (product-title))))


  (method public virtual (project-roots . rest)
    (bind-keywords ((debugged? false)) rest
      (let ((fact (new List-Factory)))
        (put-sequence~ fact (collect-base-roots))
        (put-sequence~ fact (project-extra-roots))
        (when debugged?
          (put-sequence~ fact (project-debugger-roots)))
        (get-output~ fact))))


  (method public virtual (project-root-databases)
    null)


  (method public virtual (project-extra-roots)
    null)


  (method public virtual (project-debugger-roots)
    '(Read-Error
      Walk-Error
      Debugger-Server-Remotable
      Directory-Server-Remotable))


  (method public virtual (project-debugger-modules)
    '(Debugger-Module
      Debuggee-Module
      Interpreter-Module
      Jazz-Module
      Java-Module
      JRM-Module))
  
  
  (method public virtual (project-link?)
    (neq? output-type null))
  
  
  (method public virtual (project-output-name . rest)
    (bind-keywords ((policy null)) rest
      (let ((policy (either policy [Current-Policy Workbench-Manager]))
            (name (either output-name (product-title))))
        (if (and anonymous-build (= policy anonymous-build))
            name
          (format "{a}{a}" name policy)))))
  
  
  (method (collect-base-roots)
    (let ((fact (new List-Factory)))
      (put-sequence~ fact (collect-direct-units))
      (for-each-hash (function dynamic (type-name dependency)
                       (let ((kind (get-kind~ dependency)))
                         (when (eq? kind 'include)
                           (let ((project (dependency-project dependency)))
                             (put-sequence~ fact (collect-direct-units~ project))))))
                     dependencies-hashtable)
      (get-output~ fact)))
  
  
  (method (collect-direct-units)
    (let ((units null))
      (for-each-descendant
        (function dynamic (descendant level)
          (when (and (is? descendant Jazz-File)
                     (is-not? descendant Product)
                     (get-build?~ descendant))
            (let ((name (get-name~ descendant)))
              (set! units (cons name units))))))
      units))
  
  
  (method public virtual (project-user)
    "_Defaults")
  
  
  (method public virtual (project-debug?)
    true)
  
  
  ;; All this and much of above is just a temporary quicky because I don't have the time
  ;; to implement the right solution which is having standalone Launch-Parameters components.
  (method public virtual (project-command-action)
    null)
  
  
  (method public virtual (project-command-arguments)
    null)
  

  ;;;
  ;;;; Files
  ;;;


  (method public (get-unit-file unit)
    (get-manifest-source unit))


  (method public (get-source-file name system?)
    (work-file (if system? (append "_" name) name) "cpp"))


  (method public (get-object-file name system?)
    (let ((extension (if [Use-GCC? Cpp-Builder] "o" "obj")))
      (work-file (if system? (append "_" name) name) extension)))


  (method (work-file name extension)
    (new-file~ (get-build-directory) (append (->string name) "." extension)))
  
  
  (method public (log-file)
    (work-file "Log" "txt"))


  ;;;
  ;;;; Build
  ;;;
  
  
  (definition Non-Threaded-Reporter
    null)
  
  
  (method (registered-reporter)
    (if (not Threaded-Build?)
        (begin
          (unless Non-Threaded-Reporter
            (set! Non-Threaded-Reporter (new User-Reporter)))
          Non-Threaded-Reporter)
      (let ((manager (get-activity-manager)))
        (show~ manager)
        (register-activity~ manager))))
  
  
  (method (unregister-reporter reporter)
    (when Threaded-Build?
      (unregister-activity~ (get-activity-manager) reporter)))


  (method public (build . rest)
    (bind-keywords ((toplevel-project self) (force-link? false) (log? true) (report? true) (keep-reporter? true)) rest
      (let ((proc
             (function ()
               (let ((reporter (registered-reporter))
                     (output (get-output-log)))
                 (clear-results~ output)
                 (select-results~ output)
                 (select-palette Output-Log)
                 (build-project
                  :toplevel-project toplevel-project
                  :force-link? force-link?
                  :log? log?
                  :report? report?
                  :keep-reporter? keep-reporter?
                  :reporter reporter
                  :output output)
                 (unless keep-reporter?
                   (unregister-reporter reporter))))))
        (if (and Threaded-Build? (eq? toplevel-project self))
            (new Thread
              name: "Project Builder"
              :information (format "{a} - {a}" (product-title) [Current-Policy Workbench-Manager])
              :context self
              :execute (function (thread)
                         (proc)))
          (proc)))))


  (method synchronized (build-project . rest)
    (bind-keywords ((toplevel-project self) (build-units? true) (link? true) (force-link? false) (log? false) (report? true) (keep-reporter? true) (reporter null) (output null)) rest
      (set-range~ reporter (new Range 0 (case type ((jazz) 6) (else 3))))
      (user-message~ reporter "Building {a}..." (get-presentation))
      (prepare-build)
      (let ((action
             (function dynamic (log)
               (let* ((timer (new Timer))
                      (d1 (build-dependencies toplevel-project reporter log output))
                      (d2 (build-c++ reporter log output))
                      (d3 (build-resources reporter log output))
                      (d4 (build-parameters reporter log output))
                      (d5 (build-units toplevel-project build-units? reporter log output))
                      (dirty? (or d1 d2 d3 d4 d5)))
                 (when (and link? (project-link?))
                   (link (or force-link? dirty?) reporter log output))
                 (step-it~ reporter)
                 (user-message~ reporter "{a} built in {s} seconds"
                                (project-output-name)
                                (get-duration-in-seconds~ timer))
                 (set-done~ reporter)
                 dirty?))))
        (if (not log?)
            (action null)
          (let ((file (log-file)))
            (with-closed ((printer (new File-Printer :pathname file)))
              (action printer)))))))
  
  
  (method (prepare-build)
    (prepare-directories))
  
  
  ;; All these per-project map needs big time rethinking
  (method public (prepare-maps)
    (prepare-map)
    (for-each-hash (function dynamic (type-name dependency)
                     (let ((project (dependency-project dependency)))
                       (prepare-map~ project)))
                   dependencies-hashtable))
  
  
  (method (prepare-map)
    (empty-map analyser-map))
  
  
  (method public (prepare-directories)
    (create-directories~ (get-build-directory))
    (for-each-hash (function dynamic (type-name dependency)
                     (let ((project (dependency-project dependency)))
                       (if (null? project)
                           (error "Unable to find project {t} in workbench" (get-name~ dependency))
                         (create-directories~ (get-build-directory~ project)))))
                   dependencies-hashtable))


  ;;;
  ;;;; Clean
  ;;;


  (method public (clean-all)
    (for-each (function dynamic (file)
                (when (eq? (get-product~ file) self)
                  (clean (get-name~ file) false)))
              unit-files))


  (method public (clean name system?)
    (delete-file~ (get-source-file name system?))
    (delete-file~ (get-object-file name system?)))


  ;;;
  ;;;; Dependencies
  ;;;
  
  
  (method (build-dependencies toplevel-project reporter log output)
    (when (eq? toplevel-project self)
      (let ((dirty? false)
            (dependencies (collect-dependencies)))
        (when dependencies
          (let ((reporter (registered-reporter)))
            (for-each (function dynamic (dependency)
                        (let* ((kind (get-kind~ dependency))
                               (project (dependency-project dependency))
                               (build-units? (eq? kind 'include)))
                          (when (build-project~ project :toplevel-project toplevel-project :build-units? build-units? :link? false :reporter reporter :output output)
                            (set! dirty? true))))
                      dependencies)
            (unregister-reporter reporter))
          (when reporter
            (step-it~ reporter))
          dirty?))))
  
  
  (method (collect-dependencies)
    (sort < (collect-direct-dependencies)
          :key (function dynamic (dependency)
                 (get-name~ (dependency-project dependency)))))
  
  
  (method public (collect-direct-dependencies)
    (let ((dependencies null))
      (for-each-hash (function dynamic (type-name dependency)
                       (let ((project (dependency-project dependency)))
                         (unless (member? project dependencies :key dependency-project)
                           (set! dependencies (cons dependency dependencies)))))
                     dependencies-hashtable)
      dependencies))
  
  
  (method public (dependency-project dependency)
    (find-project~ workbench (get-name~ dependency)))


  ;;;
  ;;;; C++
  ;;;
    
  
  (method public virtual (project-c++-catalog)
    null)

  
  (method (build-c++ reporter log output)
    (let ((files (project-c++-files))
          (catalog (project-c++-catalog)))
      (when catalog
        (update~ catalog :report? false))
      (build-c++-files files reporter log output)))
  
  
  (method (build-c++-files files reporter log output)
    (let ((dirty? false))
      (for-each (function dynamic (file)
                  (when (and (get-build?~ file) (build~ file self reporter log output))
                    (set! dirty? true)))
                files)
      (when reporter
        (step-it~ reporter))
      dirty?))


  ;;;
  ;;;; Resources
  ;;;


  (method public virtual (project-resources)
    (resource-file "res"))


  (method (project-resource-script)
    (resource-file "rc"))


  (method (resource-file extension)
    (work-file (product-title) extension))


  (method (resource-command)
    (format "rc /fo {a} {a}"
            (get-name~ (project-resources))
            (get-name~ (project-resource-script))))
  
  
  ;; It should be possible to put the list of resources and their file times
  ;; in the dependencies database so as to build the resources only as needed.
  (method public (build-resources reporter log output)
    (if [Use-GCC? Cpp-Builder]
        (begin
          (when reporter
            (step-it~ reporter))
          true)
    ;; to speed up for tests...
    (if false @w (exists?~ (new-file~ (get-build-directory) (get-name~ (project-resources))))
        (begin
          (when reporter
            (step-it~ reporter))
          false)
      (if (is? self Module)
          (begin
            (when reporter
              (step-it~ reporter))
            false)
        (when reporter
          (user-message~ reporter "Compiling resources..."))
        (export-resources-script)
        (let ((command (resource-command)))
          (bind-values (code out err)
              (create-process command
                              :directory (get-build-directory)
                              :visible? false
                              :capture-output? true
                              :capture-error? true
                              :debug-console? false)
            (when output
              (for-each (function dynamic (line)
                          (log-line~ output line))
                        out))
            (when (/= code EXIT_SUCCESS)
              (error "Unable to compile resources"))
            (when reporter
              (step-it~ reporter))
            true))))))
  
  
  (method public (export-resources-script)
    (let ((name (product-title))
          (script (project-resource-script)))
      (create-directories~ script)
      (with-closed ((printer (new File-Printer :pathname script)))
        (output-header (tie "{name} Resources") printer :language 'cpp/java)
        (insert-header printer)
        (insert-icon printer)
        (insert-resources printer)
        (insert-version printer))))
  
  
  (method (insert-header printer)
    (format printer "{%}{%}")
    (format printer "#include \"windows.h\"{%}")
    (format printer "{%}")
    (format printer "LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US{%}")
    (format printer "#pragma code_page(1252){%}"))
  
  
  (method (insert-icon printer)
    @w
    ((output-section "Appl" printer :language 'cpp/java)
    (let* ((icon (either icon {Bitmap-Resource "Jazz"}))
           (first-alphabeticaly "AAA")
           (source (get-icon~ workbench (get-name~ icon)))
           (destination (work-file first-alphabeticaly "ico")))
      (copy-file~ source destination :overwrite-read-only? true)
      (set-read/write~ destination)
      (insert-resource-file destination "ICON" printer name: first-alphabeticaly))))
  
  
  (method (insert-resources printer)
    (let ((group null))
      (for-each-hash (function dynamic (type-name dependency)
                       (let ((sub-project (dependency-project dependency)))
                         (for-each-descendant~ sub-project
                           (function dynamic (descendant level)
                             (typecase descendant
                               ((Product-Group)
                                 (set! group (get-name~ descendant)))
                               @w
                               ((Resource-File)
                                 (when group
                                   (output-section group printer :language 'cpp/java)
                                   (set! group null))
                                 (insert-resource descendant printer)))))))
                     dependencies-hashtable)))
  
  
  (method (insert-resource resource printer)
    (let ((marker (resource-marker~ resource)))
      (when marker
        (insert-resource-file (get-source~ resource) marker printer))))
  
  
  (method (insert-resource-file source marker printer . rest)
    (bind-keywords ((name null)) rest
      (let ((name (either name (upcase (get-base~ source)))))
        (format printer "{a :width 30}   {a :width 6}     {s}{%}"
                name
                marker
                (parse~ source)))))
  
  
  (method (insert-version printer)
    (output-section "Version" printer :language 'cpp/java)
    (let ((name (product-title))
          (owner (project-owner))
          (copyright (project-copyright)))
      (format printer "VS_VERSION_INFO VERSIONINFO{%}")
      (format printer "FILEVERSION 1, 0, 0, 0{%}")
      (format printer "PRODUCTVERSION 1, 0, 0, 0{%}")
      (format printer "FILEFLAGSMASK 0x3fL{%}")
      (format printer "FILEFLAGS 0x0L{%}")
      (format printer "FILEOS 0x40004L{%}")
      (format printer "FILETYPE 0x1L{%}")
      (format printer "FILESUBTYPE 0x0L{%}")
      (format printer "BEGIN{%}")
      (format printer "{&}BLOCK \"StringFileInfo\"{%}")
      (format printer "{&}BEGIN{%}")
      (format printer "{& 2}BLOCK \"000004b0\"{%}")
      (format printer "{& 2}BEGIN{%}")
      (format printer "{& 3}VALUE \"CompanyName\", \"{a}\\0\"{%}" owner)
      (format printer "{& 3}VALUE \"FileDescription\", \"{a}\\0\"{%}" name)
      (format printer "{& 3}VALUE \"FileVersion\", \"1, 0, 0, 0\\0\"{%}")
      (format printer "{& 3}VALUE \"InternalName\", \"{a}\\0\"{%}" name)
      (format printer "{& 3}VALUE \"LegalCopyright\", \"{a}{a}\\0\"{%}" (if copyright (format "Copyright {a} " copyright) "") owner)
      (format printer "{& 3}VALUE \"OriginalFilename\", \"{a}.exe\\0\"{%}" name)
      (format printer "{& 3}VALUE \"ProductName\", \"{a} {a}\\0\"{%}" owner name)
      (format printer "{& 3}VALUE \"ProductVersion\", \"1, 0, 0, 0\\0\"{%}")
      (format printer "{& 2}END{%}")
      (format printer "{&}END{%}")
      (format printer "{&}BLOCK \"VarFileInfo\"{%}")
      (format printer "{&}BEGIN{%}")
      (format printer "{& 2}VALUE \"Translation\", 0x0, 1200{%}")
      (format printer "{&}END{%}")
      (format printer "END{%}")))


  ;;;
  ;;;; Parameters
  ;;;


  (method (build-parameters reporter log output)
    (when (= type 'jazz)
      (let ((d1 (and bind-settings? (bind-settings (project-settings-files) reporter log output (project-settings))))
            (d2 (and bind-properties? (bind-hashtable "Properties" (project-properties-files) reporter log output (project-properties))))
            (d3 (and bind-libraries? (bind-hashtable "Libraries" (project-libraries-files) reporter log output))))
        (when reporter
          (step-it~ reporter))
        (or d1 d2 d3))))
  
  
  (method (bind-settings files reporter log output . rest)
    (bind-optionals ((extra-entries null)) rest
      (let ((compiler (new Compiler :settings-name "Settings" :settings-files (remove-non-existant files) :extra-entries extra-entries :project self)))
        (bind-settings~ compiler reporter log output))))


  (method (bind-hashtable name files reporter log output . rest)
    (bind-optionals ((extra-entries null)) rest
      (let ((compiler (new Compiler :hashtable-name name :hashtable-files (remove-non-existant files) :extra-entries extra-entries :project self)))
        (bind-hashtable~ compiler reporter log output))))
  
  
  (method (remove-non-existant files)
    (collect-if (function dynamic (file)
                  (exists?~ file))
                files))


  (method (project-settings-files)
    (list
      {File Base "Parameters" "Settings.prop"}
      (settings-file)))
  
  
  (method protected virtual (settings-file)
    (new-file~ (project-development) (list "Parameters" "Settings.prop")))


  (method (project-properties-files)
    (list
      {File Base "Parameters" "Properties.prop"}
      (properties-file)))
  
  
  (method protected virtual (properties-file)
    (new-file~ (project-development) (list "Parameters" "Properties.prop")))
  
  
  (method protected virtual (project-libraries-files)
    (list
      {File Base "Parameters" "Libraries.prop"}))


  ;;;
  ;;;; Units
  ;;;


  (method public (build-units toplevel-project build-units? reporter log output)
    (if (not build-units?)
        (begin
          (set! unit-files null)
          false)
      (set! unit-files (if (eq? toplevel-project self) (project-units) null))
      (let* ((dirty? false)
             (proc
              (function dynamic (project file)
                (when (and (get-build?~ file) (build~ file project reporter log output))
                  (set! dirty? true)))))
        (for-each (function dynamic (file)
                    (when (build-unit? file)
                      (let ((project (get-product~ file)))
                        (if (eq? project self)
                            (proc project file)
                          (let* ((dependency (project-dependency project))
                                 (kind (get-kind~ dependency)))
                            (when (memq? kind '(reference include))
                              (proc project file)))))))
                  unit-files)
        (when reporter
          (step-it~ reporter))
        dirty?)))
  
  
  (method (project-units)
    (map (function dynamic (unit-name)
           (either (get-entry~ workbench unit-name)
                   (error "Unable to find unit file for {t}" unit-name)))
         (sort < (prepare-units))))
  
  
  (method public (prepare-units . rest)
    (bind-keywords ((debugged? false) (include-path? false)) rest
      (prepare-maps)
      (collect-units :debugged? debugged? :include-path? include-path?)))
  
  
  (method public (prepare-units/resources . rest)
    (bind-keywords ((debugged? false) (include-path? false)) rest
      (prepare-maps)
      (collect-units/resources :debugged? debugged? :include-path? include-path?)))
  
  
  (method public (collect-units . rest)
    (bind-values (units resources) (apply collect-units/resources rest)
      units))
  
  
  (method public (collect-units/resources . rest)
    (bind-keywords ((debugged? false) (include-path? false)) rest
      (let ((roots (project-roots :debugged? debugged?))
            (root-databases (project-root-databases))
            (add-empty-paths
             (function dynamic (unit-names)
               (if include-path?
                   (map (function dynamic (unit-name)
                          (cons unit-name null))
                        unit-names)
                 unit-names))))
        (for-each (function dynamic (root)
                    (when (not (in-manifest? root))
                      (error "Root class {t} not found in manifest" root)))
                  roots)
        (bind-values (units resources)
            (if (walk-units?)
                (let* ((extra-modules (if debugged? (project-debugger-modules) null))
                       (analyser (new Reference-Analyser :project self :units-map analyser-map :extra-modules extra-modules :debugged? debugged? :include-path? include-path?)))
                  (find-references~ analyser roots root-databases))
              (values (add-empty-paths roots) null))
          (let ((extra (add-empty-paths (extra-units))))
            (values (append extra units)
                    resources))))))
  
  
  (method public virtual (extra-units)
    '())


  (method public virtual (walk-units?)
    true)
  
  
  (method public (analyse-unit? unit-name extra-modules)
    (let ((file (get-entry~ workbench unit-name)))
      (when (and file (is-not? file Product))
        (let ((project (get-product~ file)))
          (or (eq? project self)
              (in-dependency? file)
              (memq? (type-name (class-of project)) extra-modules))))))
  
  
  (method public (build-unit? file)
    (when (and file (get-build?~ file) (is-not? file Product))
      (let ((proj (get-product~ file)))
        (or (eq? proj self)
            (let ((dependency (project-dependency proj)))
              (and dependency (/= (get-kind~ dependency) 'error)))))))
  
  
  (method (in-dependency? file)
    (let* ((project (get-product~ file))
           (features (get-features~ file))
           (dependency (project-dependency project)))
      (and dependency
           (subset? features (get-features~ dependency)))))
  
  
  (method public (project-dependencies)
    (get-children~ (child 'dependencies)))


  (method public (project-dependency project)
    (hash-ref dependencies-hashtable (type-name (class-of project))))


  ;;;
  ;;;; Imports
  ;;;
  
  
  (method (bind-imports reporter log output)
    (when reporter
      (user-message~ reporter "Binding Imports..."))
    (let ((source-file (get-source-file "Imports" true)))
      (with-closed ((printer (new File-Printer :pathname source-file)))
        (emit-imports-header printer)
        (emit-imports-code printer))
      (let* ((compiler (get-compiler-class))
             (vc (new compiler :project self :file source-file)))
        (compile~ vc :log log :output output))))
  
  
  (method (emit-imports-header printer)
    (format printer "#include \"Jazz.h\"{%}")
    (format printer "#include \"JBoot.h\"{%}")
    (format printer "#include \"JCompiled.h\"{%}")
    (format printer "#include \"JImport.h\"{%}"))
  
  
  (method (emit-imports-code printer)
    (format printer "{%}")
    (format printer "namespace ~{{%}{%}")
    (format printer "int setup_imports(){%}")
    (format printer "~{{%}")
    (emit-imports printer)
    (format printer "}{%}")
    (format printer "int dummy = setup_imports();{%}{%}")
    (format printer "}{%}"))
  
  
  (method (emit-imports printer)
    (let* ((externals (collect-if (function dynamic (file) (not (build-unit? file))) unit-files))
           (partition (partition externals :key (function dynamic (file) (get-product~ file)))))
      (when partition
        (for-each (function dynamic (info)
                    (bind (module . files) info
                      (emit-import module files printer)))
                  partition)
        (format printer "{%}"))
      (format printer "{&}return -1;{%}")))
  
  
  (method (emit-import module files printer)
    (let ((name (type-name (class-of module))))
      (format printer "{&}register_import(intern(L\"{a}\"), intern(L\"error\"), varlist({a}, NOOBJECT));{%}"
              name
              (join (map (function dynamic (file)
                           (format "intern(L\"{a}\")" (get-name~ file)))
                         files)
                    ", "))))

  
  ;;;
  ;;;; Manifest
  ;;;
  
  
  (method public (export-manifest)
    (let ((file (project-manifest)))
      (create-directories~ file)
      (ensure-read/write file)
      (bind-values (units imports resources) (gather-units/imports/resources)
        (let ((title (format "{a} Manifest" (get-presentation))))
          (with-closed ((printer (new File-Printer :pathname file)))
            (output-header title printer)
            (export-manifest-root file printer)
            (export-manifest-units units printer)
            (export-manifest-imports imports printer)
            (export-manifest-resources resources printer))))))
  
  
  (method (gather-units/imports/resources)
    (let ((dependencies (gather-dependencies))
          (workbench (get-workbench))
          (units null)
          (imports null)
          (resources null))
      (for-each (function dynamic (dependency)
                  (bind (project . kind) dependency
                    (case kind
                      ((error)
                       (let ((symbols null))
                         (for-each-descendant~ project
                           (function dynamic (descendant level)
                             (when (and (is? descendant Jazz-File)
                                     (is-not? descendant Product)
                                     (get-build?~ descendant))
                               (set! symbols (cons (get-name~ descendant) symbols)))))
                         (set! imports (cons (list (get-name~ project) kind symbols) imports))))
                      (else
                       (for-each (function dynamic (product)
                                   (unless (memq? product units)
                                     (set! units (cons product units))))
                                 (gather-product-ascendants project))
                        (for-each-descendant~ project
                          (function dynamic (descendant level)
                            (cond ((and (is? descendant Jazz-File)
                                     (is-not? descendant Product)
                                     (get-build?~ descendant))
                                   (set! units (cons descendant units)))
                              ((is? descendant Resource-File)
                               (set! resources (cons descendant resources))))))))))
                dependencies)
      (values units imports resources)))
  
  
  (method (gather-dependencies)
    (let ((workbench (get-workbench))
          (dependencies '()))
      (letrec ((add
                (function dynamic (project kind)
                  (let ((actual (find project dependencies :key car)))
                    (if (not-null? actual)
                        (when (= (cdr actual) 'error)
                          (set-cdr! actual kind))
                      (set! dependencies (cons (cons project kind) dependencies))
                      (for-each (function dynamic (dependency)
                                  (let* ((dependency-name (get-name~ dependency))
                                         (dependency-kind (get-kind~ dependency))
                                         (dependency-project (require-project~ workbench dependency-name)))
                                    (add dependency-project dependency-kind)))
                                (project-dependencies~ project)))))))
      (add self 'include)
      (for-each (function dynamic (dependency-name)
                  (add (require-project~ workbench dependency-name) 'include))
                (project-debugger-modules))
      dependencies)))
  
  
  (method (gather-product-ascendants product)
    (if (is? product Workbench)
        null
      (cons product (gather-product-ascendants (get-parent-product~ product)))))
  
  
  (method (export-manifest-root file printer)
    (let* ((root {Directory Root})
           (anchored (anchor-to~ file root :error? false)))
      (when anchored
        (format printer "{%}{%}:root{%}")
        (format printer "{a}{%}" (- (length (get-list~ anchored)) 2)))))
  
  
  (method (export-manifest-units units printer)
    (output-section "Units" printer)
    (format printer ":units{%}")
    (format printer "({%}")
    (let ((max (maximum (map (function dynamic (unit) (length (symbol->string (get-name~ unit)))) units))))
      (emit-manifest-units max units printer))
    (format printer "){%}"))
  
  
  (method (emit-manifest-units max units printer)
    (for-each (function dynamic (unit)
                (emit-manifest-unit unit max printer))
              (sort < units :key (function dynamic (unit) (get-name~ unit)))))
  
  
  (method (emit-manifest-unit unit max printer)
    (let ((name (get-name~ unit))
          (properties (if (is? unit Product)
                          (list :source (get-manifest-source (get-name~ unit)))
                        (manifest-properties~ unit))))
      (format printer "{s}{_ :v}   ({l}){%}"
              name
              (- max (length (symbol->string name)))
              properties)))
  
  
  (method (export-manifest-imports imports printer)
    (output-section "Imports" printer)
    (format printer ":imports{%}")
    (format printer "({%}")
    (let ((max (maximum (map (function dynamic (import) (length (symbol->string (car import)))) imports))))
      (emit-manifest-imports max imports printer))
    (format printer "){%}"))
  
  
  (method (emit-manifest-imports max imports printer)
    (for-each (function dynamic (import)
                (emit-manifest-import import max printer))
              (sort < imports :key car)))
  
  
  (method (emit-manifest-import import max printer)
    (bind (module type symbols) import
      (format printer "{s}{_ :v}   {s}{_ :v}   {s}{%}"
              module
              (- max (length (symbol->string module)))
              type
              (- 6 (length (symbol->string type)))
              symbols)))


  (method (export-manifest-resources resources printer)
    (output-section "Resources" printer)
    (format printer ":resources{%}")
    (format printer "({%}")
    (emit-manifest-resources resources printer)
    (format printer "){%}"))


  (method (emit-manifest-resources resources printer)
    (let* ((resource-name (function dynamic (resource) (get-name~ (get-source~ resource))))
           (max (maximum (map (function dynamic (resource) (length (resource-name resource))) resources))))
      (for-each (function dynamic (resource)
                  (emit-manifest-resource resource max printer))
                (sort < resources :key resource-name))))


  (method (emit-manifest-resource resource max printer)
    (let* ((source (get-source~ resource))
           (name (get-base~ source))
           (type (resource-type~ (resource-class~ resource))))
      (format printer "{s}{_ :v}   {s}{_ :v}   {s}{%}"
              name
              (- max (length name))
              type
              (- 6 (length (symbol->string type)))
              source)))


  ;;;
  ;;;; Link
  ;;;
  
  
  (constant Runtime-Libraries
    '(;;"libcmt.lib"
      ;;"libcpmt.lib"
      ))


  (constant Base-Libraries
    '("kernel32.lib"
      "user32.lib"
      "gdi32.lib"
      "ole32.lib"
      "oleaut32.lib"
      "winmm.lib"
      "shell32.lib"
      "shlwapi.lib"
      "advapi32.lib"
      "rpcrt4.lib"
      "ws2_32.lib"
      "uuid.lib"
      "comsupp.lib"
      "pdh.lib"
      "dbghelp.lib"
      ;;"psapi.lib"
      ))


  (method public virtual (runtime-libraries)
    Runtime-Libraries)


  (method public virtual (base-libraries)
    Base-Libraries)


  (method (linker-file filename extension)
    (new-file~ (project-binaries) (append filename "." extension)))
  
  
  (method public (base-output-file . rest)
    (bind-keywords ((policy null)) rest
      (linker-file (project-output-name :policy policy)
        (case output-type
          ((windows console service) "exe")
          ((dll) "dll")))))
    
  
  (method public (auxiliary-output-file)
    (linker-file (append (project-output-name) "Aux")
      (case output-type
        ((windows console service) "exe")
        ((dll) "dll"))))

  
  (method (output-file)
    (let ((base (base-output-file)))
      (if (not (pathname= base (module-pathname)))
          (values base false)
        (values (auxiliary-output-file) true))))
  
  
  (method public (outputed-file)
    (let ((aux (auxiliary-output-file)))
      (if (exists?~ aux)
          aux
        (base-output-file))))
  
  
  (method (link dirty? reporter log output)
    (let ((base (base-output-file)))
      (when (or dirty? (not (exists?~ base)))
        (when (and bind-imports? (/= output-type 'dll))
          (bind-imports reporter log output))
        (user-message~ reporter "Linking executable...")
        (bind-values (output-file renamed?) (output-file)
          (link-to output-file dirty? log output)
          (when renamed?
            (launch-renamer output-file base))))))
  
  
  (method (link-to output-file dirty? log output)
    (let* ((base (get-base~ output-file))
           (model (get-linker-class))
           (linker (new model self unit-files dependencies-hashtable)))
      (prepare-linking~ linker)
      (let ((command (link-command~ linker output-file)))
        (when log
          (format log "{a}{%}" command))
        (bind-values (code out err)
            (create-process command
                            :directory (link-directory~ linker)
                            :visible? false
                            :capture-output? true
                            :capture-error? true
                            :pipe-size 524288
                            :debug-console? false)
          ;; Commented because it seems that deleting lib or exp files
          ;; stops the linker from beeing able to link incrementally...
          ;; But now that the incremental linker is always off...
          (unless (preserve-lib?)
            (delete-file~ (linker-file base "lib") :error? false))
          (delete-file~ (linker-file base "exp") :error? false)
          (when (and log (either out err))
            (format log "{%}")
            (for-each (function dynamic (line)
                        (format log "  {a}{%}" line))
                      out)
            (for-each (function dynamic (line)
                        (format log "  {a}{%}" line))
                      err))
          (when output
            (for-each (function dynamic (line)
                        (log-line~ output line))
                      out))
          (when (/= code EXIT_SUCCESS)
            (error "Unable to link executable"))))))
  
  
  (method protected virtual (preserve-lib?)
    false)
  
  
  ;;;
  ;;;; Renaming
  ;;;
  
  
  (method (renamer-command src dst)
    (format "\"{a}\" /src \"{a}\" /dst \"{a}\""
            (parse~ {File org.jazz "Jazz" "Build" "Bin" "Renamer.exe"})
            (parse~ src)
            (parse~ dst)))
  
  
  (method (launch-renamer src dst)
    (create-process (renamer-command src dst) :wait? false))


  ;;;
  ;;;; Designer
  ;;;
  
  
  @convert-descriptor
  (method meta (get-class-image)
    {Bitmap-Resource "MsgUser"})
  
  
  @convert
  (method meta (property-presentation property)
    (case (field-name property)
      ((icon) "Icon")
      ((owner) "Owner")
      ((copyright) "Copyright")
      ((version) "Version")
      ((type) "Type")
      ((setup-class) "Setup Class")
      ((application-class) "Application Class")
      ((uses-bin-directory?) "Uses Bin Directory?")
      ((bind-settings?) "Bind Settings?")
      ((bind-properties?) "Bind Properties?")
      ((bind-libraries?) "Bind Libraries?")
      ((bind-imports?) "Bind Imports?")
      ((protected?) "Protected?")
      ((output-type) "Output Type")
      ((output-name) "Output Name")
      ((anonymous-build) "Anonymous Build")
      ((uses-bin-directory?) "Uses Bin Directory?")
      ((bind-settings?) "Bind Settings?")
      ((bind-properties?) "Bind Properties?")
      ((bind-libraries?) "Bind Libraries?")
      ((bind-imports?) "Bind Imports?")
      ((protected?) "Protected?")
      ((output-type) "Output Type")
      ((output-name) "Output Name")
      ((anonymous-build) "Anonymous Build")
      (else (nextmethod property))))
  
  
  (method (get-row-instance property)
    (case (field-name property)
      ((uses-bin-directory? bind-settings? bind-properties? bind-libraries? bind-imports? protected?) (new Boolean-Row))
      (else (nextmethod property))))
  
  
  (method (get-categorized-properties)
    '(title
      include-extensions catalog-extensions
      documentation
      icon
      owner copyright version
      type setup-class application-class
      uses-bin-directory? bind-settings? bind-properties? bind-libraries? bind-imports? protected?
      output-type output-name anonymous-build))))
