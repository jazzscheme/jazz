;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Externals
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Stephane Le Cornec.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2006
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.platform.external jazz
  

  (definition natives
    '(char int long uint ulong Window Bool XID Time Drawable Pixmap Colormap Cursor))
  
  
  ;;;
  ;;;; Enumeration
  ;;;
  
  
  (macro public (enumeration name . declarations)
    (let ((definitions (map (lambda (declaration) `(definition ,@declaration)) declarations)))
      `(begin ,@definitions)))
  
  
  ;;;
  ;;;; Structure
  ;;;
  
  
  (definition (build-pointer-symbol type)
    (string->symbol (string-append (symbol->string type) "*")))
  
  
  (definition (pointer? type)
    (let* ((str (symbol->string type))
	   (lgt (string-length str)))
      (eq? (string-ref str (- lgt 1)) #\*)))
	  

  (definition (build-method-symbol struct-string . rest)
    (string->symbol (apply string-append struct-string "-" (map symbol->string rest))))
  
  
  (definition (parse-structure-name name)
    (if (symbol? name)
        (values name (symbol->string name) #f)
      (values (car name) (cadr name) (let ((rest (cddr name)))
                                       (if (null? rest)
                                           #f
                                         (car rest))))))
  
  
;; Jeremie : All this code needs big-time cleanup. Should move
;; into the code walker and manage types without all those
;; ugly hacks.
  (definition (parse-structure-accessor declaration)
    (let* ((type (car declaration))
           (type* (build-pointer-symbol type))
           (identifier (cadr declaration))
           (size (if (null? (cddr declaration)) #f (caddr declaration)))
           (size-string (cond ((not size) #f)
                              ((integer? size) (number->string size))
                              ((symbol? size) (symbol->string size)))))
      (cond ((eq? size 'embed)
             ;; Here we send back type* to prevent Gambit-C from deallocating the internal
             ;; embedded structure.
             (values type* identifier #f #f #t #f))
            ;; Jeremie : Ugly patch for pointer that do not end with star
            ;; Or types with star that are not pointers in the gambit universe
            ((or (and (pointer? type) (not (eq? size 'not-pointer))) (eq? size 'pointer))
             (values type identifier #f #f #f #t))
            ((or (not size) (eq? size 'not-pointer))
             (values type identifier #f #f #f #f))
            ((eq? type 'WCHAR)
             (values '(native wchar_t-string) identifier size-string #t #f #f))
            ((eq? type 'CHAR)
             (values '(native char-string) identifier size-string #t #f #f))
            (else
             (values type* identifier size-string #f #f #t)))))
 
  
  (definition (expand-structure/union name declarations)
    (receive (struct c-struct-string tag) (parse-structure-name name)
      (let ((struct-string (symbol->string struct))
            (struct* (build-pointer-symbol struct))
            (sizeof (string-append "sizeof(" c-struct-string ")"))
            (tag* (if tag (build-pointer-symbol tag) #f)))
        (let ((expand-accessor
                (lambda (declaration)
                        (receive (type member size str? embed? pointer?) (parse-structure-accessor declaration)
                          (let* ((member-string (symbol->string member))
                                 (getter-string (cond (embed?
                                                        (string-append "___result_voidstar = &___arg1->" member-string ";"))
                                                      (pointer?
                                                        (string-append "___result_voidstar = ___arg1->" member-string ";"))
                                                      (else
                                                       (string-append "___result = ___arg1->" member-string ";"))))
                                 (setter-string (cond (embed?
                                                        #f)
                                                      ((eq? size #f)
                                                       (string-append "___arg1->" member-string " = ___arg2;"))
                                                      ((eq? str? #t)
                                                       (if (equal? type '(native wchar_t-string))
                                                           (string-append "wcsncpy(___arg1->" member-string ", ___arg2, " size ");")
                                                         (string-append "strncpy(___arg1->" member-string ", ___arg2, " size ");")))
                                                      (else
                                                       (let* ((type-string (symbol->string type))
                                                              (base-type-string (substring type-string 0 (- (string-length type-string) 1))))
                                                         (string-append "memcpy(___arg1->" member-string ", ___arg2, " size "*" "sizeof(" base-type-string "));"))))))
                            (let ((ref `(definition ,(build-method-symbol struct-string member '-ref)
                                          (c-function (,struct*) ,type ,getter-string))))
                              (if embed?
                                  (list ref)
                                (list ref 
                                      `(definition ,(build-method-symbol struct-string member '-set!)
                                             (c-function (,struct* ,type) (native void) ,setter-string))))))))))
          `(begin
             (c-type ,struct ,(if tag (list 'type c-struct-string tag) c-struct-string))
             (c-type ,struct* ,(if tag (list 'pointer struct tag*) (list 'pointer struct)))
             (definition ,(build-method-symbol struct-string 'make)
               (c-function () ,struct* ,(string-append "___result_voidstar = calloc(1," sizeof ");")))
             (definition ,(build-method-symbol struct-string 'sizeof)
               (c-function () (native unsigned-int) ,(string-append "___result = " sizeof ";")))
             ,@(apply append (map expand-accessor declarations)))))))
 

  ;; Should be converted to special form.

  (macro public (c-union name . declarations)
    (expand-structure/union name declarations))

  (macro public (c-structure name . declarations)
    (expand-structure/union name declarations))

  (macro public (c-structure-array name . rest)
    (let* ((struct name)
           (struct-string (symbol->string struct))
           (struct* (build-pointer-symbol struct))
           (c-struct-string (if (not (null? rest)) (car rest) struct-string)))
      `(begin
         (definition ,(build-method-symbol struct-string 'array-make)
           (c-function (int) ,struct* ,(string-append "___result = calloc(___arg1,sizeof(" c-struct-string "));")))
         (definition ,(build-method-symbol struct-string 'array-element)
           (c-function (,struct* int) ,struct* ,(string-append "___result = ___arg1+___arg2;"))))))
  
  
  ;;;
  ;;;; External
  ;;;
  
  
  @debug
  (macro public (c-external type signature . rest)
    (let* ((s-name (car signature))
           (params (cdr signature))
           (c-name (if (null? rest) (symbol->string s-name) (car rest))))
      `(definition ,s-name
         (let ((cfun (c-function ,params ,type ,c-name)))
           (lambda rest
             (when debug-c-external?
               (log-object (cons ',s-name rest)))
             (prog1
                 (apply cfun rest)
               (when debug-c-external?
                 (log-string " done")
                 (log-newline))))))))
  
  
  (macro public (c-external type signature . rest)
    (let* ((s-name (car signature))
           (params (cdr signature))
           (c-name (if (null? rest) (symbol->string s-name) (car rest))))
      `(definition ,s-name
         (c-function ,params ,type ,c-name))))


  ;; tofix : Danger de segmentation fault si on passe une mauvaise taille de string.
  (macro public (c-external-string-out type arg signature . rest)
    (let* ((s-name (car signature))
           (ext-s-name (string->symbol (string-append (symbol->string s-name) "_EXT")))
           (params (cdr signature))
           (new-params (map generate-symbol params))
           (string-param (list-ref new-params arg))
           (c-name (if (null? rest) (symbol->string s-name) (car rest))))
      `(begin 
         (c-external ,type ,(cons ext-s-name params) ,c-name)
         (definition (,s-name ,@new-params)
           (let ((pt (WCHAR-array-make (+ (string-length ,string-param) 1))))
             (WCHAR-copy pt ,string-param (string-length ,string-param))
             (let* ((,string-param pt)
                    (result (,ext-s-name ,@new-params)))
              (values result (WCHAR-string ,string-param)))))))))
