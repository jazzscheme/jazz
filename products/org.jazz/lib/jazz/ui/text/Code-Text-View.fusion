;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Code Text View
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.text.Code-Text-View jazz


(import (jazz.library)
        (jazz.ui)
        (jazz.ui.view)
        (jazz.utilities)
        (jazz.platform)
        (jazz.jml)
        (jazz.literals))


(class Code-Text-View extends Text-View


  (constant Completion-Color
    {Color :red 128 :green 240 :blue 240})


  (property completion-color initialize Completion-Color getter get-completion-color setter set-completion-color)
  
  
  (slot completion-active?   initialize false)
  (slot mouse-copy-selection initialize {})
  
  
  (form
    (<install> default-style: {Text-Style name: Default :font {Font name: Code}} left-padding: 12))
  
  
  (method (new-syntax)
    (new Code-Syntax))

  
  ;;;
  ;;;; Frame
  ;;;
  
  
  (method (frame-workspaces)
    '(text debugger))
  
  
  ;;;
  ;;;; Access
  ;;;


  (method public (get-completion-color)
    completion-color)


  (method public (set-completion-color value)
    (set! completion-color value)
    (invalidate-view))


  (method (escape-press key)
    (remove-completion))
    

  (method (tab-press key modifiers)
    (if (has-completion?)
        (end-completion)
      (if (not accepts-returns?)
          (navigate-view (shift-key? modifiers))
        (if (or (empty-selection?) (= [row (get-start)] [row (get-end)]))
            (insert-char #\tab)
          (tabulate)))))

  
  (method (backspace-press key . rest)
    (bind-keywords ((word? false)) rest
      (let ((previous (previous-cell (get-start))))
        (if (not completion-active?)
            (insert-char/backspace #\backspace :word? word?)
          (when previous
            (complete-current #\backspace previous null true false))))))


  (method (char-press key translated)
    (auto-complete translated)
    (flash-matching-character)
    (when (= key #\space)
      (show-arguments)))
  
  
  (method (insert-crlf)
    (end-completion)
    (nextmethod))


  (method (focus-lose window view)
    (nextmethod window view)
    (end-completion))


  @replaced-to-make-mouse-copy-on-drag-up-work
  (method (mouse-down pos)
    (end-completion)
    (let ((alt?     (alt-down?))
          (control? (control-down?))
          (shift?   (shift-down?)))
      (cond ((alt-down?)
             (mouse-copy pos self))
            (else
             (nextmethod pos)))))


  (method (mouse-down pos)
    (end-completion)
    (set! mouse-copy-selection (essay (alt-down?) (get-selection)))
    (nextmethod pos))
  
  
  ;; This is missing many features
  ;;   - control and shift modifiers
  ;;   - on mouse-down the caret flashes at the mouse-down position and this looks bad
  ;;   - accross window mouse-copy
  (method (drag-up pos . rest)
    (nextmethod pos)
    (when (and mouse-copy-selection (alt-down?))
      (let* ((range (if (has-selection?) selection (expr-range (get-start))))
             (copy (get-string range)))
        (set-selection mouse-copy-selection)
        (mouse-insert copy)))
    (set! mouse-copy-selection null))


  (method (select-outer)
    (end-completion)
    (nextmethod))


  (method (context-menu pos)
    (bind-values (shift? control? alt?) (modifiers-down)
      (let ((move-caret
             (cond ((and (not control?) (not shift?) (not alt?)) 'outside-selection)
                   ((and (not control?) shift? (not alt?)) 'never)
                   ((and control? shift? (not alt?)) 'never)
                   (else 'always))))
        (context-menu-click pos :move-caret move-caret))
      (cond ((and (not control?) shift? (not alt?)) (edit-definition pos))
            ((and control? shift? (not alt?)) (edit-references pos))
            (else (track-popup-menu (get-context-menu) pos)))))

  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method (focus-actions)
    (cons (find-actions 'code-text)
          (nextmethod)))
  

  ;;;
  ;;;; Explorer
  ;;;


  (method (explorer-class)
    Code-Explorer)

  
  ;;;
  ;;;; Moving
  ;;;
  
  
  (method public (on-backward evt)
    (backward-expr))
  
  
  (method public (on-forward evt)
    (forward-expr))
  
  
  (method public (on-enter-composite evt)
    (enter-composite))
  
  
  (method public (on-exit-composite evt)
    (exit-composite))


  (method protected virtual (forward-expr)
    (let ((expl (new (explorer-class) self :end (get-end))))
      (when (forward-expr~ expl)
        (set-selection (get-range~ expl)))))
  
  
  (method protected virtual (backward-expr)
    (let ((expl (new (explorer-class) self :start (get-start))))
      (when (backward-expr~ expl)
        (set-selection (get-range~ expl)))))
  
  
  (method protected virtual (enter-composite)
    (let ((expl (new (explorer-class) self :start (get-start) :end (get-end))))
      (when (enter-composite~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method protected virtual (exit-composite)
    (let ((expl (new (explorer-class) self :start (get-end) :end (get-end))))
      (when (exit-list~ expl)
        (set-caret (get-end~ expl)))))
  
  
  (method (move-caret pos direction shift?)
    (nextmethod pos direction shift?)
    (end-completion))

  
  ;;;
  ;;;; Definitions
  ;;;
  
  
  (method public virtual (get-context)
    true)
  
  
  (method (header-string? form)
    (and (string? form)
         (>= (length form) 2)
         (= (first form) #\double-quote)
         (= (last form) #\double-quote)))
  
  
  (method protected virtual (edition-workspace)
    null)

  
  (method (on-edit-definition evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (cond ((header-string? form)
               (edit-filename~ appl (subseq form 1 (- (length form) 1))))
              ((file? form)
               (edit-document~ appl form :workspace (edition-workspace)))
              ((is? form URL)
               (browse-url~ appl form))
              (else
               (let ((form (standardize-form form)))
                 (edit-definition~ appl form :workspace (edition-workspace) :history-item (current-history-item) :context (get-context))))))))

  
  (method (on-edit-references evt)
    (let ((form (current-expr))
          (appl (get-application)))
      (when form
        (let ((form (standardize-form form)))
          (edit-references~ appl form :history-item (current-history-item) :context (get-context))))))
    
  
  (method (standardize-form form)
    (cond ((tag? form) (tag->name form))
          ((dispatch? form) (dispatch->name form))
          (else form)))

  
  (method (on-add-to-favorites evt)
    (let ((form (current-expr)))
      (when form
        (add-to-favorites~ (get-guest~ (singleton-palette Favorites-Manager null)) Favorite-Symbol null (list :symbol form)))))


  (method protected virtual (expr-at pos)
    )
    
  
  (method protected virtual (edit-symbol-class symbol)
    false)


  (method protected (edit-definition pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (cond ((header-string? form)
               (edit-filename~ (get-application) (subseq form 1 (- (length form) 1))))
              ((file? form)
               (edit-document~ (get-application) form))
              ((is? form URL)
               (browse-url~ (get-application) form))
              (else
               (let* ((appl (get-application))
                      (cataloguer (get-cataloguer~ appl)))
                 (when cataloguer
                   (let* ((item (current-history-item))
                          (form (standardize-form form))
                          (list (get-coalesced-definitions~ cataloguer form :context (get-context))))
                     (case (length list)
                       ((0) (bell))
                       ((1) (add-history~ appl item) (edit~ (car list)))
                       (else (track-popup-menu (new Definitions-Menu :history-item item :definitions list) pos)))))))))))


  (method protected (edit-references pos)
    (let ((form (expr-at (view->text pos))))
      (when form
        (let* ((appl (get-application))
               (cataloguer (get-cataloguer~ appl)))
          (when cataloguer
            (let* ((item (current-history-item))
                   (form (standardize-form form))
                   (list (get-references~ cataloguer form :context (get-context))))
              (case (length list)
                ((0) (bell))
                ((1) (add-history~ appl item) (edit-reference~ (car list) form))
                (else (track-popup-menu (new References-Menu :history-item item :target form :definitions list) pos)))))))))

  
  ;;;
  ;;;; History
  ;;;
  
  
  (method (current-history-item)
    (let ((selection (get-selection))
          (moniker (get-moniker)))
      (if (null? moniker)
          (let ((frame (get-frame)))
            (when frame
              (new History-Document-Item frame selection)))
        (new History-File-Item moniker selection))))

  
  ;;;
  ;;;; Save
  ;;;
  
  
  (method (save-content moniker)
    (nextmethod moniker)
    @really-not-sure-its-fun-to-have-errors-poping-on-save
    (update-catalog))

  
  ;;;
  ;;;; Catalog
  ;;;
  
  
  (method public (on-update-catalog evt)
    (unless (update-catalog)
      (bell)))
  
  
  (method (update-catalog)
    (let ((catalog (require-catalog)))
      (when catalog
        (update-file~ catalog (get-moniker))
        (user-message "Done")
        true)))
  
  
  (method (require-catalog)
    (let ((moniker (get-moniker)))
      (when moniker
        (let ((entry (get-source-entry~ (get-workbench) moniker)))
          (when entry
            (require-catalog~ entry))))))

  
  ;;;
  ;;;; Coloring
  ;;;


  (method public (on-recolorize-syntax evt)
    (with-cursor :wait
      (function dynamic ()
        (recolorize-syntax))))
  
  
  (method public (recolorize-syntax)
    (uncolorize-all)
    (colorize-syntax :recoloring? true))


  (method (uncolorize-all)
    (for-each uncolorize-row (naturals 0 (get-length))))
  
  
  (method protected virtual (preferences)
    )
  
  
  (method protected virtual (syntax-targets)
    null)
  
  
  (method protected virtual (syntax-automata)
    null)
  
  
  (method protected virtual (compute-syntax-targets)
    )
  
  
  (method protected virtual (compute-syntax-automata)
    (build-search-automata (syntax-targets) true false self cpp/java-constituent?))
  
  
  (method (colorize-syntax . rest)
    (bind-keywords ((recoloring? false) (entries? true)) rest
      (colorize-syntax-from (text-beginning) recoloring?)
      (when entries?
        (colorize-entries))))
  
  
  (method (colorize-syntax-from pos recoloring?)
    @convert-automata
    (let ((colorizer (essay (not recoloring?) (new-colorizer self)))
          (targets (syntax-targets))
          (found (automata-search (syntax-automata) (get-paragraphs) (get-limit) 0 0)))
      (while found
        (let ((info (car found)))
          (bind ((target type) row col) info
            (let ((start (new Cell row col))
                  (end (new Cell row (+ col (length target)))))
              (set! found (colorize-type found type start end colorizer false))))))
      (when colorizer
        (finish-current~ colorizer))))
  
  
  (method protected (apply-coloring colorizer start end style-name)
    (if (null? colorizer)
        (apply-style style-name start end)
      (apply-style~ colorizer start end style-name)))
  
  
  (method protected virtual (colorize-type found type start end colorizer recolorize?)
    )
  
  
  (method protected virtual (colorize-balanced-comment found start end colorizer style)
    (call/ec
      (lambda (return)
        (while found
          (let ((info (car found)))
            (bind ((target type) row col) info
              (if (= type 'balanced-comment-backward)
                  (let ((end (new Cell row (+ col 2))))
                    (apply-coloring colorizer start end style)
                    (return (cdr found)))
                (set! found (cdr found))))))
        found)))
  
  
  (method protected (colorize-balanced-comment-backward found start end colorizer style recolorize? . rest)
    (bind-keywords ((open "/*") (close "*/")) rest
      (when recolorize?
        (let ((found (multisearch-string (list (list close 'close) (open 'open)) :position start :extended? true :reverse? true)))
          (when found
            (bind (pos . (target type)) found
              (when (= type 'open)
                (apply-coloring colorizer pos end style)
                (cdr found))))))))
  
  
  (method protected (colorize-line-comment found start end colorizer line-style title-style title-char)
    (let ((title? (and title-char (= (get-char (next start 2)) title-char))))
      (if (not title?)
          (apply-coloring colorizer start (new Cell [row start] (paragraph-length [row start])) line-style)
        (apply-coloring colorizer start (+ start 3) line-style)
        (apply-coloring colorizer (+ start 3) (new Cell [row start] (paragraph-length [row start])) title-style))
      (let ((row [row start]))
        (set! found (cdr found))
        (while (and found (= (second (car found)) row))
          (set! found (cdr found)))
        found)))
  
  
  (method protected (colorize-keyword found start end colorizer style)
    (apply-coloring colorizer start end style)
    (cdr found))
  
  
  (method (find-specifier-end start)
    (let* ((row [row start])
           (col [col start])
           (str (paragraph-string row)))
      (unless (>= (+ col 1) (length str))
        (let ((nxt (element str (+ col 1))))
          (unless (or (eq? nxt #\space) (eq? nxt #\=))
            (let ((col (find-balanced #\< #\> str :start (+ col 1) :return 'position)))
              (when col
                (new Cell row (+ col 1)))))))))

  
  (method (recolorize-text start end-row)
    (let ((pos (new Cell [row start] 0))
          (targets (syntax-targets)))
      @commented-for-slow-machines-until-optimized
      (when targets
        (let ((opening (multisearch-string '(("/*" open) ("*/" close)) :position start :extended? true :reverse? true)))
          (when opening
            (bind (start . (target type)) opening
              (when (= type 'open)
                (set! pos start))))))
      (let ((range (naturals [row pos] (+ end-row 1))))
        (for-each uncolorize-row range))
      @convert-automata
      (let ((colorizer (new-colorizer self))
            (found (automata-search (syntax-automata) (get-paragraphs) end-row [row pos] [col pos])))
        (while found
          (let ((info (car found)))
            (bind ((target type) row col) info
              (let ((start (new Cell row col))
                    (end (new Cell row (+ col (length target)))))
                (set! found (colorize-type found type start end colorizer false))))))
        (finish-current~ colorizer))))
  
  
  (method public virtual (colorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (for-each colorize-entry entries))))
  
  
  (method protected virtual (get-parsed-entries)
    (let ((moniker (get-moniker)))
      (when (and moniker (file? moniker) (not (get-modified?)))
        (let ((cataloguer (get-cataloguer~ (get-application))))
          (when cataloguer
            (let* ((entries (get-file-entries~ cataloguer moniker :context '(cpp/java)))
                   (file-entry (car entries)))
              (when (and file-entry (= (get-time~ file-entry) (get-moniker-time~ (get-controller))))
                (get-definitions~ file-entry))))))))

  
  (method (colorize-entry entry)
    (letrec ((proc
              (function dynamic (entry)
                (let* ((name (get-name~ entry))
                       (line (get-line~ entry))
                       (column (get-column~ entry))
                       (start (new Cell line column))
                       (end (new Cell line (+ column (length name)))))
                  ;; until the time test of the previous method becomes functional
                  (when (<= line (get-limit))
                    (stylize 'Definition start end)
                    @cannot-work-yet
                    (when (equal? Class-Entry (class-of entry))
                      (colorize-entry (get-extends~ entry))
                      (colorize-entry (get-implements~ entry)))
                    (for-each colorize-entry (get-definitions~ entry)))))))
      (proc entry)))
  
  
  (method public (recolorize-entries)
    (let ((entries (get-parsed-entries)))
      (when entries
        (uncolorize-all)
        (colorize-syntax :entries? false)
        (for-each colorize-entry entries))))

  
  ;;;
  ;;;; Edition
  ;;;


  (method public (on-paste&stay evt)
    (let ((pos (get-start)))
      (paste-clipboard)
      (set-caret pos)))


  (method public (on-paste&next evt)
    (let ((pos (get-start)))
      (paste-clipboard)
      (set-caret (+ pos {Cell 1 0}))))

  
  ;;;
  ;;;; Reading
  ;;;
  
  
  (method (read-text-forms range . rest)
    (bind-keywords ((string null) (console? false)) rest
      (let ((string (either string (get-string range))))
        (with-closed ((reader (new String-Reader string)))
          (when console?
            (set-from-console?~ reader true))
          (read-until eof-object? reader)))))
  
  
  (method (offset-pos/range pos range)
    (if (= 0 [row start range] [row end range])
        (new Range (+ pos [start range]) (+ pos [end range]))
      (new Range
        (new Cell (+ [row pos] [row start range]) [col start range])
        (new Cell (+ [row pos] [row end range]) [col end range]))))

  
  ;;;
  ;;;; Tabulation
  ;;;


  (method public virtual (tabulate)
    (if (has-selection?)
        (for-each (if (shift-down?) untabulate-line tabulate-line)
                  (selected-lines))
      (let* ((pos (get-start))
             (row [row pos])
             (col [col pos]))
        (when (and (> row 0) (= col 0))
          (let* ((line (paragraph-string (- row 1)))
                 (rank (find-if (function dynamic (c) (not (whitespace? c))) line :return 'position)))
            (if (null? rank)
                (insert-string line)
              (insert-string (subseq line 0 rank))))))))
  
  
  (method protected virtual (tabulate-line row)
    (replace-text (new Range (new Cell row 0) (new Cell row 0))
                  (list (coerce #\tab String))))
  
  
  (method (untabulate-line row)
    (when (space/tab? (get-char (new Cell row 0)))
      (replace-text (new Range (new Cell row 0) (new Cell row 1))
                    (list ""))))
  
  
  (method (space/tab? c)
    (memq? c '(#\space #\tab)))
  
  
  (method public virtual (tabulate-lines start end)
    )


  ;;;
  ;;;; Completion
  ;;;


  (method protected virtual (favorite-completions)
    null)


  (method (get-selection-color)
    (if (not completion-active?)
        (nextmethod)
      completion-color))


  (method (back-symbol pos postfix)
    (when (or (not (text-constituent?~ syntax (get-char (if (has-selection?) (get-end) pos))))
              @dont-understand-this-test-that-makes-completion-kick-in-in-the-middle-of-words (null? postfix))
      (let ((prev (previous-cell pos)))
        (if (null? prev)
            postfix
          (let ((c (get-char prev)))
            (unless (string-delimiter? c)
              (if (not (text-constituent?~ syntax c))
                  postfix
                (let ((expl (new (explorer-class) self :start pos :end pos)))
                  (when (and (backward-expr~ expl) (memq? (get-kind~ expl) '(symbol keyword string)))
                    (let ((c (char-backward~ expl 0)))
                      (when (or (null? c) (not (string-delimiter? c)))
                        (append (get-symbol-string~ expl) (either postfix "")))))))))))))
  
  
  (method (alphabetize-completion completions offset)
    (let ((alphabet-char (remove-duplicates
                          (sort <
                                (map (function dynamic (completion)
                                       (if (> (length completion) offset) (element completion offset) #\space))
                                     completions)))))
      (coerce alphabet-char String)))


  (method (completion-string pos postfix)
    (let* ((name (back-symbol pos postfix))
           (size (length name))
           (favorites (favorite-completions))
           (favorite (assoc name favorites :test =))
           (feedback? (not (macro-playing?))))
      (if favorite
          (begin
            (when feedback?
              (clear-user-message))
            (append (either postfix "") (subseq (cdr favorite) size)))
        (when (complete-name? size)
          (let* ((completions (symbol-completions name favorites))
                 (count (length completions)))
            (cond ((null? completions)
                   (when feedback?
                     (user-message ""))
                   null)
                  ((null? (cdr completions))
                   (let ((found (car completions)))
                     (when feedback?
                       (user-message "{a}" found))
                     (if (= name found)
                         null
                       (append (either postfix "") (subseq found size)))))
                  ((> count 100)
                   (when feedback?
                     (user-message "..."))
                   null)
                  ((> count 5)
                   (let* ((common (prefix completions))
                          (offset (length common))
                          (alphabet (alphabetize-completion completions offset)))
                     (when feedback?
                       (user-message "{a} ... [{a}]" common alphabet))
                     (append (either postfix "") (subseq common size))))
                  (else
                   (let ((common (prefix completions)))
                     (when feedback?
                       (user-message "{l :detail :human}" completions))
                     (append (either postfix "") (subseq common size))))))))))
  
  
  (method protected virtual (complete-name? size)
    (>= size 2))
  
  
  (method protected virtual (symbol-completions name favorites)
    (unless (numeric? name)
      (let ((cataloguer (get-cataloguer~ (get-application))))
        (when cataloguer
          (let ((completions (get-completions~ cataloguer name :context (get-context)))
                (length (length name)))
            (for-each (function dynamic (pair)
                        (let ((favorite (cdr pair)))
                          (when (compare-n (->string favorite) name length)
                            (set! completions (cons favorite completions)))))
                      favorites)
            completions)))))
  
  
  (method protected virtual (auto-complete key)
    (get-style-at (get-start))
    (let* ((end (get-end))
           (last (essay (> [col end] 0) (get-char (- end 1))))
           (class (class-of self)))
      (if (not (auto-complete-char?~ syntax key last))
          (complete-current key (get-start) (coerce key String) false true)
        (let* ((completion-string (join (selection-lines) (crlf)))
               (offset (essay completion-string (find key completion-string :return 'position)))
               (replacement-string (essay offset (subseq completion-string 0 offset))))
          (when (and completion-active? @w (memq? key (auto-complete-characters~ class)) replacement-string)
              (replace-selection (list replacement-string)))
          (end-completion)
          (insert-char/backspace key)
          (complete-current null (get-start) null false false)))))
  

  (method (complete-current key pos postfix back? inserted?)
    (if (textual-style? (get-style-at pos))
        (insert-char/backspace key)
      (let ((string (completion-string pos postfix)))
        (if (null? string)
            (begin
              (insert-char/backspace key)
              (end-completion))
          (if back?
              (replace-text (new Range (previous-cell (get-start)) (get-end)) (list string))
            (insert-string string))
          (set-completion (new Range (if inserted? (next-cell pos) pos) (+ pos (length string))))))))
  
  
  (method protected (has-completion?)
    (and completion-active? (has-selection?)))


  (method (set-completion range)
    (set! completion-active? true)
    (set-selection range))


  (method (remove-completion)
    (when completion-active?
      (replace-selection (list ""))
      (set! completion-active? false)))


  (method protected (end-completion)
    (when completion-active?
      (set! completion-active? false)
      (set-caret (get-end))))
  
  
  (method protected (convert-completion)
    (when completion-active?
      (let ((start (get-start))
            (end (get-end)))
        (end-completion)
        (set-selection (new Range start end) :set-anchor? false))))


  (method (insert-char/backspace c . rest)
    (bind-keywords ((word? false)) rest
      (when c
        (if (/= c #\backspace)
            (insert-char c)
          ; remove competion before doing backspace
          (when completion-active?
            (replace-selection (list "")))
          (backspace word?)
          (flash-matching-character)))))
    
  
  ;;;
  ;;;; Arguments
  ;;;
  
  
  (method protected virtual (show-arguments)
    )

  
  ;;;
  ;;;; Mouse Copy
  ;;;
  
  
  (method (cursor-update pos)
    (if (not (alt-down?))
        (nextmethod pos)
      (show-text-cursor)
      (set-cursor :finger)))

  
  (method (mouse-copy pos destination)
    (when destination
      (let* ((cell (view->text pos))
             (range (expr-range cell)))
        (when (control-down?)
          (decrease! [start range]))
        (let ((copy (get-string range)))
          (when range
            (mouse-insert~ destination copy))))
      true))
  
  
  (method protected virtual (expr-range pos)
    )
  
  
  ;;;
  ;;;; Arrow Keys
  ;;;
  
  
  (method (left-arrow-press modifiers)
    (convert-completion)
    (nextmethod modifiers))
  
  
  (method (up-arrow-press modifiers)
    (convert-completion)
    (nextmethod modifiers))
  
  
  (method (right-arrow-press modifiers)
    (convert-completion)
    (nextmethod modifiers))
  
  
  (method (down-arrow-press modifiers)
    (convert-completion)
    (nextmethod modifiers))
  
  
  ;;;
  ;;;; Tabify
  ;;;
  
  
  (method (on-tabify evt)
    (tabify))
  
  
  (method (tabify)
    (for-each tabify-line
              (naturals [row (get-start)] (+ [row (get-end)] 1))))
  
  
  (method (tabify-line row)
    @to-convert-to-outline-text
    (let* ((line (paragraph-string row))
           (char (find-if (function dynamic (c) (not (whitespace? c))) line :return 'position)))
      (when (and char (> char 0))
        (let* ((column (char->column line char))
               (tabs   (floor (/ column tab-size)))
               (spaces (modulo column tab-size)))
          (replace-text (new Range (new Cell row 0) (new Cell row char))
                        (list (append! (make-string tabs #\tab)
                                       (make-string spaces #\space))))))))


  ;;;
  ;;;; Match
  ;;;
  
  
  (method protected virtual (flash-character? char)
    false)


  (method protected (flash-matching-character)
    (when (and (empty-selection?) (not (at-beginning?)))
      (let ((pos (previous-cell (get-end))))
        (when (flash-character? (get-char pos))
          (catch (Explore-Error err
                   (bell))
            (let ((expl (new (explorer-class) self :start (get-end))))
              (if (not (backward-expr~ expl))
                  (bell)
                (flash-character (get-start~ expl) pos))))))))


  (method (flash-character start end)
    (unless (macro-playing?)
      (if (cell-displayed? start)
          (let ((old (get-selection)))
            (set-selection (new Range start (next-cell start)))
            (update-view)
            (sleep 200)
            (set-selection old)
            (update-view))
        (let* ((pos (text->view end))
               @w(tran (acquire~ (get-desktop) self pos))
               @w(tool (new Tooltip :position tran :size {Dimension 100 20} :visible? false))
               (expl (new (explorer-class) self :start (+ start 1) :end (+ start 1))))
          (user-message "{l :detail :human}" (map (function dynamic (mark)
                                                    (get-string [range mark]))
                                                  (collect-forward-exprs~ expl 3)))
          (sleep 200)))))
  
  
  ;;;
  ;;;; Java
  ;;;
    
  
  (method (on-browse-java evt)
    (browse-java))
  
  
  (method (browse-java)
    @wait
    (let ((expr (current-expr)))
      (if (is-not? expr Symbol)
          (bell)
        (let* ((classname (->string expr))
               (javaClass (lookupClass~ org.apache.bcel.Repository classname)))
          (if (null? javaClass)
              (error "Unable to find java class: {a}" classname)
            (let* ((host (new-frame Java-Manager))
                   (manager (get-guest~ host)))
              (browse-classes~ manager (list classname))))))))


  ;;;
  ;;;; Read/Write
  ;;;
  
  
  (method (on-patch-file evt)
    @convert
    (let* ((file (get-moniker~ controller))
           (filename (get-name~ file))
           (patched (new File (list 'User "Patches" filename)))
           (patches (get-patches))
           (appl (get-application))
           (frame (get-player)))
      (save)
      (close~ frame)
      (create-directories~ patched)
      (copy-file~ file patched :overwrite-read-only? true)
      (map-set! patches name (list :source patched))
      (edit-document~ appl patched)
      (user-message "File {a} patched" filename)))
  
  
  (method (on-set-read/write evt)
    (let ((moniker (get-moniker~ controller)))
      (set-read/write~ moniker)
      (update-status)))

  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  @convert
  (method (debug-view view)
    (nextmethod view)
    (let* ((range (get-selection))
           (strings (range-strings range))
           (string (car text))
           (entries (get-parsed-entries))
           (entry (find-if (function dynamic (element)
                             (equal? string (get-name~ element)))
                           entries)))
      (set! [%t Development] entry))))


;;;
;;;; Definitions-Menu
;;;


(class Definitions-Menu extends Context-Menu
  
  
  (property definitions  getter get-definitions  setter set-definitions)
  (property history-item getter get-history-item setter set-history-item)
  
  
  (method public (get-definitions)
    definitions)
  
  
  (method public (set-definitions list)
    (set! definitions list))
  
  
  (method public (get-history-item)
    history-item)
  
  
  (method public (set-history-item item)
    (set! history-item item))
  
  
  (method (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (function dynamic (definition)
                    (let ((title (present~ definition 'definitions)))
                      (new Label-Item parent: self :title title :action-handler (new Event-Handler :target self :method-name 'on-action :properties (list :definition definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (function dynamic (user-data title parent)
                            (new Label-Item parent: parent :title title :action-handler (new Event-Handler :target menu :method-name 'on-action :properties (list :definition user-data)))))
             (get-string (function dynamic (user-data) (present~ user-data 'definitions))))
        (make-condensed-menu definitions create-item :key get-string))))
  
  
  (method (definition<? x y)
    (< (present~ x 'definitions) (present~ y 'definitions)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit~ (get-property~ evt :definition))))


;;;
;;;; References-Menu
;;;


(class References-Menu extends Context-Menu
  
  
  (property target       getter get-target       setter set-target)
  (property definitions  getter get-definitions  setter set-definitions)
  (property history-item getter get-history-item setter set-history-item)
  
  
  (method public (get-target)
    target)
  
  
  (method public (set-target trg)
    (set! target trg))
  
  
  (method public (get-definitions)
    definitions)
  
  
  (method public (set-definitions list)
    (set! definitions list))
  
  
  (method public (get-history-item)
    history-item)
  
  
  (method public (set-history-item item)
    (set! history-item item))
  
  
  (method (finish rest)
    (nextmethod rest)
    (if (< (length definitions) 20)
        (for-each (function dynamic (definition)
                    (let ((title (->string (present~ definition 'references))))
                      (new Label-Item parent: self :title title :action-handler (new Event-Handler :target self :method-name 'on-action :properties (list :definition definition)))))
                  (sort definition<? definitions))
      (let* ((menu self)
             (create-item (function dynamic (user-data title parent)
                            (new Label-Item parent: parent :title title :action-handler (new Event-Handler :target menu :method-name 'on-action :properties (list :definition user-data)))))
             (get-string (function dynamic (user-data) (present~ user-data 'references))))
        (make-condensed-menu definitions create-item :key get-string))))
  
  
  (method (definition<? x y)
    (< (present~ x 'references) (present~ y 'references)))
  
  
  (method (on-action evt)
    (add-history~ (get-application) history-item)
    (edit-reference~ (get-property~ evt :definition) target))))
