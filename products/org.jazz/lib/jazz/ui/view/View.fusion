;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Views
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2007
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Assem Hakmeh
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(library jazz.ui.view.View jazz


(import (jazz.library)
        (jazz.designer)
        (jazz.ui)
        (jazz.ui.window)
        (jazz.ui.clipboard)
        (jazz.ui.view)
        (jazz.ui.workspace)
        (jazz.utilities)
        (jazz.platform)
        ;; temp for timers
        (jazz.platform.windows)
        (jazz.literals))


;;;
;;;; View-Class
;;;


(class View-Class extends Drawing-Class
  
  
  ;;;
  ;;;; Palette
  ;;;
  
  
  @convert
  (method meta protected virtual (palette-class)
    (unimplemented 'palette-class)
    @Host-Palette
    Host-Palette)
  
  
  @convert
  (method meta public virtual (palette-icon)
    {Bitmap-Resource "Window"})
  
  
  @convert
  (method meta protected virtual (palette-title)
    null)
  
  
  @convert
  (method meta protected virtual (palette-position)
    null)
  
  
  @convert
  (method meta protected virtual (palette-size)
    null)
    
  
  ;;;
  ;;;; Dialog
  ;;;
  
  
  @convert
  (method meta protected virtual (dialog-class)
    Host-Dialog)
  
  
  @convert
  (method meta protected virtual (dialog-title)
    null)
  
  
  @convert
  (method meta protected virtual (dialog-position)
    null)
  
  
  @convert
  (method meta protected virtual (dialog-size)
    null)
  
  
  @convert
  (method meta protected virtual (dialog-sizable?)
    false)
  
  
  @convert
  (method meta protected virtual (dialog-closable?)
    true)
  
  
  @convert
  (method meta protected virtual (center-dialog inner)
    (let* ((outer (get-size~ (get-desktop)))
           (pos (center inner outer)))
      (new Point [h pos] (- [v pos] 50))))
  
  
  ;;;
  ;;;; Actions
  ;;;
  
  
  (method (focus-actions)
    (cons (find-actions 'view)
          (nextmethod)))
  
  
  (method (guest-actions)
    (cons (find-actions 'guest)
          (nextmethod)))


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (get-class-image)
    {Bitmap-Resource "View"})

  
  (method (property-presentation property)
    (case (field-name property)
      ((title)          "Title")
      ((font)           "Font")
      ((background)     "Background")
      ((auto-size?)     "Auto Size")
      ((tooltip?)       "Tooltip")
      ((tooltip-text)   "Tooltip Text")
      ((draggable?)     "Draggable")
      ((drag-tolerance) "Drag Tolerance")
      ((enabled?)       "Enabled")
      ((action)         "Action")
      ((outline)        "Outline")
      ((overlay)        "Overlay")
      ((user-data)      "User Data")
      (else (nextmethod property)))))


;;;
;;;; View
;;;


(class View metaclass View-Class extends Drawing
  

  ;; Quick fix for Assem's holding the right button down to scroll horizontally and not pop a context menu
  ;; (need to think of a cleaner solution for this great idea...)

  
  (property title                                initialize {}                    getter get-title           setter set-title)
  (property font                                 initialize {Font name: Ansi-Var} getter get-font            setter set-font)
  (property background                           initialize {}                    getter get-background      setter set-background)
  (property auto-size?                           initialize false                 getter get-auto-size?      setter set-auto-size?)
  (property tooltip?                             initialize false                 getter get-tooltip?        setter set-tooltip?)
  (property tooltip-text                         initialize {}                    getter get-tooltip-text    setter set-tooltip-text)
  (property draggable?                           initialize false                 getter get-draggable?      setter set-draggable?)
  (property drag-tolerance                       initialize 5                     getter get-drag-tolerance  setter set-drag-tolerance)
  (property enabled?                             initialize true                  getter get-enabled?        setter set-enabled?)
  (property action                               initialize {}                    getter get-action          setter set-action)
  (property outline                              initialize {}                    getter get-outline         setter set-outline)
  (property offscreen?                 <Boolean> initialize false                 getter get-offscreen?      setter set-offscreen?)
  (property overlay                              initialize {}                    getter get-overlay         setter set-overlay)
  (property effect                               initialize {}                    getter get-effect          setter set-effect)
  (property user-data                            initialize {}                    getter get-user-data       setter set-user-data)

  
  (property cursor-update-handler                initialize {} getter get-cursor-update-handler    setter set-cursor-update-handler)
  (property mouse-enter-handler                  initialize {} getter get-mouse-enter-handler      setter set-mouse-enter-handler)
  (property mouse-hover-handler                  initialize {} getter get-mouse-hover-handler      setter set-mouse-hover-handler)
  (property mouse-leave-handler                  initialize {} getter get-mouse-leave-handler      setter set-mouse-leave-handler)
  (property mouse-down-handler                   initialize {} getter get-mouse-down-handler       setter set-mouse-down-handler)
  (property mouse-move-handler                   initialize {} getter get-mouse-move-handler       setter set-mouse-move-handler)
  (property mouse-up-handler                     initialize {} getter get-mouse-up-handler         setter set-mouse-up-handler)
  (property drag-move-handler                    initialize {} getter get-drag-move-handler        setter set-drag-move-handler)
  (property drag-up-handler                      initialize {} getter get-drag-up-handler          setter set-drag-up-handler)
  (property double-click-handler                 initialize {} getter get-double-click-handler     setter set-double-click-handler)
  (property current-drop-handler                 initialize {} getter get-current-drop-handler     setter set-current-drop-handler)
  (property receive-drop-handler                 initialize {} getter get-receive-drop-handler     setter set-receive-drop-handler)
  (property receive-files-handler                initialize {} getter get-receive-files-handler    setter set-receive-files-handler)
  (property context-menu-handler                 initialize {} getter get-context-menu-handler     setter set-context-menu-handler)
  (property lost-capture-handler                 initialize {} getter get-lost-capture-handler     setter set-lost-capture-handler)
  (property key-down-handler                     initialize {} getter get-key-down-handler         setter set-key-down-handler)
  (property key-up-handler                       initialize {} getter get-key-up-handler           setter set-key-up-handler)
  (property key-press-handler                    initialize {} getter get-key-press-handler        setter set-key-press-handler)
  (property arrow-press-handler                  initialize {} getter get-arrow-press-handler      setter set-arrow-press-handler)
  (property escape-press-handler                 initialize {} getter get-escape-press-handler     setter set-escape-press-handler)
  (property backspace-press-handler              initialize {} getter get-backspace-press-handler  setter set-backspace-press-handler)
  (property return-press-handler                 initialize {} getter get-return-press-handler     setter set-return-press-handler)
  (property tab-press-handler                    initialize {} getter get-tab-press-handler        setter set-tab-press-handler)
  (property content-change-handler               initialize {} getter get-content-change-handler   setter set-content-change-handler)
  (property selection-handler                    initialize {} getter get-selection-handler        setter set-selection-handler)
  (property action-handler                       initialize {} getter get-action-handler           setter set-action-handler)

  
  (slot player                                   initialize {})
  (slot scroller                                 initialize {})
  (slot renderer                                 initialize {})
  (slot scaled?                     <Boolean>    initialize false)
  (slot scaling                     <Real>       initialize 1.0)
  (slot previous-size               <Dimension+> initialize {})
  (slot update-locked?              <Boolean>    initialize false)
  (slot scrollee-locked?            <Boolean>    initialize false)
  (slot modified?                   <Boolean>    initialize false)
  (slot tools-info                               initialize {})
  
  (definition inhibit-context-menu?
    false)
  
  (method (shortcut-update action-item));;abstract
  
  
  ;;;
  ;;;; Initialization
  ;;;
  
  
  (method (conclude rest)
    (nextmethod rest)
    (layout)
    (layout-scrollee))

  
  (method (print printer readably)
    (print-unreadable self printer
      (function dynamic (printer)
        (format printer "{a} {a} {a} {a}" title name position size))))
  
  
  ;;;
  ;;;; Destruction
  ;;;


  (method (destroy)
    (let ((parent parent)
          (rect (get-rect)))
      (nextmethod)
      (when (is? parent View)
        (invalidate-rect~ parent rect)
        (when player
          (view-destroyed~ player self)
          (set! player null)))))
    
  
  ;;;
  ;;;; Aliases
  ;;;

  
  (method (component-alias name)
    (case name
      ((:host) (get-host))
      ((:root) (get-root))
      ((:initiator) (popup-initiator))
      (else (nextmethod name))))
  
  
  ;;;
  ;;;; Player
  ;;;
  
  
  (method (get-player)
    (unless player
      (set! player (essay parent (get-player~ parent))))
    player)
  
  
  (method public (set-player plr)
    (set! player plr)
    (with ((proc <Procedure>
            (function dynamic (view)
              (set-player~ view player))))
      (for-each-view proc)))
  
  
  (method public (in-player?)
    (not-null? (get-player)))


  (method public (get-overlapped)
    (let ((player (get-player)))
      (when player
        (get-overlapped~ player))))
  
  
  (method public (different-overlapped? window)
    (or (null? window) (neq? (get-overlapped) (get-overlapped~ window))))
  
  
  ;;;
  ;;;; Favorite
  ;;;
  
  
  (method public virtual (add-to-favorites)
    )
  
  
  ;;;
  ;;;; Hosting
  ;;;


  (method public (get-host)
    (get-player))
  
  
  (method public (get-guest)
    (get-guest~ (get-host)))
  
  
  (method public virtual (install-in-host host)
    )
  
  
  (method public virtual (uninstall-from-host host)
    )
  
  
  (method public virtual (save-guest designer session)
    )
  
  
  (method public (add-guest-preferences designer session . initargs)
    (unimplemented 'add-guest-preferences)
    @Guest-Preferences
    (let* ((host (get-host))
           (pref (new Guest-Preferences
                   :position (get-position)
                   :size     (get-size)
                   name:     (type-name (class-of self))
                   :initargs (cons :position (cons (get-position~ host)
                                                   (cons :size (cons (get-size~ host)
                                                                     initargs)))))))
      (add-child~ designer pref session :design-events? false :select? false)))
  
  
  (method public virtual (focus-default)
    )
  
  
  (method public virtual (get-text-view)
    null)
  
  
  (method public (frame-guest?)
    (let ((host (get-host)))
      (and (is? host Host-Frame)
           (eq? (get-guest~ host) self))))
  
  
  ;;;
  ;;;; Frame
  ;;;
  
  
  (method public virtual (frame-activate)
    )
  
  
  (method public virtual (frame-deactivate)
    )
  
  
  (method public virtual (frame-workspaces)
    null)
  
  
  (method public (effective-frame-workspaces)
    (unimplemented 'effective-frame-workspaces)
    @external-name
    (let* ((pref (get-preferences 'workspaces))
           (associations (get-associations~ pref))
           (external (external-name :error? false)))
      (filter-inexistant-workspaces pref
        (either (essay external (assq external associations))
                (frame-workspaces)))))
  
  
  (method (filter-inexistant-workspaces pref workspaces)
    (let ((names (map component-name (get-children~ pref))))
      (collect-if (function dynamic (name)
                    (memq? name names))
                  workspaces)))


  (method (get-frame)
    player)
  
  
  (method public virtual (guest-icon)
    {Bitmap-Resource "Window"}
    @convert
    (frame-icon~ (class-of self)))
  
  
  (method public virtual (focus-activate)
    )
  
  
  (method public virtual (focus-deactivate)
    )
  
  
  (method public virtual (maximize)
    )
  
  
  (method public virtual (restore)
    )
  
  
  ;;;
  ;;;; Tool
  ;;;
  
  
  (method public virtual (tool-preferences)
    null)
  
  
  ;; All this tool-info stuff remains to be done. The idea is to give
  ;; docked tools a place to persist information like the selection so that
  ;; when switching documents like designs, the selection is preserved...
  ;; Note: the show-invisibles? slot of Design-Book-View is clearly a handcoded
  ;; piece of code that could be redone using tool-infos
  (method (get-tools-info)
    (unless tools-info
      (set! tools-info (new-hashtable eq?)))
    tools-info)
  
  
  (method public virtual (get-tool-info tool-name)
    (hash-ref (get-tools-info) tool-name))
  
  
  (method public virtual (set-tool-info tool-name info)
    (hash-set! (get-tools-info) tool-name info))
  
  
  ;;;
  ;;;; Palette
  ;;;
  
  
  (method public virtual (host-activate)
    )
  
  
  (method public virtual (host-deactivate)
    )
  
  
  (method public virtual (client-activate)
    )
  
  
  (method public virtual (client-deactivate)
    )
  
  
  ;;;
  ;;;; Docked
  ;;;
  
  
  (method public virtual (get-tools)
    null)
  
  
  (method public virtual (workspace-minimisable?)
    true)
    
  
  ;;;
  ;;;; Dialog
  ;;;
  
  
  (method public virtual (validate-dialog)
    )
  
  
  (method public virtual (get-modal-result)
    null)
  
  
  (method public virtual (has-dialog-result?)
    false)
  
  
  ;;;
  ;;;; Editor
  ;;;
  
  
  (method public virtual (get-editor-view)
    null)
  
  
  ;;;
  ;;;; Content
  ;;;
  
  
  (method public virtual (content-valid?)
    true)
  
  
  (method public virtual (validate-content)
    )

  
  ;;;
  ;;;; Root
  ;;;
  
  
  (method public virtual (root-activated)
    )
  
  
  (method public virtual (root-deactivated)
    )
  
  
  ;;;
  ;;;; Parent
  ;;;
  
  
  (method (set-parent parent)
    (nextmethod parent)
    (set-player (if parent (get-player~ parent) null)))
  
  
  ;;;
  ;;;; Outer
  ;;;
  
  
  (method public (outer-view limit)
    (let ((outer parent)
          (view self))
      (while (and outer (inner?~ outer view) (neq? view limit))
        (set! view outer)
        (set! outer (get-parent~ outer)))
      view))
  
  
  (method public virtual (inner? view)
    false)
  
  
  ;;;
  ;;;; Title
  ;;;
  
  
  (method public virtual (get-title)
    title)
  
  
  (method public virtual (set-title value)
    (set! title value)
    (adjust-size))
  
  
  ;;;
  ;;;; Visibility
  ;;;


  (method (show)
    (nextmethod)
    (invalidate-view))


  (method (hide)
    (nextmethod)
    (invalidate-view))
  
  
  (method protected virtual (update-displayed)
    )
  
  
  ;;;
  ;;;; Enabled
  ;;;
  

  (method public virtual (get-enabled?)
    enabled?)


  (method public virtual (set-enabled? flag)
    (set! enabled? flag)
    (invalidate-view))
  
  
  ;;;
  ;;;; Scaling
  ;;;
  

  (method (get-scaled?)
    scaled?)


  (method (set-scaled? value)
    (set! scaled? value)
    (update-displayed)
    (update-scrollbars)
    ;; Depending on whether it's the view's point of vue or it's parent
    ;; we either have to invalidate the view or its parent...
    (if parent
        (invalidate-view~ parent)
      (invalidate-view)))
  

  (method (get-scaling)
    scaling)


  (method (set-scaling value)
    (set! scaling (/ (round (* value 1000)) 1000)))

  
  ;;;
  ;;;; Actions
  ;;;
  

  (method public (get-action)
    action)


  (method public (set-action value)
    (set! action value)
    (let ((action-item (require-action-item action)))
      (when action-item
        (register-actionable~ action-item self))))

  
  ;;;
  ;;;; Actionable
  ;;;
  
  
  (method (enabled-update action-item)
    (set-enabled? (get-enabled?~ action-item)))

  
  ;;;
  ;;;; Outline
  ;;;


  (method public (get-outline)
    outline)


  (method public (set-outline value)
    (set! outline value))
  
  
  (method public (outline-select . rest)
    (unimplemented 'outline-select)
    @Tree-View
    (bind-keywords ((focus? false)) rest
      (let* ((row (outline-row))
             (rank (row-rank~ outline row))
             (elem (if (and (is? outline Tree-View) (eq? (get-selection-mode~ outline) 'cell)) (new Cell rank 0) rank)))
        (when focus?
          (acquire-focus~ outline))
        (set-selection~ outline (list elem)))))
  
  
  (method public (outline-row)
    (unimplemented 'outline-row)
    @Outline-Row
    (find-ascendant Outline-Row))


  ;;;
  ;;;; Offscreen
  ;;;
  
  
  (method (get-offscreen?)
    offscreen?)
  
  
  (method (set-offscreen? flag <bool>)
    (set! offscreen? flag))


  ;;;
  ;;;; Overlay
  ;;;
  
  
  (method (get-overlay)
    overlay)
  
  
  (method (set-overlay value)
    (set! overlay value))


  ;;;
  ;;;; Effect
  ;;;
  
  
  (method (get-effect)
    effect)
  
  
  (method (set-effect value)
    (set! effect value))

  
  ;;;
  ;;;; User data
  ;;;


  (method public (get-user-data)
    user-data)


  (method public (set-user-data value)
    (set! user-data value))

  
  ;;;
  ;;;; Lie
  ;;;
  
  
  (method (get-lie-parent h <Real> v <Real> sc <Real>)
    (if (or (null? parent) (not scaled?))
        (nextmethod h v sc)
      (get-lie-parent~ parent (+ [h position] (* h scaling)) (+ [v position] (* v scaling)) (* sc scaling))))

  
  ;;;
  ;;;; Global
  ;;;
  
  
  (method public (get-global)
    (+ (get-window-position~ player) (get-lie)))

  
  ;;;
  ;;;; Coordinates
  ;;;
  
  
  (method (get-delta origin)
    (let ((origin-player (get-player~ origin)))
      (if (and player origin-player (neq? player origin-player))
          (bind-values (h <Real> v <Real> sc <Real>) (get-lie-parent 0.0 0.0 1.0)
            (let ((delta <Point> (- (get-global~ origin) (get-global))))
              (values (* [h delta] sc) (* [v delta] sc) sc)))
        (nextmethod origin))))
  
  
  ;;;
  ;;;; Position
  ;;;
  
  
  (method (default-position)
    {Point 0 0})
  

  (method (set-position pos)
    (when (/= pos position)
      ;; todo: it is possible to invalidate more precisely
      (let ((inval? (and player (is? parent View))))
        (with ((bounds (essay inval? (get-bounds)))
               (old (essay inval? (acquire~ parent self bounds))))
          (set! position pos)
          (when player
            (with ((new (get-bounds)))
              (when old
                (invalidate-rect~ parent old))
              (invalidate-rect new)))))
      (position-change position)))

  
  ;;;
  ;;;; Size
  ;;;
  
  
  (method (default-size)
    {Dimension 100 100})
  
  
  (method public virtual (minimal-size)
    null)
  
  
  (method public virtual (preferred-size)
    (get-size))
  
  
  (method public virtual (fit-size)
    )
  

  (method (set-size sz)
    (when (/= sz size)
      (let ((inval? (and player (is? parent View))))
        (with ((old (essay inval? (get-bounds)))
               (new (essay inval? (size-rect sz)))
               (rect (essay inval? (rect-union old new)))
               (acquired (essay inval? (acquire~ parent self rect))))
          (set! size sz)
          (size-change size)
          (unless scroller
            (content-size-change size))
          (when inval?
            (invalidate-rect~ parent acquired))))))
  
  
  (method public (set-preferred-size)
    (set-size (preferred-size)))
  
  
  ;;;
  ;;;; Layout
  ;;;
  
  
  (method public (layout-view)
    (layout-drawing))


  ;;;
  ;;;; Layer
  ;;;
  
  
  (method public (front-view)
    (last children))
  
  
  (method public (back-view)
    (first children))
  
  
  (method (send-before target)
    (nextmethod target)
    (invalidate-view))
  
  
  (method (bring-to-front)
    (nextmethod)
    (invalidate-view))


  (method (send-to-back)
    (nextmethod)
    (invalidate-view))


  (method (send-child-to-front child)
    (set! children (move-to-tail! child children)))


  (method (send-child-to-back child)
    (set! children (move-to-head! child children)))

  
  ;;;
  ;;;; Scrolle
  ;;;
  
  
  (method protected virtual (scrollee-width)
    (get-width))
  
  
  (method protected virtual (scrollee-height)
    (get-height))

  
  ;;;
  ;;;; Update
  ;;;
  
  
  (method public (get-update-locked?)
    update-locked?)
  
  
  (method public (with-update-locked proc)
    (if update-locked?
        (proc)
      (unwind-protect
          (begin
            (set! update-locked? true)
            (proc))
        (set! update-locked? false)
        (invalidate-update))))
  
  
  (method protected virtual (invalidate-update)
    (invalidate-view)
    (update-scrollbars))

  
  ;;;
  ;;;; Rendering
  ;;;
  

  (method public (get-renderer)
    renderer)
  
  
  (method public (set-renderer value)
    (set! renderer value))
  
  
  (method (render dc context update lh lv sh sv sc sc?)
    (if renderer
        (render~ renderer self dc context update lh lv sh sv sc sc?)
      (nextmethod dc context update lh lv sh sv sc sc?)))

  
  ;;;
  ;;;; Drawing
  ;;;
  
  
  (method (draw-background dc context)
    (let ((background (get-drawing-background context)))
      (when background
        (with ((bounds (get-bounds)))
          (fill-rect~ dc bounds background)))))
  
  
  (method public virtual (get-drawing-background context)
    background)
  
  
  (method (draw-content dc context update lh lv sh sv sc sc?)
    (set-font~ dc font)
    (draw dc context update lh lv))

  
  ;;;
  ;;;; Page Setup
  ;;;
  
  
  (method public virtual (get-page-setup)
    (default-page-setup~ (get-application)))
  
  
  (method public virtual (get-page-setup-designer)
    (default-page-setup-designer~ (get-application)))
  
  
  (method public (get-page-setup-for name)
    (let* ((page-setup (get-page-setup))
           (branch (find-component~ page-setup name)))
      (when branch
        (set-active-branch~ page-setup branch))
      page-setup))

  
  ;;;
  ;;;; Print
  ;;;
  
  
  (method public virtual (print-document)
    (unimplemented 'print-document)
    @Print-Dialog
    (bind-values (hdc print-to-file? selection? pages? from to nb-copies orientation) (get-modal Print-Dialog)
      (if print-to-file?
          (print-picture)
        (let* ((dc (new DC hdc))
               (page-setup (get-page-setup-for 'printer))
               (resolution (get-caps~ dc LOGPIXELSX)))
          (setup-clipper~ dc (new Rect 0 0 10000 10000))
          (let ((job (new Printer-Job dc self page-setup resolution :selection? selection? :from (essay pages? from) :to (essay pages? to) :nb-copies nb-copies)))
            (print-job~ job))))))
  
  
  (method public virtual (print-picture)
    (unimplemented 'print-picture)
    @BrowseFolder-Dialog
    (let ((directory (get-modal BrowseFolder-Dialog))
          (filename "page"))
      (delete-existing directory filename)
      (let* ((page-setup (get-page-setup-for 'file))
             (resolution (get-caps~ (desktop-dc) LOGPIXELSX))
             (job (new Picture-Job directory filename self page-setup resolution)))
        (print-job~ job))
      (message-box "Print done")))
  
  
  (method (delete-existing directory filename)
    (let ((regexp (new Regular-Expression (format "{a}*.emf" filename))))
      (iterate-directory~ directory
        (function dynamic (file)
          (when (matches?~ regexp (get-name~ file))
            (delete-file~ file)))
        :recursive? false)))

  
  (method public virtual (print-layout . rest)
    (bind-keywords ((from-preview? false)) rest
      (with-locked-update
        (function dynamic ()
          (let* ((client (current-document))
                 (current (selected-workspace))
                 (ws (new Page-Workspace name: 'page :previous current)))
            (apply-preferences~ ws)
            (let* ((toplevel (get-toplevel))
                   (toolbar (find-palette~ (get-workspace-splitter~ toplevel) Page-Toolbar)))
              (set-visible?~ (locate~ toolbar 'print-preview) (not from-preview?))
              (layout-view~ toolbar))
            (let* ((frame (new-frame Page-Editor :host-title "Print Layout" :client client))
                   (pane (get-guest~ frame)))
              (acquire-focus~ pane)))))))
  

  (method public virtual (print-preview . rest)
    (bind-keywords ((from-layout? false)) rest
      (with-locked-update
        (function dynamic ()
          (let* ((frame (new-frame Preview-Pane :host-title "Print Preview" :host-visible? false :client self))
                 (pane (get-guest~ frame))
                 (current (selected-workspace))
                 (ws (new Preview-Workspace name: 'preview :previous current :pane pane)))
            (apply-preferences~ ws)
            (let* ((toplevel (get-toplevel))
                   (toolbar (find-palette~ (get-workspace-splitter~ toplevel) Preview-Toolbar)))
              (set-visible?~ (locate~ toolbar 'print-layout) (not from-layout?))
              (layout-view~ toolbar))
            (set-visible?~ frame true)
            (acquire-focus~ pane))))))
  
  
  (method public virtual (get-print-area context)
    (position/size->rect {Point 0 0} (scrollee-size)))
  
  
  (method public virtual (paginate page-width page-height)
    (let* ((area (get-print-area null))
           (width (rect-width area))
           (height (rect-height area))
           (cols (ceil (/ width page-width)))
           (rows (ceil (/ height page-height)))
           (pages (new List-Factory)))
      (for-each (function dynamic (row)
                  (for-each (function dynamic (col)
                              (let* ((h (+ [left area] (* col page-width)))
                                     (v (+ [top area] (* row page-height)))
                                     (page (new Rect h v (+ h page-width) (+ v page-height))))
                                (put~ pages page)))
                            (naturals 0 cols)))
                (naturals 0 rows))
      (get-output~ pages)))
  
  
  (method protected (with-printing proc)
    (let ((preserved null))
      (unwind-protect
          (begin
            (set! preserved (setup-printing))
            (proc))
        (when preserved
          (restore-printing preserved)))))
  
  
  (method protected virtual (setup-printing)
    (let ((pos position)
          (sc? scaled?))
      (set! position (new Point 0 0))
      (set! scaled? false)
      (update-displayed)
      (list :position pos :scaled? sc?)))
  
  
  (method protected virtual (restore-printing preserved)
    (set! position (getf preserved :position))
    (set! scaled? (getf preserved :scaled?))
    (update-displayed))
  
  
  ;;;
  ;;;; Export
  ;;;
  
  
  @convert
  (method public (export-picture . rest)
    (bind-keywords ((context null) (where 'file) (destination null) (empty-clipboard? true)) rest
      ;; it is necessary to use a temporary file because directly poping
      ;; the savefile dialog can disrupt the context (ex: popups closing)
      (let ((file (case where ((clipboard) null) ((file) (create-temporary-file)))))
        (with-cursor :wait
          (function dynamic ()
            (let ((metafile))
              (with-closed ((picture (new Picture :file file)))
                (with-printing
                  (function dynamic ()
                    (let* ((area (get-print-area context))
                           (lie (get-lie))
                           (lh [h lie])
                           (lv [v lie]))
                      (with ((content (offset-rect area lh lv)))
                        (with-clipper~ picture content
                          (function dynamic ()
                            (paint-drawing picture context null lh lv [left content] [top content] 1.0 false)))))))
                (set! metafile (get-metafile~ picture)))
              (if (eq? where 'clipboard)
                  (set-clipboard metafile :type 'metafile :empty? empty-clipboard?)
                (delete-metafile~ Picture metafile)
                (catch (Cancel-Signal
                         (delete-file~ file))
                  (let ((dest (either destination (get-modal SaveFile-Dialog :default-extension "emf" :extensions '(("Enhanced metafile (*.emf)" . "*.emf"))))))
                    (when (exists?~ dest)
                      (delete-file~ dest))
                    (move-pathname~ file dest))))))))))


  ;;;
  ;;;; Scroll
  ;;;
  
  
  (method public (get-scroller)
    scroller)
  
  
  (method public virtual (set-scroller view)
    (set! scroller view))
  
  
  (method public virtual (set-scroll-pos part pos redraw?)
    (when scroller
      (set-scroll-pos~ scroller part pos redraw?)))
    
  
  (method public virtual (set-scroll-info part min max page)
    (when scroller
      (set-scroll-info~ scroller part min max page)))
  
  
  (method public (update-scrollbars)
    (when (and scroller (not update-locked?))
      (let ((min  0)
            (max  (get-height))
            (page (get-page-size 'vert)))
        (set-vscroll-needed?~ scroller (> max page))
        (when (get-vscroll?~ scroller)
          (set-scroll-info 'vert min max page)))
      (let ((min  0)
            (max  (- (get-width) (if (get-vscroll?~ scroller) 13 0)))
            (page (get-page-size 'horz)))
        (set-hscroll-needed?~ scroller (> max page))
        (when (get-hscroll?~ scroller)
          (set-scroll-info 'horz min max page)))))
  
  
  (method public (vscroll-needed?)
    (> (get-height) (get-page-size 'vert)))
  
  
  (method public (hscroll-needed?)
    (> (- (get-width) (if (get-vscroll?~ scroller) 13 0)) (get-page-size 'horz)))
  
  
  (method public (scroll delta)
    (unless (= delta {Point 0 0})
      (scroll-to (+ (get-scrolled-position) delta))))
  
  
  (method public (scroll-to dest)
    (let ((pos (get-scrolled-position)))
      ;; dest and pos are in this view coordinates
      (when (/= dest pos)
        (let* ((size (get-size))
               (display (get-display))
               (display-size (get-size~ display))
               (sc (if scaled? scaling 1.0))
               (min-h (- (/ [width display-size] sc) [width size]))
               (min-v (- (/ [height display-size] sc) [height size]))
               (max-h 0)
               (max-v 0)
               (h (round (min (max [h dest] min-h) max-h)))
               (v (round (min (max [v dest] min-v) max-v)))
               (new-pos (new Point (round (* h sc)) (round (* v sc)))))
          (when (/= new-pos position)
            (set! position (new Point (round (* h sc)) (round (* v sc))))
            (let ((scrolled (get-scrolled-position)))
              (set-scroll-pos 'horz (- h) true)
              (set-scroll-pos 'vert (- v) true))
            (update-scrollbars)
            (let ((dh (- h [h pos]))
                  (dv (- v [v pos])))
              (scroll-invalidate dh dv)
              ;; temp for testing...
              (if scaled?
                  (invalidate-view~ scroller)
                (with ((rect (get-bounds~ display))
                       (clipper (get-view-clipper))
                       (clip-rect (acquire~ display self clipper)))
                  (scroll-view~ display dh dv rect :clip-rect clip-rect)))))))))
  
  
  (method protected virtual (redraw-scrollbars)
    )
  
  
  (method protected virtual (scroll-invalidate dh dv)
    )
    
  
  (method public (scroll-view dh dv rect . rest)
    (bind-keywords ((clip-rect null) (erase? true)) rest
      (let ((player (get-player))
            (root (get-root))
            (display (get-display)))
        (when (and player (fully-visible?))
          (with ((acquired (acquire~ root self rect))
                 (display-rect (get-display-rect))
                 (clip-rect (acquire~ root display (either clip-rect display-rect))))
            (bind-values (h v sc) (get-lie-parent 0.0 0.0 1.0)
              (scroll-window~ player (round (* dh sc)) (round (* dv sc)) acquired :clip-rect clip-rect :erase? erase?)))))))
 
  
  (method public (get-scrolled-position)
    (- (get-display-position)))
 
  
  (method public (get-scrolled-h)
    [h (get-scrolled-position)])
 
  
  (method public (get-scrolled-v)
    [v (get-scrolled-position)])
  
  
  (method public (set-scrolled-position pos)
    (when scroller
      (set-position pos)))
  
  
  (method public virtual (get-scroll-client)
    self)
  
  
  (method public virtual (get-line-size orientation)
    (case orientation
      ((vert) 13)
      ((horz) 8)))
  
  
  (method public virtual (get-page-size orientation)
    (let ((size
           (case orientation
             ((vert) (get-height~ parent))
             ((horz) (get-width~ parent)))))
      (if (not scaled?)
          size
        (round (/ size scaling)))))
  
  
  (method public (with-scrollee-locked proc)
    (if scrollee-locked?
        (proc)
      (unwind-protect
          (begin
            (set! scrollee-locked? true)
            (proc))
        (set! scrollee-locked? false))))
  
  
  (method public virtual (layout-scrollee)
    (when (and @is-this-really-necessary-because-it-doesnt-really-make-sense scroller (not update-locked?))
      (let ((size (scrollee-size)))
        (when size
          (set-size size)
          (fit-in-scroller)
          ;; prevents multiple useless layouts that can occur when update scrollbars
          ;; resizes a view that will call layout-scrollee in response (ex: tree header)
          (unless scrollee-locked?
            ;; it is important to update scrollbars first as this can change
            ;; the scrollee size and we do not want to layout twice for nothing
            (with-scrollee-locked
              (function dynamic ()
                (update-scrollbars)))
            (layout-scrollee-content))))))
  
  
  ;; temp patch until update-displayed is 100% fixed
  (method public virtual (layout-scrollee-patch)
    )
  
  
  (method public virtual (layout-scrollee-content)
    )
  
  
  (method (fit-in-scroller)
    (let ((bottom (get-bottom))
          (fit (get-display-height)))
      (when (< bottom fit)
        (scroll (new Point 0 (- fit bottom))))))
  
  
  (method public virtual (scrollee-size)
    (get-size))


  (method public virtual (on-vscroll code thumb-pos orientation)
    )


  (method public virtual (on-hscroll code thumb-pos orientation)
    )


  ;;;
  ;;;; Display
  ;;;


  ;; to-convert clean all this shit by having the callers use (get-display)...
  
  
  (method public virtual (content-size-change size)
    )

  
  (method public (get-display)
    (if scroller
        parent
      self))
  
  
  (method public (get-display-position)
    (if scroller
        (let ((pos <Point> (- (get-position))))
          (if (not scaled?)
              pos
            (new Point
              (round (/ [h pos] scaling))
              (round (/ [v pos] scaling)))))
      {Point 0 0}))
    
  
  (method public (get-display-h)
    [h (get-display-position)])
    
  
  (method public (get-display-v)
    [v (get-display-position)])
    
  
  (method public (get-display-size)
    (if scroller
        (let ((size <Dimension> (get-size~ parent)))
          (if (not scaled?)
              size
            (new Dimension (round (/ [width size] scaling)) (round (/ [height size] scaling)))))
      (get-size)))
    
  
  (method public (get-display-width)
    (if scroller
        [width (get-display-size)]
      (get-width)))
    
  
  (method public (get-display-height)
    (if scroller
        [height (get-display-size)]
      (get-height)))
  
  
  (method public (get-display-rect)
    (if scroller
        (get-bounds~ parent)
      (get-bounds)))
  
  
  (method public (view->display pos <Point>)
    (if scroller
        (if (not scaled?)
            (+ pos position)
          (new Point (round (+ [h pos] (/ [h position] scaling))) (round (+ [v pos] (/ [v position] scaling)))))
      pos))

  
  (method public (h-view->display h <int>)
    (if scroller
        (+ h [h (get-scrolled-position)])
      h))

  
  (method public (v-view->display v <int>)
    (if scroller
        (+ v [v (get-scrolled-position)])
      v))

  
  (method public (display->view pos <Point>)
    (if scroller
        (- pos (get-scrolled-position))
      pos))

  
  (method public (h-display->view h)
    (if scroller
        (- h [h (get-scrolled-position)])
      h))

  
  (method public (v-display->view v)
    (if scroller
        (- v [v (get-scrolled-position)])
      v))
    
  
  (method public (scroll-displayed h v rect . rest)
    (bind-keywords ((clip-rect null) (erase? true)) rest
      (scroll-view~ (get-display) h v rect :clip-rect clip-rect :erase? erase?)))
  
  
  (method public (scroll-needed start end context . rest)
    (bind-keywords ((force-vertical null) (force-horizontal null) (reposition? false) (debug? false)) rest
      (let ((display-pos (get-display-position))
             (display-size (get-display-size))
             (needed
              (function dynamic (start end context pos size force-direction)
                (let* ((start-offset (- pos start))
                       (end-offset (- (+ pos size) end))
                       (big-range? (> (- end start) size))
                       (proc (function dynamic (use-head?)
                               (let ((context (if context (round (* size context)) 0)))
                                 (if use-head? (+ start-offset context) (- end-offset context))))))
                  (when debug?
                    (debug start end context pos size force-direction)
                    (debug start-offset end-offset big-range?))
                  (cond
                   (reposition? (proc (neq? force-direction 'tail)))
                   ((and (> start-offset 0) (> end-offset 0)) (proc (if (null? force-direction) (not big-range?) (eq? force-direction 'head))))
                   ((and (< start-offset 0) (< end-offset 0)) (proc (if (null? force-direction) big-range? (eq? force-direction 'head))))
                   (else 0))))))
        (new Point
          (needed [h start] [h end] (car context) [h display-pos] [width display-size] force-horizontal)
          (needed [v start] [v end] (cdr context) [v display-pos] [height display-size] force-vertical)))))
  
  
  (method public (horizontal-scroll-needed target direction)
    (let* ((start (get-display-h))
           (end (+ start (get-display-width))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))
  
  
  (method public (vertical-scroll-needed target direction)
    (let* ((start (get-display-v))
           (end (+ start (get-display-height))))
      (case direction
        ((backward)
         (if (< target start)
             (- start target)
           0))
        ((forward)
         (if (> target end)
             (- end target)
           0)))))


  ;;;
  ;;;; Font
  ;;;


  (method public (get-font)
    font)
  

  (method public virtual (set-font fnt)
    (set! font fnt)
    (adjust-size))

  
  ;;;
  ;;;; Background
  ;;;
  
  
  (method public (get-background)
    background)
  
  
  (method public (set-background color)
    (set! background color)
    (invalidate-view))
  
  
  ;;;
  ;;;; Sizing
  ;;;
  

  (method public (get-auto-size?)
    auto-size?)


  (method public (set-auto-size? value)
    (set! auto-size? value)
    (adjust-size))
  
  
  (method public (adjust-size)
    (if (not auto-size?)
        (invalidate-view)
      (set-preferred-size)))

  
  ;;;
  ;;;; Iterate
  ;;;
  
  
  (method public (for-each-view proc . rest)
    (bind-keywords ((include-invisibles? false)) rest
      (loop (for child in children)
            (when (and (is? child View)
                       (or include-invisibles? (get-visible?~ child)))
              (proc child)))))
  
  
  (method public (for-each-view-reversed proc . rest)
    (bind-keywords ((include-invisibles? false)) rest
      (let ((proc
              (function dynamic (child)
                (when (and (is? child View)
                           (or include-invisibles? (get-visible?~ child)))
                  (proc child)))))
        (for-each-reversed proc children))))
  
  
  ;;;
  ;;;; Hierarchy
  ;;;
  
  
  (method public (find-mouse-view pos)
    (either (get-captured-view)
            (find-drawing pos)))


  ;;;
  ;;;; Children
  ;;;


  (method public (first-view)
    (first (get-views)))


  (method public (last-view)
    (last (get-views)))
    
  
  (method public (get-views . rest)
    (bind-keywords ((include-invisibles? false)) rest
      (with ((proc <Procedure>
              (function dynamic (child)
                (and (is? child View)
                     (or include-invisibles? (get-visible?~ child))))))
        (collect-if proc (get-children)))))


  (method public (front-view?)
    (eq? self (first-view~ parent)))


  ;;;
  ;;;; Content
  ;;;


  (method public (get-content-change-handler)
    content-change-handler)


  (method public (set-content-change-handler value)
    (set! content-change-handler value))
  
  
  (method (call-content-change origin)
    (if (null? content-change-handler)
        (content-change origin)
      (let ((event (new Event :change self (list :origin origin))))
        (invoke~ content-change-handler self event))))
  
  
  (method public virtual (content-change origin)
    )


  ;;;
  ;;;; Selection
  ;;;
  

  (method public (get-selection-handler)
    selection-handler)
  
  
  (method public (set-selection-handler handler)
    (set! selection-handler handler))


  (method public (call-selection-handler old selection force? user-origin?)
    (when selection-handler
      (invoke~ selection-handler self (new Selection-Event :selection-change self old selection :force? force? :user-origin? user-origin?))))



  ;;;
  ;;;; Modified State
  ;;;


  (method public virtual (get-modified?)
    modified?)


  (method public virtual (set-modified? state)
    (when (/= state modified?)
      (set! modified? state)))
  
  ;;;
  ;;;; Pulse
  ;;;
  
  
  (method public (register-pulse period)
    (let ((player (get-player)))
      (SetTimer (get-hwnd~ player) (object->serial-number self) period NULL)))
  
  
  (method public (unregister-pulse identifier)
    (let ((player (get-player)))
      (KillTimer (get-hwnd~ player) identifier)))


  (method (call-pulse)
    (pulse))


  (method (pulse)
    )

  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method public virtual (position-change position <Point>)
    )
  
  
  (method public virtual (size-change size <Dimension>)
    (let ((pw (essay previous-size [width previous-size]))
          (ph (essay previous-size [height previous-size]))
          (width [width size])
          (height [height size]))
      (set! previous-size size)
      (when pw
        (let ((dh (- width pw))
              (dv (- height ph)))
          (when (or (/= dh 0) (/= dv 0))
            (resize dh dv)))))
    (invalidate-layout)
    (when (get-finished?)
      (call-layout)))


  (method protected virtual (resize dh <int> dv <int>)
    )

  
  ;;;
  ;;;; Focus
  ;;;
  
  
  (method public (acquire-focus)
    (set-focus self))


  (method public (call-focus-gain)
    (set-focus-actions~ (get-application) (get-focus-actions self))
    (focus-gain))


  (method public (call-focus-lose window view)
    (if (or (different-overlapped? window) (focus-validate view))
        (begin
          (set-focus-actions~ (get-application) null)
          (focus-lose window view))
      (set-focus self)
      (throw-cancel)))
  
  
  (method public virtual (focus-validate view)
    true)
  
  
  (method public virtual (focus-lose window view)
    )
  
  
  (method public virtual (focus-master)
    self)
  
  
  (method public virtual (focus-gain)
    )
  
  
  (method public virtual (focus-delegate)
    )
  
  
  (method public virtual (focus-update-actions)
    )


  ;;;
  ;;;; Action
  ;;;
  
  
  (method public (get-action-handler)
    action-handler)
  
  
  (method public virtual (set-action-handler x)
    (set! action-handler x))


  (method public virtual (process-action sender . rest)
    (bind-optionals ((properties (action-properties))) rest
      (notify-action sender properties)))
  
  
  (method protected virtual (action-properties)
    null)
  
  
  (method public (notify-action sender properties)
    (if (null? action-handler)
        (when action
          (call-action action sender properties))
      (let* ((properties (either properties (get-properties~ action-handler)))
             (event (apply new Action-Event :action sender properties)))
        (invoke~ action-handler self event))))
  
  
  ;;;
  ;;;; Receive Files
  ;;;

  
  (method public (get-receive-files-handler)
    receive-files-handler)
  
  (method public (set-receive-files-handler handler)
    (set! receive-files-handler handler))
  
  
  (method protected (dispatch-receive-files pos files)
    (let ((view (find-mouse-view pos)))
      (when view
        (let ((view-pos (acquire~ view self pos)))
          (call-receive-files~ view view-pos files)))))

  
  (method public (call-receive-files pos files)
    (if receive-files-handler
        (invoke~ receive-files-handler self (new Event :receive-files self :position pos :files files))
      (receive-files pos files)))
  
  
  (method public virtual (receive-files pos pathnames)
    (let ((appl (get-application)))
      (receive-files~ appl pos pathnames)))


  ;;;
  ;;;; Cursor
  ;;;
  
  
  (method public (get-cursor-update-handler)
    cursor-update-handler)
  
  
  (method public (set-cursor-update-handler handler)
    (set! cursor-update-handler handler))

  
  (method public (call-cursor-update pos)
    (if (null? cursor-update-handler)
        (cursor-update pos)
      (with ((event (new Cursor-Event :set-cursor self pos)))
        (invoke~ cursor-update-handler self event))))
  
  
  (method public virtual (cursor-update pos)
    (unless Current-Drag-Drop
      (set-cursor :arrow)))
  
  
  (method public (mouse-pressed?)
    mouse-down?)
  
  
  (method public (mouse-right-pressed?)
    mouse-right-down?)
  
  
  (method public (mouse-in?)
    (eq? self mouse-in))
  
  
  (method public (mouse-over?)
    (over-view? (mouse-position)))


  (method public (over-view? point)
    (with ((bounds (get-bounds)))
      (in-rect? point bounds)))


  (method public (mouse-position)
    (let ((player (get-player))
          (root (get-root)))
      (acquire root (mouse-position~ player))))


  ;;;
  ;;;; Mouse
  ;;;
    
  
  (method public (get-mouse-enter-handler)
    mouse-enter-handler)
  
  (method public (set-mouse-enter-handler handler)
    (set! mouse-enter-handler handler))
  
  
  (method public (get-mouse-hover-handler)
    mouse-hover-handler)
  
  (method public (set-mouse-hover-handler handler)
    (set! mouse-hover-handler handler))
  
  
  (method public (get-mouse-leave-handler)
    mouse-leave-handler)
  
  (method public (set-mouse-leave-handler handler)
    (set! mouse-leave-handler handler))
  
  
  (method public (get-mouse-down-handler)
    mouse-down-handler)
  
  (method public (set-mouse-down-handler handler)
    (set! mouse-down-handler handler))
  
  
  (method public (get-mouse-move-handler)
    mouse-move-handler)
  
  (method public (set-mouse-move-handler handler)
    (set! mouse-move-handler handler))
  
  
  (method public (get-mouse-up-handler)
    mouse-up-handler)
  
  (method public (set-mouse-up-handler handler)
    (set! mouse-up-handler handler))
  
  
  (method public (get-drag-move-handler)
    drag-move-handler)
  
  (method public (set-drag-move-handler handler)
    (set! drag-move-handler handler))
  
  
  (method public (get-drag-up-handler)
    drag-up-handler)
  
  (method public (set-drag-up-handler handler)
    (set! drag-up-handler handler))
  
  
  (method public (get-double-click-handler)
    double-click-handler)
  
  (method public (set-double-click-handler handler)
    (set! double-click-handler handler))
  
  
  (method protected (dispatch-mouse-hover h v)
    @convert
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (let ((view-pos (acquire~ view self pos)))
          (call-mouse-hover~ view view-pos)
          (when (get-tooltip?~ view)
            (popup-tooltip~ view view-pos))))))
  
  
  (method (call-mouse-hover pos)
    @convert
    (if mouse-hover-handler
        (invoke~ mouse-hover-handler self (new Mouse-Event :mouse-hover self pos))
      (mouse-hover pos)))
  
  
  (method protected (dispatch-mouse-wheel delta)
    (let ((view (get-focus)))
      (when view
        (mouse-wheel~ view delta))))
  
  
  (method protected (dispatch-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view :event 'mouse-down)
        (let ((acquired (acquire~ view self pos)))
          (set! mouse-down? true)
          (set! mouse-down-view view)
          (set! mouse-down-point acquired)
          (when (mouse-activate?~ view)
            (mouse-activate~ (get-root)))
          (call-mouse-down~ view acquired)
          (call-cursor-update~ view acquired)))))

  
  (method public (call-mouse-down pos)
    (if mouse-down-handler
        (invoke~ mouse-down-handler self (new Mouse-Event :mouse-down self pos))
      (mouse-down pos)))
  
  
  (method protected (dispatch-mouse-move h v)
    (with ((pos (new Point h v)))
      (let ((view (find-mouse-view pos)))
        (when view
          (when (neq? view mouse-in)
            (when mouse-in
              (call-mouse-leave~ mouse-in)
              (unless (or (and view (is? (get-player~ view) Tooltip)) (in-tooltip? pos))
                (cancel-tooltip-tracking~ mouse-in)))
            (set! mouse-in view)
            (when mouse-in
              (unless Current-Drag-Drop
                (track-tooltip~ mouse-in))
              (call-mouse-enter~ mouse-in)))
          (if mouse-down?
              (with ((acquired (acquire~ mouse-down-view self pos)))
                (call-cursor-update~ mouse-down-view acquired)
                (process-drag-move~ mouse-down-view acquired))
            (with ((acquired (acquire~ view self pos)))
              (call-cursor-update~ view acquired)
              (process-mouse-move~ view acquired)))))))

  
  (method (process-mouse-move pos)
    (if Current-Tooltip-Context
        (process-tooltip pos)
      (call-mouse-move pos)))
  
  
  (method (call-mouse-move pos)
    (if mouse-move-handler
        (with ((event (new Mouse-Event :mouse-move self pos)))
          (invoke~ mouse-move-handler self event))
      (mouse-move pos)))
  
  
  (method protected (dispatch-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when mouse-down?
        (process-drag-up~ mouse-down-view (acquire~ mouse-down-view self pos)))
      (when view
        (let ((acquired (acquire~ view self pos)))
          (call-cursor-update~ view acquired)
          (process-mouse-up~ view acquired))))
    (when delayed-mouse-action
      (let ((action delayed-mouse-action))
        (set! delayed-mouse-action null)
        (action))))

  
  (method (process-mouse-up pos)
    (when Current-Drag-Drop
      (drag-drop Current-Drag-Drop pos))
    (call-mouse-up pos))

  
  (method (call-mouse-up pos)
    (if mouse-up-handler
        (invoke~ mouse-up-handler self (new Mouse-Event :mouse-up self pos))
      (mouse-up pos)))

  
  (method (process-drag-move pos)
    (if (and (eq? self mouse-down-view) (get-draggable?) (or (null? Current-Drag-Drop) (eq? self [view source Current-Drag-Drop])))
        (begin
          (when (allow-start-drag? pos)
            (let ((drag-drop (get-drag-drop)))
              (when drag-drop
                (drag-start pos (- mouse-down-point (get-drag-hotspot)) drag-drop))))
          (when Current-Drag-Drop
            (drag-follow pos)))
      (call-drag-move pos)))
  
  
  (method protected virtual (allow-start-drag? pos)
    (and mouse-down? (null? Current-Drag-Drop) (not (near? pos mouse-down-point drag-tolerance))))
  
  
  (method (call-drag-move pos)
    (if drag-move-handler
        (invoke~ drag-move-handler self (new Mouse-Event :drag-move self pos))
      (drag-move pos)))

  
  (method (process-drag-up pos . rest)
    (bind-optionals ((dragging? (not-null? Current-Drag-Drop))) rest
      (set! mouse-down? false)
      (call-drag-up pos dragging?)))

  
  (method (call-drag-up pos dragging?)
    (if drag-up-handler
        (invoke~ drag-up-handler self (new Mouse-Event :drag-up self pos))
      (drag-up pos dragging?)))
  
  
  (method protected (dispatch-double-click h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (close-popups~ view :event 'double-click)
        (let ((acquired (acquire~ view self pos)))
          (set! mouse-down? true)
          (set! mouse-down-view view)
          (set! mouse-down-point acquired)
          (when (mouse-activate?~ view)
            (mouse-activate~ (get-root)))
          (call-double-click~ view (acquire~ view self pos))))))
  
  
  (method public virtual (call-double-click pos)
    (if double-click-handler
        (invoke~ double-click-handler self (new Mouse-Event :double-click self pos))
      (double-click pos)))
  
  
  (method protected (dispatch-context-menu h v)
    (if inhibit-context-menu?
        (set! inhibit-context-menu? false)
      (let* ((pos (new Point h v))
             (view (find-mouse-view pos)))
        (when view
          (close-popups~ view :event 'context-menu)
          (call-context-menu~ view (acquire~ view self pos))))))
  
  
  (method public (call-context-menu pos)
    (if context-menu-handler
        (invoke~ context-menu-handler self (new Mouse-Event :context-menu self pos))
      (context-menu pos)))
  
  
  (method protected (dispatch-middle-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-middle-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (when view
        (middle-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-down h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set! mouse-right-down? true)
      (when view
        (right-mouse-down~ view (acquire~ view self pos)))))
  
  
  (method protected (dispatch-right-mouse-up h v)
    (let* ((pos (new Point h v))
           (view (find-mouse-view pos)))
      (set! mouse-right-down? false)
      (when view
        (right-mouse-up~ view (acquire~ view self pos)))))
  
  
  (method (call-mouse-enter)
    (if mouse-enter-handler
        (invoke~ mouse-enter-handler self (new Mouse-Event :mouse-enter self null))
      (mouse-enter)))
  
  
  (method (call-mouse-leave)
    (if mouse-leave-handler
        (invoke~ mouse-leave-handler self (new Mouse-Event :mouse-leave self null))
      (mouse-leave)))
  
  
  (method public virtual (mouse-hover pos)
    )
  
  
  (method public virtual (mouse-wheel delta)
    (if (or (shift-down?) mouse-right-down?)
        (begin
          (scroll (new Point (quotient delta 3) 0))
          (when mouse-right-down?
            (set! inhibit-context-menu? true)))
      (scroll (new Point 0 (quotient delta 3)))))

  
  (method public virtual (mouse-enter)
    )

  
  (method public virtual (mouse-leave)
    )

  
  (method public virtual (mouse-down pos)
    )
  
  
  (method public virtual (mouse-move pos)
    )
  
  
  (method public virtual (mouse-up pos)
    )
  
  
  (method public virtual (drag-move pos)
    )
  
  
  (method public virtual (drag-up pos . rest)
    )
  
  
  (method public virtual (double-click pos)
    (call-mouse-down pos))
  
  
  (method public virtual (with-context-click pos proc)
    (proc))
  
  
  (method public virtual (context-menu pos)
    )
  
  
  (method public virtual (get-context-menu)
    null)
  
  
  (method public virtual (middle-mouse-down pos)
    (mouse-down pos))
  
  
  (method public virtual (middle-mouse-up pos)
    (mouse-up pos))
  
  
  (method public virtual (right-mouse-down pos)
    )
  
  
  (method public virtual (right-mouse-up pos)
    )
  
  
  (method public virtual (mouse-activate?)
    true)


  (method public (mouse-view)
    (either Captured-View mouse-in))


  ;;;
  ;;;; Hovering
  ;;;
  
  
  (method public (track-hovering . rest)
    @windows-specific
    (bind-keywords ((time HOVER_DEFAULT)) rest
      (let ((player (get-player)))
        (when player
          (track-mouse-event~ player TME_HOVER :time time)))))
  
  
  (method public (cancel-hovering)
    @windows-specific
    (let ((player (get-player)))
      (when player
        (track-mouse-event~ player (bit-or TME_CANCEL TME_HOVER)))))


  ;;;
  ;;;; Tooltip
  ;;;
  
  
  (definition Current-Tooltip-Context
    null)
  
  (definition Last-Tooltip-Time
    null)
  
  (definition Last-Tooltip-Context-Pos
    null)
  
  
  (method (track-tooltip)
    @convert
    (when (get-tooltip?)
      (let ((player (get-player)))
        (when player
          (if (and Last-Tooltip-Time (< (- (clock) Last-Tooltip-Time) 500))
              (track-hovering :time 100)
            (track-hovering))))))
  
  
  (method (cancel-tooltip-tracking)
    @convert
    (cancel-hovering)
    (close-tooltip))
  
  
  (method public (reset-tooltip)
    (cancel-tooltip-tracking)
    @convert
    ;; This is crazy, but calling track-tooltip in a thread is necessary else TrackMouseEvent doesn't work!!
    (new Thread
      name: "Tooltip Reseter"
      :context self
      :execute (function (thread)
                 (track-tooltip))))
  
  
  (method (in-tooltip? pos)
    (when Current-Tooltip-Context
      (let ((view [view Current-Tooltip-Context])
            (rect [bounds Current-Tooltip-Context]))
        (when rect
          (in-rect? (acquire~ view self pos) rect)))))
  
  
  (method (process-tooltip pos)
    (unless (is? (get-overlapped) Tooltip)
      (let ((view [view Current-Tooltip-Context])
            (rect [bounds Current-Tooltip-Context]))
        (when (and rect (not (in-rect? (acquire~ view self pos) rect)))
          (reset-tooltip)))))
  
  
  (method (popup-tooltip pos)
    (unless (or mouse-down? Current-Drag-Drop (in-tooltip? pos))
      (close-tooltip)
      (let ((context (essay (/= pos Last-Tooltip-Context-Pos) (get-tooltip-context pos))))
        (set! Current-Tooltip-Context context)
        (if (not context)
            (begin
              (set! Last-Tooltip-Context-Pos pos)
              (reset-tooltip))
          (let ((text (get-text~ context)))
            (popup-text pos context text))))))
    
  
  (method (popup-text pos context text)
    (let ((view (new-tooltip-view text))
          (border (new Border-View :border-type 'solid))
          (font (get-font~ context)))
      (when font
        (set-font~ view font))
      (set-preferred-size~ view)
      (let* ((height (get-cursor-height))
             (tooltip (popup view (either (get-position~ context) (+ pos (new Dimension 0 height))) :class Tooltip :border border)))
        (set-tooltip~ Current-Tooltip-Context tooltip))))
  
  
  (method (new-tooltip-view text)
    (if (and (get-formatted-tooltip?) (list? text))
        (let* ((view (new Tooltip-Text :size {Dimension 400 100}))
               (text-view (get-text~ view)))
          (set-text~ text-view text)
          (set-size~ view (+ (get-size~ text-view) {Dimension 2 2}))
          view)
      (new Tooltip-Label :title text)))
  
  
  (method (close-tooltip)
    (when Current-Tooltip-Context
      (close-popup~ View-Player (get-tooltip~ Current-Tooltip-Context))
      (set! Current-Tooltip-Context null)
      (set! Last-Tooltip-Time (clock))))
  
  
  (method (get-cursor-height)
    (let ((cursor (get-cursor)))
      (case cursor
        ((:ibeam) 9)
        (else 21))))


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method public (get-lost-capture-handler)
    lost-capture-handler)
  
  (method public (set-lost-capture-handler handler)
    (set! lost-capture-handler handler))
  
  
  (method (call-lost-capture hwnd)
    @to-convert
    (when lost-capture-handler
      (invoke~ lost-capture-handler self (new Capture-Event :lost-capture self (get-window hwnd)))))


  ;;;
  ;;;; Groups
  ;;;
  
  
  (method public (get-selected-element . rest)
    (bind-keywords ((class Radio-Button) (group null)) rest
      (let ((element
             (find-if (function dynamic (child)
                        (and (is? child class)
                             (or (null? group) (eq? (get-group~ child) group))
                             (get-selected?~ child)))
                      children)))
        (when element
          (get-name~ element)))))
  
  
  (method public (set-selected-element name . rest)
    (bind-keywords ((class Radio-Button) (group null)) rest
      (let ((found? false))
        (for-each (function dynamic (child)
                    (when (and (is? child class)
                               (or (null? group) (eq? (get-group~ child) group)))
                      (let ((selected? (eq? (get-name~ child) name)))
                        (set-selected?~ child selected?)
                        (when selected?
                          (set! found? true)))))
                  children)
        (unless found?
          (error "Unable to find element: {t}" name)))))
  
  
  (method public (unselect-elements . rest)
    (bind-keywords ((class Radio-Button) (group null)) rest
      (for-each (function dynamic (child)
                  (when (and (is? child class)
                             (or (null? group) (eq? (get-group~ child) group)))
                    (unselect~ child)))
                children)))


  ;;;
  ;;;; Context Menu
  ;;;
  
  
  (method public (get-context-menu-handler)
    context-menu-handler)
  
  (method public (set-context-menu-handler handler)
    (set! context-menu-handler handler))


  (method public (track-popup-menu menu pos . rest)
    (if (is-not? menu Context-Menu)
        (error "{t} is not of the expected Context-Menu class" menu)
      (unless (all-invisible? menu)
        (bind-keywords ((alternate-position null) (initiator self)) rest
          (let ((popup (popup menu pos :alternate-position alternate-position :class Menu-Transient :initiator initiator)))
            popup)))))
  
  
  (method (all-invisible? menu)
    (every? (function dynamic (item)
              (not (get-visible?~ item)))
            (get-children~ menu)))


  ;;;
  ;;;; Context
  ;;;
  
  
  (method (get-context-text)
    null)
  
  
  ;;;
  ;;;; Mouse Copy
  ;;;

  
  (method public virtual (mouse-copy pos destination)
    false)

  
  (method public virtual (mouse-insert object)
    )
  
  
  ;;;
  ;;;; Desktop
  ;;;
  
  
  (method public (to-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire~ desktop player (acquire~ root self shape))))
  
  
  (method public (from-desktop shape)
    (let ((desktop (get-desktop))
          (player (get-player))
          (root (get-root)))
      (acquire root (acquire~ player desktop shape))))
  
  
  ;;;
  ;;;; Popup
  ;;;
  
  
  (method public (popup view position . rest)
    (bind-keywords ((alternate-position null) (initiator self) (class Popup) (border null) (fade-speed null) (effect null) (close-root? true)) rest
      (let* ((toplevel (get-toplevel))
             (desktop (get-desktop))
             (player (get-player))
             (max (get-size~ desktop))
             (alternate (to-desktop (either alternate-position position)))
             (position (to-desktop position))
             (size (+ (get-size~ view) {Dimension 4 4}))
             (border (either border (new Border-View name: 'border :border-type 'raised)))
             (popup (popup~ player class :position (fit-point position alternate size max) :size size :close-root? close-root?)))
        (set-initiator~ popup initiator)
        (set-parent~ border (get-root~ popup))
        (set-position~ border {Point 0 0})
        (set-size~ border (get-size~ popup))
        (set-parent~ view border)
        (set-visible?~ view true)
        (layout-view~ border)
        (set-effect~ (get-root~ popup) effect)
        (fade-in~ popup :fade-speed fade-speed)
        popup)))
  
  
  (method public virtual (close-popups . rest)
    (bind-keywords ((event null) (all? false) (exclude null)) rest
      (close-popups~ player :all? all? :exclude exclude)))
  
  
  (method public virtual (popup-destroy popup)
    )
  
  
  (method public (popup-initiator)
    (let ((overlapped (get-overlapped)))
      (when (is? overlapped Popup)
        (get-initiator~ overlapped))))
  
  
  (method public (owned? overlapped)
    (memq? overlapped (get-owners~ (get-overlapped))))


  ;;;
  ;;;; Drag
  ;;;


  (method public virtual (get-draggable?)
    draggable?)


  (method public (set-draggable? flag)
    (set! draggable? flag))


  (method public (get-drag-tolerance)
    drag-tolerance)


  (method public (set-drag-tolerance tolerance)
    (set! drag-tolerance tolerance))
  
  
  (method public virtual (get-drag-drop)
    (let ((source (get-drag-source)))
      (when source
        (new DnD :source source))))
  
  
  (method public virtual (get-drag-hotspot)
    {Point 0 0})
  
  
  (method public virtual (get-drag-source)
    (let ((pos (get-drag-position)))
      (new Drag-Source :view self :position pos :image (get-drag-image pos))))
  
  
  (method public virtual (get-drag-position)
    mouse-down-point)
  
  
  (method public virtual (get-drag-image pos)
    null)
  
  
  (method (drag-start pos hotspot drag-drop)
    (set! Current-Drag-Drop drag-drop)
    (let ((view [view source drag-drop]))
      (set-cursor :no)
      (acquire-focus~ view)
      (acquire-capture~ view)
      @old
      (let* ((image [image source drag-drop])
             (portfolio (get-portfolio~ image))
             (image-name (get-image-name~ image)))
        (ImageList_BeginDrag (get-handle~ portfolio) (get-image~ portfolio image-name) [h hotspot] [v hotspot]))
      (let ((global (to-desktop~ view pos)))
        @old(ImageList_DragEnter (get-hwnd~ (get-desktop)) [h global] [v global])
        (hide-drag-image)
        (process-drag-feedback global))))
  
  
  (method (drag-follow pos)
    (when Current-Drag-Drop
      (let* ((drag-drop Current-Drag-Drop)
             (view [view source drag-drop])
             (global (to-desktop~ view pos)))
        @old(ImageList_DragMove [h global] [v global])
        (process-drag-feedback global))))
  
  
  (method (drag-drop drag-drop pos)
    (drag-end)
    (when [target drag-drop]
      (drop drag-drop pos)))
  
  
  (method (drag-end)
    (when Current-Drag-Drop
      (let ((drag-drop Current-Drag-Drop))
        (hide-drag-image)
        (unhighlight-current drag-drop)
        @old(ImageList_EndDrag)
        @old(ImageList_DragLeave (get-hwnd~ (get-desktop)))
        (release-capture~ [view source drag-drop])
        (set! Current-Drag-Drop null))))
  
  
  (method (process-drag-feedback global)
    (let* ((drag-drop Current-Drag-Drop)
           (current [view drag-drop])
           (desktop (get-desktop))
           (view (find-view~ desktop global)))
      (set! [view drag-drop] view)
      (when view
        (let* ((local (to-view~ desktop global view))
               (target (call-current-drop~ view drag-drop local)))
          (when (neq? target [target drag-drop])
            (set-cursor (if target :move :no))
            (hide-drag-image)
            (unhighlight-current drag-drop)
            (set! [target drag-drop] target)
            (when target
              (highlight-current drag-drop view local))
            (when target
              (show-drag-image)))))))
  
  
  (method (hide-drag-image)
    @old(ImageList_DragShowNolock false))
  
  
  (method (show-drag-image)
    @old(ImageList_DragShowNolock true))
  
  
  (method (highlight-current drag-drop view local)
    (highlight-drop~ view drag-drop local))
  
  
  (method (unhighlight-current drag-drop)
    (let ((current-target [target drag-drop]))
      (when current-target
        (unhighlight-drop~ [view current-target] drag-drop))))
  
  
  (method public virtual (highlight-drop drag-drop pos)
    )
  
  
  (method public virtual (unhighlight-drop drag-drop)
    )


  ;;;
  ;;;; Drop
  ;;;
  
  
  (method public (get-current-drop-handler)
    current-drop-handler)
  
  (method public (set-current-drop-handler handler)
    (set! current-drop-handler handler))
    
  
  (method public (call-current-drop drag-drop pos)
    (if current-drop-handler
        (invoke~ current-drop-handler self (new Drop-Event :drop-target self pos drag-drop))
      (current-drop drag-drop pos)))

  
  (method public virtual (current-drop drag-drop pos)
    null)
  
  
  (method public (standard-current-drop evt acceptance . rest)
    (bind-keywords ((handler null)) rest
      (let* ((sender (get-sender~ evt))
             (pos (get-position~ evt))
             (drag-drop (get-drag-drop~ evt))
             (current (get-target~ drag-drop))
             (drag-start (get-view~ (get-source~ drag-drop)))
             (drag-over (get-view~ drag-drop))
             (drag-info (cons drag-start drag-over)))
        (if (neq? drag-start drag-over)
            (let ((criteria (find-if (function dynamic (criteria) (accepts?~ criteria drag-info)) acceptance)))
              (if criteria
                  (new Drop-Target :handler handler :view sender :position pos :criteria criteria)
                (current-drop~ sender drag-drop pos)))
          (current-drop~ sender drag-drop pos)))))

  
  (method public (get-receive-drop-handler)
    receive-drop-handler)
  
  (method public (set-receive-drop-handler handler)
    (set! receive-drop-handler handler))
  
  
  (method public virtual (drop drag-drop pos)
    (let* ((src (get-view~ (get-source~ drag-drop)))
           (trg (get-target~ drag-drop))
           (dst (either (get-handler~ trg) (get-view~ trg))))
      (when dst
        (call-receive-drop~ dst self (acquire~ dst src pos) drag-drop))))
  
  
  (method public (call-receive-drop sender pos drag-drop)
    (if receive-drop-handler
        (invoke~ receive-drop-handler self (new Drop-Event :receive-drop sender pos drag-drop))
      (receive-drop sender pos drag-drop)))
  
  
  (method public virtual (receive-drop sender pos drag-drop)
    )


  ;;;
  ;;;; Keyboard
  ;;;
  
  
  (method public (get-key-down-handler)
    key-down-handler)
  
  
  (method public (set-key-down-handler handler)
    (set! key-down-handler handler))
  
  
  (method public (get-key-up-handler)
    key-up-handler)
  
  
  (method public (set-key-up-handler handler)
    (set! key-up-handler handler))
  
  
  (method public (get-key-press-handler)
    key-press-handler)
  
  
  (method public (set-key-press-handler handler)
    (set! key-press-handler handler))
  
  
  (method (call-key-down key)
    (if key-down-handler
        (invoke~ key-down-handler self (new Keyboard-Event :key-down self key))
      (key-down key)))
  
  
  (method (call-key-up key)
    (if key-up-handler
        (invoke~ key-up-handler self (new Keyboard-Event :key-up self key))
      (key-up key)))
  
  
  (method protected (call-key-press key)
    (if key-press-handler
        (invoke~ key-press-handler self (new Keyboard-Event :char self key))
      (key-press key)
      ;; necessary as some keys do not come from bound accelerators
      (when (macro-recording?)
        (let* ((appl (get-application))
               (recorder (get-recorder~ appl)))
          (when recorder
            (let ((handler {Event-Handler :focus on-insert})
                  (event (new Event (if char? :char :key) self :content key)))
              (when (record-event?~ appl event)
                (record~ recorder handler event))))))))
  
  
  (method public (get-arrow-press-handler)
    arrow-press-handler)
  
  
  (method public (set-arrow-press-handler handler)
    (set! arrow-press-handler handler))
  
  
  (method public (get-escape-press-handler)
    escape-press-handler)
  
  
  (method public (set-escape-press-handler handler)
    (set! escape-press-handler handler))
  
  
  (method public (get-backspace-press-handler)
    backspace-press-handler)
  
  
  (method public (set-backspace-press-handler handler)
    (set! backspace-press-handler handler))
  
  
  (method public (get-return-press-handler)
    return-press-handler)
  
  
  (method public (set-return-press-handler handler)
    (set! return-press-handler handler))
  
  
  (method public (get-tab-press-handler)
    tab-press-handler)
  
  
  (method public (set-tab-press-handler handler)
    (set! tab-press-handler handler))
    
  
  (method (on-arrow evt)
    (call-arrow-press evt))

  
  (method (call-arrow-press evt)
    (if arrow-press-handler
        (invoke~ arrow-press-handler self evt)
      (arrow-press (get-property~ evt :direction) (get-modifiers~ evt))))


  (method public virtual (arrow-press direction modifiers)
    (case direction
      ((left)  (left-arrow-press  modifiers))
      ((up)    (up-arrow-press    modifiers))
      ((right) (right-arrow-press modifiers))
      ((down)  (down-arrow-press  modifiers))))


  (method public virtual (left-arrow-press modifiers)
    )


  (method public virtual (up-arrow-press modifiers)
    )


  (method public virtual (right-arrow-press modifiers)
    )


  (method public virtual (down-arrow-press modifiers)
    )
  
  
  (method public virtual (on-escape-press evt)
    (call-escape-press #\escape))
  
  
  (method (call-escape-press key)
    (if escape-press-handler
        (invoke~ escape-press-handler self (new Keyboard-Event :char self key))
      (escape-press key)))


  (method public virtual (escape-press key)
    )
  
  
  (method public virtual (on-backspace-press evt)
    (call-backspace-press #\backspace))
  
  
  (method (call-backspace-press key)
    (if backspace-press-handler
        (invoke~ backspace-press-handler self (new Keyboard-Event :char self key))
      (backspace-press key)))


  (method public virtual (backspace-press key . rest)
    )
  
  
  (method public virtual (on-return-press evt)
    (call-return-press #\return))
  

  (method (call-return-press key)
    (if return-press-handler
        (invoke~ return-press-handler self (new Keyboard-Event :char self key))
      (return-press key)))


  (method public virtual (return-press key)
    )
  
  
  (method public virtual (on-tab-press evt)
    (call-tab-press #\tab))
  
  
  (method (call-tab-press key)
    (if tab-press-handler
        (invoke~ tab-press-handler self (new Keyboard-Event :char self key))
      (tab-press key (modifiers-keys))))


  (method public virtual (tab-press key modifiers)
    )
  
  
  (method public virtual (key-down key)
    )
  
  
  (method public virtual (key-up key)
    )
  
  
  (method public (on-key-press evt)
    (key-press (get-property~ evt :key)))


  (method public virtual (key-press key)
    )
  
  
  (method protected (dispatch-key-down key)
    (let ((view (get-focus)))
      (when view
        (call-key-down~ view key))))
  
  
  (method protected (dispatch-key-up key)
    (let ((view (get-focus)))
      (when view
        (call-key-up~ view key))))
  
  
  (method protected (dispatch-key-press key)
    (if (and Current-Drag-Drop (= key #\escape))
        (begin
          (drag-end)
          @convert
          (complete-drag-up true))
      (let ((view (get-focus)))
        (when view
          (call-key-press~ view key)))))


  ;;;
  ;;;; Tab
  ;;;
  
  
  (method public (find-tab-manager)
    (if (or (get-tab-stops) (null? parent))
        self
      (find-tab-manager~ parent)))
  
  
  (method public (navigate-tab from backward?)
    (let ((to (navigated-view from backward?)))
      (when (and to (neq? to from))
        (tab-stop-exit~ from)
        (acquire-focus~ to)
        (tab-stop-enter~ to))))
  
  
  (method public (navigated-view from backward?)
    (let ((stops (get-tab-stops)))
      (when stops
        (let ((count (length stops))
              (rank (find from stops :return 'position)))
          (when rank
            (let ((new-rank (if backward? (if (= rank 0) (- count 1) (- rank 1)) (modulo (+ rank 1) count))))
              (element stops new-rank)))))))
  
  
  (method public virtual (on-next-view evt)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self false)))
  
  
  (method public virtual (on-previous-view evt)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self true)))
  
  
  (method protected (navigate-view backward?)
    (let ((manager (find-tab-manager)))
      (navigate-tab~ manager self backward?)))
  
  
  (method public virtual (get-tab-stops)
    {})
  
  
  (method public virtual (tab-stop-enter)
    (select-all))
  
  
  (method public virtual (tab-stop-exit)
    )


  ;;;
  ;;;; Edition
  ;;;
  
  
  (method (on-undo evt)
    (if (null? surrogate)
        (undo)
      (undo~ surrogate)))
  
  
  (method (on-redo evt)
    (if (null? surrogate)
        (redo)
      (redo~ surrogate)))
  
  
  (method (on-cut evt)
    (if (null? surrogate)
        (cut-selection)
      (cut-selection~ surrogate)))
  
  
  (method (on-copy evt)
    (if (null? surrogate)
        (copy-selection)
      (copy-selection~ surrogate)))
  
  
  (method (on-paste evt)
    (if (null? surrogate)
        (paste-clipboard)
      (paste-clipboard~ surrogate)))
  
  
  (method (on-paste-properties evt)
    (if (null? surrogate)
        (paste-properties)
      (paste-properties~ surrogate)))
  
  
  (method (on-delete evt)
    (if (null? surrogate)
        (delete-selection)
      (delete-selection~ surrogate)))
  
  
  (method (on-rename evt)
    (if (null? surrogate)
        (rename-selection)
      (rename-selection~ surrogate)))
  
  
  (method (on-select-all evt)
    (if (null? surrogate)
        (select-all)
      (select-all~ surrogate)))
  
  
  (method public virtual (can-undo?)
    (if surrogate
        (can-undo?~ surrogate)
      false))
  
  
  (method public virtual (can-redo?)
    (if surrogate
        (can-redo?~ surrogate)
      false))
  
  
  (method public virtual (can-cut?)
    (if surrogate
        (can-cut?~ surrogate)
      false))
  
  
  (method public virtual (can-copy?)
    (if surrogate
        (can-copy?~ surrogate)
      false))
  
  
  (method public virtual (can-paste?)
    (if surrogate
        (can-paste?~ surrogate)
      false))
  
  
  (method public virtual (can-paste-properties?)
    (if surrogate
        (can-paste-properties?~ surrogate)
      false))
  
  
  (method public virtual (can-delete?)
    (if surrogate
        (can-delete?~ surrogate)
      false))
  
  
  (method public virtual (can-rename?)
    (if surrogate
        (can-rename?~ surrogate)
      false))
  
  
  (method public virtual (can-select-all?)
    (if surrogate
        (can-select-all?~ surrogate)
      false))
  
  
  (method public virtual (undo)
    )
  
  
  (method public virtual (redo)
    )
  
  
  (method public virtual (cut-selection)
    )
  
  
  (method public virtual (copy-selection)
    )
  
  
  (method public virtual (paste-clipboard)
    )
  
  
  (method public virtual (paste-properties)
    )
  
  
  (method public virtual (delete-selection)
    )
  
  
  (method public virtual (rename-selection)
    )
  
  
  (method public virtual (select-all . rest)
    )


  ;;;
  ;;;; Capture
  ;;;
  
  
  (method public (acquire-capture)
    (set! Captured-View self)
    (acquire-capture~ (get-player)))
  
  
  (method public (release-capture)
    (set! Captured-View null)
    (release-capture~ (get-player)))


  ;;;
  ;;;; Tooltips
  ;;;


  (method public virtual (get-tooltip?)
    tooltip?)


  (method public (set-tooltip? flag)
    (when (/= flag tooltip?)
      (set! tooltip? flag)))


  (method public virtual (get-tooltip-text)
    (if (or (null? tooltip-text) (null? action))
        tooltip-text
      (let ((shortcut (get-shortcut~ (require-action-item action))))
        (if (null? shortcut)
            tooltip-text
          (format "{a}, {a}" tooltip-text (present-shortcut~ shortcut))))))


  (method public (set-tooltip-text text)
    (set! tooltip-text text))
  
  
  ;; a quicky... this should probably by default return the value of a property
  (method public virtual (get-formatted-tooltip?)
    false)
  
  
  (method public virtual (get-tooltip-context pos)
    (let ((text (get-tooltip-text)))
      (when text
        (new Tooltip-Context :view self :text text))))

  
  ;;;
  ;;;; Clipping
  ;;;
  
  
  (method (get-translated-clipper h v)
    (with ((b (get-bounds))
           (r (offset-rect b (round h) (round v))))
      (if (null? parent)
          (copy r)
        (let ((sc <Real> (if scaled? scaling 1.0)))
          (with ((p <Rect> (get-translated-clipper~ parent (- (* h sc) [h position]) (- (* v sc) [v position]))))
            (when scaled?
              (set! [left p] (round (/ [left p] sc)))
              (set! [top p] (round (/ [top p] sc)))
              (set! [right p] (round (/ [right p] sc)))
              (set! [bottom p] (round (/ [bottom p] sc))))
            (rect-intersection p r))))))


  ;;;
  ;;;; Invalidation
  ;;;
  
  
  (method public (invalidate-view)
    (with ((bounds (get-bounds)))
      (invalidate-rect bounds)))
  
  
  (method public (invalidate-rect rect)
    (let ((player (get-player)))
      (when player
        (let ((root (get-root)))
          (with ((acquired (acquire~ root self rect)))
            (invalidate-rect~ player acquired true))))))
  
  
  ;; todo: not using acquire is a potentiel scaling bug...
  (method public (invalidate-region region)
    (let ((player (get-player)))
      (when player
        (let* ((root (get-root))
               (delta (- (get-lie) (get-lie~ root))))
          (offset!~ region [h delta] [v delta])
          (invalidate-region~ player region true)))))
  
  
  (method public (redraw-view . rest)
    (bind-keywords ((rect null) (region null)) rest
      (let ((player (get-player)))
        (when player
          (let ((root (get-root)))
            (cond (rect
                   (with ((acquired (acquire~ root self rect)))
                     (redraw-window~ player :rect acquired)))
                  ;; todo: not using acquire is a potentiel scaling bug...
                  (region
                   (let ((delta (- (get-lie) (get-lie~ root))))
                     (offset!~ region [h delta] [v delta])
                     (redraw-window~ player :region region)))
                  (else
                   (with ((bounds (get-bounds))
                          (acquired (acquire~ root self bounds)))
                     (redraw-window~ player :rect acquired)))))))))
  

  (method public (redraw-view-only . rest)
    ;(invalidate-view)
    ;(update-view)
    (unimplemented 'redraw-view-only)
    @convert
    (bind-keywords ((rect null) (region null)) rest
      (let ((player (get-player)))
        (when player
          (let ((hwnd (get-hwnd~ player)))
            (with ((hrgn (CreateRectRgn 0 0 0 0)))
              (GetUpdateRgn hwnd hrgn false)
              (ValidateRect hwnd NULL)
              (redraw-view :rect rect :region region)
              (InvalidateRgn hwnd hrgn false)
              @convert-delete
              (DeleteObject hrgn)))))))
  
  
  (method public (update-view . rest)
    (bind-keywords ((effect null)) rest
      (let ((player (get-player)))
        (when player
          (set-effect effect)
          (update-window~ player)))))

  
  ;;;
  ;;;; Border
  ;;;


  (method public (invalidate-border . rest)
    (bind-keywords ((insets {Rect 1 1 1 1})) rest
      (when (get-finished?)
        (with-closed ((region (border-region :insets insets)))
          (invalidate-region region)))))


  (method public (redraw-border . rest)
    (bind-keywords ((insets {Rect 1 1 1 1})) rest
      (with-closed ((region (border-region :insets insets)))
        (redraw-view :region region))))


  (method public (border-region . rest)
    (bind-keywords ((insets {Rect 1 1 1 1})) rest
      (with ((bounds (get-bounds)))
        (frame-region bounds :insets insets))))


  ;;;
  ;;;; Save
  ;;;

  
  (method public (on-save evt)
    (if (null? surrogate)
        (save)
      (save~ surrogate)))
  
  
  (method public (on-save-as evt)
    (save-as))
  
  
  (method public (on-revert-saved evt)
    (revert-saved))
        
  
  (method public (on-compare-saved evt)
    (compare-saved))


  (method public virtual (save)
    )


  (method public virtual (save-as)
    )
  
  
  (method public virtual (save-to moniker)
    )

  
  (method public virtual (revert-saved)
    )

  
  (method public virtual (compare-saved)
    )


  ;;;
  ;;;; Designer
  ;;;
  
  
  (method (install-surrogate?)
    true)
  
  
  (method (component-surrogate)
    View-Surrogate)
  
  
  (method (addable-class? class)
    (subtype? class View))

  
  (method (get-row-class property)
    (case (field-name property)
      ((cursor-update-handler)   Handler-Row)
      ((mouse-enter-handler)     Handler-Row)
      ((mouse-hover-handler)     Handler-Row)
      ((mouse-leave-handler)     Handler-Row)
      ((mouse-down-handler)      Handler-Row)
      ((mouse-move-handler)      Handler-Row)
      ((mouse-up-handler)        Handler-Row)
      ((drag-move-handler)       Handler-Row)
      ((drag-up-handler)         Handler-Row)
      ((double-click-handler)    Handler-Row)
      ((current-drop-handler)    Handler-Row)
      ((receive-drop-handler)    Handler-Row)
      ((context-menu-handler)    Handler-Row)
      ((lost-capture-handler)    Handler-Row)
      ((key-down-handler)        Handler-Row)
      ((key-up-handler)          Handler-Row)
      ((key-press-handler)       Handler-Row)
      ((arrow-press-handler)     Handler-Row)
      ((escape-press-handler)    Handler-Row)
      ((backspace-press-handler) Handler-Row)
      ((return-press-handler)    Handler-Row)
      ((tab-press-handler)       Handler-Row)
      ((selection-handler)       Handler-Row)
      ((action-handler)          Handler-Row)
      (else (nextmethod property))))

  
  (method (get-row-instance property)
    (case (field-name property)
      ((title)        (new Localized-Row))
      ((position)     (new Point-Row))
      ((size)         (new Dimension-Row))
      ((font)         (new Font-Row))
      ((background)   (new Color-Row))
      ((auto-size?)   (new Boolean-Row))
      ((tooltip-text) (new String-Row))
      ((transparent?) (new Boolean-Row))
      ((offscreen?)   (new Boolean-Row))
      ((tooltip?)     (new Boolean-Row))
      ((draggable?)   (new Boolean-Row))
      ((enabled?)     (new Boolean-Row))
      (else (nextmethod property))))

  
  ;;;
  ;;;; Debugging
  ;;;
  
  
  @convert
  (method public virtual (debug-view pos)
    (set-%~ Development self)
    (set! [%m Development] pos)
    (set! [%r Development] (get-root))
    (set! [%h Development] (get-player))
    (set! [%g Development] (when (is? player View-Host) (get-guest~ player))))


  (method public virtual (describe-view pos)
    (list
     (list "Class" (class-of self))
     (list "Name" (get-name))
     (list "Position" (get-position))
     (list "Size" (get-size))
     (list "Mouse" pos)
     (list "Action" action)
     (list "Action Handler" action-handler)))


  ;; State as in the state that the view and it's associated objects must maintain
  ;; in synch to have a coherent state. State can be a big source of headaches...
  (method public virtual (describe-state pos)
    )
  
  
  (method public (outline-view)
    (let* ((display (new Columns-Display))
           (classes (new Indented-Column display))
           (properties (new Aligned-Column display :border 3)))
      (for-each-descendant
        (function dynamic (view level)
          (when (is? view View)
            (let ((type (type-name (class-of view)))
                  (lie (get-lie~ view))
                  (position (get-position~ view))
                  (size (get-size~ view)))
              (output~ classes type level)
              (output~ properties (format "~{Point {a :width 4 :justify :right} {a :width 4 :justify :right}}   ~{Point {a :width 4 :justify :right} {a :width 4 :justify :right}}   ~{Dimension {a :width 4 :justify :right} {a :width 4 :justify :right}}"
                                          [h lie]
                                          [v lie]
                                          [h position]
                                          [v position]
                                          [width size]
                                          [height size]))
              (newline~ display)))))
      (print-to~ display (list classes properties) :console)
      (format :console "{%}")
      nil))))
