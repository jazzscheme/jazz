;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; Blues Interpreter
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2006
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; NOTES
;; - Doing %Syntax as a class that creates instances of itself makes me realize that maybe syntax
;;   and special forms are not so not alike and could be possibly unified!!! Try macro and special
;;   form versions of different syntaxes... Also, really what we are doing when defining scan_object
;;   is only doing a hand coded version of the automatic code based on the macro bijection!!!
;;   It seems that the cost in memory and performance and ... for macros is very high. Maybe if I have
;;   very clean high level functions for compiling, scanning, ... that special forms will be much more
;;   appealing (and they don't have any of the lexical capture etc crap of macros). Maybe macros are
;;   even an historical bad bad bad decision that is really not clean because it doesn't take into account
;;   many key aspects of extending a language that in Jazz can be elegantly done by having special forms
;;   as classes!!! The ultimate test is clearly going to be trying to implement the Jazz OO system on top
;;   of Scheme using both approaches. I am 99% sure that the special form approach is going to be for a
;;   complex system like that, much simpler to implement (and also much more efficient to interpret *and*
;;   to compile). Ummm the compile part might be where macros shine especially if I can keep their usage
;;   to simple syntactic sugar over a clean OO self reflective layer).
;; - In a fully reflexive system, how can you keep the implementation language (here Jazz
;;   that will become %Jazz) completly distinct from the implemented language when
;;   you have access to class-of, ...?
;; - I see Jazz files starting optionaly with (dialect Jazz) or ... and Jazz beeing
;;   a subclass of Dialect that implements the Jazz language as a subdialect of Scheme
;;   but that could implement any other dialect all based on the common reader types
;; - Naming: abstract parameters for the function parameters and the actual values are arguments
;; - Naming: result of lisp reader -> form and result of code walk -> expr
;; - This is the chance to really think well about the dynamic environment. What does a free reference
;;   mean? If I use a manifest or any other means, what does it mean? etc


;; 1                    -> {Constant 1}
;; (+ 1 2)              -> {Call {Global +} {Constant 1} {Constant 2}}
;; ((function (x) 1) 2) -> 


(library blues.interpreter.Interpreter jazz


(class Interpreter extends Object
  
  
  (method public (evaluate expr runtime)
    (let ((walker (new Walker))
          (code [walker (codewalk expr)]))
      [runtime (execute code)]))))
